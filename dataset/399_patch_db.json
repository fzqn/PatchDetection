[{"CVE_ID":"CVE-2012-4517","CWE_ID":"399","category":"security","commit_id":"c7d28b35d64333c262de3ec972c426423dadccf9","commit_message":"From c7d28b35d64333c262de3ec972c426423dadccf9 Mon Sep 17 00:00:00 2001\nFrom: \"sean.hefty@intel.com\" <sean.hefty@intel.com>\nDate: Tue, 3 Apr 2012 17:20:35 -0700\nSubject: [PATCH] Fix refcnt for multicast destination\n\nmc_dest has a default refcnt of 0.  When a multicast destination is\nreleased, an attempt is made to free it, which can result in the\nibacm service crashing.\n\nSigned-off-by: Sean Hefty <sean.hefty@intel.com>\n---\n src\/acm.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/src\/acm.c b\/src\/acm.c\nindex d47f9d6..818dbcc 100644\n--- a\/src\/acm.c\n+++ b\/src\/acm.c\n@@ -762,6 +762,7 @@ static void acm_process_join_resp(struct acm_ep *ep, struct ib_user_mad *umad)\n \t\t}\n \t}\n \n+\tatomic_set(&dest->refcnt, 1);\n \tdest->state = ACM_READY;\n \tacm_log(1, \"join successful\\n\");\n out:\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-13309","CWE_ID":"399","category":"security","commit_id":"5f21230b657ccd65452dd3d94c5b5401ba691a2d","commit_message":"From 5f21230b657ccd65452dd3d94c5b5401ba691a2d Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 23 Jun 2019 11:46:42 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1616\n\n---\n MagickWand\/mogrify.c   | 3 +++\n MagickWand\/operation.c | 5 ++++-\n 2 files changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/MagickWand\/mogrify.c b\/MagickWand\/mogrify.c\nindex 82b3c0c1c4..150b679230 100644\n--- a\/MagickWand\/mogrify.c\n+++ b\/MagickWand\/mogrify.c\n@@ -7908,6 +7908,8 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n               &distortion,exception);\n             if (difference_image == (Image *) NULL)\n               break;\n+            reconstruct_image=DestroyImage(reconstruct_image);\n+            image=DestroyImage(image);\n             if (*images != (Image *) NULL)\n               *images=DestroyImageList(*images);\n             *images=difference_image;\n@@ -8295,6 +8297,7 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n                    q=GetImageFromList(*images,index-1);\n                    if (q == (Image *) NULL)\n                      {\n+                       p=DestroyImage(p);\n                        (void) ThrowMagickException(exception,GetMagickModule(),\n                          OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                        status=MagickFalse;\ndiff --git a\/MagickWand\/operation.c b\/MagickWand\/operation.c\nindex 9005da5887..b874574346 100644\n--- a\/MagickWand\/operation.c\n+++ b\/MagickWand\/operation.c\n@@ -4171,7 +4171,10 @@ WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n             {\n                index_image=GetImageFromList(_images,index-1);\n                if (index_image == (Image *) NULL)\n-                 CLIWandExceptArgBreak(OptionError,\"NoSuchImage\",option,arg1);\n+                 {\n+                   insert_image=DestroyImage(insert_image);\n+                   CLIWandExceptArgBreak(OptionError,\"NoSuchImage\",option,arg1);\n+                 }\n               InsertImageInList(&index_image,insert_image);\n             }\n           _images=GetFirstImageInList(index_image);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2019-13309","CWE_ID":"399","category":"security","commit_id":"5982632109cad48bc6dab867298fdea4dea57c51","commit_message":"From 5982632109cad48bc6dab867298fdea4dea57c51 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 23 Jun 2019 11:47:36 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1616\n\n---\n wand\/mogrify.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/wand\/mogrify.c b\/wand\/mogrify.c\nindex d641914f7..fca494d2c 100644\n--- a\/wand\/mogrify.c\n+++ b\/wand\/mogrify.c\n@@ -7923,6 +7923,8 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n               channel,metric,&distortion,exception);\n             if (difference_image == (Image *) NULL)\n               break;\n+            reconstruct_image=DestroyImage(reconstruct_image);\n+            image=DestroyImage(image);\n             if (*images != (Image *) NULL)\n               *images=DestroyImageList(*images);\n             *images=difference_image;\n@@ -8265,6 +8267,7 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n                    q=GetImageFromList(*images,index-1);\n                    if (q == (Image *) NULL)\n                      {\n+                       p=DestroyImage(p);\n                        (void) ThrowMagickException(exception,GetMagickModule(),\n                          OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                        status=MagickFalse;\n","owner":"ImageMagick","repo":"ImageMagick6","source":"cve"},{"CVE_ID":"CVE-2014-3687","CWE_ID":"399","category":"security","commit_id":"b69040d8e39f20d5215a03502a8e8b4c6ab78395","commit_message":"From b69040d8e39f20d5215a03502a8e8b4c6ab78395 Mon Sep 17 00:00:00 2001\nFrom: Daniel Borkmann <dborkman@redhat.com>\nDate: Thu, 9 Oct 2014 22:55:32 +0200\nSubject: net: sctp: fix panic on duplicate ASCONF chunks\n\nWhen receiving a e.g. semi-good formed connection scan in the\nform of ...\n\n  -------------- INIT[ASCONF; ASCONF_ACK] ------------->\n  <----------- INIT-ACK[ASCONF; ASCONF_ACK] ------------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n  ---------------- ASCONF_a; ASCONF_b ----------------->\n\n... where ASCONF_a equals ASCONF_b chunk (at least both serials\nneed to be equal), we panic an SCTP server!\n\nThe problem is that good-formed ASCONF chunks that we reply with\nASCONF_ACK chunks are cached per serial. Thus, when we receive a\nsame ASCONF chunk twice (e.g. through a lost ASCONF_ACK), we do\nnot need to process them again on the server side (that was the\nidea, also proposed in the RFC). Instead, we know it was cached\nand we just resend the cached chunk instead. So far, so good.\n\nWhere things get nasty is in SCTP's side effect interpreter, that\nis, sctp_cmd_interpreter():\n\nWhile incoming ASCONF_a (chunk = event_arg) is being marked\n!end_of_packet and !singleton, and we have an association context,\nwe do not flush the outqueue the first time after processing the\nASCONF_ACK singleton chunk via SCTP_CMD_REPLY. Instead, we keep it\nqueued up, although we set local_cork to 1. Commit 2e3216cd54b1\nchanged the precedence, so that as long as we get bundled, incoming\nchunks we try possible bundling on outgoing queue as well. Before\nthis commit, we would just flush the output queue.\n\nNow, while ASCONF_a's ASCONF_ACK sits in the corked outq, we\ncontinue to process the same ASCONF_b chunk from the packet. As\nwe have cached the previous ASCONF_ACK, we find it, grab it and\ndo another SCTP_CMD_REPLY command on it. So, effectively, we rip\nthe chunk->list pointers and requeue the same ASCONF_ACK chunk\nanother time. Since we process ASCONF_b, it's correctly marked\nwith end_of_packet and we enforce an uncork, and thus flush, thus\ncrashing the kernel.\n\nFix it by testing if the ASCONF_ACK is currently pending and if\nthat is the case, do not requeue it. When flushing the output\nqueue we may relink the chunk for preparing an outgoing packet,\nbut eventually unlink it when it's copied into the skb right\nbefore transmission.\n\nJoint work with Vlad Yasevich.\n\nFixes: 2e3216cd54b1 (\"sctp: Follow security requirement of responding with 1 packet\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/sctp\/sctp.h | 5 +++++\n net\/sctp\/associola.c    | 2 ++\n 2 files changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/include\/net\/sctp\/sctp.h b\/include\/net\/sctp\/sctp.h\nindex 9fbd856e6713..856f01cb51dd 100644\n--- a\/include\/net\/sctp\/sctp.h\n+++ b\/include\/net\/sctp\/sctp.h\n@@ -426,6 +426,11 @@ static inline void sctp_assoc_pending_pmtu(struct sock *sk, struct sctp_associat\n \tasoc->pmtu_pending = 0;\n }\n \n+static inline bool sctp_chunk_pending(const struct sctp_chunk *chunk)\n+{\n+\treturn !list_empty(&chunk->list);\n+}\n+\n \/* Walk through a list of TLV parameters.  Don't trust the\n  * individual parameter lengths and instead depend on\n  * the chunk length to indicate when to stop.  Make sure\ndiff --git a\/net\/sctp\/associola.c b\/net\/sctp\/associola.c\nindex a88b8524846e..f791edd64d6c 100644\n--- a\/net\/sctp\/associola.c\n+++ b\/net\/sctp\/associola.c\n@@ -1668,6 +1668,8 @@ struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n \t * ack chunk whose serial number matches that of the request.\n \t *\/\n \tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n+\t\tif (sctp_chunk_pending(ack))\n+\t\t\tcontinue;\n \t\tif (ack->subh.addip_hdr->serial == serial) {\n \t\t\tsctp_chunk_hold(ack);\n \t\t\treturn ack;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-2141","CWE_ID":"399","category":"security","commit_id":"b9e146d8eb3b9ecae5086d373b50fa0c1f3e7f0f","commit_message":"From b9e146d8eb3b9ecae5086d373b50fa0c1f3e7f0f Mon Sep 17 00:00:00 2001\nFrom: Emese Revfy <re.emese@gmail.com>\nDate: Wed, 17 Apr 2013 15:58:36 -0700\nSubject: [PATCH] kernel\/signal.c: stop info leak via the tkill and the tgkill\n syscalls\n\nThis fixes a kernel memory contents leak via the tkill and tgkill syscalls\nfor compat processes.\n\nThis is visible in the siginfo_t->_sifields._rt.si_sigval.sival_ptr field\nwhen handling signals delivered from tkill.\n\nThe place of the infoleak:\n\nint copy_siginfo_to_user32(compat_siginfo_t __user *to, siginfo_t *from)\n{\n        ...\n        put_user_ex(ptr_to_compat(from->si_ptr), &to->si_ptr);\n        ...\n}\n\nSigned-off-by: Emese Revfy <re.emese@gmail.com>\nReviewed-by: PaX Team <pageexec@freemail.hu>\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: \"Eric W. Biederman\" <ebiederm@xmission.com>\nCc: Serge Hallyn <serge.hallyn@canonical.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/signal.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/kernel\/signal.c b\/kernel\/signal.c\nindex dd72567767d96..598dc06be4214 100644\n--- a\/kernel\/signal.c\n+++ b\/kernel\/signal.c\n@@ -2948,7 +2948,7 @@ do_send_specific(pid_t tgid, pid_t pid, int sig, struct siginfo *info)\n \n static int do_tkill(pid_t tgid, pid_t pid, int sig)\n {\n-\tstruct siginfo info;\n+\tstruct siginfo info = {};\n \n \tinfo.si_signo = sig;\n \tinfo.si_errno = 0;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-14174","CWE_ID":"399","category":"security","commit_id":"f68a98a9d385838a1c73ec960a14102949940a64","commit_message":"From f68a98a9d385838a1c73ec960a14102949940a64 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 31 Aug 2017 10:27:46 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/714\n\n---\n coders\/psd.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex 88227678ef..6c026d2b14 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -1688,6 +1688,12 @@ static MagickBooleanType ReadPSDLayersInternal(Image *image,\n                 {\n                   size_t blend_source=ReadBlobLong(image);\n                   size_t blend_dest=ReadBlobLong(image);\n+                  if (EOFBlob(image) != MagickFalse)\n+                    {\n+                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n+                      ThrowBinaryException(CorruptImageError,\n+                        \"InsufficientImageDataInFile\",image->filename);\n+                    }\n                   if (image->debug != MagickFalse)\n                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"        source(%x), dest(%x)\",(unsigned int)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2012-0207","CWE_ID":"399","category":"security","commit_id":"25c413ad0029ea86008234be28aee33456e53e5b","commit_message":"From 25c413ad0029ea86008234be28aee33456e53e5b Mon Sep 17 00:00:00 2001\nFrom: Ben Hutchings <ben@decadent.org.uk>\nDate: Mon, 9 Jan 2012 14:06:46 -0800\nSubject: [PATCH] igmp: Avoid zero delay when receiving odd mixture of IGMP\n queries\n\ncommit a8c1f65c79cbbb2f7da782d4c9d15639a9b94b27 upstream.\n\nCommit 5b7c84066733c5dfb0e4016d939757b38de189e4 ('ipv4: correct IGMP\nbehavior on v3 query during v2-compatibility mode') added yet another\ncase for query parsing, which can result in max_delay = 0.  Substitute\na value of 1, as in the usual v3 case.\n\nReported-by: Simon McVittie <smcv@debian.org>\nReferences: http:\/\/bugs.debian.org\/654876\nSigned-off-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/igmp.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/net\/ipv4\/igmp.c b\/net\/ipv4\/igmp.c\nindex b2ca095cb9dab..c3cc64c6f715e 100644\n--- a\/net\/ipv4\/igmp.c\n+++ b\/net\/ipv4\/igmp.c\n@@ -875,6 +875,8 @@ static void igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb,\n \t\t * to be intended in a v3 query.\n \t\t *\/\n \t\tmax_delay = IGMPV3_MRC(ih3->code)*(HZ\/IGMP_TIMER_SCALE);\n+\t\tif (!max_delay)\n+\t\t\tmax_delay = 1;\t\/* can't mod w\/ 0 *\/\n \t} else { \/* v3 *\/\n \t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))\n \t\t\treturn;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1082","CWE_ID":"399","category":"security","commit_id":"22bacca48a1755f79b7e0f192ddb9fbb7fc6e64e","commit_message":"From 22bacca48a1755f79b7e0f192ddb9fbb7fc6e64e Mon Sep 17 00:00:00 2001\nFrom: Davide Libenzi <davidel@xmailserver.org>\nDate: Fri, 25 Feb 2011 14:44:12 -0800\nSubject: epoll: prevent creating circular epoll structures\n\nIn several places, an epoll fd can call another file's ->f_op->poll()\nmethod with ep->mtx held.  This is in general unsafe, because that other\nfile could itself be an epoll fd that contains the original epoll fd.\n\nThe code defends against this possibility in its own ->poll() method using\nep_call_nested, but there are several other unsafe calls to ->poll\nelsewhere that can be made to deadlock.  For example, the following simple\nprogram causes the call in ep_insert recursively call the original fd's\n->poll, leading to deadlock:\n\n #include <unistd.h>\n #include <sys\/epoll.h>\n\n int main(void) {\n     int e1, e2, p[2];\n     struct epoll_event evt = {\n         .events = EPOLLIN\n     };\n\n     e1 = epoll_create(1);\n     e2 = epoll_create(2);\n     pipe(p);\n\n     epoll_ctl(e2, EPOLL_CTL_ADD, e1, &evt);\n     epoll_ctl(e1, EPOLL_CTL_ADD, p[0], &evt);\n     write(p[1], p, sizeof p);\n     epoll_ctl(e1, EPOLL_CTL_ADD, e2, &evt);\n\n     return 0;\n }\n\nOn insertion, check whether the inserted file is itself a struct epoll,\nand if so, do a recursive walk to detect whether inserting this file would\ncreate a loop of epoll structures, which could lead to deadlock.\n\n[nelhage@ksplice.com: Use epmutex to serialize concurrent inserts]\nSigned-off-by: Davide Libenzi <davidel@xmailserver.org>\nSigned-off-by: Nelson Elhage <nelhage@ksplice.com>\nReported-by: Nelson Elhage <nelhage@ksplice.com>\nTested-by: Nelson Elhage <nelhage@ksplice.com>\nCc: <stable@kernel.org>\t\t[2.6.34+, possibly earlier]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/eventpoll.c | 95 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n 1 file changed, 95 insertions(+)\n\n","diff_code":"diff --git a\/fs\/eventpoll.c b\/fs\/eventpoll.c\nindex 267d0ada4541..4a09af9e9a63 100644\n--- a\/fs\/eventpoll.c\n+++ b\/fs\/eventpoll.c\n@@ -63,6 +63,13 @@\n  * cleanup path and it is also acquired by eventpoll_release_file()\n  * if a file has been pushed inside an epoll set and it is then\n  * close()d without a previous call toepoll_ctl(EPOLL_CTL_DEL).\n+ * It is also acquired when inserting an epoll fd onto another epoll\n+ * fd. We do this so that we walk the epoll tree and ensure that this\n+ * insertion does not create a cycle of epoll file descriptors, which\n+ * could lead to deadlock. We need a global mutex to prevent two\n+ * simultaneous inserts (A into B and B into A) from racing and\n+ * constructing a cycle without either insert observing that it is\n+ * going to.\n  * It is possible to drop the \"ep->mtx\" and to use the global\n  * mutex \"epmutex\" (together with \"ep->lock\") to have it working,\n  * but having \"ep->mtx\" will make the interface more scalable.\n@@ -224,6 +231,9 @@ static long max_user_watches __read_mostly;\n  *\/\n static DEFINE_MUTEX(epmutex);\n \n+\/* Used to check for epoll file descriptor inclusion loops *\/\n+static struct nested_calls poll_loop_ncalls;\n+\n \/* Used for safe wake up implementation *\/\n static struct nested_calls poll_safewake_ncalls;\n \n@@ -1198,6 +1208,62 @@ retry:\n \treturn res;\n }\n \n+\/**\n+ * ep_loop_check_proc - Callback function to be passed to the @ep_call_nested()\n+ *                      API, to verify that adding an epoll file inside another\n+ *                      epoll structure, does not violate the constraints, in\n+ *                      terms of closed loops, or too deep chains (which can\n+ *                      result in excessive stack usage).\n+ *\n+ * @priv: Pointer to the epoll file to be currently checked.\n+ * @cookie: Original cookie for this call. This is the top-of-the-chain epoll\n+ *          data structure pointer.\n+ * @call_nests: Current dept of the @ep_call_nested() call stack.\n+ *\n+ * Returns: Returns zero if adding the epoll @file inside current epoll\n+ *          structure @ep does not violate the constraints, or -1 otherwise.\n+ *\/\n+static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n+{\n+\tint error = 0;\n+\tstruct file *file = priv;\n+\tstruct eventpoll *ep = file->private_data;\n+\tstruct rb_node *rbp;\n+\tstruct epitem *epi;\n+\n+\tmutex_lock(&ep->mtx);\n+\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n+\t\tepi = rb_entry(rbp, struct epitem, rbn);\n+\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n+\t\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n+\t\t\t\t\t       ep_loop_check_proc, epi->ffd.file,\n+\t\t\t\t\t       epi->ffd.file->private_data, current);\n+\t\t\tif (error != 0)\n+\t\t\t\tbreak;\n+\t\t}\n+\t}\n+\tmutex_unlock(&ep->mtx);\n+\n+\treturn error;\n+}\n+\n+\/**\n+ * ep_loop_check - Performs a check to verify that adding an epoll file (@file)\n+ *                 another epoll file (represented by @ep) does not create\n+ *                 closed loops or too deep chains.\n+ *\n+ * @ep: Pointer to the epoll private data structure.\n+ * @file: Pointer to the epoll file to be checked.\n+ *\n+ * Returns: Returns zero if adding the epoll @file inside current epoll\n+ *          structure @ep does not violate the constraints, or -1 otherwise.\n+ *\/\n+static int ep_loop_check(struct eventpoll *ep, struct file *file)\n+{\n+\treturn ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n+\t\t\t      ep_loop_check_proc, file, ep, current);\n+}\n+\n \/*\n  * Open an eventpoll file descriptor.\n  *\/\n@@ -1246,6 +1312,7 @@ SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n \t\tstruct epoll_event __user *, event)\n {\n \tint error;\n+\tint did_lock_epmutex = 0;\n \tstruct file *file, *tfile;\n \tstruct eventpoll *ep;\n \tstruct epitem *epi;\n@@ -1287,6 +1354,25 @@ SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n \t *\/\n \tep = file->private_data;\n \n+\t\/*\n+\t * When we insert an epoll file descriptor, inside another epoll file\n+\t * descriptor, there is the change of creating closed loops, which are\n+\t * better be handled here, than in more critical paths.\n+\t *\n+\t * We hold epmutex across the loop check and the insert in this case, in\n+\t * order to prevent two separate inserts from racing and each doing the\n+\t * insert \"at the same time\" such that ep_loop_check passes on both\n+\t * before either one does the insert, thereby creating a cycle.\n+\t *\/\n+\tif (unlikely(is_file_epoll(tfile) && op == EPOLL_CTL_ADD)) {\n+\t\tmutex_lock(&epmutex);\n+\t\tdid_lock_epmutex = 1;\n+\t\terror = -ELOOP;\n+\t\tif (ep_loop_check(ep, tfile) != 0)\n+\t\t\tgoto error_tgt_fput;\n+\t}\n+\n+\n \tmutex_lock(&ep->mtx);\n \n \t\/*\n@@ -1322,6 +1408,9 @@ SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n \tmutex_unlock(&ep->mtx);\n \n error_tgt_fput:\n+\tif (unlikely(did_lock_epmutex))\n+\t\tmutex_unlock(&epmutex);\n+\n \tfput(tfile);\n error_fput:\n \tfput(file);\n@@ -1441,6 +1530,12 @@ static int __init eventpoll_init(void)\n \t\tEP_ITEM_COST;\n \tBUG_ON(max_user_watches < 0);\n \n+\t\/*\n+\t * Initialize the structure used to perform epoll file descriptor\n+\t * inclusion loops checks.\n+\t *\/\n+\tep_nested_calls_init(&poll_loop_ncalls);\n+\n \t\/* Initialize the structure used to perform safe poll wait head wake ups *\/\n \tep_nested_calls_init(&poll_safewake_ncalls);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-9106","CWE_ID":"399","category":"security","commit_id":"fdfcc9aeea1492f4b819a24c94dfb678145b1bf9","commit_message":"From fdfcc9aeea1492f4b819a24c94dfb678145b1bf9 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Mon, 17 Oct 2016 14:13:58 +0200\nSubject: [PATCH] 9pfs: fix memory leak in v9fs_write\n\nIf an error occurs when marshalling the transfer length to the guest, the\nv9fs_write() function doesn't free an IO vector, thus leading to a memory\nleak. This patch fixes the issue.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nReviewed-by: Greg Kurz <groug@kaod.org>\n[groug, rephrased the changelog]\nSigned-off-by: Greg Kurz <groug@kaod.org>\n---\n hw\/9pfs\/9p.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/9pfs\/9p.c b\/hw\/9pfs\/9p.c\nindex d43a552..e88cf25 100644\n--- a\/hw\/9pfs\/9p.c\n+++ b\/hw\/9pfs\/9p.c\n@@ -2090,7 +2090,7 @@ static void coroutine_fn v9fs_write(void *opaque)\n     offset = 7;\n     err = pdu_marshal(pdu, offset, \"d\", total);\n     if (err < 0) {\n-        goto out;\n+        goto out_qiov;\n     }\n     err += offset;\n     trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-1086","CWE_ID":"399","category":"security","commit_id":"29e1fa3565a7951cc415c634eb2b78dbdbee151d","commit_message":"From 29e1fa3565a7951cc415c634eb2b78dbdbee151d Mon Sep 17 00:00:00 2001\nFrom: Ang Way Chuang <wcang79@gmail.com>\nDate: Thu, 25 Feb 2010 09:45:03 +0800\nSubject: dvb-core: Fix DoS bug in ULE decapsulation code that can be triggered\n by an invalid Payload Pointer\n\nULE (Unidirectional Lightweight Encapsulation RFC 4326) decapsulation\nhas a bug that causes endless loop when Payload Pointer of MPEG2-TS\nframe is 182 or 183.  Anyone who sends malicious MPEG2-TS frame will\ncause the receiver of ULE SNDU to go into endless loop.\n\nThis patch was generated and tested against linux-2.6.32.9 and should\napply cleanly to linux-2.6.33 as well because there was only one typo\nfix to dvb_net.c since v2.6.32.\n\nThis bug was brought to you by modern day Santa Claus who decided to\nshower the satellite dish at Keio University with heavy snow causing\nhuge burst of errors.  We, receiver end, received Santa Claus's gift in\nthe form of kernel bug.\n\nCare has been taken not to introduce more bug by fixing this bug, but\nplease scrutinize the code for I always produces buggy code.\n\nSigned-off-by: Ang Way Chuang <wcang79@gmail.com>\nAcked-by: Mauro Carvalho Chehab <mchehab@redhat.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/media\/dvb\/dvb-core\/dvb_net.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/drivers\/media\/dvb\/dvb-core\/dvb_net.c b\/drivers\/media\/dvb\/dvb-core\/dvb_net.c\nindex 8b8558fcb042..b11533f76195 100644\n--- a\/drivers\/media\/dvb\/dvb-core\/dvb_net.c\n+++ b\/drivers\/media\/dvb\/dvb-core\/dvb_net.c\n@@ -504,6 +504,7 @@ static void dvb_net_ule( struct net_device *dev, const u8 *buf, size_t buf_len )\n \t\t\t\t       \"bytes left in TS.  Resyncing.\\n\", ts_remain);\n \t\t\t\tpriv->ule_sndu_len = 0;\n \t\t\t\tpriv->need_pusi = 1;\n+\t\t\t\tts += TS_SZ;\n \t\t\t\tcontinue;\n \t\t\t}\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5552","CWE_ID":"399","category":"security","commit_id":"33243031dad02d161225ba99d782616da133f689","commit_message":"From 33243031dad02d161225ba99d782616da133f689 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Thu, 29 Dec 2016 03:11:26 -0500\nSubject: [PATCH] virtio-gpu-3d: fix memory leak in resource attach backing\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nIf the virgl_renderer_resource_attach_iov function fails the\n'res_iovs' will be leaked. Add check of the return value to\nfree the 'res_iovs' when failing.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nReviewed-by: Marc-Andr\u00c3\u00a9 Lureau <marcandre.lureau@redhat.com>\nMessage-id: 1482999086-59795-1-git-send-email-liq3ea@gmail.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/display\/virtio-gpu-3d.c | 7 +++++--\n 1 file changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/hw\/display\/virtio-gpu-3d.c b\/hw\/display\/virtio-gpu-3d.c\nindex e29f099..b13ced3 100644\n--- a\/hw\/display\/virtio-gpu-3d.c\n+++ b\/hw\/display\/virtio-gpu-3d.c\n@@ -291,8 +291,11 @@ static void virgl_resource_attach_backing(VirtIOGPU *g,\n         return;\n     }\n \n-    virgl_renderer_resource_attach_iov(att_rb.resource_id,\n-                                       res_iovs, att_rb.nr_entries);\n+    ret = virgl_renderer_resource_attach_iov(att_rb.resource_id,\n+                                             res_iovs, att_rb.nr_entries);\n+\n+    if (ret != 0)\n+        virtio_gpu_cleanup_mapping_iov(res_iovs, att_rb.nr_entries);\n }\n \n static void virgl_resource_detach_backing(VirtIOGPU *g,\n-- \n1.8.3.1\n\n","owner":"qemu","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2013-5634","CWE_ID":"399","category":"security","commit_id":"e8180dcaa8470ceca21109f143876fdcd9fe050a","commit_message":"From e8180dcaa8470ceca21109f143876fdcd9fe050a Mon Sep 17 00:00:00 2001\nFrom: Andre Przywara <andre.przywara@linaro.org>\nDate: Thu, 9 May 2013 00:28:06 +0200\nSubject: [PATCH] ARM: KVM: prevent NULL pointer dereferences with KVM VCPU\n ioctl\n\nSome ARM KVM VCPU ioctls require the vCPU to be properly initialized\nwith the KVM_ARM_VCPU_INIT ioctl before being used with further\nrequests. KVM_RUN checks whether this initialization has been\ndone, but other ioctls do not.\nNamely KVM_GET_REG_LIST will dereference an array with index -1\nwithout initialization and thus leads to a kernel oops.\nFix this by adding checks before executing the ioctl handlers.\n\n [ Removed superflous comment from static function - Christoffer ]\n\nChanges from v1:\n * moved check into a static function with a meaningful name\n\nSigned-off-by: Andre Przywara <andre.przywara@linaro.org>\nSigned-off-by: Christoffer Dall <cdall@cs.columbia.edu>\n---\n arch\/arm\/kvm\/arm.c | 15 +++++++++++++--\n 1 file changed, 13 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm\/kvm\/arm.c b\/arch\/arm\/kvm\/arm.c\nindex 37d216d814cdd..ef1703b9587b0 100644\n--- a\/arch\/arm\/kvm\/arm.c\n+++ b\/arch\/arm\/kvm\/arm.c\n@@ -492,6 +492,11 @@ static void vcpu_pause(struct kvm_vcpu *vcpu)\n \twait_event_interruptible(*wq, !vcpu->arch.pause);\n }\n \n+static int kvm_vcpu_initialized(struct kvm_vcpu *vcpu)\n+{\n+\treturn vcpu->arch.target >= 0;\n+}\n+\n \/**\n  * kvm_arch_vcpu_ioctl_run - the main VCPU run function to execute guest code\n  * @vcpu:\tThe VCPU pointer\n@@ -508,8 +513,7 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)\n \tint ret;\n \tsigset_t sigsaved;\n \n-\t\/* Make sure they initialize the vcpu with KVM_ARM_VCPU_INIT *\/\n-\tif (unlikely(vcpu->arch.target < 0))\n+\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n \t\treturn -ENOEXEC;\n \n \tret = kvm_vcpu_first_run_init(vcpu);\n@@ -710,6 +714,10 @@ long kvm_arch_vcpu_ioctl(struct file *filp,\n \tcase KVM_SET_ONE_REG:\n \tcase KVM_GET_ONE_REG: {\n \t\tstruct kvm_one_reg reg;\n+\n+\t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n+\t\t\treturn -ENOEXEC;\n+\n \t\tif (copy_from_user(&reg, argp, sizeof(reg)))\n \t\t\treturn -EFAULT;\n \t\tif (ioctl == KVM_SET_ONE_REG)\n@@ -722,6 +730,9 @@ long kvm_arch_vcpu_ioctl(struct file *filp,\n \t\tstruct kvm_reg_list reg_list;\n \t\tunsigned n;\n \n+\t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n+\t\t\treturn -ENOEXEC;\n+\n \t\tif (copy_from_user(&reg_list, user_list, sizeof(reg_list)))\n \t\t\treturn -EFAULT;\n \t\tn = reg_list.n;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-6386","CWE_ID":"399","category":"security","commit_id":"737c3350850ca4dbc5633b3bdb4118176ce59920","commit_message":"From 737c3350850ca4dbc5633b3bdb4118176ce59920 Mon Sep 17 00:00:00 2001\nFrom: Dave Airlie <airlied@redhat.com>\nDate: Tue, 28 Feb 2017 14:52:09 +1000\nSubject: renderer: fix memory leak in vertex elements state create\n\nReported-by: Li Qiang\nFree the vertex array in error path.\nThis was introduced by this commit:\nrenderer: fix heap overflow in vertex elements state create.\n\nI rewrote the code to not require the allocation in the first\nplace if we have an error, seems nicer.\n\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n src\/vrend_renderer.c | 9 +++++----\n 1 file changed, 5 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/src\/vrend_renderer.c b\/src\/vrend_renderer.c\nindex 1bca7ad..e5d9f5c 100644\n--- a\/src\/vrend_renderer.c\n+++ b\/src\/vrend_renderer.c\n@@ -1648,18 +1648,19 @@ int vrend_create_vertex_elements_state(struct vrend_context *ctx,\n                                        unsigned num_elements,\n                                        const struct pipe_vertex_element *elements)\n {\n-   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);\n+   struct vrend_vertex_element_array *v;\n    const struct util_format_description *desc;\n    GLenum type;\n    int i;\n    uint32_t ret_handle;\n \n-   if (!v)\n-      return ENOMEM;\n-\n    if (num_elements > PIPE_MAX_ATTRIBS)\n       return EINVAL;\n \n+   v = CALLOC_STRUCT(vrend_vertex_element_array);\n+   if (!v)\n+      return ENOMEM;\n+\n    v->count = num_elements;\n    for (i = 0; i < num_elements; i++) {\n       memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-16645","CWE_ID":"399","category":"security","commit_id":"ecb31dbad39ccdc65868d5d2a37f0f0521250832","commit_message":"From ecb31dbad39ccdc65868d5d2a37f0f0521250832 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 27 Aug 2018 15:24:10 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1268\n\n---\n coders\/bmp.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/coders\/bmp.c b\/coders\/bmp.c\nindex 8461e1a494..e20085fefb 100644\n--- a\/coders\/bmp.c\n+++ b\/coders\/bmp.c\n@@ -661,6 +661,8 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         bmp_info.x_pixels=ReadBlobLSBLong(image);\n         bmp_info.y_pixels=ReadBlobLSBLong(image);\n         bmp_info.number_colors=ReadBlobLSBLong(image);\n+        if (bmp_info.number_colors > GetBlobSize(image))\n+          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         bmp_info.colors_important=ReadBlobLSBLong(image);\n         if (image->debug != MagickFalse)\n           {\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-4592","CWE_ID":"399","category":"security","commit_id":"12d6e7538e2d418c08f082b1b44ffa5fb7270ed8","commit_message":"From 12d6e7538e2d418c08f082b1b44ffa5fb7270ed8 Mon Sep 17 00:00:00 2001\nFrom: Marcelo Tosatti <mtosatti@redhat.com>\nDate: Fri, 24 Aug 2012 15:54:58 -0300\nSubject: KVM: perform an invalid memslot step for gpa base change\n\nPPC must flush all translations before the new memory slot\nis visible.\n\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>\n---\n virt\/kvm\/kvm_main.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/virt\/kvm\/kvm_main.c b\/virt\/kvm\/kvm_main.c\nindex a4bf05be5fea..f41ea1262d51 100644\n--- a\/virt\/kvm\/kvm_main.c\n+++ b\/virt\/kvm\/kvm_main.c\n@@ -791,7 +791,7 @@ int __kvm_set_memory_region(struct kvm *kvm,\n \t\t\/* destroy any largepage mappings for dirty tracking *\/\n \t}\n \n-\tif (!npages) {\n+\tif (!npages || base_gfn != old.base_gfn) {\n \t\tstruct kvm_memory_slot *slot;\n \n \t\tr = -ENOMEM;\n@@ -807,8 +807,8 @@ int __kvm_set_memory_region(struct kvm *kvm,\n \t\told_memslots = kvm->memslots;\n \t\trcu_assign_pointer(kvm->memslots, slots);\n \t\tsynchronize_srcu_expedited(&kvm->srcu);\n-\t\t\/* From this point no new shadow pages pointing to a deleted\n-\t\t * memslot will be created.\n+\t\t\/* From this point no new shadow pages pointing to a deleted,\n+\t\t * or moved, memslot will be created.\n \t\t *\n \t\t * validation of sp->gfn happens in:\n \t\t * \t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-14171","CWE_ID":"399","category":"security","commit_id":"c24bcb553650b91e9eff15ef6e54ca73de2453b7","commit_message":"From c24bcb553650b91e9eff15ef6e54ca73de2453b7 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?=E5=AD=99=E6=B5=A9=28=E6=99=93=E9=BB=91=29?=\n <tony.sh@alibaba-inc.com>\nDate: Tue, 29 Aug 2017 23:59:21 +0200\nSubject: [PATCH] avformat\/nsvdec: Fix DoS due to lack of eof check in\n nsvs_file_offset loop.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nFixes: 20170829.nsv\n\nCo-Author: \u5f20\u6d2a\u4eae(\u671b\u521d)\" <wangchu.zhl@alibaba-inc.com>\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/nsvdec.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavformat\/nsvdec.c b\/libavformat\/nsvdec.c\nindex c6ddb67bbdd..d8ce656817c 100644\n--- a\/libavformat\/nsvdec.c\n+++ b\/libavformat\/nsvdec.c\n@@ -335,8 +335,11 @@ static int nsv_parse_NSVf_header(AVFormatContext *s)\n         if (!nsv->nsvs_file_offset)\n             return AVERROR(ENOMEM);\n \n-        for(i=0;i<table_entries_used;i++)\n+        for(i=0;i<table_entries_used;i++) {\n+            if (avio_feof(pb))\n+                return AVERROR_INVALIDDATA;\n             nsv->nsvs_file_offset[i] = avio_rl32(pb) + size;\n+        }\n \n         if(table_entries > table_entries_used &&\n            avio_rl32(pb) == MKTAG('T','O','C','2')) {\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2016-4008","CWE_ID":"399","category":"security","commit_id":"f435825c0f527a8e52e6ffbc3ad0bc60531d537e","commit_message":"From f435825c0f527a8e52e6ffbc3ad0bc60531d537e Mon Sep 17 00:00:00 2001\nFrom: Nikos Mavrogiannopoulos <nmav@redhat.com>\nDate: Mon, 4 Apr 2016 15:06:21 +0200\nSubject: [PATCH] _asn1_extract_der_octet: catch invalid input cases early\n\nThat is, check the calculated lengths for validity prior\nto entering a loop. This avoids an infinite recursion.\nReported by Pascal Cuoq.\n---\n lib\/decoding.c | 9 ++++++++-\n 1 file changed, 8 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/lib\/decoding.c b\/lib\/decoding.c\nindex 4fa045c..6fd60d0 100644\n--- a\/lib\/decoding.c\n+++ b\/lib\/decoding.c\n@@ -767,10 +767,17 @@ _asn1_extract_der_octet (asn1_node node, const unsigned char *der,\n   DECR_LEN(der_len, len3);\n \n   if (len2 == -1)\n-    counter_end = der_len - 2;\n+    {\n+      if (der_len < 2)\n+        return ASN1_DER_ERROR;\n+      counter_end = der_len - 2;\n+    }\n   else\n     counter_end = der_len;\n \n+  if (counter_end < counter)\n+    return ASN1_DER_ERROR;\n+\n   while (counter < counter_end)\n     {\n       DECR_LEN(der_len, 1);\n-- \n1.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3538","CWE_ID":"399","category":"security","commit_id":"74cafd7de9ec99a14f4480927580e501c8f852c3","commit_message":"From 74cafd7de9ec99a14f4480927580e501c8f852c3 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Fri, 30 May 2014 16:47:44 +0000\nSubject: [PATCH] If requested, limit search length.\n\n---\n src\/softmagic.c | 18 +++++++++++++-----\n 1 file changed, 13 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/softmagic.c b\/src\/softmagic.c\nindex 620d6eafa..3e631efe8 100644\n--- a\/src\/softmagic.c\n+++ b\/src\/softmagic.c\n@@ -32,7 +32,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: softmagic.c,v 1.187 2014\/05\/13 16:42:17 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: softmagic.c,v 1.188 2014\/05\/14 23:15:42 christos Exp $\")\n #endif\t\/* lint *\/\n \n #include \"magic.h\"\n@@ -1929,15 +1929,23 @@ magiccheck(struct magic_set *ms, struct magic *m)\n \t\t\tfile_regerror(&rx, rc, ms);\n \t\t\tv = (uint64_t)-1;\n \t\t} else {\n+#ifndef REG_STARTEND\n+\t\t\tchar c;\n+#endif\n \t\t\tregmatch_t pmatch[1];\n+\t\t\tsize_t slen = ms->search.s_len;\n+\t\t\t\/* Limit by offset if requested *\/\n+\t\t\tif (m->str_range > 0)\n+\t\t\t\tslen = MIN(slen, m->str_range);\n #ifndef REG_STARTEND\n #define\tREG_STARTEND\t0\n-\t\t\tsize_t l = ms->search.s_len - 1;\n-\t\t\tchar c = ms->search.s[l];\n-\t\t\t((char *)(intptr_t)ms->search.s)[l] = '\\0';\n+\t\t\tif (slen != 0)\n+\t\t\t\tslen--;\n+\t\t\tc = ms->search.s[slen];\n+\t\t\t((char *)(intptr_t)ms->search.s)[slen] = '\\0';\n #else\n \t\t\tpmatch[0].rm_so = 0;\n-\t\t\tpmatch[0].rm_eo = ms->search.s_len;\n+\t\t\tpmatch[0].rm_eo = slen;\n #endif\n \t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n \t\t\t    1, pmatch, REG_STARTEND);\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2008-1514","CWE_ID":"399","category":"security","commit_id":"3d6e48f43340343d97839eadb1ab7b6a3ea98797","commit_message":"From 3d6e48f43340343d97839eadb1ab7b6a3ea98797 Mon Sep 17 00:00:00 2001\nFrom: Jarod Wilson <jwilson@redhat.com>\nDate: Tue, 9 Sep 2008 12:38:56 +0200\nSubject: [S390] CVE-2008-1514: prevent ptrace padding area read\/write in\n 31-bit mode\n\nWhen running a 31-bit ptrace, on either an s390 or s390x kernel,\nreads and writes into a padding area in struct user_regs_struct32\nwill result in a kernel panic.\n\nThis is also known as CVE-2008-1514.\n\nTest case available here:\nhttp:\/\/sources.redhat.com\/cgi-bin\/cvsweb.cgi\/~checkout~\/tests\/ptrace-tests\/tests\/user-area-padding.c?cvsroot=systemtap\n\nSteps to reproduce:\n1) wget the above\n2) gcc -o user-area-padding-31bit user-area-padding.c -Wall -ggdb2 -D_GNU_SOURCE -m31\n3) .\/user-area-padding-31bit\n<panic>\n\nTest status\n-----------\nWithout patch, both s390 and s390x kernels panic. With patch, the test case,\nas well as the gdb testsuite, pass without incident, padding area reads\nreturning zero, writes ignored.\n\nNb: original version returned -EINVAL on write attempts, which broke the\ngdb test and made the test case slightly unhappy, Jan Kratochvil suggested\nthe change to return 0 on write attempts.\n\nSigned-off-by: Jarod Wilson <jarod@redhat.com>\nTested-by: Jan Kratochvil <jan.kratochvil@redhat.com>\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>\n---\n arch\/s390\/kernel\/compat_ptrace.h |  1 +\n arch\/s390\/kernel\/ptrace.c        | 28 ++++++++++++++++++++++++++++\n 2 files changed, 29 insertions(+)\n\n","diff_code":"diff --git a\/arch\/s390\/kernel\/compat_ptrace.h b\/arch\/s390\/kernel\/compat_ptrace.h\nindex cde81fa64f89..a2be3a978d5c 100644\n--- a\/arch\/s390\/kernel\/compat_ptrace.h\n+++ b\/arch\/s390\/kernel\/compat_ptrace.h\n@@ -42,6 +42,7 @@ struct user_regs_struct32\n \tu32 gprs[NUM_GPRS];\n \tu32 acrs[NUM_ACRS];\n \tu32 orig_gpr2;\n+\t\/* nb: there's a 4-byte hole here *\/\n \ts390_fp_regs fp_regs;\n \t\/*\n \t * These per registers are in here so that gdb can modify them\ndiff --git a\/arch\/s390\/kernel\/ptrace.c b\/arch\/s390\/kernel\/ptrace.c\nindex 2815bfe348a6..c8b08289eb87 100644\n--- a\/arch\/s390\/kernel\/ptrace.c\n+++ b\/arch\/s390\/kernel\/ptrace.c\n@@ -170,6 +170,13 @@ static unsigned long __peek_user(struct task_struct *child, addr_t addr)\n \t\t *\/\n \t\ttmp = (addr_t) task_pt_regs(child)->orig_gpr2;\n \n+\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n+\t\t\/*\n+\t\t * prevent reads of padding hole between\n+\t\t * orig_gpr2 and fp_regs on s390.\n+\t\t *\/\n+\t\ttmp = 0;\n+\n \t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n \t\t\/* \n \t\t * floating point regs. are stored in the thread structure\n@@ -270,6 +277,13 @@ static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n \t\t *\/\n \t\ttask_pt_regs(child)->orig_gpr2 = data;\n \n+\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n+\t\t\/*\n+\t\t * prevent writes of padding hole between\n+\t\t * orig_gpr2 and fp_regs on s390.\n+\t\t *\/\n+\t\treturn 0;\n+\n \t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n \t\t\/*\n \t\t * floating point regs. are stored in the thread structure\n@@ -428,6 +442,13 @@ static u32 __peek_user_compat(struct task_struct *child, addr_t addr)\n \t\t *\/\n \t\ttmp = *(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4);\n \n+\t} else if (addr < (addr_t) &dummy32->regs.fp_regs) {\n+\t\t\/*\n+\t\t * prevent reads of padding hole between\n+\t\t * orig_gpr2 and fp_regs on s390.\n+\t\t *\/\n+\t\ttmp = 0;\n+\n \t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n \t\t\/*\n \t\t * floating point regs. are stored in the thread structure \n@@ -514,6 +535,13 @@ static int __poke_user_compat(struct task_struct *child,\n \t\t *\/\n \t\t*(__u32*)((addr_t) &task_pt_regs(child)->orig_gpr2 + 4) = tmp;\n \n+\t} else if (addr < (addr_t) &dummy32->regs.fp_regs) {\n+\t\t\/*\n+\t\t * prevent writess of padding hole between\n+\t\t * orig_gpr2 and fp_regs on s390.\n+\t\t *\/\n+\t\treturn 0;\n+\n \t} else if (addr < (addr_t) (&dummy32->regs.fp_regs + 1)) {\n \t\t\/*\n \t\t * floating point regs. are stored in the thread structure \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2012-3510","CWE_ID":"399","category":"security","commit_id":"f0ec1aaf54caddd21c259aea8b2ecfbde4ee4fb9","commit_message":"From f0ec1aaf54caddd21c259aea8b2ecfbde4ee4fb9 Mon Sep 17 00:00:00 2001\nFrom: Oleg Nesterov <oleg@tv-sign.ru>\nDate: Sun, 29 Oct 2006 22:46:43 -0800\nSubject: [PATCH] [PATCH] xacct_add_tsk: fix pure theoretical ->mm\n use-after-free\n\nParanoid fix. The task can free its ->mm after the 'if (p->mm)' check.\n\nSigned-off-by: Oleg Nesterov <oleg@tv-sign.ru>\nCc: Shailabh Nagar <nagar@watson.ibm.com>\nCc: Balbir Singh <balbir@in.ibm.com>\nCc: Jay Lan <jlan@sgi.com>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>\n---\n kernel\/tsacct.c | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/tsacct.c b\/kernel\/tsacct.c\nindex 65a5036a3d951..96f77013d3f03 100644\n--- a\/kernel\/tsacct.c\n+++ b\/kernel\/tsacct.c\n@@ -80,13 +80,17 @@ void bacct_add_tsk(struct taskstats *stats, struct task_struct *tsk)\n  *\/\n void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n {\n+\tstruct mm_struct *mm;\n+\n \t\/* convert pages-jiffies to Mbyte-usec *\/\n \tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE \/ MB;\n \tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE \/ MB;\n-\tif (p->mm) {\n+\tmm = get_task_mm(p);\n+\tif (mm) {\n \t\t\/* adjust to KB unit *\/\n-\t\tstats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE \/ KB;\n-\t\tstats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE \/ KB;\n+\t\tstats->hiwater_rss   = mm->hiwater_rss * PAGE_SIZE \/ KB;\n+\t\tstats->hiwater_vm    = mm->hiwater_vm * PAGE_SIZE \/ KB;\n+\t\tmmput(mm);\n \t}\n \tstats->read_char\t= p->rchar;\n \tstats->write_char\t= p->wchar;\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-4138","CWE_ID":"399","category":"security","commit_id":"8c0c0cc2d9f4c523fde04bdfe41e4380dec8ee54","commit_message":"From 8c0c0cc2d9f4c523fde04bdfe41e4380dec8ee54 Mon Sep 17 00:00:00 2001\nFrom: Jay Fenlason <fenlason@redhat.com>\nDate: Fri, 11 Dec 2009 14:23:58 -0500\nSubject: firewire: ohci: handle receive packets with a data length of zero\n\nQueueing to receive an ISO packet with a payload length of zero\nsilently does nothing in dualbuffer mode, and crashes the kernel in\npacket-per-buffer mode.  Return an error in dualbuffer mode, because\nthe DMA controller won't let us do what we want, and work correctly in\npacket-per-buffer mode.\n\nSigned-off-by: Jay Fenlason <fenlason@redhat.com>\nSigned-off-by: Stefan Richter <stefanr@s5r6.in-berlin.de>\nCc: stable@kernel.org\n---\n drivers\/firewire\/ohci.c | 12 ++++++++++--\n 1 file changed, 10 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/firewire\/ohci.c b\/drivers\/firewire\/ohci.c\nindex a71477541dc7..553c74e1e4e3 100644\n--- a\/drivers\/firewire\/ohci.c\n+++ b\/drivers\/firewire\/ohci.c\n@@ -2189,6 +2189,13 @@ static int ohci_queue_iso_receive_dualbuffer(struct fw_iso_context *base,\n \tpage     = payload >> PAGE_SHIFT;\n \toffset   = payload & ~PAGE_MASK;\n \trest     = p->payload_length;\n+\t\/*\n+\t * The controllers I've tested have not worked correctly when\n+\t * second_req_count is zero.  Rather than do something we know won't\n+\t * work, return an error\n+\t *\/\n+\tif (rest == 0)\n+\t\treturn -EINVAL;\n \n \t\/* FIXME: make packet-per-buffer\/dual-buffer a context option *\/\n \twhile (rest > 0) {\n@@ -2242,7 +2249,7 @@ static int ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,\n \t\t\t\t\tunsigned long payload)\n {\n \tstruct iso_context *ctx = container_of(base, struct iso_context, base);\n-\tstruct descriptor *d = NULL, *pd = NULL;\n+\tstruct descriptor *d, *pd;\n \tstruct fw_iso_packet *p = packet;\n \tdma_addr_t d_bus, page_bus;\n \tu32 z, header_z, rest;\n@@ -2280,8 +2287,9 @@ static int ohci_queue_iso_receive_packet_per_buffer(struct fw_iso_context *base,\n \t\td->data_address = cpu_to_le32(d_bus + (z * sizeof(*d)));\n \n \t\trest = payload_per_buffer;\n+\t\tpd = d;\n \t\tfor (j = 1; j < z; j++) {\n-\t\t\tpd = d + j;\n+\t\t\tpd++;\n \t\t\tpd->control = cpu_to_le16(DESCRIPTOR_STATUS |\n \t\t\t\t\t\t  DESCRIPTOR_INPUT_MORE);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8877","CWE_ID":"399","category":"security","commit_id":"4751b606fa38edc456d627140898a7ec679fcc24","commit_message":"From 4751b606fa38edc456d627140898a7ec679fcc24 Mon Sep 17 00:00:00 2001\nFrom: Vladimir Mitrovic <vladimir.x.mitrovic@gmail.com>\nDate: Wed, 5 Aug 2015 03:01:06 +0200\nSubject: [PATCH] gdImageScaleTwoPass memory leak fix\n\nFixing memory leak in gdImageScaleTwoPass, as reported by @cmb69 and\nconfirmed by @vapier.  This bug actually bit me in production and I'm\nvery thankful that it was reported with an easy fix.\n\nFixes #173.\n---\n src\/gd_interpolation.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/gd_interpolation.c b\/src\/gd_interpolation.c\nindex fcc11e6e..f00c9462 100644\n--- a\/src\/gd_interpolation.c\n+++ b\/src\/gd_interpolation.c\n@@ -1087,7 +1087,7 @@ gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n     }\/* if *\/\n \n     if (src != tmp_im) {\n-        gdFree(tmp_im);\n+        gdImageDestroy(tmp_im);\n     }\/* if *\/\n \n \treturn dst;\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2016-7539","CWE_ID":"399","category":"security","commit_id":"4e81ce8b07219c69a9aeccb0f7f7b927ca6db74c","commit_message":"From 4e81ce8b07219c69a9aeccb0f7f7b927ca6db74c Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 7 Jan 2016 09:08:49 -0500\nSubject: [PATCH] \n http:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=2&t=28946\n\n---\n magick\/cache.c | 17 +++--------------\n 1 file changed, 3 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/magick\/cache.c b\/magick\/cache.c\nindex 3eab0b0f4a..0e4e482f8d 100644\n--- a\/magick\/cache.c\n+++ b\/magick\/cache.c\n@@ -3371,19 +3371,6 @@ static MagickBooleanType MaskPixelCacheNexus(Image *image,NexusInfo *nexus_info,\n %\n *\/\n \n-static inline void AllocatePixelCachePixels(CacheInfo *cache_info)\n-{\n-  cache_info->mapped=MagickFalse;\n-  cache_info->pixels=(PixelPacket *) MagickAssumeAligned(\n-    AcquireAlignedMemory(1,(size_t) cache_info->length));\n-  if (cache_info->pixels == (PixelPacket *) NULL)\n-    {\n-      cache_info->mapped=MagickTrue;\n-      cache_info->pixels=(PixelPacket *) MapBlob(-1,IOMode,0,(size_t)\n-        cache_info->length);\n-    }\n-}\n-\n #if defined(__cplusplus) || defined(c_plusplus)\n extern \"C\" {\n #endif\n@@ -3603,7 +3590,9 @@ static MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n       if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||\n           (cache_info->type == MemoryCache))\n         {\n-          AllocatePixelCachePixels(cache_info);\n+          cache_info->mapped=MagickFalse;\n+          cache_info->pixels=(PixelPacket *) MagickAssumeAligned(\n+            AcquireAlignedMemory(1,(size_t) cache_info->length));\n           if (cache_info->pixels == (PixelPacket *) NULL)\n             cache_info->pixels=source_info.pixels;\n           else\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-5525","CWE_ID":"399","category":"security","commit_id":"12351a91da97b414eec8cdb09f1d9f41e535a401","commit_message":"From 12351a91da97b414eec8cdb09f1d9f41e535a401 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Wed, 14 Dec 2016 18:30:21 -0800\nSubject: [PATCH] audio: ac97: add exit function\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nCurrently the ac97 device emulation doesn't have a exit function,\nhot unplug this device will leak some memory. Add a exit function to\navoid this.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nReviewed-by: Marc-Andr\u00c3\u00a9 Lureau <marcandre.lureau@redhat.com>\nMessage-id: 58520052.4825ed0a.27a71.6cae@mx.google.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/audio\/ac97.c | 11 +++++++++++\n 1 file changed, 11 insertions(+)\n\n","diff_code":"diff --git a\/hw\/audio\/ac97.c b\/hw\/audio\/ac97.c\nindex cbd959e..c306575 100644\n--- a\/hw\/audio\/ac97.c\n+++ b\/hw\/audio\/ac97.c\n@@ -1387,6 +1387,16 @@ static void ac97_realize(PCIDevice *dev, Error **errp)\n     ac97_on_reset (&s->dev.qdev);\n }\n \n+static void ac97_exit(PCIDevice *dev)\n+{\n+    AC97LinkState *s = DO_UPCAST(AC97LinkState, dev, dev);\n+\n+    AUD_close_in(&s->card, s->voice_pi);\n+    AUD_close_out(&s->card, s->voice_po);\n+    AUD_close_in(&s->card, s->voice_mc);\n+    AUD_remove_card(&s->card);\n+}\n+\n static int ac97_init (PCIBus *bus)\n {\n     pci_create_simple (bus, -1, \"AC97\");\n@@ -1404,6 +1414,7 @@ static void ac97_class_init (ObjectClass *klass, void *data)\n     PCIDeviceClass *k = PCI_DEVICE_CLASS (klass);\n \n     k->realize = ac97_realize;\n+    k->exit = ac97_exit;\n     k->vendor_id = PCI_VENDOR_ID_INTEL;\n     k->device_id = PCI_DEVICE_ID_INTEL_82801AA_5;\n     k->revision = 0x01;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0281","CWE_ID":"399","category":"security","commit_id":"564f7cc2a51dcd2f28ab12a13394f31be5aa3c93","commit_message":"From 564f7cc2a51dcd2f28ab12a13394f31be5aa3c93 Mon Sep 17 00:00:00 2001\nFrom: David Vossel <dvossel@redhat.com>\nDate: Sat, 5 Jan 2013 00:19:59 -0600\nSubject: [PATCH] High: core: Internal tls api improvements for reuse with\n future LRMD tls backend.\n\n---\n cib\/callbacks.c        |  13 +-\n cib\/callbacks.h        |   6 +-\n cib\/notify.c           |   2 +-\n cib\/remote.c           | 326 ++++++++++++-------\n include\/crm_internal.h |  36 +-\n lib\/cib\/cib_remote.c   | 290 ++++++++---------\n lib\/common\/mainloop.c  |   1 +\n lib\/common\/remote.c    | 723 +++++++++++++++++++++++++++++++----------\n tools\/crm_mon.c        |   2 +-\n 9 files changed, 939 insertions(+), 460 deletions(-)\n\n","diff_code":"diff --git a\/cib\/callbacks.c b\/cib\/callbacks.c\nindex 86cfd92261..aa5f6a8272 100644\n--- a\/cib\/callbacks.c\n+++ b\/cib\/callbacks.c\n@@ -347,13 +347,18 @@ do_local_notify(xmlNode * notify_src, const char *client_id,\n         int rid = 0;\n \n         if(sync_reply) {\n-            CRM_LOG_ASSERT(client_obj->request_id);\n+            if (client_obj->ipc) {\n+                CRM_LOG_ASSERT(client_obj->request_id);\n \n-            rid = client_obj->request_id;\n-            client_obj->request_id = 0;\n+                rid = client_obj->request_id;\n+                client_obj->request_id = 0;\n \n-            crm_trace(\"Sending response %d to %s %s\",\n+                crm_trace(\"Sending response %d to %s %s\",\n                       rid, client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n+            } else {\n+                crm_trace(\"Sending response to %s %s\",\n+                      client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n+            }\n \n         } else {\n             crm_trace(\"Sending an event to %s %s\",\ndiff --git a\/cib\/callbacks.h b\/cib\/callbacks.h\nindex 99a5065bf5..b8af997b63 100644\n--- a\/cib\/callbacks.h\n+++ b\/cib\/callbacks.h\n@@ -41,18 +41,21 @@ typedef struct cib_client_s {\n     char *name;\n     char *callback_id;\n     char *user;\n+    char *recv_buf;\n     int request_id;\n \n     qb_ipcs_connection_t *ipc;\n \n #ifdef HAVE_GNUTLS_GNUTLS_H\n     gnutls_session *session;\n+    gboolean handshake_complete;\n #else\n     void *session;\n #endif\n     gboolean encrypted;\n+    gboolean remote_auth;\n     mainloop_io_t *remote;\n-        \n+\n     unsigned long num_calls;\n \n     int pre_notify;\n@@ -60,6 +63,7 @@ typedef struct cib_client_s {\n     int confirmations;\n     int replace;\n     int diffs;\n+    int remote_auth_timeout;\n \n     GList *delegated_calls;\n } cib_client_t;\ndiff --git a\/cib\/notify.c b\/cib\/notify.c\nindex 9dcb6997af..1dcda8fcdf 100644\n--- a\/cib\/notify.c\n+++ b\/cib\/notify.c\n@@ -83,7 +83,7 @@ cib_notify_client(gpointer key, gpointer value, gpointer user_data)\n     CRM_CHECK(client != NULL, return TRUE);\n     CRM_CHECK(update_msg != NULL, return TRUE);\n \n-    if (client->ipc == NULL) {\n+    if (client->ipc == NULL && client->session == NULL) {\n         crm_warn(\"Skipping client with NULL channel\");\n         return FALSE;\n     }\ndiff --git a\/cib\/remote.c b\/cib\/remote.c\nindex 7ad7132b2c..f9b90a074c 100644\n--- a\/cib\/remote.c\n+++ b\/cib\/remote.c\n@@ -60,10 +60,6 @@\n #  endif\n #endif\n \n-#ifdef HAVE_DECL_NANOSLEEP\n-#  include <time.h>\n-#endif\n-\n extern int remote_tls_fd;\n extern gboolean cib_shutdown_flag;\n \n@@ -73,17 +69,16 @@ void cib_remote_connection_destroy(gpointer user_data);\n #ifdef HAVE_GNUTLS_GNUTLS_H\n #  define DH_BITS 1024\n gnutls_dh_params dh_params;\n-extern gnutls_anon_server_credentials anon_cred_s;\n+gnutls_anon_server_credentials anon_cred_s;\n static void\n debug_log(int level, const char *str)\n {\n     fputs(str, stderr);\n }\n-\n-extern gnutls_session *create_tls_session(int csock, int type);\n-\n #endif\n \n+#define REMOTE_AUTH_TIMEOUT 10000\n+\n int num_clients;\n int authenticate_user(const char *user, const char *passwd);\n int cib_remote_listen(gpointer data);\n@@ -121,7 +116,7 @@ init_remote_listener(int port, gboolean encrypted)\n #else\n         crm_notice(\"Starting a tls listener on port %d.\", port);\n         gnutls_global_init();\n-\/* \tgnutls_global_set_log_level (10); *\/\n+        \/* gnutls_global_set_log_level (10); *\/\n         gnutls_global_set_log_function(debug_log);\n         gnutls_dh_params_init(&dh_params);\n         gnutls_dh_params_generate2(dh_params, DH_BITS);\n@@ -215,37 +210,89 @@ check_group_membership(const char *usr, const char *grp)\n     return FALSE;\n }\n \n+static gboolean\n+cib_remote_auth(xmlNode *login)\n+{\n+    const char *user = NULL;\n+    const char *pass = NULL;\n+    const char *tmp = NULL;\n+\n+    crm_log_xml_info(login, \"Login: \");\n+    if (login == NULL) {\n+        return FALSE;\n+    }\n+\n+    tmp = crm_element_name(login);\n+    if (safe_str_neq(tmp, \"cib_command\")) {\n+        crm_err(\"Wrong tag: %s\", tmp);\n+        return FALSE;\n+    }\n+\n+    tmp = crm_element_value(login, \"op\");\n+    if (safe_str_neq(tmp, \"authenticate\")) {\n+        crm_err(\"Wrong operation: %s\", tmp);\n+        return FALSE;\n+    }\n+\n+    user = crm_element_value(login, \"user\");\n+    pass = crm_element_value(login, \"password\");\n+\n+    if (!user || !pass) {\n+        crm_err(\"missing auth credentials\");\n+        return FALSE;\n+    }\n+\n+    \/* Non-root daemons can only validate the password of the\n+     * user they're running as\n+     *\/\n+    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n+        crm_err(\"User is not a member of the required group\");\n+        return FALSE;\n+\n+    } else if (authenticate_user(user, pass) == FALSE) {\n+        crm_err(\"PAM auth failed\");\n+        return FALSE;\n+    }\n+\n+    return TRUE;\n+}\n+\n+static gboolean\n+remote_auth_timeout_cb(gpointer data)\n+{\n+    cib_client_t *client = data;\n+\n+    client->remote_auth_timeout = 0;\n+\n+    if (client->remote_auth == TRUE) {\n+        return FALSE;\n+    }\n+\n+    mainloop_del_fd(client->remote);\n+    crm_err(\"Remote client authentication timed out\");\n+\n+    return FALSE;\n+}\n int\n cib_remote_listen(gpointer data)\n {\n-    int lpc = 0;\n     int csock = 0;\n     unsigned laddr;\n-    time_t now = 0;\n-    time_t start = time(NULL);\n     struct sockaddr_in addr;\n     int ssock = *(int *)data;\n+    int flag;\n \n #ifdef HAVE_GNUTLS_GNUTLS_H\n     gnutls_session *session = NULL;\n #endif\n     cib_client_t *new_client = NULL;\n \n-    xmlNode *login = NULL;\n-    const char *user = NULL;\n-    const char *pass = NULL;\n-    const char *tmp = NULL;\n-\n-#ifdef HAVE_DECL_NANOSLEEP\n-    const struct timespec sleepfast = { 0, 10000000 };  \/* 10 millisec *\/\n-#endif\n-\n     static struct mainloop_fd_callbacks remote_client_fd_callbacks = \n         {\n             .dispatch = cib_remote_msg,\n             .destroy = cib_remote_connection_destroy,\n-        };    \n-    \n+        };\n+\n     \/* accept the connection *\/\n     laddr = sizeof(addr);\n     csock = accept(ssock, (struct sockaddr *)&addr, &laddr);\n@@ -257,10 +304,22 @@ cib_remote_listen(gpointer data)\n         return TRUE;\n     }\n \n+    if ((flag = fcntl(csock, F_GETFL)) >= 0) {\n+        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {\n+            crm_err( \"fcntl() write failed\");\n+            close(csock);\n+            return TRUE;\n+        }\n+    } else {\n+        crm_err( \"fcntl() read failed\");\n+        close(csock);\n+        return TRUE;\n+    }\n+\n     if (ssock == remote_tls_fd) {\n #ifdef HAVE_GNUTLS_GNUTLS_H\n         \/* create gnutls session for the server socket *\/\n-        session = create_tls_session(csock, GNUTLS_SERVER);\n+        session = crm_create_anon_tls_session(csock, GNUTLS_SERVER, anon_cred_s);\n         if (session == NULL) {\n             crm_err(\"TLS session creation failed\");\n             close(csock);\n@@ -269,73 +328,13 @@ cib_remote_listen(gpointer data)\n #endif\n     }\n \n-    do {\n-        crm_trace(\"Iter: %d\", lpc++);\n-        if (ssock == remote_tls_fd) {\n-#ifdef HAVE_GNUTLS_GNUTLS_H\n-            login = crm_recv_remote_msg(session, TRUE);\n-#endif\n-        } else {\n-            login = crm_recv_remote_msg(GINT_TO_POINTER(csock), FALSE);\n-        }\n-        if (login != NULL) {\n-            break;\n-        }\n-#ifdef HAVE_DECL_NANOSLEEP\n-        nanosleep(&sleepfast, NULL);\n-#else\n-        sleep(1);\n-#endif\n-        now = time(NULL);\n-\n-        \/* Peers have 3s to connect *\/\n-    } while (login == NULL && (start - now) < 4);\n-\n-    crm_log_xml_info(login, \"Login: \");\n-    if (login == NULL) {\n-        goto bail;\n-    }\n-\n-    tmp = crm_element_name(login);\n-    if (safe_str_neq(tmp, \"cib_command\")) {\n-        crm_err(\"Wrong tag: %s\", tmp);\n-        goto bail;\n-    }\n-\n-    tmp = crm_element_value(login, \"op\");\n-    if (safe_str_neq(tmp, \"authenticate\")) {\n-        crm_err(\"Wrong operation: %s\", tmp);\n-        goto bail;\n-    }\n-\n-    user = crm_element_value(login, \"user\");\n-    pass = crm_element_value(login, \"password\");\n-\n-    \/* Non-root daemons can only validate the password of the\n-     * user they're running as\n-     *\/\n-    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n-        crm_err(\"User is not a member of the required group\");\n-        goto bail;\n-\n-    } else if (authenticate_user(user, pass) == FALSE) {\n-        crm_err(\"PAM auth failed\");\n-        goto bail;\n-    }\n-\n-    \/* send ACK *\/\n     num_clients++;\n     new_client = calloc(1, sizeof(cib_client_t));\n-    new_client->name = crm_element_value_copy(login, \"name\");\n-\n-    CRM_CHECK(new_client->id == NULL, free(new_client->id));\n     new_client->id = crm_generate_uuid();\n-\n-#if ENABLE_ACL\n-    new_client->user = strdup(user);\n-#endif\n-\n     new_client->callback_id = NULL;\n+    \/* clients have a few seconds to perform handshake. *\/\n+    new_client->remote_auth_timeout = g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, new_client);\n+\n     if (ssock == remote_tls_fd) {\n #ifdef HAVE_GNUTLS_GNUTLS_H\n         new_client->encrypted = TRUE;\n@@ -345,37 +344,19 @@ cib_remote_listen(gpointer data)\n         new_client->session = GINT_TO_POINTER(csock);\n     }\n \n-    free_xml(login);\n-    login = create_xml_node(NULL, \"cib_result\");\n-    crm_xml_add(login, F_CIB_OPERATION, CRM_OP_REGISTER);\n-    crm_xml_add(login, F_CIB_CLIENTID, new_client->id);\n-    crm_send_remote_msg(new_client->session, login, new_client->encrypted);\n-    free_xml(login);\n-\n     new_client->remote = mainloop_add_fd(\n         \"cib-remote-client\", G_PRIORITY_DEFAULT, csock, new_client, &remote_client_fd_callbacks);\n \n     g_hash_table_insert(client_list, new_client->id, new_client);\n \n     return TRUE;\n-\n-  bail:\n-    if (ssock == remote_tls_fd) {\n-#ifdef HAVE_GNUTLS_GNUTLS_H\n-        gnutls_bye(*session, GNUTLS_SHUT_RDWR);\n-        gnutls_deinit(*session);\n-        gnutls_free(session);\n-#endif\n-    }\n-    close(csock);\n-    free_xml(login);\n-    return TRUE;\n }\n \n void\n cib_remote_connection_destroy(gpointer user_data)\n {\n     cib_client_t *client = user_data;\n+    int csock = 0;\n \n     if (client == NULL) {\n         return;\n@@ -393,10 +374,36 @@ cib_remote_connection_destroy(gpointer user_data)\n     crm_trace(\"Destroying %s (%p)\", client->name, user_data);\n     num_clients--;\n     crm_trace(\"Num unfree'd clients: %d\", num_clients);\n+    if (client->remote_auth_timeout) {\n+        g_source_remove(client->remote_auth_timeout);\n+    }\n+\n+    if (client->encrypted) {\n+#ifdef HAVE_GNUTLS_GNUTLS_H\n+        if (client->session) {\n+            void *sock_ptr = gnutls_transport_get_ptr(*client->session);\n+            csock = GPOINTER_TO_INT(sock_ptr);\n+            if (client->handshake_complete) {\n+                gnutls_bye(*client->session, GNUTLS_SHUT_WR);\n+            }\n+            gnutls_deinit(*client->session);\n+            gnutls_free(client->session);\n+        }\n+#endif\n+    } else {\n+        csock = GPOINTER_TO_INT(client->session);\n+    }\n+    client->session = NULL;\n+\n+    if (csock > 0) {\n+        close(csock);\n+    }\n+\n     free(client->name);\n     free(client->callback_id);\n     free(client->id);\n     free(client->user);\n+    free(client->recv_buf);\n     free(client);\n     crm_trace(\"Freed the cib client\");\n \n@@ -406,24 +413,15 @@ cib_remote_connection_destroy(gpointer user_data)\n     return;\n }\n \n-int\n-cib_remote_msg(gpointer data)\n+static void\n+cib_handle_remote_msg(cib_client_t *client, xmlNode *command)\n {\n     const char *value = NULL;\n-    xmlNode *command = NULL;\n-    cib_client_t *client = data;\n-\n-    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n-\n-    command = crm_recv_remote_msg(client->session, client->encrypted);\n-    if (command == NULL) {\n-        return -1;\n-    }\n \n     value = crm_element_name(command);\n     if (safe_str_neq(value, \"cib_command\")) {\n         crm_log_xml_trace(command, \"Bad command: \");\n-        goto bail;\n+        return;\n     }\n \n     if (client->name == NULL) {\n@@ -472,9 +470,95 @@ cib_remote_msg(gpointer data)\n \n     crm_log_xml_trace(command, \"Remote command: \");\n     cib_common_callback_worker(0, 0, command, client, TRUE);\n-  bail:\n-    free_xml(command);\n-    command = NULL;\n+}\n+\n+int\n+cib_remote_msg(gpointer data)\n+{\n+    xmlNode *command = NULL;\n+    cib_client_t *client = data;\n+    int disconnected = 0;\n+    int timeout = client->remote_auth ? -1 : 1000;\n+\n+    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n+\n+#ifdef HAVE_GNUTLS_GNUTLS_H\n+    if (client->encrypted && (client->handshake_complete == FALSE)) {\n+        int rc = 0;\n+\n+        \/* Muliple calls to handshake will be required, this callback\n+         * will be invoked once the client sends more handshake data. *\/\n+        do {\n+            rc = gnutls_handshake(*client->session);\n+\n+            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n+                crm_err(\"Remote cib tls handshake failed\");\n+                return -1;\n+            }\n+        } while (rc == GNUTLS_E_INTERRUPTED);\n+\n+        if (rc == 0) {\n+            crm_debug(\"Remote cib tls handshake completed\");\n+            client->handshake_complete = TRUE;\n+            if (client->remote_auth_timeout) {\n+                g_source_remove(client->remote_auth_timeout);\n+            }\n+            \/* after handshake, clients must send auth in a few seconds *\/\n+            client->remote_auth_timeout = g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, client);\n+        }\n+        return 0;\n+    }\n+#endif\n+\n+    crm_recv_remote_msg(client->session, &client->recv_buf, client->encrypted, timeout, &disconnected);\n+\n+    \/* must pass auth before we will process anything else *\/\n+    if (client->remote_auth == FALSE) {\n+        xmlNode *reg;\n+#if ENABLE_ACL\n+        const char *user = NULL;\n+#endif\n+        command = crm_parse_remote_buffer(&client->recv_buf);\n+        if (cib_remote_auth(command) == FALSE) {\n+            free_xml(command);\n+            return -1;\n+        }\n+\n+        crm_debug(\"remote connection authenticated successfully\");\n+        client->remote_auth = TRUE;\n+        g_source_remove(client->remote_auth_timeout);\n+        client->remote_auth_timeout = 0;\n+        client->name = crm_element_value_copy(command, \"name\");\n+\n+#if ENABLE_ACL\n+        user = crm_element_value(command, \"user\");\n+        if (user) {\n+           new_client->user = strdup(user);\n+        }\n+#endif\n+\n+        \/* send ACK *\/\n+        reg = create_xml_node(NULL, \"cib_result\");\n+        crm_xml_add(reg, F_CIB_OPERATION, CRM_OP_REGISTER);\n+        crm_xml_add(reg, F_CIB_CLIENTID, client->id);\n+        crm_send_remote_msg(client->session, reg, client->encrypted);\n+        free_xml(reg);\n+        free_xml(command);\n+    }\n+\n+    command = crm_parse_remote_buffer(&client->recv_buf);\n+    while (command) {\n+        crm_trace(\"command received\");\n+        cib_handle_remote_msg(client, command);\n+        free_xml(command);\n+        command = crm_parse_remote_buffer(&client->recv_buf);\n+    }\n+\n+    if (disconnected) {\n+        crm_trace(\"disconnected while receiving remote cib msg.\");\n+        return -1;\n+    }\n+\n     return 0;\n }\n \ndiff --git a\/include\/crm_internal.h b\/include\/crm_internal.h\nindex cf6d95d373..388af5931f 100644\n--- a\/include\/crm_internal.h\n+++ b\/include\/crm_internal.h\n@@ -199,8 +199,40 @@ void g_hash_destroy_str(gpointer data);\n long long crm_int_helper(const char *text, char **end_text);\n char *crm_concat(const char *prefix, const char *suffix, char join);\n char *generate_hash_key(const char *crm_msg_reference, const char *sys);\n-xmlNode *crm_recv_remote_msg(void *session, gboolean encrypted);\n-void crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted);\n+\n+\n+\/*! remote tcp\/tls helper functions *\/\n+gboolean crm_recv_remote_msg(void *session, char **recv_buf, gboolean encrypted, int total_timeout_ms, int *disconnected);\n+char *crm_recv_remote_raw(void *data, gboolean encrypted, size_t max_recv, size_t *recv_len, int *disconnected);\n+int crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted);\n+int crm_recv_remote_ready(void *session, gboolean encrypted, int timeout_ms);\n+xmlNode *crm_parse_remote_buffer(char **msg_buf);\n+int crm_remote_tcp_connect(const char *host, int port);\n+\n+#ifdef HAVE_GNUTLS_GNUTLS_H\n+\/*!\n+ * \\internal\n+ * \\brief Initiate the client handshake after establishing the tcp socket.\n+ * \\note This is a blocking function, it will block until the entire handshake\n+ *       is complete or until the timeout period is reached.\n+ * \\retval 0 success\n+ * \\retval negative, failure\n+ *\/\n+int crm_initiate_client_tls_handshake(void *session_data, int timeout_ms);\n+\/*!\n+ * \\internal\n+ * \\brief Create client or server session for anon DH encryption credentials\n+ * \\param sock, the socket the session will use for transport\n+ * \\param type, GNUTLS_SERVER or GNUTLS_CLIENT\n+ * \\param credentials, gnutls_anon_server_credentials_t or gnutls_anon_client_credentials_t\n+ *\n+ * \\retval gnutls_session * on success\n+ * \\retval NULL on failure\n+ *\/\n+void *crm_create_anon_tls_session(int sock, int type, void *credentials);\n+#endif\n+\n+#define REMOTE_MSG_TERMINATOR \"\\r\\n\\r\\n\"\n \n const char *daemon_option(const char *option);\n void set_daemon_option(const char *option, const char *value);\ndiff --git a\/lib\/cib\/cib_remote.c b\/lib\/cib\/cib_remote.c\nindex 91bca96eb3..ca80c0e077 100644\n--- a\/lib\/cib\/cib_remote.c\n+++ b\/lib\/cib\/cib_remote.c\n@@ -38,14 +38,15 @@\n #ifdef HAVE_GNUTLS_GNUTLS_H\n #  undef KEYFILE\n #  include <gnutls\/gnutls.h>\n-extern gnutls_anon_client_credentials anon_cred_c;\n-extern gnutls_session *create_tls_session(int csock, int type);\n+gnutls_anon_client_credentials anon_cred_c;\n+#define DEFAULT_CLIENT_HANDSHAKE_TIMEOUT 5000 \/* 5 seconds *\/\n \n const int kx_prio[] = {\n     GNUTLS_KX_ANON_DH,\n     0\n };\n \n+static gboolean remote_gnutls_credentials_init = FALSE;\n #else\n typedef void gnutls_session;\n #endif\n@@ -61,6 +62,7 @@ struct remote_connection_s {\n     gnutls_session *session;\n     mainloop_io_t *source;\n     char *token;\n+    char *recv_buf;\n };\n \n typedef struct cib_remote_opaque_s {\n@@ -76,7 +78,8 @@ typedef struct cib_remote_opaque_s {\n } cib_remote_opaque_t;\n \n void cib_remote_connection_destroy(gpointer user_data);\n-int cib_remote_dispatch(gpointer user_data);\n+int cib_remote_callback_dispatch(gpointer user_data);\n+int cib_remote_command_dispatch(gpointer user_data);\n int cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type);\n int cib_remote_signoff(cib_t * cib);\n int cib_remote_free(cib_t * cib);\n@@ -158,117 +161,91 @@ cib_tls_close(cib_t * cib)\n {\n     cib_remote_opaque_t *private = cib->variant_opaque;\n \n-    shutdown(private->command.socket, SHUT_RDWR);       \/* no more receptions *\/\n-    shutdown(private->callback.socket, SHUT_RDWR);      \/* no more receptions *\/\n-    close(private->command.socket);\n-    close(private->callback.socket);\n-\n #ifdef HAVE_GNUTLS_GNUTLS_H\n     if (private->command.encrypted) {\n-        gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);\n-        gnutls_deinit(*(private->command.session));\n-        gnutls_free(private->command.session);\n-\n-        gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);\n-        gnutls_deinit(*(private->callback.session));\n-        gnutls_free(private->callback.session);\n+        if (private->command.session) {\n+            gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);\n+            gnutls_deinit(*(private->command.session));\n+            gnutls_free(private->command.session);\n+        }\n \n-        gnutls_anon_free_client_credentials(anon_cred_c);\n-        gnutls_global_deinit();\n+        if (private->callback.session) {\n+            gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);\n+            gnutls_deinit(*(private->callback.session));\n+            gnutls_free(private->callback.session);\n+        }\n+        private->command.session = NULL;\n+        private->callback.session = NULL;\n+        if (remote_gnutls_credentials_init) {\n+            gnutls_anon_free_client_credentials(anon_cred_c);\n+            gnutls_global_deinit();\n+            remote_gnutls_credentials_init = FALSE;\n+        }\n     }\n #endif\n+\n+    if (private->command.socket) {\n+        shutdown(private->command.socket, SHUT_RDWR);       \/* no more receptions *\/\n+        close(private->command.socket);\n+    }\n+    if (private->callback.socket) {\n+        shutdown(private->callback.socket, SHUT_RDWR);      \/* no more receptions *\/\n+        close(private->callback.socket);\n+    }\n+    private->command.socket = 0;\n+    private->callback.socket = 0;\n+\n+    free(private->command.recv_buf);\n+    free(private->callback.recv_buf);\n+    private->command.recv_buf = NULL;\n+    private->callback.recv_buf = NULL;\n+\n     return 0;\n }\n \n static int\n-cib_tls_signon(cib_t * cib, struct remote_connection_s *connection)\n+cib_tls_signon(cib_t * cib, struct remote_connection_s *connection, gboolean event_channel)\n {\n     int sock;\n     cib_remote_opaque_t *private = cib->variant_opaque;\n-    struct sockaddr_in addr;\n     int rc = 0;\n-    char *server = private->server;\n-\n-    int ret_ga;\n-    struct addrinfo *res;\n-    struct addrinfo hints;\n+    int disconnected = 0;\n \n     xmlNode *answer = NULL;\n     xmlNode *login = NULL;\n \n-    static struct mainloop_fd_callbacks cib_fd_callbacks = \n-        {\n-            .dispatch = cib_remote_dispatch,\n-            .destroy = cib_remote_connection_destroy,\n-        };\n+    static struct mainloop_fd_callbacks cib_fd_callbacks = { 0, };\n+\n+    cib_fd_callbacks.dispatch = event_channel ? cib_remote_callback_dispatch : cib_remote_command_dispatch;\n+    cib_fd_callbacks.destroy = cib_remote_connection_destroy;\n \n     connection->socket = 0;\n     connection->session = NULL;\n \n-    \/* create socket *\/\n-    sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n-    if (sock == -1) {\n-        crm_perror(LOG_ERR, \"Socket creation failed\");\n-        return -1;\n-    }\n-\n-    \/* getaddrinfo *\/\n-    bzero(&hints, sizeof(struct addrinfo));\n-    hints.ai_flags = AI_CANONNAME;\n-    hints.ai_family = AF_INET;\n-    hints.ai_socktype = SOCK_RAW;\n-\n-    if (hints.ai_family == AF_INET6) {\n-        hints.ai_protocol = IPPROTO_ICMPV6;\n-    } else {\n-        hints.ai_protocol = IPPROTO_ICMP;\n-    }\n-\n-    crm_debug(\"Looking up %s\", server);\n-    ret_ga = getaddrinfo(server, NULL, &hints, &res);\n-    if (ret_ga) {\n-        crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));\n-        close(sock);\n-        return -1;\n-    }\n-\n-    if (res->ai_canonname) {\n-        server = res->ai_canonname;\n-    }\n-\n-    crm_debug(\"Got address %s for %s\", server, private->server);\n-\n-    if (!res->ai_addr) {\n-        fprintf(stderr, \"getaddrinfo failed\");\n-        crm_exit(1);\n-    }\n-#if 1\n-    memcpy(&addr, res->ai_addr, res->ai_addrlen);\n-#else\n-    \/* connect to server *\/\n-    memset(&addr, 0, sizeof(addr));\n-    addr.sin_family = AF_INET;\n-    addr.sin_addr.s_addr = inet_addr(server);\n-#endif\n-    addr.sin_port = htons(private->port);\n-\n-    if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n-        crm_perror(LOG_ERR, \"Connection to %s:%d failed\", server, private->port);\n-        close(sock);\n-        return -1;\n+    sock = crm_remote_tcp_connect(private->server, private->port);\n+    if (sock <= 0) {\n+        crm_perror(LOG_ERR, \"remote tcp connection to %s:%d failed\", private->server, private->port);\n     }\n \n+    connection->socket = sock;\n     if (connection->encrypted) {\n         \/* initialize GnuTls lib *\/\n #ifdef HAVE_GNUTLS_GNUTLS_H\n-        gnutls_global_init();\n-        gnutls_anon_allocate_client_credentials(&anon_cred_c);\n+        if (remote_gnutls_credentials_init == FALSE) {\n+            gnutls_global_init();\n+            gnutls_anon_allocate_client_credentials(&anon_cred_c);\n+            remote_gnutls_credentials_init = TRUE;\n+        }\n \n         \/* bind the socket to GnuTls lib *\/\n-        connection->session = create_tls_session(sock, GNUTLS_CLIENT);\n-        if (connection->session == NULL) {\n-            crm_perror(LOG_ERR, \"Session creation for %s:%d failed\", server, private->port);\n-            close(sock);\n+        connection->session = crm_create_anon_tls_session(sock, GNUTLS_CLIENT, anon_cred_c);\n+\n+        if (crm_initiate_client_tls_handshake(connection->session, DEFAULT_CLIENT_HANDSHAKE_TIMEOUT) != 0) {\n+            crm_err(\"Session creation for %s:%d failed\", private->server, private->port);\n+\n+            gnutls_deinit(*connection->session);\n+            gnutls_free(connection->session);\n+            connection->session = NULL;\n             cib_tls_close(cib);\n             return -1;\n         }\n@@ -289,7 +266,14 @@ cib_tls_signon(cib_t * cib, struct remote_connection_s *connection)\n     crm_send_remote_msg(connection->session, login, connection->encrypted);\n     free_xml(login);\n \n-    answer = crm_recv_remote_msg(connection->session, connection->encrypted);\n+    crm_recv_remote_msg(connection->session, &connection->recv_buf, connection->encrypted, -1, &disconnected);\n+\n+    if (disconnected) {\n+        rc = -ENOTCONN;\n+    }\n+\n+    answer = crm_parse_remote_buffer(&connection->recv_buf);\n+\n     crm_log_xml_trace(answer, \"Reply\");\n     if (answer == NULL) {\n         rc = -EPROTO;\n@@ -310,12 +294,15 @@ cib_tls_signon(cib_t * cib, struct remote_connection_s *connection)\n             connection->token = strdup(tmp_ticket);\n         }\n     }\n+    free_xml(answer);\n+    answer = NULL;\n \n     if (rc != 0) {\n         cib_tls_close(cib);\n+        return rc;\n     }\n \n-    connection->socket = sock;\n+    crm_trace(\"remote client connection established\");\n     connection->source = mainloop_add_fd(\"cib-remote\", G_PRIORITY_HIGH, connection->socket, cib, &cib_fd_callbacks);\n     return rc;\n }\n@@ -331,35 +318,61 @@ cib_remote_connection_destroy(gpointer user_data)\n }\n \n int\n-cib_remote_dispatch(gpointer user_data)\n+cib_remote_command_dispatch(gpointer user_data)\n+{\n+    int disconnected = 0;\n+    cib_t *cib = user_data;\n+    cib_remote_opaque_t *private = cib->variant_opaque;\n+\n+    crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, -1, &disconnected);\n+\n+    free(private->command.recv_buf);\n+    private->command.recv_buf = NULL;\n+    crm_err(\"received late reply for remote cib connection, discarding\");\n+\n+    if (disconnected) {\n+        return -1;\n+    }\n+    return 0;\n+}\n+\n+int\n+cib_remote_callback_dispatch(gpointer user_data)\n {\n     cib_t *cib = user_data;\n     cib_remote_opaque_t *private = cib->variant_opaque;\n \n     xmlNode *msg = NULL;\n-    const char *type = NULL;\n+    int disconnected = 0;\n \n     crm_info(\"Message on callback channel\");\n-    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n \n-    type = crm_element_value(msg, F_TYPE);\n-    crm_trace(\"Activating %s callbacks...\", type);\n+    crm_recv_remote_msg(private->callback.session, &private->callback.recv_buf, private->callback.encrypted, -1, &disconnected);\n \n-    if (safe_str_eq(type, T_CIB)) {\n-        cib_native_callback(cib, msg, 0, 0);\n+    msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n+    while (msg) {\n+        const char *type = crm_element_value(msg, F_TYPE);\n+        crm_trace(\"Activating %s callbacks...\", type);\n \n-    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n-        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n+        if (safe_str_eq(type, T_CIB)) {\n+            cib_native_callback(cib, msg, 0, 0);\n \n-    } else {\n-        crm_err(\"Unknown message type: %s\", type);\n-    }\n+        } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n+            g_list_foreach(cib->notify_list, cib_native_notify, msg);\n+\n+        } else {\n+            crm_err(\"Unknown message type: %s\", type);\n+        }\n \n-    if (msg != NULL) {\n         free_xml(msg);\n-        return 0;\n+        msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n+    }\n+\n+    if (disconnected) {\n+        return -1;\n     }\n-    return -1;\n+\n+    return 0;\n }\n \n int\n@@ -394,11 +407,11 @@ cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type)\n     }\n \n     if (rc == pcmk_ok) {\n-        rc = cib_tls_signon(cib, &(private->command));\n+        rc = cib_tls_signon(cib, &(private->command), FALSE);\n     }\n \n     if (rc == pcmk_ok) {\n-        rc = cib_tls_signon(cib, &(private->callback));\n+        rc = cib_tls_signon(cib, &(private->callback), TRUE);\n     }\n \n     if (rc == pcmk_ok) {\n@@ -463,37 +476,20 @@ cib_remote_free(cib_t * cib)\n     return rc;\n }\n \n-static gboolean timer_expired = FALSE;\n-static struct timer_rec_s *sync_timer = NULL;\n-static gboolean\n-cib_timeout_handler(gpointer data)\n-{\n-    struct timer_rec_s *timer = data;\n-\n-    timer_expired = TRUE;\n-    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n-\n-    \/* Always return TRUE, never remove the handler\n-     * We do that after the while-loop in cib_native_perform_op()\n-     *\/\n-    return TRUE;\n-}\n-\n int\n cib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char *section,\n                       xmlNode * data, xmlNode ** output_data, int call_options, const char *name)\n {\n     int rc = pcmk_ok;\n+    int disconnected = 0;\n+    int remaining_time = 0;\n+    time_t start_time;\n \n     xmlNode *op_msg = NULL;\n     xmlNode *op_reply = NULL;\n \n     cib_remote_opaque_t *private = cib->variant_opaque;\n \n-    if (sync_timer == NULL) {\n-        sync_timer = calloc(1, sizeof(struct timer_rec_s));\n-    }\n-\n     if (cib->state == cib_disconnected) {\n         return -ENOTCONN;\n     }\n@@ -524,7 +520,11 @@ cib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char\n     }\n \n     crm_trace(\"Sending %s message to CIB service\", op);\n-    crm_send_remote_msg(private->command.session, op_msg, private->command.encrypted);\n+    if (!(call_options & cib_sync_call)) {\n+        crm_send_remote_msg(private->callback.session, op_msg, private->command.encrypted);\n+    } else {\n+        crm_send_remote_msg(private->command.session, op_msg, private->command.encrypted);\n+    }\n     free_xml(op_msg);\n \n     if ((call_options & cib_discard_reply)) {\n@@ -537,30 +537,21 @@ cib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char\n \n     crm_trace(\"Waiting for a syncronous reply\");\n \n-    if (cib->call_timeout > 0) {\n-        \/* We need this, even with msgfromIPC_timeout(), because we might\n-         * get other\/older replies that don't match the active request\n-         *\/\n-        timer_expired = FALSE;\n-        sync_timer->call_id = cib->call_id;\n-        sync_timer->timeout = cib->call_timeout * 1000;\n-        sync_timer->ref = g_timeout_add(sync_timer->timeout, cib_timeout_handler, sync_timer);\n-    }\n+    start_time = time(NULL);\n+    remaining_time = cib->call_timeout ? cib->call_timeout : 60;\n \n-    while (timer_expired == FALSE) {\n+    while (remaining_time > 0 && !disconnected) {\n         int reply_id = -1;\n         int msg_id = cib->call_id;\n \n-        op_reply = crm_recv_remote_msg(private->command.session, private->command.encrypted);\n-        if (op_reply == NULL) {\n+        crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, remaining_time * 1000, &disconnected);\n+        op_reply = crm_parse_remote_buffer(&private->command.recv_buf);\n+\n+        if (!op_reply) {\n             break;\n         }\n \n         crm_element_value_int(op_reply, F_CIB_CALLID, &reply_id);\n-        CRM_CHECK(reply_id > 0, free_xml(op_reply);\n-                  if (sync_timer->ref > 0) {\n-                  g_source_remove(sync_timer->ref); sync_timer->ref = 0;}\n-                  return -ENOMSG) ;\n \n         if (reply_id == msg_id) {\n             break;\n@@ -579,15 +570,9 @@ cib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char\n \n         free_xml(op_reply);\n         op_reply = NULL;\n-    }\n-\n-    if (sync_timer->ref > 0) {\n-        g_source_remove(sync_timer->ref);\n-        sync_timer->ref = 0;\n-    }\n \n-    if (timer_expired) {\n-        return -ETIME;\n+        \/* wasn't the right reply, try and read some more *\/\n+        remaining_time = time(NULL) - start_time;\n     }\n \n     \/* if(IPC_ISRCONN(native->command_channel) == FALSE) { *\/\n@@ -596,7 +581,10 @@ cib_remote_perform_op(cib_t * cib, const char *op, const char *host, const char\n     \/*      cib->state = cib_disconnected; *\/\n     \/* } *\/\n \n-    if (op_reply == NULL) {\n+    if (disconnected) {\n+        crm_err(\"Disconnected while waiting for reply.\");\n+        return -ENOTCONN;\n+    } else if (op_reply == NULL) {\n         crm_err(\"No reply message - empty\");\n         return -ENOMSG;\n     }\ndiff --git a\/lib\/common\/mainloop.c b\/lib\/common\/mainloop.c\nindex 09cf6e92b0..1e413b60f3 100644\n--- a\/lib\/common\/mainloop.c\n+++ b\/lib\/common\/mainloop.c\n@@ -178,6 +178,7 @@ mainloop_destroy_trigger(crm_trigger_t * source)\n     source->trigger = FALSE;\n     if (source->id > 0) {\n         g_source_remove(source->id);\n+        source->id = 0;\n     }\n     return TRUE;\n }\ndiff --git a\/lib\/common\/remote.c b\/lib\/common\/remote.c\nindex 7f04097c31..ae61481bc5 100644\n--- a\/lib\/common\/remote.c\n+++ b\/lib\/common\/remote.c\n@@ -25,8 +25,10 @@\n #include <sys\/stat.h>\n #include <unistd.h>\n #include <sys\/socket.h>\n-\n+#include <arpa\/inet.h>\n #include <netinet\/ip.h>\n+#include <netdb.h>\n+\n \n #include <stdlib.h>\n #include <errno.h>\n@@ -42,7 +44,7 @@\n #endif\n \n #ifdef HAVE_GNUTLS_GNUTLS_H\n-const int tls_kx_order[] = {\n+const int anon_tls_kx_order[] = {\n     GNUTLS_KX_ANON_DH,\n     GNUTLS_KX_DHE_RSA,\n     GNUTLS_KX_DHE_DSS,\n@@ -50,22 +52,32 @@ const int tls_kx_order[] = {\n     0\n };\n \n-gnutls_anon_client_credentials anon_cred_c;\n-gnutls_anon_server_credentials anon_cred_s;\n-static char *cib_send_tls(gnutls_session * session, xmlNode * msg);\n-static char *cib_recv_tls(gnutls_session * session);\n-#endif\n+int\n+crm_initiate_client_tls_handshake(void *session_data, int timeout_ms)\n+{\n+    int rc = 0;\n+    int pollrc = 0;\n+    time_t start = time(NULL);\n+    gnutls_session *session = session_data;\n \n-char *cib_recv_plaintext(int sock);\n-char *cib_send_plaintext(int sock, xmlNode * msg);\n+    do {\n+        rc = gnutls_handshake(*session);\n+        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n+            pollrc = crm_recv_remote_ready(session, TRUE, 1000);\n+            if (pollrc < 0) {\n+                \/* poll returned error, there is no hope *\/\n+                rc = -1;\n+            }\n+        }\n+    } while (((time(NULL) - start) < (timeout_ms\/1000)) &&\n+            (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN));\n \n-#ifdef HAVE_GNUTLS_GNUTLS_H\n-gnutls_session *create_tls_session(int csock, int type);\n+    return rc;\n+}\n \n-gnutls_session *\n-create_tls_session(int csock, int type \/* GNUTLS_SERVER, GNUTLS_CLIENT *\/ )\n+void *\n+crm_create_anon_tls_session(int csock, int type \/* GNUTLS_SERVER, GNUTLS_CLIENT *\/, void *credentials)\n {\n-    int rc = 0;\n     gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n \n     gnutls_init(session, type);\n@@ -75,266 +87,619 @@ create_tls_session(int csock, int type \/* GNUTLS_SERVER, GNUTLS_CLIENT *\/ )\n \/*\tgnutls_priority_set_direct (*session, \"NONE:+VERS-TLS-ALL:+CIPHER-ALL:+MAC-ALL:+SIGN-ALL:+COMP-ALL:+ANON-DH\", NULL); *\/\n #  else\n     gnutls_set_default_priority(*session);\n-    gnutls_kx_set_priority(*session, tls_kx_order);\n+    gnutls_kx_set_priority(*session, anon_tls_kx_order);\n #  endif\n     gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n     switch (type) {\n-        case GNUTLS_SERVER:\n-            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);\n-            break;\n-        case GNUTLS_CLIENT:\n-            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);\n-            break;\n+    case GNUTLS_SERVER:\n+        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_server_credentials_t) credentials);\n+        break;\n+    case GNUTLS_CLIENT:\n+        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_client_credentials_t) credentials);\n+        break;\n     }\n \n-    do {\n-        rc = gnutls_handshake(*session);\n-    } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);\n-\n-    if (rc < 0) {\n-        crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));\n-        gnutls_deinit(*session);\n-        gnutls_free(session);\n-        return NULL;\n-    }\n     return session;\n }\n \n-static char *\n-cib_send_tls(gnutls_session * session, xmlNode * msg)\n+static int\n+crm_send_tls(gnutls_session * session, const char *buf, size_t len)\n {\n-    char *xml_text = NULL;\n-\n-#  if 0\n-    const char *name = crm_element_name(msg);\n+    const char *unsent = buf;\n+    int rc = 0;\n+    int total_send;\n \n-    if (safe_str_neq(name, \"cib_command\")) {\n-        xmlNodeSetName(msg, \"cib_result\");\n+    if (buf == NULL) {\n+        return -1;\n     }\n-#  endif\n-    xml_text = dump_xml_unformatted(msg);\n-    if (xml_text != NULL) {\n-        char *unsent = xml_text;\n-        int len = strlen(xml_text);\n-        int rc = 0;\n \n-        len++;                  \/* null char *\/\n-        crm_trace(\"Message size: %d\", len);\n+    total_send = len;\n+    crm_trace(\"Message size: %d\", len);\n \n-        while (TRUE) {\n-            rc = gnutls_record_send(*session, unsent, len);\n-            crm_debug(\"Sent %d bytes\", rc);\n+    while (TRUE) {\n+        rc = gnutls_record_send(*session, unsent, len);\n \n-            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n-                crm_debug(\"Retry\");\n+        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n+            crm_debug(\"Retry\");\n \n-            } else if (rc < 0) {\n-                crm_debug(\"Connection terminated\");\n-                break;\n+        } else if (rc < 0) {\n+            crm_err(\"Connection terminated rc = %d\", rc);\n+            break;\n \n-            } else if (rc < len) {\n-                crm_debug(\"Only sent %d of %d bytes\", rc, len);\n-                len -= rc;\n-                unsent += rc;\n-            } else {\n-                break;\n-            }\n+        } else if (rc < len) {\n+            crm_debug(\"Only sent %d of %d bytes\", rc, len);\n+            len -= rc;\n+            unsent += rc;\n+        } else {\n+            crm_debug(\"Sent %d bytes\", rc);\n+            break;\n         }\n-\n     }\n-    free(xml_text);\n-    return NULL;\n \n+    return rc < 0 ? rc : total_send;\n }\n \n+\n+\/*!\n+ * \\internal\n+ * \\brief Read bytes off non blocking tls session.\n+ *\n+ * \\param session - tls session to read\n+ * \\param max_size - max bytes allowed to read for buffer. 0 assumes no limit\n+ *\n+ * \\note only use with NON-Blocking sockets. Should only be used after polling socket.\n+ *       This function will return once max_size is met, the socket read buffer\n+ *       is empty, or an error is encountered.\n+ *\n+ * \\retval '\\0' terminated buffer on success\n+ *\/\n static char *\n-cib_recv_tls(gnutls_session * session)\n+crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n {\n     char *buf = NULL;\n-\n     int rc = 0;\n-    int len = 0;\n-    int chunk_size = 1024;\n+    size_t len = 0;\n+    size_t chunk_size = max_size ? max_size : 1024;\n+    size_t buf_size = 0;\n+    size_t read_size = 0;\n \n     if (session == NULL) {\n-        return NULL;\n+        if (disconnected) {\n+            *disconnected = 1;\n+        }\n+        goto done;\n     }\n \n-    buf = calloc(1, chunk_size);\n+    buf = calloc(1, chunk_size + 1);\n+    buf_size = chunk_size;\n \n     while (TRUE) {\n-        errno = 0;\n-        rc = gnutls_record_recv(*session, buf + len, chunk_size);\n-        crm_trace(\"Got %d more bytes. errno=%d\", rc, errno);\n+        read_size = buf_size - len;\n \n-        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n-            crm_trace(\"Retry\");\n+        \/* automatically grow the buffer when needed if max_size is not set.*\/\n+        if (!max_size && (read_size < (chunk_size \/ 2))) {\n+            buf_size += chunk_size;\n+            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n+            buf = realloc(buf, buf_size + 1);\n+            CRM_ASSERT(buf != NULL);\n \n-        } else if (rc == GNUTLS_E_UNEXPECTED_PACKET_LENGTH) {\n-            crm_trace(\"Session disconnected\");\n-            goto bail;\n+            read_size = buf_size - len;\n+        }\n \n-        } else if (rc < 0) {\n-            crm_err(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n-            goto bail;\n+        rc = gnutls_record_recv(*session, buf + len, read_size);\n \n-        } else if (rc == chunk_size) {\n+        if (rc > 0) {\n+            crm_trace(\"Got %d more bytes.\", rc);\n             len += rc;\n-            chunk_size *= 2;\n-            buf = realloc(buf, len + chunk_size);\n-            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n-            CRM_ASSERT(buf != NULL);\n-\n-        } else if (buf[len + rc - 1] != 0) {\n-            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n-            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n-            len += rc;\n-            buf = realloc(buf, len + chunk_size);\n-            CRM_ASSERT(buf != NULL);\n+            \/* always null terminate buffer, the +1 to alloc always allows for this.*\/\n+            buf[len] = '\\0';\n+        }\n+        if (max_size && (max_size == read_size)) {\n+            crm_trace(\"Buffer max read size %d met\" , max_size);\n+            goto done;\n+        }\n \n-        } else {\n-            crm_trace(\"Got %d more bytes\", (int)rc);\n-            return buf;\n+        \/* process any errors. *\/\n+        if (rc == GNUTLS_E_INTERRUPTED) {\n+            crm_trace(\"EINTR encoutered, retry tls read\");\n+        } else if (rc == GNUTLS_E_AGAIN) {\n+            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n+            goto done;\n+        } else if (rc <= 0) {\n+            if (rc == 0) {\n+                crm_debug(\"EOF encoutered during TLS read\");\n+            } else {\n+                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n+            }\n+            if (disconnected) {\n+                *disconnected = 1;\n+            }\n+            goto done;\n         }\n     }\n-  bail:\n-    free(buf);\n-    return NULL;\n+\n+done:\n+    if (recv_len) {\n+        *recv_len = len;\n+    }\n+    if (!len) {\n+        free(buf);\n+        buf = NULL;\n+    }\n+    return buf;\n \n }\n #endif\n \n-char *\n-cib_send_plaintext(int sock, xmlNode * msg)\n+static int\n+crm_send_plaintext(int sock, const char *buf, size_t len)\n {\n-    char *xml_text = dump_xml_unformatted(msg);\n \n-    if (xml_text != NULL) {\n-        int rc = 0;\n-        char *unsent = xml_text;\n-        int len = strlen(xml_text);\n+    int rc = 0;\n+    const char *unsent = buf;\n+    int total_send;\n \n-        len++;                  \/* null char *\/\n-        crm_trace(\"Message on socket %d: size=%d\", sock, len);\n-  retry:\n-        rc = write(sock, unsent, len);\n-        if (rc < 0) {\n-            switch (errno) {\n-                case EINTR:\n-                case EAGAIN:\n-                    crm_trace(\"Retry\");\n-                    goto retry;\n-                default:\n-                    crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, len);\n-                    break;\n-            }\n+    if (buf == NULL) {\n+        return -1;\n+    }\n+    total_send = len;\n \n-        } else if (rc < len) {\n-            crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n-            len -= rc;\n-            unsent += rc;\n+    crm_trace(\"Message on socket %d: size=%d\", sock, len);\n+  retry:\n+    rc = write(sock, unsent, len);\n+    if (rc < 0) {\n+        switch (errno) {\n+        case EINTR:\n+        case EAGAIN:\n+            crm_trace(\"Retry\");\n             goto retry;\n-\n-        } else {\n-            crm_trace(\"Sent %d bytes: %.100s\", rc, xml_text);\n+        default:\n+            crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, (int) len);\n+            break;\n         }\n+\n+    } else if (rc < len) {\n+        crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n+        len -= rc;\n+        unsent += rc;\n+        goto retry;\n+\n+     } else {\n+        crm_trace(\"Sent %d bytes: %.100s\", rc, buf);\n     }\n-    free(xml_text);\n-    return NULL;\n+\n+    return rc < 0 ? rc : total_send;\n \n }\n \n-char *\n-cib_recv_plaintext(int sock)\n+\/*!\n+ * \\internal\n+ * \\brief Read bytes off non blocking socket.\n+ *\n+ * \\param session - tls session to read\n+ * \\param max_size - max bytes allowed to read for buffer. 0 assumes no limit\n+ *\n+ * \\note only use with NON-Blocking sockets. Should only be used after polling socket.\n+ *       This function will return once max_size is met, the socket read buffer\n+ *       is empty, or an error is encountered.\n+ *\n+ * \\retval '\\0' terminated buffer on success\n+ *\/\n+static char *\n+crm_recv_plaintext(int sock, size_t max_size, size_t *recv_len, int *disconnected)\n {\n     char *buf = NULL;\n-\n     ssize_t rc = 0;\n     ssize_t len = 0;\n-    ssize_t chunk_size = 512;\n+    ssize_t chunk_size = max_size ? max_size : 1024;\n+    size_t buf_size = 0;\n+    size_t read_size = 0;\n \n-    buf = calloc(1, chunk_size);\n+    if (sock <= 0) {\n+        if (disconnected) {\n+            *disconnected = 1;\n+        }\n+        goto done;\n+    }\n \n-    while (1) {\n-        errno = 0;\n-        rc = read(sock, buf + len, chunk_size);\n-        crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n-\n-        if (errno == EINTR || errno == EAGAIN) {\n-            crm_trace(\"Retry: %d\", (int)rc);\n-            if (rc > 0) {\n-                len += rc;\n-                buf = realloc(buf, len + chunk_size);\n-                CRM_ASSERT(buf != NULL);\n-            }\n+    buf = calloc(1, chunk_size + 1);\n+    buf_size = chunk_size;\n \n-        } else if (rc < 0) {\n-            crm_perror(LOG_ERR, \"Error receiving message: %d\", (int)rc);\n-            goto bail;\n+    while (TRUE) {\n+        errno = 0;\n+        read_size = buf_size - len;\n \n-        } else if (rc == chunk_size) {\n-            len += rc;\n-            chunk_size *= 2;\n-            buf = realloc(buf, len + chunk_size);\n-            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n+        \/* automatically grow the buffer when needed if max_size is not set.*\/\n+        if (!max_size && (read_size < (chunk_size \/ 2))) {\n+            buf_size += chunk_size;\n+            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n+            buf = realloc(buf, buf_size + 1);\n             CRM_ASSERT(buf != NULL);\n \n-        } else if (buf[len + rc - 1] != 0) {\n-            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n-            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n+            read_size = buf_size - len;\n+        }\n+\n+        rc = read(sock, buf + len, chunk_size);\n+\n+        if (rc > 0) {\n+            crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n             len += rc;\n-            buf = realloc(buf, len + chunk_size);\n-            CRM_ASSERT(buf != NULL);\n+            \/* always null terminate buffer, the +1 to alloc always allows for this.*\/\n+            buf[len] = '\\0';\n+        }\n+        if (max_size && (max_size == read_size)) {\n+            crm_trace(\"Buffer max read size %d met\" , max_size);\n+            goto done;\n+        }\n \n-        } else {\n-            return buf;\n+        if (rc > 0) {\n+            continue;\n+        } else if (rc == 0) {\n+            if (disconnected) {\n+                *disconnected = 1;\n+            }\n+            crm_trace(\"EOF encoutered during read\");\n+            goto done;\n+        }\n+\n+        \/* process errors *\/\n+        if (errno == EINTR) {\n+            crm_trace(\"EINTER encoutered, retry socket read.\");\n+        } else if (errno == EAGAIN) {\n+            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n+            goto done;\n+        } else if (errno <= 0) {\n+            if (disconnected) {\n+                *disconnected = 1;\n+            }\n+            crm_debug(\"Error receiving message: %d\", (int)rc);\n+            goto done;\n         }\n     }\n-  bail:\n-    free(buf);\n-    return NULL;\n \n+done:\n+    if (recv_len) {\n+        *recv_len = len;\n+    }\n+    if (!len) {\n+        free(buf);\n+        buf = NULL;\n+    }\n+    return buf;\n }\n \n-void\n-crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n+static int\n+crm_send_remote_msg_raw(void *session, const char *buf, size_t len, gboolean encrypted)\n {\n+    int rc = -1;\n     if (encrypted) {\n #ifdef HAVE_GNUTLS_GNUTLS_H\n-        cib_send_tls(session, msg);\n+        rc = crm_send_tls(session, buf, len);\n #else\n         CRM_ASSERT(encrypted == FALSE);\n #endif\n     } else {\n-        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n+        rc = crm_send_plaintext(GPOINTER_TO_INT(session), buf, len);\n     }\n+    return rc;\n }\n \n+int\n+crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n+{\n+    int rc = -1;\n+    char *xml_text = NULL;\n+    int len = 0;\n+\n+    xml_text = dump_xml_unformatted(msg);\n+    if (xml_text) {\n+        len = strlen(xml_text);\n+    } else {\n+        crm_err(\"Invalid XML, can not send msg\");\n+        return -1;\n+    }\n+\n+    rc = crm_send_remote_msg_raw(session, xml_text, len, encrypted);\n+    if (rc < 0) {\n+        goto done;\n+    }\n+    rc = crm_send_remote_msg_raw(session, REMOTE_MSG_TERMINATOR, strlen(REMOTE_MSG_TERMINATOR), encrypted);\n+\n+done:\n+    if (rc < 0) {\n+        crm_err(\"Failed to send remote msg, rc = %d\", rc);\n+    }\n+\n+    free(xml_text);\n+    return rc;\n+}\n+\n+\/*!\n+ * \\internal\n+ * \\brief handles the recv buffer and parsing out msgs.\n+ * \\note new_data is owned by this function once it is passed in.\n+ *\/\n xmlNode *\n-crm_recv_remote_msg(void *session, gboolean encrypted)\n+crm_parse_remote_buffer(char **msg_buf)\n {\n-    char *reply = NULL;\n+    char *buf = NULL;\n+    char *start = NULL;\n+    char *end = NULL;\n     xmlNode *xml = NULL;\n \n+    if (*msg_buf == NULL) {\n+        return NULL;\n+    }\n+\n+    \/* take ownership of the buffer *\/\n+    buf = *msg_buf;\n+    *msg_buf = NULL;\n+\n+    \/* MSGS are separated by a '\\r\\n\\r\\n'. Split a message off the buffer and return it. *\/\n+    start = buf;\n+    end = strstr(start, REMOTE_MSG_TERMINATOR);\n+\n+    while (!xml && end) {\n+\n+        \/* grab the message *\/\n+        end[0] = '\\0';\n+        end += strlen(REMOTE_MSG_TERMINATOR);\n+\n+        xml = string2xml(start);\n+        if (xml == NULL) {\n+            crm_err(\"Couldn't parse: '%.120s'\", start);\n+        }\n+        start = end;\n+        end = strstr(start, REMOTE_MSG_TERMINATOR);\n+    }\n+\n+    if (xml && start) {\n+        \/* we have msgs left over, save it until next time *\/\n+        *msg_buf = strdup(start);\n+        free(buf);\n+    } else if (!xml) {\n+        \/* no msg present *\/\n+        *msg_buf = buf;\n+    }\n+\n+    return xml;\n+}\n+\n+\/*!\n+ * \\internal\n+ * \\brief Determine if a remote session has data to read\n+ *\n+ * \\retval 0, timeout occured.\n+ * \\retval positive, data is ready to be read\n+ * \\retval negative, session has ended\n+ *\/\n+int\n+crm_recv_remote_ready(void *session, gboolean encrypted, int timeout \/* ms *\/)\n+{\n+    struct pollfd fds = { 0, };\n+    int sock = 0;\n+    void *sock_ptr = NULL;\n+    int rc = 0;\n+    time_t start;\n+\n+    if (encrypted) {\n+#ifdef HAVE_GNUTLS_GNUTLS_H\n+        gnutls_session *tls_session = session;\n+        sock_ptr = gnutls_transport_get_ptr(*tls_session);\n+#else\n+        CRM_ASSERT(encrypted == FALSE);\n+#endif\n+    } else {\n+        sock_ptr = session;\n+    }\n+\n+    sock = GPOINTER_TO_INT(sock_ptr);\n+    if (sock <= 0) {\n+        return -ENOTCONN;\n+    }\n+\n+    start = time(NULL);\n+    errno = 0;\n+    do {\n+        fds.fd = sock;\n+        fds.events = POLLIN;\n+\n+        \/* If we got an EINTR while polling, and we have a\n+         * specific timeout we are trying to honor, attempt\n+         * to adjust the timeout to the closest second. *\/\n+        if (errno == EINTR && (timeout > 0)) {\n+            timeout = timeout - ((time(NULL) - start) * 1000);\n+            if (timeout < 1000) {\n+                timeout = 1000;\n+            }\n+        }\n+\n+        rc = poll(&fds, 1, timeout);\n+    } while (rc < 0 && errno == EINTR);\n+\n+    return rc;\n+}\n+\n+char *\n+crm_recv_remote_raw(void *session, gboolean encrypted, size_t max_recv, size_t *recv_len, int *disconnected)\n+{\n+    char *reply = NULL;\n+    if (recv_len) {\n+        *recv_len = 0;\n+    }\n+\n+    if (disconnected) {\n+        *disconnected = 0;\n+    }\n+\n     if (encrypted) {\n #ifdef HAVE_GNUTLS_GNUTLS_H\n-        reply = cib_recv_tls(session);\n+        reply = crm_recv_tls(session, max_recv, recv_len, disconnected);\n #else\n         CRM_ASSERT(encrypted == FALSE);\n #endif\n     } else {\n-        reply = cib_recv_plaintext(GPOINTER_TO_INT(session));\n+        reply = crm_recv_plaintext(GPOINTER_TO_INT(session), max_recv, recv_len, disconnected);\n     }\n     if (reply == NULL || strlen(reply) == 0) {\n         crm_trace(\"Empty reply\");\n+    }\n \n-    } else {\n-        xml = string2xml(reply);\n-        if (xml == NULL) {\n-            crm_err(\"Couldn't parse: '%.120s'\", reply);\n+    return reply;\n+}\n+\n+\/*!\n+ * \\internal\n+ * \\brief Read data off the socket until at least one full message is present or timeout occures.\n+ * \\retval TRUE message read\n+ * \\retval FALSE full message not read\n+ *\/\n+\n+gboolean\n+crm_recv_remote_msg(void *session, char **recv_buf, gboolean encrypted, int total_timeout \/*ms *\/, int *disconnected)\n+{\n+    int ret;\n+    size_t request_len = 0;\n+    time_t start = time(NULL);\n+    char *raw_request = NULL;\n+    int remaining_timeout = 0;\n+\n+    if (total_timeout == 0) {\n+        total_timeout = 10000;\n+    } else if (total_timeout < 0) {\n+        total_timeout = 60000;\n+    }\n+    *disconnected = 0;\n+\n+    remaining_timeout = total_timeout;\n+    while ((remaining_timeout > 0) && !(*disconnected)) {\n+\n+        \/* read some more off the tls buffer if we still have time left. *\/\n+        crm_trace(\"waiting to receive remote msg, starting timeout %d, remaining_timeout %d\", total_timeout, remaining_timeout);\n+        ret = crm_recv_remote_ready(session, encrypted, remaining_timeout);\n+        raw_request = NULL;\n+\n+        if (ret == 0) {\n+            crm_err(\"poll timed out (%d ms) while waiting to receive msg\", remaining_timeout);\n+            return FALSE;\n+\n+        } else if (ret < 0) {\n+            if (errno != EINTR) {\n+                crm_debug(\"poll returned error while waiting for msg, rc: %d, errno: %d\", ret, errno);\n+                *disconnected = 1;\n+                return FALSE;\n+            }\n+            crm_debug(\"poll EINTR encountered during poll, retrying\");\n+        } else {\n+            raw_request = crm_recv_remote_raw(session, encrypted, 0, &request_len, disconnected);\n+        }\n+\n+        remaining_timeout = remaining_timeout - ((time(NULL) - start) * 1000);\n+\n+        if (!raw_request) {\n+            crm_debug(\"Empty msg received after poll\");\n+            continue;\n+        }\n+\n+        if (*recv_buf) {\n+            int old_len = strlen(*recv_buf);\n+\n+            crm_trace(\"Expanding recv buffer from %d to %d\", old_len, old_len+request_len);\n+\n+            *recv_buf = realloc(*recv_buf, old_len + request_len + 1);\n+            memcpy(*recv_buf + old_len, raw_request, request_len);\n+            *(*recv_buf+old_len+request_len) = '\\0';\n+            free(raw_request);\n+        } else {\n+            *recv_buf = raw_request;\n+        }\n+\n+        if (strstr(*recv_buf, REMOTE_MSG_TERMINATOR)) {\n+            return TRUE;\n         }\n     }\n \n-    free(reply);\n-    return xml;\n+    return FALSE;\n }\n+\n+\/*!\n+ * \\internal\n+ * \\brief tcp connection to server at specified port\n+ * \\retval positive, socket fd.\n+ * \\retval negative, failed to connect.\n+ *\/\n+int\n+crm_remote_tcp_connect(const char *host, int port)\n+{\n+    struct addrinfo *res;\n+    struct addrinfo *rp;\n+    struct addrinfo hints;\n+    const char *server = host;\n+    int ret_ga;\n+    int sock;\n+\n+    \/* getaddrinfo *\/\n+    memset(&hints, 0, sizeof(struct addrinfo));\n+    hints.ai_family = AF_UNSPEC;    \/* Allow IPv4 or IPv6 *\/\n+    hints.ai_socktype = SOCK_STREAM;\n+    hints.ai_flags = AI_CANONNAME;\n+\n+    crm_debug(\"Looking up %s\", server);\n+    ret_ga = getaddrinfo(server, NULL, &hints, &res);\n+    if (ret_ga) {\n+        crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));\n+        return -1;\n+    }\n+\n+    if (!res || !res->ai_addr) {\n+        crm_err(\"getaddrinfo failed\");\n+        return -1;\n+    }\n+\n+    for (rp = res; rp != NULL; rp = rp->ai_next) {\n+        struct sockaddr *addr = rp->ai_addr;\n+        int flag = 0;\n+        if (!addr) {\n+            continue;\n+        }\n+\n+        if (rp->ai_canonname) {\n+            server = res->ai_canonname;\n+        }\n+        crm_debug(\"Got address %s for %s\", server, host);\n+\n+        \/* create socket *\/\n+        sock = socket(rp->ai_family, SOCK_STREAM, IPPROTO_TCP);\n+        if (sock == -1) {\n+            crm_err(\"Socket creation failed for remote client connection.\");\n+            continue;\n+        }\n+        if (addr->sa_family == AF_INET6) {\n+            struct sockaddr_in6 *addr_in = (struct sockaddr_in6 *) addr;\n+            addr_in->sin6_port = htons(port);\n+        } else {\n+            struct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n+            addr_in->sin_port = htons(port);\n+            crm_info(\"Attempting to connect to remote server at %s:%d\", inet_ntoa(addr_in->sin_addr), port);\n+        }\n+\n+        if (connect(sock, rp->ai_addr, rp->ai_addrlen) == 0) {\n+            if ((flag = fcntl(sock, F_GETFL)) >= 0) {\n+                if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) < 0) {\n+                    crm_err( \"fcntl() write failed\");\n+                    close(sock);\n+                    sock = -1;\n+                    continue;\n+                }\n+            }\n+            break;                  \/* Success *\/\n+        }\n+\n+        close(sock);\n+        sock = -1;\n+    }\n+    freeaddrinfo(res);\n+\n+    return sock;\n+}\n+\ndiff --git a\/tools\/crm_mon.c b\/tools\/crm_mon.c\nindex 5c2e68722a..fe592649fc 100644\n--- a\/tools\/crm_mon.c\n+++ b\/tools\/crm_mon.c\n@@ -275,7 +275,7 @@ cib_connect(gboolean full)\n             if (rc == pcmk_ok) {\n                 rc = cib->cmds->set_connection_dnotify(cib, mon_cib_connection_destroy);\n                 if (rc == -EPROTONOSUPPORT) {\n-                    print_as(\"Notification setup failed, won't be able to reconnect after failure\");\n+                    print_as(\"Notification setup not supported, won't be able to reconnect after failure\");\n                     if (as_console) {\n                         sleep(2);\n                     }\n","owner":"ClusterLabs","repo":"pacemaker","source":"cve"},{"CVE_ID":"CVE-2014-9718","CWE_ID":"399","category":"security","commit_id":"3251bdcf1c67427d964517053c3d185b46e618e8","commit_message":"From 3251bdcf1c67427d964517053c3d185b46e618e8 Mon Sep 17 00:00:00 2001\nFrom: John Snow <jsnow@redhat.com>\nDate: Fri, 31 Oct 2014 16:03:39 -0400\nSubject: [PATCH] ide: Correct handling of malformed\/short PRDTs\n\nThis impacts both BMDMA and AHCI HBA interfaces for IDE.\nCurrently, we confuse the difference between a PRDT having\n\"0 bytes\" and a PRDT having \"0 complete sectors.\"\n\nWhen we receive an incomplete sector, inconsistent error checking\nleads to an infinite loop wherein the call succeeds, but it\ndidn't give us enough bytes -- leading us to re-call the\nDMA chain over and over again. This leads to, in the BMDMA case,\nleaked memory for short PRDTs, and infinite loops and resource\nusage in the AHCI case.\n\nThe .prepare_buf() callback is reworked to return the number of\nbytes that it successfully prepared. 0 is a valid, non-error\nanswer that means the table was empty and described no bytes.\n-1 indicates an error.\n\nOur current implementation uses the io_buffer in IDEState to\nultimately describe the size of a prepared scatter-gather list.\nEven though the AHCI PRDT\/SGList can be as large as 256GiB, the\nAHCI command header limits transactions to just 4GiB. ATA8-ACS3,\nhowever, defines the largest transaction to be an LBA48 command\nthat transfers 65,536 sectors. With a 512 byte sector size, this\nis just 32MiB.\n\nSince our current state structures use the int type to describe\nthe size of the buffer, and this state is migrated as int32, we\nare limited to describing 2GiB buffer sizes unless we change the\nmigration protocol.\n\nFor this reason, this patch begins to unify the assertions in the\nIDE pathways that the scatter-gather list provided by either the\nAHCI PRDT or the PCI BMDMA PRDs can only describe, at a maximum,\n2GiB. This should be resilient enough unless we need a sector\nsize that exceeds 32KiB.\n\nFurther, the likelihood of any guest operating system actually\nattempting to transfer this much data in a single operation is\nvery slim.\n\nTo this end, the IDEState variables have been updated to more\nexplicitly clarify our maximum supported size. Callers to the\nprepare_buf callback have been reworked to understand the new\nreturn code, and all versions of the prepare_buf callback have\nbeen adjusted accordingly.\n\nLastly, the ahci_populate_sglist helper, relied upon by the\nAHCI implementation of .prepare_buf() as well as the PCI\nimplementation of the callback have had overflow assertions\nadded to help make clear the reasonings behind the various\ntype changes.\n\n[Added %d -> %\"PRId64\" fix John sent because off_pos changed from int to\nint64_t.\n--Stefan]\n\nSigned-off-by: John Snow <jsnow@redhat.com>\nReviewed-by: Paolo Bonzini <pbonzini@redhat.com>\nMessage-id: 1414785819-26209-4-git-send-email-jsnow@redhat.com\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\n---\n hw\/ide\/ahci.c     | 33 ++++++++++++++++++++++++++-------\n hw\/ide\/core.c     | 10 ++++++++--\n hw\/ide\/internal.h | 13 +++++++------\n hw\/ide\/macio.c    |  7 ++++++-\n hw\/ide\/pci.c      | 27 +++++++++++++++++++++------\n 5 files changed, 68 insertions(+), 22 deletions(-)\n\n","diff_code":"diff --git a\/hw\/ide\/ahci.c b\/hw\/ide\/ahci.c\nindex 28aa105..9647d94 100644\n--- a\/hw\/ide\/ahci.c\n+++ b\/hw\/ide\/ahci.c\n@@ -730,7 +730,8 @@ static int prdt_tbl_entry_size(const AHCI_SG *tbl)\n     return (le32_to_cpu(tbl->flags_size) & AHCI_PRDT_SIZE_MASK) + 1;\n }\n \n-static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n+static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,\n+                                int32_t offset)\n {\n     AHCICmdHdr *cmd = ad->cur_cmd;\n     uint32_t opts = le32_to_cpu(cmd->opts);\n@@ -741,13 +742,21 @@ static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n     uint8_t *prdt;\n     int i;\n     int r = 0;\n-    int sum = 0;\n+    uint64_t sum = 0;\n     int off_idx = -1;\n-    int off_pos = -1;\n+    int64_t off_pos = -1;\n     int tbl_entry_size;\n     IDEBus *bus = &ad->port;\n     BusState *qbus = BUS(bus);\n \n+    \/*\n+     * Note: AHCI PRDT can describe up to 256GiB. SATA\/ATA only support\n+     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a\n+     * 512 byte sector size. We limit the PRDT in this implementation to\n+     * a reasonably large 2GiB, which can accommodate the maximum transfer\n+     * request for sector sizes up to 32K.\n+     *\/\n+\n     if (!sglist_alloc_hint) {\n         DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n         return -1;\n@@ -782,7 +791,7 @@ static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n         }\n         if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n             DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n-                            \"off_idx: %d, off_pos: %d\\n\",\n+                            \"off_idx: %d, off_pos: %\"PRId64\"\\n\",\n                             __func__, off_idx, off_pos);\n             r = -1;\n             goto out;\n@@ -797,6 +806,13 @@ static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n             \/* flags_size is zero-based *\/\n             qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n                             prdt_tbl_entry_size(&tbl[i]));\n+            if (sglist->size > INT32_MAX) {\n+                error_report(\"AHCI Physical Region Descriptor Table describes \"\n+                             \"more than 2 GiB.\\n\");\n+                qemu_sglist_destroy(sglist);\n+                r = -1;\n+                goto out;\n+            }\n         }\n     }\n \n@@ -1140,16 +1156,19 @@ static void ahci_start_dma(IDEDMA *dma, IDEState *s,\n  * Not currently invoked by PIO R\/W chains,\n  * which invoke ahci_populate_sglist via ahci_start_transfer.\n  *\/\n-static int ahci_dma_prepare_buf(IDEDMA *dma, int is_write)\n+static int32_t ahci_dma_prepare_buf(IDEDMA *dma, int is_write)\n {\n     AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n     IDEState *s = &ad->port.ifs[0];\n \n-    ahci_populate_sglist(ad, &s->sg, s->io_buffer_offset);\n+    if (ahci_populate_sglist(ad, &s->sg, s->io_buffer_offset) == -1) {\n+        DPRINTF(ad->port_no, \"ahci_dma_prepare_buf failed.\\n\");\n+        return -1;\n+    }\n     s->io_buffer_size = s->sg.size;\n \n     DPRINTF(ad->port_no, \"len=%#x\\n\", s->io_buffer_size);\n-    return s->io_buffer_size != 0;\n+    return s->io_buffer_size;\n }\n \n \/**\ndiff --git a\/hw\/ide\/core.c b\/hw\/ide\/core.c\nindex dab21f0..00e21cf 100644\n--- a\/hw\/ide\/core.c\n+++ b\/hw\/ide\/core.c\n@@ -731,10 +731,11 @@ void ide_dma_cb(void *opaque, int ret)\n     n = s->nsector;\n     s->io_buffer_index = 0;\n     s->io_buffer_size = n * 512;\n-    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) {\n+    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) < 512) {\n         \/* The PRDs were too short. Reset the Active bit, but don't raise an\n          * interrupt. *\/\n         s->status = READY_STAT | SEEK_STAT;\n+        dma_buf_commit(s, 0);\n         goto eot;\n     }\n \n@@ -2313,12 +2314,17 @@ static int ide_nop_int(IDEDMA *dma, int x)\n     return 0;\n }\n \n+static int32_t ide_nop_int32(IDEDMA *dma, int x)\n+{\n+    return 0;\n+}\n+\n static void ide_nop_restart(void *opaque, int x, RunState y)\n {\n }\n \n static const IDEDMAOps ide_dma_nop_ops = {\n-    .prepare_buf    = ide_nop_int,\n+    .prepare_buf    = ide_nop_int32,\n     .rw_buf         = ide_nop_int,\n     .set_unit       = ide_nop_int,\n     .restart_cb     = ide_nop_restart,\ndiff --git a\/hw\/ide\/internal.h b\/hw\/ide\/internal.h\nindex 907493d..8a3eca4 100644\n--- a\/hw\/ide\/internal.h\n+++ b\/hw\/ide\/internal.h\n@@ -322,6 +322,7 @@ typedef void EndTransferFunc(IDEState *);\n typedef void DMAStartFunc(IDEDMA *, IDEState *, BlockCompletionFunc *);\n typedef void DMAVoidFunc(IDEDMA *);\n typedef int DMAIntFunc(IDEDMA *, int);\n+typedef int32_t DMAInt32Func(IDEDMA *, int);\n typedef void DMAu32Func(IDEDMA *, uint32_t);\n typedef void DMAStopFunc(IDEDMA *, bool);\n typedef void DMARestartFunc(void *, int, RunState);\n@@ -385,7 +386,7 @@ struct IDEState {\n     uint8_t cdrom_changed;\n     int packet_transfer_size;\n     int elementary_transfer_size;\n-    int io_buffer_index;\n+    int32_t io_buffer_index;\n     int lba;\n     int cd_sector_size;\n     int atapi_dma; \/* true if dma is requested for the packet cmd *\/\n@@ -394,8 +395,8 @@ struct IDEState {\n     struct iovec iov;\n     QEMUIOVector qiov;\n     \/* ATA DMA state *\/\n-    int io_buffer_offset;\n-    int io_buffer_size;\n+    int32_t io_buffer_offset;\n+    int32_t io_buffer_size;\n     QEMUSGList sg;\n     \/* PIO transfer handling *\/\n     int req_nb_sectors; \/* number of sectors per interrupt *\/\n@@ -405,8 +406,8 @@ struct IDEState {\n     uint8_t *io_buffer;\n     \/* PIO save\/restore *\/\n     int32_t io_buffer_total_len;\n-    int cur_io_buffer_offset;\n-    int cur_io_buffer_len;\n+    int32_t cur_io_buffer_offset;\n+    int32_t cur_io_buffer_len;\n     uint8_t end_transfer_fn_idx;\n     QEMUTimer *sector_write_timer; \/* only used for win2k install hack *\/\n     uint32_t irq_count; \/* counts IRQs when using win2k install hack *\/\n@@ -430,7 +431,7 @@ struct IDEState {\n struct IDEDMAOps {\n     DMAStartFunc *start_dma;\n     DMAVoidFunc *start_transfer;\n-    DMAIntFunc *prepare_buf;\n+    DMAInt32Func *prepare_buf;\n     DMAu32Func *commit_buf;\n     DMAIntFunc *rw_buf;\n     DMAIntFunc *set_unit;\ndiff --git a\/hw\/ide\/macio.c b\/hw\/ide\/macio.c\nindex 9a55407..f6074f2 100644\n--- a\/hw\/ide\/macio.c\n+++ b\/hw\/ide\/macio.c\n@@ -553,6 +553,11 @@ static int ide_nop_int(IDEDMA *dma, int x)\n     return 0;\n }\n \n+static int32_t ide_nop_int32(IDEDMA *dma, int x)\n+{\n+    return 0;\n+}\n+\n static void ide_nop_restart(void *opaque, int x, RunState y)\n {\n }\n@@ -569,7 +574,7 @@ static void ide_dbdma_start(IDEDMA *dma, IDEState *s,\n \n static const IDEDMAOps dbdma_ops = {\n     .start_dma      = ide_dbdma_start,\n-    .prepare_buf    = ide_nop_int,\n+    .prepare_buf    = ide_nop_int32,\n     .rw_buf         = ide_nop_int,\n     .set_unit       = ide_nop_int,\n     .restart_cb     = ide_nop_restart,\ndiff --git a\/hw\/ide\/pci.c b\/hw\/ide\/pci.c\nindex 2dad50e..bee5ad3 100644\n--- a\/hw\/ide\/pci.c\n+++ b\/hw\/ide\/pci.c\n@@ -28,7 +28,7 @@\n #include <hw\/isa\/isa.h>\n #include \"sysemu\/block-backend.h\"\n #include \"sysemu\/dma.h\"\n-\n+#include \"qemu\/error-report.h\"\n #include <hw\/ide\/pci.h>\n \n #define BMDMA_PAGE_SIZE 4096\n@@ -55,8 +55,11 @@ static void bmdma_start_dma(IDEDMA *dma, IDEState *s,\n     }\n }\n \n-\/* return 0 if buffer completed *\/\n-static int bmdma_prepare_buf(IDEDMA *dma, int is_write)\n+\/**\n+ * Return the number of bytes successfully prepared.\n+ * -1 on error.\n+ *\/\n+static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)\n {\n     BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n     IDEState *s = bmdma_active_if(bm);\n@@ -74,8 +77,9 @@ static int bmdma_prepare_buf(IDEDMA *dma, int is_write)\n         if (bm->cur_prd_len == 0) {\n             \/* end of table (with a fail safe of one page) *\/\n             if (bm->cur_prd_last ||\n-                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE)\n-                return s->io_buffer_size != 0;\n+                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {\n+                return s->io_buffer_size;\n+            }\n             pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);\n             bm->cur_addr += 8;\n             prd.addr = le32_to_cpu(prd.addr);\n@@ -90,12 +94,23 @@ static int bmdma_prepare_buf(IDEDMA *dma, int is_write)\n         l = bm->cur_prd_len;\n         if (l > 0) {\n             qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n+\n+            \/* Note: We limit the max transfer to be 2GiB.\n+             * This should accommodate the largest ATA transaction\n+             * for LBA48 (65,536 sectors) and 32K sector sizes. *\/\n+            if (s->sg.size > INT32_MAX) {\n+                error_report(\"IDE: sglist describes more than 2GiB.\\n\");\n+                break;\n+            }\n             bm->cur_prd_addr += l;\n             bm->cur_prd_len -= l;\n             s->io_buffer_size += l;\n         }\n     }\n-    return 1;\n+\n+    qemu_sglist_destroy(&s->sg);\n+    s->io_buffer_size = 0;\n+    return -1;\n }\n \n \/* return 0 if buffer completed *\/\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-5366","CWE_ID":"399","category":"security","commit_id":"beb39db59d14990e401e235faf66a6b9b31240b0","commit_message":"From beb39db59d14990e401e235faf66a6b9b31240b0 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Sat, 30 May 2015 09:16:53 -0700\nSubject: [PATCH] udp: fix behavior of wrong checksums\n\nWe have two problems in UDP stack related to bogus checksums :\n\n1) We return -EAGAIN to application even if receive queue is not empty.\n   This breaks applications using edge trigger epoll()\n\n2) Under UDP flood, we can loop forever without yielding to other\n   processes, potentially hanging the host, especially on non SMP.\n\nThis patch is an attempt to make things better.\n\nWe might in the future add extra support for rt applications\nwanting to better control time spent doing a recv() in a hostile\nenvironment. For example we could validate checksums before queuing\npackets in socket receive queue.\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Willem de Bruijn <willemb@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/udp.c | 6 ++----\n net\/ipv6\/udp.c | 6 ++----\n 2 files changed, 4 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/udp.c b\/net\/ipv4\/udp.c\nindex d10b7e0112ebd..1c92ea67baefe 100644\n--- a\/net\/ipv4\/udp.c\n+++ b\/net\/ipv4\/udp.c\n@@ -1345,10 +1345,8 @@ int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,\n \t}\n \tunlock_sock_fast(sk, slow);\n \n-\tif (noblock)\n-\t\treturn -EAGAIN;\n-\n-\t\/* starting over for a new packet *\/\n+\t\/* starting over for a new packet, but check if we need to yield *\/\n+\tcond_resched();\n \tmsg->msg_flags &= ~MSG_TRUNC;\n \tgoto try_again;\n }\ndiff --git a\/net\/ipv6\/udp.c b\/net\/ipv6\/udp.c\nindex c2ec41617a354..e51fc3eee6dbd 100644\n--- a\/net\/ipv6\/udp.c\n+++ b\/net\/ipv6\/udp.c\n@@ -525,10 +525,8 @@ int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n \t}\n \tunlock_sock_fast(sk, slow);\n \n-\tif (noblock)\n-\t\treturn -EAGAIN;\n-\n-\t\/* starting over for a new packet *\/\n+\t\/* starting over for a new packet, but check if we need to yield *\/\n+\tcond_resched();\n \tmsg->msg_flags &= ~MSG_TRUNC;\n \tgoto try_again;\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-11523","CWE_ID":"399","category":"security","commit_id":"83e0f8ffd7eeb7661b0ff83257da23d24ca7f078","commit_message":"From 83e0f8ffd7eeb7661b0ff83257da23d24ca7f078 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Wed, 19 Jul 2017 13:14:22 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/591\n\n---\n coders\/txt.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/coders\/txt.c b\/coders\/txt.c\nindex c3d37fff69..16e7ac2e94 100644\n--- a\/coders\/txt.c\n+++ b\/coders\/txt.c\n@@ -563,6 +563,12 @@ static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           break;\n       }\n     }\n+    if (EOFBlob(image) != MagickFalse)\n+      {\n+        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n+          image->filename);\n+        break;\n+      }\n     (void) ReadBlobString(image,text);\n     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n       {\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2010-3443","CWE_ID":"399","category":"security","commit_id":"a4ca568cdf68cf4a0343eb161518dc8e50cea87d","commit_message":"From a4ca568cdf68cf4a0343eb161518dc8e50cea87d Mon Sep 17 00:00:00 2001\nFrom: Marcus Eggenberger <egs@quassel-irc.org>\nDate: Sun, 5 Sep 2010 21:41:19 +0200\nSubject: [PATCH] Fixing issues with multiple CTCP requests in one message\n\n If we receive multiple CTCP requests in one PRIVMSG we now answer with\n one packed NOTICE containing all CTCP replies. This fixes a possible\n DoS Attack rendering Quassels IRC connection useless. Upgrading is\n strongly recommended. Thanks to Jima for reporting and supporting.\n---\n src\/core\/ctcphandler.cpp | 71 ++++++++++++++++++++++++++--------------\n src\/core\/ctcphandler.h   | 12 ++++---\n 2 files changed, 53 insertions(+), 30 deletions(-)\n\n","diff_code":"diff --git a\/src\/core\/ctcphandler.cpp b\/src\/core\/ctcphandler.cpp\nindex 655f17004..758d2ef14 100644\n--- a\/src\/core\/ctcphandler.cpp\n+++ b\/src\/core\/ctcphandler.cpp\n@@ -129,6 +129,7 @@ void CtcpHandler::parse(Message::Type messageType, const QString &prefix, const\n   int xdelimPos = -1;\n   int xdelimEndPos = -1;\n   int spacePos = -1;\n+  QList<QByteArray> replies;\n   while((xdelimPos = dequotedMessage.indexOf(XDELIM)) != -1) {\n     if(xdelimPos > 0)\n       displayMsg(messageType, target, userDecode(target, dequotedMessage.left(xdelimPos)), prefix, flags);\n@@ -154,7 +155,16 @@ void CtcpHandler::parse(Message::Type messageType, const QString &prefix, const\n       ctcpparam = QString();\n     }\n \n-    handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam));\n+    if(!_ignoreListManager->ctcpMatch(prefix, network()->networkName(), ctcpcmd.toUpper())) {\n+      QString reply_;\n+      handle(ctcpcmd, Q_ARG(CtcpType, ctcptype), Q_ARG(QString, prefix), Q_ARG(QString, target), Q_ARG(QString, ctcpparam), Q_ARG(QString, reply_));\n+      if(ctcptype == CtcpQuery && !reply_.isNull()) {\n+        replies << lowLevelQuote(pack(serverEncode(ctcpcmd), userEncode(nickFromMask(prefix), reply_)));\n+      }\n+    }\n+  }\n+  if(ctcptype == CtcpQuery && !replies.isEmpty()) {\n+    packedReply(nickFromMask(prefix), replies);\n   }\n \n   if(!dequotedMessage.isEmpty())\n@@ -180,20 +190,39 @@ void CtcpHandler::reply(const QString &bufname, const QString &ctcpTag, const QS\n   emit putCmd(\"NOTICE\", params);\n }\n \n+void CtcpHandler::packedReply(const QString &bufname, const QList<QByteArray> &replies) {\n+  QList<QByteArray> params;\n+\n+  int answerSize = 0;\n+  for(int i = 0; i < replies.count(); i++) {\n+    answerSize += replies.at(i).size();\n+  }\n+\n+  QByteArray quotedReply(answerSize, 0);\n+  int nextPos = 0;\n+  QByteArray &reply = quotedReply;\n+  for(int i = 0; i < replies.count(); i++) {\n+    reply = replies.at(i);\n+    quotedReply.replace(nextPos, reply.size(), reply);\n+    nextPos += reply.size();\n+  }\n+\n+  params << serverEncode(bufname) << quotedReply;\n+  emit putCmd(\"NOTICE\", params);\n+}\n+\n \/\/******************************\/\n \/\/ CTCP HANDLER\n \/\/******************************\/\n-void CtcpHandler::handleAction(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {\n+void CtcpHandler::handleAction(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &\/*reply*\/) {\n   Q_UNUSED(ctcptype)\n   emit displayMsg(Message::Action, typeByTarget(target), target, param, prefix);\n }\n \n-void CtcpHandler::handlePing(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {\n+void CtcpHandler::handlePing(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {\n   Q_UNUSED(target)\n   if(ctcptype == CtcpQuery) {\n-    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), \"PING\"))\n-      return;\n-    reply(nickFromMask(prefix), \"PING\", param);\n+    reply = param;\n     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, \"\", tr(\"Received CTCP PING request from %1\").arg(prefix));\n   } else {\n     \/\/ display ping answer\n@@ -204,14 +233,10 @@ void CtcpHandler::handlePing(CtcpType ctcptype, const QString &prefix, const QSt\n   }\n }\n \n-void CtcpHandler::handleVersion(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {\n+void CtcpHandler::handleVersion(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {\n   Q_UNUSED(target)\n   if(ctcptype == CtcpQuery) {\n-    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), \"VERSION\"))\n-      return;\n-    reply(nickFromMask(prefix), \"VERSION\", QString(\"Quassel IRC %1 (built on %2) -- http:\/\/www.quassel-irc.org\")\n-          .arg(Quassel::buildInfo().plainVersionString)\n-          .arg(Quassel::buildInfo().buildDate));\n+    reply = QString(\"Quassel IRC %1 (built on %2) -- http:\/\/www.quassel-irc.org\").arg(Quassel::buildInfo().plainVersionString).arg(Quassel::buildInfo().buildDate);\n     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, \"\", tr(\"Received CTCP VERSION request by %1\").arg(prefix));\n   } else {\n     \/\/ display Version answer\n@@ -220,28 +245,24 @@ void CtcpHandler::handleVersion(CtcpType ctcptype, const QString &prefix, const\n   }\n }\n \n-void CtcpHandler::handleTime(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {\n+void CtcpHandler::handleTime(CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {\n   Q_UNUSED(target)\n   if(ctcptype == CtcpQuery) {\n-    if(_ignoreListManager->ctcpMatch(prefix, network()->networkName(), \"TIME\"))\n-      return;\n-    reply(nickFromMask(prefix), \"TIME\", QDateTime::currentDateTime().toString());\n+    reply = QDateTime::currentDateTime().toString();\n     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, \"\", tr(\"Received CTCP TIME request by %1\").arg(prefix));\n-  }\n-  else {\n+  } else {\n     emit displayMsg(Message::Server, BufferInfo::StatusBuffer, \"\", tr(\"Received CTCP TIME answer from %1: %2\")\n                     .arg(nickFromMask(prefix)).arg(param));\n   }\n }\n \n-void CtcpHandler::defaultHandler(const QString &cmd, CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param) {\n+void CtcpHandler::defaultHandler(const QString &cmd, CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply) {\n   Q_UNUSED(ctcptype);\n   Q_UNUSED(target);\n-  if(!_ignoreListManager->ctcpMatch(prefix, network()->networkName())) {\n-    QString str = tr(\"Received unknown CTCP %1 by %2\").arg(cmd).arg(prefix);\n-    if(!param.isEmpty())\n-      str.append(tr(\" with arguments: %1\").arg(param));\n-    emit displayMsg(Message::Error, BufferInfo::StatusBuffer, \"\", str);\n-  }\n+  Q_UNUSED(reply);\n+  QString str = tr(\"Received unknown CTCP %1 by %2\").arg(cmd).arg(prefix);\n+  if(!param.isEmpty())\n+    str.append(tr(\" with arguments: %1\").arg(param));\n+  emit displayMsg(Message::Error, BufferInfo::StatusBuffer, \"\", str);\n }\n \ndiff --git a\/src\/core\/ctcphandler.h b\/src\/core\/ctcphandler.h\nindex 169ec16f4..e2f43a582 100644\n--- a\/src\/core\/ctcphandler.h\n+++ b\/src\/core\/ctcphandler.h\n@@ -48,14 +48,16 @@ public:\n   void reply(const QString &bufname, const QString &ctcpTag, const QString &message);\n \n public slots:\n-  void handleAction(CtcpType, const QString &prefix, const QString &target, const QString &param);\n-  void handlePing(CtcpType, const QString &prefix, const QString &target, const QString &param);\n-  void handleTime(CtcpType, const QString &prefix, const QString &target, const QString &param);\n-  void handleVersion(CtcpType, const QString &prefix, const QString &target, const QString &param);\n+  void handleAction(CtcpType, const QString &prefix, const QString &target, const QString &param, QString &reply);\n+  void handlePing(CtcpType, const QString &prefix, const QString &target, const QString &param, QString &reply);\n+  void handleTime(CtcpType, const QString &prefix, const QString &target, const QString &param, QString &reply);\n+  void handleVersion(CtcpType, const QString &prefix, const QString &target, const QString &param, QString &reply);\n \n-  void defaultHandler(const QString &cmd, CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param);\n+  void defaultHandler(const QString &cmd, CtcpType ctcptype, const QString &prefix, const QString &target, const QString &param, QString &reply);\n \n private:\n+  void packedReply(const QString &bufname, const QList<QByteArray> &replies);\n+\n   QByteArray XDELIM;\n   QHash<QByteArray, QByteArray> ctcpMDequoteHash;\n   QHash<QByteArray, QByteArray> ctcpXDelimDequoteHash;\n-- \n2.20.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-6304","CWE_ID":"399","category":"security","commit_id":"2c0d295e26306e15a92eb23a84a1802005c1c137","commit_message":"From 2c0d295e26306e15a92eb23a84a1802005c1c137 Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Fri, 9 Sep 2016 10:08:45 +0100\nSubject: [PATCH] Fix OCSP Status Request extension unbounded memory growth\n\nA malicious client can send an excessively large OCSP Status Request\nextension. If that client continually requests renegotiation,\nsending a large OCSP Status Request extension each time, then there will\nbe unbounded memory growth on the server. This will eventually lead to a\nDenial Of Service attack through memory exhaustion. Servers with a\ndefault configuration are vulnerable even if they do not support OCSP.\nBuilds using the \"no-ocsp\" build time option are not affected.\n\nI have also checked other extensions to see if they suffer from a similar\nproblem but I could not find any other issues.\n\nCVE-2016-6304\n\nIssue reported by Shi Lei.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n---\n ssl\/t1_lib.c | 24 +++++++++++++++++-------\n 1 file changed, 17 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/ssl\/t1_lib.c b\/ssl\/t1_lib.c\nindex 7680491340..4bc13ca5ce 100644\n--- a\/ssl\/t1_lib.c\n+++ b\/ssl\/t1_lib.c\n@@ -1284,6 +1284,23 @@ int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,\n                 size -= 2;\n                 if (dsize > size)\n                     goto err;\n+\n+                \/*\n+                 * We remove any OCSP_RESPIDs from a previous handshake\n+                 * to prevent unbounded memory growth - CVE-2016-6304\n+                 *\/\n+                sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids,\n+                                        OCSP_RESPID_free);\n+                if (dsize > 0) {\n+                    s->tlsext_ocsp_ids = sk_OCSP_RESPID_new_null();\n+                    if (s->tlsext_ocsp_ids == NULL) {\n+                        *al = SSL_AD_INTERNAL_ERROR;\n+                        return 0;\n+                    }\n+                } else {\n+                    s->tlsext_ocsp_ids = NULL;\n+                }\n+\n                 while (dsize > 0) {\n                     OCSP_RESPID *id;\n                     int idsize;\n@@ -1303,13 +1320,6 @@ int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p,\n                         OCSP_RESPID_free(id);\n                         goto err;\n                     }\n-                    if (!s->tlsext_ocsp_ids\n-                        && !(s->tlsext_ocsp_ids =\n-                             sk_OCSP_RESPID_new_null())) {\n-                        OCSP_RESPID_free(id);\n-                        *al = SSL_AD_INTERNAL_ERROR;\n-                        return 0;\n-                    }\n                     if (!sk_OCSP_RESPID_push(s->tlsext_ocsp_ids, id)) {\n                         OCSP_RESPID_free(id);\n                         *al = SSL_AD_INTERNAL_ERROR;\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-2161","CWE_ID":"399","category":"security","commit_id":"8312e3fc9041027a33c8bc667bb99740fdf41dd5","commit_message":"From 8312e3fc9041027a33c8bc667bb99740fdf41dd5 Mon Sep 17 00:00:00 2001\nFrom: Kostya <kostya.shishkov@gmail.com>\nDate: Tue, 15 Mar 2011 09:19:43 +0000\nSubject: [PATCH] Do not attempt to decode APE file with no frames\n\nThis fixes invalid reads\/writes with this sample:\nhttp:\/\/packetstorm.linuxsecurity.com\/1103-exploits\/vlc105-dos.txt\n---\n libavformat\/ape.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/libavformat\/ape.c b\/libavformat\/ape.c\nindex 6c269849fd2..dd2aeb9ff30 100644\n--- a\/libavformat\/ape.c\n+++ b\/libavformat\/ape.c\n@@ -242,6 +242,10 @@ static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n             avio_seek(pb, ape->wavheaderlength, SEEK_CUR);\n     }\n \n+    if(!ape->totalframes){\n+        av_log(s, AV_LOG_ERROR, \"No frames in the file!\\n\");\n+        return AVERROR(EINVAL);\n+    }\n     if(ape->totalframes > UINT_MAX \/ sizeof(APEFrame)){\n         av_log(s, AV_LOG_ERROR, \"Too many frames: %d\\n\", ape->totalframes);\n         return -1;\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2016-5350","CWE_ID":"399","category":"security","commit_id":"b4d16b4495b732888e12baf5b8a7e9bf2665e22b","commit_message":"From b4d16b4495b732888e12baf5b8a7e9bf2665e22b Mon Sep 17 00:00:00 2001\nFrom: Gerald Combs <gerald@wireshark.org>\nDate: Mon, 28 Mar 2016 15:46:33 -0700\nSubject: [PATCH] SPOOLSS: Try to avoid an infinite loop.\n\nUse tvb_reported_length_remaining in dissect_spoolss_uint16uni. Make\nsure our offset always increments in dissect_spoolss_keybuffer.\n\nChange-Id: I7017c9685bb2fa27161d80a03b8fca4ef630e793\nReviewed-on: https:\/\/code.wireshark.org\/review\/14687\nReviewed-by: Gerald Combs <gerald@wireshark.org>\nPetri-Dish: Gerald Combs <gerald@wireshark.org>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n---\n epan\/dissectors\/packet-dcerpc-spoolss.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/epan\/dissectors\/packet-dcerpc-spoolss.c b\/epan\/dissectors\/packet-dcerpc-spoolss.c\nindex 8774e3416a..22eef3c5ad 100644\n--- a\/epan\/dissectors\/packet-dcerpc-spoolss.c\n+++ b\/epan\/dissectors\/packet-dcerpc-spoolss.c\n@@ -1090,7 +1090,7 @@ dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n \n \t\/* Get remaining data in buffer as a string *\/\n \n-\tremaining = tvb_captured_length_remaining(tvb, offset);\n+\tremaining = tvb_reported_length_remaining(tvb, offset);\n \tif (remaining <= 0) {\n \t\tif (data)\n \t\t\t*data = g_strdup(\"\");\n@@ -6198,9 +6198,10 @@ dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n \t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n \t}\n \n-\twhile (offset < end_offset)\n+\twhile (offset > 0 && offset < end_offset) {\n \t\toffset = dissect_spoolss_uint16uni(\n \t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n+\t}\n \n \treturn offset;\n }\n","owner":"wireshark","repo":"wireshark","source":"cve"},{"CVE_ID":"CVE-2017-18238","CWE_ID":"399","category":"security","commit_id":"886cd1d2314755adb1f4cdb99c16ff00830f0331","commit_message":"From 886cd1d2314755adb1f4cdb99c16ff00830f0331 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Hubert=20Figui=C3=A8re?= <hub@figuiere.net>\nDate: Thu, 1 Feb 2018 21:02:45 -0500\nSubject: Bug 102483 - Fix an infinite loop in QuickTime parser.\n\n---\n XMPFiles\/source\/FormatSupport\/QuickTime_Support.cpp | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/XMPFiles\/source\/FormatSupport\/QuickTime_Support.cpp b\/XMPFiles\/source\/FormatSupport\/QuickTime_Support.cpp\nindex 8e2d45a..c735693 100644\n--- a\/XMPFiles\/source\/FormatSupport\/QuickTime_Support.cpp\n+++ b\/XMPFiles\/source\/FormatSupport\/QuickTime_Support.cpp\n@@ -920,7 +920,8 @@ bool TradQT_Manager::ParseCachedBoxes ( const MOOV_Manager & moovMgr )\n \n \t\t\tminiLen = 4 + GetUns16BE ( boxPtr );\t\/\/ ! Include header in local miniLen.\n \t\t\tmacLang  = GetUns16BE ( boxPtr+2);\n-\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) ) continue;\t\/\/ Ignore bad or empty values.\n+\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) )\n+\t\t\t\tbreak;\t\/\/ Ignore bad or empty values.\n \t\t\t\n \t\t\tXMP_StringPtr valuePtr = (char*)(boxPtr+4);\n \t\t\tsize_t valueLen = miniLen - 4;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9428","CWE_ID":"399","category":"security","commit_id":"5b6698b0e4a37053de35cc24ee695b98a7eb712b","commit_message":"From 5b6698b0e4a37053de35cc24ee695b98a7eb712b Mon Sep 17 00:00:00 2001\nFrom: Sven Eckelmann <sven@narfation.org>\nDate: Sat, 20 Dec 2014 13:48:55 +0100\nSubject: batman-adv: Calculate extra tail size based on queued fragments\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe fragmentation code was replaced in 610bfc6bc99bc83680d190ebc69359a05fc7f605\n(\"batman-adv: Receive fragmented packets and merge\"). The new code provided a\nmostly unused parameter skb for the merging function. It is used inside the\nfunction to calculate the additionally needed skb tailroom. But instead of\nincreasing its own tailroom, it is only increasing the tailroom of the first\nqueued skb. This is not correct in some situations because the first queued\nentry can be a different one than the parameter.\n\nAn observed problem was:\n\n1. packet with size 104, total_size 1464, fragno 1 was received\n   - packet is queued\n2. packet with size 1400, total_size 1464, fragno 0 was received\n   - packet is queued at the end of the list\n3. enough data was received and can be given to the merge function\n   (1464 == (1400 - 20) + (104 - 20))\n   - merge functions gets 1400 byte large packet as skb argument\n4. merge function gets first entry in queue (104 byte)\n   - stored as skb_out\n5. merge function calculates the required extra tail as total_size - skb->len\n   - pskb_expand_head tail of skb_out with 64 bytes\n6. merge function tries to squeeze the extra 1380 bytes from the second queued\n   skb (1400 byte aka skb parameter) in the 64 extra tail bytes of skb_out\n\nInstead calculate the extra required tail bytes for skb_out also using skb_out\ninstead of using the parameter skb. The skb parameter is only used to get the\ntotal_size from the last received packet. This is also the total_size used to\ndecide that all fragments were received.\n\nReported-by: Philipp Psurek <philipp.psurek@gmail.com>\nSigned-off-by: Sven Eckelmann <sven@narfation.org>\nAcked-by: Martin Hundeb\u00f8ll <martin@hundeboll.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/batman-adv\/fragmentation.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/batman-adv\/fragmentation.c b\/net\/batman-adv\/fragmentation.c\nindex fc1835c6bb40..8af3461d18d2 100644\n--- a\/net\/batman-adv\/fragmentation.c\n+++ b\/net\/batman-adv\/fragmentation.c\n@@ -251,7 +251,7 @@ batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n \tkfree(entry);\n \n \t\/* Make room for the rest of the fragments. *\/\n-\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n+\tif (pskb_expand_head(skb_out, 0, size - skb_out->len, GFP_ATOMIC) < 0) {\n \t\tkfree_skb(skb_out);\n \t\tskb_out = NULL;\n \t\tgoto free;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-6410","CWE_ID":"399","category":"security","commit_id":"c03aa9f6e1f938618e6db2e23afef0574efeeb65","commit_message":"From c03aa9f6e1f938618e6db2e23afef0574efeeb65 Mon Sep 17 00:00:00 2001\nFrom: Jan Kara <jack@suse.cz>\nDate: Thu, 4 Sep 2014 14:06:55 +0200\nSubject: [PATCH] udf: Avoid infinite loop when processing indirect ICBs\n\nWe did not implement any bound on number of indirect ICBs we follow when\nloading inode. Thus corrupted medium could cause kernel to go into an\ninfinite loop, possibly causing a stack overflow.\n\nFix the possible stack overflow by removing recursion from\n__udf_read_inode() and limit number of indirect ICBs we follow to avoid\ninfinite loops.\n\nSigned-off-by: Jan Kara <jack@suse.cz>\n---\n fs\/udf\/inode.c | 35 +++++++++++++++++++++--------------\n 1 file changed, 21 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/fs\/udf\/inode.c b\/fs\/udf\/inode.c\nindex 68cc7b144c260..a6a40536ebf13 100644\n--- a\/fs\/udf\/inode.c\n+++ b\/fs\/udf\/inode.c\n@@ -1270,6 +1270,13 @@ int udf_setsize(struct inode *inode, loff_t newsize)\n \treturn 0;\n }\n \n+\/*\n+ * Maximum length of linked list formed by ICB hierarchy. The chosen number is\n+ * arbitrary - just that we hopefully don't limit any real use of rewritten\n+ * inode on write-once media but avoid looping for too long on corrupted media.\n+ *\/\n+#define UDF_MAX_ICB_NESTING 1024\n+\n static void __udf_read_inode(struct inode *inode)\n {\n \tstruct buffer_head *bh = NULL;\n@@ -1279,7 +1286,9 @@ static void __udf_read_inode(struct inode *inode)\n \tstruct udf_inode_info *iinfo = UDF_I(inode);\n \tstruct udf_sb_info *sbi = UDF_SB(inode->i_sb);\n \tunsigned int link_count;\n+\tunsigned int indirections = 0;\n \n+reread:\n \t\/*\n \t * Set defaults, but the inode is still incomplete!\n \t * Note: get_new_inode() sets the following on a new inode:\n@@ -1317,28 +1326,26 @@ static void __udf_read_inode(struct inode *inode)\n \t\tibh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 1,\n \t\t\t\t\t&ident);\n \t\tif (ident == TAG_IDENT_IE && ibh) {\n-\t\t\tstruct buffer_head *nbh = NULL;\n \t\t\tstruct kernel_lb_addr loc;\n \t\t\tstruct indirectEntry *ie;\n \n \t\t\tie = (struct indirectEntry *)ibh->b_data;\n \t\t\tloc = lelb_to_cpu(ie->indirectICB.extLocation);\n \n-\t\t\tif (ie->indirectICB.extLength &&\n-\t\t\t\t(nbh = udf_read_ptagged(inode->i_sb, &loc, 0,\n-\t\t\t\t\t\t\t&ident))) {\n-\t\t\t\tif (ident == TAG_IDENT_FE ||\n-\t\t\t\t\tident == TAG_IDENT_EFE) {\n-\t\t\t\t\tmemcpy(&iinfo->i_location,\n-\t\t\t\t\t\t&loc,\n-\t\t\t\t\t\tsizeof(struct kernel_lb_addr));\n-\t\t\t\t\tbrelse(bh);\n-\t\t\t\t\tbrelse(ibh);\n-\t\t\t\t\tbrelse(nbh);\n-\t\t\t\t\t__udf_read_inode(inode);\n+\t\t\tif (ie->indirectICB.extLength) {\n+\t\t\t\tbrelse(bh);\n+\t\t\t\tbrelse(ibh);\n+\t\t\t\tmemcpy(&iinfo->i_location, &loc,\n+\t\t\t\t       sizeof(struct kernel_lb_addr));\n+\t\t\t\tif (++indirections > UDF_MAX_ICB_NESTING) {\n+\t\t\t\t\tudf_err(inode->i_sb,\n+\t\t\t\t\t\t\"too many ICBs in ICB hierarchy\"\n+\t\t\t\t\t\t\" (max %d supported)\\n\",\n+\t\t\t\t\t\tUDF_MAX_ICB_NESTING);\n+\t\t\t\t\tmake_bad_inode(inode);\n \t\t\t\t\treturn;\n \t\t\t\t}\n-\t\t\t\tbrelse(nbh);\n+\t\t\t\tgoto reread;\n \t\t\t}\n \t\t}\n \t\tbrelse(ibh);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-4348","CWE_ID":"399","category":"security","commit_id":"6f092343855a71e03b8d209815d8c45bf3a27fcd","commit_message":"From 6f092343855a71e03b8d209815d8c45bf3a27fcd Mon Sep 17 00:00:00 2001\nFrom: Jason Wang <jasowang@redhat.com>\nDate: Fri, 1 Nov 2013 15:01:10 +0800\nSubject: net: flow_dissector: fail on evil iph->ihl\n\nWe don't validate iph->ihl which may lead a dead loop if we meet a IPIP\nskb whose iph->ihl is zero. Fix this by failing immediately when iph->ihl\nis evil (less than 5).\n\nThis issue were introduced by commit ec5efe7946280d1e84603389a1030ccec0a767ae\n(rps: support IPIP encapsulation).\n\nCc: Eric Dumazet <edumazet@google.com>\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Michael S. Tsirkin <mst@redhat.com>\nCc: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/flow_dissector.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/core\/flow_dissector.c b\/net\/core\/flow_dissector.c\nindex 8d7d0dd72db2..143b6fdb9647 100644\n--- a\/net\/core\/flow_dissector.c\n+++ b\/net\/core\/flow_dissector.c\n@@ -40,7 +40,7 @@ again:\n \t\tstruct iphdr _iph;\n ip:\n \t\tiph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);\n-\t\tif (!iph)\n+\t\tif (!iph || iph->ihl < 5)\n \t\t\treturn false;\n \n \t\tif (ip_is_fragment(iph))\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6414","CWE_ID":"399","category":"security","commit_id":"9113dc6a303604a2d9812ac70c17d076ef11886c","commit_message":"From 9113dc6a303604a2d9812ac70c17d076ef11886c Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Tue, 21 Feb 2017 22:34:20 -0800\nSubject: smartcard: fix memory leak in vcard_apdu_new\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nIn the error path, 'new_apdu->a_data' is not freed.\nThis can be triggered by the guest continuely.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nReviewed-by: Marc-Andr\u00e9 Lureau <marcandre.lureau@redhat.com>\n---\n src\/card_7816.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/card_7816.c b\/src\/card_7816.c\nindex b598ef9..0082504 100644\n--- a\/src\/card_7816.c\n+++ b\/src\/card_7816.c\n@@ -341,12 +341,12 @@ vcard_apdu_new(unsigned char *raw_apdu, int len, vcard_7816_status_t *status)\n     new_apdu->a_len = len;\n     *status = vcard_apdu_set_class(new_apdu);\n     if (*status != VCARD7816_STATUS_SUCCESS) {\n-        g_free(new_apdu);\n+        vcard_apdu_delete(new_apdu);\n         return NULL;\n     }\n     *status = vcard_apdu_set_length(new_apdu);\n     if (*status != VCARD7816_STATUS_SUCCESS) {\n-        g_free(new_apdu);\n+        vcard_apdu_delete(new_apdu);\n         new_apdu = NULL;\n     }\n     return new_apdu;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-7175","CWE_ID":"399","category":"security","commit_id":"1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae","commit_message":"From 1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae Mon Sep 17 00:00:00 2001\nFrom: Cristy <mikayla-grace@urban-warrior.org>\nDate: Sun, 20 Jan 2019 11:11:52 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1450\n\n---\n coders\/pcd.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/coders\/pcd.c b\/coders\/pcd.c\nindex 8eb8ac6526..7e48c138c6 100644\n--- a\/coders\/pcd.c\n+++ b\/coders\/pcd.c\n@@ -204,6 +204,8 @@ static MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n     if (pcd_table[i] == (PCDTable *) NULL)\n       {\n         buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n+        for (j=0; j < i; j++)\n+          pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);\n         ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n           image->filename);\n       }\n@@ -215,6 +217,8 @@ static MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n       if (r->length > 16)\n         {\n           buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n+          for (j=0; j <= i; j++)\n+            pcd_table[j]=(PCDTable *) RelinquishMagickMemory(pcd_table[j]);\n           return(MagickFalse);\n         }\n       PCDGetBits(16);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-18261","CWE_ID":"399","category":"security","commit_id":"adb4f11e0a8f4e29900adb2b7af28b6bbd5c1fa4","commit_message":"From adb4f11e0a8f4e29900adb2b7af28b6bbd5c1fa4 Mon Sep 17 00:00:00 2001\nFrom: Ding Tianhong <dingtianhong@huawei.com>\nDate: Thu, 10 Aug 2017 10:52:45 +0800\nSubject: [PATCH] clocksource\/drivers\/arm_arch_timer: Avoid infinite recursion\n when ftrace is enabled\n\nOn platforms with an arch timer erratum workaround, it's possible for\narch_timer_reg_read_stable() to recurse into itself when certain\ntracing options are enabled, leading to stack overflows and related\nproblems.\n\nFor example, when PREEMPT_TRACER and FUNCTION_GRAPH_TRACER are\nselected, it's possible to trigger this with:\n\n$ mount -t debugfs nodev \/sys\/kernel\/debug\/\n$ echo function_graph > \/sys\/kernel\/debug\/tracing\/current_tracer\n\nThe problem is that in such cases, preempt_disable() instrumentation\nattempts to acquire a timestamp via trace_clock(), resulting in a call\nback to arch_timer_reg_read_stable(), and hence recursion.\n\nThis patch changes arch_timer_reg_read_stable() to use\npreempt_{disable,enable}_notrace(), which avoids this.\n\nThis problem is similar to the fixed by upstream commit 96b3d28bf4\n(\"sched\/clock: Prevent tracing recursion in sched_clock_cpu()\").\n\nFixes: 6acc71ccac71 (\"arm64: arch_timer: Allows a CPU-specific erratum to only affect a subset of CPUs\")\nSigned-off-by: Ding Tianhong <dingtianhong@huawei.com>\nAcked-by: Mark Rutland <mark.rutland@arm.com>\nAcked-by: Marc Zyngier <marc.zyngier@arm.com>\nSigned-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>\n---\n arch\/arm64\/include\/asm\/arch_timer.h | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm64\/include\/asm\/arch_timer.h b\/arch\/arm64\/include\/asm\/arch_timer.h\nindex 74d08e44a651b..a652ce0a5cb2c 100644\n--- a\/arch\/arm64\/include\/asm\/arch_timer.h\n+++ b\/arch\/arm64\/include\/asm\/arch_timer.h\n@@ -65,13 +65,13 @@ DECLARE_PER_CPU(const struct arch_timer_erratum_workaround *,\n \tu64 _val;\t\t\t\t\t\t\t\\\n \tif (needs_unstable_timer_counter_workaround()) {\t\t\\\n \t\tconst struct arch_timer_erratum_workaround *wa;\t\t\\\n-\t\tpreempt_disable();\t\t\t\t\t\\\n+\t\tpreempt_disable_notrace();\t\t\t\t\\\n \t\twa = __this_cpu_read(timer_unstable_counter_workaround); \\\n \t\tif (wa && wa->read_##reg)\t\t\t\t\\\n \t\t\t_val = wa->read_##reg();\t\t\t\\\n \t\telse\t\t\t\t\t\t\t\\\n \t\t\t_val = read_sysreg(reg);\t\t\t\\\n-\t\tpreempt_enable();\t\t\t\t\t\\\n+\t\tpreempt_enable_notrace();\t\t\t\t\\\n \t} else {\t\t\t\t\t\t\t\\\n \t\t_val = read_sysreg(reg);\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-14174","CWE_ID":"399","category":"security","commit_id":"04a567494786d5bb50894fc8bb8fea0cf496bea8","commit_message":"From 04a567494786d5bb50894fc8bb8fea0cf496bea8 Mon Sep 17 00:00:00 2001\nFrom: Dirk Lemstra <dirk@git.imagemagick.org>\nDate: Thu, 31 Aug 2017 20:49:19 +0200\nSubject: [PATCH] Slightly different fix for #714\n\n---\n coders\/psd.c | 32 ++++++++++----------------------\n 1 file changed, 10 insertions(+), 22 deletions(-)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex a29f6ac3ee..88a63e577e 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -1323,10 +1323,10 @@ static MagickBooleanType ReadPSDChannel(Image *image,\n       if ((layer_info->channel_info[channel].type != -2) ||\n           (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) &&\n            (IsStringTrue(option) == MagickFalse)))\n-      {\n-        SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n-        return(MagickTrue);\n-      }\n+        {\n+          SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR);\n+          return(MagickTrue);\n+        }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n       if (mask != (Image *) NULL)\n@@ -1701,24 +1701,12 @@ static MagickBooleanType ReadPSDLayersInternal(Image *image,\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"      layer blending ranges: length=%.20g\",(double)\n                     ((MagickOffsetType) length));\n-                \/*\n-                  We read it, but don't use it...\n-                *\/\n-                for (j=0; j < (ssize_t) length; j+=8)\n-                {\n-                  size_t blend_source=ReadBlobLong(image);\n-                  size_t blend_dest=ReadBlobLong(image);\n-                  if (EOFBlob(image) != MagickFalse)\n-                    {\n-                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n-                      ThrowBinaryException(CorruptImageError,\n-                        \"InsufficientImageDataInFile\",image->filename);\n-                    }\n-                  if (image->debug != MagickFalse)\n-                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n-                      \"        source(%x), dest(%x)\",(unsigned int)\n-                      blend_source,(unsigned int) blend_dest);\n-                }\n+                if (DiscardBlobBytes(image,length) == MagickFalse)\n+                  {\n+                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n+                    ThrowBinaryException(CorruptImageError,\n+                      \"UnexpectedEndOfFile\",image->filename);\n+                  }\n               }\n             \/*\n               Layer name.\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2011-0991","CWE_ID":"399","category":"security","commit_id":"89d1455a80ef13cddee5d79ec00c06055da3085c","commit_message":"From 89d1455a80ef13cddee5d79ec00c06055da3085c Mon Sep 17 00:00:00 2001\nFrom: Rodrigo Kumpera <kumpera@gmail.com>\nDate: Tue, 1 Feb 2011 16:50:24 +0100\nSubject: [PATCH] Don't use finalization to cleanup dynamic methods.\n\n\t* reflection.c: Use a reference queue to cleanup\n\tdynamic methods instead of finalization.\n\n\t* runtime.c: Shutdown the dynamic method queue\n\tbefore runtime cleanup begins.\n\n\t* DynamicMethod.cs: No longer finalizable.\n\n\t* icall-def.h: Remove unused dynamic method icall.\n\n\tFixes #660422\n---\n ...\/System.Reflection.Emit\/DynamicMethod.cs   |  8 ---\n mono\/metadata\/icall-def.h                     |  1 -\n mono\/metadata\/object-internals.h              |  3 +\n mono\/metadata\/reflection.c                    | 58 +++++++++++++++----\n mono\/metadata\/runtime.c                       |  3 +\n 5 files changed, 53 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/mcs\/class\/corlib\/System.Reflection.Emit\/DynamicMethod.cs b\/mcs\/class\/corlib\/System.Reflection.Emit\/DynamicMethod.cs\nindex 9af56018aa1a..6fb1600be4d3 100644\n--- a\/mcs\/class\/corlib\/System.Reflection.Emit\/DynamicMethod.cs\n+++ b\/mcs\/class\/corlib\/System.Reflection.Emit\/DynamicMethod.cs\n@@ -127,9 +127,6 @@ public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool\n \t\t[MethodImplAttribute(MethodImplOptions.InternalCall)]\n \t\tprivate extern void create_dynamic_method (DynamicMethod m);\n \n-\t\t[MethodImplAttribute(MethodImplOptions.InternalCall)]\n-\t\tprivate extern void destroy_dynamic_method (DynamicMethod m);\n-\n \t\tprivate void CreateDynMethod () {\n \t\t\tif (mhandle.Value == IntPtr.Zero) {\n \t\t\t\tif (ilgen == null || ilgen.ILOffset == 0)\n@@ -158,11 +155,6 @@ public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool\n \t\t\t}\n \t\t}\n \n-\t\t~DynamicMethod ()\n-\t\t{\n-\t\t\tdestroy_dynamic_method (this);\n-\t\t}\n-\n \t\t[ComVisible (true)]\n \t\tpublic Delegate CreateDelegate (Type delegateType)\n \t\t{\ndiff --git a\/mono\/metadata\/icall-def.h b\/mono\/metadata\/icall-def.h\nindex 26614eb4a79b..9b894cbc2025 100644\n--- a\/mono\/metadata\/icall-def.h\n+++ b\/mono\/metadata\/icall-def.h\n@@ -524,7 +524,6 @@ ICALL(DERIVEDTYPE_1, \"create_unmanaged_type\", mono_reflection_create_unmanaged_t\n \n ICALL_TYPE(DYNM, \"System.Reflection.Emit.DynamicMethod\", DYNM_1)\n ICALL(DYNM_1, \"create_dynamic_method\", mono_reflection_create_dynamic_method)\n-ICALL(DYNM_2, \"destroy_dynamic_method\", mono_reflection_destroy_dynamic_method)\n \n ICALL_TYPE(ENUMB, \"System.Reflection.Emit.EnumBuilder\", ENUMB_1)\n ICALL(ENUMB_1, \"setup_enum_type\", ves_icall_EnumBuilder_setup_enum_type)\ndiff --git a\/mono\/metadata\/object-internals.h b\/mono\/metadata\/object-internals.h\nindex 79280485bf58..345c6a810dce 100644\n--- a\/mono\/metadata\/object-internals.h\n+++ b\/mono\/metadata\/object-internals.h\n@@ -1539,6 +1539,9 @@ mono_object_new_pinned (MonoDomain *domain, MonoClass *klass) MONO_INTERNAL;\n void\n mono_field_static_get_value_for_thread (MonoInternalThread *thread, MonoVTable *vt, MonoClassField *field, void *value) MONO_INTERNAL;\n \n+void\n+mono_reflection_shutdown (void) MONO_INTERNAL;\n+\n #endif \/* __MONO_OBJECT_INTERNALS_H__ *\/\n \n \ndiff --git a\/mono\/metadata\/reflection.c b\/mono\/metadata\/reflection.c\nindex e267172ccd9b..d0252ab623a3 100644\n--- a\/mono\/metadata\/reflection.c\n+++ b\/mono\/metadata\/reflection.c\n@@ -11441,15 +11441,56 @@ mono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig)\n \treturn result;\n }\n \n+typedef struct {\n+\tMonoMethod *handle;\n+\tMonoDomain *domain;\n+} DynamicMethodReleaseData;\n+\t\n+static MonoReferenceQueue *dynamic_method_queue;\n+\n+void\n+mono_reflection_shutdown (void)\n+{\n+\tMonoReferenceQueue *queue;\n+\tmono_loader_lock ();\n+\tqueue = dynamic_method_queue;\n+\tdynamic_method_queue = NULL;\n+\tif (queue)\n+\t\tmono_gc_reference_queue_free (queue);\n+\tmono_loader_unlock ();\n+}\n+\n+static void\n+free_dynamic_method (void *dynamic_method)\n+{\n+\tDynamicMethodReleaseData *data = dynamic_method;\n+\n+\tmono_runtime_free_method (data->domain, data->handle);\n+\tg_free (data);\n+}\n+\n void \n mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n {\n+\tMonoReferenceQueue *queue;\n+\tMonoMethod *handle;\n+\tDynamicMethodReleaseData *release_data;\n \tReflectionMethodBuilder rmb;\n \tMonoMethodSignature *sig;\n \tMonoClass *klass;\n \tGSList *l;\n \tint i;\n \n+\tif (mono_runtime_is_shutting_down ())\n+\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"\"));\n+\n+\tif (!(queue = dynamic_method_queue)) {\n+\t\tmono_loader_lock ();\n+\t\tif (!(queue = dynamic_method_queue))\n+\t\t\tqueue = dynamic_method_queue = mono_gc_reference_queue_new (free_dynamic_method);\n+\t\tmono_loader_unlock ();\n+\t}\n+\n \tsig = dynamic_method_to_signature (mb);\n \n \treflection_methodbuilder_from_dynamic_method (&rmb, mb);\n@@ -11507,7 +11548,12 @@ mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n \n \tklass = mb->owner ? mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)mb->owner)) : mono_defaults.object_class;\n \n-\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n+\tmb->mhandle = handle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n+\trelease_data = g_new (DynamicMethodReleaseData, 1);\n+\trelease_data->handle = handle;\n+\trelease_data->domain = mono_object_get_domain ((MonoObject*)mb);\n+\tif (!mono_gc_reference_queue_add (queue, (MonoObject*)mb, release_data))\n+\t\tg_free (release_data);\n \n \t\/* Fix up refs entries pointing at us *\/\n \tfor (l = mb->referenced_by; l; l = l->next) {\n@@ -11533,16 +11579,6 @@ mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n \n #endif \/* DISABLE_REFLECTION_EMIT *\/\n \n-void\n-mono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb)\n-{\n-\tg_assert (mb);\n-\n-\tif (mb->mhandle)\n-\t\tmono_runtime_free_method (\n-\t\t\tmono_object_get_domain ((MonoObject*)mb), mb->mhandle);\n-}\n-\n \/**\n  * \n  * mono_reflection_is_valid_dynamic_token:\ndiff --git a\/mono\/metadata\/runtime.c b\/mono\/metadata\/runtime.c\nindex e4a4c32b3a37..1a20d496d3ee 100644\n--- a\/mono\/metadata\/runtime.c\n+++ b\/mono\/metadata\/runtime.c\n@@ -39,5 +39,8 @@ void\n mono_runtime_shutdown (void)\n {\n \tmono_domain_foreach (fire_process_exit_event, NULL);\n+\n+\t\/*From this point on, no more DM methods can be created. *\/\n+\tmono_reflection_shutdown ();\n }\n \n","owner":"mono","repo":"mono","source":"cve"},{"CVE_ID":"CVE-2010-3078","CWE_ID":"399","category":"security","commit_id":"a122eb2fdfd78b58c6dd992d6f4b1aaef667eef9","commit_message":"From a122eb2fdfd78b58c6dd992d6f4b1aaef667eef9 Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <dan.j.rosenberg@gmail.com>\nDate: Mon, 6 Sep 2010 18:24:57 -0400\nSubject: xfs: prevent reading uninitialized stack memory\n\nThe XFS_IOC_FSGETXATTR ioctl allows unprivileged users to read 12\nbytes of uninitialized stack memory, because the fsxattr struct\ndeclared on the stack in xfs_ioc_fsgetxattr() does not alter (or zero)\nthe 12-byte fsx_pad member before copying it back to the user.  This\npatch takes care of it.\n\nSigned-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>\nReviewed-by: Eric Sandeen <sandeen@redhat.com>\nSigned-off-by: Alex Elder <aelder@sgi.com>\n---\n fs\/xfs\/linux-2.6\/xfs_ioctl.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/fs\/xfs\/linux-2.6\/xfs_ioctl.c b\/fs\/xfs\/linux-2.6\/xfs_ioctl.c\nindex 4fec427b83ef..3b9e626f7cd1 100644\n--- a\/fs\/xfs\/linux-2.6\/xfs_ioctl.c\n+++ b\/fs\/xfs\/linux-2.6\/xfs_ioctl.c\n@@ -785,6 +785,8 @@ xfs_ioc_fsgetxattr(\n {\n \tstruct fsxattr\t\tfa;\n \n+\tmemset(&fa, 0, sizeof(struct fsxattr));\n+\n \txfs_ilock(ip, XFS_ILOCK_SHARED);\n \tfa.fsx_xflags = xfs_ip2xflags(ip);\n \tfa.fsx_extsize = ip->i_d.di_extsize << ip->i_mount->m_sb.sb_blocklog;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-11523","CWE_ID":"399","category":"security","commit_id":"a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78","commit_message":"From a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Wed, 19 Jul 2017 13:15:21 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/591\n\n---\n coders\/txt.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/coders\/txt.c b\/coders\/txt.c\nindex bc0e0f7447..f59418bbcc 100644\n--- a\/coders\/txt.c\n+++ b\/coders\/txt.c\n@@ -580,6 +580,12 @@ static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           break;\n       }\n     }\n+    if (EOFBlob(image) != MagickFalse)\n+      {\n+        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n+          image->filename);\n+        break;\n+      }\n     (void) ReadBlobString(image,text);\n     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n       {\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-14056","CWE_ID":"399","category":"security","commit_id":"96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de","commit_message":"From 96f24d1bee7fe7bac08e2b7c74db1a046c9dc0de Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?=E5=AD=99=E6=B5=A9=20and=20=E5=BC=A0=E6=B4=AA=E4=BA=AE=28?=\n =?UTF-8?q?=E6=9C=9B=E5=88=9D=29?= <tony.sh and wangchu.zhl@alibaba-inc.com>\nDate: Fri, 25 Aug 2017 01:15:29 +0200\nSubject: [PATCH] avformat\/rl2: Fix DoS due to lack of eof check\n\nFixes: loop.rl2\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/rl2.c | 15 ++++++++++++---\n 1 file changed, 12 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libavformat\/rl2.c b\/libavformat\/rl2.c\nindex 0bec8f1d9ab..eb1682dfcb7 100644\n--- a\/libavformat\/rl2.c\n+++ b\/libavformat\/rl2.c\n@@ -170,12 +170,21 @@ static av_cold int rl2_read_header(AVFormatContext *s)\n     }\n \n     \/** read offset and size tables *\/\n-    for(i=0; i < frame_count;i++)\n+    for(i=0; i < frame_count;i++) {\n+        if (avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n         chunk_size[i] = avio_rl32(pb);\n-    for(i=0; i < frame_count;i++)\n+    }\n+    for(i=0; i < frame_count;i++) {\n+        if (avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n         chunk_offset[i] = avio_rl32(pb);\n-    for(i=0; i < frame_count;i++)\n+    }\n+    for(i=0; i < frame_count;i++) {\n+        if (avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n         audio_size[i] = avio_rl32(pb) & 0xFFFF;\n+    }\n \n     \/** build the sample index *\/\n     for(i=0;i<frame_count;i++){\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-7472","CWE_ID":"399","category":"security","commit_id":"c9f838d104fed6f2f61d68164712e3204bf5271b","commit_message":"From c9f838d104fed6f2f61d68164712e3204bf5271b Mon Sep 17 00:00:00 2001\nFrom: Eric Biggers <ebiggers@google.com>\nDate: Tue, 18 Apr 2017 15:31:09 +0100\nSubject: [PATCH] KEYS: fix keyctl_set_reqkey_keyring() to not leak thread\n keyrings\n\nThis fixes CVE-2017-7472.\n\nRunning the following program as an unprivileged user exhausts kernel\nmemory by leaking thread keyrings:\n\n\t#include <keyutils.h>\n\n\tint main()\n\t{\n\t\tfor (;;)\n\t\t\tkeyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_THREAD_KEYRING);\n\t}\n\nFix it by only creating a new thread keyring if there wasn't one before.\nTo make things more consistent, make install_thread_keyring_to_cred()\nand install_process_keyring_to_cred() both return 0 if the corresponding\nkeyring is already present.\n\nFixes: d84f4f992cbd (\"CRED: Inaugurate COW credentials\")\nCc: stable@vger.kernel.org # 2.6.29+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\n---\n security\/keys\/keyctl.c       | 11 ++++-----\n security\/keys\/process_keys.c | 44 ++++++++++++++++++++++--------------\n 2 files changed, 31 insertions(+), 24 deletions(-)\n\n","diff_code":"diff --git a\/security\/keys\/keyctl.c b\/security\/keys\/keyctl.c\nindex ab082a2e8fdda..4ad3212adebe8 100644\n--- a\/security\/keys\/keyctl.c\n+++ b\/security\/keys\/keyctl.c\n@@ -1258,8 +1258,8 @@ long keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n  * Read or set the default keyring in which request_key() will cache keys and\n  * return the old setting.\n  *\n- * If a process keyring is specified then this will be created if it doesn't\n- * yet exist.  The old setting will be returned if successful.\n+ * If a thread or process keyring is specified then it will be created if it\n+ * doesn't yet exist.  The old setting will be returned if successful.\n  *\/\n long keyctl_set_reqkey_keyring(int reqkey_defl)\n {\n@@ -1284,11 +1284,8 @@ long keyctl_set_reqkey_keyring(int reqkey_defl)\n \n \tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n \t\tret = install_process_keyring_to_cred(new);\n-\t\tif (ret < 0) {\n-\t\t\tif (ret != -EEXIST)\n-\t\t\t\tgoto error;\n-\t\t\tret = 0;\n-\t\t}\n+\t\tif (ret < 0)\n+\t\t\tgoto error;\n \t\tgoto set;\n \n \tcase KEY_REQKEY_DEFL_DEFAULT:\ndiff --git a\/security\/keys\/process_keys.c b\/security\/keys\/process_keys.c\nindex b6fdd22205b16..9139b18fc863e 100644\n--- a\/security\/keys\/process_keys.c\n+++ b\/security\/keys\/process_keys.c\n@@ -128,13 +128,18 @@ int install_user_keyrings(void)\n }\n \n \/*\n- * Install a fresh thread keyring directly to new credentials.  This keyring is\n- * allowed to overrun the quota.\n+ * Install a thread keyring to the given credentials struct if it didn't have\n+ * one already.  This is allowed to overrun the quota.\n+ *\n+ * Return: 0 if a thread keyring is now present; -errno on failure.\n  *\/\n int install_thread_keyring_to_cred(struct cred *new)\n {\n \tstruct key *keyring;\n \n+\tif (new->thread_keyring)\n+\t\treturn 0;\n+\n \tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n \t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n \t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n@@ -147,7 +152,9 @@ int install_thread_keyring_to_cred(struct cred *new)\n }\n \n \/*\n- * Install a fresh thread keyring, discarding the old one.\n+ * Install a thread keyring to the current task if it didn't have one already.\n+ *\n+ * Return: 0 if a thread keyring is now present; -errno on failure.\n  *\/\n static int install_thread_keyring(void)\n {\n@@ -158,8 +165,6 @@ static int install_thread_keyring(void)\n \tif (!new)\n \t\treturn -ENOMEM;\n \n-\tBUG_ON(new->thread_keyring);\n-\n \tret = install_thread_keyring_to_cred(new);\n \tif (ret < 0) {\n \t\tabort_creds(new);\n@@ -170,17 +175,17 @@ static int install_thread_keyring(void)\n }\n \n \/*\n- * Install a process keyring directly to a credentials struct.\n+ * Install a process keyring to the given credentials struct if it didn't have\n+ * one already.  This is allowed to overrun the quota.\n  *\n- * Returns -EEXIST if there was already a process keyring, 0 if one installed,\n- * and other value on any other error\n+ * Return: 0 if a process keyring is now present; -errno on failure.\n  *\/\n int install_process_keyring_to_cred(struct cred *new)\n {\n \tstruct key *keyring;\n \n \tif (new->process_keyring)\n-\t\treturn -EEXIST;\n+\t\treturn 0;\n \n \tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n \t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n@@ -194,11 +199,9 @@ int install_process_keyring_to_cred(struct cred *new)\n }\n \n \/*\n- * Make sure a process keyring is installed for the current process.  The\n- * existing process keyring is not replaced.\n+ * Install a process keyring to the current task if it didn't have one already.\n  *\n- * Returns 0 if there is a process keyring by the end of this function, some\n- * error otherwise.\n+ * Return: 0 if a process keyring is now present; -errno on failure.\n  *\/\n static int install_process_keyring(void)\n {\n@@ -212,14 +215,18 @@ static int install_process_keyring(void)\n \tret = install_process_keyring_to_cred(new);\n \tif (ret < 0) {\n \t\tabort_creds(new);\n-\t\treturn ret != -EEXIST ? ret : 0;\n+\t\treturn ret;\n \t}\n \n \treturn commit_creds(new);\n }\n \n \/*\n- * Install a session keyring directly to a credentials struct.\n+ * Install the given keyring as the session keyring of the given credentials\n+ * struct, replacing the existing one if any.  If the given keyring is NULL,\n+ * then install a new anonymous session keyring.\n+ *\n+ * Return: 0 on success; -errno on failure.\n  *\/\n int install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\n {\n@@ -254,8 +261,11 @@ int install_session_keyring_to_cred(struct cred *cred, struct key *keyring)\n }\n \n \/*\n- * Install a session keyring, discarding the old one.  If a keyring is not\n- * supplied, an empty one is invented.\n+ * Install the given keyring as the session keyring of the current task,\n+ * replacing the existing one if any.  If the given keyring is NULL, then\n+ * install a new anonymous session keyring.\n+ *\n+ * Return: 0 on success; -errno on failure.\n  *\/\n static int install_session_keyring(struct key *keyring)\n {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-18208","CWE_ID":"399","category":"security","commit_id":"6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91","commit_message":"From 6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91 Mon Sep 17 00:00:00 2001\nFrom: chenjie <chenjie6@huawei.com>\nDate: Wed, 29 Nov 2017 16:10:54 -0800\nSubject: mm\/madvise.c: fix madvise() infinite loop under special circumstances\n\nMADVISE_WILLNEED has always been a noop for DAX (formerly XIP) mappings.\nUnfortunately madvise_willneed() doesn't communicate this information\nproperly to the generic madvise syscall implementation.  The calling\nconvention is quite subtle there.  madvise_vma() is supposed to either\nreturn an error or update &prev otherwise the main loop will never\nadvance to the next vma and it will keep looping for ever without a way\nto get out of the kernel.\n\nIt seems this has been broken since introduction.  Nobody has noticed\nbecause nobody seems to be using MADVISE_WILLNEED on these DAX mappings.\n\n[mhocko@suse.com: rewrite changelog]\nLink: http:\/\/lkml.kernel.org\/r\/20171127115318.911-1-guoxuenan@huawei.com\nFixes: fe77ba6f4f97 (\"[PATCH] xip: madvice\/fadvice: execute in place\")\nSigned-off-by: chenjie <chenjie6@huawei.com>\nSigned-off-by: guoxuenan <guoxuenan@huawei.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nCc: Minchan Kim <minchan@kernel.org>\nCc: zhangyi (F) <yi.zhang@huawei.com>\nCc: Miao Xie <miaoxie@huawei.com>\nCc: Mike Rapoport <rppt@linux.vnet.ibm.com>\nCc: Shaohua Li <shli@fb.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: Mel Gorman <mgorman@techsingularity.net>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Anshuman Khandual <khandual@linux.vnet.ibm.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: Carsten Otte <cotte@de.ibm.com>\nCc: Dan Williams <dan.j.williams@intel.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/madvise.c | 4 +---\n 1 file changed, 1 insertion(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/mm\/madvise.c b\/mm\/madvise.c\nindex 375cf32087e4..751e97aa2210 100644\n--- a\/mm\/madvise.c\n+++ b\/mm\/madvise.c\n@@ -276,15 +276,14 @@ static long madvise_willneed(struct vm_area_struct *vma,\n {\n \tstruct file *file = vma->vm_file;\n \n+\t*prev = vma;\n #ifdef CONFIG_SWAP\n \tif (!file) {\n-\t\t*prev = vma;\n \t\tforce_swapin_readahead(vma, start, end);\n \t\treturn 0;\n \t}\n \n \tif (shmem_mapping(file->f_mapping)) {\n-\t\t*prev = vma;\n \t\tforce_shm_swapin_readahead(vma, start, end,\n \t\t\t\t\tfile->f_mapping);\n \t\treturn 0;\n@@ -299,7 +298,6 @@ static long madvise_willneed(struct vm_area_struct *vma,\n \t\treturn 0;\n \t}\n \n-\t*prev = vma;\n \tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n \tif (end > vma->vm_end)\n \t\tend = vma->vm_end;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-11683","CWE_ID":"399","category":"security","commit_id":"4dd2b82d5adfbe0b1587ccad7a8f76d826120f37","commit_message":"From 4dd2b82d5adfbe0b1587ccad7a8f76d826120f37 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Wed, 1 May 2019 18:56:28 -0700\nSubject: udp: fix GRO packet of death\n\nsyzbot was able to crash host by sending UDP packets with a 0 payload.\n\nTCP does not have this issue since we do not aggregate packets without\npayload.\n\nSince dev_gro_receive() sets gso_size based on skb_gro_len(skb)\nit seems not worth trying to cope with padded packets.\n\nBUG: KASAN: slab-out-of-bounds in skb_gro_receive+0xf5f\/0x10e0 net\/core\/skbuff.c:3826\nRead of size 16 at addr ffff88808893fff0 by task syz-executor612\/7889\n\nCPU: 0 PID: 7889 Comm: syz-executor612 Not tainted 5.1.0-rc7+ #96\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS Google 01\/01\/2011\nCall Trace:\n __dump_stack lib\/dump_stack.c:77 [inline]\n dump_stack+0x172\/0x1f0 lib\/dump_stack.c:113\n print_address_description.cold+0x7c\/0x20d mm\/kasan\/report.c:187\n kasan_report.cold+0x1b\/0x40 mm\/kasan\/report.c:317\n __asan_report_load16_noabort+0x14\/0x20 mm\/kasan\/generic_report.c:133\n skb_gro_receive+0xf5f\/0x10e0 net\/core\/skbuff.c:3826\n udp_gro_receive_segment net\/ipv4\/udp_offload.c:382 [inline]\n call_gro_receive include\/linux\/netdevice.h:2349 [inline]\n udp_gro_receive+0xb61\/0xfd0 net\/ipv4\/udp_offload.c:414\n udp4_gro_receive+0x763\/0xeb0 net\/ipv4\/udp_offload.c:478\n inet_gro_receive+0xe72\/0x1110 net\/ipv4\/af_inet.c:1510\n dev_gro_receive+0x1cd0\/0x23c0 net\/core\/dev.c:5581\n napi_gro_frags+0x36b\/0xd10 net\/core\/dev.c:5843\n tun_get_user+0x2f24\/0x3fb0 drivers\/net\/tun.c:1981\n tun_chr_write_iter+0xbd\/0x156 drivers\/net\/tun.c:2027\n call_write_iter include\/linux\/fs.h:1866 [inline]\n do_iter_readv_writev+0x5e1\/0x8e0 fs\/read_write.c:681\n do_iter_write fs\/read_write.c:957 [inline]\n do_iter_write+0x184\/0x610 fs\/read_write.c:938\n vfs_writev+0x1b3\/0x2f0 fs\/read_write.c:1002\n do_writev+0x15e\/0x370 fs\/read_write.c:1037\n __do_sys_writev fs\/read_write.c:1110 [inline]\n __se_sys_writev fs\/read_write.c:1107 [inline]\n __x64_sys_writev+0x75\/0xb0 fs\/read_write.c:1107\n do_syscall_64+0x103\/0x610 arch\/x86\/entry\/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49\/0xbe\nRIP: 0033:0x441cc0\nCode: 05 48 3d 01 f0 ff ff 0f 83 9d 09 fc ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 83 3d 51 93 29 00 00 75 14 b8 14 00 00 00 0f 05 <48> 3d 01 f0 ff ff 0f 83 74 09 fc ff c3 48 83 ec 08 e8 ba 2b 00 00\nRSP: 002b:00007ffe8c716118 EFLAGS: 00000246 ORIG_RAX: 0000000000000014\nRAX: ffffffffffffffda RBX: 00007ffe8c716150 RCX: 0000000000441cc0\nRDX: 0000000000000001 RSI: 00007ffe8c716170 RDI: 00000000000000f0\nRBP: 0000000000000000 R08: 000000000000ffff R09: 0000000000a64668\nR10: 0000000020000040 R11: 0000000000000246 R12: 000000000000c2d9\nR13: 0000000000402b50 R14: 0000000000000000 R15: 0000000000000000\n\nAllocated by task 5143:\n save_stack+0x45\/0xd0 mm\/kasan\/common.c:75\n set_track mm\/kasan\/common.c:87 [inline]\n __kasan_kmalloc mm\/kasan\/common.c:497 [inline]\n __kasan_kmalloc.constprop.0+0xcf\/0xe0 mm\/kasan\/common.c:470\n kasan_slab_alloc+0xf\/0x20 mm\/kasan\/common.c:505\n slab_post_alloc_hook mm\/slab.h:437 [inline]\n slab_alloc mm\/slab.c:3393 [inline]\n kmem_cache_alloc+0x11a\/0x6f0 mm\/slab.c:3555\n mm_alloc+0x1d\/0xd0 kernel\/fork.c:1030\n bprm_mm_init fs\/exec.c:363 [inline]\n __do_execve_file.isra.0+0xaa3\/0x23f0 fs\/exec.c:1791\n do_execveat_common fs\/exec.c:1865 [inline]\n do_execve fs\/exec.c:1882 [inline]\n __do_sys_execve fs\/exec.c:1958 [inline]\n __se_sys_execve fs\/exec.c:1953 [inline]\n __x64_sys_execve+0x8f\/0xc0 fs\/exec.c:1953\n do_syscall_64+0x103\/0x610 arch\/x86\/entry\/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49\/0xbe\n\nFreed by task 5351:\n save_stack+0x45\/0xd0 mm\/kasan\/common.c:75\n set_track mm\/kasan\/common.c:87 [inline]\n __kasan_slab_free+0x102\/0x150 mm\/kasan\/common.c:459\n kasan_slab_free+0xe\/0x10 mm\/kasan\/common.c:467\n __cache_free mm\/slab.c:3499 [inline]\n kmem_cache_free+0x86\/0x260 mm\/slab.c:3765\n __mmdrop+0x238\/0x320 kernel\/fork.c:677\n mmdrop include\/linux\/sched\/mm.h:49 [inline]\n finish_task_switch+0x47b\/0x780 kernel\/sched\/core.c:2746\n context_switch kernel\/sched\/core.c:2880 [inline]\n __schedule+0x81b\/0x1cc0 kernel\/sched\/core.c:3518\n preempt_schedule_irq+0xb5\/0x140 kernel\/sched\/core.c:3745\n retint_kernel+0x1b\/0x2d\n arch_local_irq_restore arch\/x86\/include\/asm\/paravirt.h:767 [inline]\n kmem_cache_free+0xab\/0x260 mm\/slab.c:3766\n anon_vma_chain_free mm\/rmap.c:134 [inline]\n unlink_anon_vmas+0x2ba\/0x870 mm\/rmap.c:401\n free_pgtables+0x1af\/0x2f0 mm\/memory.c:394\n exit_mmap+0x2d1\/0x530 mm\/mmap.c:3144\n __mmput kernel\/fork.c:1046 [inline]\n mmput+0x15f\/0x4c0 kernel\/fork.c:1067\n exec_mmap fs\/exec.c:1046 [inline]\n flush_old_exec+0x8d9\/0x1c20 fs\/exec.c:1279\n load_elf_binary+0x9bc\/0x53f0 fs\/binfmt_elf.c:864\n search_binary_handler fs\/exec.c:1656 [inline]\n search_binary_handler+0x17f\/0x570 fs\/exec.c:1634\n exec_binprm fs\/exec.c:1698 [inline]\n __do_execve_file.isra.0+0x1394\/0x23f0 fs\/exec.c:1818\n do_execveat_common fs\/exec.c:1865 [inline]\n do_execve fs\/exec.c:1882 [inline]\n __do_sys_execve fs\/exec.c:1958 [inline]\n __se_sys_execve fs\/exec.c:1953 [inline]\n __x64_sys_execve+0x8f\/0xc0 fs\/exec.c:1953\n do_syscall_64+0x103\/0x610 arch\/x86\/entry\/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49\/0xbe\n\nThe buggy address belongs to the object at ffff88808893f7c0\n which belongs to the cache mm_struct of size 1496\nThe buggy address is located 600 bytes to the right of\n 1496-byte region [ffff88808893f7c0, ffff88808893fd98)\nThe buggy address belongs to the page:\npage:ffffea0002224f80 count:1 mapcount:0 mapping:ffff88821bc40ac0 index:0xffff88808893f7c0 compound_mapcount: 0\nflags: 0x1fffc0000010200(slab|head)\nraw: 01fffc0000010200 ffffea00025b4f08 ffffea00027b9d08 ffff88821bc40ac0\nraw: ffff88808893f7c0 ffff88808893e440 0000000100000001 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff88808893fe80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff88808893ff00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff88808893ff80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n                                                             ^\n ffff888088940000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff888088940080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\nFixes: e20cf8d3f1f7 (\"udp: implement GRO for plain UDP sockets.\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Paolo Abeni <pabeni@redhat.com>\nReported-by: syzbot <syzkaller@googlegroups.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/udp_offload.c | 13 ++++++++++---\n 1 file changed, 10 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/udp_offload.c b\/net\/ipv4\/udp_offload.c\nindex d8776b2110c1..065334b41d57 100644\n--- a\/net\/ipv4\/udp_offload.c\n+++ b\/net\/ipv4\/udp_offload.c\n@@ -352,6 +352,7 @@ static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n \tstruct sk_buff *pp = NULL;\n \tstruct udphdr *uh2;\n \tstruct sk_buff *p;\n+\tunsigned int ulen;\n \n \t\/* requires non zero csum, for symmetry with GSO *\/\n \tif (!uh->check) {\n@@ -359,6 +360,12 @@ static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n \t\treturn NULL;\n \t}\n \n+\t\/* Do not deal with padded or malicious packets, sorry ! *\/\n+\tulen = ntohs(uh->len);\n+\tif (ulen <= sizeof(*uh) || ulen != skb_gro_len(skb)) {\n+\t\tNAPI_GRO_CB(skb)->flush = 1;\n+\t\treturn NULL;\n+\t}\n \t\/* pull encapsulating udp header *\/\n \tskb_gro_pull(skb, sizeof(struct udphdr));\n \tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n@@ -377,12 +384,12 @@ static struct sk_buff *udp_gro_receive_segment(struct list_head *head,\n \n \t\t\/* Terminate the flow on len mismatch or if it grow \"too much\".\n \t\t * Under small packet flood GRO count could elsewhere grow a lot\n-\t\t * leading to execessive truesize values.\n+\t\t * leading to excessive truesize values.\n \t\t * On len mismatch merge the first packet shorter than gso_size,\n \t\t * otherwise complete the GRO packet.\n \t\t *\/\n-\t\tif (uh->len > uh2->len || skb_gro_receive(p, skb) ||\n-\t\t    uh->len != uh2->len ||\n+\t\tif (ulen > ntohs(uh2->len) || skb_gro_receive(p, skb) ||\n+\t\t    ulen != ntohs(uh2->len) ||\n \t\t    NAPI_GRO_CB(p)->count >= UDP_GRO_CNT_MAX)\n \t\t\tpp = p;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5987","CWE_ID":"399","category":"security","commit_id":"6e86d90352adf6cb08295255220295cf23c4286e","commit_message":"From 6e86d90352adf6cb08295255220295cf23c4286e Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Tue, 28 Feb 2017 12:08:14 +0000\nSubject: [PATCH] sd: sdhci: check transfer mode register in multi block\n transfer\n\nIn the SDHCI protocol, the transfer mode register value\nis used during multi block transfer to check if block count\nregister is enabled and should be updated. Transfer mode\nregister could be set such that, block count register would\nnot be updated, thus leading to an infinite loop. Add check\nto avoid it.\n\nReported-by: Wjjzhang <wjjzhang@tencent.com>\nReported-by: Jiang Xin <jiangxin1@huawei.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-id: 20170214185225.7994-3-ppandit@redhat.com\nReviewed-by: Alistair Francis <alistair.francis@xilinx.com>\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>\n---\n hw\/sd\/sdhci.c | 10 +++++-----\n 1 file changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/hw\/sd\/sdhci.c b\/hw\/sd\/sdhci.c\nindex a65c77d..5adeab6 100644\n--- a\/hw\/sd\/sdhci.c\n+++ b\/hw\/sd\/sdhci.c\n@@ -487,6 +487,11 @@ static void sdhci_sdma_transfer_multi_blocks(SDHCIState *s)\n     uint32_t boundary_chk = 1 << (((s->blksize & 0xf000) >> 12) + 12);\n     uint32_t boundary_count = boundary_chk - (s->sdmasysad % boundary_chk);\n \n+    if (!(s->trnmod & SDHC_TRNS_BLK_CNT_EN) || !s->blkcnt) {\n+        qemu_log_mask(LOG_UNIMP, \"infinite transfer is not supported\\n\");\n+        return;\n+    }\n+\n     \/* XXX: Some sd\/mmc drivers (for example, u-boot-slp) do not account for\n      * possible stop at page boundary if initial address is not page aligned,\n      * allow them to work properly *\/\n@@ -798,11 +803,6 @@ static void sdhci_data_transfer(void *opaque)\n     if (s->trnmod & SDHC_TRNS_DMA) {\n         switch (SDHC_DMA_TYPE(s->hostctl)) {\n         case SDHC_CTRL_SDMA:\n-            if ((s->trnmod & SDHC_TRNS_MULTI) &&\n-                    (!(s->trnmod & SDHC_TRNS_BLK_CNT_EN) || s->blkcnt == 0)) {\n-                break;\n-            }\n-\n             if ((s->blkcnt == 1) || !(s->trnmod & SDHC_TRNS_MULTI)) {\n                 sdhci_sdma_transfer_single_block(s);\n             } else {\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2007-5501","CWE_ID":"399","category":"security","commit_id":"96a2d41a3e495734b63bff4e5dd0112741b93b38","commit_message":"From 96a2d41a3e495734b63bff4e5dd0112741b93b38 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Ilpo=20J=E4rvinen?= <ilpo.jarvinen@helsinki.fi>\nDate: Wed, 14 Nov 2007 15:47:18 -0800\nSubject: [TCP]: Make sure write_queue_from does not begin with NULL ptr\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nNULL ptr can be returned from tcp_write_queue_head to cached_skb\nand then assigned to skb if packets_out was zero. Without this,\nsystem is vulnerable to a carefully crafted ACKs which obviously\nis remotely triggerable.\n\nBesides, there's very little that needs to be done in sacktag\nif there weren't any packets outstanding, just skipping the rest\ndoesn't hurt.\n\nSigned-off-by: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp_input.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/net\/ipv4\/tcp_input.c b\/net\/ipv4\/tcp_input.c\nindex 12ae9a68cdaa..3f126ece8eb5 100644\n--- a\/net\/ipv4\/tcp_input.c\n+++ b\/net\/ipv4\/tcp_input.c\n@@ -1269,6 +1269,9 @@ tcp_sacktag_write_queue(struct sock *sk, struct sk_buff *ack_skb, u32 prior_snd_\n \tif (before(TCP_SKB_CB(ack_skb)->ack_seq, prior_snd_una - tp->max_window))\n \t\treturn 0;\n \n+\tif (!tp->packets_out)\n+\t\tgoto out;\n+\n \t\/* SACK fastpath:\n \t * if the only SACK change is the increase of the end_seq of\n \t * the first block then only apply that SACK block\n@@ -1515,6 +1518,8 @@ tcp_sacktag_write_queue(struct sock *sk, struct sk_buff *ack_skb, u32 prior_snd_\n \t    (!tp->frto_highmark || after(tp->snd_una, tp->frto_highmark)))\n \t\ttcp_update_reordering(sk, tp->fackets_out - reord, 0);\n \n+out:\n+\n #if FASTRETRANS_DEBUG > 0\n \tBUG_TRAP((int)tp->sacked_out >= 0);\n \tBUG_TRAP((int)tp->lost_out >= 0);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2010-3080","CWE_ID":"399","category":"security","commit_id":"27f7ad53829f79e799a253285318bff79ece15bd","commit_message":"From 27f7ad53829f79e799a253285318bff79ece15bd Mon Sep 17 00:00:00 2001\nFrom: Takashi Iwai <tiwai@suse.de>\nDate: Mon, 6 Sep 2010 09:13:45 +0200\nSubject: ALSA: seq\/oss - Fix double-free at error path of snd_seq_oss_open()\n\nThe error handling in snd_seq_oss_open() has several bad codes that\ndo dereferecing released pointers and double-free of kmalloc'ed data.\nThe object dp is release in free_devinfo() that is called via\nprivate_free callback.  The rest shouldn't touch this object any more.\n\nThe patch changes delete_port() to call kfree() in any case, and gets\nrid of unnecessary calls of destructors in snd_seq_oss_open().\n\nFixes CVE-2010-3080.\n\nReported-and-tested-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nCc: <stable@kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/core\/seq\/oss\/seq_oss_init.c | 9 ++++-----\n 1 file changed, 4 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/sound\/core\/seq\/oss\/seq_oss_init.c b\/sound\/core\/seq\/oss\/seq_oss_init.c\nindex 685712276ac9..69cd7b3c362d 100644\n--- a\/sound\/core\/seq\/oss\/seq_oss_init.c\n+++ b\/sound\/core\/seq\/oss\/seq_oss_init.c\n@@ -281,13 +281,10 @@ snd_seq_oss_open(struct file *file, int level)\n \treturn 0;\n \n  _error:\n-\tsnd_seq_oss_writeq_delete(dp->writeq);\n-\tsnd_seq_oss_readq_delete(dp->readq);\n \tsnd_seq_oss_synth_cleanup(dp);\n \tsnd_seq_oss_midi_cleanup(dp);\n-\tdelete_port(dp);\n \tdelete_seq_queue(dp->queue);\n-\tkfree(dp);\n+\tdelete_port(dp);\n \n \treturn rc;\n }\n@@ -350,8 +347,10 @@ create_port(struct seq_oss_devinfo *dp)\n static int\n delete_port(struct seq_oss_devinfo *dp)\n {\n-\tif (dp->port < 0)\n+\tif (dp->port < 0) {\n+\t\tkfree(dp);\n \t\treturn 0;\n+\t}\n \n \tdebug_printk((\"delete_port %i\\n\", dp->port));\n \treturn snd_seq_event_port_detach(dp->cseq, dp->port);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-2479","CWE_ID":"399","category":"security","commit_id":"78f11a255749d09025f54d4e2df4fbcb031530e2","commit_message":"From 78f11a255749d09025f54d4e2df4fbcb031530e2 Mon Sep 17 00:00:00 2001\nFrom: Andrea Arcangeli <aarcange@redhat.com>\nDate: Wed, 27 Apr 2011 15:26:45 -0700\nSubject: mm: thp: fix \/dev\/zero MAP_PRIVATE and vm_flags cleanups\n\nThe huge_memory.c THP page fault was allowed to run if vm_ops was null\n(which would succeed for \/dev\/zero MAP_PRIVATE, as the f_op->mmap wouldn't\nsetup a special vma->vm_ops and it would fallback to regular anonymous\nmemory) but other THP logics weren't fully activated for vmas with vm_file\nnot NULL (\/dev\/zero has a not NULL vma->vm_file).\n\nSo this removes the vm_file checks so that \/dev\/zero also can safely use\nTHP (the other albeit safer approach to fix this bug would have been to\nprevent the THP initial page fault to run if vm_file was set).\n\nAfter removing the vm_file checks, this also makes huge_memory.c stricter\nin khugepaged for the DEBUG_VM=y case.  It doesn't replace the vm_file\ncheck with a is_pfn_mapping check (but it keeps checking for VM_PFNMAP\nunder VM_BUG_ON) because for a is_cow_mapping() mapping VM_PFNMAP should\nonly be allowed to exist before the first page fault, and in turn when\nvma->anon_vma is null (so preventing khugepaged registration).  So I tend\nto think the previous comment saying if vm_file was set, VM_PFNMAP might\nhave been set and we could still be registered in khugepaged (despite\nanon_vma was not NULL to be registered in khugepaged) was too paranoid.\nThe is_linear_pfn_mapping check is also I think superfluous (as described\nby comment) but under DEBUG_VM it is safe to stay.\n\nAddresses https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=33682\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nReported-by: Caspar Zhang <bugs@casparzhang.com>\nAcked-by: Mel Gorman <mel@csn.ul.ie>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@kernel.org>\t\t[2.6.38.x]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n include\/linux\/huge_mm.h |  2 +-\n include\/linux\/mm.h      |  3 ++-\n mm\/huge_memory.c        | 43 ++++++++++++++++++++++++-------------------\n 3 files changed, 27 insertions(+), 21 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/huge_mm.h b\/include\/linux\/huge_mm.h\nindex df29c8fde36b..8847c8c29791 100644\n--- a\/include\/linux\/huge_mm.h\n+++ b\/include\/linux\/huge_mm.h\n@@ -117,7 +117,7 @@ static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,\n \t\t\t\t\t unsigned long end,\n \t\t\t\t\t long adjust_next)\n {\n-\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n+\tif (!vma->anon_vma || vma->vm_ops)\n \t\treturn;\n \t__vma_adjust_trans_huge(vma, start, end, adjust_next);\n }\ndiff --git a\/include\/linux\/mm.h b\/include\/linux\/mm.h\nindex 692dbae6ffa7..2348db26bc3d 100644\n--- a\/include\/linux\/mm.h\n+++ b\/include\/linux\/mm.h\n@@ -137,7 +137,8 @@ extern unsigned int kobjsize(const void *objp);\n #define VM_RandomReadHint(v)\t\t((v)->vm_flags & VM_RAND_READ)\n \n \/*\n- * special vmas that are non-mergable, non-mlock()able\n+ * Special vmas that are non-mergable, non-mlock()able.\n+ * Note: mm\/huge_memory.c VM_NO_THP depends on this definition.\n  *\/\n #define VM_SPECIAL (VM_IO | VM_DONTEXPAND | VM_RESERVED | VM_PFNMAP)\n \ndiff --git a\/mm\/huge_memory.c b\/mm\/huge_memory.c\nindex 470dcda10add..83326ad66d9b 100644\n--- a\/mm\/huge_memory.c\n+++ b\/mm\/huge_memory.c\n@@ -1408,6 +1408,9 @@ out:\n \treturn ret;\n }\n \n+#define VM_NO_THP (VM_SPECIAL|VM_INSERTPAGE|VM_MIXEDMAP|VM_SAO| \\\n+\t\t   VM_HUGETLB|VM_SHARED|VM_MAYSHARE)\n+\n int hugepage_madvise(struct vm_area_struct *vma,\n \t\t     unsigned long *vm_flags, int advice)\n {\n@@ -1416,11 +1419,7 @@ int hugepage_madvise(struct vm_area_struct *vma,\n \t\t\/*\n \t\t * Be somewhat over-protective like KSM for now!\n \t\t *\/\n-\t\tif (*vm_flags & (VM_HUGEPAGE |\n-\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n-\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n-\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n-\t\t\t\t VM_MIXEDMAP | VM_SAO))\n+\t\tif (*vm_flags & (VM_HUGEPAGE | VM_NO_THP))\n \t\t\treturn -EINVAL;\n \t\t*vm_flags &= ~VM_NOHUGEPAGE;\n \t\t*vm_flags |= VM_HUGEPAGE;\n@@ -1436,11 +1435,7 @@ int hugepage_madvise(struct vm_area_struct *vma,\n \t\t\/*\n \t\t * Be somewhat over-protective like KSM for now!\n \t\t *\/\n-\t\tif (*vm_flags & (VM_NOHUGEPAGE |\n-\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n-\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n-\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n-\t\t\t\t VM_MIXEDMAP | VM_SAO))\n+\t\tif (*vm_flags & (VM_NOHUGEPAGE | VM_NO_THP))\n \t\t\treturn -EINVAL;\n \t\t*vm_flags &= ~VM_HUGEPAGE;\n \t\t*vm_flags |= VM_NOHUGEPAGE;\n@@ -1574,10 +1569,14 @@ int khugepaged_enter_vma_merge(struct vm_area_struct *vma)\n \t\t * page fault if needed.\n \t\t *\/\n \t\treturn 0;\n-\tif (vma->vm_file || vma->vm_ops)\n+\tif (vma->vm_ops)\n \t\t\/* khugepaged not yet working on file or special mappings *\/\n \t\treturn 0;\n-\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n+\t\/*\n+\t * If is_pfn_mapping() is true is_learn_pfn_mapping() must be\n+\t * true too, verify it here.\n+\t *\/\n+\tVM_BUG_ON(is_linear_pfn_mapping(vma) || vma->vm_flags & VM_NO_THP);\n \thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n \thend = vma->vm_end & HPAGE_PMD_MASK;\n \tif (hstart < hend)\n@@ -1828,12 +1827,15 @@ static void collapse_huge_page(struct mm_struct *mm,\n \t    (vma->vm_flags & VM_NOHUGEPAGE))\n \t\tgoto out;\n \n-\t\/* VM_PFNMAP vmas may have vm_ops null but vm_file set *\/\n-\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n+\tif (!vma->anon_vma || vma->vm_ops)\n \t\tgoto out;\n \tif (is_vma_temporary_stack(vma))\n \t\tgoto out;\n-\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n+\t\/*\n+\t * If is_pfn_mapping() is true is_learn_pfn_mapping() must be\n+\t * true too, verify it here.\n+\t *\/\n+\tVM_BUG_ON(is_linear_pfn_mapping(vma) || vma->vm_flags & VM_NO_THP);\n \n \tpgd = pgd_offset(mm, address);\n \tif (!pgd_present(*pgd))\n@@ -2066,13 +2068,16 @@ static unsigned int khugepaged_scan_mm_slot(unsigned int pages,\n \t\t\tprogress++;\n \t\t\tcontinue;\n \t\t}\n-\t\t\/* VM_PFNMAP vmas may have vm_ops null but vm_file set *\/\n-\t\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n+\t\tif (!vma->anon_vma || vma->vm_ops)\n \t\t\tgoto skip;\n \t\tif (is_vma_temporary_stack(vma))\n \t\t\tgoto skip;\n-\n-\t\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n+\t\t\/*\n+\t\t * If is_pfn_mapping() is true is_learn_pfn_mapping()\n+\t\t * must be true too, verify it here.\n+\t\t *\/\n+\t\tVM_BUG_ON(is_linear_pfn_mapping(vma) ||\n+\t\t\t  vma->vm_flags & VM_NO_THP);\n \n \t\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n \t\thend = vma->vm_end & HPAGE_PMD_MASK;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-7970","CWE_ID":"399","category":"security","commit_id":"0d0826019e529f21c84687521d03f60cd241ca7d","commit_message":"From 0d0826019e529f21c84687521d03f60cd241ca7d Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Wed, 8 Oct 2014 10:42:27 -0700\nSubject: mnt: Prevent pivot_root from creating a loop in the mount tree\n\nAndy Lutomirski recently demonstrated that when chroot is used to set\nthe root path below the path for the new ``root'' passed to pivot_root\nthe pivot_root system call succeeds and leaks mounts.\n\nIn examining the code I see that starting with a new root that is\nbelow the current root in the mount tree will result in a loop in the\nmount tree after the mounts are detached and then reattached to one\nanother.  Resulting in all kinds of ugliness including a leak of that\nmounts involved in the leak of the mount loop.\n\nPrevent this problem by ensuring that the new mount is reachable from\nthe current root of the mount tree.\n\n[Added stable cc.  Fixes CVE-2014-7970.  --Andy]\n\nCc: stable@vger.kernel.org\nReported-by: Andy Lutomirski <luto@amacapital.net>\nReviewed-by: Andy Lutomirski <luto@amacapital.net>\nLink: http:\/\/lkml.kernel.org\/r\/87bnpmihks.fsf@x220.int.ebiederm.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\n---\n fs\/namespace.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/fs\/namespace.c b\/fs\/namespace.c\nindex ef42d9bee212..74647c2fe69c 100644\n--- a\/fs\/namespace.c\n+++ b\/fs\/namespace.c\n@@ -2820,6 +2820,9 @@ SYSCALL_DEFINE2(pivot_root, const char __user *, new_root,\n \t\/* make sure we can reach put_old from new_root *\/\n \tif (!is_path_reachable(old_mnt, old.dentry, &new))\n \t\tgoto out4;\n+\t\/* make certain new is below the root *\/\n+\tif (!is_path_reachable(new_mnt, new.dentry, &root))\n+\t\tgoto out4;\n \troot_mp->m_count++; \/* pin it so it won't go away *\/\n \tlock_mount_hash();\n \tdetach_mnt(new_mnt, &parent_path);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4162","CWE_ID":"399","category":"security","commit_id":"8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1","commit_message":"From 8822b64a0fa64a5dd1dfcf837c5b0be83f8c05d1 Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Mon, 1 Jul 2013 20:21:30 +0200\nSubject: ipv6: call udp_push_pending_frames when uncorking a socket with\n AF_INET pending data\n\nWe accidentally call down to ip6_push_pending_frames when uncorking\npending AF_INET data on a ipv6 socket. This results in the following\nsplat (from Dave Jones):\n\nskbuff: skb_under_panic: text:ffffffff816765f6 len:48 put:40 head:ffff88013deb6df0 data:ffff88013deb6dec tail:0x2c end:0xc0 dev:<NULL>\n------------[ cut here ]------------\nkernel BUG at net\/core\/skbuff.c:126!\ninvalid opcode: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC\nModules linked in: dccp_ipv4 dccp 8021q garp bridge stp dlci mpoa snd_seq_dummy sctp fuse hidp tun bnep nfnetlink scsi_transport_iscsi rfcomm can_raw can_bcm af_802154 appletalk caif_socket can caif ipt_ULOG x25 rose af_key pppoe pppox ipx phonet irda llc2 ppp_generic slhc p8023 psnap p8022 llc crc_ccitt atm bluetooth\n+netrom ax25 nfc rfkill rds af_rxrpc coretemp hwmon kvm_intel kvm crc32c_intel snd_hda_codec_realtek ghash_clmulni_intel microcode pcspkr snd_hda_codec_hdmi snd_hda_intel snd_hda_codec snd_hwdep usb_debug snd_seq snd_seq_device snd_pcm e1000e snd_page_alloc snd_timer ptp snd pps_core soundcore xfs libcrc32c\nCPU: 2 PID: 8095 Comm: trinity-child2 Not tainted 3.10.0-rc7+ #37\ntask: ffff8801f52c2520 ti: ffff8801e6430000 task.ti: ffff8801e6430000\nRIP: 0010:[<ffffffff816e759c>]  [<ffffffff816e759c>] skb_panic+0x63\/0x65\nRSP: 0018:ffff8801e6431de8  EFLAGS: 00010282\nRAX: 0000000000000086 RBX: ffff8802353d3cc0 RCX: 0000000000000006\nRDX: 0000000000003b90 RSI: ffff8801f52c2ca0 RDI: ffff8801f52c2520\nRBP: ffff8801e6431e08 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000001 R12: ffff88022ea0c800\nR13: ffff88022ea0cdf8 R14: ffff8802353ecb40 R15: ffffffff81cc7800\nFS:  00007f5720a10740(0000) GS:ffff880244c00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000005862000 CR3: 000000022843c000 CR4: 00000000001407e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000600\nStack:\n ffff88013deb6dec 000000000000002c 00000000000000c0 ffffffff81a3f6e4\n ffff8801e6431e18 ffffffff8159a9aa ffff8801e6431e90 ffffffff816765f6\n ffffffff810b756b 0000000700000002 ffff8801e6431e40 0000fea9292aa8c0\nCall Trace:\n [<ffffffff8159a9aa>] skb_push+0x3a\/0x40\n [<ffffffff816765f6>] ip6_push_pending_frames+0x1f6\/0x4d0\n [<ffffffff810b756b>] ? mark_held_locks+0xbb\/0x140\n [<ffffffff81694919>] udp_v6_push_pending_frames+0x2b9\/0x3d0\n [<ffffffff81694660>] ? udplite_getfrag+0x20\/0x20\n [<ffffffff8162092a>] udp_lib_setsockopt+0x1aa\/0x1f0\n [<ffffffff811cc5e7>] ? fget_light+0x387\/0x4f0\n [<ffffffff816958a4>] udpv6_setsockopt+0x34\/0x40\n [<ffffffff815949f4>] sock_common_setsockopt+0x14\/0x20\n [<ffffffff81593c31>] SyS_setsockopt+0x71\/0xd0\n [<ffffffff816f5d54>] tracesys+0xdd\/0xe2\nCode: 00 00 48 89 44 24 10 8b 87 d8 00 00 00 48 89 44 24 08 48 8b 87 e8 00 00 00 48 c7 c7 c0 04 aa 81 48 89 04 24 31 c0 e8 e1 7e ff ff <0f> 0b 55 48 89 e5 0f 0b 55 48 89 e5 0f 0b 55 48 89 e5 0f 0b 55\nRIP  [<ffffffff816e759c>] skb_panic+0x63\/0x65\n RSP <ffff8801e6431de8>\n\nThis patch adds a check if the pending data is of address family AF_INET\nand directly calls udp_push_ending_frames from udp_v6_push_pending_frames\nif that is the case.\n\nThis bug was found by Dave Jones with trinity.\n\n(Also move the initialization of fl6 below the AF_INET check, even if\nnot strictly necessary.)\n\nCc: Dave Jones <davej@redhat.com>\nCc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/udp.h | 1 +\n net\/ipv4\/udp.c    | 3 ++-\n net\/ipv6\/udp.c    | 7 ++++++-\n 3 files changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/udp.h b\/include\/net\/udp.h\nindex b30a71a51839..74c10ec5e74f 100644\n--- a\/include\/net\/udp.h\n+++ b\/include\/net\/udp.h\n@@ -181,6 +181,7 @@ extern int udp_get_port(struct sock *sk, unsigned short snum,\n extern void udp_err(struct sk_buff *, u32);\n extern int udp_sendmsg(struct kiocb *iocb, struct sock *sk,\n \t\t\t    struct msghdr *msg, size_t len);\n+extern int udp_push_pending_frames(struct sock *sk);\n extern void udp_flush_pending_frames(struct sock *sk);\n extern int udp_rcv(struct sk_buff *skb);\n extern int udp_ioctl(struct sock *sk, int cmd, unsigned long arg);\ndiff --git a\/net\/ipv4\/udp.c b\/net\/ipv4\/udp.c\nindex 959502afd8d9..6b270e53c207 100644\n--- a\/net\/ipv4\/udp.c\n+++ b\/net\/ipv4\/udp.c\n@@ -800,7 +800,7 @@ send:\n \/*\n  * Push out all pending data as one UDP datagram. Socket is locked.\n  *\/\n-static int udp_push_pending_frames(struct sock *sk)\n+int udp_push_pending_frames(struct sock *sk)\n {\n \tstruct udp_sock  *up = udp_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n@@ -819,6 +819,7 @@ out:\n \tup->pending = 0;\n \treturn err;\n }\n+EXPORT_SYMBOL(udp_push_pending_frames);\n \n int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t\tsize_t len)\ndiff --git a\/net\/ipv6\/udp.c b\/net\/ipv6\/udp.c\nindex f77e34c5a0e2..b6f31437a1f8 100644\n--- a\/net\/ipv6\/udp.c\n+++ b\/net\/ipv6\/udp.c\n@@ -959,11 +959,16 @@ static int udp_v6_push_pending_frames(struct sock *sk)\n \tstruct udphdr *uh;\n \tstruct udp_sock  *up = udp_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n-\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n+\tstruct flowi6 *fl6;\n \tint err = 0;\n \tint is_udplite = IS_UDPLITE(sk);\n \t__wsum csum = 0;\n \n+\tif (up->pending == AF_INET)\n+\t\treturn udp_push_pending_frames(sk);\n+\n+\tfl6 = &inet->cork.fl.u.ip6;\n+\n \t\/* Grab the skbuff where UDP header space exists. *\/\n \tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n \t\tgoto out;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-7377","CWE_ID":"399","category":"security","commit_id":"d63fb193e71644a073b77ff5ac6f1216f2f6cf6e","commit_message":"From d63fb193e71644a073b77ff5ac6f1216f2f6cf6e Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Mon, 27 Mar 2017 21:13:19 +0200\nSubject: [PATCH] 9pfs: fix file descriptor leak\n\nThe v9fs_create() and v9fs_lcreate() functions are used to create a file\non the backend and to associate it to a fid. The fid shouldn't be already\nin-use, otherwise both functions may silently leak a file descriptor or\nallocated memory. The current code doesn't check that.\n\nThis patch ensures that the fid isn't already associated to anything\nbefore using it.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\n(reworded the changelog, Greg Kurz)\nSigned-off-by: Greg Kurz <groug@kaod.org>\n---\n hw\/9pfs\/9p.c | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\n","diff_code":"diff --git a\/hw\/9pfs\/9p.c b\/hw\/9pfs\/9p.c\nindex b8c0b99..48babce 100644\n--- a\/hw\/9pfs\/9p.c\n+++ b\/hw\/9pfs\/9p.c\n@@ -1550,6 +1550,10 @@ static void coroutine_fn v9fs_lcreate(void *opaque)\n         err = -ENOENT;\n         goto out_nofid;\n     }\n+    if (fidp->fid_type != P9_FID_NONE) {\n+        err = -EINVAL;\n+        goto out;\n+    }\n \n     flags = get_dotl_openflags(pdu->s, flags);\n     err = v9fs_co_open2(pdu, fidp, &name, gid,\n@@ -2153,6 +2157,10 @@ static void coroutine_fn v9fs_create(void *opaque)\n         err = -EINVAL;\n         goto out_nofid;\n     }\n+    if (fidp->fid_type != P9_FID_NONE) {\n+        err = -EINVAL;\n+        goto out;\n+    }\n     if (perm & P9_STAT_MODE_DIR) {\n         err = v9fs_co_mkdir(pdu, fidp, &name, perm & 0777,\n                             fidp->uid, -1, &stbuf);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5850","CWE_ID":"399","category":"security","commit_id":"142cfc82b932bc211218fbd7bdda8c7ce83f19df","commit_message":"From 142cfc82b932bc211218fbd7bdda8c7ce83f19df Mon Sep 17 00:00:00 2001\nFrom: reyk <reyk@openbsd.org>\nDate: Tue, 31 Jan 2017 14:39:47 +0000\nSubject: [PATCH] Reimplement httpd's support for byte ranges.\n\nThe previous implementation loaded all the output into a single output\nbuffer and used its size to determine the Content-Length of the body.\n\nThe new implementation calculates the body length first and writes the\nindividual ranges in an async way using the bufferevent mechanism.\n\nThis prevents httpd from using too much memory and applies the\nwatermark and throttling mechanisms to range requests.\n\nProblem reported by Pierre Kim (pierre.kim.sec at gmail.com)\n\nOK benno@ sunil@\n---\n usr.sbin\/httpd\/httpd.h       |  25 +++++-\n usr.sbin\/httpd\/server_file.c | 157 ++++++++++++++---------------------\n usr.sbin\/httpd\/server_http.c |  99 +++++++++++++++++++++-\n 3 files changed, 183 insertions(+), 98 deletions(-)\n\n","diff_code":"diff --git a\/usr.sbin\/httpd\/httpd.h b\/usr.sbin\/httpd\/httpd.h\nindex 94fe76534af..5490b4919cc 100644\n--- a\/usr.sbin\/httpd\/httpd.h\n+++ b\/usr.sbin\/httpd\/httpd.h\n@@ -1,4 +1,4 @@\n-\/*\t$OpenBSD: httpd.h,v 1.126 2017\/01\/31 12:21:27 reyk Exp $\t*\/\n+\/*\t$OpenBSD: httpd.h,v 1.127 2017\/01\/31 14:39:47 reyk Exp $\t*\/\n \n \/*\n  * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>\n@@ -73,6 +73,7 @@\n #define SERVER_MAX_PREFETCH\t256\n #define SERVER_MIN_PREFETCHED\t32\n #define SERVER_HSTS_DEFAULT_AGE\t31536000\n+#define SERVER_MAX_RANGES\t4\n \n #define MEDIATYPE_NAMEMAX\t128\t\/* file name extension *\/\n #define MEDIATYPE_TYPEMAX\t64\t\/* length of type\/subtype *\/\n@@ -93,7 +94,8 @@ enum httpchunk {\n \tTOREAD_HTTP_HEADER\t\t= -2,\n \tTOREAD_HTTP_CHUNK_LENGTH\t= -3,\n \tTOREAD_HTTP_CHUNK_TRAILER\t= -4,\n-\tTOREAD_HTTP_NONE\t\t= -5\n+\tTOREAD_HTTP_NONE\t\t= -5,\n+\tTOREAD_HTTP_RANGE\t\t= TOREAD_HTTP_CHUNK_LENGTH\n };\n \n #if DEBUG\n@@ -295,6 +297,22 @@ struct fcgi_data {\n \tint\t\t\t headersdone;\n };\n \n+struct range {\n+\toff_t\tstart;\n+\toff_t\tend;\n+};\n+\n+struct range_data {\n+\tstruct range\t\t range[SERVER_MAX_RANGES];\n+\tint\t\t\t range_count;\n+\tint\t\t\t range_index;\n+\toff_t\t\t\t range_toread;\n+\n+\t\/* For the Content headers in each part *\/\n+\tstruct media_type\t*range_media;\n+\tsize_t\t\t\t range_total;\n+};\n+\n struct client {\n \tuint32_t\t\t clt_id;\n \tpid_t\t\t\t clt_pid;\n@@ -313,6 +331,7 @@ struct client {\n \tvoid\t\t\t*clt_descreq;\n \tvoid\t\t\t*clt_descresp;\n \tint\t\t\t clt_sndbufsiz;\n+\tuint64_t\t\t clt_boundary;\n \n \tint\t\t\t clt_fd;\n \tstruct tls\t\t*clt_tls_ctx;\n@@ -327,6 +346,7 @@ struct client {\n \tint\t\t\t clt_done;\n \tint\t\t\t clt_chunk;\n \tint\t\t\t clt_inflight;\n+\tstruct range_data\t clt_ranges;\n \tstruct fcgi_data\t clt_fcgi;\n \tchar\t\t\t*clt_remote_user;\n \tstruct evbuffer\t\t*clt_srvevb;\n@@ -601,6 +621,7 @@ const char\n \t*server_httperror_byid(unsigned int);\n void\t server_read_httpcontent(struct bufferevent *, void *);\n void\t server_read_httpchunks(struct bufferevent *, void *);\n+void\t server_read_httprange(struct bufferevent *, void *);\n int\t server_writeheader_http(struct client *clt, struct kv *, void *);\n int\t server_headers(struct client *, void *,\n \t    int (*)(struct client *, struct kv *, void *), void *);\ndiff --git a\/usr.sbin\/httpd\/server_file.c b\/usr.sbin\/httpd\/server_file.c\nindex 500742ec927..62c6fad306e 100644\n--- a\/usr.sbin\/httpd\/server_file.c\n+++ b\/usr.sbin\/httpd\/server_file.c\n@@ -1,7 +1,7 @@\n-\/*\t$OpenBSD: server_file.c,v 1.63 2017\/01\/30 09:54:41 reyk Exp $\t*\/\n+\/*\t$OpenBSD: server_file.c,v 1.64 2017\/01\/31 14:39:47 reyk Exp $\t*\/\n \n \/*\n- * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>\n+ * Copyright (c) 2006 - 2017 Reyk Floeter <reyk@openbsd.org>\n  *\n  * Permission to use, copy, modify, and distribute this software for any\n  * purpose with or without fee is hereby granted, provided that the above\n@@ -36,12 +36,6 @@\n \n #define MINIMUM(a, b)\t(((a) < (b)) ? (a) : (b))\n #define MAXIMUM(a, b)\t(((a) > (b)) ? (a) : (b))\n-#define MAX_RANGES\t4\n-\n-struct range {\n-\toff_t\tstart;\n-\toff_t\tend;\n-};\n \n int\t\t server_file_access(struct httpd *, struct client *,\n \t\t    char *, size_t);\n@@ -55,8 +49,7 @@ int\t\t server_file_modified_since(struct http_descriptor *,\n \t\t    struct stat *);\n int\t\t server_file_method(struct client *);\n int\t\t parse_range_spec(char *, size_t, struct range *);\n-struct range\t*parse_range(char *, size_t, int *);\n-int\t\t buffer_add_range(int, struct evbuffer *, struct range *);\n+int\t\t parse_ranges(struct client *, char *, size_t);\n \n int\n server_file_access(struct httpd *env, struct client *clt,\n@@ -303,11 +296,10 @@ server_partial_file_request(struct httpd *env, struct client *clt, char *path,\n \tstruct http_descriptor\t*resp = clt->clt_descresp;\n \tstruct http_descriptor\t*desc = clt->clt_descreq;\n \tstruct media_type\t*media, multipart_media;\n+\tstruct range_data\t*r = &clt->clt_ranges;\n \tstruct range\t\t*range;\n-\tstruct evbuffer\t\t*evb = NULL;\n-\tsize_t\t\t\t content_length;\n+\tsize_t\t\t\t content_length = 0;\n \tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n-\tuint32_t\t\t boundary;\n \tchar\t\t\t content_range[64];\n \tconst char\t\t*errstr = NULL;\n \n@@ -315,7 +307,7 @@ server_partial_file_request(struct httpd *env, struct client *clt, char *path,\n \tif (desc->http_method != HTTP_METHOD_GET)\n \t\treturn server_file_request(env, clt, path, st);\n \n-\tif ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {\n+\tif ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {\n \t\tcode = 416;\n \t\t(void)snprintf(content_range, sizeof(content_range),\n \t\t    \"bytes *\/%lld\", st->st_size);\n@@ -328,12 +320,10 @@ server_partial_file_request(struct httpd *env, struct client *clt, char *path,\n \t\tgoto abort;\n \n \tmedia = media_find_config(env, srv_conf, path);\n-\tif ((evb = evbuffer_new()) == NULL) {\n-\t\terrstr = \"failed to allocate file buffer\";\n-\t\tgoto abort;\n-\t}\n+\tr->range_media = media;\n \n \tif (nranges == 1) {\n+\t\trange = &r->range[0];\n \t\t(void)snprintf(content_range, sizeof(content_range),\n \t\t    \"bytes %lld-%lld\/%lld\", range->start, range->end,\n \t\t    st->st_size);\n@@ -341,56 +331,46 @@ server_partial_file_request(struct httpd *env, struct client *clt, char *path,\n \t\t    content_range) == NULL)\n \t\t\tgoto abort;\n \n-\t\tcontent_length = range->end - range->start + 1;\n-\t\tif (buffer_add_range(fd, evb, range) == 0)\n-\t\t\tgoto abort;\n-\n+\t\trange = &r->range[0];\n+\t\tcontent_length += range->end - range->start + 1;\n \t} else {\n-\t\tcontent_length = 0;\n-\t\tboundary = arc4random();\n-\t\t\/* Generate a multipart payload of byteranges *\/\n-\t\twhile (nranges--) {\n-\t\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud\\r\\n\",\n-\t\t\t    boundary)) == -1)\n-\t\t\t\tgoto abort;\n+\t\t\/* Add boundary, all parts will be handled by the callback *\/\n+\t\tarc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));\n \n-\t\t\tcontent_length += i;\n-\t\t\tif ((i = evbuffer_add_printf(evb,\n-\t\t\t    \"Content-Type: %s\/%s\\r\\n\",\n-\t\t\t    media->media_type, media->media_subtype)) == -1)\n-\t\t\t\tgoto abort;\n+\t\t\/* Calculate Content-Length of the complete multipart body *\/\n+\t\tfor (i = 0; i < nranges; i++) {\n+\t\t\trange = &r->range[i];\n \n-\t\t\tcontent_length += i;\n-\t\t\tif ((i = evbuffer_add_printf(evb,\n+\t\t\t\/* calculate Content-Length of the complete body *\/\n+\t\t\tif ((ret = snprintf(NULL, 0,\n+\t\t\t    \"\\r\\n--%llu\\r\\n\"\n+\t\t\t    \"Content-Type: %s\/%s\\r\\n\"\n \t\t\t    \"Content-Range: bytes %lld-%lld\/%lld\\r\\n\\r\\n\",\n-\t\t\t    range->start, range->end, st->st_size)) == -1)\n+\t\t\t    clt->clt_boundary,\n+\t\t\t    media->media_type, media->media_subtype,\n+\t\t\t    range->start, range->end, st->st_size)) < 0)\n \t\t\t\tgoto abort;\n \n-\t\t\tcontent_length += i;\n-\t\t\tif (buffer_add_range(fd, evb, range) == 0)\n-\t\t\t\tgoto abort;\n+\t\t\t\/* Add data length *\/\n+\t\t\tcontent_length += ret + range->end - range->start + 1;\n \n-\t\t\tcontent_length += range->end - range->start + 1;\n-\t\t\trange++;\n \t\t}\n-\n-\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud--\\r\\n\",\n-\t\t    boundary)) == -1)\n+\t\tif ((ret = snprintf(NULL, 0, \"\\r\\n--%llu--\\r\\n\",\n+\t\t    clt->clt_boundary)) < 0)\n \t\t\tgoto abort;\n-\n-\t\tcontent_length += i;\n+\t\tcontent_length += ret;\n \n \t\t\/* prepare multipart\/byteranges media type *\/\n \t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n \t\t    sizeof(multipart_media.media_type));\n \t\t(void)snprintf(multipart_media.media_subtype,\n \t\t    sizeof(multipart_media.media_subtype),\n-\t\t    \"byteranges; boundary=%ud\", boundary);\n+\t\t    \"byteranges; boundary=%llu\", clt->clt_boundary);\n \t\tmedia = &multipart_media;\n \t}\n \n-\tclose(fd);\n-\tfd = -1;\n+\t\/* Start with first range *\/\n+\tr->range_toread = TOREAD_HTTP_RANGE;\n \n \tret = server_response_http(clt, 206, media, content_length,\n \t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n@@ -399,23 +379,34 @@ server_partial_file_request(struct httpd *env, struct client *clt, char *path,\n \t\tgoto fail;\n \tcase 0:\n \t\t\/* Connection is already finished *\/\n+\t\tclose(fd);\n \t\tgoto done;\n \tdefault:\n \t\tbreak;\n \t}\n \n-\tif (server_bufferevent_write_buffer(clt, evb) == -1)\n+\tclt->clt_fd = fd;\n+\tif (clt->clt_srvbev != NULL)\n+\t\tbufferevent_free(clt->clt_srvbev);\n+\n+\tclt->clt_srvbev_throttled = 0;\n+\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,\n+\t    server_write, server_file_error, clt);\n+\tif (clt->clt_srvbev == NULL) {\n+\t\terrstr = \"failed to allocate file buffer event\";\n \t\tgoto fail;\n+\t}\n \n-\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n-\tif (clt->clt_persist)\n-\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n-\telse\n-\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n-\tclt->clt_done = 0;\n+\t\/* Adjust read watermark to the socket output buffer size *\/\n+\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,\n+\t    clt->clt_sndbufsiz);\n+\n+\tbufferevent_settimeout(clt->clt_srvbev,\n+\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);\n+\tbufferevent_enable(clt->clt_srvbev, EV_READ);\n+\tbufferevent_disable(clt->clt_bev, EV_READ);\n \n  done:\n-\tevbuffer_free(evb);\n \tserver_reset_http(clt);\n \treturn (0);\n  fail:\n@@ -423,8 +414,6 @@ server_partial_file_request(struct httpd *env, struct client *clt, char *path,\n \tbufferevent_free(clt->clt_bev);\n \tclt->clt_bev = NULL;\n  abort:\n-\tif (evb != NULL)\n-\t\tevbuffer_free(evb);\n \tif (fd != -1)\n \t\tclose(fd);\n \tif (errstr == NULL)\n@@ -668,41 +657,44 @@ server_file_modified_since(struct http_descriptor *desc, struct stat *st)\n \treturn (-1);\n }\n \n-struct range *\n-parse_range(char *str, size_t file_sz, int *nranges)\n+int\n+parse_ranges(struct client *clt, char *str, size_t file_sz)\n {\n-\tstatic struct range\t ranges[MAX_RANGES];\n \tint\t\t\t i = 0;\n \tchar\t\t\t*p, *q;\n+\tstruct range_data\t*r = &clt->clt_ranges;\n+\n+\tmemset(r, 0, sizeof(*r));\n \n \t\/* Extract range unit *\/\n \tif ((p = strchr(str, '=')) == NULL)\n-\t\treturn (NULL);\n+\t\treturn (-1);\n \n \t*p++ = '\\0';\n \t\/* Check if it's a bytes range spec *\/\n \tif (strcmp(str, \"bytes\") != 0)\n-\t\treturn (NULL);\n+\t\treturn (-1);\n \n \twhile ((q = strchr(p, ',')) != NULL) {\n \t\t*q++ = '\\0';\n \n \t\t\/* Extract start and end positions *\/\n-\t\tif (parse_range_spec(p, file_sz, &ranges[i]) == 0)\n+\t\tif (parse_range_spec(p, file_sz, &r->range[i]) == 0)\n \t\t\tcontinue;\n \n \t\ti++;\n-\t\tif (i == MAX_RANGES)\n-\t\t\treturn (NULL);\n+\t\tif (i == SERVER_MAX_RANGES)\n+\t\t\treturn (-1);\n \n \t\tp = q;\n \t}\n \n-\tif (parse_range_spec(p, file_sz, &ranges[i]) != 0)\n+\tif (parse_range_spec(p, file_sz, &r->range[i]) != 0)\n \t\ti++;\n \n-\t*nranges = i;\n-\treturn (i ? ranges : NULL);\n+\tr->range_total = file_sz;\n+\tr->range_count = i;\n+\treturn (i);\n }\n \n int\n@@ -752,26 +744,3 @@ parse_range_spec(char *str, size_t size, struct range *r)\n \n \treturn (1);\n }\n-\n-int\n-buffer_add_range(int fd, struct evbuffer *evb, struct range *range)\n-{\n-\tchar\tbuf[BUFSIZ];\n-\tsize_t\tn, range_sz;\n-\tssize_t\tnread;\n-\n-\tif (lseek(fd, range->start, SEEK_SET) == -1)\n-\t\treturn (0);\n-\n-\trange_sz = range->end - range->start + 1;\n-\twhile (range_sz) {\n-\t\tn = MINIMUM(range_sz, sizeof(buf));\n-\t\tif ((nread = read(fd, buf, n)) == -1)\n-\t\t\treturn (0);\n-\n-\t\tevbuffer_add(evb, buf, nread);\n-\t\trange_sz -= nread;\n-\t}\n-\n-\treturn (1);\n-}\ndiff --git a\/usr.sbin\/httpd\/server_http.c b\/usr.sbin\/httpd\/server_http.c\nindex 9b4457d6b5d..b5ea1a8e27e 100644\n--- a\/usr.sbin\/httpd\/server_http.c\n+++ b\/usr.sbin\/httpd\/server_http.c\n@@ -1,7 +1,7 @@\n-\/*\t$OpenBSD: server_http.c,v 1.111 2017\/01\/31 12:21:27 reyk Exp $\t*\/\n+\/*\t$OpenBSD: server_http.c,v 1.112 2017\/01\/31 14:39:47 reyk Exp $\t*\/\n \n \/*\n- * Copyright (c) 2006 - 2015 Reyk Floeter <reyk@openbsd.org>\n+ * Copyright (c) 2006 - 2017 Reyk Floeter <reyk@openbsd.org>\n  *\n  * Permission to use, copy, modify, and distribute this software for any\n  * purpose with or without fee is hereby granted, provided that the above\n@@ -609,6 +609,101 @@ server_read_httpchunks(struct bufferevent *bev, void *arg)\n \tserver_close(clt, strerror(errno));\n }\n \n+void\n+server_read_httprange(struct bufferevent *bev, void *arg)\n+{\n+\tstruct client\t\t*clt = arg;\n+\tstruct evbuffer\t\t*src = EVBUFFER_INPUT(bev);\n+\tsize_t\t\t\t size;\n+\tstruct media_type\t*media;\n+\tstruct range_data\t*r = &clt->clt_ranges;\n+\tstruct range\t\t*range;\n+\n+\tgetmonotime(&clt->clt_tv_last);\n+\n+\tif (r->range_toread > 0) {\n+\t\tsize = EVBUFFER_LENGTH(src);\n+\t\tif (!size)\n+\t\t\treturn;\n+\n+\t\t\/* Read chunk data *\/\n+\t\tif ((off_t)size > r->range_toread) {\n+\t\t\tsize = r->range_toread;\n+\t\t\tif (server_bufferevent_write_chunk(clt, src, size)\n+\t\t\t    == -1)\n+\t\t\t\tgoto fail;\n+\t\t\tr->range_toread = 0;\n+\t\t} else {\n+\t\t\tif (server_bufferevent_write_buffer(clt, src) == -1)\n+\t\t\t\tgoto fail;\n+\t\t\tr->range_toread -= size;\n+\t\t}\n+\t\tif (r->range_toread < 1)\n+\t\t\tr->range_toread = TOREAD_HTTP_RANGE;\n+\t\tDPRINTF(\"%s: done, size %lu, to read %lld\", __func__,\n+\t\t    size, r->range_toread);\n+\t}\n+\n+\tswitch (r->range_toread) {\n+\tcase TOREAD_HTTP_RANGE:\n+\t\tif (r->range_index >= r->range_count) {\n+\t\t\tif (r->range_count > 1) {\n+\t\t\t\t\/* Add end marker *\/\n+\t\t\t\tif (server_bufferevent_printf(clt,\n+\t\t\t\t    \"\\r\\n--%llu--\\r\\n\",\n+\t\t\t\t    clt->clt_boundary) == -1)\n+\t\t\t\t\tgoto fail;\n+\t\t\t}\n+\t\t\tr->range_toread = TOREAD_HTTP_NONE;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\trange = &r->range[r->range_index];\n+\n+\t\tif (r->range_count > 1) {\n+\t\t\tmedia = r->range_media;\n+\t\t\tif (server_bufferevent_printf(clt,\n+\t\t\t    \"\\r\\n--%llu\\r\\n\"\n+\t\t\t    \"Content-Type: %s\/%s\\r\\n\"\n+\t\t\t    \"Content-Range: bytes %lld-%lld\/%zu\\r\\n\\r\\n\",\n+\t\t\t    clt->clt_boundary,\n+\t\t\t    media->media_type, media->media_subtype,\n+\t\t\t    range->start, range->end, r->range_total) == -1)\n+\t\t\t\tgoto fail;\n+\t\t}\n+\t\tr->range_toread = range->end - range->start + 1;\n+\n+\t\tif (lseek(clt->clt_fd, range->start, SEEK_SET) == -1)\n+\t\t\tgoto fail;\n+\n+\t\t\/* Throw away bytes that are already in the input buffer *\/\n+\t\tevbuffer_drain(src, EVBUFFER_LENGTH(src));\n+\n+\t\t\/* Increment for the next part *\/\n+\t\tr->range_index++;\n+\t\tbreak;\n+\tcase TOREAD_HTTP_NONE:\n+\tcase 0:\n+\t\tbreak;\n+\t}\n+\n+\tif (clt->clt_done)\n+\t\tgoto done;\n+\n+\tif (EVBUFFER_LENGTH(EVBUFFER_OUTPUT(clt->clt_bev)) > (size_t)\n+\t    SERVER_MAX_PREFETCH * clt->clt_sndbufsiz) {\n+\t\tbufferevent_disable(clt->clt_srvbev, EV_READ);\n+\t\tclt->clt_srvbev_throttled = 1;\n+\t}\n+\n+\treturn;\n+ done:\n+\t(*bev->errorcb)(bev, EVBUFFER_READ, bev->cbarg);\n+\treturn;\n+ fail:\n+\tserver_close(clt, strerror(errno));\n+}\n+\n void\n server_reset_http(struct client *clt)\n {\n","owner":"openbsd","repo":"src","source":"cve"},{"CVE_ID":"CVE-2012-0023","CWE_ID":"399","category":"security","commit_id":"7d282fac1cc455b5a5eca2bb56375efcbf879b06","commit_message":"From 7d282fac1cc455b5a5eca2bb56375efcbf879b06 Mon Sep 17 00:00:00 2001\nFrom: Clement Lecigne <clecigne@google.com>\nDate: Tue, 20 Dec 2011 17:44:10 +0200\nSubject: [PATCH] TiVo: fix double free\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nSigned-off-by: R\u00c3\u00a9mi Denis-Courmont <remi@remlab.net>\n---\n modules\/demux\/ty.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/modules\/demux\/ty.c b\/modules\/demux\/ty.c\nindex e916b41147..b181a6a73b 100644\n--- a\/modules\/demux\/ty.c\n+++ b\/modules\/demux\/ty.c\n@@ -1887,6 +1887,7 @@ static int get_chunk_header(demux_t *p_demux)\n     \/*msg_Dbg( p_demux, \"chunk has %d records\", i_num_recs );*\/\n \n     free(p_sys->rec_hdrs);\n+    p_sys->rec_hdrs = NULL;\n \n     \/* skip past the 4 bytes we \"peeked\" earlier *\/\n     stream_Read( p_demux->s, NULL, 4 );\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-4326","CWE_ID":"399","category":"security","commit_id":"a9cf73ea7ff78f52662c8658d93c226effbbedde","commit_message":"From a9cf73ea7ff78f52662c8658d93c226effbbedde Mon Sep 17 00:00:00 2001\nFrom: Shan Wei <shanwei@cn.fujitsu.com>\nDate: Tue, 19 Apr 2011 22:52:49 +0000\nSubject: [PATCH] ipv6: udp: fix the wrong headroom check\n\nAt this point, skb->data points to skb_transport_header.\nSo, headroom check is wrong.\n\nFor some case:bridge(UFO is on) + eth device(UFO is off),\nthere is no enough headroom for IPv6 frag head.\nBut headroom check is always false.\n\nThis will bring about data be moved to there prior to skb->head,\nwhen adding IPv6 frag header to skb.\n\nSigned-off-by: Shan Wei <shanwei@cn.fujitsu.com>\nAcked-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/udp.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/udp.c b\/net\/ipv6\/udp.c\nindex 15c37746845ed..9e305d74b3d41 100644\n--- a\/net\/ipv6\/udp.c\n+++ b\/net\/ipv6\/udp.c\n@@ -1335,7 +1335,7 @@ static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n \tskb->ip_summed = CHECKSUM_NONE;\n \n \t\/* Check if there is enough headroom to insert fragment header. *\/\n-\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n+\tif ((skb_mac_header(skb) < skb->head + frag_hdr_sz) &&\n \t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n \t\tgoto out;\n \n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-3538","CWE_ID":"399","category":"security","commit_id":"4a284c89d6ef11aca34da65da7d673050a5ea320","commit_message":"From 4a284c89d6ef11aca34da65da7d673050a5ea320 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Tue, 3 Jun 2014 19:01:34 +0000\nSubject: [PATCH] * Enforce limit of 8K on regex searches that have no limits *\n Allow the l modifier for regex to mean line count. Default   to byte count.\n If line count is specified, assume a max   of 80 characters per line to limit\n the byte count. * Don't allow conversions to be used for dates, allowing  \n the mask field to be used as an offset. * Bump the version of the magic\n format so that regex changes   are visible.\n\n---\n ChangeLog               |  9 ++++++\n doc\/magic.man           | 16 +++++++--\n magic\/Magdir\/android    | 14 ++++----\n magic\/Magdir\/fortran    |  4 +--\n magic\/Magdir\/graphviz   |  6 ++--\n magic\/Magdir\/marc21     | 12 +++----\n magic\/Magdir\/scientific | 12 +++----\n magic\/Magdir\/troff      |  6 ++--\n src\/apprentice.c        | 12 +++++--\n src\/file.h              |  5 +--\n src\/softmagic.c         | 72 ++++++++++++++++++++++++-----------------\n 11 files changed, 105 insertions(+), 63 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 976dbc4da..ad244c133 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,12 @@\n+2014-06-02  14:50  Christos Zoulas <christos@zoulas.com>\n+\n+\t* Enforce limit of 8K on regex searches that have no limits\n+\t* Allow the l modifier for regex to mean line count. Default\n+\t  to byte count. If line count is specified, assume a max\n+\t  of 80 characters per line to limit the byte count.\n+\t* Don't allow conversions to be used for dates, allowing\n+\t  the mask field to be used as an offset.\n+\n 2014-05-30  12:51  Christos Zoulas <christos@zoulas.com>\n \n \t* Make the range operator limit the length of the\ndiff --git a\/doc\/magic.man b\/doc\/magic.man\nindex a79ad255f..66d3b1738 100644\n--- a\/doc\/magic.man\n+++ b\/doc\/magic.man\n@@ -1,4 +1,4 @@\n-.\\\" $File: magic.man,v 1.82 2014\/05\/30 16:51:23 christos Exp $\n+.\\\" $File: magic.man,v 1.83 2014\/06\/03 17:36:13 christos Exp $\n .Dd June 3, 2014\n .Dt MAGIC __FSECTION__\n .Os\n@@ -232,12 +232,21 @@ The size of the string to search should also be limited by specifying\n .Dv \/<length> ,\n to avoid performance issues scanning long files.\n The type specification can also be optionally followed by\n-.Dv \/[c][s] .\n+.Dv \/[c][s][l] .\n The\n .Dq c\n flag makes the match case insensitive, while the\n .Dq s\n flag update the offset to the start offset of the match, rather than the end.\n+The\n+.Dq l\n+modifier, changes the limit of length to mean number of lines instead of a\n+byte count.\n+Lines are delimited by the platforms native line delimiter.\n+When a line count is specified, an implicit byte count also computed assuming\n+each line is 80 characters long.\n+If neither a byte or line count is specified, the search is limited automatically\n+to 8KiB.\n .Dv ^\n and\n .Dv $\n@@ -406,6 +415,9 @@ is octal, and\n .Dv 0x13\n is hexadecimal.\n .Pp\n+Numeric operations are not performed on date types, instead the numeric\n+value is interpreted as an offset.\n+.Pp\n For string values, the string from the\n file must match the specified string.\n The operators\ndiff --git a\/magic\/Magdir\/android b\/magic\/Magdir\/android\nindex 29f683117..12072d3a6 100644\n--- a\/magic\/Magdir\/android\n+++ b\/magic\/Magdir\/android\n@@ -1,6 +1,6 @@\n \n #------------------------------------------------------------\n-# $File: android,v 1.2 2013\/11\/05 14:00:25 christos Exp $\n+# $File: android,v 1.3 2013\/11\/08 01:24:22 christos Exp $\n # Various android related magic entries\n #------------------------------------------------------------\n \n@@ -89,12 +89,12 @@\n >17\tstring\t\t0\\n\t\t\t\\b, Not-Compressed\n >17\tstring\t\t1\\n\t\t\t\\b, Compressed\n # any string as long as it's not the word none (which is matched below)\n->>19    regex\/1\t\t\\^([^n\\n]|n[^o]|no[^n]|non[^e]|none.+).*\t\\b, Encrypted (%s)\n+>>19    regex\/1l\t\\^([^n\\n]|n[^o]|no[^n]|non[^e]|none.+).*\t\\b, Encrypted (%s)\n >>19\tstring\t\tnone\\n\t\t\t\\b, Not-Encrypted\n # Commented out because they don't seem useful to print\n # (but they are part of the header - the tar file comes after them):\n-#>>>&1\t\tregex\/1 .*\t\\b, Password salt: %s\n-#>>>>&1\t\tregex\/1 .*\t\\b, Master salt: %s\n-#>>>>>&1\tregex\/1 .*\t\\b, PBKDF2 rounds: %s\n-#>>>>>>&1\tregex\/1 .*\t\\b, IV: %s\n-#>>>>>>>&1\tregex\/1 .*\t\\b, Key: %s\n+#>>>&1\t\tregex\/1l .*\t\\b, Password salt: %s\n+#>>>>&1\t\tregex\/1l .*\t\\b, Master salt: %s\n+#>>>>>&1\tregex\/1l .*\t\\b, PBKDF2 rounds: %s\n+#>>>>>>&1\tregex\/1l .*\t\\b, IV: %s\n+#>>>>>>>&1\tregex\/1l .*\t\\b, Key: %s\ndiff --git a\/magic\/Magdir\/fortran b\/magic\/Magdir\/fortran\nindex 1f136d250..320331eff 100644\n--- a\/magic\/Magdir\/fortran\n+++ b\/magic\/Magdir\/fortran\n@@ -1,7 +1,7 @@\n \n #------------------------------------------------------------------------------\n-# $File: fortran,v 1.6 2009\/09\/19 16:28:09 christos Exp $\n+# $File: fortran,v 1.7 2012\/06\/21 01:55:02 christos Exp $\n # FORTRAN source\n-0\tregex\/100\t\\^[Cc][\\ \\t]\tFORTRAN program\n+0\tregex\/100l\t\\^[Cc][\\ \\t]\tFORTRAN program\n !:mime\ttext\/x-fortran\n !:strength - 5\ndiff --git a\/magic\/Magdir\/graphviz b\/magic\/Magdir\/graphviz\nindex 0fbdb995b..d1ca1d0ff 100644\n--- a\/magic\/Magdir\/graphviz\n+++ b\/magic\/Magdir\/graphviz\n@@ -1,12 +1,12 @@\n \n #------------------------------------------------------------------------------\n-# $File$\n+# $File: graphviz,v 1.7 2009\/09\/19 16:28:09 christos Exp $\n # graphviz:  file(1) magic for http:\/\/www.graphviz.org\/\n \n # FIXME: These patterns match too generally. For example, the first\n # line matches a LaTeX file containing the word \"graph\" (with a {\n # following later) and the second line matches this file.\n-#0\tregex\/100\t[\\r\\n\\t\\ ]*graph[\\r\\n\\t\\ ]+.*\\\\{\tgraphviz graph text\n+#0\tregex\/100l\t[\\r\\n\\t\\ ]*graph[\\r\\n\\t\\ ]+.*\\\\{\tgraphviz graph text\n #!:mime\ttext\/vnd.graphviz\n-#0\tregex\/100\t[\\r\\n\\t\\ ]*digraph[\\r\\n\\t\\ ]+.*\\\\{\tgraphviz digraph text\n+#0\tregex\/100l\t[\\r\\n\\t\\ ]*digraph[\\r\\n\\t\\ ]+.*\\\\{\tgraphviz digraph text\n #!:mime\ttext\/vnd.graphviz\ndiff --git a\/magic\/Magdir\/marc21 b\/magic\/Magdir\/marc21\nindex 83f7959e0..7e859a389 100644\n--- a\/magic\/Magdir\/marc21\n+++ b\/magic\/Magdir\/marc21\n@@ -12,17 +12,17 @@\n 20\tstring\t45\t\n \n # leader starts with 5 digits, followed by codes specific to MARC format\n->0\tregex\/1\t(^[0-9]{5})[acdnp][^bhlnqsu-z]\tMARC21 Bibliographic\n+>0\tregex\/1l\t(^[0-9]{5})[acdnp][^bhlnqsu-z]\tMARC21 Bibliographic\n !:mime\tapplication\/marc\n->0\tregex\/1\t(^[0-9]{5})[acdnosx][z]\tMARC21 Authority\n+>0\tregex\/1l\t(^[0-9]{5})[acdnosx][z]\tMARC21 Authority\n !:mime\tapplication\/marc\n->0\tregex\/1\t(^[0-9]{5})[cdn][uvxy]\tMARC21 Holdings\n+>0\tregex\/1l\t(^[0-9]{5})[cdn][uvxy]\tMARC21 Holdings\n !:mime\tapplication\/marc\n-0\tregex\/1\t(^[0-9]{5})[acdn][w]\tMARC21 Classification\n+0\tregex\/1l\t(^[0-9]{5})[acdn][w]\tMARC21 Classification\n !:mime\tapplication\/marc\n->0\tregex\/1\t(^[0-9]{5})[cdn][q]\tMARC21 Community\n+>0\tregex\/1l\t(^[0-9]{5})[cdn][q]\tMARC21 Community\n !:mime\tapplication\/marc\n \n # leader position 22-23, should be \"00\" but is it?\n->0\tregex\/1\t(^.{21})([^0]{2})\t(non-conforming)\n+>0\tregex\/1l\t(^.{21})([^0]{2})\t(non-conforming)\n !:mime\tapplication\/marc\ndiff --git a\/magic\/Magdir\/scientific b\/magic\/Magdir\/scientific\nindex b52999951..5651f85e2 100644\n--- a\/magic\/Magdir\/scientific\n+++ b\/magic\/Magdir\/scientific\n@@ -1,6 +1,6 @@\n \n #------------------------------------------------------------------------------\n-# $File: scientific,v 1.7 2010\/09\/20 19:19:17 rrt Exp $\n+# $File: scientific,v 1.8 2014\/01\/06 17:46:23 rrt Exp $\n # scientific:  file(1) magic for scientific formats \n #\n # From: Joe Krahn <krahn@niehs.nih.gov>\n@@ -91,12 +91,12 @@\n # uppercase letters. However, examples have been seen without the date string,\n # e.g., the example on the chemime site.\n 0\tstring\tHEADER\\ \\ \\ \\ \n->&0\tregex\/1\t\\^.{40}\n->>&0\tregex\/1\t[0-9]{2}-[A-Z]{3}-[0-9]{2}\\ {3}\n->>>&0\tregex\/1s\t[A-Z0-9]{4}.{14}$\n->>>>&0\tregex\/1\t[A-Z0-9]{4}\tProtein Data Bank data, ID Code %s\n+>&0\tregex\/1l\t\\^.{40}\n+>>&0\tregex\/1l\t[0-9]{2}-[A-Z]{3}-[0-9]{2}\\ {3}\n+>>>&0\tregex\/1ls\t[A-Z0-9]{4}.{14}$\n+>>>>&0\tregex\/1l\t[A-Z0-9]{4}\tProtein Data Bank data, ID Code %s\n !:mime\tchemical\/x-pdb\n->>>>0\tregex\/1\t[0-9]{2}-[A-Z]{3}-[0-9]{2}\t\\b, %s\n+>>>>0\tregex\/1l\t[0-9]{2}-[A-Z]{3}-[0-9]{2}\t\\b, %s\n \n # Type:\tGDSII Stream file\n 0\tbelong\t0x00060002\tGDSII Stream file\ndiff --git a\/magic\/Magdir\/troff b\/magic\/Magdir\/troff\nindex d410495c3..be477c46e 100644\n--- a\/magic\/Magdir\/troff\n+++ b\/magic\/Magdir\/troff\n@@ -1,6 +1,6 @@\n \n #------------------------------------------------------------------------------\n-# $File$\n+# $File: troff,v 1.10 2009\/09\/19 16:28:12 christos Exp $\n # troff:  file(1) magic for *roff\n #\n # updated by Daniel Quinlan (quinlan@yggdrasil.com)\n@@ -16,9 +16,9 @@\n !:mime\ttext\/troff\n 0\tsearch\/1\t'''\t\ttroff or preprocessor input text\n !:mime\ttext\/troff\n-0\tregex\/20\t\\^\\\\.[A-Za-z0-9][A-Za-z0-9][\\ \\t]\ttroff or preprocessor input text\n+0\tregex\/20l\t\\^\\\\.[A-Za-z0-9][A-Za-z0-9][\\ \\t]\ttroff or preprocessor input text\n !:mime\ttext\/troff\n-0\tregex\/20\t\\^\\\\.[A-Za-z0-9][A-Za-z0-9]$\ttroff or preprocessor input text\n+0\tregex\/20l\t\\^\\\\.[A-Za-z0-9][A-Za-z0-9]$\ttroff or preprocessor input text\n !:mime\ttext\/troff\n \n # ditroff intermediate output text\ndiff --git a\/src\/apprentice.c b\/src\/apprentice.c\nindex bca7913f5..30931f894 100644\n--- a\/src\/apprentice.c\n+++ b\/src\/apprentice.c\n@@ -32,7 +32,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: apprentice.c,v 1.209 2014\/05\/13 16:42:17 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: apprentice.c,v 1.210 2014\/05\/14 23:15:42 christos Exp $\")\n #endif\t\/* lint *\/\n \n #include \"magic.h\"\n@@ -1382,7 +1382,8 @@ string_modifier_check(struct magic_set *ms, struct magic *m)\n \tif ((ms->flags & MAGIC_CHECK) == 0)\n \t\treturn 0;\n \n-\tif (m->type != FILE_PSTRING && (m->str_flags & PSTRING_LEN) != 0) {\n+\tif ((m->type != FILE_REGEX || (m->str_flags & REGEX_LINE_COUNT) == 0) &&\n+\t    (m->type != FILE_PSTRING && (m->str_flags & PSTRING_LEN) != 0)) {\n \t\tfile_magwarn(ms,\n \t\t    \"'\/BHhLl' modifiers are only allowed for pascal strings\\n\");\n \t\treturn -1;\n@@ -1875,8 +1876,13 @@ parse(struct magic_set *ms, struct magic_entry *me, const char *line,\n \t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;\n \t\t\t\t\tbreak;\n \t\t\t\tcase CHAR_PSTRING_4_LE:\n-\t\t\t\t\tif (m->type != FILE_PSTRING)\n+\t\t\t\t\tswitch (m->type) {\n+\t\t\t\t\tcase FILE_PSTRING:\n+\t\t\t\t\tcase FILE_REGEX:\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tdefault:\n \t\t\t\t\t\tgoto bad;\n+\t\t\t\t\t}\n \t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;\n \t\t\t\t\tbreak;\n \t\t\t\tcase CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:\ndiff --git a\/src\/file.h b\/src\/file.h\nindex e73d45416..8e1df2995 100644\n--- a\/src\/file.h\n+++ b\/src\/file.h\n@@ -27,7 +27,7 @@\n  *\/\n \/*\n  * file.h - definitions for file(1) program\n- * @(#)$File: file.h,v 1.150 2014\/05\/05 20:53:10 christos Exp $\n+ * @(#)$File: file.h,v 1.151 2014\/05\/14 23:15:42 christos Exp $\n  *\/\n \n #ifndef __file_h__\n@@ -133,7 +133,7 @@\n #define MAXstring 64\t\t\/* max len of \"string\" types *\/\n \n #define MAGICNO\t\t0xF11E041C\n-#define VERSIONNO\t11\n+#define VERSIONNO\t12\n #define FILE_MAGICSIZE\t248\n \n #define\tFILE_LOAD\t0\n@@ -321,6 +321,7 @@ struct magic {\n #define PSTRING_2_LE\t\t\t\tBIT(9)\n #define PSTRING_4_BE\t\t\t\tBIT(10)\n #define PSTRING_4_LE\t\t\t\tBIT(11)\n+#define REGEX_LINE_COUNT\t\t\tBIT(11)\n #define PSTRING_LEN\t\\\n     (PSTRING_1_BE|PSTRING_2_LE|PSTRING_2_BE|PSTRING_4_LE|PSTRING_4_BE)\n #define PSTRING_LENGTH_INCLUDES_ITSELF\t\tBIT(12)\ndiff --git a\/src\/softmagic.c b\/src\/softmagic.c\nindex 3e631efe8..9ba500b73 100644\n--- a\/src\/softmagic.c\n+++ b\/src\/softmagic.c\n@@ -32,7 +32,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: softmagic.c,v 1.188 2014\/05\/14 23:15:42 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: softmagic.c,v 1.189 2014\/05\/30 16:47:44 christos Exp $\")\n #endif\t\/* lint *\/\n \n #include \"magic.h\"\n@@ -57,7 +57,7 @@ private int32_t mprint(struct magic_set *, struct magic *);\n private int32_t moffset(struct magic_set *, struct magic *);\n private void mdebug(uint32_t, const char *, size_t);\n private int mcopy(struct magic_set *, union VALUETYPE *, int, int,\n-    const unsigned char *, uint32_t, size_t, size_t);\n+    const unsigned char *, uint32_t, size_t, struct magic *);\n private int mconvert(struct magic_set *, struct magic *, int);\n private int print_sep(struct magic_set *, int);\n private int handle_annotation(struct magic_set *, struct magic *);\n@@ -540,7 +540,7 @@ mprint(struct magic_set *ms, struct magic *m)\n \tcase FILE_LEDATE:\n \tcase FILE_MEDATE:\n \t\tif (file_printf(ms, F(ms, m, \"%s\"),\n-\t\t    file_fmttime(p->l, FILE_T_LOCAL, tbuf)) == -1)\n+\t\t    file_fmttime(p->l + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n \t\t\treturn -1;\n \t\tt = ms->offset + sizeof(uint32_t);\n \t\tbreak;\n@@ -550,7 +550,7 @@ mprint(struct magic_set *ms, struct magic *m)\n \tcase FILE_LELDATE:\n \tcase FILE_MELDATE:\n \t\tif (file_printf(ms, F(ms, m, \"%s\"),\n-\t\t    file_fmttime(p->l, 0, tbuf)) == -1)\n+\t\t    file_fmttime(p->l + m->num_mask, 0, tbuf)) == -1)\n \t\t\treturn -1;\n \t\tt = ms->offset + sizeof(uint32_t);\n \t\tbreak;\n@@ -559,7 +559,7 @@ mprint(struct magic_set *ms, struct magic *m)\n \tcase FILE_BEQDATE:\n \tcase FILE_LEQDATE:\n \t\tif (file_printf(ms, F(ms, m, \"%s\"),\n-\t\t    file_fmttime(p->q, FILE_T_LOCAL, tbuf)) == -1)\n+\t\t    file_fmttime(p->q + m->num_mask, FILE_T_LOCAL, tbuf)) == -1)\n \t\t\treturn -1;\n \t\tt = ms->offset + sizeof(uint64_t);\n \t\tbreak;\n@@ -568,7 +568,7 @@ mprint(struct magic_set *ms, struct magic *m)\n \tcase FILE_BEQLDATE:\n \tcase FILE_LEQLDATE:\n \t\tif (file_printf(ms, F(ms, m, \"%s\"),\n-\t\t    file_fmttime(p->q, 0, tbuf)) == -1)\n+\t\t    file_fmttime(p->q + m->num_mask, 0, tbuf)) == -1)\n \t\t\treturn -1;\n \t\tt = ms->offset + sizeof(uint64_t);\n \t\tbreak;\n@@ -577,7 +577,7 @@ mprint(struct magic_set *ms, struct magic *m)\n \tcase FILE_BEQWDATE:\n \tcase FILE_LEQWDATE:\n \t\tif (file_printf(ms, F(ms, m, \"%s\"),\n-\t\t    file_fmttime(p->q, FILE_T_WINDOWS, tbuf)) == -1)\n+\t\t    file_fmttime(p->q + m->num_mask, FILE_T_WINDOWS, tbuf)) == -1)\n \t\t\treturn -1;\n \t\tt = ms->offset + sizeof(uint64_t);\n \t\tbreak;\n@@ -912,8 +912,9 @@ private int\n mconvert(struct magic_set *ms, struct magic *m, int flip)\n {\n \tunion VALUETYPE *p = &ms->ms_value;\n+\tuint8_t type;\n \n-\tswitch (cvt_flip(m->type, flip)) {\n+\tswitch (type = cvt_flip(m->type, flip)) {\n \tcase FILE_BYTE:\n \t\tcvt_8(p, m);\n \t\treturn 1;\n@@ -957,7 +958,8 @@ mconvert(struct magic_set *ms, struct magic *m, int flip)\n \tcase FILE_BELDATE:\n \t\tp->l = (int32_t)\n \t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n-\t\tcvt_32(p, m);\n+\t\tif (type == FILE_BELONG)\n+\t\t\tcvt_32(p, m);\n \t\treturn 1;\n \tcase FILE_BEQUAD:\n \tcase FILE_BEQDATE:\n@@ -968,7 +970,8 @@ mconvert(struct magic_set *ms, struct magic *m, int flip)\n \t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n \t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n \t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n-\t\tcvt_64(p, m);\n+\t\tif (type == FILE_BEQUAD)\n+\t\t\tcvt_64(p, m);\n \t\treturn 1;\n \tcase FILE_LESHORT:\n \t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n@@ -979,7 +982,8 @@ mconvert(struct magic_set *ms, struct magic *m, int flip)\n \tcase FILE_LELDATE:\n \t\tp->l = (int32_t)\n \t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n-\t\tcvt_32(p, m);\n+\t\tif (type == FILE_LELONG)\n+\t\t\tcvt_32(p, m);\n \t\treturn 1;\n \tcase FILE_LEQUAD:\n \tcase FILE_LEQDATE:\n@@ -990,14 +994,16 @@ mconvert(struct magic_set *ms, struct magic *m, int flip)\n \t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n \t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n \t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n-\t\tcvt_64(p, m);\n+\t\tif (type == FILE_LEQUAD)\n+\t\t\tcvt_64(p, m);\n \t\treturn 1;\n \tcase FILE_MELONG:\n \tcase FILE_MEDATE:\n \tcase FILE_MELDATE:\n \t\tp->l = (int32_t)\n \t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n-\t\tcvt_32(p, m);\n+\t\tif (type == FILE_MELONG)\n+\t\t\tcvt_32(p, m);\n \t\treturn 1;\n \tcase FILE_FLOAT:\n \t\tcvt_float(p, m);\n@@ -1054,7 +1060,7 @@ mdebug(uint32_t offset, const char *str, size_t len)\n \n private int\n mcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n-    const unsigned char *s, uint32_t offset, size_t nbytes, size_t linecnt)\n+    const unsigned char *s, uint32_t offset, size_t nbytes, struct magic *m)\n {\n \t\/*\n \t * Note: FILE_SEARCH and FILE_REGEX do not actually copy\n@@ -1074,15 +1080,29 @@ mcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n \t\t\tconst char *last;\t\/* end of search region *\/\n \t\t\tconst char *buf;\t\/* start of search region *\/\n \t\t\tconst char *end;\n-\t\t\tsize_t lines;\n+\t\t\tsize_t lines, linecnt, bytecnt;\n \n \t\t\tif (s == NULL) {\n \t\t\t\tms->search.s_len = 0;\n \t\t\t\tms->search.s = NULL;\n \t\t\t\treturn 0;\n \t\t\t}\n+\n+\t\t\tif (m->str_flags & REGEX_LINE_COUNT) {\n+\t\t\t\tlinecnt = m->str_range;\n+\t\t\t\tbytecnt = linecnt * 80;\n+\t\t\t} else {\n+\t\t\t\tlinecnt = 0;\n+\t\t\t\tbytecnt = m->str_range;\n+\t\t\t}\n+\n+\t\t\tif (bytecnt == 0)\n+\t\t\t\tbytecnt = 8192;\n+\t\t\tif (bytecnt > nbytes)\n+\t\t\t\tbytecnt = nbytes;\n+\n \t\t\tbuf = RCAST(const char *, s) + offset;\n-\t\t\tend = last = RCAST(const char *, s) + nbytes;\n+\t\t\tend = last = RCAST(const char *, s) + bytecnt;\n \t\t\t\/* mget() guarantees buf <= last *\/\n \t\t\tfor (lines = linecnt, b = buf; lines && b < end &&\n \t\t\t     ((b = CAST(const char *,\n@@ -1095,7 +1115,7 @@ mcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n \t\t\t\t\tb++;\n \t\t\t}\n \t\t\tif (lines)\n-\t\t\t\tlast = RCAST(const char *, s) + nbytes;\n+\t\t\t\tlast = RCAST(const char *, s) + bytecnt;\n \n \t\t\tms->search.s = buf;\n \t\t\tms->search.s_len = last - buf;\n@@ -1166,7 +1186,6 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n     int *need_separator, int *returnval)\n {\n \tuint32_t soffset, offset = ms->offset;\n-\tuint32_t count = m->str_range;\n \tuint32_t lhs;\n \tint rv, oneed_separator, in_type;\n \tchar *sbuf, *rbuf;\n@@ -1179,13 +1198,12 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t}\n \n \tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n-\t    (uint32_t)nbytes, count) == -1)\n+\t    (uint32_t)nbytes, m) == -1)\n \t\treturn -1;\n \n \tif ((ms->flags & MAGIC_DEBUG) != 0) {\n \t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%zu, \"\n-\t\t    \"nbytes=%zu, count=%u)\\n\", m->type, m->flag, offset, o,\n-\t\t    nbytes, count);\n+\t\t    \"nbytes=%zu)\\n\", m->type, m->flag, offset, o, nbytes);\n \t\tmdebug(offset, (char *)(void *)p, sizeof(union VALUETYPE));\n #ifndef COMPILE_ONLY\n \t\tfile_mdump(m);\n@@ -1550,7 +1568,7 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \t\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n \t\t\t\tfprintf(stderr, \"indirect +offs=%u\\n\", offset);\n \t\t}\n-\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, count) == -1)\n+\t\tif (mcopy(ms, p, m->type, 0, s, offset, nbytes, m) == -1)\n \t\t\treturn -1;\n \t\tms->offset = offset;\n \n@@ -1906,7 +1924,8 @@ magiccheck(struct magic_set *ms, struct magic *m)\n \t\t\tif (slen + idx > ms->search.s_len)\n \t\t\t\tbreak;\n \n-\t\t\tv = file_strncmp(m->value.s, ms->search.s + idx, slen, m->str_flags);\n+\t\t\tv = file_strncmp(m->value.s, ms->search.s + idx, slen,\n+\t\t\t    m->str_flags);\n \t\t\tif (v == 0) {\t\/* found match *\/\n \t\t\t\tms->search.offset += idx;\n \t\t\t\tbreak;\n@@ -1929,16 +1948,11 @@ magiccheck(struct magic_set *ms, struct magic *m)\n \t\t\tfile_regerror(&rx, rc, ms);\n \t\t\tv = (uint64_t)-1;\n \t\t} else {\n-#ifndef REG_STARTEND\n-\t\t\tchar c;\n-#endif\n \t\t\tregmatch_t pmatch[1];\n \t\t\tsize_t slen = ms->search.s_len;\n-\t\t\t\/* Limit by offset if requested *\/\n-\t\t\tif (m->str_range > 0)\n-\t\t\t\tslen = MIN(slen, m->str_range);\n #ifndef REG_STARTEND\n #define\tREG_STARTEND\t0\n+\t\t\tchar c;\n \t\t\tif (slen != 0)\n \t\t\t\tslen--;\n \t\t\tc = ms->search.s[slen];\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2013-7339","CWE_ID":"399","category":"security","commit_id":"c2349758acf1874e4c2b93fe41d072336f1a31d0","commit_message":"From c2349758acf1874e4c2b93fe41d072336f1a31d0 Mon Sep 17 00:00:00 2001\nFrom: Sasha Levin <sasha.levin@oracle.com>\nDate: Wed, 18 Dec 2013 23:49:42 -0500\nSubject: [PATCH] rds: prevent dereference of a NULL device\n\nBinding might result in a NULL device, which is dereferenced\ncausing this BUG:\n\n[ 1317.260548] BUG: unable to handle kernel NULL pointer dereference at 000000000000097\n4\n[ 1317.261847] IP: [<ffffffff84225f52>] rds_ib_laddr_check+0x82\/0x110\n[ 1317.263315] PGD 418bcb067 PUD 3ceb21067 PMD 0\n[ 1317.263502] Oops: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC\n[ 1317.264179] Dumping ftrace buffer:\n[ 1317.264774]    (ftrace buffer empty)\n[ 1317.265220] Modules linked in:\n[ 1317.265824] CPU: 4 PID: 836 Comm: trinity-child46 Tainted: G        W    3.13.0-rc4-\nnext-20131218-sasha-00013-g2cebb9b-dirty #4159\n[ 1317.267415] task: ffff8803ddf33000 ti: ffff8803cd31a000 task.ti: ffff8803cd31a000\n[ 1317.268399] RIP: 0010:[<ffffffff84225f52>]  [<ffffffff84225f52>] rds_ib_laddr_check+\n0x82\/0x110\n[ 1317.269670] RSP: 0000:ffff8803cd31bdf8  EFLAGS: 00010246\n[ 1317.270230] RAX: 0000000000000000 RBX: ffff88020b0dd388 RCX: 0000000000000000\n[ 1317.270230] RDX: ffffffff8439822e RSI: 00000000000c000a RDI: 0000000000000286\n[ 1317.270230] RBP: ffff8803cd31be38 R08: 0000000000000000 R09: 0000000000000000\n[ 1317.270230] R10: 0000000000000000 R11: 0000000000000001 R12: 0000000000000000\n[ 1317.270230] R13: 0000000054086700 R14: 0000000000a25de0 R15: 0000000000000031\n[ 1317.270230] FS:  00007ff40251d700(0000) GS:ffff88022e200000(0000) knlGS:000000000000\n0000\n[ 1317.270230] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[ 1317.270230] CR2: 0000000000000974 CR3: 00000003cd478000 CR4: 00000000000006e0\n[ 1317.270230] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[ 1317.270230] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000090602\n[ 1317.270230] Stack:\n[ 1317.270230]  0000000054086700 5408670000a25de0 5408670000000002 0000000000000000\n[ 1317.270230]  ffffffff84223542 00000000ea54c767 0000000000000000 ffffffff86d26160\n[ 1317.270230]  ffff8803cd31be68 ffffffff84223556 ffff8803cd31beb8 ffff8800c6765280\n[ 1317.270230] Call Trace:\n[ 1317.270230]  [<ffffffff84223542>] ? rds_trans_get_preferred+0x42\/0xa0\n[ 1317.270230]  [<ffffffff84223556>] rds_trans_get_preferred+0x56\/0xa0\n[ 1317.270230]  [<ffffffff8421c9c3>] rds_bind+0x73\/0xf0\n[ 1317.270230]  [<ffffffff83e4ce62>] SYSC_bind+0x92\/0xf0\n[ 1317.270230]  [<ffffffff812493f8>] ? context_tracking_user_exit+0xb8\/0x1d0\n[ 1317.270230]  [<ffffffff8119313d>] ? trace_hardirqs_on+0xd\/0x10\n[ 1317.270230]  [<ffffffff8107a852>] ? syscall_trace_enter+0x32\/0x290\n[ 1317.270230]  [<ffffffff83e4cece>] SyS_bind+0xe\/0x10\n[ 1317.270230]  [<ffffffff843a6ad0>] tracesys+0xdd\/0xe2\n[ 1317.270230] Code: 00 8b 45 cc 48 8d 75 d0 48 c7 45 d8 00 00 00 00 66 c7 45 d0 02 00\n89 45 d4 48 89 df e8 78 49 76 ff 41 89 c4 85 c0 75 0c 48 8b 03 <80> b8 74 09 00 00 01 7\n4 06 41 bc 9d ff ff ff f6 05 2a b6 c2 02\n[ 1317.270230] RIP  [<ffffffff84225f52>] rds_ib_laddr_check+0x82\/0x110\n[ 1317.270230]  RSP <ffff8803cd31bdf8>\n[ 1317.270230] CR2: 0000000000000974\n\nSigned-off-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/rds\/ib.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/rds\/ib.c b\/net\/rds\/ib.c\nindex b4c8b0022feee..ba2dffeff6087 100644\n--- a\/net\/rds\/ib.c\n+++ b\/net\/rds\/ib.c\n@@ -338,7 +338,8 @@ static int rds_ib_laddr_check(__be32 addr)\n \tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n \t\/* due to this, we will claim to support iWARP devices unless we\n \t   check node_type. *\/\n-\tif (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)\n+\tif (ret || !cm_id->device ||\n+\t    cm_id->device->node_type != RDMA_NODE_IB_CA)\n \t\tret = -EADDRNOTAVAIL;\n \n \trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-1950","CWE_ID":"399","category":"security","commit_id":"a9f437119d79a438cb12e510f3cadd4060102c9f","commit_message":"From a9f437119d79a438cb12e510f3cadd4060102c9f Mon Sep 17 00:00:00 2001\nFrom: Steve Dickson <steved@redhat.com>\nDate: Thu, 18 Apr 2013 14:29:58 -0400\nSubject: [PATCH] svc_getargs(): Should not be freeing arg pointers on failures\n\ncommit 82cc2e61 (SVCAUTH_WRAP\/SVCAUTH_UNWRAP) introduce a regression\nthat causes callers of svc_getargs() to crash when svc_freeargs() frees\nargs points that are allocated on the stack.\n\nsvc_getargs() should let the callers do the freeing and not make any\nassumptions on the type of memory passed in.\n\nAlso see:\n    https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=948378\nand\n    CVE-2013-1950 EMBARGOED rpcbind: invalid pointer free leads to crash\n\nSigned-off-by: Steve Dickson <steved@redhat.com>\n---\n src\/svc_dg.c | 1 -\n 1 file changed, 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/svc_dg.c b\/src\/svc_dg.c\nindex b1ac462..6e00191 100644\n--- a\/src\/svc_dg.c\n+++ b\/src\/svc_dg.c\n@@ -284,7 +284,6 @@ svc_dg_getargs(xprt, xdr_args, args_ptr)\n {\n \tif (! SVCAUTH_UNWRAP(xprt->xp_auth, &(su_data(xprt)->su_xdrs),\n \t\t\t     xdr_args, args_ptr)) {\n-\t\t(void)svc_freeargs(xprt, xdr_args, args_ptr);\n \t\treturn FALSE;\n \t}\n \treturn TRUE;\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-4021","CWE_ID":"399","category":"security","commit_id":"f60311d5f7670d9539b424e4ed8b5c0872fc9e83","commit_message":"From f60311d5f7670d9539b424e4ed8b5c0872fc9e83 Mon Sep 17 00:00:00 2001\nFrom: \"Anand V. Avati\" <avati@gluster.com>\nDate: Thu, 22 Oct 2009 06:24:52 -0700\nSubject: fuse: prevent fuse_put_request on invalid pointer\n\nfuse_direct_io() has a loop where requests are allocated in each\niteration. if allocation fails, the loop is broken out and follows\ninto an unconditional fuse_put_request() on that invalid pointer.\n\nSigned-off-by: Anand V. Avati <avati@gluster.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCc: stable@kernel.org\n---\n fs\/fuse\/file.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/fuse\/file.c b\/fs\/fuse\/file.c\nindex a3492f7d207c..5887a6395ad2 100644\n--- a\/fs\/fuse\/file.c\n+++ b\/fs\/fuse\/file.c\n@@ -1063,7 +1063,8 @@ ssize_t fuse_direct_io(struct file *file, const char __user *buf,\n \t\t\t\tbreak;\n \t\t}\n \t}\n-\tfuse_put_request(fc, req);\n+\tif (!IS_ERR(req))\n+\t\tfuse_put_request(fc, req);\n \tif (res > 0)\n \t\t*ppos = pos;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8480","CWE_ID":"399","category":"security","commit_id":"3f6f1480d86bf9fc16c160d803ab1d006e3058d5","commit_message":"From 3f6f1480d86bf9fc16c160d803ab1d006e3058d5 Mon Sep 17 00:00:00 2001\nFrom: Nadav Amit <namit@cs.technion.ac.il>\nDate: Mon, 13 Oct 2014 13:04:14 +0300\nSubject: KVM: x86: PREFETCH and HINT_NOP should have SrcMem flag\n\nThe decode phase of the x86 emulator assumes that every instruction with the\nModRM flag, and which can be used with RIP-relative addressing, has either\nSrcMem or DstMem.  This is not the case for several instructions - prefetch,\nhint-nop and clflush.\n\nAdding SrcMem|NoAccess for prefetch and hint-nop and SrcMem for clflush.\n\nThis fixes CVE-2014-8480.\n\nFixes: 41061cdb98a0bec464278b4db8e894a3121671f5\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/emulate.c | 7 ++++---\n 1 file changed, 4 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/emulate.c b\/arch\/x86\/kvm\/emulate.c\nindex 97da5034d812..749f9fa38254 100644\n--- a\/arch\/x86\/kvm\/emulate.c\n+++ b\/arch\/x86\/kvm\/emulate.c\n@@ -3807,7 +3807,7 @@ static const struct opcode group11[] = {\n };\n \n static const struct gprefix pfx_0f_ae_7 = {\n-\tI(0, em_clflush), N, N, N,\n+\tI(SrcMem | ByteOp, em_clflush), N, N, N,\n };\n \n static const struct group_dual group15 = { {\n@@ -4024,10 +4024,11 @@ static const struct opcode twobyte_table[256] = {\n \tN, I(ImplicitOps | EmulateOnUD, em_syscall),\n \tII(ImplicitOps | Priv, em_clts, clts), N,\n \tDI(ImplicitOps | Priv, invd), DI(ImplicitOps | Priv, wbinvd), N, N,\n-\tN, D(ImplicitOps | ModRM), N, N,\n+\tN, D(ImplicitOps | ModRM | SrcMem | NoAccess), N, N,\n \t\/* 0x10 - 0x1F *\/\n \tN, N, N, N, N, N, N, N,\n-\tD(ImplicitOps | ModRM), N, N, N, N, N, N, D(ImplicitOps | ModRM),\n+\tD(ImplicitOps | ModRM | SrcMem | NoAccess),\n+\tN, N, N, N, N, N, D(ImplicitOps | ModRM | SrcMem | NoAccess),\n \t\/* 0x20 - 0x2F *\/\n \tDIP(ModRM | DstMem | Priv | Op3264 | NoMod, cr_read, check_cr_read),\n \tDIP(ModRM | DstMem | Priv | Op3264 | NoMod, dr_read, check_dr_read),\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-2847","CWE_ID":"399","category":"security","commit_id":"759c01142a5d0f364a462346168a56de28a80f52","commit_message":"From 759c01142a5d0f364a462346168a56de28a80f52 Mon Sep 17 00:00:00 2001\nFrom: Willy Tarreau <w@1wt.eu>\nDate: Mon, 18 Jan 2016 16:36:09 +0100\nSubject: [PATCH] pipe: limit the per-user amount of pages allocated in pipes\n\nOn no-so-small systems, it is possible for a single process to cause an\nOOM condition by filling large pipes with data that are never read. A\ntypical process filling 4000 pipes with 1 MB of data will use 4 GB of\nmemory. On small systems it may be tricky to set the pipe max size to\nprevent this from happening.\n\nThis patch makes it possible to enforce a per-user soft limit above\nwhich new pipes will be limited to a single page, effectively limiting\nthem to 4 kB each, as well as a hard limit above which no new pipes may\nbe created for this user. This has the effect of protecting the system\nagainst memory abuse without hurting other users, and still allowing\npipes to work correctly though with less data at once.\n\nThe limit are controlled by two new sysctls : pipe-user-pages-soft, and\npipe-user-pages-hard. Both may be disabled by setting them to zero. The\ndefault soft limit allows the default number of FDs per process (1024)\nto create pipes of the default size (64kB), thus reaching a limit of 64MB\nbefore starting to create only smaller pipes. With 256 processes limited\nto 1024 FDs each, this results in 1024*64kB + (256*1024 - 1024) * 4kB =\n1084 MB of memory allocated for a user. The hard limit is disabled by\ndefault to avoid breaking existing applications that make intensive use\nof pipes (eg: for splicing).\n\nReported-by: socketpair@gmail.com\nReported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nMitigates: CVE-2013-4312 (Linux 2.0+)\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n Documentation\/sysctl\/fs.txt | 23 ++++++++++++++++++\n fs\/pipe.c                   | 47 +++++++++++++++++++++++++++++++++++--\n include\/linux\/pipe_fs_i.h   |  4 ++++\n include\/linux\/sched.h       |  1 +\n kernel\/sysctl.c             | 14 +++++++++++\n 5 files changed, 87 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/Documentation\/sysctl\/fs.txt b\/Documentation\/sysctl\/fs.txt\nindex 88152f214f48c..302b5ed616a6b 100644\n--- a\/Documentation\/sysctl\/fs.txt\n+++ b\/Documentation\/sysctl\/fs.txt\n@@ -32,6 +32,8 @@ Currently, these files are in \/proc\/sys\/fs:\n - nr_open\n - overflowuid\n - overflowgid\n+- pipe-user-pages-hard\n+- pipe-user-pages-soft\n - protected_hardlinks\n - protected_symlinks\n - suid_dumpable\n@@ -159,6 +161,27 @@ The default is 65534.\n \n ==============================================================\n \n+pipe-user-pages-hard:\n+\n+Maximum total number of pages a non-privileged user may allocate for pipes.\n+Once this limit is reached, no new pipes may be allocated until usage goes\n+below the limit again. When set to 0, no limit is applied, which is the default\n+setting.\n+\n+==============================================================\n+\n+pipe-user-pages-soft:\n+\n+Maximum total number of pages a non-privileged user may allocate for pipes\n+before the pipe size gets limited to a single page. Once this limit is reached,\n+new pipes will be limited to a single page in size for this user in order to\n+limit total memory usage, and trying to increase them using fcntl() will be\n+denied until usage goes below the limit again. The default value allows to\n+allocate up to 1024 pipes at their default size. When set to 0, no limit is\n+applied.\n+\n+==============================================================\n+\n protected_hardlinks:\n \n A long-standing class of security issues is the hardlink-based\ndiff --git a\/fs\/pipe.c b\/fs\/pipe.c\nindex 42cf8ddf0e559..ab8dad3ccb6a8 100644\n--- a\/fs\/pipe.c\n+++ b\/fs\/pipe.c\n@@ -38,6 +38,12 @@ unsigned int pipe_max_size = 1048576;\n  *\/\n unsigned int pipe_min_size = PAGE_SIZE;\n \n+\/* Maximum allocatable pages per user. Hard limit is unset by default, soft\n+ * matches default values.\n+ *\/\n+unsigned long pipe_user_pages_hard;\n+unsigned long pipe_user_pages_soft = PIPE_DEF_BUFFERS * INR_OPEN_CUR;\n+\n \/*\n  * We use a start+len construction, which provides full use of the \n  * allocated memory.\n@@ -583,20 +589,49 @@ pipe_fasync(int fd, struct file *filp, int on)\n \treturn retval;\n }\n \n+static void account_pipe_buffers(struct pipe_inode_info *pipe,\n+                                 unsigned long old, unsigned long new)\n+{\n+\tatomic_long_add(new - old, &pipe->user->pipe_bufs);\n+}\n+\n+static bool too_many_pipe_buffers_soft(struct user_struct *user)\n+{\n+\treturn pipe_user_pages_soft &&\n+\t       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_soft;\n+}\n+\n+static bool too_many_pipe_buffers_hard(struct user_struct *user)\n+{\n+\treturn pipe_user_pages_hard &&\n+\t       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_hard;\n+}\n+\n struct pipe_inode_info *alloc_pipe_info(void)\n {\n \tstruct pipe_inode_info *pipe;\n \n \tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n \tif (pipe) {\n-\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n+\t\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n+\t\tstruct user_struct *user = get_current_user();\n+\n+\t\tif (!too_many_pipe_buffers_hard(user)) {\n+\t\t\tif (too_many_pipe_buffers_soft(user))\n+\t\t\t\tpipe_bufs = 1;\n+\t\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);\n+\t\t}\n+\n \t\tif (pipe->bufs) {\n \t\t\tinit_waitqueue_head(&pipe->wait);\n \t\t\tpipe->r_counter = pipe->w_counter = 1;\n-\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n+\t\t\tpipe->buffers = pipe_bufs;\n+\t\t\tpipe->user = user;\n+\t\t\taccount_pipe_buffers(pipe, 0, pipe_bufs);\n \t\t\tmutex_init(&pipe->mutex);\n \t\t\treturn pipe;\n \t\t}\n+\t\tfree_uid(user);\n \t\tkfree(pipe);\n \t}\n \n@@ -607,6 +642,8 @@ void free_pipe_info(struct pipe_inode_info *pipe)\n {\n \tint i;\n \n+\taccount_pipe_buffers(pipe, pipe->buffers, 0);\n+\tfree_uid(pipe->user);\n \tfor (i = 0; i < pipe->buffers; i++) {\n \t\tstruct pipe_buffer *buf = pipe->bufs + i;\n \t\tif (buf->ops)\n@@ -998,6 +1035,7 @@ static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n \t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n \t}\n \n+\taccount_pipe_buffers(pipe, pipe->buffers, nr_pages);\n \tpipe->curbuf = 0;\n \tkfree(pipe->bufs);\n \tpipe->bufs = bufs;\n@@ -1069,6 +1107,11 @@ long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n \t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n \t\t\tret = -EPERM;\n \t\t\tgoto out;\n+\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n+\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n+\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n+\t\t\tret = -EPERM;\n+\t\t\tgoto out;\n \t\t}\n \t\tret = pipe_set_size(pipe, nr_pages);\n \t\tbreak;\ndiff --git a\/include\/linux\/pipe_fs_i.h b\/include\/linux\/pipe_fs_i.h\nindex eb8b8ac6df3c8..24f5470d39446 100644\n--- a\/include\/linux\/pipe_fs_i.h\n+++ b\/include\/linux\/pipe_fs_i.h\n@@ -42,6 +42,7 @@ struct pipe_buffer {\n  *\t@fasync_readers: reader side fasync\n  *\t@fasync_writers: writer side fasync\n  *\t@bufs: the circular array of pipe buffers\n+ *\t@user: the user who created this pipe\n  **\/\n struct pipe_inode_info {\n \tstruct mutex mutex;\n@@ -57,6 +58,7 @@ struct pipe_inode_info {\n \tstruct fasync_struct *fasync_readers;\n \tstruct fasync_struct *fasync_writers;\n \tstruct pipe_buffer *bufs;\n+\tstruct user_struct *user;\n };\n \n \/*\n@@ -123,6 +125,8 @@ void pipe_unlock(struct pipe_inode_info *);\n void pipe_double_lock(struct pipe_inode_info *, struct pipe_inode_info *);\n \n extern unsigned int pipe_max_size, pipe_min_size;\n+extern unsigned long pipe_user_pages_hard;\n+extern unsigned long pipe_user_pages_soft;\n int pipe_proc_fn(struct ctl_table *, int, void __user *, size_t *, loff_t *);\n \n \ndiff --git a\/include\/linux\/sched.h b\/include\/linux\/sched.h\nindex 61aa9bbea871f..1589ddc88e388 100644\n--- a\/include\/linux\/sched.h\n+++ b\/include\/linux\/sched.h\n@@ -835,6 +835,7 @@ struct user_struct {\n #endif\n \tunsigned long locked_shm; \/* How many pages of mlocked shm ? *\/\n \tunsigned long unix_inflight;\t\/* How many files in flight in unix sockets *\/\n+\tatomic_long_t pipe_bufs;  \/* how many pages are allocated in pipe buffers *\/\n \n #ifdef CONFIG_KEYS\n \tstruct key *uid_keyring;\t\/* UID specific keyring *\/\ndiff --git a\/kernel\/sysctl.c b\/kernel\/sysctl.c\nindex c810f8afdb7f7..f6fd236429bd3 100644\n--- a\/kernel\/sysctl.c\n+++ b\/kernel\/sysctl.c\n@@ -1757,6 +1757,20 @@ static struct ctl_table fs_table[] = {\n \t\t.proc_handler\t= &pipe_proc_fn,\n \t\t.extra1\t\t= &pipe_min_size,\n \t},\n+\t{\n+\t\t.procname\t= \"pipe-user-pages-hard\",\n+\t\t.data\t\t= &pipe_user_pages_hard,\n+\t\t.maxlen\t\t= sizeof(pipe_user_pages_hard),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_doulongvec_minmax,\n+\t},\n+\t{\n+\t\t.procname\t= \"pipe-user-pages-soft\",\n+\t\t.data\t\t= &pipe_user_pages_soft,\n+\t\t.maxlen\t\t= sizeof(pipe_user_pages_soft),\n+\t\t.mode\t\t= 0644,\n+\t\t.proc_handler\t= proc_doulongvec_minmax,\n+\t},\n \t{ }\n };\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-1583","CWE_ID":"399","category":"security","commit_id":"d0772b70faaf8e9f2013b6c4273d94d5eac8047a","commit_message":"From d0772b70faaf8e9f2013b6c4273d94d5eac8047a Mon Sep 17 00:00:00 2001\nFrom: Eric Sesterhenn <snakebyte@gmx.de>\nDate: Sat, 28 Apr 2007 21:26:23 -0700\nSubject: [PATCH] [IPV6]: Fix slab corruption running ip6sic\n\nFrom: Eric Sesterhenn <snakebyte@gmx.de>\n\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/xfrm6_tunnel.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/xfrm6_tunnel.c b\/net\/ipv6\/xfrm6_tunnel.c\nindex 538499a899750..5502cc948dfbb 100644\n--- a\/net\/ipv6\/xfrm6_tunnel.c\n+++ b\/net\/ipv6\/xfrm6_tunnel.c\n@@ -261,7 +261,7 @@ static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n \t__be32 spi;\n \n \tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n-\treturn xfrm6_rcv_spi(skb, spi);\n+\treturn xfrm6_rcv_spi(skb, spi) > 0 ? : 0;\n }\n \n static int xfrm6_tunnel_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5578","CWE_ID":"399","category":"security","commit_id":"204f01b30975923c64006f8067f0937b91eea68b","commit_message":"From 204f01b30975923c64006f8067f0937b91eea68b Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Thu, 29 Dec 2016 04:28:41 -0500\nSubject: [PATCH] virtio-gpu: fix memory leak in resource attach backing\n\nIn the resource attach backing function, everytime it will\nallocate 'res->iov' thus can leading a memory leak. This\npatch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nMessage-id: 1483003721-65360-1-git-send-email-liq3ea@gmail.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/display\/virtio-gpu.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/hw\/display\/virtio-gpu.c b\/hw\/display\/virtio-gpu.c\nindex 6a26258..ca88cf4 100644\n--- a\/hw\/display\/virtio-gpu.c\n+++ b\/hw\/display\/virtio-gpu.c\n@@ -714,6 +714,11 @@ virtio_gpu_resource_attach_backing(VirtIOGPU *g,\n         return;\n     }\n \n+    if (res->iov) {\n+        cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n+        return;\n+    }\n+\n     ret = virtio_gpu_create_mapping_iov(&ab, cmd, &res->addrs, &res->iov);\n     if (ret != 0) {\n         cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n-- \n1.8.3.1\n\n","owner":"qemu","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2016-6308","CWE_ID":"399","category":"security","commit_id":"df6b5e29ffea2d5a3e08de92fb765fdb21c7a21e","commit_message":"From df6b5e29ffea2d5a3e08de92fb765fdb21c7a21e Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Mon, 19 Sep 2016 11:57:07 +0100\nSubject: [PATCH] Excessive allocation of memory in dtls1_preprocess_fragment()\n\nThis issue is very similar to CVE-2016-6307 described in the previous\ncommit. The underlying defect is different but the security analysis and\nimpacts are the same except that it impacts DTLS.\n\nA DTLS message includes 3 bytes for its length in the header for the\nmessage.\nThis would allow for messages up to 16Mb in length. Messages of this length\nare excessive and OpenSSL includes a check to ensure that a peer is sending\nreasonably sized messages in order to avoid too much memory being consumed\nto service a connection. A flaw in the logic of version 1.1.0 means that\nmemory for the message is allocated too early, prior to the excessive\nmessage length check. Due to way memory is allocated in OpenSSL this could\nmean an attacker could force up to 21Mb to be allocated to service a\nconnection. This could lead to a Denial of Service through memory\nexhaustion. However, the excessive message length check still takes place,\nand this would cause the connection to immediately fail. Assuming that the\napplication calls SSL_free() on the failed conneciton in a timely manner\nthen the 21Mb of allocated memory will then be immediately freed again.\nTherefore the excessive memory allocation will be transitory in nature.\nThis then means that there is only a security impact if:\n\n1) The application does not call SSL_free() in a timely manner in the\nevent that the connection fails\nor\n2) The application is working in a constrained environment where there\nis very little free memory\nor\n3) The attacker initiates multiple connection attempts such that there\nare multiple connections in a state where memory has been allocated for\nthe connection; SSL_free() has not yet been called; and there is\ninsufficient memory to service the multiple requests.\n\nExcept in the instance of (1) above any Denial Of Service is likely to\nbe transitory because as soon as the connection fails the memory is\nsubsequently freed again in the SSL_free() call. However there is an\nincreased risk during this period of application crashes due to the lack\nof memory - which would then mean a more serious Denial of Service.\n\nThis issue does not affect TLS users.\n\nIssue was reported by Shi Lei (Gear Team, Qihoo 360 Inc.).\n\nCVE-2016-6308\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(cherry picked from commit 48c054fec3506417b2598837b8062aae7114c200)\n---\n ssl\/statem\/statem_dtls.c | 35 ++++++++++++++++++-----------------\n 1 file changed, 18 insertions(+), 17 deletions(-)\n\n","diff_code":"diff --git a\/ssl\/statem\/statem_dtls.c b\/ssl\/statem\/statem_dtls.c\nindex de2de09796..043f41b724 100644\n--- a\/ssl\/statem\/statem_dtls.c\n+++ b\/ssl\/statem\/statem_dtls.c\n@@ -388,6 +388,20 @@ int dtls_get_message(SSL *s, int *mt, unsigned long *len)\n     return 1;\n }\n \n+\/*\n+ * dtls1_max_handshake_message_len returns the maximum number of bytes\n+ * permitted in a DTLS handshake message for |s|. The minimum is 16KB, but\n+ * may be greater if the maximum certificate list size requires it.\n+ *\/\n+static unsigned long dtls1_max_handshake_message_len(const SSL *s)\n+{\n+    unsigned long max_len =\n+        DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n+    if (max_len < (unsigned long)s->max_cert_list)\n+        return s->max_cert_list;\n+    return max_len;\n+}\n+\n static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr)\n {\n     size_t frag_off, frag_len, msg_len;\n@@ -397,15 +411,16 @@ static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr)\n     frag_len = msg_hdr->frag_len;\n \n     \/* sanity checking *\/\n-    if ((frag_off + frag_len) > msg_len) {\n+    if ((frag_off + frag_len) > msg_len\n+            || msg_len > dtls1_max_handshake_message_len(s)) {\n         SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);\n         return SSL_AD_ILLEGAL_PARAMETER;\n     }\n \n     if (s->d1->r_msg_hdr.frag_off == 0) { \/* first fragment *\/\n         \/*\n-         * msg_len is limited to 2^24, but is effectively checked against max\n-         * above\n+         * msg_len is limited to 2^24, but is effectively checked against\n+         * dtls_max_handshake_message_len(s) above\n          *\/\n         if (!BUF_MEM_grow_clean(s->init_buf, msg_len + DTLS1_HM_HEADER_LENGTH)) {\n             SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, ERR_R_BUF_LIB);\n@@ -493,20 +508,6 @@ static int dtls1_retrieve_buffered_fragment(SSL *s, int *ok)\n         return 0;\n }\n \n-\/*\n- * dtls1_max_handshake_message_len returns the maximum number of bytes\n- * permitted in a DTLS handshake message for |s|. The minimum is 16KB, but\n- * may be greater if the maximum certificate list size requires it.\n- *\/\n-static unsigned long dtls1_max_handshake_message_len(const SSL *s)\n-{\n-    unsigned long max_len =\n-        DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n-    if (max_len < (unsigned long)s->max_cert_list)\n-        return s->max_cert_list;\n-    return max_len;\n-}\n-\n static int\n dtls1_reassemble_fragment(SSL *s, const struct hm_header_st *msg_hdr, int *ok)\n {\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8559","CWE_ID":"399","category":"security","commit_id":"ca5358ef75fc69fee5322a38a340f5739d997c10","commit_message":"From ca5358ef75fc69fee5322a38a340f5739d997c10 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Sun, 26 Oct 2014 19:31:10 -0400\nSubject: deal with deadlock in d_walk()\n\n... by not hitting rename_retry for reasons other than rename having\nhappened.  In other words, do _not_ restart when finding that\nbetween unlocking the child and locking the parent the former got\ninto __dentry_kill().  Skip the killed siblings instead...\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n fs\/dcache.c | 31 ++++++++++++++++---------------\n 1 file changed, 16 insertions(+), 15 deletions(-)\n\n","diff_code":"diff --git a\/fs\/dcache.c b\/fs\/dcache.c\nindex 8b4c45e40834..e90aa825cc03 100644\n--- a\/fs\/dcache.c\n+++ b\/fs\/dcache.c\n@@ -495,7 +495,7 @@ static void __dentry_kill(struct dentry *dentry)\n \t}\n \t\/* if it was on the hash then remove it *\/\n \t__d_drop(dentry);\n-\tlist_del(&dentry->d_child);\n+\t__list_del_entry(&dentry->d_child);\n \t\/*\n \t * Inform d_walk() that we are no longer attached to the\n \t * dentry tree\n@@ -1081,33 +1081,31 @@ resume:\n \t\/*\n \t * All done at this level ... ascend and resume the search.\n \t *\/\n+\trcu_read_lock();\n+ascend:\n \tif (this_parent != parent) {\n \t\tstruct dentry *child = this_parent;\n \t\tthis_parent = child->d_parent;\n \n-\t\trcu_read_lock();\n \t\tspin_unlock(&child->d_lock);\n \t\tspin_lock(&this_parent->d_lock);\n \n-\t\t\/*\n-\t\t * might go back up the wrong parent if we have had a rename\n-\t\t * or deletion\n-\t\t *\/\n-\t\tif (this_parent != child->d_parent ||\n-\t\t\t (child->d_flags & DCACHE_DENTRY_KILLED) ||\n-\t\t\t need_seqretry(&rename_lock, seq)) {\n-\t\t\tspin_unlock(&this_parent->d_lock);\n-\t\t\trcu_read_unlock();\n+\t\t\/* might go back up the wrong parent if we have had a rename. *\/\n+\t\tif (need_seqretry(&rename_lock, seq))\n \t\t\tgoto rename_retry;\n+\t\tnext = child->d_child.next;\n+\t\twhile (unlikely(child->d_flags & DCACHE_DENTRY_KILLED)) {\n+\t\t\tif (next == &this_parent->d_subdirs)\n+\t\t\t\tgoto ascend;\n+\t\t\tchild = list_entry(next, struct dentry, d_child);\n+\t\t\tnext = next->next;\n \t\t}\n \t\trcu_read_unlock();\n-\t\tnext = child->d_child.next;\n \t\tgoto resume;\n \t}\n-\tif (need_seqretry(&rename_lock, seq)) {\n-\t\tspin_unlock(&this_parent->d_lock);\n+\tif (need_seqretry(&rename_lock, seq))\n \t\tgoto rename_retry;\n-\t}\n+\trcu_read_unlock();\n \tif (finish)\n \t\tfinish(data);\n \n@@ -1117,6 +1115,9 @@ out_unlock:\n \treturn;\n \n rename_retry:\n+\tspin_unlock(&this_parent->d_lock);\n+\trcu_read_unlock();\n+\tBUG_ON(seq & 1);\n \tif (!retry)\n \t\treturn;\n \tseq = 1;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2016-10155","CWE_ID":"399","category":"security","commit_id":"eb7a20a3616085d46aa6b4b4224e15587ec67e6e","commit_message":"From eb7a20a3616085d46aa6b4b4224e15587ec67e6e Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Mon, 28 Nov 2016 17:49:04 -0800\nSubject: [PATCH] watchdog: 6300esb: add exit function\n\nWhen the Intel 6300ESB watchdog is hot unplug. The timer allocated\nin realize isn't freed thus leaking memory leak. This patch avoid\nthis through adding the exit function.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nMessage-Id: <583cde9c.3223ed0a.7f0c2.886e@mx.google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n hw\/watchdog\/wdt_i6300esb.c | 9 +++++++++\n 1 file changed, 9 insertions(+)\n\n","diff_code":"diff --git a\/hw\/watchdog\/wdt_i6300esb.c b\/hw\/watchdog\/wdt_i6300esb.c\nindex a83d951..49b3cd1 100644\n--- a\/hw\/watchdog\/wdt_i6300esb.c\n+++ b\/hw\/watchdog\/wdt_i6300esb.c\n@@ -428,6 +428,14 @@ static void i6300esb_realize(PCIDevice *dev, Error **errp)\n     \/* qemu_register_coalesced_mmio (addr, 0x10); ? *\/\n }\n \n+static void i6300esb_exit(PCIDevice *dev)\n+{\n+    I6300State *d = WATCHDOG_I6300ESB_DEVICE(dev);\n+\n+    timer_del(d->timer);\n+    timer_free(d->timer);\n+}\n+\n static WatchdogTimerModel model = {\n     .wdt_name = \"i6300esb\",\n     .wdt_description = \"Intel 6300ESB\",\n@@ -441,6 +449,7 @@ static void i6300esb_class_init(ObjectClass *klass, void *data)\n     k->config_read = i6300esb_config_read;\n     k->config_write = i6300esb_config_write;\n     k->realize = i6300esb_realize;\n+    k->exit = i6300esb_exit;\n     k->vendor_id = PCI_VENDOR_ID_INTEL;\n     k->device_id = PCI_DEVICE_ID_INTEL_ESB_9;\n     k->class_id = PCI_CLASS_SYSTEM_OTHER;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5526","CWE_ID":"399","category":"security","commit_id":"069eb7b2b8fc47c7cb52e5a4af23ea98d939e3da","commit_message":"From 069eb7b2b8fc47c7cb52e5a4af23ea98d939e3da Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Wed, 14 Dec 2016 18:32:22 -0800\nSubject: [PATCH] audio: es1370: add exit function\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nCurrently the es1370 device emulation doesn't have a exit function,\nhot unplug this device will leak some memory. Add a exit function to\navoid this.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nReviewed-by: Marc-Andr\u00c3\u00a9 Lureau <marcandre.lureau@redhat.com>\nMessage-id: 585200c9.a968ca0a.1ab80.4c98@mx.google.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/audio\/es1370.c | 14 ++++++++++++++\n 1 file changed, 14 insertions(+)\n\n","diff_code":"diff --git a\/hw\/audio\/es1370.c b\/hw\/audio\/es1370.c\nindex 8449b5f..883ec69 100644\n--- a\/hw\/audio\/es1370.c\n+++ b\/hw\/audio\/es1370.c\n@@ -1041,6 +1041,19 @@ static void es1370_realize(PCIDevice *dev, Error **errp)\n     es1370_reset (s);\n }\n \n+static void es1370_exit(PCIDevice *dev)\n+{\n+    ES1370State *s = ES1370(dev);\n+    int i;\n+\n+    for (i = 0; i < 2; ++i) {\n+        AUD_close_out(&s->card, s->dac_voice[i]);\n+    }\n+\n+    AUD_close_in(&s->card, s->adc_voice);\n+    AUD_remove_card(&s->card);\n+}\n+\n static int es1370_init (PCIBus *bus)\n {\n     pci_create_simple (bus, -1, TYPE_ES1370);\n@@ -1053,6 +1066,7 @@ static void es1370_class_init (ObjectClass *klass, void *data)\n     PCIDeviceClass *k = PCI_DEVICE_CLASS (klass);\n \n     k->realize = es1370_realize;\n+    k->exit = es1370_exit;\n     k->vendor_id = PCI_VENDOR_ID_ENSONIQ;\n     k->device_id = PCI_DEVICE_ID_ENSONIQ_ES1370;\n     k->class_id = PCI_CLASS_MULTIMEDIA_AUDIO;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2008-1367","CWE_ID":"399","category":"security","commit_id":"e40cd10ccff3d9fbffd57b93780bee4b7b9bff51","commit_message":"From e40cd10ccff3d9fbffd57b93780bee4b7b9bff51 Mon Sep 17 00:00:00 2001\nFrom: Aurelien Jarno <aurelien@aurel32.net>\nDate: Wed, 5 Mar 2008 19:14:24 +0100\nSubject: x86: clear DF before calling signal handler\n\nThe Linux kernel currently does not clear the direction flag before\ncalling a signal handler, whereas the x86\/x86-64 ABI requires that.\n\nLinux had this behavior\/bug forever, but this becomes a real problem\nwith gcc version 4.3, which assumes that the direction flag is\ncorrectly cleared at the entry of a function.\n\nThis patches changes the setup_frame() functions to clear the\ndirection before entering the signal handler.\n\nSigned-off-by: Aurelien Jarno <aurelien@aurel32.net>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nAcked-by: H. Peter Anvin <hpa@zytor.com>\n---\n arch\/x86\/ia32\/ia32_signal.c | 4 ++--\n arch\/x86\/kernel\/signal_32.c | 4 ++--\n arch\/x86\/kernel\/signal_64.c | 2 +-\n 3 files changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/ia32\/ia32_signal.c b\/arch\/x86\/ia32\/ia32_signal.c\nindex 1c0503bdfb1a..5e7771a3ba2f 100644\n--- a\/arch\/x86\/ia32\/ia32_signal.c\n+++ b\/arch\/x86\/ia32\/ia32_signal.c\n@@ -500,7 +500,7 @@ int ia32_setup_frame(int sig, struct k_sigaction *ka,\n \tregs->ss = __USER32_DS;\n \n \tset_fs(USER_DS);\n-\tregs->flags &= ~X86_EFLAGS_TF;\n+\tregs->flags &= ~(X86_EFLAGS_TF | X86_EFLAGS_DF);\n \tif (test_thread_flag(TIF_SINGLESTEP))\n \t\tptrace_notify(SIGTRAP);\n \n@@ -600,7 +600,7 @@ int ia32_setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n \tregs->ss = __USER32_DS;\n \n \tset_fs(USER_DS);\n-\tregs->flags &= ~X86_EFLAGS_TF;\n+\tregs->flags &= ~(X86_EFLAGS_TF | X86_EFLAGS_DF);\n \tif (test_thread_flag(TIF_SINGLESTEP))\n \t\tptrace_notify(SIGTRAP);\n \ndiff --git a\/arch\/x86\/kernel\/signal_32.c b\/arch\/x86\/kernel\/signal_32.c\nindex caee1f002fed..0157a6f0f41f 100644\n--- a\/arch\/x86\/kernel\/signal_32.c\n+++ b\/arch\/x86\/kernel\/signal_32.c\n@@ -407,7 +407,7 @@ static int setup_frame(int sig, struct k_sigaction *ka,\n \t * The tracer may want to single-step inside the\n \t * handler too.\n \t *\/\n-\tregs->flags &= ~TF_MASK;\n+\tregs->flags &= ~(TF_MASK | X86_EFLAGS_DF);\n \tif (test_thread_flag(TIF_SINGLESTEP))\n \t\tptrace_notify(SIGTRAP);\n \n@@ -500,7 +500,7 @@ static int setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n \t * The tracer may want to single-step inside the\n \t * handler too.\n \t *\/\n-\tregs->flags &= ~TF_MASK;\n+\tregs->flags &= ~(TF_MASK | X86_EFLAGS_DF);\n \tif (test_thread_flag(TIF_SINGLESTEP))\n \t\tptrace_notify(SIGTRAP);\n \ndiff --git a\/arch\/x86\/kernel\/signal_64.c b\/arch\/x86\/kernel\/signal_64.c\nindex 7347bb14e306..56b72fb67f9b 100644\n--- a\/arch\/x86\/kernel\/signal_64.c\n+++ b\/arch\/x86\/kernel\/signal_64.c\n@@ -295,7 +295,7 @@ static int setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,\n \t   see include\/asm-x86_64\/uaccess.h for details. *\/\n \tset_fs(USER_DS);\n \n-\tregs->flags &= ~X86_EFLAGS_TF;\n+\tregs->flags &= ~(X86_EFLAGS_TF | X86_EFLAGS_DF);\n \tif (test_thread_flag(TIF_SINGLESTEP))\n \t\tptrace_notify(SIGTRAP);\n #ifdef DEBUG_SIG\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8559","CWE_ID":"399","category":"security","commit_id":"946e51f2bf37f1656916eb75bd0742ba33983c28","commit_message":"From 946e51f2bf37f1656916eb75bd0742ba33983c28 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Sun, 26 Oct 2014 19:19:16 -0400\nSubject: move d_rcu from overlapping d_child to overlapping d_alias\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/powerpc\/platforms\/cell\/spufs\/inode.c       |  2 +-\n drivers\/staging\/lustre\/lustre\/llite\/dcache.c    |  2 +-\n drivers\/staging\/lustre\/lustre\/llite\/llite_lib.c |  2 +-\n drivers\/staging\/lustre\/lustre\/llite\/namei.c     |  8 ++--\n fs\/affs\/amigaffs.c                              |  2 +-\n fs\/autofs4\/expire.c                             | 12 +++---\n fs\/autofs4\/root.c                               |  2 +-\n fs\/ceph\/dir.c                                   |  8 ++--\n fs\/ceph\/inode.c                                 |  2 +-\n fs\/cifs\/inode.c                                 |  2 +-\n fs\/coda\/cache.c                                 |  2 +-\n fs\/dcache.c                                     | 53 ++++++++++++-------------\n fs\/debugfs\/inode.c                              |  2 +-\n fs\/exportfs\/expfs.c                             |  2 +-\n fs\/libfs.c                                      | 12 +++---\n fs\/ncpfs\/dir.c                                  |  2 +-\n fs\/ncpfs\/ncplib_kernel.h                        |  4 +-\n fs\/nfs\/getroot.c                                |  2 +-\n fs\/notify\/fsnotify.c                            |  4 +-\n fs\/ocfs2\/dcache.c                               |  2 +-\n include\/linux\/dcache.h                          |  8 ++--\n kernel\/trace\/trace.c                            |  4 +-\n kernel\/trace\/trace_events.c                     |  2 +-\n security\/selinux\/selinuxfs.c                    |  6 +--\n 24 files changed, 73 insertions(+), 74 deletions(-)\n\n","diff_code":"diff --git a\/arch\/powerpc\/platforms\/cell\/spufs\/inode.c b\/arch\/powerpc\/platforms\/cell\/spufs\/inode.c\nindex 87ba7cf99cd7..65d633f20d37 100644\n--- a\/arch\/powerpc\/platforms\/cell\/spufs\/inode.c\n+++ b\/arch\/powerpc\/platforms\/cell\/spufs\/inode.c\n@@ -164,7 +164,7 @@ static void spufs_prune_dir(struct dentry *dir)\n \tstruct dentry *dentry, *tmp;\n \n \tmutex_lock(&dir->d_inode->i_mutex);\n-\tlist_for_each_entry_safe(dentry, tmp, &dir->d_subdirs, d_u.d_child) {\n+\tlist_for_each_entry_safe(dentry, tmp, &dir->d_subdirs, d_child) {\n \t\tspin_lock(&dentry->d_lock);\n \t\tif (!(d_unhashed(dentry)) && dentry->d_inode) {\n \t\t\tdget_dlock(dentry);\ndiff --git a\/drivers\/staging\/lustre\/lustre\/llite\/dcache.c b\/drivers\/staging\/lustre\/lustre\/llite\/dcache.c\nindex 439e4875b05c..311907b762bd 100644\n--- a\/drivers\/staging\/lustre\/lustre\/llite\/dcache.c\n+++ b\/drivers\/staging\/lustre\/lustre\/llite\/dcache.c\n@@ -258,7 +258,7 @@ void ll_invalidate_aliases(struct inode *inode)\n \t       inode->i_ino, inode->i_generation, inode);\n \n \tll_lock_dcache(inode);\n-\tll_d_hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {\n+\tll_d_hlist_for_each_entry(dentry, p, &inode->i_dentry, d_u.d_alias) {\n \t\tCDEBUG(D_DENTRY, \"dentry in drop %.*s (%p) parent %p \"\n \t\t       \"inode %p flags %d\\n\", dentry->d_name.len,\n \t\t       dentry->d_name.name, dentry, dentry->d_parent,\ndiff --git a\/drivers\/staging\/lustre\/lustre\/llite\/llite_lib.c b\/drivers\/staging\/lustre\/lustre\/llite\/llite_lib.c\nindex a8bcc51057f1..f4ca7b753021 100644\n--- a\/drivers\/staging\/lustre\/lustre\/llite\/llite_lib.c\n+++ b\/drivers\/staging\/lustre\/lustre\/llite\/llite_lib.c\n@@ -711,7 +711,7 @@ void lustre_dump_dentry(struct dentry *dentry, int recur)\n \t\treturn;\n \n \tlist_for_each(tmp, &dentry->d_subdirs) {\n-\t\tstruct dentry *d = list_entry(tmp, struct dentry, d_u.d_child);\n+\t\tstruct dentry *d = list_entry(tmp, struct dentry, d_child);\n \t\tlustre_dump_dentry(d, recur - 1);\n \t}\n }\ndiff --git a\/drivers\/staging\/lustre\/lustre\/llite\/namei.c b\/drivers\/staging\/lustre\/lustre\/llite\/namei.c\nindex 7a68c1e027e0..6dfd98509268 100644\n--- a\/drivers\/staging\/lustre\/lustre\/llite\/namei.c\n+++ b\/drivers\/staging\/lustre\/lustre\/llite\/namei.c\n@@ -167,14 +167,14 @@ static void ll_invalidate_negative_children(struct inode *dir)\n \tstruct ll_d_hlist_node *p;\n \n \tll_lock_dcache(dir);\n-\tll_d_hlist_for_each_entry(dentry, p, &dir->i_dentry, d_alias) {\n+\tll_d_hlist_for_each_entry(dentry, p, &dir->i_dentry, d_u.d_alias) {\n \t\tspin_lock(&dentry->d_lock);\n \t\tif (!list_empty(&dentry->d_subdirs)) {\n \t\t\tstruct dentry *child;\n \n \t\t\tlist_for_each_entry_safe(child, tmp_subdir,\n \t\t\t\t\t\t &dentry->d_subdirs,\n-\t\t\t\t\t\t d_u.d_child) {\n+\t\t\t\t\t\t d_child) {\n \t\t\t\tif (child->d_inode == NULL)\n \t\t\t\t\td_lustre_invalidate(child, 1);\n \t\t\t}\n@@ -362,7 +362,7 @@ static struct dentry *ll_find_alias(struct inode *inode, struct dentry *dentry)\n \tdiscon_alias = invalid_alias = NULL;\n \n \tll_lock_dcache(inode);\n-\tll_d_hlist_for_each_entry(alias, p, &inode->i_dentry, d_alias) {\n+\tll_d_hlist_for_each_entry(alias, p, &inode->i_dentry, d_u.d_alias) {\n \t\tLASSERT(alias != dentry);\n \n \t\tspin_lock(&alias->d_lock);\n@@ -953,7 +953,7 @@ static void ll_get_child_fid(struct inode * dir, struct qstr *name,\n {\n \tstruct dentry *parent, *child;\n \n-\tparent = ll_d_hlist_entry(dir->i_dentry, struct dentry, d_alias);\n+\tparent = ll_d_hlist_entry(dir->i_dentry, struct dentry, d_u.d_alias);\n \tchild = d_lookup(parent, name);\n \tif (child) {\n \t\tif (child->d_inode)\ndiff --git a\/fs\/affs\/amigaffs.c b\/fs\/affs\/amigaffs.c\nindex abc853968fed..937ce8754b24 100644\n--- a\/fs\/affs\/amigaffs.c\n+++ b\/fs\/affs\/amigaffs.c\n@@ -125,7 +125,7 @@ affs_fix_dcache(struct inode *inode, u32 entry_ino)\n {\n \tstruct dentry *dentry;\n \tspin_lock(&inode->i_lock);\n-\thlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {\n+\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n \t\tif (entry_ino == (u32)(long)dentry->d_fsdata) {\n \t\t\tdentry->d_fsdata = (void *)inode->i_ino;\n \t\t\tbreak;\ndiff --git a\/fs\/autofs4\/expire.c b\/fs\/autofs4\/expire.c\nindex 683a5b9ce22a..dcdec6fd33c6 100644\n--- a\/fs\/autofs4\/expire.c\n+++ b\/fs\/autofs4\/expire.c\n@@ -85,7 +85,7 @@ static struct dentry *get_next_positive_subdir(struct dentry *prev,\n \tspin_lock(&root->d_lock);\n \n \tif (prev)\n-\t\tnext = prev->d_u.d_child.next;\n+\t\tnext = prev->d_child.next;\n \telse {\n \t\tprev = dget_dlock(root);\n \t\tnext = prev->d_subdirs.next;\n@@ -99,13 +99,13 @@ cont:\n \t\treturn NULL;\n \t}\n \n-\tq = list_entry(next, struct dentry, d_u.d_child);\n+\tq = list_entry(next, struct dentry, d_child);\n \n \tspin_lock_nested(&q->d_lock, DENTRY_D_LOCK_NESTED);\n \t\/* Already gone or negative dentry (under construction) - try next *\/\n \tif (!d_count(q) || !simple_positive(q)) {\n \t\tspin_unlock(&q->d_lock);\n-\t\tnext = q->d_u.d_child.next;\n+\t\tnext = q->d_child.next;\n \t\tgoto cont;\n \t}\n \tdget_dlock(q);\n@@ -155,13 +155,13 @@ again:\n \t\t\t\tgoto relock;\n \t\t\t}\n \t\t\tspin_unlock(&p->d_lock);\n-\t\t\tnext = p->d_u.d_child.next;\n+\t\t\tnext = p->d_child.next;\n \t\t\tp = parent;\n \t\t\tif (next != &parent->d_subdirs)\n \t\t\t\tbreak;\n \t\t}\n \t}\n-\tret = list_entry(next, struct dentry, d_u.d_child);\n+\tret = list_entry(next, struct dentry, d_child);\n \n \tspin_lock_nested(&ret->d_lock, DENTRY_D_LOCK_NESTED);\n \t\/* Negative dentry - try next *\/\n@@ -489,7 +489,7 @@ found:\n \tspin_lock(&sbi->lookup_lock);\n \tspin_lock(&expired->d_parent->d_lock);\n \tspin_lock_nested(&expired->d_lock, DENTRY_D_LOCK_NESTED);\n-\tlist_move(&expired->d_parent->d_subdirs, &expired->d_u.d_child);\n+\tlist_move(&expired->d_parent->d_subdirs, &expired->d_child);\n \tspin_unlock(&expired->d_lock);\n \tspin_unlock(&expired->d_parent->d_lock);\n \tspin_unlock(&sbi->lookup_lock);\ndiff --git a\/fs\/autofs4\/root.c b\/fs\/autofs4\/root.c\nindex d76d083f2f06..0822c9eacc56 100644\n--- a\/fs\/autofs4\/root.c\n+++ b\/fs\/autofs4\/root.c\n@@ -687,7 +687,7 @@ static void autofs_clear_leaf_automount_flags(struct dentry *dentry)\n \t\/* only consider parents below dentrys in the root *\/\n \tif (IS_ROOT(parent->d_parent))\n \t\treturn;\n-\td_child = &dentry->d_u.d_child;\n+\td_child = &dentry->d_child;\n \t\/* Set parent managed if it's becoming empty *\/\n \tif (d_child->next == &parent->d_subdirs &&\n \t    d_child->prev == &parent->d_subdirs)\ndiff --git a\/fs\/ceph\/dir.c b\/fs\/ceph\/dir.c\nindex e6d63f8f98c0..695e7888fef8 100644\n--- a\/fs\/ceph\/dir.c\n+++ b\/fs\/ceph\/dir.c\n@@ -111,7 +111,7 @@ static int fpos_cmp(loff_t l, loff_t r)\n \/*\n  * When possible, we try to satisfy a readdir by peeking at the\n  * dcache.  We make this work by carefully ordering dentries on\n- * d_u.d_child when we initially get results back from the MDS, and\n+ * d_child when we initially get results back from the MDS, and\n  * falling back to a \"normal\" sync readdir if any dentries in the dir\n  * are dropped.\n  *\n@@ -147,11 +147,11 @@ static int __dcache_readdir(struct file *file,  struct dir_context *ctx,\n \t\tp = parent->d_subdirs.prev;\n \t\tdout(\" initial p %p\/%p\\n\", p->prev, p->next);\n \t} else {\n-\t\tp = last->d_u.d_child.prev;\n+\t\tp = last->d_child.prev;\n \t}\n \n more:\n-\tdentry = list_entry(p, struct dentry, d_u.d_child);\n+\tdentry = list_entry(p, struct dentry, d_child);\n \tdi = ceph_dentry(dentry);\n \twhile (1) {\n \t\tdout(\" p %p\/%p %s d_subdirs %p\/%p\\n\", p->prev, p->next,\n@@ -174,7 +174,7 @@ more:\n \t\t     !dentry->d_inode ? \" null\" : \"\");\n \t\tspin_unlock(&dentry->d_lock);\n \t\tp = p->prev;\n-\t\tdentry = list_entry(p, struct dentry, d_u.d_child);\n+\t\tdentry = list_entry(p, struct dentry, d_child);\n \t\tdi = ceph_dentry(dentry);\n \t}\n \ndiff --git a\/fs\/ceph\/inode.c b\/fs\/ceph\/inode.c\nindex 7b6139004401..7a1df90c7771 100644\n--- a\/fs\/ceph\/inode.c\n+++ b\/fs\/ceph\/inode.c\n@@ -1399,7 +1399,7 @@ retry_lookup:\n \t\t\t\/* reorder parent's d_subdirs *\/\n \t\t\tspin_lock(&parent->d_lock);\n \t\t\tspin_lock_nested(&dn->d_lock, DENTRY_D_LOCK_NESTED);\n-\t\t\tlist_move(&dn->d_u.d_child, &parent->d_subdirs);\n+\t\t\tlist_move(&dn->d_child, &parent->d_subdirs);\n \t\t\tspin_unlock(&dn->d_lock);\n \t\t\tspin_unlock(&parent->d_lock);\n \t\t}\ndiff --git a\/fs\/cifs\/inode.c b\/fs\/cifs\/inode.c\nindex 197cb503d528..0c3ce464cae4 100644\n--- a\/fs\/cifs\/inode.c\n+++ b\/fs\/cifs\/inode.c\n@@ -895,7 +895,7 @@ inode_has_hashed_dentries(struct inode *inode)\n \tstruct dentry *dentry;\n \n \tspin_lock(&inode->i_lock);\n-\thlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {\n+\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n \t\tif (!d_unhashed(dentry) || IS_ROOT(dentry)) {\n \t\t\tspin_unlock(&inode->i_lock);\n \t\t\treturn true;\ndiff --git a\/fs\/coda\/cache.c b\/fs\/coda\/cache.c\nindex 278f8fdeb9ef..46ee6f238985 100644\n--- a\/fs\/coda\/cache.c\n+++ b\/fs\/coda\/cache.c\n@@ -92,7 +92,7 @@ static void coda_flag_children(struct dentry *parent, int flag)\n \tstruct dentry *de;\n \n \tspin_lock(&parent->d_lock);\n-\tlist_for_each_entry(de, &parent->d_subdirs, d_u.d_child) {\n+\tlist_for_each_entry(de, &parent->d_subdirs, d_child) {\n \t\t\/* don't know what to do with negative dentries *\/\n \t\tif (de->d_inode ) \n \t\t\tcoda_flag_inode(de->d_inode, flag);\ndiff --git a\/fs\/dcache.c b\/fs\/dcache.c\nindex 3ffef7f4e5cd..8b4c45e40834 100644\n--- a\/fs\/dcache.c\n+++ b\/fs\/dcache.c\n@@ -44,7 +44,7 @@\n \/*\n  * Usage:\n  * dcache->d_inode->i_lock protects:\n- *   - i_dentry, d_alias, d_inode of aliases\n+ *   - i_dentry, d_u.d_alias, d_inode of aliases\n  * dcache_hash_bucket lock protects:\n  *   - the dcache hash table\n  * s_anon bl list spinlock protects:\n@@ -59,7 +59,7 @@\n  *   - d_unhashed()\n  *   - d_parent and d_subdirs\n  *   - childrens' d_child and d_parent\n- *   - d_alias, d_inode\n+ *   - d_u.d_alias, d_inode\n  *\n  * Ordering:\n  * dentry->d_inode->i_lock\n@@ -252,14 +252,12 @@ static void __d_free(struct rcu_head *head)\n {\n \tstruct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);\n \n-\tWARN_ON(!hlist_unhashed(&dentry->d_alias));\n \tkmem_cache_free(dentry_cache, dentry); \n }\n \n static void __d_free_external(struct rcu_head *head)\n {\n \tstruct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);\n-\tWARN_ON(!hlist_unhashed(&dentry->d_alias));\n \tkfree(external_name(dentry));\n \tkmem_cache_free(dentry_cache, dentry); \n }\n@@ -271,6 +269,7 @@ static inline int dname_external(const struct dentry *dentry)\n \n static void dentry_free(struct dentry *dentry)\n {\n+\tWARN_ON(!hlist_unhashed(&dentry->d_u.d_alias));\n \tif (unlikely(dname_external(dentry))) {\n \t\tstruct external_name *p = external_name(dentry);\n \t\tif (likely(atomic_dec_and_test(&p->u.count))) {\n@@ -311,7 +310,7 @@ static void dentry_iput(struct dentry * dentry)\n \tstruct inode *inode = dentry->d_inode;\n \tif (inode) {\n \t\tdentry->d_inode = NULL;\n-\t\thlist_del_init(&dentry->d_alias);\n+\t\thlist_del_init(&dentry->d_u.d_alias);\n \t\tspin_unlock(&dentry->d_lock);\n \t\tspin_unlock(&inode->i_lock);\n \t\tif (!inode->i_nlink)\n@@ -336,7 +335,7 @@ static void dentry_unlink_inode(struct dentry * dentry)\n \tstruct inode *inode = dentry->d_inode;\n \t__d_clear_type(dentry);\n \tdentry->d_inode = NULL;\n-\thlist_del_init(&dentry->d_alias);\n+\thlist_del_init(&dentry->d_u.d_alias);\n \tdentry_rcuwalk_barrier(dentry);\n \tspin_unlock(&dentry->d_lock);\n \tspin_unlock(&inode->i_lock);\n@@ -496,7 +495,7 @@ static void __dentry_kill(struct dentry *dentry)\n \t}\n \t\/* if it was on the hash then remove it *\/\n \t__d_drop(dentry);\n-\tlist_del(&dentry->d_u.d_child);\n+\tlist_del(&dentry->d_child);\n \t\/*\n \t * Inform d_walk() that we are no longer attached to the\n \t * dentry tree\n@@ -722,7 +721,7 @@ static struct dentry *__d_find_alias(struct inode *inode)\n \n again:\n \tdiscon_alias = NULL;\n-\thlist_for_each_entry(alias, &inode->i_dentry, d_alias) {\n+\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n \t\tspin_lock(&alias->d_lock);\n  \t\tif (S_ISDIR(inode->i_mode) || !d_unhashed(alias)) {\n \t\t\tif (IS_ROOT(alias) &&\n@@ -772,7 +771,7 @@ void d_prune_aliases(struct inode *inode)\n \tstruct dentry *dentry;\n restart:\n \tspin_lock(&inode->i_lock);\n-\thlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {\n+\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n \t\tspin_lock(&dentry->d_lock);\n \t\tif (!dentry->d_lockref.count) {\n \t\t\tstruct dentry *parent = lock_parent(dentry);\n@@ -1050,7 +1049,7 @@ repeat:\n resume:\n \twhile (next != &this_parent->d_subdirs) {\n \t\tstruct list_head *tmp = next;\n-\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_u.d_child);\n+\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n \t\tnext = tmp->next;\n \n \t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n@@ -1102,7 +1101,7 @@ resume:\n \t\t\tgoto rename_retry;\n \t\t}\n \t\trcu_read_unlock();\n-\t\tnext = child->d_u.d_child.next;\n+\t\tnext = child->d_child.next;\n \t\tgoto resume;\n \t}\n \tif (need_seqretry(&rename_lock, seq)) {\n@@ -1454,8 +1453,8 @@ struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n \tINIT_HLIST_BL_NODE(&dentry->d_hash);\n \tINIT_LIST_HEAD(&dentry->d_lru);\n \tINIT_LIST_HEAD(&dentry->d_subdirs);\n-\tINIT_HLIST_NODE(&dentry->d_alias);\n-\tINIT_LIST_HEAD(&dentry->d_u.d_child);\n+\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n+\tINIT_LIST_HEAD(&dentry->d_child);\n \td_set_d_op(dentry, dentry->d_sb->s_d_op);\n \n \tthis_cpu_inc(nr_dentry);\n@@ -1485,7 +1484,7 @@ struct dentry *d_alloc(struct dentry * parent, const struct qstr *name)\n \t *\/\n \t__dget_dlock(parent);\n \tdentry->d_parent = parent;\n-\tlist_add(&dentry->d_u.d_child, &parent->d_subdirs);\n+\tlist_add(&dentry->d_child, &parent->d_subdirs);\n \tspin_unlock(&parent->d_lock);\n \n \treturn dentry;\n@@ -1578,7 +1577,7 @@ static void __d_instantiate(struct dentry *dentry, struct inode *inode)\n \tspin_lock(&dentry->d_lock);\n \t__d_set_type(dentry, add_flags);\n \tif (inode)\n-\t\thlist_add_head(&dentry->d_alias, &inode->i_dentry);\n+\t\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n \tdentry->d_inode = inode;\n \tdentry_rcuwalk_barrier(dentry);\n \tspin_unlock(&dentry->d_lock);\n@@ -1602,7 +1601,7 @@ static void __d_instantiate(struct dentry *dentry, struct inode *inode)\n  \n void d_instantiate(struct dentry *entry, struct inode * inode)\n {\n-\tBUG_ON(!hlist_unhashed(&entry->d_alias));\n+\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n \tif (inode)\n \t\tspin_lock(&inode->i_lock);\n \t__d_instantiate(entry, inode);\n@@ -1641,7 +1640,7 @@ static struct dentry *__d_instantiate_unique(struct dentry *entry,\n \t\treturn NULL;\n \t}\n \n-\thlist_for_each_entry(alias, &inode->i_dentry, d_alias) {\n+\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n \t\t\/*\n \t\t * Don't need alias->d_lock here, because aliases with\n \t\t * d_parent == entry->d_parent are not subject to name or\n@@ -1667,7 +1666,7 @@ struct dentry *d_instantiate_unique(struct dentry *entry, struct inode *inode)\n {\n \tstruct dentry *result;\n \n-\tBUG_ON(!hlist_unhashed(&entry->d_alias));\n+\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n \n \tif (inode)\n \t\tspin_lock(&inode->i_lock);\n@@ -1698,7 +1697,7 @@ EXPORT_SYMBOL(d_instantiate_unique);\n  *\/\n int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n {\n-\tBUG_ON(!hlist_unhashed(&entry->d_alias));\n+\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n \n \tspin_lock(&inode->i_lock);\n \tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n@@ -1737,7 +1736,7 @@ static struct dentry * __d_find_any_alias(struct inode *inode)\n \n \tif (hlist_empty(&inode->i_dentry))\n \t\treturn NULL;\n-\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_alias);\n+\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n \t__dget(alias);\n \treturn alias;\n }\n@@ -1799,7 +1798,7 @@ static struct dentry *__d_obtain_alias(struct inode *inode, int disconnected)\n \tspin_lock(&tmp->d_lock);\n \ttmp->d_inode = inode;\n \ttmp->d_flags |= add_flags;\n-\thlist_add_head(&tmp->d_alias, &inode->i_dentry);\n+\thlist_add_head(&tmp->d_u.d_alias, &inode->i_dentry);\n \thlist_bl_lock(&tmp->d_sb->s_anon);\n \thlist_bl_add_head(&tmp->d_hash, &tmp->d_sb->s_anon);\n \thlist_bl_unlock(&tmp->d_sb->s_anon);\n@@ -2234,7 +2233,7 @@ int d_validate(struct dentry *dentry, struct dentry *dparent)\n \tstruct dentry *child;\n \n \tspin_lock(&dparent->d_lock);\n-\tlist_for_each_entry(child, &dparent->d_subdirs, d_u.d_child) {\n+\tlist_for_each_entry(child, &dparent->d_subdirs, d_child) {\n \t\tif (dentry == child) {\n \t\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n \t\t\t__dget_dlock(dentry);\n@@ -2525,13 +2524,13 @@ static void __d_move(struct dentry *dentry, struct dentry *target,\n \t\t\/* splicing a tree *\/\n \t\tdentry->d_parent = target->d_parent;\n \t\ttarget->d_parent = target;\n-\t\tlist_del_init(&target->d_u.d_child);\n-\t\tlist_move(&dentry->d_u.d_child, &dentry->d_parent->d_subdirs);\n+\t\tlist_del_init(&target->d_child);\n+\t\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n \t} else {\n \t\t\/* swapping two dentries *\/\n \t\tswap(dentry->d_parent, target->d_parent);\n-\t\tlist_move(&target->d_u.d_child, &target->d_parent->d_subdirs);\n-\t\tlist_move(&dentry->d_u.d_child, &dentry->d_parent->d_subdirs);\n+\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n+\t\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n \t\tif (exchange)\n \t\t\tfsnotify_d_move(target);\n \t\tfsnotify_d_move(dentry);\n@@ -3320,7 +3319,7 @@ void d_tmpfile(struct dentry *dentry, struct inode *inode)\n {\n \tinode_dec_link_count(inode);\n \tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n-\t\t!hlist_unhashed(&dentry->d_alias) ||\n+\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n \t\t!d_unlinked(dentry));\n \tspin_lock(&dentry->d_parent->d_lock);\n \tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\ndiff --git a\/fs\/debugfs\/inode.c b\/fs\/debugfs\/inode.c\nindex 1e3b99d3db0d..05f2960ed7c3 100644\n--- a\/fs\/debugfs\/inode.c\n+++ b\/fs\/debugfs\/inode.c\n@@ -553,7 +553,7 @@ void debugfs_remove_recursive(struct dentry *dentry)\n \t * use the d_u.d_child as the rcu head and corrupt this list.\n \t *\/\n \tspin_lock(&parent->d_lock);\n-\tlist_for_each_entry(child, &parent->d_subdirs, d_u.d_child) {\n+\tlist_for_each_entry(child, &parent->d_subdirs, d_child) {\n \t\tif (!debugfs_positive(child))\n \t\t\tcontinue;\n \ndiff --git a\/fs\/exportfs\/expfs.c b\/fs\/exportfs\/expfs.c\nindex a2b350ddd402..fdfd206c737a 100644\n--- a\/fs\/exportfs\/expfs.c\n+++ b\/fs\/exportfs\/expfs.c\n@@ -50,7 +50,7 @@ find_acceptable_alias(struct dentry *result,\n \n \tinode = result->d_inode;\n \tspin_lock(&inode->i_lock);\n-\thlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {\n+\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n \t\tdget(dentry);\n \t\tspin_unlock(&inode->i_lock);\n \t\tif (toput)\ndiff --git a\/fs\/libfs.c b\/fs\/libfs.c\nindex 171d2846f2a3..005843ce5dbd 100644\n--- a\/fs\/libfs.c\n+++ b\/fs\/libfs.c\n@@ -114,18 +114,18 @@ loff_t dcache_dir_lseek(struct file *file, loff_t offset, int whence)\n \n \t\t\tspin_lock(&dentry->d_lock);\n \t\t\t\/* d_lock not required for cursor *\/\n-\t\t\tlist_del(&cursor->d_u.d_child);\n+\t\t\tlist_del(&cursor->d_child);\n \t\t\tp = dentry->d_subdirs.next;\n \t\t\twhile (n && p != &dentry->d_subdirs) {\n \t\t\t\tstruct dentry *next;\n-\t\t\t\tnext = list_entry(p, struct dentry, d_u.d_child);\n+\t\t\t\tnext = list_entry(p, struct dentry, d_child);\n \t\t\t\tspin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);\n \t\t\t\tif (simple_positive(next))\n \t\t\t\t\tn--;\n \t\t\t\tspin_unlock(&next->d_lock);\n \t\t\t\tp = p->next;\n \t\t\t}\n-\t\t\tlist_add_tail(&cursor->d_u.d_child, p);\n+\t\t\tlist_add_tail(&cursor->d_child, p);\n \t\t\tspin_unlock(&dentry->d_lock);\n \t\t}\n \t}\n@@ -150,7 +150,7 @@ int dcache_readdir(struct file *file, struct dir_context *ctx)\n {\n \tstruct dentry *dentry = file->f_path.dentry;\n \tstruct dentry *cursor = file->private_data;\n-\tstruct list_head *p, *q = &cursor->d_u.d_child;\n+\tstruct list_head *p, *q = &cursor->d_child;\n \n \tif (!dir_emit_dots(file, ctx))\n \t\treturn 0;\n@@ -159,7 +159,7 @@ int dcache_readdir(struct file *file, struct dir_context *ctx)\n \t\tlist_move(q, &dentry->d_subdirs);\n \n \tfor (p = q->next; p != &dentry->d_subdirs; p = p->next) {\n-\t\tstruct dentry *next = list_entry(p, struct dentry, d_u.d_child);\n+\t\tstruct dentry *next = list_entry(p, struct dentry, d_child);\n \t\tspin_lock_nested(&next->d_lock, DENTRY_D_LOCK_NESTED);\n \t\tif (!simple_positive(next)) {\n \t\t\tspin_unlock(&next->d_lock);\n@@ -287,7 +287,7 @@ int simple_empty(struct dentry *dentry)\n \tint ret = 0;\n \n \tspin_lock(&dentry->d_lock);\n-\tlist_for_each_entry(child, &dentry->d_subdirs, d_u.d_child) {\n+\tlist_for_each_entry(child, &dentry->d_subdirs, d_child) {\n \t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n \t\tif (simple_positive(child)) {\n \t\t\tspin_unlock(&child->d_lock);\ndiff --git a\/fs\/ncpfs\/dir.c b\/fs\/ncpfs\/dir.c\nindex 461f6be5df20..865d578704c8 100644\n--- a\/fs\/ncpfs\/dir.c\n+++ b\/fs\/ncpfs\/dir.c\n@@ -403,7 +403,7 @@ ncp_dget_fpos(struct dentry *dentry, struct dentry *parent, unsigned long fpos)\n \n \t\/* If a pointer is invalid, we search the dentry. *\/\n \tspin_lock(&parent->d_lock);\n-\tlist_for_each_entry(dent, &parent->d_subdirs, d_u.d_child) {\n+\tlist_for_each_entry(dent, &parent->d_subdirs, d_child) {\n \t\tif ((unsigned long)dent->d_fsdata == fpos) {\n \t\t\tif (dent->d_inode)\n \t\t\t\tdget(dent);\ndiff --git a\/fs\/ncpfs\/ncplib_kernel.h b\/fs\/ncpfs\/ncplib_kernel.h\nindex 52cb19d66ecb..b785f74bfe3c 100644\n--- a\/fs\/ncpfs\/ncplib_kernel.h\n+++ b\/fs\/ncpfs\/ncplib_kernel.h\n@@ -191,7 +191,7 @@ ncp_renew_dentries(struct dentry *parent)\n \tstruct dentry *dentry;\n \n \tspin_lock(&parent->d_lock);\n-\tlist_for_each_entry(dentry, &parent->d_subdirs, d_u.d_child) {\n+\tlist_for_each_entry(dentry, &parent->d_subdirs, d_child) {\n \t\tif (dentry->d_fsdata == NULL)\n \t\t\tncp_age_dentry(server, dentry);\n \t\telse\n@@ -207,7 +207,7 @@ ncp_invalidate_dircache_entries(struct dentry *parent)\n \tstruct dentry *dentry;\n \n \tspin_lock(&parent->d_lock);\n-\tlist_for_each_entry(dentry, &parent->d_subdirs, d_u.d_child) {\n+\tlist_for_each_entry(dentry, &parent->d_subdirs, d_child) {\n \t\tdentry->d_fsdata = NULL;\n \t\tncp_age_dentry(server, dentry);\n \t}\ndiff --git a\/fs\/nfs\/getroot.c b\/fs\/nfs\/getroot.c\nindex 880618a8b048..ebc6a0add5ae 100644\n--- a\/fs\/nfs\/getroot.c\n+++ b\/fs\/nfs\/getroot.c\n@@ -58,7 +58,7 @@ static int nfs_superblock_set_dummy_root(struct super_block *sb, struct inode *i\n \t\t *\/\n \t\tspin_lock(&sb->s_root->d_inode->i_lock);\n \t\tspin_lock(&sb->s_root->d_lock);\n-\t\thlist_del_init(&sb->s_root->d_alias);\n+\t\thlist_del_init(&sb->s_root->d_u.d_alias);\n \t\tspin_unlock(&sb->s_root->d_lock);\n \t\tspin_unlock(&sb->s_root->d_inode->i_lock);\n \t}\ndiff --git a\/fs\/notify\/fsnotify.c b\/fs\/notify\/fsnotify.c\nindex 9d3e9c50066a..700129940c6e 100644\n--- a\/fs\/notify\/fsnotify.c\n+++ b\/fs\/notify\/fsnotify.c\n@@ -63,14 +63,14 @@ void __fsnotify_update_child_dentry_flags(struct inode *inode)\n \tspin_lock(&inode->i_lock);\n \t\/* run all of the dentries associated with this inode.  Since this is a\n \t * directory, there damn well better only be one item on this list *\/\n-\thlist_for_each_entry(alias, &inode->i_dentry, d_alias) {\n+\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n \t\tstruct dentry *child;\n \n \t\t\/* run all of the children of the original inode and fix their\n \t\t * d_flags to indicate parental interest (their parent is the\n \t\t * original inode) *\/\n \t\tspin_lock(&alias->d_lock);\n-\t\tlist_for_each_entry(child, &alias->d_subdirs, d_u.d_child) {\n+\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n \t\t\tif (!child->d_inode)\n \t\t\t\tcontinue;\n \ndiff --git a\/fs\/ocfs2\/dcache.c b\/fs\/ocfs2\/dcache.c\nindex e2e05a106beb..92edcfc23c1c 100644\n--- a\/fs\/ocfs2\/dcache.c\n+++ b\/fs\/ocfs2\/dcache.c\n@@ -172,7 +172,7 @@ struct dentry *ocfs2_find_local_alias(struct inode *inode,\n \tstruct dentry *dentry;\n \n \tspin_lock(&inode->i_lock);\n-\thlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {\n+\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n \t\tspin_lock(&dentry->d_lock);\n \t\tif (ocfs2_match_dentry(dentry, parent_blkno, skip_unhashed)) {\n \t\t\ttrace_ocfs2_find_local_alias(dentry->d_name.len,\ndiff --git a\/include\/linux\/dcache.h b\/include\/linux\/dcache.h\nindex b2a2a08523bf..1c2f1b84468b 100644\n--- a\/include\/linux\/dcache.h\n+++ b\/include\/linux\/dcache.h\n@@ -124,15 +124,15 @@ struct dentry {\n \tvoid *d_fsdata;\t\t\t\/* fs-specific data *\/\n \n \tstruct list_head d_lru;\t\t\/* LRU list *\/\n+\tstruct list_head d_child;\t\/* child of parent list *\/\n+\tstruct list_head d_subdirs;\t\/* our children *\/\n \t\/*\n-\t * d_child and d_rcu can share memory\n+\t * d_alias and d_rcu can share memory\n \t *\/\n \tunion {\n-\t\tstruct list_head d_child;\t\/* child of parent list *\/\n+\t\tstruct hlist_node d_alias;\t\/* inode alias list *\/\n \t \tstruct rcu_head d_rcu;\n \t} d_u;\n-\tstruct list_head d_subdirs;\t\/* our children *\/\n-\tstruct hlist_node d_alias;\t\/* inode alias list *\/\n };\n \n \/*\ndiff --git a\/kernel\/trace\/trace.c b\/kernel\/trace\/trace.c\nindex 8a528392b1f4..459a7b1251e5 100644\n--- a\/kernel\/trace\/trace.c\n+++ b\/kernel\/trace\/trace.c\n@@ -6420,7 +6420,7 @@ static int instance_mkdir (struct inode *inode, struct dentry *dentry, umode_t m\n \tint ret;\n \n \t\/* Paranoid: Make sure the parent is the \"instances\" directory *\/\n-\tparent = hlist_entry(inode->i_dentry.first, struct dentry, d_alias);\n+\tparent = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n \tif (WARN_ON_ONCE(parent != trace_instance_dir))\n \t\treturn -ENOENT;\n \n@@ -6447,7 +6447,7 @@ static int instance_rmdir(struct inode *inode, struct dentry *dentry)\n \tint ret;\n \n \t\/* Paranoid: Make sure the parent is the \"instances\" directory *\/\n-\tparent = hlist_entry(inode->i_dentry.first, struct dentry, d_alias);\n+\tparent = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n \tif (WARN_ON_ONCE(parent != trace_instance_dir))\n \t\treturn -ENOENT;\n \ndiff --git a\/kernel\/trace\/trace_events.c b\/kernel\/trace\/trace_events.c\nindex 0cc51edde3a8..1b0df1e504f0 100644\n--- a\/kernel\/trace\/trace_events.c\n+++ b\/kernel\/trace\/trace_events.c\n@@ -461,7 +461,7 @@ static void remove_event_file_dir(struct ftrace_event_file *file)\n \n \tif (dir) {\n \t\tspin_lock(&dir->d_lock);\t\/* probably unneeded *\/\n-\t\tlist_for_each_entry(child, &dir->d_subdirs, d_u.d_child) {\n+\t\tlist_for_each_entry(child, &dir->d_subdirs, d_child) {\n \t\t\tif (child->d_inode)\t\/* probably unneeded *\/\n \t\t\t\tchild->d_inode->i_private = NULL;\n \t\t}\ndiff --git a\/security\/selinux\/selinuxfs.c b\/security\/selinux\/selinuxfs.c\nindex c71737f6d1cc..33db1ad4fd10 100644\n--- a\/security\/selinux\/selinuxfs.c\n+++ b\/security\/selinux\/selinuxfs.c\n@@ -1200,7 +1200,7 @@ static void sel_remove_entries(struct dentry *de)\n \tspin_lock(&de->d_lock);\n \tnode = de->d_subdirs.next;\n \twhile (node != &de->d_subdirs) {\n-\t\tstruct dentry *d = list_entry(node, struct dentry, d_u.d_child);\n+\t\tstruct dentry *d = list_entry(node, struct dentry, d_child);\n \n \t\tspin_lock_nested(&d->d_lock, DENTRY_D_LOCK_NESTED);\n \t\tlist_del_init(node);\n@@ -1674,12 +1674,12 @@ static void sel_remove_classes(void)\n \n \tlist_for_each(class_node, &class_dir->d_subdirs) {\n \t\tstruct dentry *class_subdir = list_entry(class_node,\n-\t\t\t\t\tstruct dentry, d_u.d_child);\n+\t\t\t\t\tstruct dentry, d_child);\n \t\tstruct list_head *class_subdir_node;\n \n \t\tlist_for_each(class_subdir_node, &class_subdir->d_subdirs) {\n \t\t\tstruct dentry *d = list_entry(class_subdir_node,\n-\t\t\t\t\t\tstruct dentry, d_u.d_child);\n+\t\t\t\t\t\tstruct dentry, d_child);\n \n \t\t\tif (d->d_inode)\n \t\t\t\tif (d->d_inode->i_mode & S_IFDIR)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4163","CWE_ID":"399","category":"security","commit_id":"9284bcf4e335e5f18a8bc7b26461c33ab60d0689","commit_message":"From 9284bcf4e335e5f18a8bc7b26461c33ab60d0689 Mon Sep 17 00:00:00 2001\nFrom: Jens Axboe <jaxboe@fusionio.com>\nDate: Fri, 29 Oct 2010 08:10:18 -0600\nSubject: block: check for proper length of iov entries in\n blk_rq_map_user_iov()\n\nEnsure that we pass down properly validated iov segments before\ncalling into the mapping or copy functions.\n\nReported-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: stable@kernel.org\nSigned-off-by: Jens Axboe <jaxboe@fusionio.com>\n---\n block\/blk-map.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/block\/blk-map.c b\/block\/blk-map.c\nindex d4a586d8691e..5d5dbe47c228 100644\n--- a\/block\/blk-map.c\n+++ b\/block\/blk-map.c\n@@ -205,6 +205,8 @@ int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n \t\t\tunaligned = 1;\n \t\t\tbreak;\n \t\t}\n+\t\tif (!iov[i].iov_len)\n+\t\t\treturn -EINVAL;\n \t}\n \n \tif (unaligned || (q->dma_pad_mask & len) || map_data)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-4141","CWE_ID":"399","category":"security","commit_id":"53281b6d34d44308372d16acb7fb5327609f68b6","commit_message":"From 53281b6d34d44308372d16acb7fb5327609f68b6 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Wed, 16 Dec 2009 08:23:37 -0800\nSubject: fasync: split 'fasync_helper()' into separate add\/remove functions\n\nYes, the add and remove cases do share the same basic loop and the\nlocking, but the compiler can inline and then CSE some of the end result\nanyway.  And splitting it up makes the code way easier to follow,\nand makes it clearer exactly what the semantics are.\n\nIn particular, we must make sure that the FASYNC flag in file->f_flags\nexactly matches the state of \"is this file on any fasync list\", since\nnot only is that flag visible to user space (F_GETFL), but we also use\nthat flag to check whether we need to remove any fasync entries on file\nclose.\n\nWe got that wrong for the case of a mixed use of file locking (which\ntries to remove any fasync entries for file leases) and fasync.\n\nSplitting the function up also makes it possible to do some future\noptimizations without making the function even messier.  In particular,\nsince the FASYNC flag has to match the state of \"is this on a list\", we\ncan do the following future optimizations:\n\n - on remove, we don't even need to get the locks and traverse the list\n   if FASYNC isn't set, since we can know a priori that there is no\n   point (this is effectively the same optimization that we already do\n   in __fput() wrt removing fasync on file close)\n\n - on add, we can use the FASYNC flag to decide whether we are changing\n   an existing entry or need to allocate a new one.\n\nbut this is just the cleanup + fix for the FASYNC flag.\n\nAcked-by: Al Viro <viro@ZenIV.linux.org.uk>\nTested-by: Tavis Ormandy <taviso@google.com>\nCc: Jeff Dike <jdike@addtoit.com>\nCc: Matt Mackall <mpm@selenic.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/fcntl.c | 102 +++++++++++++++++++++++++++++++++++++++----------------------\n 1 file changed, 66 insertions(+), 36 deletions(-)\n\n","diff_code":"diff --git a\/fs\/fcntl.c b\/fs\/fcntl.c\nindex 2cf93ec40a67..97e01dc0d95f 100644\n--- a\/fs\/fcntl.c\n+++ b\/fs\/fcntl.c\n@@ -618,60 +618,90 @@ static DEFINE_RWLOCK(fasync_lock);\n static struct kmem_cache *fasync_cache __read_mostly;\n \n \/*\n- * fasync_helper() is used by almost all character device drivers\n- * to set up the fasync queue. It returns negative on error, 0 if it did\n- * no changes and positive if it added\/deleted the entry.\n+ * Remove a fasync entry. If successfully removed, return\n+ * positive and clear the FASYNC flag. If no entry exists,\n+ * do nothing and return 0.\n+ *\n+ * NOTE! It is very important that the FASYNC flag always\n+ * match the state \"is the filp on a fasync list\".\n+ *\n+ * We always take the 'filp->f_lock', in since fasync_lock\n+ * needs to be irq-safe.\n  *\/\n-int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n+static int fasync_remove_entry(struct file *filp, struct fasync_struct **fapp)\n {\n \tstruct fasync_struct *fa, **fp;\n-\tstruct fasync_struct *new = NULL;\n \tint result = 0;\n \n-\tif (on) {\n-\t\tnew = kmem_cache_alloc(fasync_cache, GFP_KERNEL);\n-\t\tif (!new)\n-\t\t\treturn -ENOMEM;\n+\tspin_lock(&filp->f_lock);\n+\twrite_lock_irq(&fasync_lock);\n+\tfor (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {\n+\t\tif (fa->fa_file != filp)\n+\t\t\tcontinue;\n+\t\t*fp = fa->fa_next;\n+\t\tkmem_cache_free(fasync_cache, fa);\n+\t\tfilp->f_flags &= ~FASYNC;\n+\t\tresult = 1;\n+\t\tbreak;\n \t}\n+\twrite_unlock_irq(&fasync_lock);\n+\tspin_unlock(&filp->f_lock);\n+\treturn result;\n+}\n+\n+\/*\n+ * Add a fasync entry. Return negative on error, positive if\n+ * added, and zero if did nothing but change an existing one.\n+ *\n+ * NOTE! It is very important that the FASYNC flag always\n+ * match the state \"is the filp on a fasync list\".\n+ *\/\n+static int fasync_add_entry(int fd, struct file *filp, struct fasync_struct **fapp)\n+{\n+\tstruct fasync_struct *new, *fa, **fp;\n+\tint result = 0;\n+\n+\tnew = kmem_cache_alloc(fasync_cache, GFP_KERNEL);\n+\tif (!new)\n+\t\treturn -ENOMEM;\n \n-\t\/*\n-\t * We need to take f_lock first since it's not an IRQ-safe\n-\t * lock.\n-\t *\/\n \tspin_lock(&filp->f_lock);\n \twrite_lock_irq(&fasync_lock);\n \tfor (fp = fapp; (fa = *fp) != NULL; fp = &fa->fa_next) {\n-\t\tif (fa->fa_file == filp) {\n-\t\t\tif(on) {\n-\t\t\t\tfa->fa_fd = fd;\n-\t\t\t\tkmem_cache_free(fasync_cache, new);\n-\t\t\t} else {\n-\t\t\t\t*fp = fa->fa_next;\n-\t\t\t\tkmem_cache_free(fasync_cache, fa);\n-\t\t\t\tresult = 1;\n-\t\t\t}\n-\t\t\tgoto out;\n-\t\t}\n+\t\tif (fa->fa_file != filp)\n+\t\t\tcontinue;\n+\t\tfa->fa_fd = fd;\n+\t\tkmem_cache_free(fasync_cache, new);\n+\t\tgoto out;\n \t}\n \n-\tif (on) {\n-\t\tnew->magic = FASYNC_MAGIC;\n-\t\tnew->fa_file = filp;\n-\t\tnew->fa_fd = fd;\n-\t\tnew->fa_next = *fapp;\n-\t\t*fapp = new;\n-\t\tresult = 1;\n-\t}\n+\tnew->magic = FASYNC_MAGIC;\n+\tnew->fa_file = filp;\n+\tnew->fa_fd = fd;\n+\tnew->fa_next = *fapp;\n+\t*fapp = new;\n+\tresult = 1;\n+\tfilp->f_flags |= FASYNC;\n+\n out:\n-\tif (on)\n-\t\tfilp->f_flags |= FASYNC;\n-\telse\n-\t\tfilp->f_flags &= ~FASYNC;\n \twrite_unlock_irq(&fasync_lock);\n \tspin_unlock(&filp->f_lock);\n \treturn result;\n }\n \n+\/*\n+ * fasync_helper() is used by almost all character device drivers\n+ * to set up the fasync queue, and for regular files by the file\n+ * lease code. It returns negative on error, 0 if it did no changes\n+ * and positive if it added\/deleted the entry.\n+ *\/\n+int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)\n+{\n+\tif (!on)\n+\t\treturn fasync_remove_entry(filp, fapp);\n+\treturn fasync_add_entry(fd, filp, fapp);\n+}\n+\n EXPORT_SYMBOL(fasync_helper);\n \n void __kill_fasync(struct fasync_struct *fa, int sig, int band)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2014-9621","CWE_ID":"399","category":"security","commit_id":"65437cee25199dbd385fb35901bc0011e164276c","commit_message":"From 65437cee25199dbd385fb35901bc0011e164276c Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Tue, 16 Dec 2014 23:29:42 +0000\nSubject: [PATCH] Limit string printing to 100 chars, and add flags I forgot in\n the previous commit.\n\n---\n src\/readelf.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/src\/readelf.c b\/src\/readelf.c\nindex 8e50d7281..cd1f79d5f 100644\n--- a\/src\/readelf.c\n+++ b\/src\/readelf.c\n@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.115 2014\/12\/16 20:53:05 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.116 2014\/12\/16 23:18:40 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -900,19 +900,23 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t}\n \n \tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n+\t\tif (descsz > 100)\n+\t\t\tdescsz = 100;\n \t\tswitch (xnh_type) {\n \t    \tcase NT_NETBSD_VERSION:\n \t\t\treturn size;\n \t\tcase NT_NETBSD_MARCH:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_MARCH)\n \t\t\t\treturn size;\n-\t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,\n-\t\t\t    (const char *)&nbuf[doff]) == -1)\n+\t\t\t*flags |= FLAGS_DID_NETBSD_MARCH;\n+\t\t\tif (file_printf(ms, \", compiled for: %.*s\",\n+\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n \t\tcase NT_NETBSD_CMODEL:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_CMODEL)\n \t\t\t\treturn size;\n+\t\t\t*flags |= FLAGS_DID_NETBSD_CMODEL;\n \t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n \t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n \t\t\t\treturn size;\n@@ -920,6 +924,7 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\tdefault:\n \t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n \t\t\t\treturn size;\n+\t\t\t*flags |= FLAGS_DID_NETBSD_UNKNOWN;\n \t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n \t\t\t\treturn size;\n \t\t\tbreak;\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2016-7908","CWE_ID":"399","category":"security","commit_id":"070c4b92b8cd5390889716677a0b92444d6e087a","commit_message":"From 070c4b92b8cd5390889716677a0b92444d6e087a Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Thu, 22 Sep 2016 16:02:37 +0530\nSubject: [PATCH] net: mcf: limit buffer descriptor count\n\nColdFire Fast Ethernet Controller uses buffer descriptors to manage\ndata flow to\/fro receive & transmit queues. While transmitting\npackets, it could continue to read buffer descriptors if a buffer\ndescriptor has length of zero and has crafted values in bd.flags.\nSet upper limit to number of buffer descriptors.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nReviewed-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\n---\n hw\/net\/mcf_fec.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/hw\/net\/mcf_fec.c b\/hw\/net\/mcf_fec.c\nindex 0ee8ad9..d31fea1 100644\n--- a\/hw\/net\/mcf_fec.c\n+++ b\/hw\/net\/mcf_fec.c\n@@ -23,6 +23,7 @@ do { printf(\"mcf_fec: \" fmt , ## __VA_ARGS__); } while (0)\n #define DPRINTF(fmt, ...) do {} while(0)\n #endif\n \n+#define FEC_MAX_DESC 1024\n #define FEC_MAX_FRAME_SIZE 2032\n \n typedef struct {\n@@ -149,7 +150,7 @@ static void mcf_fec_do_tx(mcf_fec_state *s)\n     uint32_t addr;\n     mcf_fec_bd bd;\n     int frame_size;\n-    int len;\n+    int len, descnt = 0;\n     uint8_t frame[FEC_MAX_FRAME_SIZE];\n     uint8_t *ptr;\n \n@@ -157,7 +158,7 @@ static void mcf_fec_do_tx(mcf_fec_state *s)\n     ptr = frame;\n     frame_size = 0;\n     addr = s->tx_descriptor;\n-    while (1) {\n+    while (descnt++ < FEC_MAX_DESC) {\n         mcf_fec_read_bd(&bd, addr);\n         DPRINTF(\"tx_bd %x flags %04x len %d data %08x\\n\",\n                 addr, bd.flags, bd.length, bd.data);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6317","CWE_ID":"399","category":"security","commit_id":"a2f12a1b0f95b13b6f8dc3d05d7b74b4386394e4","commit_message":"From a2f12a1b0f95b13b6f8dc3d05d7b74b4386394e4 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Sat, 7 Jan 2017 01:24:21 -0500\nSubject: renderer: fix memory leak in add shader program\n\nFree 'sprog' in error path to avoid memory leak.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n src\/vrend_renderer.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/src\/vrend_renderer.c b\/src\/vrend_renderer.c\nindex 32e2e7d..ad68f71 100644\n--- a\/src\/vrend_renderer.c\n+++ b\/src\/vrend_renderer.c\n@@ -892,6 +892,7 @@ static struct vrend_linked_shader_program *add_shader_program(struct vrend_conte\n          fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n       fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n       glDeleteProgram(prog_id);\n+      free(sprog);\n       return NULL;\n    }\n \n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-2126","CWE_ID":"399","category":"security","commit_id":"19ffddb0fe1a4ffdb459b797ffcf7f490d28b5a6","commit_message":"From 19ffddb0fe1a4ffdb459b797ffcf7f490d28b5a6 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Sun, 26 May 2013 11:53:39 +0400\nSubject: [PATCH] prevent double-free() on broken full-color images error\n handling\n\n---\n src\/libraw_cxx.cpp | 10 ++++++++--\n 1 file changed, 8 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/libraw_cxx.cpp b\/src\/libraw_cxx.cpp\nindex e36c11a5..f45521b2 100644\n--- a\/src\/libraw_cxx.cpp\n+++ b\/src\/libraw_cxx.cpp\n@@ -1144,8 +1144,8 @@ int LibRaw::unpack(void)\n                 IO.shrink = 0;\n \t\t\t\tS.raw_pitch = S.width*8;\n                 \/\/ allocate image as temporary buffer, size \n-                imgdata.rawdata.raw_alloc = calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));\n-                imgdata.image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;\n+                imgdata.rawdata.raw_alloc = 0;\n+                imgdata.image = (ushort (*)[4]) calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));\n               }\n             ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n \n@@ -1155,6 +1155,12 @@ int LibRaw::unpack(void)\n             (this->*load_raw)();\n \t\t\tif(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n \t\t\t\tC.maximum = m_save;\n+\t\t\tif (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n+\t\t\t{\n+\t\t\t\t\/\/ successfully decoded legacy image, attach image to raw_alloc\n+\t\t\t\timgdata.rawdata.raw_alloc = imgdata.image;\n+\t\t\t\timgdata.image = 0; \n+\t\t\t}\n           }\n \n         if(imgdata.rawdata.raw_image)\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2016-10214","CWE_ID":"399","category":"security","commit_id":"40b0e7813325b08077b6f541b3989edb2d86d837","commit_message":"From 40b0e7813325b08077b6f541b3989edb2d86d837 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Mon, 26 Dec 2016 21:23:42 -0500\nSubject: renderer: fix a leak in resource attach\n\nJust return if the resource has been attached a iov\nto avoid memory leak.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n src\/vrend_renderer.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/src\/vrend_renderer.c b\/src\/vrend_renderer.c\nindex da7cbed..00b61eb 100644\n--- a\/src\/vrend_renderer.c\n+++ b\/src\/vrend_renderer.c\n@@ -4031,6 +4031,9 @@ int vrend_renderer_resource_attach_iov(int res_handle, struct iovec *iov,\n    if (!res)\n       return EINVAL;\n \n+   if (res->iov)\n+      return 0;\n+\n    \/* work out size and max resource size *\/\n    res->iov = iov;\n    res->num_iovs = num_iovs;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-1339","CWE_ID":"399","category":"security","commit_id":"2c5816b4beccc8ba709144539f6fdd764f8fa49c","commit_message":"From 2c5816b4beccc8ba709144539f6fdd764f8fa49c Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Tue, 10 Nov 2015 10:32:36 +0100\nSubject: cuse: fix memory leak\n\nThe problem is that fuse_dev_alloc() acquires an extra reference to cc.fc,\nand the original ref count is never dropped.\n\nReported-by: Colin Ian King <colin.king@canonical.com>\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nFixes: cc080e9e9be1 (\"fuse: introduce per-instance fuse_dev structure\")\nCc: <stable@vger.kernel.org> # v4.2+\n---\n fs\/fuse\/cuse.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/fs\/fuse\/cuse.c b\/fs\/fuse\/cuse.c\nindex eae2c11268bc..8e3ee1936c7e 100644\n--- a\/fs\/fuse\/cuse.c\n+++ b\/fs\/fuse\/cuse.c\n@@ -549,6 +549,8 @@ static int cuse_channel_release(struct inode *inode, struct file *file)\n \t\tunregister_chrdev_region(cc->cdev->dev, 1);\n \t\tcdev_del(cc->cdev);\n \t}\n+\t\/* Base reference is now owned by \"fud\" *\/\n+\tfuse_conn_put(&cc->fc);\n \n \trc = fuse_dev_release(inode, file);\t\/* puts the base reference *\/\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-2017","CWE_ID":"399","category":"security","commit_id":"6ec82562ffc6f297d0de36d65776cff8e5704867","commit_message":"From 6ec82562ffc6f297d0de36d65776cff8e5704867 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <eric.dumazet@gmail.com>\nDate: Thu, 6 May 2010 00:53:53 -0700\nSubject: [PATCH] veth: Dont kfree_skb() after dev_forward_skb()\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nIn case of congestion, netif_rx() frees the skb, so we must assume\ndev_forward_skb() also consume skb.\n\nBug introduced by commit 445409602c092\n(veth: move loopback logic to common location)\n\nWe must change dev_forward_skb() to always consume skb, and veth to not\ndouble free it.\n\nBug report : http:\/\/marc.info\/?l=linux-netdev&m=127310770900442&w=3\n\nReported-by: Mart\u00edn Ferrari <martin.ferrari@gmail.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/veth.c |  1 -\n net\/core\/dev.c     | 11 +++++------\n 2 files changed, 5 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/veth.c b\/drivers\/net\/veth.c\nindex f9f0730b53d5d..5ec542dd5b500 100644\n--- a\/drivers\/net\/veth.c\n+++ b\/drivers\/net\/veth.c\n@@ -187,7 +187,6 @@ static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n \treturn NETDEV_TX_OK;\n \n rx_drop:\n-\tkfree_skb(skb);\n \trcv_stats->rx_dropped++;\n \treturn NETDEV_TX_OK;\n }\ndiff --git a\/net\/core\/dev.c b\/net\/core\/dev.c\nindex f769098774b7e..264137fce3a25 100644\n--- a\/net\/core\/dev.c\n+++ b\/net\/core\/dev.c\n@@ -1451,7 +1451,7 @@ static inline void net_timestamp(struct sk_buff *skb)\n  *\n  * return values:\n  *\tNET_RX_SUCCESS\t(no congestion)\n- *\tNET_RX_DROP     (packet was dropped)\n+ *\tNET_RX_DROP     (packet was dropped, but freed)\n  *\n  * dev_forward_skb can be used for injecting an skb from the\n  * start_xmit function of one device into the receive queue\n@@ -1465,12 +1465,11 @@ int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n {\n \tskb_orphan(skb);\n \n-\tif (!(dev->flags & IFF_UP))\n-\t\treturn NET_RX_DROP;\n-\n-\tif (skb->len > (dev->mtu + dev->hard_header_len))\n+\tif (!(dev->flags & IFF_UP) ||\n+\t    (skb->len > (dev->mtu + dev->hard_header_len))) {\n+\t\tkfree_skb(skb);\n \t\treturn NET_RX_DROP;\n-\n+\t}\n \tskb_set_dev(skb, dev);\n \tskb->tstamp.tv64 = 0;\n \tskb->pkt_type = PACKET_HOST;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-9102","CWE_ID":"399","category":"security","commit_id":"ff55e94d23ae94c8628b0115320157c763eb3e06","commit_message":"From ff55e94d23ae94c8628b0115320157c763eb3e06 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Mon, 17 Oct 2016 14:13:58 +0200\nSubject: [PATCH] 9pfs: fix memory leak in v9fs_xattrcreate\n\nThe 'fs.xattr.value' field in V9fsFidState object doesn't consider the\nsituation that this field has been allocated previously. Every time, it\nwill be allocated directly. This leads to a host memory leak issue if\nthe client sends another Txattrcreate message with the same fid number\nbefore the fid from the previous time got clunked.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nReviewed-by: Greg Kurz <groug@kaod.org>\n[groug, updated the changelog to indicate how the leak can occur]\nSigned-off-by: Greg Kurz <groug@kaod.org>\n---\n hw\/9pfs\/9p.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/hw\/9pfs\/9p.c b\/hw\/9pfs\/9p.c\nindex bf23b01..66135cf 100644\n--- a\/hw\/9pfs\/9p.c\n+++ b\/hw\/9pfs\/9p.c\n@@ -3282,6 +3282,7 @@ static void coroutine_fn v9fs_xattrcreate(void *opaque)\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n+    g_free(xattr_fidp->fs.xattr.value);\n     xattr_fidp->fs.xattr.value = g_malloc0(size);\n     err = offset;\n     put_fid(pdu, file_fidp);\n-- \n1.8.3.1\n\n","owner":"qemu","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2010-0008","CWE_ID":"399","category":"security","commit_id":"ece25dfa0991f65c4e1d26beb1c3c45bda4239b8","commit_message":"From ece25dfa0991f65c4e1d26beb1c3c45bda4239b8 Mon Sep 17 00:00:00 2001\nFrom: Vlad Yasevich <vladislav.yasevich@hp.com>\nDate: Fri, 7 Sep 2007 16:30:54 -0400\nSubject: SCTP: Clean up OOTB handling and fix infinite loop processing\n\nWhile processing OOTB chunks as well as chunks with an invalid\nlength of 0, it was possible to SCTP to get wedged inside an\ninfinite loop because we didn't catch the condition correctly,\nor didn't mark the packet for discard correctly.\nThis work is based on original findings and work by\nWei Yongjun <yjwei@cn.fujitsu.com>\n\nSigned-off-by: Vlad Yasevich <vladislav.yasevich@hp.com>\n---\n include\/net\/sctp\/sm.h    |   1 -\n net\/sctp\/sm_statefuns.c  | 163 +++++++++++++++++++++++++++++++++++++----------\n net\/sctp\/sm_statetable.c |  16 ++---\n 3 files changed, 138 insertions(+), 42 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/sctp\/sm.h b\/include\/net\/sctp\/sm.h\nindex 991c85bb9e36..cc71f366d1cd 100644\n--- a\/include\/net\/sctp\/sm.h\n+++ b\/include\/net\/sctp\/sm.h\n@@ -114,7 +114,6 @@ sctp_state_fn_t sctp_sf_do_4_C;\n sctp_state_fn_t sctp_sf_eat_data_6_2;\n sctp_state_fn_t sctp_sf_eat_data_fast_4_4;\n sctp_state_fn_t sctp_sf_eat_sack_6_2;\n-sctp_state_fn_t sctp_sf_tabort_8_4_8;\n sctp_state_fn_t sctp_sf_operr_notify;\n sctp_state_fn_t sctp_sf_t1_init_timer_expire;\n sctp_state_fn_t sctp_sf_t1_cookie_timer_expire;\ndiff --git a\/net\/sctp\/sm_statefuns.c b\/net\/sctp\/sm_statefuns.c\nindex 5e7fb0f54b88..caed19d90d06 100644\n--- a\/net\/sctp\/sm_statefuns.c\n+++ b\/net\/sctp\/sm_statefuns.c\n@@ -90,6 +90,11 @@ static sctp_disposition_t sctp_sf_shut_8_4_5(const struct sctp_endpoint *ep,\n \t\t\t\t\t     const sctp_subtype_t type,\n \t\t\t\t\t     void *arg,\n \t\t\t\t\t     sctp_cmd_seq_t *commands);\n+static sctp_disposition_t sctp_sf_tabort_8_4_8(const struct sctp_endpoint *ep,\n+\t\t\t\t\tconst struct sctp_association *asoc,\n+\t\t\t\t\tconst sctp_subtype_t type,\n+\t\t\t\t\tvoid *arg,\n+\t\t\t\t\tsctp_cmd_seq_t *commands);\n static struct sctp_sackhdr *sctp_sm_pull_sack(struct sctp_chunk *chunk);\n \n static sctp_disposition_t sctp_stop_t1_and_abort(sctp_cmd_seq_t *commands,\n@@ -98,6 +103,7 @@ static sctp_disposition_t sctp_stop_t1_and_abort(sctp_cmd_seq_t *commands,\n \t\t\t\t\t   struct sctp_transport *transport);\n \n static sctp_disposition_t sctp_sf_abort_violation(\n+\t\t\t\t     const struct sctp_endpoint *ep,\n \t\t\t\t     const struct sctp_association *asoc,\n \t\t\t\t     void *arg,\n \t\t\t\t     sctp_cmd_seq_t *commands,\n@@ -118,6 +124,13 @@ static sctp_disposition_t sctp_sf_violation_ctsn(\n \t\t\t\t     void *arg,\n \t\t\t\t     sctp_cmd_seq_t *commands);\n \n+static sctp_disposition_t sctp_sf_violation_chunk(\n+\t\t\t\t     const struct sctp_endpoint *ep,\n+\t\t\t\t     const struct sctp_association *asoc,\n+\t\t\t\t     const sctp_subtype_t type,\n+\t\t\t\t     void *arg,\n+\t\t\t\t     sctp_cmd_seq_t *commands);\n+\n \/* Small helper function that checks if the chunk length\n  * is of the appropriate length.  The 'required_length' argument\n  * is set to be the size of a specific chunk we are testing.\n@@ -181,16 +194,21 @@ sctp_disposition_t sctp_sf_do_4_C(const struct sctp_endpoint *ep,\n \tstruct sctp_chunk *chunk = arg;\n \tstruct sctp_ulpevent *ev;\n \n+\tif (!sctp_vtag_verify_either(chunk, asoc))\n+\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n+\n \t\/* RFC 2960 6.10 Bundling\n \t *\n \t * An endpoint MUST NOT bundle INIT, INIT ACK or\n \t * SHUTDOWN COMPLETE with any other chunks.\n \t *\/\n \tif (!chunk->singleton)\n-\t\treturn SCTP_DISPOSITION_VIOLATION;\n+\t\treturn sctp_sf_violation_chunk(ep, asoc, type, arg, commands);\n \n-\tif (!sctp_vtag_verify_either(chunk, asoc))\n-\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n+\t\/* Make sure that the SHUTDOWN_COMPLETE chunk has a valid length. *\/\n+\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n+\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n \n \t\/* RFC 2960 10.2 SCTP-to-ULP\n \t *\n@@ -450,17 +468,17 @@ sctp_disposition_t sctp_sf_do_5_1C_ack(const struct sctp_endpoint *ep,\n \tif (!sctp_vtag_verify(chunk, asoc))\n \t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n \n-\t\/* Make sure that the INIT-ACK chunk has a valid length *\/\n-\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_initack_chunk_t)))\n-\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n-\t\t\t\t\t\t  commands);\n \t\/* 6.10 Bundling\n \t * An endpoint MUST NOT bundle INIT, INIT ACK or\n \t * SHUTDOWN COMPLETE with any other chunks.\n \t *\/\n \tif (!chunk->singleton)\n-\t\treturn SCTP_DISPOSITION_VIOLATION;\n+\t\treturn sctp_sf_violation_chunk(ep, asoc, type, arg, commands);\n \n+\t\/* Make sure that the INIT-ACK chunk has a valid length *\/\n+\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_initack_chunk_t)))\n+\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n \t\/* Grab the INIT header.  *\/\n \tchunk->subh.init_hdr = (sctp_inithdr_t *) chunk->skb->data;\n \n@@ -585,7 +603,7 @@ sctp_disposition_t sctp_sf_do_5_1D_ce(const struct sctp_endpoint *ep,\n \t * control endpoint, respond with an ABORT.\n \t *\/\n \tif (ep == sctp_sk((sctp_get_ctl_sock()))->ep)\n-\t\treturn sctp_sf_ootb(ep, asoc, type, arg, commands);\n+\t\treturn sctp_sf_tabort_8_4_8(ep, asoc, type, arg, commands);\n \n \t\/* Make sure that the COOKIE_ECHO chunk has a valid length.\n \t * In this case, we check that we have enough for at least a\n@@ -2496,6 +2514,11 @@ sctp_disposition_t sctp_sf_do_9_2_reshutack(const struct sctp_endpoint *ep,\n \tstruct sctp_chunk *chunk = (struct sctp_chunk *) arg;\n \tstruct sctp_chunk *reply;\n \n+\t\/* Make sure that the chunk has a valid length *\/\n+\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n+\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n+\n \t\/* Since we are not going to really process this INIT, there\n \t * is no point in verifying chunk boundries.  Just generate\n \t * the SHUTDOWN ACK.\n@@ -2929,7 +2952,7 @@ sctp_disposition_t sctp_sf_eat_sack_6_2(const struct sctp_endpoint *ep,\n  *\n  * The return value is the disposition of the chunk.\n *\/\n-sctp_disposition_t sctp_sf_tabort_8_4_8(const struct sctp_endpoint *ep,\n+static sctp_disposition_t sctp_sf_tabort_8_4_8(const struct sctp_endpoint *ep,\n \t\t\t\t\tconst struct sctp_association *asoc,\n \t\t\t\t\tconst sctp_subtype_t type,\n \t\t\t\t\tvoid *arg,\n@@ -3126,14 +3149,14 @@ sctp_disposition_t sctp_sf_ootb(const struct sctp_endpoint *ep,\n \n \tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n \tdo {\n-\t\t\/* Break out if chunk length is less then minimal. *\/\n+\t\t\/* Report violation if the chunk is less then minimal *\/\n \t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n-\t\t\tbreak;\n-\n-\t\tch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n-\t\tif (ch_end > skb_tail_pointer(skb))\n-\t\t\tbreak;\n+\t\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n \n+\t\t\/* Now that we know we at least have a chunk header,\n+\t\t * do things that are type appropriate.\n+\t\t *\/\n \t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n \t\t\tootb_shut_ack = 1;\n \n@@ -3145,6 +3168,12 @@ sctp_disposition_t sctp_sf_ootb(const struct sctp_endpoint *ep,\n \t\tif (SCTP_CID_ABORT == ch->type)\n \t\t\treturn sctp_sf_pdiscard(ep, asoc, type, arg, commands);\n \n+\t\t\/* Report violation if chunk len overflows *\/\n+\t\tch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n+\t\tif (ch_end > skb_tail_pointer(skb))\n+\t\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n+\n \t\tch = (sctp_chunkhdr_t *) ch_end;\n \t} while (ch_end < skb_tail_pointer(skb));\n \n@@ -3244,6 +3273,13 @@ sctp_disposition_t sctp_sf_do_8_5_1_E_sa(const struct sctp_endpoint *ep,\n \t\t\t\t      void *arg,\n \t\t\t\t      sctp_cmd_seq_t *commands)\n {\n+\tstruct sctp_chunk *chunk = arg;\n+\n+\t\/* Make sure that the SHUTDOWN_ACK chunk has a valid length. *\/\n+\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n+\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n+\n \t\/* Although we do have an association in this case, it corresponds\n \t * to a restarted association. So the packet is treated as an OOTB\n \t * packet and the state function that handles OOTB SHUTDOWN_ACK is\n@@ -3658,6 +3694,16 @@ sctp_disposition_t sctp_sf_discard_chunk(const struct sctp_endpoint *ep,\n \t\t\t\t\t void *arg,\n \t\t\t\t\t sctp_cmd_seq_t *commands)\n {\n+\tstruct sctp_chunk *chunk = arg;\n+\n+\t\/* Make sure that the chunk has a valid length.\n+\t * Since we don't know the chunk type, we use a general\n+\t * chunkhdr structure to make a comparison.\n+\t *\/\n+\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n+\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n+\n \tSCTP_DEBUG_PRINTK(\"Chunk %d is discarded\\n\", type.chunk);\n \treturn SCTP_DISPOSITION_DISCARD;\n }\n@@ -3713,6 +3759,13 @@ sctp_disposition_t sctp_sf_violation(const struct sctp_endpoint *ep,\n \t\t\t\t     void *arg,\n \t\t\t\t     sctp_cmd_seq_t *commands)\n {\n+\tstruct sctp_chunk *chunk = arg;\n+\n+\t\/* Make sure that the chunk has a valid length. *\/\n+\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n+\t\treturn sctp_sf_violation_chunklen(ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n+\n \treturn SCTP_DISPOSITION_VIOLATION;\n }\n \n@@ -3720,12 +3773,14 @@ sctp_disposition_t sctp_sf_violation(const struct sctp_endpoint *ep,\n  * Common function to handle a protocol violation.\n  *\/\n static sctp_disposition_t sctp_sf_abort_violation(\n+\t\t\t\t     const struct sctp_endpoint *ep,\n \t\t\t\t     const struct sctp_association *asoc,\n \t\t\t\t     void *arg,\n \t\t\t\t     sctp_cmd_seq_t *commands,\n \t\t\t\t     const __u8 *payload,\n \t\t\t\t     const size_t paylen)\n {\n+\tstruct sctp_packet *packet = NULL;\n \tstruct sctp_chunk *chunk =  arg;\n \tstruct sctp_chunk *abort = NULL;\n \n@@ -3734,30 +3789,51 @@ static sctp_disposition_t sctp_sf_abort_violation(\n \tif (!abort)\n \t\tgoto nomem;\n \n-\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n-\tSCTP_INC_STATS(SCTP_MIB_OUTCTRLCHUNKS);\n+\tif (asoc) {\n+\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));\n+\t\tSCTP_INC_STATS(SCTP_MIB_OUTCTRLCHUNKS);\n \n-\tif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\n-\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n-\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n-\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n-\t\t\t\tSCTP_ERROR(ECONNREFUSED));\n-\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n-\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n+\t\tif (asoc->state <= SCTP_STATE_COOKIE_ECHOED) {\n+\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\n+\t\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n+\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n+\t\t\t\t\tSCTP_ERROR(ECONNREFUSED));\n+\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n+\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n+\t\t} else {\n+\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n+\t\t\t\t\tSCTP_ERROR(ECONNABORTED));\n+\t\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n+\t\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n+\t\t\tSCTP_DEC_STATS(SCTP_MIB_CURRESTAB);\n+\t\t}\n \t} else {\n-\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n-\t\t\t\tSCTP_ERROR(ECONNABORTED));\n-\t\tsctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,\n-\t\t\t\tSCTP_PERR(SCTP_ERROR_PROTO_VIOLATION));\n-\t\tSCTP_DEC_STATS(SCTP_MIB_CURRESTAB);\n+\t\tpacket = sctp_ootb_pkt_new(asoc, chunk);\n+\n+\t\tif (!packet)\n+\t\t\tgoto nomem_pkt;\n+\n+\t\tif (sctp_test_T_bit(abort))\n+\t\t\tpacket->vtag = ntohl(chunk->sctp_hdr->vtag);\n+\n+\t\tabort->skb->sk = ep->base.sk;\n+\n+\t\tsctp_packet_append_chunk(packet, abort);\n+\n+\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT,\n+\t\t\tSCTP_PACKET(packet));\n+\n+\t\tSCTP_INC_STATS(SCTP_MIB_OUTCTRLCHUNKS);\n \t}\n \n-\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\n+\tsctp_sf_pdiscard(ep, asoc, SCTP_ST_CHUNK(0), arg, commands);\n \n \tSCTP_INC_STATS(SCTP_MIB_ABORTEDS);\n \n \treturn SCTP_DISPOSITION_ABORT;\n \n+nomem_pkt:\n+\tsctp_chunk_free(abort);\n nomem:\n \treturn SCTP_DISPOSITION_NOMEM;\n }\n@@ -3790,7 +3866,7 @@ static sctp_disposition_t sctp_sf_violation_chunklen(\n {\n \tchar err_str[]=\"The following chunk had invalid length:\";\n \n-\treturn sctp_sf_abort_violation(asoc, arg, commands, err_str,\n+\treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n \t\t\t\t\tsizeof(err_str));\n }\n \n@@ -3809,10 +3885,31 @@ static sctp_disposition_t sctp_sf_violation_ctsn(\n {\n \tchar err_str[]=\"The cumulative tsn ack beyond the max tsn currently sent:\";\n \n-\treturn sctp_sf_abort_violation(asoc, arg, commands, err_str,\n+\treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n \t\t\t\t\tsizeof(err_str));\n }\n \n+\/* Handle protocol violation of an invalid chunk bundling.  For example,\n+ * when we have an association and we recieve bundled INIT-ACK, or\n+ * SHUDOWN-COMPLETE, our peer is clearly violationg the \"MUST NOT bundle\"\n+ * statement from the specs.  Additinally, there might be an attacker\n+ * on the path and we may not want to continue this communication.\n+ *\/\n+static sctp_disposition_t sctp_sf_violation_chunk(\n+\t\t\t\t     const struct sctp_endpoint *ep,\n+\t\t\t\t     const struct sctp_association *asoc,\n+\t\t\t\t     const sctp_subtype_t type,\n+\t\t\t\t     void *arg,\n+\t\t\t\t     sctp_cmd_seq_t *commands)\n+{\n+\tchar err_str[]=\"The following chunk violates protocol:\";\n+\n+\tif (!asoc)\n+\t\treturn sctp_sf_violation(ep, asoc, type, arg, commands);\n+\n+\treturn sctp_sf_abort_violation(ep, asoc, arg, commands, err_str,\n+\t\t\t\t\tsizeof(err_str));\n+}\n \/***************************************************************************\n  * These are the state functions for handling primitive (Section 10) events.\n  ***************************************************************************\/\ndiff --git a\/net\/sctp\/sm_statetable.c b\/net\/sctp\/sm_statetable.c\nindex 70a91ece3c49..ddb0ba3974b0 100644\n--- a\/net\/sctp\/sm_statetable.c\n+++ b\/net\/sctp\/sm_statetable.c\n@@ -110,7 +110,7 @@ const sctp_sm_table_entry_t *sctp_sm_lookup_event(sctp_event_t event_type,\n \t\/* SCTP_STATE_EMPTY *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_CLOSED *\/ \\\n-\tTYPE_SCTP_FUNC(sctp_sf_tabort_8_4_8), \\\n+\tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_COOKIE_WAIT *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_discard_chunk), \\\n \t\/* SCTP_STATE_COOKIE_ECHOED *\/ \\\n@@ -173,7 +173,7 @@ const sctp_sm_table_entry_t *sctp_sm_lookup_event(sctp_event_t event_type,\n \t\/*  SCTP_STATE_EMPTY *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_CLOSED *\/ \\\n-\tTYPE_SCTP_FUNC(sctp_sf_tabort_8_4_8), \\\n+\tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_COOKIE_WAIT *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_discard_chunk), \\\n \t\/* SCTP_STATE_COOKIE_ECHOED *\/ \\\n@@ -194,7 +194,7 @@ const sctp_sm_table_entry_t *sctp_sm_lookup_event(sctp_event_t event_type,\n \t\/*  SCTP_STATE_EMPTY *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_CLOSED *\/ \\\n-\tTYPE_SCTP_FUNC(sctp_sf_tabort_8_4_8), \\\n+\tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_COOKIE_WAIT *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_discard_chunk), \\\n \t\/* SCTP_STATE_COOKIE_ECHOED *\/ \\\n@@ -216,7 +216,7 @@ const sctp_sm_table_entry_t *sctp_sm_lookup_event(sctp_event_t event_type,\n \t\/*  SCTP_STATE_EMPTY *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_CLOSED *\/ \\\n-\tTYPE_SCTP_FUNC(sctp_sf_tabort_8_4_8), \\\n+\tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_COOKIE_WAIT *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_violation), \\\n \t\/* SCTP_STATE_COOKIE_ECHOED *\/ \\\n@@ -258,7 +258,7 @@ const sctp_sm_table_entry_t *sctp_sm_lookup_event(sctp_event_t event_type,\n \t\/* SCTP_STATE_EMPTY *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_CLOSED *\/ \\\n-\tTYPE_SCTP_FUNC(sctp_sf_tabort_8_4_8), \\\n+\tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_COOKIE_WAIT *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_discard_chunk), \\\n \t\/* SCTP_STATE_COOKIE_ECHOED *\/ \\\n@@ -300,7 +300,7 @@ const sctp_sm_table_entry_t *sctp_sm_lookup_event(sctp_event_t event_type,\n \t\/* SCTP_STATE_EMPTY *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_CLOSED *\/ \\\n-\tTYPE_SCTP_FUNC(sctp_sf_tabort_8_4_8), \\\n+\tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_COOKIE_WAIT *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_discard_chunk), \\\n \t\/* SCTP_STATE_COOKIE_ECHOED *\/ \\\n@@ -499,7 +499,7 @@ static const sctp_sm_table_entry_t addip_chunk_event_table[SCTP_NUM_ADDIP_CHUNK_\n \t\/* SCTP_STATE_EMPTY *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_CLOSED *\/ \\\n-\tTYPE_SCTP_FUNC(sctp_sf_tabort_8_4_8), \\\n+\tTYPE_SCTP_FUNC(sctp_sf_ootb), \\\n \t\/* SCTP_STATE_COOKIE_WAIT *\/ \\\n \tTYPE_SCTP_FUNC(sctp_sf_discard_chunk), \\\n \t\/* SCTP_STATE_COOKIE_ECHOED *\/ \\\n@@ -528,7 +528,7 @@ chunk_event_table_unknown[SCTP_STATE_NUM_STATES] = {\n \t\/* SCTP_STATE_EMPTY *\/\n \tTYPE_SCTP_FUNC(sctp_sf_ootb),\n \t\/* SCTP_STATE_CLOSED *\/\n-\tTYPE_SCTP_FUNC(sctp_sf_tabort_8_4_8),\n+\tTYPE_SCTP_FUNC(sctp_sf_ootb),\n \t\/* SCTP_STATE_COOKIE_WAIT *\/\n \tTYPE_SCTP_FUNC(sctp_sf_unk_chunk),\n \t\/* SCTP_STATE_COOKIE_ECHOED *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2014-3673","CWE_ID":"399","category":"security","commit_id":"9de7922bc709eee2f609cd01d98aaedc4cf5ea74","commit_message":"From 9de7922bc709eee2f609cd01d98aaedc4cf5ea74 Mon Sep 17 00:00:00 2001\nFrom: Daniel Borkmann <dborkman@redhat.com>\nDate: Thu, 9 Oct 2014 22:55:31 +0200\nSubject: [PATCH] net: sctp: fix skb_over_panic when receiving malformed ASCONF\n chunks\n\nCommit 6f4c618ddb0 (\"SCTP : Add paramters validity check for\nASCONF chunk\") added basic verification of ASCONF chunks, however,\nit is still possible to remotely crash a server by sending a\nspecial crafted ASCONF chunk, even up to pre 2.6.12 kernels:\n\nskb_over_panic: text:ffffffffa01ea1c3 len:31056 put:30768\n head:ffff88011bd81800 data:ffff88011bd81800 tail:0x7950\n end:0x440 dev:<NULL>\n ------------[ cut here ]------------\nkernel BUG at net\/core\/skbuff.c:129!\n[...]\nCall Trace:\n <IRQ>\n [<ffffffff8144fb1c>] skb_put+0x5c\/0x70\n [<ffffffffa01ea1c3>] sctp_addto_chunk+0x63\/0xd0 [sctp]\n [<ffffffffa01eadaf>] sctp_process_asconf+0x1af\/0x540 [sctp]\n [<ffffffff8152d025>] ? _read_unlock_bh+0x15\/0x20\n [<ffffffffa01e0038>] sctp_sf_do_asconf+0x168\/0x240 [sctp]\n [<ffffffffa01e3751>] sctp_do_sm+0x71\/0x1210 [sctp]\n [<ffffffff8147645d>] ? fib_rules_lookup+0xad\/0xf0\n [<ffffffffa01e6b22>] ? sctp_cmp_addr_exact+0x32\/0x40 [sctp]\n [<ffffffffa01e8393>] sctp_assoc_bh_rcv+0xd3\/0x180 [sctp]\n [<ffffffffa01ee986>] sctp_inq_push+0x56\/0x80 [sctp]\n [<ffffffffa01fcc42>] sctp_rcv+0x982\/0xa10 [sctp]\n [<ffffffffa01d5123>] ? ipt_local_in_hook+0x23\/0x28 [iptable_filter]\n [<ffffffff8148bdc9>] ? nf_iterate+0x69\/0xb0\n [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0\/0x2d0\n [<ffffffff8148bf86>] ? nf_hook_slow+0x76\/0x120\n [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0\/0x2d0\n [<ffffffff81496ded>] ip_local_deliver_finish+0xdd\/0x2d0\n [<ffffffff81497078>] ip_local_deliver+0x98\/0xa0\n [<ffffffff8149653d>] ip_rcv_finish+0x12d\/0x440\n [<ffffffff81496ac5>] ip_rcv+0x275\/0x350\n [<ffffffff8145c88b>] __netif_receive_skb+0x4ab\/0x750\n [<ffffffff81460588>] netif_receive_skb+0x58\/0x60\n\nThis can be triggered e.g., through a simple scripted nmap\nconnection scan injecting the chunk after the handshake, for\nexample, ...\n\n  -------------- INIT[ASCONF; ASCONF_ACK] ------------->\n  <----------- INIT-ACK[ASCONF; ASCONF_ACK] ------------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n  ------------------ ASCONF; UNKNOWN ------------------>\n\n... where ASCONF chunk of length 280 contains 2 parameters ...\n\n  1) Add IP address parameter (param length: 16)\n  2) Add\/del IP address parameter (param length: 255)\n\n... followed by an UNKNOWN chunk of e.g. 4 bytes. Here, the\nAddress Parameter in the ASCONF chunk is even missing, too.\nThis is just an example and similarly-crafted ASCONF chunks\ncould be used just as well.\n\nThe ASCONF chunk passes through sctp_verify_asconf() as all\nparameters passed sanity checks, and after walking, we ended\nup successfully at the chunk end boundary, and thus may invoke\nsctp_process_asconf(). Parameter walking is done with\nWORD_ROUND() to take padding into account.\n\nIn sctp_process_asconf()'s TLV processing, we may fail in\nsctp_process_asconf_param() e.g., due to removal of the IP\naddress that is also the source address of the packet containing\nthe ASCONF chunk, and thus we need to add all TLVs after the\nfailure to our ASCONF response to remote via helper function\nsctp_add_asconf_response(), which basically invokes a\nsctp_addto_chunk() adding the error parameters to the given\nskb.\n\nWhen walking to the next parameter this time, we proceed\nwith ...\n\n  length = ntohs(asconf_param->param_hdr.length);\n  asconf_param = (void *)asconf_param + length;\n\n... instead of the WORD_ROUND()'ed length, thus resulting here\nin an off-by-one that leads to reading the follow-up garbage\nparameter length of 12336, and thus throwing an skb_over_panic\nfor the reply when trying to sctp_addto_chunk() next time,\nwhich implicitly calls the skb_put() with that length.\n\nFix it by using sctp_walk_params() [ which is also used in\nINIT parameter processing ] macro in the verification *and*\nin ASCONF processing: it will make sure we don't spill over,\nthat we walk parameters WORD_ROUND()'ed. Moreover, we're being\nmore defensive and guard against unknown parameter types and\nmissized addresses.\n\nJoint work with Vlad Yasevich.\n\nFixes: b896b82be4ae (\"[SCTP] ADDIP: Support for processing incoming ASCONF_ACK chunks.\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: Vlad Yasevich <vyasevich@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/sctp\/sm.h    |  6 +--\n net\/sctp\/sm_make_chunk.c | 99 ++++++++++++++++++++++------------------\n net\/sctp\/sm_statefuns.c  | 18 +-------\n 3 files changed, 60 insertions(+), 63 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/sctp\/sm.h b\/include\/net\/sctp\/sm.h\nindex 7f4eeb340a54a..72a31db47ded2 100644\n--- a\/include\/net\/sctp\/sm.h\n+++ b\/include\/net\/sctp\/sm.h\n@@ -248,9 +248,9 @@ struct sctp_chunk *sctp_make_asconf_update_ip(struct sctp_association *,\n \t\t\t\t\t      int, __be16);\n struct sctp_chunk *sctp_make_asconf_set_prim(struct sctp_association *asoc,\n \t\t\t\t\t     union sctp_addr *addr);\n-int sctp_verify_asconf(const struct sctp_association *asoc,\n-\t\t       struct sctp_paramhdr *param_hdr, void *chunk_end,\n-\t\t       struct sctp_paramhdr **errp);\n+bool sctp_verify_asconf(const struct sctp_association *asoc,\n+\t\t\tstruct sctp_chunk *chunk, bool addr_param_needed,\n+\t\t\tstruct sctp_paramhdr **errp);\n struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n \t\t\t\t       struct sctp_chunk *asconf);\n int sctp_process_asconf_ack(struct sctp_association *asoc,\ndiff --git a\/net\/sctp\/sm_make_chunk.c b\/net\/sctp\/sm_make_chunk.c\nindex ae0e616a7ca5e..ab734be8cb209 100644\n--- a\/net\/sctp\/sm_make_chunk.c\n+++ b\/net\/sctp\/sm_make_chunk.c\n@@ -3110,50 +3110,63 @@ static __be16 sctp_process_asconf_param(struct sctp_association *asoc,\n \treturn SCTP_ERROR_NO_ERROR;\n }\n \n-\/* Verify the ASCONF packet before we process it.  *\/\n-int sctp_verify_asconf(const struct sctp_association *asoc,\n-\t\t       struct sctp_paramhdr *param_hdr, void *chunk_end,\n-\t\t       struct sctp_paramhdr **errp) {\n-\tsctp_addip_param_t *asconf_param;\n+\/* Verify the ASCONF packet before we process it. *\/\n+bool sctp_verify_asconf(const struct sctp_association *asoc,\n+\t\t\tstruct sctp_chunk *chunk, bool addr_param_needed,\n+\t\t\tstruct sctp_paramhdr **errp)\n+{\n+\tsctp_addip_chunk_t *addip = (sctp_addip_chunk_t *) chunk->chunk_hdr;\n \tunion sctp_params param;\n-\tint length, plen;\n-\n-\tparam.v = (sctp_paramhdr_t *) param_hdr;\n-\twhile (param.v <= chunk_end - sizeof(sctp_paramhdr_t)) {\n-\t\tlength = ntohs(param.p->length);\n-\t\t*errp = param.p;\n+\tbool addr_param_seen = false;\n \n-\t\tif (param.v > chunk_end - length ||\n-\t\t    length < sizeof(sctp_paramhdr_t))\n-\t\t\treturn 0;\n+\tsctp_walk_params(param, addip, addip_hdr.params) {\n+\t\tsize_t length = ntohs(param.p->length);\n \n+\t\t*errp = param.p;\n \t\tswitch (param.p->type) {\n+\t\tcase SCTP_PARAM_ERR_CAUSE:\n+\t\t\tbreak;\n+\t\tcase SCTP_PARAM_IPV4_ADDRESS:\n+\t\t\tif (length != sizeof(sctp_ipv4addr_param_t))\n+\t\t\t\treturn false;\n+\t\t\taddr_param_seen = true;\n+\t\t\tbreak;\n+\t\tcase SCTP_PARAM_IPV6_ADDRESS:\n+\t\t\tif (length != sizeof(sctp_ipv6addr_param_t))\n+\t\t\t\treturn false;\n+\t\t\taddr_param_seen = true;\n+\t\t\tbreak;\n \t\tcase SCTP_PARAM_ADD_IP:\n \t\tcase SCTP_PARAM_DEL_IP:\n \t\tcase SCTP_PARAM_SET_PRIMARY:\n-\t\t\tasconf_param = (sctp_addip_param_t *)param.v;\n-\t\t\tplen = ntohs(asconf_param->param_hdr.length);\n-\t\t\tif (plen < sizeof(sctp_addip_param_t) +\n-\t\t\t    sizeof(sctp_paramhdr_t))\n-\t\t\t\treturn 0;\n+\t\t\t\/* In ASCONF chunks, these need to be first. *\/\n+\t\t\tif (addr_param_needed && !addr_param_seen)\n+\t\t\t\treturn false;\n+\t\t\tlength = ntohs(param.addip->param_hdr.length);\n+\t\t\tif (length < sizeof(sctp_addip_param_t) +\n+\t\t\t\t     sizeof(sctp_paramhdr_t))\n+\t\t\t\treturn false;\n \t\t\tbreak;\n \t\tcase SCTP_PARAM_SUCCESS_REPORT:\n \t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n \t\t\tif (length != sizeof(sctp_addip_param_t))\n-\t\t\t\treturn 0;\n-\n+\t\t\t\treturn false;\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\tbreak;\n+\t\t\t\/* This is unkown to us, reject! *\/\n+\t\t\treturn false;\n \t\t}\n-\n-\t\tparam.v += WORD_ROUND(length);\n \t}\n \n-\tif (param.v != chunk_end)\n-\t\treturn 0;\n+\t\/* Remaining sanity checks. *\/\n+\tif (addr_param_needed && !addr_param_seen)\n+\t\treturn false;\n+\tif (!addr_param_needed && addr_param_seen)\n+\t\treturn false;\n+\tif (param.v != chunk->chunk_end)\n+\t\treturn false;\n \n-\treturn 1;\n+\treturn true;\n }\n \n \/* Process an incoming ASCONF chunk with the next expected serial no. and\n@@ -3162,16 +3175,17 @@ int sctp_verify_asconf(const struct sctp_association *asoc,\n struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n \t\t\t\t       struct sctp_chunk *asconf)\n {\n+\tsctp_addip_chunk_t *addip = (sctp_addip_chunk_t *) asconf->chunk_hdr;\n+\tbool all_param_pass = true;\n+\tunion sctp_params param;\n \tsctp_addiphdr_t\t\t*hdr;\n \tunion sctp_addr_param\t*addr_param;\n \tsctp_addip_param_t\t*asconf_param;\n \tstruct sctp_chunk\t*asconf_ack;\n-\n \t__be16\terr_code;\n \tint\tlength = 0;\n \tint\tchunk_len;\n \t__u32\tserial;\n-\tint\tall_param_pass = 1;\n \n \tchunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n \thdr = (sctp_addiphdr_t *)asconf->skb->data;\n@@ -3199,9 +3213,14 @@ struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n \t\tgoto done;\n \n \t\/* Process the TLVs contained within the ASCONF chunk. *\/\n-\twhile (chunk_len > 0) {\n+\tsctp_walk_params(param, addip, addip_hdr.params) {\n+\t\t\/* Skip preceeding address parameters. *\/\n+\t\tif (param.p->type == SCTP_PARAM_IPV4_ADDRESS ||\n+\t\t    param.p->type == SCTP_PARAM_IPV6_ADDRESS)\n+\t\t\tcontinue;\n+\n \t\terr_code = sctp_process_asconf_param(asoc, asconf,\n-\t\t\t\t\t\t     asconf_param);\n+\t\t\t\t\t\t     param.addip);\n \t\t\/* ADDIP 4.1 A7)\n \t\t * If an error response is received for a TLV parameter,\n \t\t * all TLVs with no response before the failed TLV are\n@@ -3209,28 +3228,20 @@ struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n \t\t * the failed response are considered unsuccessful unless\n \t\t * a specific success indication is present for the parameter.\n \t\t *\/\n-\t\tif (SCTP_ERROR_NO_ERROR != err_code)\n-\t\t\tall_param_pass = 0;\n-\n+\t\tif (err_code != SCTP_ERROR_NO_ERROR)\n+\t\t\tall_param_pass = false;\n \t\tif (!all_param_pass)\n-\t\t\tsctp_add_asconf_response(asconf_ack,\n-\t\t\t\t\t\t asconf_param->crr_id, err_code,\n-\t\t\t\t\t\t asconf_param);\n+\t\t\tsctp_add_asconf_response(asconf_ack, param.addip->crr_id,\n+\t\t\t\t\t\t err_code, param.addip);\n \n \t\t\/* ADDIP 4.3 D11) When an endpoint receiving an ASCONF to add\n \t\t * an IP address sends an 'Out of Resource' in its response, it\n \t\t * MUST also fail any subsequent add or delete requests bundled\n \t\t * in the ASCONF.\n \t\t *\/\n-\t\tif (SCTP_ERROR_RSRC_LOW == err_code)\n+\t\tif (err_code == SCTP_ERROR_RSRC_LOW)\n \t\t\tgoto done;\n-\n-\t\t\/* Move to the next ASCONF param. *\/\n-\t\tlength = ntohs(asconf_param->param_hdr.length);\n-\t\tasconf_param = (void *)asconf_param + length;\n-\t\tchunk_len -= length;\n \t}\n-\n done:\n \tasoc->peer.addip_serial++;\n \ndiff --git a\/net\/sctp\/sm_statefuns.c b\/net\/sctp\/sm_statefuns.c\nindex c8f606324134e..bdea3dfbad31a 100644\n--- a\/net\/sctp\/sm_statefuns.c\n+++ b\/net\/sctp\/sm_statefuns.c\n@@ -3591,9 +3591,7 @@ sctp_disposition_t sctp_sf_do_asconf(struct net *net,\n \tstruct sctp_chunk\t*asconf_ack = NULL;\n \tstruct sctp_paramhdr\t*err_param = NULL;\n \tsctp_addiphdr_t\t\t*hdr;\n-\tunion sctp_addr_param\t*addr_param;\n \t__u32\t\t\tserial;\n-\tint\t\t\tlength;\n \n \tif (!sctp_vtag_verify(chunk, asoc)) {\n \t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPORT_BAD_TAG,\n@@ -3618,17 +3616,8 @@ sctp_disposition_t sctp_sf_do_asconf(struct net *net,\n \thdr = (sctp_addiphdr_t *)chunk->skb->data;\n \tserial = ntohl(hdr->serial);\n \n-\taddr_param = (union sctp_addr_param *)hdr->params;\n-\tlength = ntohs(addr_param->p.length);\n-\tif (length < sizeof(sctp_paramhdr_t))\n-\t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n-\t\t\t   (void *)addr_param, commands);\n-\n \t\/* Verify the ASCONF chunk before processing it. *\/\n-\tif (!sctp_verify_asconf(asoc,\n-\t\t\t    (sctp_paramhdr_t *)((void *)addr_param + length),\n-\t\t\t    (void *)chunk->chunk_end,\n-\t\t\t    &err_param))\n+\tif (!sctp_verify_asconf(asoc, chunk, true, &err_param))\n \t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n \t\t\t\t\t\t  (void *)err_param, commands);\n \n@@ -3745,10 +3734,7 @@ sctp_disposition_t sctp_sf_do_asconf_ack(struct net *net,\n \trcvd_serial = ntohl(addip_hdr->serial);\n \n \t\/* Verify the ASCONF-ACK chunk before processing it. *\/\n-\tif (!sctp_verify_asconf(asoc,\n-\t    (sctp_paramhdr_t *)addip_hdr->params,\n-\t    (void *)asconf_ack->chunk_end,\n-\t    &err_param))\n+\tif (!sctp_verify_asconf(asoc, asconf_ack, false, &err_param))\n \t\treturn sctp_sf_violation_paramlen(net, ep, asoc, type, arg,\n \t\t\t   (void *)err_param, commands);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-2806","CWE_ID":"399","category":"security","commit_id":"c06da1ad34663da7b6fc39b030dc3ae185b96557","commit_message":"From c06da1ad34663da7b6fc39b030dc3ae185b96557 Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Thu, 5 Aug 2010 23:15:26 +0200\nSubject: Fix Savannah bug #30656.\n\n* src\/type42\/t42parse.c (t42_parse_sfnts): Protect against negative\nstring_size.\nFix comparison.\n---\n ChangeLog             |  8 ++++++++\n src\/type42\/t42parse.c | 13 ++++++++++---\n 2 files changed, 18 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex b042fc9..4235ffb 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,11 @@\n+2010-08-05  Werner Lemberg  <wl@gnu.org>\n+\n+\tFix Savannah bug #30656.\n+\n+\t* src\/type42\/t42parse.c (t42_parse_sfnts): Protect against negative\n+\tstring_size.\n+\tFix comparison.\n+\n 2010-08-05  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>\n \n \t[cff] Don't use any values in decoder after parsing error.\ndiff --git a\/src\/type42\/t42parse.c b\/src\/type42\/t42parse.c\nindex 4dc7203..5774269 100644\n--- a\/src\/type42\/t42parse.c\n+++ b\/src\/type42\/t42parse.c\n@@ -4,7 +4,7 @@\n \/*                                                                         *\/\n \/*    Type 42 font parser (body).                                          *\/\n \/*                                                                         *\/\n-\/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by            *\/\n+\/*  Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 by      *\/\n \/*  Roberto Alameda.                                                       *\/\n \/*                                                                         *\/\n \/*  This file is part of the FreeType project, and may only be used,       *\/\n@@ -577,6 +577,12 @@\n         }\n \n         string_size = T1_ToInt( parser );\n+        if ( string_size < 0 )\n+        {\n+          FT_ERROR(( \"t42_parse_sfnts: invalid string size\\n\" ));\n+          error = T42_Err_Invalid_File_Format;\n+          goto Fail;\n+        }\n \n         T1_Skip_PS_Token( parser );             \/* `RD' *\/\n         if ( parser->root.error )\n@@ -584,13 +590,14 @@\n \n         string_buf = parser->root.cursor + 1;   \/* one space after `RD' *\/\n \n-        parser->root.cursor += string_size + 1;\n-        if ( parser->root.cursor >= limit )\n+        if ( limit - parser->root.cursor < string_size )\n         {\n           FT_ERROR(( \"t42_parse_sfnts: too many binary data\\n\" ));\n           error = T42_Err_Invalid_File_Format;\n           goto Fail;\n         }\n+        else\n+          parser->root.cursor += string_size + 1;\n       }\n \n       if ( !string_buf )\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10163","CWE_ID":"399","category":"security","commit_id":"747a293ff6055203e529f083896b823e22523fe7","commit_message":"From 747a293ff6055203e529f083896b823e22523fe7 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Mon, 26 Dec 2016 21:23:43 -0500\nSubject: vrend: fix a leak in context create internal\n\nCreate a context more than once causes memory leak issue.\nJuest return if the context exists.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n src\/vrend_decode.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/src\/vrend_decode.c b\/src\/vrend_decode.c\nindex 409cec7..ede7280 100644\n--- a\/src\/vrend_decode.c\n+++ b\/src\/vrend_decode.c\n@@ -1045,6 +1045,10 @@ void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen,\n    if (handle >= VREND_MAX_CTX)\n       return;\n \n+   dctx = dec_ctx[handle];\n+   if (dctx)\n+      return;\n+\n    dctx = malloc(sizeof(struct vrend_decode_ctx));\n    if (!dctx)\n       return;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-2179","CWE_ID":"399","category":"security","commit_id":"f5c7f5dfbaf0d2f7d946d0fe86f08e6bcb36ed0d","commit_message":"From f5c7f5dfbaf0d2f7d946d0fe86f08e6bcb36ed0d Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Thu, 30 Jun 2016 13:17:08 +0100\nSubject: [PATCH] Fix DTLS buffered message DoS attack\n\nDTLS can handle out of order record delivery. Additionally since\nhandshake messages can be bigger than will fit into a single packet, the\nmessages can be fragmented across multiple records (as with normal TLS).\nThat means that the messages can arrive mixed up, and we have to\nreassemble them. We keep a queue of buffered messages that are \"from the\nfuture\", i.e. messages we're not ready to deal with yet but have arrived\nearly. The messages held there may not be full yet - they could be one\nor more fragments that are still in the process of being reassembled.\n\nThe code assumes that we will eventually complete the reassembly and\nwhen that occurs the complete message is removed from the queue at the\npoint that we need to use it.\n\nHowever, DTLS is also tolerant of packet loss. To get around that DTLS\nmessages can be retransmitted. If we receive a full (non-fragmented)\nmessage from the peer after previously having received a fragment of\nthat message, then we ignore the message in the queue and just use the\nnon-fragmented version. At that point the queued message will never get\nremoved.\n\nAdditionally the peer could send \"future\" messages that we never get to\nin order to complete the handshake. Each message has a sequence number\n(starting from 0). We will accept a message fragment for the current\nmessage sequence number, or for any sequence up to 10 into the future.\nHowever if the Finished message has a sequence number of 2, anything\ngreater than that in the queue is just left there.\n\nSo, in those two ways we can end up with \"orphaned\" data in the queue\nthat will never get removed - except when the connection is closed. At\nthat point all the queues are flushed.\n\nAn attacker could seek to exploit this by filling up the queues with\nlots of large messages that are never going to be used in order to\nattempt a DoS by memory exhaustion.\n\nI will assume that we are only concerned with servers here. It does not\nseem reasonable to be concerned about a memory exhaustion attack on a\nclient. They are unlikely to process enough connections for this to be\nan issue.\n\nA \"long\" handshake with many messages might be 5 messages long (in the\nincoming direction), e.g. ClientHello, Certificate, ClientKeyExchange,\nCertificateVerify, Finished. So this would be message sequence numbers 0\nto 4. Additionally we can buffer up to 10 messages in the future.\nTherefore the maximum number of messages that an attacker could send\nthat could get orphaned would typically be 15.\n\nThe maximum size that a DTLS message is allowed to be is defined by\nmax_cert_list, which by default is 100k. Therefore the maximum amount of\n\"orphaned\" memory per connection is 1500k.\n\nMessage sequence numbers get reset after the Finished message, so\nrenegotiation will not extend the maximum number of messages that can be\norphaned per connection.\n\nAs noted above, the queues do get cleared when the connection is closed.\nTherefore in order to mount an effective attack, an attacker would have\nto open many simultaneous connections.\n\nIssue reported by Quan Luo.\n\nCVE-2016-2179\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\n---\n ssl\/d1_lib.c             | 15 ++++++++++++++-\n ssl\/ssl_locl.h           |  3 ++-\n ssl\/statem\/statem_dtls.c | 32 ++++++++++++++++----------------\n ssl\/statem\/statem_lib.c  |  1 +\n ssl\/statem\/statem_srvr.c |  4 ++--\n 5 files changed, 35 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/ssl\/d1_lib.c b\/ssl\/d1_lib.c\nindex 7fb9b96d1d..0ada7edf77 100644\n--- a\/ssl\/d1_lib.c\n+++ b\/ssl\/d1_lib.c\n@@ -114,6 +114,12 @@ int dtls1_new(SSL *s)\n }\n \n static void dtls1_clear_queues(SSL *s)\n+{\n+    dtls1_clear_received_buffer(s);\n+    dtls1_clear_sent_buffer(s);\n+}\n+\n+void dtls1_clear_received_buffer(SSL *s)\n {\n     pitem *item = NULL;\n     hm_fragment *frag = NULL;\n@@ -123,6 +129,12 @@ static void dtls1_clear_queues(SSL *s)\n         dtls1_hm_fragment_free(frag);\n         pitem_free(item);\n     }\n+}\n+\n+void dtls1_clear_sent_buffer(SSL *s)\n+{\n+    pitem *item = NULL;\n+    hm_fragment *frag = NULL;\n \n     while ((item = pqueue_pop(s->d1->sent_messages)) != NULL) {\n         frag = (hm_fragment *)item->data;\n@@ -131,6 +143,7 @@ static void dtls1_clear_queues(SSL *s)\n     }\n }\n \n+\n void dtls1_free(SSL *s)\n {\n     DTLS_RECORD_LAYER_free(&s->rlayer);\n@@ -325,7 +338,7 @@ void dtls1_stop_timer(SSL *s)\n     BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,\n              &(s->d1->next_timeout));\n     \/* Clear retransmission buffer *\/\n-    dtls1_clear_record_buffer(s);\n+    dtls1_clear_sent_buffer(s);\n }\n \n int dtls1_check_timeout_num(SSL *s)\ndiff --git a\/ssl\/ssl_locl.h b\/ssl\/ssl_locl.h\nindex 6fba98325a..4079b31637 100644\n--- a\/ssl\/ssl_locl.h\n+++ b\/ssl\/ssl_locl.h\n@@ -1923,7 +1923,8 @@ __owur int dtls1_buffer_message(SSL *s, int ccs);\n __owur int dtls1_retransmit_message(SSL *s, unsigned short seq, int *found);\n __owur int dtls1_get_queue_priority(unsigned short seq, int is_ccs);\n int dtls1_retransmit_buffered_messages(SSL *s);\n-void dtls1_clear_record_buffer(SSL *s);\n+void dtls1_clear_received_buffer(SSL *s);\n+void dtls1_clear_sent_buffer(SSL *s);\n void dtls1_get_message_header(unsigned char *data,\n                               struct hm_header_st *msg_hdr);\n __owur long dtls1_default_timeout(void);\ndiff --git a\/ssl\/statem\/statem_dtls.c b\/ssl\/statem\/statem_dtls.c\nindex 46843ce0fc..de2de09796 100644\n--- a\/ssl\/statem\/statem_dtls.c\n+++ b\/ssl\/statem\/statem_dtls.c\n@@ -442,11 +442,23 @@ static int dtls1_retrieve_buffered_fragment(SSL *s, int *ok)\n     int al;\n \n     *ok = 0;\n-    item = pqueue_peek(s->d1->buffered_messages);\n-    if (item == NULL)\n-        return 0;\n \n-    frag = (hm_fragment *)item->data;\n+    do {\n+        item = pqueue_peek(s->d1->buffered_messages);\n+        if (item == NULL)\n+            return 0;\n+\n+        frag = (hm_fragment *)item->data;\n+\n+        if (frag->msg_header.seq < s->d1->handshake_read_seq) {\n+            \/* This is a stale message that has been buffered so clear it *\/\n+            pqueue_pop(s->d1->buffered_messages);\n+            dtls1_hm_fragment_free(frag);\n+            pitem_free(item);\n+            item = NULL;\n+            frag = NULL;\n+        }\n+    } while (item == NULL);\n \n     \/* Don't return if reassembly still in progress *\/\n     if (frag->reassembly != NULL)\n@@ -1117,18 +1129,6 @@ int dtls1_retransmit_message(SSL *s, unsigned short seq, int *found)\n     return ret;\n }\n \n-\/* call this function when the buffered messages are no longer needed *\/\n-void dtls1_clear_record_buffer(SSL *s)\n-{\n-    pitem *item;\n-\n-    for (item = pqueue_pop(s->d1->sent_messages);\n-         item != NULL; item = pqueue_pop(s->d1->sent_messages)) {\n-        dtls1_hm_fragment_free((hm_fragment *)item->data);\n-        pitem_free(item);\n-    }\n-}\n-\n void dtls1_set_message_header(SSL *s,\n                               unsigned char mt, unsigned long len,\n                               unsigned long frag_off, unsigned long frag_len)\ndiff --git a\/ssl\/statem\/statem_lib.c b\/ssl\/statem\/statem_lib.c\nindex fac9684ce2..19b75a7ac7 100644\n--- a\/ssl\/statem\/statem_lib.c\n+++ b\/ssl\/statem\/statem_lib.c\n@@ -331,6 +331,7 @@ WORK_STATE tls_finish_handshake(SSL *s, WORK_STATE wst)\n             s->d1->handshake_read_seq = 0;\n             s->d1->handshake_write_seq = 0;\n             s->d1->next_handshake_write_seq = 0;\n+            dtls1_clear_received_buffer(s);\n         }\n     }\n \ndiff --git a\/ssl\/statem\/statem_srvr.c b\/ssl\/statem\/statem_srvr.c\nindex ae1c65d9ae..95dcc9b60b 100644\n--- a\/ssl\/statem\/statem_srvr.c\n+++ b\/ssl\/statem\/statem_srvr.c\n@@ -433,13 +433,13 @@ WORK_STATE ossl_statem_server_pre_work(SSL *s, WORK_STATE wst)\n     case TLS_ST_SW_HELLO_REQ:\n         s->shutdown = 0;\n         if (SSL_IS_DTLS(s))\n-            dtls1_clear_record_buffer(s);\n+            dtls1_clear_sent_buffer(s);\n         break;\n \n     case DTLS_ST_SW_HELLO_VERIFY_REQUEST:\n         s->shutdown = 0;\n         if (SSL_IS_DTLS(s)) {\n-            dtls1_clear_record_buffer(s);\n+            dtls1_clear_sent_buffer(s);\n             \/* We don't buffer this message so don't use the timer *\/\n             st->use_timer = 0;\n         }\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-2491","CWE_ID":"399","category":"security","commit_id":"0b760113a3a155269a3fba93a409c640031dd68f","commit_message":"From 0b760113a3a155269a3fba93a409c640031dd68f Mon Sep 17 00:00:00 2001\nFrom: Trond Myklebust <Trond.Myklebust@netapp.com>\nDate: Tue, 31 May 2011 15:15:34 -0400\nSubject: [PATCH] NLM: Don't hang forever on NLM unlock requests\n\nIf the NLM daemon is killed on the NFS server, we can currently end up\nhanging forever on an 'unlock' request, instead of aborting. Basically,\nif the rpcbind request fails, or the server keeps returning garbage, we\nreally want to quit instead of retrying.\n\nTested-by: Vasily Averin <vvs@sw.ru>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nCc: stable@kernel.org\n---\n fs\/lockd\/clntproc.c          | 8 +++++++-\n include\/linux\/sunrpc\/sched.h | 3 ++-\n net\/sunrpc\/clnt.c            | 3 +++\n net\/sunrpc\/sched.c           | 1 +\n 4 files changed, 13 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/lockd\/clntproc.c b\/fs\/lockd\/clntproc.c\nindex adb45ec9038cc..e374050a911c6 100644\n--- a\/fs\/lockd\/clntproc.c\n+++ b\/fs\/lockd\/clntproc.c\n@@ -708,7 +708,13 @@ static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n \n \tif (task->tk_status < 0) {\n \t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n-\t\tgoto retry_rebind;\n+\t\tswitch (task->tk_status) {\n+\t\tcase -EACCES:\n+\t\tcase -EIO:\n+\t\t\tgoto die;\n+\t\tdefault:\n+\t\t\tgoto retry_rebind;\n+\t\t}\n \t}\n \tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n \t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\ndiff --git a\/include\/linux\/sunrpc\/sched.h b\/include\/linux\/sunrpc\/sched.h\nindex f73c482ec9c60..fe2d8e6b923b4 100644\n--- a\/include\/linux\/sunrpc\/sched.h\n+++ b\/include\/linux\/sunrpc\/sched.h\n@@ -84,7 +84,8 @@ struct rpc_task {\n #endif\n \tunsigned char\t\ttk_priority : 2,\/* Task priority *\/\n \t\t\t\ttk_garb_retry : 2,\n-\t\t\t\ttk_cred_retry : 2;\n+\t\t\t\ttk_cred_retry : 2,\n+\t\t\t\ttk_rebind_retry : 2;\n };\n #define tk_xprt\t\t\ttk_client->cl_xprt\n \ndiff --git a\/net\/sunrpc\/clnt.c b\/net\/sunrpc\/clnt.c\nindex b84d7395535e7..566bcfd067f67 100644\n--- a\/net\/sunrpc\/clnt.c\n+++ b\/net\/sunrpc\/clnt.c\n@@ -1175,6 +1175,9 @@ call_bind_status(struct rpc_task *task)\n \t\t\tstatus = -EOPNOTSUPP;\n \t\t\tbreak;\n \t\t}\n+\t\tif (task->tk_rebind_retry == 0)\n+\t\t\tbreak;\n+\t\ttask->tk_rebind_retry--;\n \t\trpc_delay(task, 3*HZ);\n \t\tgoto retry_timeout;\n \tcase -ETIMEDOUT:\ndiff --git a\/net\/sunrpc\/sched.c b\/net\/sunrpc\/sched.c\nindex 6b43ee7221d5a..a27406b1654f1 100644\n--- a\/net\/sunrpc\/sched.c\n+++ b\/net\/sunrpc\/sched.c\n@@ -792,6 +792,7 @@ static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *ta\n \t\/* Initialize retry counters *\/\n \ttask->tk_garb_retry = 2;\n \ttask->tk_cred_retry = 2;\n+\ttask->tk_rebind_retry = 2;\n \n \ttask->tk_priority = task_setup_data->priority - RPC_PRIORITY_LOW;\n \ttask->tk_owner = current->tgid;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-15033","CWE_ID":"399","category":"security","commit_id":"ef8f40689ac452398026c07da41656a7c87e4683","commit_message":"From ef8f40689ac452398026c07da41656a7c87e4683 Mon Sep 17 00:00:00 2001\nFrom: root <356986351@qq.com>\nDate: Thu, 14 Sep 2017 13:44:34 +0000\nSubject: [PATCH] fix multiple memory leak in ReadYUVImage\n\n---\n coders\/yuv.c | 14 ++++++++++++--\n 1 file changed, 12 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/coders\/yuv.c b\/coders\/yuv.c\nindex a203ea7681..6eeac3d557 100644\n--- a\/coders\/yuv.c\n+++ b\/coders\/yuv.c\n@@ -211,7 +211,10 @@ static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n       horizontal_factor,(image->rows+vertical_factor-1)\/vertical_factor,\n       MagickTrue,exception);\n     if (chroma_image == (Image *) NULL)\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      {\n+        scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n+        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      }\n     \/*\n       Convert raster image to pixel packets.\n     *\/\n@@ -227,6 +230,7 @@ static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n         if (status == MagickFalse)\n           {\n+            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n             image=DestroyImageList(image);\n             return((Image *) NULL);\n           }\n@@ -353,6 +357,7 @@ static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n         if (status == MagickFalse)\n           {\n+            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n             image=DestroyImageList(image);\n             return((Image *) NULL);\n           }\n@@ -399,6 +404,7 @@ static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n           if (status == MagickFalse)\n             {\n+              scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n               image=DestroyImageList(image);\n               return((Image *) NULL);\n             }\n@@ -442,7 +448,10 @@ static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n       TriangleFilter,exception);\n     chroma_image=DestroyImage(chroma_image);\n     if (resize_image == (Image *) NULL)\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      {\n+        scanline=(unsigned char *) RelinquishMagickMemory(scanline);   \n+        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      }\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n@@ -491,6 +500,7 @@ static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         AcquireNextImage(image_info,image,exception);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n+            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n             image=DestroyImageList(image);\n             return((Image *) NULL);\n           }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2014-9620","CWE_ID":"399","category":"security","commit_id":"ce90e05774dd77d86cfc8dfa6da57b32816841c4","commit_message":"From ce90e05774dd77d86cfc8dfa6da57b32816841c4 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Tue, 16 Dec 2014 23:18:40 +0000\nSubject: [PATCH] - Add a limit to the number of ELF notes processed (Suggested\n by Alexander   Cherepanov) - Restructure ELF note printing so that we don't\n print the same message   multiple times on repeated notes of the same kind.\n\n---\n ChangeLog        |   5 +\n doc\/file.man     |   5 +-\n doc\/libmagic.man |  13 +-\n src\/apprentice.c |   3 +-\n src\/elfclass.h   |  16 +-\n src\/file.c       |   3 +-\n src\/file.h       |   4 +-\n src\/file_opts.h  |   1 +\n src\/magic.c      |   8 +-\n src\/magic.h.in   |   1 +\n src\/readelf.c    | 431 +++++++++++++++++++++++++++--------------------\n 11 files changed, 292 insertions(+), 198 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex d8b5fb342..7e501baa3 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,8 @@\n+2014-12-16  18:10  Christos Zoulas <christos@zoulas.com>\n+\t\n+\t* restructure elf note printing to avoid repeated messages\n+\t* add note limit, suggested by Alexander Cherepanov\n+\n 2014-12-16  16:53  Christos Zoulas <christos@zoulas.com>\n \t\n \t* Bail out on partial pread()'s (Alexander Cherepanov)\ndiff --git a\/doc\/file.man b\/doc\/file.man\nindex 52eb035f6..07b32db52 100644\n--- a\/doc\/file.man\n+++ b\/doc\/file.man\n@@ -1,5 +1,5 @@\n-.\\\" $File: file.man,v 1.109 2014\/11\/28 02:35:05 christos Exp $\n-.Dd November 27, 2014\n+.\\\" $File: file.man,v 1.110 2014\/11\/28 02:46:39 christos Exp $\n+.Dd December 16, 2014\n .Dt FILE __CSECTION__\n .Os\n .Sh NAME\n@@ -310,6 +310,7 @@ Set various parameter limits.\n .It Sy \"Name\" Ta Sy \"Default\" Ta Sy \"Explanation\"\n .It Li indir Ta 15 Ta recursion limit for indirect magic\n .It Li name Ta 30 Ta use count limit for name\/use magic\n+.It Li elf_notes Ta 256 Ta max ELF notes processed\n .It Li elf_phnum Ta 128 Ta max ELF program sections processed\n .It Li elf_shnum Ta 32768 Ta max ELF sections processed\n .El\ndiff --git a\/doc\/libmagic.man b\/doc\/libmagic.man\nindex 9fdd20808..6f3792e0e 100644\n--- a\/doc\/libmagic.man\n+++ b\/doc\/libmagic.man\n@@ -1,4 +1,4 @@\n-.\\\" $File: libmagic.man,v 1.32 2014\/11\/28 02:35:05 christos Exp $\n+.\\\" $File: libmagic.man,v 1.33 2014\/11\/28 02:46:39 christos Exp $\n .\\\"\n .\\\" Copyright (c) Christos Zoulas 2003.\n .\\\" All Rights Reserved.\n@@ -25,7 +25,7 @@\n .\\\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n .\\\" SUCH DAMAGE.\n .\\\"\n-.Dd November 27, 2014\n+.Dd December 16, 2014\n .Dt LIBMAGIC 3\n .Os\n .Sh NAME\n@@ -284,6 +284,7 @@ library.\n .It Sy \"Parameter\" Ta Sy \"Type\" Ta Sy \"Default\"\n .It Li MAGIC_PARAM_INDIR_MAX Ta size_t Ta 15\n .It Li MAGIC_PARAM_NAME_MAX Ta size_t Ta 30\n+.It Li MAGIC_PARAM_ELF_NOTES_MAX Ta size_t Ta 256\n .It Li MAGIC_PARAM_ELF_PHNUM_MAX Ta size_t Ta 128\n .It Li MAGIC_PARAM_ELF_SHNUM_MAX Ta size_t Ta 32768\n .El\n@@ -303,12 +304,16 @@ The\n parameter controls the maximum number of calls for name\/use.\n .Pp\n The\n+.Dv MAGIC_PARAM_NOTES_MAX\n+parameter controls how many ELF notes will be processed.\n+.Pp\n+The\n .Dv MAGIC_PARAM_PHNUM_MAX\n-parameter controls how many elf program sections will be processed.\n+parameter controls how many ELF program sections will be processed.\n .Pp\n The\n .Dv MAGIC_PARAM_SHNUM_MAX\n-parameter controls how many elf sections will be processed.\n+parameter controls how many ELF sections will be processed.\n .Pp\n The\n .Fn magic_version\ndiff --git a\/src\/apprentice.c b\/src\/apprentice.c\nindex 58a27ec14..ac098263b 100644\n--- a\/src\/apprentice.c\n+++ b\/src\/apprentice.c\n@@ -32,7 +32,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: apprentice.c,v 1.226 2014\/11\/28 02:35:05 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: apprentice.c,v 1.227 2014\/11\/28 02:46:39 christos Exp $\")\n #endif\t\/* lint *\/\n \n #include \"magic.h\"\n@@ -528,6 +528,7 @@ file_ms_alloc(int flags)\n \tms->name_max = FILE_NAME_MAX;\n \tms->elf_shnum_max = FILE_ELF_SHNUM_MAX;\n \tms->elf_phnum_max = FILE_ELF_PHNUM_MAX;\n+\tms->elf_notes_max = FILE_ELF_NOTES_MAX;\n \treturn ms;\n free:\n \tfree(ms);\ndiff --git a\/src\/elfclass.h b\/src\/elfclass.h\nindex e144d1127..5360b0b55 100644\n--- a\/src\/elfclass.h\n+++ b\/src\/elfclass.h\n@@ -32,17 +32,18 @@\n \tswap = (u.c[sizeof(int32_t) - 1] + 1) != elfhdr.e_ident[EI_DATA];\n \n \ttype = elf_getu16(swap, elfhdr.e_type);\n+\tnotecount = ms->elf_notes_max;\n \tswitch (type) {\n #ifdef ELFCORE\n \tcase ET_CORE:\n \t\tphnum = elf_getu16(swap, elfhdr.e_phnum);\n \t\tif (phnum > ms->elf_phnum_max)\n-\t\t\treturn toomany(ms, \"program\", phnum);\n+\t\t\treturn toomany(ms, \"program headers\", phnum);\n \t\tflags |= FLAGS_IS_CORE;\n \t\tif (dophn_core(ms, clazz, swap, fd,\n \t\t    (off_t)elf_getu(swap, elfhdr.e_phoff), phnum,\n \t\t    (size_t)elf_getu16(swap, elfhdr.e_phentsize),\n-\t\t    fsize, &flags) == -1)\n+\t\t    fsize, &flags, &notecount) == -1)\n \t\t\treturn -1;\n \t\tbreak;\n #endif\n@@ -57,22 +58,25 @@\n \t\tif (dophn_exec(ms, clazz, swap, fd,\n \t\t    (off_t)elf_getu(swap, elfhdr.e_phoff), phnum,\n \t\t    (size_t)elf_getu16(swap, elfhdr.e_phentsize),\n-\t\t    fsize, &flags, shnum) == -1)\n+\t\t    fsize, shnum, &flags, &notecount) == -1)\n \t\t\treturn -1;\n \t\t\/*FALLTHROUGH*\/\n \tcase ET_REL:\n \t\tshnum = elf_getu16(swap, elfhdr.e_shnum);\n \t\tif (shnum > ms->elf_shnum_max)\n-\t\t\treturn toomany(ms, \"section\", shnum);\n+\t\t\treturn toomany(ms, \"section headers\", shnum);\n \t\tif (doshn(ms, clazz, swap, fd,\n \t\t    (off_t)elf_getu(swap, elfhdr.e_shoff), shnum,\n \t\t    (size_t)elf_getu16(swap, elfhdr.e_shentsize),\n-\t\t    fsize, &flags, elf_getu16(swap, elfhdr.e_machine),\n-\t\t    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)\n+\t\t    fsize, elf_getu16(swap, elfhdr.e_machine),\n+\t\t    (int)elf_getu16(swap, elfhdr.e_shstrndx),\n+\t\t    &flags, &notecount) == -1)\n \t\t\treturn -1;\n \t\tbreak;\n \n \tdefault:\n \t\tbreak;\n \t}\n+\tif (notecount == 0)\n+\t\treturn toomany(ms, \"notes\", ms->elf_notes_max);\n \treturn 1;\ndiff --git a\/src\/file.c b\/src\/file.c\nindex cabd4e1a7..f1312cfff 100644\n--- a\/src\/file.c\n+++ b\/src\/file.c\n@@ -32,7 +32,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: file.c,v 1.158 2014\/11\/28 02:35:05 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: file.c,v 1.159 2014\/11\/28 02:46:39 christos Exp $\")\n #endif\t\/* lint *\/\n \n #include \"magic.h\"\n@@ -125,6 +125,7 @@ private struct {\n \t{ \"name\",\tMAGIC_PARAM_NAME_MAX, 0 },\n \t{ \"elf_phnum\",\tMAGIC_PARAM_ELF_PHNUM_MAX, 0 },\n \t{ \"elf_shnum\",\tMAGIC_PARAM_ELF_SHNUM_MAX, 0 },\n+\t{ \"elf_notes\",\tMAGIC_PARAM_ELF_NOTES_MAX, 0 },\n };\n \n private char *progname;\t\t\/* used throughout \t\t*\/\ndiff --git a\/src\/file.h b\/src\/file.h\nindex 6d422a3cc..e977a2c4e 100644\n--- a\/src\/file.h\n+++ b\/src\/file.h\n@@ -27,7 +27,7 @@\n  *\/\n \/*\n  * file.h - definitions for file(1) program\n- * @(#)$File: file.h,v 1.161 2014\/12\/04 15:56:46 christos Exp $\n+ * @(#)$File: file.h,v 1.162 2014\/12\/11 12:34:24 christos Exp $\n  *\/\n \n #ifndef __file_h__\n@@ -407,10 +407,12 @@ struct magic_set {\n \tuint16_t name_max;\n \tuint16_t elf_shnum_max;\n \tuint16_t elf_phnum_max;\n+\tuint16_t elf_notes_max;\n #define\tFILE_INDIR_MAX\t\t\t15\n #define\tFILE_NAME_MAX\t\t\t30\n #define\tFILE_ELF_SHNUM_MAX\t\t32768\n #define\tFILE_ELF_PHNUM_MAX\t\t128\n+#define\tFILE_ELF_NOTES_MAX\t\t256\n };\n \n \/* Type for Unicode characters *\/\ndiff --git a\/src\/file_opts.h b\/src\/file_opts.h\nindex 130ca40aa..3286ac607 100644\n--- a\/src\/file_opts.h\n+++ b\/src\/file_opts.h\n@@ -46,6 +46,7 @@ OPT('p', \"preserve-date\", 0, \"        preserve access times on files\\n\")\n OPT('P', \"parameter\", 0, \"            set file engine parameter limits\\n\"\n     \"                               indir        15 recursion limit for indirection\\n\"\n     \"                               name         30 use limit for name\/use magic\\n\"\n+    \"                               elf_notes   256 max ELF notes processed\\n\"\n     \"                               elf_phnum   128 max ELF prog sections processed\\n\"\n     \"                               elf_shnum 32768 max ELF sections processed\\n\")\n OPT('r', \"raw\", 0, \"                  don't translate unprintable chars to \\\\ooo\\n\")\ndiff --git a\/src\/magic.c b\/src\/magic.c\nindex 1edd7f663..0c3371bf6 100644\n--- a\/src\/magic.c\n+++ b\/src\/magic.c\n@@ -33,7 +33,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: magic.c,v 1.89 2014\/11\/28 02:46:39 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: magic.c,v 1.90 2014\/12\/04 15:56:46 christos Exp $\")\n #endif\t\/* lint *\/\n \n #include \"magic.h\"\n@@ -554,6 +554,9 @@ magic_setparam(struct magic_set *ms, int param, const void *val)\n \tcase MAGIC_PARAM_ELF_SHNUM_MAX:\n \t\tms->elf_shnum_max = *(const size_t *)val;\n \t\treturn 0;\n+\tcase MAGIC_PARAM_ELF_NOTES_MAX:\n+\t\tms->elf_notes_max = *(const size_t *)val;\n+\t\treturn 0;\n \tdefault:\n \t\terrno = EINVAL;\n \t\treturn -1;\n@@ -576,6 +579,9 @@ magic_getparam(struct magic_set *ms, int param, void *val)\n \tcase MAGIC_PARAM_ELF_SHNUM_MAX:\n \t\t*(size_t *)val = ms->elf_shnum_max;\n \t\treturn 0;\n+\tcase MAGIC_PARAM_ELF_NOTES_MAX:\n+\t\t*(size_t *)val = ms->elf_notes_max;\n+\t\treturn 0;\n \tdefault:\n \t\terrno = EINVAL;\n \t\treturn -1;\ndiff --git a\/src\/magic.h.in b\/src\/magic.h.in\nindex 856478b68..0d4c5ce87 100644\n--- a\/src\/magic.h.in\n+++ b\/src\/magic.h.in\n@@ -107,6 +107,7 @@ int magic_errno(magic_t);\n #define MAGIC_PARAM_NAME_MAX\t\t1\n #define MAGIC_PARAM_ELF_PHNUM_MAX\t2\n #define MAGIC_PARAM_ELF_SHNUM_MAX\t3\n+#define MAGIC_PARAM_ELF_NOTES_MAX\t4\n \n int magic_setparam(magic_t, int, const void *);\n int magic_getparam(magic_t, int, void *);\ndiff --git a\/src\/readelf.c b\/src\/readelf.c\nindex 9d54fc973..8e50d7281 100644\n--- a\/src\/readelf.c\n+++ b\/src\/readelf.c\n@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.114 2014\/12\/11 14:19:36 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.115 2014\/12\/16 20:53:05 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -43,14 +43,14 @@ FILE_RCSID(\"@(#)$File: readelf.c,v 1.114 2014\/12\/11 14:19:36 christos Exp $\")\n \n #ifdef\tELFCORE\n private int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t,\n-    off_t, int *);\n+    off_t, int *, uint16_t *);\n #endif\n private int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t,\n-    off_t, int *, int);\n+    off_t, int, int *, uint16_t *);\n private int doshn(struct magic_set *, int, int, int, off_t, int, size_t,\n-    off_t, int *, int, int);\n+    off_t, int, int, int *, uint16_t *);\n private size_t donote(struct magic_set *, void *, size_t, size_t, int,\n-    int, size_t, int *);\n+    int, size_t, int *, uint16_t *);\n \n #define\tELF_ALIGN(a)\t((((a) + align - 1) \/ align) * align)\n \n@@ -67,7 +67,7 @@ private uint64_t getu64(int, uint64_t);\n private int\n toomany(struct magic_set *ms, const char *name, uint16_t num)\n {\n-\tif (file_printf(ms, \", too many %s header sections (%u)\", name, num\n+\tif (file_printf(ms, \", too many %s (%u)\", name, num\n \t    ) == -1)\n \t\treturn -1;\n \treturn 0;\n@@ -293,15 +293,19 @@ private const char os_style_names[][8] = {\n \t\"NetBSD\",\n };\n \n-#define FLAGS_DID_CORE\t\t0x01\n-#define FLAGS_DID_NOTE\t\t0x02\n-#define FLAGS_DID_BUILD_ID\t0x04\n-#define FLAGS_DID_CORE_STYLE\t0x08\n-#define FLAGS_IS_CORE\t\t0x10\n+#define FLAGS_DID_CORE\t\t\t0x001\n+#define FLAGS_DID_OS_NOTE\t\t0x002\n+#define FLAGS_DID_BUILD_ID\t\t0x004\n+#define FLAGS_DID_CORE_STYLE\t\t0x008\n+#define FLAGS_DID_NETBSD_PAX\t\t0x010\n+#define FLAGS_DID_NETBSD_MARCH\t\t0x020\n+#define FLAGS_DID_NETBSD_CMODEL\t\t0x040\n+#define FLAGS_DID_NETBSD_UNKNOWN\t0x080\n+#define FLAGS_IS_CORE\t\t\t0x100\n \n private int\n dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n-    int num, size_t size, off_t fsize, int *flags)\n+    int num, size_t size, off_t fsize, int *flags, uint16_t *notecount)\n {\n \tElf32_Phdr ph32;\n \tElf64_Phdr ph64;\n@@ -347,7 +351,7 @@ dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n \t\t\tif (offset >= (size_t)bufsize)\n \t\t\t\tbreak;\n \t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n-\t\t\t    clazz, swap, 4, flags);\n+\t\t\t    clazz, swap, 4, flags, notecount);\n \t\t\tif (offset == 0)\n \t\t\t\tbreak;\n \n@@ -477,133 +481,127 @@ do_note_freebsd_version(struct magic_set *ms, int swap, void *v)\n \t}\n }\n \n-private size_t\n-donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n-    int clazz, int swap, size_t align, int *flags)\n+private int\n+do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n+    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n+    size_t noff, size_t doff, int *flags)\n {\n-\tElf32_Nhdr nh32;\n-\tElf64_Nhdr nh64;\n-\tsize_t noff, doff;\n-#ifdef ELFCORE\n-\tint os_style = -1;\n-#endif\n-\tuint32_t namesz, descsz;\n-\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n-\tchar sbuf[512];\n-\n-\tif (xnh_sizeof + offset > size) {\n-\t\t\/*\n-\t\t * We're out of note headers.\n-\t\t *\/\n-\t\treturn xnh_sizeof + offset;\n-\t}\n-\n-\t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n-\toffset += xnh_sizeof;\n-\n-\tnamesz = xnh_namesz;\n-\tdescsz = xnh_descsz;\n-\tif ((namesz == 0) && (descsz == 0)) {\n-\t\t\/*\n-\t\t * We're out of note headers.\n-\t\t *\/\n-\t\treturn (offset >= size) ? offset : size;\n-\t}\n-\n-\tif (namesz & 0x80000000) {\n-\t    (void)file_printf(ms, \", bad note name size 0x%lx\",\n-\t\t(unsigned long)namesz);\n-\t    return 0;\n-\t}\n-\n-\tif (descsz & 0x80000000) {\n-\t    (void)file_printf(ms, \", bad note description size 0x%lx\",\n-\t\t(unsigned long)descsz);\n-\t    return 0;\n-\t}\n-\n-\n-\tnoff = offset;\n-\tdoff = ELF_ALIGN(offset + namesz);\n-\n-\tif (offset + namesz > size) {\n-\t\t\/*\n-\t\t * We're past the end of the buffer.\n-\t\t *\/\n-\t\treturn doff;\n-\t}\n-\n-\toffset = ELF_ALIGN(doff + descsz);\n-\tif (doff + descsz > size) {\n-\t\t\/*\n-\t\t * We're past the end of the buffer.\n-\t\t *\/\n-\t\treturn (offset >= size) ? offset : size;\n+\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n+\t    type == NT_GNU_BUILD_ID && (descsz == 16 || descsz == 20)) {\n+\t\tuint8_t desc[20];\n+\t\tuint32_t i;\n+\t\t*flags |= FLAGS_DID_BUILD_ID;\n+\t\tif (file_printf(ms, \", BuildID[%s]=\", descsz == 16 ? \"md5\/uuid\" :\n+\t\t    \"sha1\") == -1)\n+\t\t\treturn 1;\n+\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n+\t\tfor (i = 0; i < descsz; i++)\n+\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n+\t\t\treturn 1;\n+\t\treturn 1;\n \t}\n+\treturn 0;\n+}\n \n-\tif ((*flags & (FLAGS_DID_NOTE|FLAGS_DID_BUILD_ID)) ==\n-\t    (FLAGS_DID_NOTE|FLAGS_DID_BUILD_ID))\n-\t\tgoto core;\n-\n+private int\n+do_os_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n+    int swap, uint32_t namesz, uint32_t descsz,\n+    size_t noff, size_t doff, int *flags)\n+{\n \tif (namesz == 5 && strcmp((char *)&nbuf[noff], \"SuSE\") == 0 &&\n-\t    xnh_type == NT_GNU_VERSION && descsz == 2) {\n+\t    type == NT_GNU_VERSION && descsz == 2) {\n+\t    *flags |= FLAGS_DID_OS_NOTE;\n \t    file_printf(ms, \", for SuSE %d.%d\", nbuf[doff], nbuf[doff + 1]);\n+\t    return 1;\n \t}\n+\n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n-\t    xnh_type == NT_GNU_VERSION && descsz == 16) {\n+\t    type == NT_GNU_VERSION && descsz == 16) {\n \t\tuint32_t desc[4];\n \t\t(void)memcpy(desc, &nbuf[doff], sizeof(desc));\n \n+\t\t*flags |= FLAGS_DID_OS_NOTE;\n \t\tif (file_printf(ms, \", for GNU\/\") == -1)\n-\t\t\treturn size;\n+\t\t\treturn 1;\n \t\tswitch (elf_getu32(swap, desc[0])) {\n \t\tcase GNU_OS_LINUX:\n \t\t\tif (file_printf(ms, \"Linux\") == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\tbreak;\n \t\tcase GNU_OS_HURD:\n \t\t\tif (file_printf(ms, \"Hurd\") == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\tbreak;\n \t\tcase GNU_OS_SOLARIS:\n \t\t\tif (file_printf(ms, \"Solaris\") == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\tbreak;\n \t\tcase GNU_OS_KFREEBSD:\n \t\t\tif (file_printf(ms, \"kFreeBSD\") == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\tbreak;\n \t\tcase GNU_OS_KNETBSD:\n \t\t\tif (file_printf(ms, \"kNetBSD\") == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tif (file_printf(ms, \"<unknown>\") == -1)\n-\t\t\t\treturn size; \n+\t\t\t\treturn 1; \n \t\t}\n \t\tif (file_printf(ms, \" %d.%d.%d\", elf_getu32(swap, desc[1]),\n \t\t    elf_getu32(swap, desc[2]), elf_getu32(swap, desc[3])) == -1)\n-\t\t\treturn size;\n-\t\t*flags |= FLAGS_DID_NOTE;\n-\t\treturn size;\n+\t\t\treturn 1;\n+\t\treturn 1;\n \t}\n \n-\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n-\t    xnh_type == NT_GNU_BUILD_ID && (descsz == 16 || descsz == 20)) {\n-\t    uint8_t desc[20];\n-\t    uint32_t i;\n-\t    if (file_printf(ms, \", BuildID[%s]=\", descsz == 16 ? \"md5\/uuid\" :\n-\t\t\"sha1\") == -1)\n-\t\t    return size;\n-\t    (void)memcpy(desc, &nbuf[doff], descsz);\n-\t    for (i = 0; i < descsz; i++)\n-\t\tif (file_printf(ms, \"%02x\", desc[i]) == -1)\n-\t\t    return size;\n-\t    *flags |= FLAGS_DID_BUILD_ID;\n+\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n+\t    \tif (type == NT_NETBSD_VERSION && descsz == 4) {\n+\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n+\t\t\tdo_note_netbsd_version(ms, swap, &nbuf[doff]);\n+\t\t\treturn 1;\n+\t\t}\n+\t}\n+\n+\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0) {\n+\t    \tif (type == NT_FREEBSD_VERSION && descsz == 4) {\n+\t\t\t*flags |= FLAGS_DID_OS_NOTE;\n+\t\t\tdo_note_freebsd_version(ms, swap, &nbuf[doff]);\n+\t\t\treturn 1;\n+\t\t}\n \t}\n \n+\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"OpenBSD\") == 0 &&\n+\t    type == NT_OPENBSD_VERSION && descsz == 4) {\n+\t\t*flags |= FLAGS_DID_OS_NOTE;\n+\t\tif (file_printf(ms, \", for OpenBSD\") == -1)\n+\t\t\treturn 1;\n+\t\t\/* Content of note is always 0 *\/\n+\t\treturn 1;\n+\t}\n+\n+\tif (namesz == 10 && strcmp((char *)&nbuf[noff], \"DragonFly\") == 0 &&\n+\t    type == NT_DRAGONFLY_VERSION && descsz == 4) {\n+\t\tuint32_t desc;\n+\t\t*flags |= FLAGS_DID_OS_NOTE;\n+\t\tif (file_printf(ms, \", for DragonFly\") == -1)\n+\t\t\treturn 1;\n+\t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n+\t\tdesc = elf_getu32(swap, desc);\n+\t\tif (file_printf(ms, \" %d.%d.%d\", desc \/ 100000,\n+\t\t    desc \/ 10000 % 10, desc % 10000) == -1)\n+\t\t\treturn 1;\n+\t\treturn 1;\n+\t}\n+\treturn 0;\n+}\n+\n+private int\n+do_pax_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n+    int swap, uint32_t namesz, uint32_t descsz,\n+    size_t noff, size_t doff, int *flags)\n+{\n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"PaX\") == 0 &&\n-\t    xnh_type == NT_NETBSD_PAX && descsz == 4) {\n+\t    type == NT_NETBSD_PAX && descsz == 4) {\n \t\tstatic const char *pax[] = {\n \t\t    \"+mprotect\",\n \t\t    \"-mprotect\",\n@@ -616,80 +614,32 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\tsize_t i;\n \t\tint did = 0;\n \n+\t\t*flags |= FLAGS_DID_NETBSD_PAX;\n \t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n \t\tdesc = elf_getu32(swap, desc);\n \n \t\tif (desc && file_printf(ms, \", PaX: \") == -1)\n-\t\t\treturn size;\n+\t\t\treturn 1;\n \n \t\tfor (i = 0; i < __arraycount(pax); i++) {\n \t\t\tif (((1 << i) & desc) == 0)\n \t\t\t\tcontinue;\n \t\t\tif (file_printf(ms, \"%s%s\", did++ ? \",\" : \"\",\n \t\t\t    pax[i]) == -1)\n-\t\t\t\treturn size;\n-\t\t}\n-\t}\n-\n-\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n-\t\tswitch (xnh_type) {\n-\t\tcase NT_NETBSD_VERSION:\n-\t\t\tif (descsz == 4) {\n-\t\t\t\tdo_note_netbsd_version(ms, swap, &nbuf[doff]);\n-\t\t\t\t*flags |= FLAGS_DID_NOTE;\n-\t\t\t\treturn size;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase NT_NETBSD_MARCH:\n-\t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,\n-\t\t\t    (const char *)&nbuf[doff]) == -1)\n-\t\t\t\treturn size;\n-\t\t\tbreak;\n-\t\tcase NT_NETBSD_CMODEL:\n-\t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n-\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n-\t\t\t\treturn size;\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n-\t\t\t\treturn size;\n-\t\t\tbreak;\n-\t\t}\n-\t\treturn size;\n-\t}\n-\n-\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"FreeBSD\") == 0) {\n-\t    \tif (xnh_type == NT_FREEBSD_VERSION && descsz == 4) {\n-\t\t\tdo_note_freebsd_version(ms, swap, &nbuf[doff]);\n-\t\t\t*flags |= FLAGS_DID_NOTE;\n-\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t}\n+\t\treturn 1;\n \t}\n+\treturn 0;\n+}\n \n-\tif (namesz == 8 && strcmp((char *)&nbuf[noff], \"OpenBSD\") == 0 &&\n-\t    xnh_type == NT_OPENBSD_VERSION && descsz == 4) {\n-\t\tif (file_printf(ms, \", for OpenBSD\") == -1)\n-\t\t\treturn size;\n-\t\t\/* Content of note is always 0 *\/\n-\t\t*flags |= FLAGS_DID_NOTE;\n-\t\treturn size;\n-\t}\n-\n-\tif (namesz == 10 && strcmp((char *)&nbuf[noff], \"DragonFly\") == 0 &&\n-\t    xnh_type == NT_DRAGONFLY_VERSION && descsz == 4) {\n-\t\tuint32_t desc;\n-\t\tif (file_printf(ms, \", for DragonFly\") == -1)\n-\t\t\treturn size;\n-\t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n-\t\tdesc = elf_getu32(swap, desc);\n-\t\tif (file_printf(ms, \" %d.%d.%d\", desc \/ 100000,\n-\t\t    desc \/ 10000 % 10, desc % 10000) == -1)\n-\t\t\treturn size;\n-\t\t*flags |= FLAGS_DID_NOTE;\n-\t\treturn size;\n-\t}\n-\n-core:\n+private int\n+do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n+    int swap, uint32_t namesz, uint32_t descsz,\n+    size_t noff, size_t doff, int *flags, size_t size, int clazz)\n+{\n+#ifdef ELFCORE\n+\tint os_style = -1;\n \t\/*\n \t * Sigh.  The 2.0.36 kernel in Debian 2.1, at\n \t * least, doesn't correctly implement name\n@@ -718,20 +668,17 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\tos_style = OS_STYLE_NETBSD;\n \t}\n \n-#ifdef ELFCORE\n-\tif ((*flags & FLAGS_DID_CORE) != 0)\n-\t\treturn size;\n-\n \tif (os_style != -1 && (*flags & FLAGS_DID_CORE_STYLE) == 0) {\n \t\tif (file_printf(ms, \", %s-style\", os_style_names[os_style])\n \t\t    == -1)\n-\t\t\treturn size;\n+\t\t\treturn 1;\n \t\t*flags |= FLAGS_DID_CORE_STYLE;\n \t}\n \n \tswitch (os_style) {\n \tcase OS_STYLE_NETBSD:\n-\t\tif (xnh_type == NT_NETBSD_CORE_PROCINFO) {\n+\t\tif (type == NT_NETBSD_CORE_PROCINFO) {\n+\t\t\tchar sbuf[512];\n \t\t\tuint32_t signo;\n \t\t\t\/*\n \t\t\t * Extract the program name.  It is at\n@@ -741,7 +688,7 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\t\tif (file_printf(ms, \", from '%.31s'\",\n \t\t\t    file_printable(sbuf, sizeof(sbuf),\n \t\t\t    (const char *)&nbuf[doff + 0x7c])) == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\t\n \t\t\t\/*\n \t\t\t * Extract the signal number.  It is at\n@@ -751,14 +698,14 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\t\t    sizeof(signo));\n \t\t\tif (file_printf(ms, \" (signal %u)\",\n \t\t\t    elf_getu32(swap, signo)) == -1)\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \t\t\t*flags |= FLAGS_DID_CORE;\n-\t\t\treturn size;\n+\t\t\treturn 1;\n \t\t}\n \t\tbreak;\n \n \tdefault:\n-\t\tif (xnh_type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n+\t\tif (type == NT_PRPSINFO && *flags & FLAGS_IS_CORE) {\n \t\t\tsize_t i, j;\n \t\t\tunsigned char c;\n \t\t\t\/*\n@@ -826,7 +773,7 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\t\t\t * Try next offsets, in case this match is\n \t\t\t\t * in the middle of a string.\n \t\t\t\t *\/\n-\t\t\t\tfor (k = i + 1 ; k < NOFFSETS ; k++) {\n+\t\t\t\tfor (k = i + 1 ; k < NOFFSETS; k++) {\n \t\t\t\t\tsize_t no;\n \t\t\t\t\tint adjust = 1;\n \t\t\t\t\tif (prpsoffsets(k) >= prpsoffsets(i))\n@@ -851,9 +798,9 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\t\t\t\tcp--;\n \t\t\t\tif (file_printf(ms, \", from '%.*s'\",\n \t\t\t\t    (int)(cp - cname), cname) == -1)\n-\t\t\t\t\treturn size;\n+\t\t\t\t\treturn 1;\n \t\t\t\t*flags |= FLAGS_DID_CORE;\n-\t\t\t\treturn size;\n+\t\t\t\treturn 1;\n \n \t\t\ttryanother:\n \t\t\t\t;\n@@ -862,6 +809,124 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \t\tbreak;\n \t}\n #endif\n+\treturn 0;\n+}\n+\n+private size_t\n+donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n+    int clazz, int swap, size_t align, int *flags, uint16_t *notecount)\n+{\n+\tElf32_Nhdr nh32;\n+\tElf64_Nhdr nh64;\n+\tsize_t noff, doff;\n+\tuint32_t namesz, descsz;\n+\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n+\n+\tif (*notecount == 0)\n+\t\treturn 0;\n+\t--*notecount;\n+\n+\tif (xnh_sizeof + offset > size) {\n+\t\t\/*\n+\t\t * We're out of note headers.\n+\t\t *\/\n+\t\treturn xnh_sizeof + offset;\n+\t}\n+\n+\t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n+\toffset += xnh_sizeof;\n+\n+\tnamesz = xnh_namesz;\n+\tdescsz = xnh_descsz;\n+\tif ((namesz == 0) && (descsz == 0)) {\n+\t\t\/*\n+\t\t * We're out of note headers.\n+\t\t *\/\n+\t\treturn (offset >= size) ? offset : size;\n+\t}\n+\n+\tif (namesz & 0x80000000) {\n+\t    (void)file_printf(ms, \", bad note name size 0x%lx\",\n+\t\t(unsigned long)namesz);\n+\t    return 0;\n+\t}\n+\n+\tif (descsz & 0x80000000) {\n+\t    (void)file_printf(ms, \", bad note description size 0x%lx\",\n+\t\t(unsigned long)descsz);\n+\t    return 0;\n+\t}\n+\n+\tnoff = offset;\n+\tdoff = ELF_ALIGN(offset + namesz);\n+\n+\tif (offset + namesz > size) {\n+\t\t\/*\n+\t\t * We're past the end of the buffer.\n+\t\t *\/\n+\t\treturn doff;\n+\t}\n+\n+\toffset = ELF_ALIGN(doff + descsz);\n+\tif (doff + descsz > size) {\n+\t\t\/*\n+\t\t * We're past the end of the buffer.\n+\t\t *\/\n+\t\treturn (offset >= size) ? offset : size;\n+\t}\n+\n+\tif ((*flags & FLAGS_DID_OS_NOTE) == 0) {\n+\t\tif (do_os_note(ms, nbuf, xnh_type, swap,\n+\t\t    namesz, descsz, noff, doff, flags))\n+\t\t\treturn size;\n+\t}\n+\n+\tif ((*flags & FLAGS_DID_BUILD_ID) == 0) {\n+\t\tif (do_bid_note(ms, nbuf, xnh_type, swap,\n+\t\t    namesz, descsz, noff, doff, flags))\n+\t\t\treturn size;\n+\t}\n+\t\t\n+\tif ((*flags & FLAGS_DID_NETBSD_PAX) == 0) {\n+\t\tif (do_pax_note(ms, nbuf, xnh_type, swap,\n+\t\t    namesz, descsz, noff, doff, flags))\n+\t\t\treturn size;\n+\t}\n+\n+\tif ((*flags & FLAGS_DID_CORE) == 0) {\n+\t\tif (do_core_note(ms, nbuf, xnh_type, swap,\n+\t\t    namesz, descsz, noff, doff, flags, size, clazz))\n+\t\t\treturn size;\n+\t}\n+\n+\tif (namesz == 7 && strcmp((char *)&nbuf[noff], \"NetBSD\") == 0) {\n+\t\tswitch (xnh_type) {\n+\t    \tcase NT_NETBSD_VERSION:\n+\t\t\treturn size;\n+\t\tcase NT_NETBSD_MARCH:\n+\t\t\tif (*flags & FLAGS_DID_NETBSD_MARCH)\n+\t\t\t\treturn size;\n+\t\t\tif (file_printf(ms, \", compiled for: %.*s\", (int)descsz,\n+\t\t\t    (const char *)&nbuf[doff]) == -1)\n+\t\t\t\treturn size;\n+\t\t\tbreak;\n+\t\tcase NT_NETBSD_CMODEL:\n+\t\t\tif (*flags & FLAGS_DID_NETBSD_CMODEL)\n+\t\t\t\treturn size;\n+\t\t\tif (file_printf(ms, \", compiler model: %.*s\",\n+\t\t\t    (int)descsz, (const char *)&nbuf[doff]) == -1)\n+\t\t\t\treturn size;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tif (*flags & FLAGS_DID_NETBSD_UNKNOWN)\n+\t\t\t\treturn size;\n+\t\t\tif (file_printf(ms, \", note=%u\", xnh_type) == -1)\n+\t\t\t\treturn size;\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn size;\n+\t}\n+\n \treturn offset;\n }\n \n@@ -917,7 +982,8 @@ static const cap_desc_t cap_desc_386[] = {\n \n private int\n doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n-    size_t size, off_t fsize, int *flags, int mach, int strtab)\n+    size_t size, off_t fsize, int mach, int strtab, int *flags,\n+    uint16_t *notecount)\n {\n \tElf32_Shdr sh32;\n \tElf64_Shdr sh64;\n@@ -994,7 +1060,7 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \t\t\t\tif (noff >= (off_t)xsh_size)\n \t\t\t\t\tbreak;\n \t\t\t\tnoff = donote(ms, nbuf, (size_t)noff,\n-\t\t\t\t    xsh_size, clazz, swap, 4, flags);\n+\t\t\t\t    xsh_size, clazz, swap, 4, flags, notecount);\n \t\t\t\tif (noff == 0)\n \t\t\t\t\tbreak;\n \t\t\t}\n@@ -1161,7 +1227,8 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n  *\/\n private int\n dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n-    int num, size_t size, off_t fsize, int *flags, int sh_num)\n+    int num, size_t size, off_t fsize, int sh_num, int *flags,\n+    uint16_t *notecount)\n {\n \tElf32_Phdr ph32;\n \tElf64_Phdr ph64;\n@@ -1242,7 +1309,7 @@ dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n \t\t\t\t\tbreak;\n \t\t\t\toffset = donote(ms, nbuf, offset,\n \t\t\t\t    (size_t)bufsize, clazz, swap, align,\n-\t\t\t\t    flags);\n+\t\t\t\t    flags, notecount);\n \t\t\t\tif (offset == 0)\n \t\t\t\t\tbreak;\n \t\t\t}\n@@ -1277,7 +1344,7 @@ file_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,\n \tint flags = 0;\n \tElf32_Ehdr elf32hdr;\n \tElf64_Ehdr elf64hdr;\n-\tuint16_t type, phnum, shnum;\n+\tuint16_t type, phnum, shnum, notecount;\n \n \tif (ms->flags & (MAGIC_MIME|MAGIC_APPLE))\n \t\treturn 0;\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2017-9060","CWE_ID":"399","category":"security","commit_id":"dd248ed7e204ee8a1873914e02b8b526e8f1b80d","commit_message":"From dd248ed7e204ee8a1873914e02b8b526e8f1b80d Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Sat, 21 Jan 2017 23:42:33 -0800\nSubject: [PATCH] virtio-gpu: fix memory leak in set scanout\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nIn virtio_gpu_set_scanout function, when creating the 'rect'\nits refcount is set to 2, by pixman_image_create_bits and\nqemu_create_displaysurface_pixman function. This can lead\na memory leak issues. This patch avoid this issue.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nReviewed-by: Marc-Andr\u00c3\u00a9 Lureau <marcandre.lureau@redhat.com>\nMessage-id: 5884626f.5b2f6b0a.1bfff.3037@mx.google.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/display\/virtio-gpu.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/hw\/display\/virtio-gpu.c b\/hw\/display\/virtio-gpu.c\nindex 444ca06..9b530ab 100644\n--- a\/hw\/display\/virtio-gpu.c\n+++ b\/hw\/display\/virtio-gpu.c\n@@ -608,6 +608,7 @@ static void virtio_gpu_set_scanout(VirtIOGPU *g,\n             cmd->error = VIRTIO_GPU_RESP_ERR_UNSPEC;\n             return;\n         }\n+        pixman_image_unref(rect);\n         dpy_gfx_replace_surface(g->scanout[ss.scanout_id].con, scanout->ds);\n     }\n \n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-0716","CWE_ID":"399","category":"security","commit_id":"6b0d6a9b4296fa16a28d10d416db7a770fc03287","commit_message":"From 6b0d6a9b4296fa16a28d10d416db7a770fc03287 Mon Sep 17 00:00:00 2001\nFrom: Herbert Xu <herbert@gondor.apana.org.au>\nDate: Fri, 11 Feb 2011 12:36:55 +0000\nSubject: [PATCH] bridge: Fix mglist corruption that leads to memory corruption\n\nThe list mp->mglist is used to indicate whether a multicast group\nis active on the bridge interface itself as opposed to one of the\nconstituent interfaces in the bridge.\n\nUnfortunately the operation that adds the mp->mglist node to the\nlist neglected to check whether it has already been added.  This\nleads to list corruption in the form of nodes pointing to itself.\n\nNormally this would be quite obvious as it would cause an infinite\nloop when walking the list.  However, as this list is never actually\nwalked (which means that we don't really need it, I'll get rid of\nit in a subsequent patch), this instead is hidden until we perform\na delete operation on the affected nodes.\n\nAs the same node may now be pointed to by more than one node, the\ndelete operations can then cause modification of freed memory.\n\nThis was observed in practice to cause corruption in 512-byte slabs,\nmost commonly leading to crashes in jbd2.\n\nThanks to Josef Bacik for pointing me in the right direction.\n\nReported-by: Ian Page Hands <ihands@redhat.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/bridge\/br_multicast.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/bridge\/br_multicast.c b\/net\/bridge\/br_multicast.c\nindex f701a21acb340..fdbd41c76ec45 100644\n--- a\/net\/bridge\/br_multicast.c\n+++ b\/net\/bridge\/br_multicast.c\n@@ -719,7 +719,8 @@ static int br_multicast_add_group(struct net_bridge *br,\n \t\tgoto err;\n \n \tif (!port) {\n-\t\thlist_add_head(&mp->mglist, &br->mglist);\n+\t\tif (hlist_unhashed(&mp->mglist))\n+\t\t\thlist_add_head(&mp->mglist, &br->mglist);\n \t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n \t\tgoto out;\n \t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-4205","CWE_ID":"399","category":"security","commit_id":"6160968cee8b90a5dd95318d716e31d7775c4ef3","commit_message":"From 6160968cee8b90a5dd95318d716e31d7775c4ef3 Mon Sep 17 00:00:00 2001\nFrom: Oleg Nesterov <oleg@redhat.com>\nDate: Tue, 6 Aug 2013 19:38:55 +0200\nSubject: userns: unshare_userns(&cred) should not populate cred on failure\n\nunshare_userns(new_cred) does *new_cred = prepare_creds() before\ncreate_user_ns() which can fail. However, the caller expects that\nit doesn't need to take care of new_cred if unshare_userns() fails.\n\nWe could change the single caller, sys_unshare(), but I think it\nwould be more clean to avoid the side effects on failure, so with\nthis patch unshare_userns() does put_cred() itself and initializes\n*new_cred only if create_user_ns() succeeeds.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nReviewed-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/user_namespace.c | 13 +++++++++----\n 1 file changed, 9 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/user_namespace.c b\/kernel\/user_namespace.c\nindex d8c30db06c5b..6e50a44610ee 100644\n--- a\/kernel\/user_namespace.c\n+++ b\/kernel\/user_namespace.c\n@@ -105,16 +105,21 @@ int create_user_ns(struct cred *new)\n int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n {\n \tstruct cred *cred;\n+\tint err = -ENOMEM;\n \n \tif (!(unshare_flags & CLONE_NEWUSER))\n \t\treturn 0;\n \n \tcred = prepare_creds();\n-\tif (!cred)\n-\t\treturn -ENOMEM;\n+\tif (cred) {\n+\t\terr = create_user_ns(cred);\n+\t\tif (err)\n+\t\t\tput_cred(cred);\n+\t\telse\n+\t\t\t*new_cred = cred;\n+\t}\n \n-\t*new_cred = cred;\n-\treturn create_user_ns(cred);\n+\treturn err;\n }\n \n void free_user_ns(struct user_namespace *ns)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-1488","CWE_ID":"399","category":"security","commit_id":"b95c35e76b29ba812e5dabdd91592e25ec640e93","commit_message":"From b95c35e76b29ba812e5dabdd91592e25ec640e93 Mon Sep 17 00:00:00 2001\nFrom: Oleg Nesterov <oleg@redhat.com>\nDate: Thu, 1 Apr 2010 15:13:57 +0200\nSubject: oom: fix the unsafe usage of badness() in proc_oom_score()\n\nproc_oom_score(task) has a reference to task_struct, but that is all.\nIf this task was already released before we take tasklist_lock\n\n\t- we can't use task->group_leader, it points to nowhere\n\n\t- it is not safe to call badness() even if this task is\n\t  ->group_leader, has_intersects_mems_allowed() assumes\n\t  it is safe to iterate over ->thread_group list.\n\n\t- even worse, badness() can hit ->signal == NULL\n\nAdd the pid_alive() check to ensure __unhash_process() was not called.\n\nAlso, use \"task\" instead of task->group_leader. badness() should return\nthe same result for any sub-thread. Currently this is not true, but\nthis should be changed anyway.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/proc\/base.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/proc\/base.c b\/fs\/proc\/base.c\nindex a7310841c831..b1f6e62773d3 100644\n--- a\/fs\/proc\/base.c\n+++ b\/fs\/proc\/base.c\n@@ -442,12 +442,13 @@ static const struct file_operations proc_lstats_operations = {\n unsigned long badness(struct task_struct *p, unsigned long uptime);\n static int proc_oom_score(struct task_struct *task, char *buffer)\n {\n-\tunsigned long points;\n+\tunsigned long points = 0;\n \tstruct timespec uptime;\n \n \tdo_posix_clock_monotonic_gettime(&uptime);\n \tread_lock(&tasklist_lock);\n-\tpoints = badness(task->group_leader, uptime.tv_sec);\n+\tif (pid_alive(task))\n+\t\tpoints = badness(task, uptime.tv_sec);\n \tread_unlock(&tasklist_lock);\n \treturn sprintf(buffer, \"%lu\\n\", points);\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2018-7751","CWE_ID":"399","category":"security","commit_id":"a6cba062051f345e8ebfdff34aba071ed73d923f","commit_message":"From a6cba062051f345e8ebfdff34aba071ed73d923f Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sat, 10 Mar 2018 01:40:36 +0100\nSubject: [PATCH] avformat\/img2dec: fix infinite loop\n\nFixes: kira-poc\n\nFound-by: Kira <kira_cxy@foxmail.com>\nChange suggested by Kira\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/img2dec.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavformat\/img2dec.c b\/libavformat\/img2dec.c\nindex 62db0d9..f3f52c8 100644\n--- a\/libavformat\/img2dec.c\n+++ b\/libavformat\/img2dec.c\n@@ -878,10 +878,14 @@ static int svg_probe(AVProbeData *p)\n {\n     const uint8_t *b = p->buf;\n     const uint8_t *end = p->buf + p->buf_size;\n+\n     if (memcmp(p->buf, \"<?xml\", 5))\n         return 0;\n     while (b < end) {\n-        b += ff_subtitles_next_line(b);\n+        int inc = ff_subtitles_next_line(b);\n+        if (!inc)\n+            break;\n+        b += inc;\n         if (b >= end - 4)\n             return 0;\n         if (!memcmp(b, \"<svg\", 4))\n-- \n2.7.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7466","CWE_ID":"399","category":"security","commit_id":"b53dd4495ced2432a0b652ea895e651d07336f7e","commit_message":"From b53dd4495ced2432a0b652ea895e651d07336f7e Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Tue, 13 Sep 2016 03:20:03 -0700\nSubject: [PATCH] usb:xhci:fix memory leak in usb_xhci_exit\n\nIf the xhci uses msix, it doesn't free the corresponding\nmemory, thus leading a memory leak. This patch avoid this.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nMessage-id: 57d7d2e0.d4301c0a.d13e9.9a55@mx.google.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/usb\/hcd-xhci.c | 3 +--\n 1 file changed, 1 insertion(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/hw\/usb\/hcd-xhci.c b\/hw\/usb\/hcd-xhci.c\nindex 37c1493..726435c 100644\n--- a\/hw\/usb\/hcd-xhci.c\n+++ b\/hw\/usb\/hcd-xhci.c\n@@ -3715,8 +3715,7 @@ static void usb_xhci_exit(PCIDevice *dev)\n     \/* destroy msix memory region *\/\n     if (dev->msix_table && dev->msix_pba\n         && dev->msix_entry_used) {\n-        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n-        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n+        msix_uninit(dev, &xhci->mem, &xhci->mem);\n     }\n \n     usb_bus_release(&xhci->bus);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9438","CWE_ID":"399","category":"security","commit_id":"10e8bd3071677dd1fa76beeef4bc2fc427cea5e7","commit_message":"From 10e8bd3071677dd1fa76beeef4bc2fc427cea5e7 Mon Sep 17 00:00:00 2001\nFrom: Victor Manuel Alvarez\n <vmalvarez@vmalvarez-macbookpro.roam.corp.google.com>\nDate: Thu, 1 Jun 2017 16:10:05 +0200\nSubject: [PATCH] Fix issue #674 for hex strings.\n\n---\n libyara\/hex_grammar.c | 136 +++++++++++++++++++++++-------------------\n libyara\/hex_grammar.h |   4 +-\n libyara\/hex_grammar.y |  14 +++++\n 3 files changed, 91 insertions(+), 63 deletions(-)\n\n","diff_code":"diff --git a\/libyara\/hex_grammar.c b\/libyara\/hex_grammar.c\nindex a6cfbf06..48f550a5 100644\n--- a\/libyara\/hex_grammar.c\n+++ b\/libyara\/hex_grammar.c\n@@ -93,6 +93,13 @@\n #define mark_as_not_fast_regexp() \\\n     ((RE_AST*) yyget_extra(yyscanner))->flags &= ~RE_FLAGS_FAST_REGEXP\n \n+#define incr_ast_levels() \\\n+    if (((RE_AST*) yyget_extra(yyscanner))->levels++ > RE_MAX_AST_LEVELS) \\\n+    { \\\n+      lex_env->last_error_code = ERROR_INVALID_HEX_STRING; \\\n+      YYABORT; \\\n+    }\n+\n #define ERROR_IF(x, error) \\\n     if (x) \\\n     { \\\n@@ -107,7 +114,7 @@\n     } \\\n \n \n-#line 111 \"hex_grammar.c\" \/* yacc.c:339  *\/\n+#line 118 \"hex_grammar.c\" \/* yacc.c:339  *\/\n \n # ifndef YY_NULLPTR\n #  if defined __cplusplus && 201103L <= __cplusplus\n@@ -157,12 +164,12 @@ extern int hex_yydebug;\n \n union YYSTYPE\n {\n-#line 78 \"hex_grammar.y\" \/* yacc.c:355  *\/\n+#line 85 \"hex_grammar.y\" \/* yacc.c:355  *\/\n \n   int64_t integer;\n   RE_NODE *re_node;\n \n-#line 166 \"hex_grammar.c\" \/* yacc.c:355  *\/\n+#line 173 \"hex_grammar.c\" \/* yacc.c:355  *\/\n };\n \n typedef union YYSTYPE YYSTYPE;\n@@ -178,7 +185,7 @@ int hex_yyparse (void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env);\n \n \/* Copy the second part of user declarations.  *\/\n \n-#line 182 \"hex_grammar.c\" \/* yacc.c:358  *\/\n+#line 189 \"hex_grammar.c\" \/* yacc.c:358  *\/\n \n #ifdef short\n # undef short\n@@ -476,9 +483,9 @@ static const yytype_uint8 yytranslate[] =\n   \/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  *\/\n static const yytype_uint16 yyrline[] =\n {\n-       0,   105,   105,   114,   118,   127,   189,   193,   206,   210,\n-     219,   233,   232,   245,   268,   300,   322,   342,   346,   360,\n-     368\n+       0,   112,   112,   121,   125,   136,   200,   204,   219,   223,\n+     232,   246,   245,   258,   281,   313,   335,   355,   359,   374,\n+     382\n };\n #endif\n \n@@ -1017,45 +1024,45 @@ yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, H\n   switch (yytype)\n     {\n           case 16: \/* tokens  *\/\n-#line 94 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n+#line 101 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1023 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1030 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n     case 17: \/* token_sequence  *\/\n-#line 95 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n+#line 102 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1029 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1036 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n     case 18: \/* token_or_range  *\/\n-#line 96 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n+#line 103 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1035 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1042 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n     case 19: \/* token  *\/\n-#line 97 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n+#line 104 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1041 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1048 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n     case 21: \/* range  *\/\n-#line 100 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n+#line 107 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1047 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1054 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n     case 22: \/* alternatives  *\/\n-#line 99 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n+#line 106 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1053 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1060 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n     case 23: \/* byte  *\/\n-#line 98 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n+#line 105 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1059 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1066 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n \n@@ -1321,25 +1328,27 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n   switch (yyn)\n     {\n         case 2:\n-#line 106 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 113 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         RE_AST* re_ast = yyget_extra(yyscanner);\n         re_ast->root_node = (yyvsp[-1].re_node);\n       }\n-#line 1330 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1337 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 3:\n-#line 115 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 122 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         (yyval.re_node) = (yyvsp[0].re_node);\n       }\n-#line 1338 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1345 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 4:\n-#line 119 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 126 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n+        incr_ast_levels();\n+\n         (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));\n \n         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n@@ -1347,16 +1356,18 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1351 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1360 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 5:\n-#line 128 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 137 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         RE_NODE* new_concat;\n         RE_NODE* leftmost_concat = NULL;\n         RE_NODE* leftmost_node = (yyvsp[-1].re_node);\n \n+        incr_ast_levels();\n+\n         (yyval.re_node) = NULL;\n \n         \/*\n@@ -1409,20 +1420,22 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1413 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1424 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 6:\n-#line 190 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 201 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         (yyval.re_node) = (yyvsp[0].re_node);\n       }\n-#line 1421 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1432 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 7:\n-#line 194 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 205 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n+        incr_ast_levels();\n+\n         (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));\n \n         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n@@ -1430,28 +1443,28 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1434 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1447 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 8:\n-#line 207 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 220 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         (yyval.re_node) = (yyvsp[0].re_node);\n       }\n-#line 1442 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1455 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 9:\n-#line 211 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 224 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         (yyval.re_node) = (yyvsp[0].re_node);\n         (yyval.re_node)->greedy = FALSE;\n       }\n-#line 1451 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1464 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 10:\n-#line 220 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 233 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         lex_env->token_count++;\n \n@@ -1464,28 +1477,28 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.re_node) = (yyvsp[0].re_node);\n       }\n-#line 1468 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1481 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 11:\n-#line 233 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 246 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         lex_env->inside_or++;\n       }\n-#line 1476 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1489 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 12:\n-#line 237 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 250 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         (yyval.re_node) = (yyvsp[-1].re_node);\n         lex_env->inside_or--;\n       }\n-#line 1485 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1498 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 13:\n-#line 246 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 259 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         if ((yyvsp[-1].integer) <= 0)\n         {\n@@ -1508,11 +1521,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.re_node)->start = (int) (yyvsp[-1].integer);\n         (yyval.re_node)->end = (int) (yyvsp[-1].integer);\n       }\n-#line 1512 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1525 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 14:\n-#line 269 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 282 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         if (lex_env->inside_or &&\n             ((yyvsp[-3].integer) > STRING_CHAINING_THRESHOLD ||\n@@ -1544,11 +1557,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.re_node)->start = (int) (yyvsp[-3].integer);\n         (yyval.re_node)->end = (int) (yyvsp[-1].integer);\n       }\n-#line 1548 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1561 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 15:\n-#line 301 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 314 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         if (lex_env->inside_or)\n         {\n@@ -1570,11 +1583,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.re_node)->start = (int) (yyvsp[-2].integer);\n         (yyval.re_node)->end = INT_MAX;\n       }\n-#line 1574 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1587 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 16:\n-#line 323 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 336 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         if (lex_env->inside_or)\n         {\n@@ -1590,21 +1603,22 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.re_node)->start = 0;\n         (yyval.re_node)->end = INT_MAX;\n       }\n-#line 1594 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1607 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 17:\n-#line 343 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 356 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n           (yyval.re_node) = (yyvsp[0].re_node);\n       }\n-#line 1602 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1615 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 18:\n-#line 347 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 360 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         mark_as_not_fast_regexp();\n+        incr_ast_levels();\n \n         (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-2].re_node), (yyvsp[0].re_node));\n \n@@ -1613,11 +1627,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1617 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1631 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 19:\n-#line 361 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 375 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL, NULL, NULL);\n \n@@ -1625,11 +1639,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.re_node)->value = (int) (yyvsp[0].integer);\n       }\n-#line 1629 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1643 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n   case 20:\n-#line 369 \"hex_grammar.y\" \/* yacc.c:1646  *\/\n+#line 383 \"hex_grammar.y\" \/* yacc.c:1661  *\/\n     {\n         uint8_t mask = (uint8_t) ((yyvsp[0].integer) >> 8);\n \n@@ -1649,11 +1663,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.re_node)->mask = mask;\n         }\n       }\n-#line 1653 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1667 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n     break;\n \n \n-#line 1657 \"hex_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1671 \"hex_grammar.c\" \/* yacc.c:1661  *\/\n       default: break;\n     }\n   \/* User semantic actions sometimes alter yychar, and that requires\n@@ -1881,5 +1895,5 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n #endif\n   return yyresult;\n }\n-#line 390 \"hex_grammar.y\" \/* yacc.c:1906  *\/\n+#line 404 \"hex_grammar.y\" \/* yacc.c:1906  *\/\n \ndiff --git a\/libyara\/hex_grammar.h b\/libyara\/hex_grammar.h\nindex 31e7fe26..d37c1640 100644\n--- a\/libyara\/hex_grammar.h\n+++ b\/libyara\/hex_grammar.h\n@@ -60,12 +60,12 @@ extern int hex_yydebug;\n \n union YYSTYPE\n {\n-#line 78 \"hex_grammar.y\" \/* yacc.c:1909  *\/\n+#line 85 \"hex_grammar.y\" \/* yacc.c:1915  *\/\n \n   int64_t integer;\n   RE_NODE *re_node;\n \n-#line 69 \"hex_grammar.h\" \/* yacc.c:1909  *\/\n+#line 69 \"hex_grammar.h\" \/* yacc.c:1915  *\/\n };\n \n typedef union YYSTYPE YYSTYPE;\ndiff --git a\/libyara\/hex_grammar.y b\/libyara\/hex_grammar.y\nindex f42e0b1c..bf907e93 100644\n--- a\/libyara\/hex_grammar.y\n+++ b\/libyara\/hex_grammar.y\n@@ -51,6 +51,13 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n #define mark_as_not_fast_regexp() \\\n     ((RE_AST*) yyget_extra(yyscanner))->flags &= ~RE_FLAGS_FAST_REGEXP\n \n+#define incr_ast_levels() \\\n+    if (((RE_AST*) yyget_extra(yyscanner))->levels++ > RE_MAX_AST_LEVELS) \\\n+    { \\\n+      lex_env->last_error_code = ERROR_INVALID_HEX_STRING; \\\n+      YYABORT; \\\n+    }\n+\n #define ERROR_IF(x, error) \\\n     if (x) \\\n     { \\\n@@ -117,6 +124,8 @@ tokens\n       }\n     | token token\n       {\n+        incr_ast_levels();\n+\n         $$ = yr_re_node_create(RE_NODE_CONCAT, $1, $2);\n \n         DESTROY_NODE_IF($$ == NULL, $1);\n@@ -130,6 +139,8 @@ tokens\n         RE_NODE* leftmost_concat = NULL;\n         RE_NODE* leftmost_node = $2;\n \n+        incr_ast_levels();\n+\n         $$ = NULL;\n \n         \/*\n@@ -192,6 +203,8 @@ token_sequence\n       }\n     | token_sequence token_or_range\n       {\n+        incr_ast_levels();\n+\n         $$ = yr_re_node_create(RE_NODE_CONCAT, $1, $2);\n \n         DESTROY_NODE_IF($$ == NULL, $1);\n@@ -346,6 +359,7 @@ alternatives\n     | alternatives '|' tokens\n       {\n         mark_as_not_fast_regexp();\n+        incr_ast_levels();\n \n         $$ = yr_re_node_create(RE_NODE_ALT, $1, $3);\n \n","owner":"VirusTotal","repo":"yara","source":"cve"},{"CVE_ID":"CVE-2019-7397","CWE_ID":"399","category":"security","commit_id":"306c1f0fa5754ca78efd16ab752f0e981d4f6b82","commit_message":"From 306c1f0fa5754ca78efd16ab752f0e981d4f6b82 Mon Sep 17 00:00:00 2001\nFrom: Cristy <mikayla-grace@urban-warrior.org>\nDate: Sun, 20 Jan 2019 10:17:27 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1454\n\n---\n coders\/pdf.c | 26 +++++++++++++++++---------\n 1 file changed, 17 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/coders\/pdf.c b\/coders\/pdf.c\nindex 4c5708ee76..cf31b270a8 100644\n--- a\/coders\/pdf.c\n+++ b\/coders\/pdf.c\n@@ -1901,6 +1901,7 @@ RestoreMSCWarning\n             status=InjectImageBlob(image_info,image,image,\"jpeg\",exception);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -1911,6 +1912,7 @@ RestoreMSCWarning\n             status=InjectImageBlob(image_info,image,image,\"jp2\",exception);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -1964,6 +1966,7 @@ RestoreMSCWarning\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -2010,6 +2013,7 @@ RestoreMSCWarning\n             status=InjectImageBlob(image_info,image,image,\"jpeg\",exception);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -2020,6 +2024,7 @@ RestoreMSCWarning\n             status=InjectImageBlob(image_info,image,image,\"jp2\",exception);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -2038,10 +2043,7 @@ RestoreMSCWarning\n             length*=image->colorspace == CMYKColorspace ? 4UL : 3UL;\n             pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n             if (pixel_info == (MemoryInfo *) NULL)\n-              {\n-                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n-                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n-              }\n+              ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n             pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n             \/*\n               Dump runoffset encoded pixels.\n@@ -2081,6 +2083,7 @@ RestoreMSCWarning\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -2138,11 +2141,7 @@ RestoreMSCWarning\n               length=(size_t) number_pixels;\n               pixel_info=AcquireVirtualMemory(length,sizeof(*pixels));\n               if (pixel_info == (MemoryInfo *) NULL)\n-                {\n-                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n-                  ThrowPDFException(ResourceLimitError,\n-                    \"MemoryAllocationFailed\");\n-                }\n+                ThrowPDFException(ResourceLimitError,\"MemoryAllocationFailed\");\n               pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n               \/*\n                 Dump Runlength encoded pixels.\n@@ -2178,6 +2177,7 @@ RestoreMSCWarning\n               pixel_info=RelinquishVirtualMemory(pixel_info);\n               if (status == MagickFalse)\n                 {\n+                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                   (void) CloseBlob(image);\n                   return(MagickFalse);\n                 }\n@@ -2426,6 +2426,7 @@ RestoreMSCWarning\n               exception);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -2436,6 +2437,7 @@ RestoreMSCWarning\n             status=InjectImageBlob(image_info,image,tile_image,\"jp2\",exception);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -2487,6 +2489,7 @@ RestoreMSCWarning\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -2528,6 +2531,7 @@ RestoreMSCWarning\n               exception);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -2538,6 +2542,7 @@ RestoreMSCWarning\n             status=InjectImageBlob(image_info,image,tile_image,\"jp2\",exception);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -2593,6 +2598,7 @@ RestoreMSCWarning\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n@@ -2681,6 +2687,7 @@ RestoreMSCWarning\n               pixel_info=RelinquishVirtualMemory(pixel_info);\n               if (status == MagickFalse)\n                 {\n+                  xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                   (void) CloseBlob(image);\n                   return(MagickFalse);\n                 }\n@@ -2893,6 +2900,7 @@ RestoreMSCWarning\n             pixel_info=RelinquishVirtualMemory(pixel_info);\n             if (status == MagickFalse)\n               {\n+                xref=(MagickOffsetType *) RelinquishMagickMemory(xref);\n                 (void) CloseBlob(image);\n                 return(MagickFalse);\n               }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-0798","CWE_ID":"399","category":"security","commit_id":"259b664f950c2ba66fbf4b0fe5281327904ead21","commit_message":"From 259b664f950c2ba66fbf4b0fe5281327904ead21 Mon Sep 17 00:00:00 2001\nFrom: Emilia Kasper <emilia@openssl.org>\nDate: Wed, 24 Feb 2016 12:59:59 +0100\nSubject: [PATCH] CVE-2016-0798: avoid memory leak in SRP\n\nThe SRP user database lookup method SRP_VBASE_get_by_user had confusing\nmemory management semantics; the returned pointer was sometimes newly\nallocated, and sometimes owned by the callee. The calling code has no\nway of distinguishing these two cases.\n\nSpecifically, SRP servers that configure a secret seed to hide valid\nlogin information are vulnerable to a memory leak: an attacker\nconnecting with an invalid username can cause a memory leak of around\n300 bytes per connection.\n\nServers that do not configure SRP, or configure SRP but do not configure\na seed are not vulnerable.\n\nIn Apache, the seed directive is known as SSLSRPUnknownUserSeed.\n\nTo mitigate the memory leak, the seed handling in SRP_VBASE_get_by_user\nis now disabled even if the user has configured a seed.\n\nApplications are advised to migrate to SRP_VBASE_get1_by_user. However,\nnote that OpenSSL makes no strong guarantees about the\nindistinguishability of valid and invalid logins. In particular,\ncomputations are currently not carried out in constant time.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n---\n CHANGES              | 19 +++++++++++++++\n apps\/s_server.c      | 49 +++++++++++++++++++++++--------------\n crypto\/srp\/srp.h     | 10 ++++++++\n crypto\/srp\/srp_vfy.c | 57 ++++++++++++++++++++++++++++++++++++++++----\n util\/libeay.num      |  2 ++\n 5 files changed, 114 insertions(+), 23 deletions(-)\n\n","diff_code":"diff --git a\/CHANGES b\/CHANGES\nindex 8039184896..26a0291b38 100644\n--- a\/CHANGES\n+++ b\/CHANGES\n@@ -4,6 +4,25 @@\n \n  Changes between 1.0.2f and 1.0.2g [xx XXX xxxx]\n \n+  *) Disable SRP fake user seed to address a server memory leak.\n+\n+     Add a new method SRP_VBASE_get1_by_user that handles the seed properly.\n+\n+     SRP_VBASE_get_by_user had inconsistent memory management behaviour.\n+     In order to fix an unavoidable memory leak, SRP_VBASE_get_by_user\n+     was changed to ignore the \"fake user\" SRP seed, even if the seed\n+     is configured.\n+\n+     Users should use SRP_VBASE_get1_by_user instead. Note that in\n+     SRP_VBASE_get1_by_user, caller must free the returned value. Note\n+     also that even though configuring the SRP seed attempts to hide\n+     invalid usernames by continuing the handshake with fake\n+     credentials, this behaviour is not constant time and no strong\n+     guarantees are made that the handshake is indistinguishable from\n+     that of a valid user.\n+     (CVE-2016-0798)\n+     [Emilia K\u00c3\u00a4sper]\n+\n   *) Change the req app to generate a 2048-bit RSA\/DSA key by default,\n      if no keysize is specified with default_bits. This fixes an\n      omission in an earlier change that changed all RSA\/DSA key generation\ndiff --git a\/apps\/s_server.c b\/apps\/s_server.c\nindex 65cbaaf6eb..09c755b55c 100644\n--- a\/apps\/s_server.c\n+++ b\/apps\/s_server.c\n@@ -429,6 +429,8 @@ typedef struct srpsrvparm_st {\n static int MS_CALLBACK ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)\n {\n     srpsrvparm *p = (srpsrvparm *) arg;\n+    int ret = SSL3_AL_FATAL;\n+\n     if (p->login == NULL && p->user == NULL) {\n         p->login = SSL_get_srp_username(s);\n         BIO_printf(bio_err, \"SRP username = \\\"%s\\\"\\n\", p->login);\n@@ -437,21 +439,25 @@ static int MS_CALLBACK ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)\n \n     if (p->user == NULL) {\n         BIO_printf(bio_err, \"User %s doesn't exist\\n\", p->login);\n-        return SSL3_AL_FATAL;\n+        goto err;\n     }\n+\n     if (SSL_set_srp_server_param\n         (s, p->user->N, p->user->g, p->user->s, p->user->v,\n          p->user->info) < 0) {\n         *ad = SSL_AD_INTERNAL_ERROR;\n-        return SSL3_AL_FATAL;\n+        goto err;\n     }\n     BIO_printf(bio_err,\n                \"SRP parameters set: username = \\\"%s\\\" info=\\\"%s\\\" \\n\",\n                p->login, p->user->info);\n-    \/* need to check whether there are memory leaks *\/\n+    ret = SSL_ERROR_NONE;\n+\n+err:\n+    SRP_user_pwd_free(p->user);\n     p->user = NULL;\n     p->login = NULL;\n-    return SSL_ERROR_NONE;\n+    return ret;\n }\n \n #endif\n@@ -2452,9 +2458,10 @@ static int sv_body(char *hostname, int s, int stype, unsigned char *context)\n #ifndef OPENSSL_NO_SRP\n                 while (SSL_get_error(con, k) == SSL_ERROR_WANT_X509_LOOKUP) {\n                     BIO_printf(bio_s_out, \"LOOKUP renego during write\\n\");\n+                    SRP_user_pwd_free(srp_callback_parm.user);\n                     srp_callback_parm.user =\n-                        SRP_VBASE_get_by_user(srp_callback_parm.vb,\n-                                              srp_callback_parm.login);\n+                        SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n+                                               srp_callback_parm.login);\n                     if (srp_callback_parm.user)\n                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                    srp_callback_parm.user->info);\n@@ -2508,9 +2515,10 @@ static int sv_body(char *hostname, int s, int stype, unsigned char *context)\n #ifndef OPENSSL_NO_SRP\n                 while (SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {\n                     BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");\n+                    SRP_user_pwd_free(srp_callback_parm.user);\n                     srp_callback_parm.user =\n-                        SRP_VBASE_get_by_user(srp_callback_parm.vb,\n-                                              srp_callback_parm.login);\n+                        SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n+                                               srp_callback_parm.login);\n                     if (srp_callback_parm.user)\n                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                    srp_callback_parm.user->info);\n@@ -2605,9 +2613,10 @@ static int init_ssl_connection(SSL *con)\n     while (i <= 0 && SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {\n         BIO_printf(bio_s_out, \"LOOKUP during accept %s\\n\",\n                    srp_callback_parm.login);\n+        SRP_user_pwd_free(srp_callback_parm.user);\n         srp_callback_parm.user =\n-            SRP_VBASE_get_by_user(srp_callback_parm.vb,\n-                                  srp_callback_parm.login);\n+            SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n+                                   srp_callback_parm.login);\n         if (srp_callback_parm.user)\n             BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                        srp_callback_parm.user->info);\n@@ -2849,9 +2858,10 @@ static int www_body(char *hostname, int s, int stype, unsigned char *context)\n                    && SSL_get_error(con, i) == SSL_ERROR_WANT_X509_LOOKUP) {\n                 BIO_printf(bio_s_out, \"LOOKUP during accept %s\\n\",\n                            srp_callback_parm.login);\n+                SRP_user_pwd_free(srp_callback_parm.user);\n                 srp_callback_parm.user =\n-                    SRP_VBASE_get_by_user(srp_callback_parm.vb,\n-                                          srp_callback_parm.login);\n+                    SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n+                                           srp_callback_parm.login);\n                 if (srp_callback_parm.user)\n                     BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                srp_callback_parm.user->info);\n@@ -2891,9 +2901,10 @@ static int www_body(char *hostname, int s, int stype, unsigned char *context)\n                 if (BIO_should_io_special(io)\n                     && BIO_get_retry_reason(io) == BIO_RR_SSL_X509_LOOKUP) {\n                     BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");\n+                    SRP_user_pwd_free(srp_callback_parm.user);\n                     srp_callback_parm.user =\n-                        SRP_VBASE_get_by_user(srp_callback_parm.vb,\n-                                              srp_callback_parm.login);\n+                        SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n+                                               srp_callback_parm.login);\n                     if (srp_callback_parm.user)\n                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                    srp_callback_parm.user->info);\n@@ -3236,9 +3247,10 @@ static int rev_body(char *hostname, int s, int stype, unsigned char *context)\n         if (BIO_should_io_special(io)\n             && BIO_get_retry_reason(io) == BIO_RR_SSL_X509_LOOKUP) {\n             BIO_printf(bio_s_out, \"LOOKUP renego during accept\\n\");\n+            SRP_user_pwd_free(srp_callback_parm.user);\n             srp_callback_parm.user =\n-                SRP_VBASE_get_by_user(srp_callback_parm.vb,\n-                                      srp_callback_parm.login);\n+                SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n+                                       srp_callback_parm.login);\n             if (srp_callback_parm.user)\n                 BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                            srp_callback_parm.user->info);\n@@ -3264,9 +3276,10 @@ static int rev_body(char *hostname, int s, int stype, unsigned char *context)\n                 if (BIO_should_io_special(io)\n                     && BIO_get_retry_reason(io) == BIO_RR_SSL_X509_LOOKUP) {\n                     BIO_printf(bio_s_out, \"LOOKUP renego during read\\n\");\n+                    SRP_user_pwd_free(srp_callback_parm.user);\n                     srp_callback_parm.user =\n-                        SRP_VBASE_get_by_user(srp_callback_parm.vb,\n-                                              srp_callback_parm.login);\n+                        SRP_VBASE_get1_by_user(srp_callback_parm.vb,\n+                                               srp_callback_parm.login);\n                     if (srp_callback_parm.user)\n                         BIO_printf(bio_s_out, \"LOOKUP done %s\\n\",\n                                    srp_callback_parm.user->info);\ndiff --git a\/crypto\/srp\/srp.h b\/crypto\/srp\/srp.h\nindex d072536fec..028892a1ff 100644\n--- a\/crypto\/srp\/srp.h\n+++ b\/crypto\/srp\/srp.h\n@@ -82,16 +82,21 @@ typedef struct SRP_gN_cache_st {\n DECLARE_STACK_OF(SRP_gN_cache)\n \n typedef struct SRP_user_pwd_st {\n+    \/* Owned by us. *\/\n     char *id;\n     BIGNUM *s;\n     BIGNUM *v;\n+    \/* Not owned by us. *\/\n     const BIGNUM *g;\n     const BIGNUM *N;\n+    \/* Owned by us. *\/\n     char *info;\n } SRP_user_pwd;\n \n DECLARE_STACK_OF(SRP_user_pwd)\n \n+void SRP_user_pwd_free(SRP_user_pwd *user_pwd);\n+\n typedef struct SRP_VBASE_st {\n     STACK_OF(SRP_user_pwd) *users_pwd;\n     STACK_OF(SRP_gN_cache) *gN_cache;\n@@ -115,7 +120,12 @@ DECLARE_STACK_OF(SRP_gN)\n SRP_VBASE *SRP_VBASE_new(char *seed_key);\n int SRP_VBASE_free(SRP_VBASE *vb);\n int SRP_VBASE_init(SRP_VBASE *vb, char *verifier_file);\n+\n+\/* This method ignores the configured seed and fails for an unknown user. *\/\n SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username);\n+\/* NOTE: unlike in SRP_VBASE_get_by_user, caller owns the returned pointer.*\/\n+SRP_user_pwd *SRP_VBASE_get1_by_user(SRP_VBASE *vb, char *username);\n+\n char *SRP_create_verifier(const char *user, const char *pass, char **salt,\n                           char **verifier, const char *N, const char *g);\n int SRP_create_verifier_BN(const char *user, const char *pass, BIGNUM **salt,\ndiff --git a\/crypto\/srp\/srp_vfy.c b\/crypto\/srp\/srp_vfy.c\nindex a3f1a8a0a4..26ad3e07b4 100644\n--- a\/crypto\/srp\/srp_vfy.c\n+++ b\/crypto\/srp\/srp_vfy.c\n@@ -185,7 +185,7 @@ static char *t_tob64(char *dst, const unsigned char *src, int size)\n     return olddst;\n }\n \n-static void SRP_user_pwd_free(SRP_user_pwd *user_pwd)\n+void SRP_user_pwd_free(SRP_user_pwd *user_pwd)\n {\n     if (user_pwd == NULL)\n         return;\n@@ -247,6 +247,24 @@ static int SRP_user_pwd_set_sv_BN(SRP_user_pwd *vinfo, BIGNUM *s, BIGNUM *v)\n     return (vinfo->s != NULL && vinfo->v != NULL);\n }\n \n+static SRP_user_pwd *srp_user_pwd_dup(SRP_user_pwd *src)\n+{\n+    SRP_user_pwd *ret;\n+\n+    if (src == NULL)\n+        return NULL;\n+    if ((ret = SRP_user_pwd_new()) == NULL)\n+        return NULL;\n+\n+    SRP_user_pwd_set_gN(ret, src->g, src->N);\n+    if (!SRP_user_pwd_set_ids(ret, src->id, src->info)\n+        || !SRP_user_pwd_set_sv_BN(ret, BN_dup(src->s), BN_dup(src->v))) {\n+            SRP_user_pwd_free(ret);\n+            return NULL;\n+    }\n+    return ret;\n+}\n+\n SRP_VBASE *SRP_VBASE_new(char *seed_key)\n {\n     SRP_VBASE *vb = (SRP_VBASE *)OPENSSL_malloc(sizeof(SRP_VBASE));\n@@ -468,21 +486,50 @@ int SRP_VBASE_init(SRP_VBASE *vb, char *verifier_file)\n \n }\n \n-SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)\n+static SRP_user_pwd *find_user(SRP_VBASE *vb, char *username)\n {\n     int i;\n     SRP_user_pwd *user;\n-    unsigned char digv[SHA_DIGEST_LENGTH];\n-    unsigned char digs[SHA_DIGEST_LENGTH];\n-    EVP_MD_CTX ctxt;\n \n     if (vb == NULL)\n         return NULL;\n+\n     for (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) {\n         user = sk_SRP_user_pwd_value(vb->users_pwd, i);\n         if (strcmp(user->id, username) == 0)\n             return user;\n     }\n+\n+    return NULL;\n+}\n+\n+\/*\n+ * This method ignores the configured seed and fails for an unknown user.\n+ * Ownership of the returned pointer is not released to the caller.\n+ * In other words, caller must not free the result.\n+ *\/\n+SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)\n+{\n+    return find_user(vb, username);\n+}\n+\n+\/*\n+ * Ownership of the returned pointer is released to the caller.\n+ * In other words, caller must free the result once done.\n+ *\/\n+SRP_user_pwd *SRP_VBASE_get1_by_user(SRP_VBASE *vb, char *username)\n+{\n+    SRP_user_pwd *user;\n+    unsigned char digv[SHA_DIGEST_LENGTH];\n+    unsigned char digs[SHA_DIGEST_LENGTH];\n+    EVP_MD_CTX ctxt;\n+\n+    if (vb == NULL)\n+        return NULL;\n+\n+    if ((user = find_user(vb, username)) != NULL)\n+        return srp_user_pwd_dup(user);\n+\n     if ((vb->seed_key == NULL) ||\n         (vb->default_g == NULL) || (vb->default_N == NULL))\n         return NULL;\ndiff --git a\/util\/libeay.num b\/util\/libeay.num\nindex 7f7487df50..e5b3c6ea84 100755\n--- a\/util\/libeay.num\n+++ b\/util\/libeay.num\n@@ -1807,6 +1807,8 @@ ASN1_UTCTIME_get                        2350\tNOEXIST::FUNCTION:\n X509_REQ_digest                         2362\tEXIST::FUNCTION:EVP\n X509_CRL_digest                         2391\tEXIST::FUNCTION:EVP\n ASN1_STRING_clear_free                  2392\tEXIST::FUNCTION:\n+SRP_VBASE_get1_by_user                  2393\tEXIST::FUNCTION:SRP\n+SRP_user_pwd_free                       2394\tEXIST::FUNCTION:SRP\n d2i_ASN1_SET_OF_PKCS7                   2397\tNOEXIST::FUNCTION:\n X509_ALGOR_cmp                          2398\tEXIST::FUNCTION:\n EVP_CIPHER_CTX_set_key_length           2399\tEXIST::FUNCTION:\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-0410","CWE_ID":"399","category":"security","commit_id":"f98bfbd78c37c5946cc53089da32a5f741efdeb7","commit_message":"From f98bfbd78c37c5946cc53089da32a5f741efdeb7 Mon Sep 17 00:00:00 2001\nFrom: Evgeniy Polyakov <zbr@ioremap.net>\nDate: Tue, 2 Feb 2010 15:58:48 -0800\nSubject: connector: Delete buggy notification code.\n\nOn Tue, Feb 02, 2010 at 02:57:14PM -0800, Greg KH (gregkh@suse.de) wrote:\n> > There are at least two ways to fix it: using a big cannon and a small\n> > one. The former way is to disable notification registration, since it is\n> > not used by anyone at all. Second way is to check whether calling\n> > process is root and its destination group is -1 (kind of priveledged\n> > one) before command is dispatched to workqueue.\n>\n> Well if no one is using it, removing it makes the most sense, right?\n>\n> No objection from me, care to make up a patch either way for this?\n\nGetting it is not used, let's drop support for notifications about\n(un)registered events from connector.\nAnother option was to check credentials on receiving, but we can always\nrestore it without bugs if needed, but genetlink has a wider code base\nand none complained, that userspace can not get notification when some\nother clients were (un)registered.\n\nKudos for Sebastian Krahmer <krahmer@suse.de>, who found a bug in the\ncode.\n\nSigned-off-by: Evgeniy Polyakov <zbr@ioremap.net>\nAcked-by: Greg Kroah-Hartman <gregkh@suse.de>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/connector\/connector.c | 175 ------------------------------------------\n include\/linux\/connector.h     |  32 --------\n 2 files changed, 207 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/connector\/connector.c b\/drivers\/connector\/connector.c\nindex f06024668f99..537c29ac4487 100644\n--- a\/drivers\/connector\/connector.c\n+++ b\/drivers\/connector\/connector.c\n@@ -36,17 +36,6 @@ MODULE_LICENSE(\"GPL\");\n MODULE_AUTHOR(\"Evgeniy Polyakov <zbr@ioremap.net>\");\n MODULE_DESCRIPTION(\"Generic userspace <-> kernelspace connector.\");\n \n-static u32 cn_idx = CN_IDX_CONNECTOR;\n-static u32 cn_val = CN_VAL_CONNECTOR;\n-\n-module_param(cn_idx, uint, 0);\n-module_param(cn_val, uint, 0);\n-MODULE_PARM_DESC(cn_idx, \"Connector's main device idx.\");\n-MODULE_PARM_DESC(cn_val, \"Connector's main device val.\");\n-\n-static DEFINE_MUTEX(notify_lock);\n-static LIST_HEAD(notify_list);\n-\n static struct cn_dev cdev;\n \n static int cn_already_initialized;\n@@ -209,54 +198,6 @@ static void cn_rx_skb(struct sk_buff *__skb)\n \t}\n }\n \n-\/*\n- * Notification routing.\n- *\n- * Gets id and checks if there are notification request for it's idx\n- * and val.  If there are such requests notify the listeners with the\n- * given notify event.\n- *\n- *\/\n-static void cn_notify(struct cb_id *id, u32 notify_event)\n-{\n-\tstruct cn_ctl_entry *ent;\n-\n-\tmutex_lock(&notify_lock);\n-\tlist_for_each_entry(ent, &notify_list, notify_entry) {\n-\t\tint i;\n-\t\tstruct cn_notify_req *req;\n-\t\tstruct cn_ctl_msg *ctl = ent->msg;\n-\t\tint idx_found, val_found;\n-\n-\t\tidx_found = val_found = 0;\n-\n-\t\treq = (struct cn_notify_req *)ctl->data;\n-\t\tfor (i = 0; i < ctl->idx_notify_num; ++i, ++req) {\n-\t\t\tif (id->idx >= req->first &&\n-\t\t\t\t\tid->idx < req->first + req->range) {\n-\t\t\t\tidx_found = 1;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor (i = 0; i < ctl->val_notify_num; ++i, ++req) {\n-\t\t\tif (id->val >= req->first &&\n-\t\t\t\t\tid->val < req->first + req->range) {\n-\t\t\t\tval_found = 1;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (idx_found && val_found) {\n-\t\t\tstruct cn_msg m = { .ack = notify_event, };\n-\n-\t\t\tmemcpy(&m.id, id, sizeof(m.id));\n-\t\t\tcn_netlink_send(&m, ctl->group, GFP_KERNEL);\n-\t\t}\n-\t}\n-\tmutex_unlock(&notify_lock);\n-}\n-\n \/*\n  * Callback add routing - adds callback with given ID and name.\n  * If there is registered callback with the same ID it will not be added.\n@@ -276,8 +217,6 @@ int cn_add_callback(struct cb_id *id, char *name,\n \tif (err)\n \t\treturn err;\n \n-\tcn_notify(id, 0);\n-\n \treturn 0;\n }\n EXPORT_SYMBOL_GPL(cn_add_callback);\n@@ -295,111 +234,9 @@ void cn_del_callback(struct cb_id *id)\n \tstruct cn_dev *dev = &cdev;\n \n \tcn_queue_del_callback(dev->cbdev, id);\n-\tcn_notify(id, 1);\n }\n EXPORT_SYMBOL_GPL(cn_del_callback);\n \n-\/*\n- * Checks two connector's control messages to be the same.\n- * Returns 1 if they are the same or if the first one is corrupted.\n- *\/\n-static int cn_ctl_msg_equals(struct cn_ctl_msg *m1, struct cn_ctl_msg *m2)\n-{\n-\tint i;\n-\tstruct cn_notify_req *req1, *req2;\n-\n-\tif (m1->idx_notify_num != m2->idx_notify_num)\n-\t\treturn 0;\n-\n-\tif (m1->val_notify_num != m2->val_notify_num)\n-\t\treturn 0;\n-\n-\tif (m1->len != m2->len)\n-\t\treturn 0;\n-\n-\tif ((m1->idx_notify_num + m1->val_notify_num) * sizeof(*req1) !=\n-\t    m1->len)\n-\t\treturn 1;\n-\n-\treq1 = (struct cn_notify_req *)m1->data;\n-\treq2 = (struct cn_notify_req *)m2->data;\n-\n-\tfor (i = 0; i < m1->idx_notify_num; ++i) {\n-\t\tif (req1->first != req2->first || req1->range != req2->range)\n-\t\t\treturn 0;\n-\t\treq1++;\n-\t\treq2++;\n-\t}\n-\n-\tfor (i = 0; i < m1->val_notify_num; ++i) {\n-\t\tif (req1->first != req2->first || req1->range != req2->range)\n-\t\t\treturn 0;\n-\t\treq1++;\n-\t\treq2++;\n-\t}\n-\n-\treturn 1;\n-}\n-\n-\/*\n- * Main connector device's callback.\n- *\n- * Used for notification of a request's processing.\n- *\/\n-static void cn_callback(struct cn_msg *msg, struct netlink_skb_parms *nsp)\n-{\n-\tstruct cn_ctl_msg *ctl;\n-\tstruct cn_ctl_entry *ent;\n-\tu32 size;\n-\n-\tif (msg->len < sizeof(*ctl))\n-\t\treturn;\n-\n-\tctl = (struct cn_ctl_msg *)msg->data;\n-\n-\tsize = (sizeof(*ctl) + ((ctl->idx_notify_num +\n-\t\t\t\t ctl->val_notify_num) *\n-\t\t\t\tsizeof(struct cn_notify_req)));\n-\n-\tif (msg->len != size)\n-\t\treturn;\n-\n-\tif (ctl->len + sizeof(*ctl) != msg->len)\n-\t\treturn;\n-\n-\t\/*\n-\t * Remove notification.\n-\t *\/\n-\tif (ctl->group == 0) {\n-\t\tstruct cn_ctl_entry *n;\n-\n-\t\tmutex_lock(&notify_lock);\n-\t\tlist_for_each_entry_safe(ent, n, &notify_list, notify_entry) {\n-\t\t\tif (cn_ctl_msg_equals(ent->msg, ctl)) {\n-\t\t\t\tlist_del(&ent->notify_entry);\n-\t\t\t\tkfree(ent);\n-\t\t\t}\n-\t\t}\n-\t\tmutex_unlock(&notify_lock);\n-\n-\t\treturn;\n-\t}\n-\n-\tsize += sizeof(*ent);\n-\n-\tent = kzalloc(size, GFP_KERNEL);\n-\tif (!ent)\n-\t\treturn;\n-\n-\tent->msg = (struct cn_ctl_msg *)(ent + 1);\n-\n-\tmemcpy(ent->msg, ctl, size - sizeof(*ent));\n-\n-\tmutex_lock(&notify_lock);\n-\tlist_add(&ent->notify_entry, &notify_list);\n-\tmutex_unlock(&notify_lock);\n-}\n-\n static int cn_proc_show(struct seq_file *m, void *v)\n {\n \tstruct cn_queue_dev *dev = cdev.cbdev;\n@@ -437,11 +274,8 @@ static const struct file_operations cn_file_ops = {\n static int __devinit cn_init(void)\n {\n \tstruct cn_dev *dev = &cdev;\n-\tint err;\n \n \tdev->input = cn_rx_skb;\n-\tdev->id.idx = cn_idx;\n-\tdev->id.val = cn_val;\n \n \tdev->nls = netlink_kernel_create(&init_net, NETLINK_CONNECTOR,\n \t\t\t\t\t CN_NETLINK_USERS + 0xf,\n@@ -457,14 +291,6 @@ static int __devinit cn_init(void)\n \n \tcn_already_initialized = 1;\n \n-\terr = cn_add_callback(&dev->id, \"connector\", &cn_callback);\n-\tif (err) {\n-\t\tcn_already_initialized = 0;\n-\t\tcn_queue_free_dev(dev->cbdev);\n-\t\tnetlink_kernel_release(dev->nls);\n-\t\treturn -EINVAL;\n-\t}\n-\n \tproc_net_fops_create(&init_net, \"connector\", S_IRUGO, &cn_file_ops);\n \n \treturn 0;\n@@ -478,7 +304,6 @@ static void __devexit cn_fini(void)\n \n \tproc_net_remove(&init_net, \"connector\");\n \n-\tcn_del_callback(&dev->id);\n \tcn_queue_free_dev(dev->cbdev);\n \tnetlink_kernel_release(dev->nls);\n }\ndiff --git a\/include\/linux\/connector.h b\/include\/linux\/connector.h\nindex 72ba63eb83c5..3a779ffba60b 100644\n--- a\/include\/linux\/connector.h\n+++ b\/include\/linux\/connector.h\n@@ -24,9 +24,6 @@\n \n #include <linux\/types.h>\n \n-#define CN_IDX_CONNECTOR\t\t0xffffffff\n-#define CN_VAL_CONNECTOR\t\t0xffffffff\n-\n \/*\n  * Process Events connector unique ids -- used for message routing\n  *\/\n@@ -75,30 +72,6 @@ struct cn_msg {\n \t__u8 data[0];\n };\n \n-\/*\n- * Notify structure - requests notification about\n- * registering\/unregistering idx\/val in range [first, first+range].\n- *\/\n-struct cn_notify_req {\n-\t__u32 first;\n-\t__u32 range;\n-};\n-\n-\/*\n- * Main notification control message\n- * *_notify_num \t- number of appropriate cn_notify_req structures after \n- *\t\t\t\tthis struct.\n- * group \t\t- notification receiver's idx.\n- * len \t\t\t- total length of the attached data.\n- *\/\n-struct cn_ctl_msg {\n-\t__u32 idx_notify_num;\n-\t__u32 val_notify_num;\n-\t__u32 group;\n-\t__u32 len;\n-\t__u8 data[0];\n-};\n-\n #ifdef __KERNEL__\n \n #include <asm\/atomic.h>\n@@ -151,11 +124,6 @@ struct cn_callback_entry {\n \tu32 seq, group;\n };\n \n-struct cn_ctl_entry {\n-\tstruct list_head notify_entry;\n-\tstruct cn_ctl_msg *msg;\n-};\n-\n struct cn_dev {\n \tstruct cb_id id;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2803","CWE_ID":"399","category":"security","commit_id":"951cbea56fdc03ef96d07fbd7e5bed755d42ac8a","commit_message":"From 951cbea56fdc03ef96d07fbd7e5bed755d42ac8a Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sun, 22 Apr 2012 20:03:53 +0200\nSubject: [PATCH] mpeg12dec: reset data size after parsing extradata.\n\nThis ended up corrupting data structures and may possibly\nlead to a double free.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/mpeg12.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/libavcodec\/mpeg12.c b\/libavcodec\/mpeg12.c\nindex ea19b819cc..b66d535e28 100644\n--- a\/libavcodec\/mpeg12.c\n+++ b\/libavcodec\/mpeg12.c\n@@ -2289,6 +2289,7 @@ static int mpeg_decode_frame(AVCodecContext *avctx,\n \n     if (avctx->extradata && !avctx->frame_number) {\n         int ret = decode_chunks(avctx, picture, data_size, avctx->extradata, avctx->extradata_size);\n+        *data_size = 0;\n         if (ret < 0 && (avctx->err_recognition & AV_EF_EXPLODE))\n             return ret;\n     }\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-3290","CWE_ID":"399","category":"security","commit_id":"07708c4af1346ab1521b26a202f438366b7bcffd","commit_message":"From 07708c4af1346ab1521b26a202f438366b7bcffd Mon Sep 17 00:00:00 2001\nFrom: Jan Kiszka <jan.kiszka@siemens.com>\nDate: Mon, 3 Aug 2009 18:43:28 +0200\nSubject: KVM: x86: Disallow hypercalls for guest callers in rings > 0\n\nSo far unprivileged guest callers running in ring 3 can issue, e.g., MMU\nhypercalls. Normally, such callers cannot provide any hand-crafted MMU\ncommand structure as it has to be passed by its physical address, but\nthey can still crash the guest kernel by passing random addresses.\n\nTo close the hole, this patch considers hypercalls valid only if issued\nfrom guest ring 0. This may still be relaxed on a per-hypercall base in\nthe future once required.\n\nCc: stable@kernel.org\nSigned-off-by: Jan Kiszka <jan.kiszka@siemens.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>\n---\n arch\/x86\/kvm\/x86.c       | 6 ++++++\n include\/linux\/kvm_para.h | 1 +\n 2 files changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/x86.c b\/arch\/x86\/kvm\/x86.c\nindex fa525d511d92..92b5eddaa877 100644\n--- a\/arch\/x86\/kvm\/x86.c\n+++ b\/arch\/x86\/kvm\/x86.c\n@@ -3213,6 +3213,11 @@ int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n \t\ta3 &= 0xFFFFFFFF;\n \t}\n \n+\tif (kvm_x86_ops->get_cpl(vcpu) != 0) {\n+\t\tret = -KVM_EPERM;\n+\t\tgoto out;\n+\t}\n+\n \tswitch (nr) {\n \tcase KVM_HC_VAPIC_POLL_IRQ:\n \t\tret = 0;\n@@ -3224,6 +3229,7 @@ int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n \t\tret = -KVM_ENOSYS;\n \t\tbreak;\n \t}\n+out:\n \tkvm_register_write(vcpu, VCPU_REGS_RAX, ret);\n \t++vcpu->stat.hypercalls;\n \treturn r;\ndiff --git a\/include\/linux\/kvm_para.h b\/include\/linux\/kvm_para.h\nindex 3ddce03766ca..d73109243fda 100644\n--- a\/include\/linux\/kvm_para.h\n+++ b\/include\/linux\/kvm_para.h\n@@ -13,6 +13,7 @@\n #define KVM_ENOSYS\t\t1000\n #define KVM_EFAULT\t\tEFAULT\n #define KVM_E2BIG\t\tE2BIG\n+#define KVM_EPERM\t\tEPERM\n \n #define KVM_HC_VAPIC_POLL_IRQ\t\t1\n #define KVM_HC_MMU_OP\t\t\t2\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-14059","CWE_ID":"399","category":"security","commit_id":"7e80b63ecd259d69d383623e75b318bf2bd491f6","commit_message":"From 7e80b63ecd259d69d383623e75b318bf2bd491f6 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?=E5=AD=99=E6=B5=A9=20and=20=E5=BC=A0=E6=B4=AA=E4=BA=AE=28?=\n =?UTF-8?q?=E6=9C=9B=E5=88=9D=29?= <tony.sh and wangchu.zhl@alibaba-inc.com>\nDate: Fri, 25 Aug 2017 01:15:27 +0200\nSubject: [PATCH] avformat\/cinedec: Fix DoS due to lack of eof check\n\nFixes: loop.cine\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/cinedec.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavformat\/cinedec.c b\/libavformat\/cinedec.c\nindex 763b93ba2e1..de34fb96382 100644\n--- a\/libavformat\/cinedec.c\n+++ b\/libavformat\/cinedec.c\n@@ -267,8 +267,12 @@ static int cine_read_header(AVFormatContext *avctx)\n \n     \/* parse image offsets *\/\n     avio_seek(pb, offImageOffsets, SEEK_SET);\n-    for (i = 0; i < st->duration; i++)\n+    for (i = 0; i < st->duration; i++) {\n+        if (avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n+\n         av_add_index_entry(st, avio_rl64(pb), i, 0, 0, AVINDEX_KEYFRAME);\n+    }\n \n     return 0;\n }\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-18204","CWE_ID":"399","category":"security","commit_id":"28f5a8a7c033cbf3e32277f4cc9c6afd74f05300","commit_message":"From 28f5a8a7c033cbf3e32277f4cc9c6afd74f05300 Mon Sep 17 00:00:00 2001\nFrom: alex chen <alex.chen@huawei.com>\nDate: Wed, 15 Nov 2017 17:31:40 -0800\nSubject: [PATCH] ocfs2: should wait dio before inode lock in ocfs2_setattr()\n\nwe should wait dio requests to finish before inode lock in\nocfs2_setattr(), otherwise the following deadlock will happen:\n\nprocess 1                  process 2                    process 3\ntruncate file 'A'          end_io of writing file 'A'   receiving the bast messages\nocfs2_setattr\n ocfs2_inode_lock_tracker\n  ocfs2_inode_lock_full\n inode_dio_wait\n  __inode_dio_wait\n  -->waiting for all dio\n  requests finish\n                                                        dlm_proxy_ast_handler\n                                                         dlm_do_local_bast\n                                                          ocfs2_blocking_ast\n                                                           ocfs2_generic_handle_bast\n                                                            set OCFS2_LOCK_BLOCKED flag\n                        dio_end_io\n                         dio_bio_end_aio\n                          dio_complete\n                           ocfs2_dio_end_io\n                            ocfs2_dio_end_io_write\n                             ocfs2_inode_lock\n                              __ocfs2_cluster_lock\n                               ocfs2_wait_for_mask\n                               -->waiting for OCFS2_LOCK_BLOCKED\n                               flag to be cleared, that is waiting\n                               for 'process 1' unlocking the inode lock\n                           inode_dio_end\n                           -->here dec the i_dio_count, but will never\n                           be called, so a deadlock happened.\n\nLink: http:\/\/lkml.kernel.org\/r\/59F81636.70508@huawei.com\nSigned-off-by: Alex Chen <alex.chen@huawei.com>\nReviewed-by: Jun Piao <piaojun@huawei.com>\nReviewed-by: Joseph Qi <jiangqi903@gmail.com>\nAcked-by: Changwei Ge <ge.changwei@h3c.com>\nCc: Mark Fasheh <mfasheh@versity.com>\nCc: Joel Becker <jlbec@evilplan.org>\nCc: Junxiao Bi <junxiao.bi@oracle.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/ocfs2\/file.c | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ocfs2\/file.c b\/fs\/ocfs2\/file.c\nindex 6e41fc8fabbe7..dc455d45a66ae 100644\n--- a\/fs\/ocfs2\/file.c\n+++ b\/fs\/ocfs2\/file.c\n@@ -1161,6 +1161,13 @@ int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)\n \t}\n \tsize_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE;\n \tif (size_change) {\n+\t\t\/*\n+\t\t * Here we should wait dio to finish before inode lock\n+\t\t * to avoid a deadlock between ocfs2_setattr() and\n+\t\t * ocfs2_dio_end_io_write()\n+\t\t *\/\n+\t\tinode_dio_wait(inode);\n+\n \t\tstatus = ocfs2_rw_lock(inode, 1);\n \t\tif (status < 0) {\n \t\t\tmlog_errno(status);\n@@ -1200,8 +1207,6 @@ int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)\n \t\tif (status)\n \t\t\tgoto bail_unlock;\n \n-\t\tinode_dio_wait(inode);\n-\n \t\tif (i_size_read(inode) >= attr->ia_size) {\n \t\t\tif (ocfs2_should_order_data(inode)) {\n \t\t\t\tstatus = ocfs2_begin_ordered_truncate(inode,\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-0858","CWE_ID":"399","category":"security","commit_id":"204cb29b3c84a74cbcd059d353c70c8bdc567d98","commit_message":"From 204cb29b3c84a74cbcd059d353c70c8bdc567d98 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sun, 25 Dec 2011 12:28:50 +0100\nSubject: [PATCH] shorten: Use separate pointers for the allocated memory for\n decoded samples.\n\nFixes invalid free() if any of the buffers are not allocated due to either\nnot decoding a header or an error prior to allocating all buffers.\n\nFixes CVE-2012-0858\nCC: libav-stable@libav.org\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\nSigned-off-by: Justin Ruggles <justin.ruggles@gmail.com>\n---\n libavcodec\/shorten.c | 14 ++++++++------\n 1 file changed, 8 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/shorten.c b\/libavcodec\/shorten.c\nindex eb67df7..83777fb 100644\n--- a\/libavcodec\/shorten.c\n+++ b\/libavcodec\/shorten.c\n@@ -86,6 +86,7 @@ typedef struct ShortenContext {\n     int channels;\n \n     int32_t *decoded[MAX_CHANNELS];\n+    int32_t *decoded_base[MAX_CHANNELS];\n     int32_t *offset[MAX_CHANNELS];\n     int *coeffs;\n     uint8_t *bitstream;\n@@ -140,13 +141,14 @@ static int allocate_buffers(ShortenContext *s)\n             return AVERROR(ENOMEM);\n         s->offset[chan] = tmp_ptr;\n \n-        tmp_ptr = av_realloc(s->decoded[chan], sizeof(int32_t)*(s->blocksize + s->nwrap));\n+        tmp_ptr = av_realloc(s->decoded_base[chan], (s->blocksize + s->nwrap) *\n+                             sizeof(s->decoded_base[0][0]));\n         if (!tmp_ptr)\n             return AVERROR(ENOMEM);\n-        s->decoded[chan] = tmp_ptr;\n+        s->decoded_base[chan] = tmp_ptr;\n         for (i=0; i<s->nwrap; i++)\n-            s->decoded[chan][i] = 0;\n-        s->decoded[chan] += s->nwrap;\n+            s->decoded_base[chan][i] = 0;\n+        s->decoded[chan] = s->decoded_base[chan] + s->nwrap;\n     }\n \n     coeffs = av_realloc(s->coeffs, s->nwrap * sizeof(*s->coeffs));\n@@ -615,8 +617,8 @@ static av_cold int shorten_decode_close(AVCodecContext *avctx)\n     int i;\n \n     for (i = 0; i < s->channels; i++) {\n-        s->decoded[i] -= s->nwrap;\n-        av_freep(&s->decoded[i]);\n+        s->decoded[i] = NULL;\n+        av_freep(&s->decoded_base[i]);\n         av_freep(&s->offset[i]);\n     }\n     av_freep(&s->bitstream);\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5856","CWE_ID":"399","category":"security","commit_id":"765a707000e838c30b18d712fe6cb3dd8e0435f3","commit_message":"From 765a707000e838c30b18d712fe6cb3dd8e0435f3 Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Mon, 2 Jan 2017 11:03:33 +0100\nSubject: [PATCH] megasas: fix guest-triggered memory leak\n\nIf the guest sets the sglist size to a value >=2GB, megasas_handle_dcmd\nwill return MFI_STAT_MEMORY_NOT_AVAILABLE without freeing the memory.\nAvoid this by returning only the status from map_dcmd, and loading\ncmd->iov_size in the caller.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n hw\/scsi\/megasas.c | 11 ++++++-----\n 1 file changed, 6 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/hw\/scsi\/megasas.c b\/hw\/scsi\/megasas.c\nindex 67fc1e7..6233865 100644\n--- a\/hw\/scsi\/megasas.c\n+++ b\/hw\/scsi\/megasas.c\n@@ -683,14 +683,14 @@ static int megasas_map_dcmd(MegasasState *s, MegasasCmd *cmd)\n         trace_megasas_dcmd_invalid_sge(cmd->index,\n                                        cmd->frame->header.sge_count);\n         cmd->iov_size = 0;\n-        return -1;\n+        return -EINVAL;\n     }\n     iov_pa = megasas_sgl_get_addr(cmd, &cmd->frame->dcmd.sgl);\n     iov_size = megasas_sgl_get_len(cmd, &cmd->frame->dcmd.sgl);\n     pci_dma_sglist_init(&cmd->qsg, PCI_DEVICE(s), 1);\n     qemu_sglist_add(&cmd->qsg, iov_pa, iov_size);\n     cmd->iov_size = iov_size;\n-    return cmd->iov_size;\n+    return 0;\n }\n \n static void megasas_finish_dcmd(MegasasCmd *cmd, uint32_t iov_size)\n@@ -1559,19 +1559,20 @@ static const struct dcmd_cmd_tbl_t {\n \n static int megasas_handle_dcmd(MegasasState *s, MegasasCmd *cmd)\n {\n-    int opcode, len;\n+    int opcode;\n     int retval = 0;\n+    size_t len;\n     const struct dcmd_cmd_tbl_t *cmdptr = dcmd_cmd_tbl;\n \n     opcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n     trace_megasas_handle_dcmd(cmd->index, opcode);\n-    len = megasas_map_dcmd(s, cmd);\n-    if (len < 0) {\n+    if (megasas_map_dcmd(s, cmd) < 0) {\n         return MFI_STAT_MEMORY_NOT_AVAILABLE;\n     }\n     while (cmdptr->opcode != -1 && cmdptr->opcode != opcode) {\n         cmdptr++;\n     }\n+    len = cmd->iov_size;\n     if (cmdptr->opcode == -1) {\n         trace_megasas_dcmd_unhandled(cmd->index, opcode, len);\n         retval = megasas_dcmd_dummy(s, cmd);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-14170","CWE_ID":"399","category":"security","commit_id":"900f39692ca0337a98a7cf047e4e2611071810c2","commit_message":"From 900f39692ca0337a98a7cf047e4e2611071810c2 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?=E5=AD=99=E6=B5=A9=28=E6=99=93=E9=BB=91=29?=\n <tony.sh@alibaba-inc.com>\nDate: Tue, 29 Aug 2017 23:59:21 +0200\nSubject: [PATCH] avformat\/mxfdec: Fix DoS issues in\n mxf_read_index_entry_array()\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nFixes: 20170829A.mxf\n\nCo-Author: \u5f20\u6d2a\u4eae(\u671b\u521d)\" <wangchu.zhl@alibaba-inc.com>\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/mxfdec.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/libavformat\/mxfdec.c b\/libavformat\/mxfdec.c\nindex f8d0f9e0570..6adb77d81fb 100644\n--- a\/libavformat\/mxfdec.c\n+++ b\/libavformat\/mxfdec.c\n@@ -899,6 +899,8 @@ static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *seg\n     segment->nb_index_entries = avio_rb32(pb);\n \n     length = avio_rb32(pb);\n+    if(segment->nb_index_entries && length < 11)\n+        return AVERROR_INVALIDDATA;\n \n     if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n         !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n@@ -909,6 +911,8 @@ static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *seg\n     }\n \n     for (i = 0; i < segment->nb_index_entries; i++) {\n+        if(avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n         segment->temporal_offset_entries[i] = avio_r8(pb);\n         avio_r8(pb);                                        \/* KeyFrameOffset *\/\n         segment->flag_entries[i] = avio_r8(pb);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2010-4805","CWE_ID":"399","category":"security","commit_id":"c377411f2494a931ff7facdbb3a6839b1266bcf6","commit_message":"From c377411f2494a931ff7facdbb3a6839b1266bcf6 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <eric.dumazet@gmail.com>\nDate: Tue, 27 Apr 2010 15:13:20 -0700\nSubject: net: sk_add_backlog() take rmem_alloc into account\n\nCurrent socket backlog limit is not enough to really stop DDOS attacks,\nbecause user thread spend many time to process a full backlog each\nround, and user might crazy spin on socket lock.\n\nWe should add backlog size and receive_queue size (aka rmem_alloc) to\npace writers, and let user run without being slow down too much.\n\nIntroduce a sk_rcvqueues_full() helper, to avoid taking socket lock in\nstress situations.\n\nUnder huge stress from a multiqueue\/RPS enabled NIC, a single flow udp\nreceiver can now process ~200.000 pps (instead of ~100 pps before the\npatch) on a 8 core machine.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/sock.h | 13 +++++++++++--\n net\/core\/sock.c    |  5 ++++-\n net\/ipv4\/udp.c     |  4 ++++\n net\/ipv6\/udp.c     |  8 ++++++++\n net\/sctp\/socket.c  |  3 ---\n 5 files changed, 27 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/sock.h b\/include\/net\/sock.h\nindex 07822280d953..cf12b1e61fa6 100644\n--- a\/include\/net\/sock.h\n+++ b\/include\/net\/sock.h\n@@ -256,7 +256,6 @@ struct sock {\n \t\tstruct sk_buff *head;\n \t\tstruct sk_buff *tail;\n \t\tint len;\n-\t\tint limit;\n \t} sk_backlog;\n \twait_queue_head_t\t*sk_sleep;\n \tstruct dst_entry\t*sk_dst_cache;\n@@ -608,10 +607,20 @@ static inline void __sk_add_backlog(struct sock *sk, struct sk_buff *skb)\n \tskb->next = NULL;\n }\n \n+\/*\n+ * Take into account size of receive queue and backlog queue\n+ *\/\n+static inline bool sk_rcvqueues_full(const struct sock *sk, const struct sk_buff *skb)\n+{\n+\tunsigned int qsize = sk->sk_backlog.len + atomic_read(&sk->sk_rmem_alloc);\n+\n+\treturn qsize + skb->truesize > sk->sk_rcvbuf;\n+}\n+\n \/* The per-socket spinlock must be held here. *\/\n static inline __must_check int sk_add_backlog(struct sock *sk, struct sk_buff *skb)\n {\n-\tif (sk->sk_backlog.len >= max(sk->sk_backlog.limit, sk->sk_rcvbuf << 1))\n+\tif (sk_rcvqueues_full(sk, skb))\n \t\treturn -ENOBUFS;\n \n \t__sk_add_backlog(sk, skb);\ndiff --git a\/net\/core\/sock.c b\/net\/core\/sock.c\nindex 58ebd146ce5a..51041759517e 100644\n--- a\/net\/core\/sock.c\n+++ b\/net\/core\/sock.c\n@@ -327,6 +327,10 @@ int sk_receive_skb(struct sock *sk, struct sk_buff *skb, const int nested)\n \n \tskb->dev = NULL;\n \n+\tif (sk_rcvqueues_full(sk, skb)) {\n+\t\tatomic_inc(&sk->sk_drops);\n+\t\tgoto discard_and_relse;\n+\t}\n \tif (nested)\n \t\tbh_lock_sock_nested(sk);\n \telse\n@@ -1885,7 +1889,6 @@ void sock_init_data(struct socket *sock, struct sock *sk)\n \tsk->sk_allocation\t=\tGFP_KERNEL;\n \tsk->sk_rcvbuf\t\t=\tsysctl_rmem_default;\n \tsk->sk_sndbuf\t\t=\tsysctl_wmem_default;\n-\tsk->sk_backlog.limit\t=\tsk->sk_rcvbuf << 1;\n \tsk->sk_state\t\t=\tTCP_CLOSE;\n \tsk_set_socket(sk, sock);\n \ndiff --git a\/net\/ipv4\/udp.c b\/net\/ipv4\/udp.c\nindex fa3d2874db41..63eb56b2d873 100644\n--- a\/net\/ipv4\/udp.c\n+++ b\/net\/ipv4\/udp.c\n@@ -1372,6 +1372,10 @@ int udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)\n \t\t\tgoto drop;\n \t}\n \n+\n+\tif (sk_rcvqueues_full(sk, skb))\n+\t\tgoto drop;\n+\n \trc = 0;\n \n \tbh_lock_sock(sk);\ndiff --git a\/net\/ipv6\/udp.c b\/net\/ipv6\/udp.c\nindex 2850e35cee3d..3ead20ad9d07 100644\n--- a\/net\/ipv6\/udp.c\n+++ b\/net\/ipv6\/udp.c\n@@ -584,6 +584,10 @@ static void flush_stack(struct sock **stack, unsigned int count,\n \n \t\tsk = stack[i];\n \t\tif (skb1) {\n+\t\t\tif (sk_rcvqueues_full(sk, skb)) {\n+\t\t\t\tkfree_skb(skb1);\n+\t\t\t\tgoto drop;\n+\t\t\t}\n \t\t\tbh_lock_sock(sk);\n \t\t\tif (!sock_owned_by_user(sk))\n \t\t\t\tudpv6_queue_rcv_skb(sk, skb1);\n@@ -759,6 +763,10 @@ int __udp6_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,\n \n \t\/* deliver *\/\n \n+\tif (sk_rcvqueues_full(sk, skb)) {\n+\t\tsock_put(sk);\n+\t\tgoto discard;\n+\t}\n \tbh_lock_sock(sk);\n \tif (!sock_owned_by_user(sk))\n \t\tudpv6_queue_rcv_skb(sk, skb);\ndiff --git a\/net\/sctp\/socket.c b\/net\/sctp\/socket.c\nindex f34adcca8a8c..13d8229f3a9c 100644\n--- a\/net\/sctp\/socket.c\n+++ b\/net\/sctp\/socket.c\n@@ -3721,9 +3721,6 @@ SCTP_STATIC int sctp_init_sock(struct sock *sk)\n \tSCTP_DBG_OBJCNT_INC(sock);\n \tpercpu_counter_inc(&sctp_sockets_allocated);\n \n-\t\/* Set socket backlog limit. *\/\n-\tsk->sk_backlog.limit = sysctl_sctp_rmem[1];\n-\n \tlocal_bh_disable();\n \tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n \tlocal_bh_enable();\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-16641","CWE_ID":"399","category":"security","commit_id":"256825d4eb33dc301496710d15cf5a7ae924088b","commit_message":"From 256825d4eb33dc301496710d15cf5a7ae924088b Mon Sep 17 00:00:00 2001\nFrom: Dirk Lemstra <dirk@git.imagemagick.org>\nDate: Sat, 14 Jul 2018 17:02:15 +0200\nSubject: [PATCH] Fixed possible memory leak reported in #1206\n\n---\n coders\/tiff.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/coders\/tiff.c b\/coders\/tiff.c\nindex 2a042cbb5a..b6419c6c4a 100644\n--- a\/coders\/tiff.c\n+++ b\/coders\/tiff.c\n@@ -3128,6 +3128,7 @@ static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n   layers=AcquireStringInfo(profile.quantum);\n   if (layers == (StringInfo *) NULL)\n     {\n+      base_image=DestroyImage(base_image);\n       clone_info=DestroyImageInfo(clone_info);\n       ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n         image->filename);\n@@ -3137,6 +3138,7 @@ static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n   custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n   if (custom_stream == (CustomStreamInfo *) NULL)\n     {\n+      base_image=DestroyImage(base_image);\n       clone_info=DestroyImageInfo(clone_info);\n       layers=DestroyStringInfo(layers);\n       ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n@@ -3145,6 +3147,7 @@ static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n   blob=CloneBlobInfo((BlobInfo *) NULL);\n   if (blob == (BlobInfo *) NULL)\n     {\n+      base_image=DestroyImage(base_image);\n       clone_info=DestroyImageInfo(clone_info);\n       layers=DestroyStringInfo(layers);\n       custom_stream=DestroyCustomStreamInfo(custom_stream);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2015-6526","CWE_ID":"399","category":"security","commit_id":"9a5cbce421a283e6aea3c4007f141735bf9da8c3","commit_message":"From 9a5cbce421a283e6aea3c4007f141735bf9da8c3 Mon Sep 17 00:00:00 2001\nFrom: Anton Blanchard <anton@samba.org>\nDate: Tue, 14 Apr 2015 07:51:03 +1000\nSubject: powerpc\/perf: Cap 64bit userspace backtraces to PERF_MAX_STACK_DEPTH\n\nWe cap 32bit userspace backtraces to PERF_MAX_STACK_DEPTH\n(currently 127), but we forgot to do the same for 64bit backtraces.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Anton Blanchard <anton@samba.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\n---\n arch\/powerpc\/perf\/callchain.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/powerpc\/perf\/callchain.c b\/arch\/powerpc\/perf\/callchain.c\nindex 2396dda282cd..ead55351b254 100644\n--- a\/arch\/powerpc\/perf\/callchain.c\n+++ b\/arch\/powerpc\/perf\/callchain.c\n@@ -243,7 +243,7 @@ static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n \tsp = regs->gpr[1];\n \tperf_callchain_store(entry, next_ip);\n \n-\tfor (;;) {\n+\twhile (entry->nr < PERF_MAX_STACK_DEPTH) {\n \t\tfp = (unsigned long __user *) sp;\n \t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n \t\t\treturn;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-7021","CWE_ID":"399","category":"security","commit_id":"cdd5df8189ff1537f7abe8defe971f80602cc2d2","commit_message":"From cdd5df8189ff1537f7abe8defe971f80602cc2d2 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Mon, 2 Sep 2013 04:32:23 +0200\nSubject: [PATCH] avfilter\/vf_fps: make sure the fifo is not empty before using\n it\n\nFixes Ticket2905\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavfilter\/vf_fps.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavfilter\/vf_fps.c b\/libavfilter\/vf_fps.c\nindex 4eb3663b1a4..06ebdfadce6 100644\n--- a\/libavfilter\/vf_fps.c\n+++ b\/libavfilter\/vf_fps.c\n@@ -205,7 +205,7 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *buf)\n     }\n \n     \/* now wait for the next timestamp *\/\n-    if (buf->pts == AV_NOPTS_VALUE) {\n+    if (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) {\n         return write_to_fifo(s->fifo, buf);\n     }\n \n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2016-2550","CWE_ID":"399","category":"security","commit_id":"415e3d3e90ce9e18727e8843ae343eda5a58fad6","commit_message":"From 415e3d3e90ce9e18727e8843ae343eda5a58fad6 Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Wed, 3 Feb 2016 02:11:03 +0100\nSubject: [PATCH] unix: correctly track in-flight fds in sending process\n user_struct\n\nThe commit referenced in the Fixes tag incorrectly accounted the number\nof in-flight fds over a unix domain socket to the original opener\nof the file-descriptor. This allows another process to arbitrary\ndeplete the original file-openers resource limit for the maximum of\nopen files. Instead the sending processes and its struct cred should\nbe credited.\n\nTo do so, we add a reference counted struct user_struct pointer to the\nscm_fp_list and use it to account for the number of inflight unix fds.\n\nFixes: 712f4aad406bb1 (\"unix: properly account for FDs passed over unix sockets\")\nReported-by: David Herrmann <dh.herrmann@gmail.com>\nCc: David Herrmann <dh.herrmann@gmail.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/af_unix.h | 4 ++--\n include\/net\/scm.h     | 1 +\n net\/core\/scm.c        | 7 +++++++\n net\/unix\/af_unix.c    | 4 ++--\n net\/unix\/garbage.c    | 8 ++++----\n 5 files changed, 16 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/af_unix.h b\/include\/net\/af_unix.h\nindex 2a91a0561a478..9b4c418bebd84 100644\n--- a\/include\/net\/af_unix.h\n+++ b\/include\/net\/af_unix.h\n@@ -6,8 +6,8 @@\n #include <linux\/mutex.h>\n #include <net\/sock.h>\n \n-void unix_inflight(struct file *fp);\n-void unix_notinflight(struct file *fp);\n+void unix_inflight(struct user_struct *user, struct file *fp);\n+void unix_notinflight(struct user_struct *user, struct file *fp);\n void unix_gc(void);\n void wait_for_unix_gc(void);\n struct sock *unix_get_socket(struct file *filp);\ndiff --git a\/include\/net\/scm.h b\/include\/net\/scm.h\nindex 262532d111f51..59fa93c01d2a1 100644\n--- a\/include\/net\/scm.h\n+++ b\/include\/net\/scm.h\n@@ -21,6 +21,7 @@ struct scm_creds {\n struct scm_fp_list {\n \tshort\t\t\tcount;\n \tshort\t\t\tmax;\n+\tstruct user_struct\t*user;\n \tstruct file\t\t*fp[SCM_MAX_FD];\n };\n \ndiff --git a\/net\/core\/scm.c b\/net\/core\/scm.c\nindex 14596fb371727..2696aefdc1488 100644\n--- a\/net\/core\/scm.c\n+++ b\/net\/core\/scm.c\n@@ -87,6 +87,7 @@ static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n \t\t*fplp = fpl;\n \t\tfpl->count = 0;\n \t\tfpl->max = SCM_MAX_FD;\n+\t\tfpl->user = NULL;\n \t}\n \tfpp = &fpl->fp[fpl->count];\n \n@@ -107,6 +108,10 @@ static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n \t\t*fpp++ = file;\n \t\tfpl->count++;\n \t}\n+\n+\tif (!fpl->user)\n+\t\tfpl->user = get_uid(current_user());\n+\n \treturn num;\n }\n \n@@ -119,6 +124,7 @@ void __scm_destroy(struct scm_cookie *scm)\n \t\tscm->fp = NULL;\n \t\tfor (i=fpl->count-1; i>=0; i--)\n \t\t\tfput(fpl->fp[i]);\n+\t\tfree_uid(fpl->user);\n \t\tkfree(fpl);\n \t}\n }\n@@ -336,6 +342,7 @@ struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n \t\tfor (i = 0; i < fpl->count; i++)\n \t\t\tget_file(fpl->fp[i]);\n \t\tnew_fpl->max = new_fpl->count;\n+\t\tnew_fpl->user = get_uid(fpl->user);\n \t}\n \treturn new_fpl;\n }\ndiff --git a\/net\/unix\/af_unix.c b\/net\/unix\/af_unix.c\nindex 49d5093eb0553..29be035f9c650 100644\n--- a\/net\/unix\/af_unix.c\n+++ b\/net\/unix\/af_unix.c\n@@ -1496,7 +1496,7 @@ static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n \tUNIXCB(skb).fp = NULL;\n \n \tfor (i = scm->fp->count-1; i >= 0; i--)\n-\t\tunix_notinflight(scm->fp->fp[i]);\n+\t\tunix_notinflight(scm->fp->user, scm->fp->fp[i]);\n }\n \n static void unix_destruct_scm(struct sk_buff *skb)\n@@ -1561,7 +1561,7 @@ static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n \t\treturn -ENOMEM;\n \n \tfor (i = scm->fp->count - 1; i >= 0; i--)\n-\t\tunix_inflight(scm->fp->fp[i]);\n+\t\tunix_inflight(scm->fp->user, scm->fp->fp[i]);\n \treturn max_level;\n }\n \ndiff --git a\/net\/unix\/garbage.c b\/net\/unix\/garbage.c\nindex 8fcdc2283af50..6a0d48525fcf9 100644\n--- a\/net\/unix\/garbage.c\n+++ b\/net\/unix\/garbage.c\n@@ -116,7 +116,7 @@ struct sock *unix_get_socket(struct file *filp)\n  * descriptor if it is for an AF_UNIX socket.\n  *\/\n \n-void unix_inflight(struct file *fp)\n+void unix_inflight(struct user_struct *user, struct file *fp)\n {\n \tstruct sock *s = unix_get_socket(fp);\n \n@@ -133,11 +133,11 @@ void unix_inflight(struct file *fp)\n \t\t}\n \t\tunix_tot_inflight++;\n \t}\n-\tfp->f_cred->user->unix_inflight++;\n+\tuser->unix_inflight++;\n \tspin_unlock(&unix_gc_lock);\n }\n \n-void unix_notinflight(struct file *fp)\n+void unix_notinflight(struct user_struct *user, struct file *fp)\n {\n \tstruct sock *s = unix_get_socket(fp);\n \n@@ -152,7 +152,7 @@ void unix_notinflight(struct file *fp)\n \t\t\tlist_del_init(&u->link);\n \t\tunix_tot_inflight--;\n \t}\n-\tfp->f_cred->user->unix_inflight--;\n+\tuser->unix_inflight--;\n \tspin_unlock(&unix_gc_lock);\n }\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-8577","CWE_ID":"399","category":"security","commit_id":"e95c9a493a5a8d6f969e86c9f19f80ffe6587e19","commit_message":"From e95c9a493a5a8d6f969e86c9f19f80ffe6587e19 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Mon, 17 Oct 2016 14:13:58 +0200\nSubject: [PATCH] 9pfs: fix potential host memory leak in v9fs_read\n\nIn 9pfs read dispatch function, it doesn't free two QEMUIOVector\nobject thus causing potential memory leak. This patch avoid this.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Greg Kurz <groug@kaod.org>\n---\n hw\/9pfs\/9p.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/hw\/9pfs\/9p.c b\/hw\/9pfs\/9p.c\nindex 39a7e1d..ff94a62 100644\n--- a\/hw\/9pfs\/9p.c\n+++ b\/hw\/9pfs\/9p.c\n@@ -1826,14 +1826,15 @@ static void v9fs_read(void *opaque)\n             if (len < 0) {\n                 \/* IO error return the error *\/\n                 err = len;\n-                goto out;\n+                goto out_free_iovec;\n             }\n         } while (count < max_count && len > 0);\n         err = pdu_marshal(pdu, offset, \"d\", count);\n         if (err < 0) {\n-            goto out;\n+            goto out_free_iovec;\n         }\n         err += offset + count;\n+out_free_iovec:\n         qemu_iovec_destroy(&qiov);\n         qemu_iovec_destroy(&qiov_full);\n     } else if (fidp->fid_type == P9_FID_XATTR) {\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-16640","CWE_ID":"399","category":"security","commit_id":"76efa969342568841ecf320b5a041685a6d24e0b","commit_message":"From 76efa969342568841ecf320b5a041685a6d24e0b Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sat, 7 Jul 2018 07:27:47 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1201\n\n---\n coders\/png.c | 19 +++++++++++--------\n configure    | 26 +++++++++++++-------------\n 2 files changed, 24 insertions(+), 21 deletions(-)\n\n","diff_code":"diff --git a\/coders\/png.c b\/coders\/png.c\nindex b3ecd890be..d811544e31 100644\n--- a\/coders\/png.c\n+++ b\/coders\/png.c\n@@ -4560,7 +4560,11 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,\n         chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n \n         if (chunk == (unsigned char *) NULL)\n-          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+          {\n+            DestroyJNG(NULL,&color_image,&color_image_info,\n+              &alpha_image,&alpha_image_info);\n+            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+          }\n \n         for (i=0; i < (ssize_t) length; i++)\n         {\n@@ -4587,13 +4591,12 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,\n             jng_width=(png_uint_32)mng_get_long(p);\n             jng_height=(png_uint_32)mng_get_long(&p[4]);\n             if ((jng_width == 0) || (jng_height == 0))\n-            {\n-              DestroyJNG(chunk,&color_image,&color_image_info,\n-                &alpha_image,&alpha_image_info);\n-\n-              ThrowReaderException(CorruptImageError,\n-                \"NegativeOrZeroImageSize\");\n-            }\n+              {\n+                DestroyJNG(chunk,&color_image,&color_image_info,\n+                  &alpha_image,&alpha_image_info);\n+                ThrowReaderException(CorruptImageError,\n+                  \"NegativeOrZeroImageSize\");\n+              }\n             jng_color_type=p[8];\n             jng_image_sample_depth=p[9];\n             jng_image_compression_method=p[10];\ndiff --git a\/configure b\/configure\nindex f44c15ac0a..2bc5726fab 100755\n--- a\/configure\n+++ b\/configure\n@@ -1,6 +1,6 @@\n #! \/bin\/sh\n # Guess values for system-dependent variables and create Makefiles.\n-# Generated by GNU Autoconf 2.69 for ImageMagick 7.0.8-5.\n+# Generated by GNU Autoconf 2.69 for ImageMagick 7.0.8-6.\n #\n # Report bugs to <https:\/\/github.com\/ImageMagick\/ImageMagick\/issues>.\n #\n@@ -590,8 +590,8 @@ MAKEFLAGS=\n # Identity of this package.\n PACKAGE_NAME='ImageMagick'\n PACKAGE_TARNAME='ImageMagick'\n-PACKAGE_VERSION='7.0.8-5'\n-PACKAGE_STRING='ImageMagick 7.0.8-5'\n+PACKAGE_VERSION='7.0.8-6'\n+PACKAGE_STRING='ImageMagick 7.0.8-6'\n PACKAGE_BUGREPORT='https:\/\/github.com\/ImageMagick\/ImageMagick\/issues'\n PACKAGE_URL='https:\/\/www.imagemagick.org'\n \n@@ -1842,7 +1842,7 @@ if test \"$ac_init_help\" = \"long\"; then\n   # Omit some internal or obsolete options to make the list less imposing.\n   # This message is too long to be a string in the A\/UX 3.1 sh.\n   cat <<_ACEOF\n-\\`configure' configures ImageMagick 7.0.8-5 to adapt to many kinds of systems.\n+\\`configure' configures ImageMagick 7.0.8-6 to adapt to many kinds of systems.\n \n Usage: $0 [OPTION]... [VAR=VALUE]...\n \n@@ -1917,7 +1917,7 @@ fi\n \n if test -n \"$ac_init_help\"; then\n   case $ac_init_help in\n-     short | recursive ) echo \"Configuration of ImageMagick 7.0.8-5:\";;\n+     short | recursive ) echo \"Configuration of ImageMagick 7.0.8-6:\";;\n    esac\n   cat <<\\_ACEOF\n \n@@ -2204,7 +2204,7 @@ fi\n test -n \"$ac_init_help\" && exit $ac_status\n if $ac_init_version; then\n   cat <<\\_ACEOF\n-ImageMagick configure 7.0.8-5\n+ImageMagick configure 7.0.8-6\n generated by GNU Autoconf 2.69\n \n Copyright (C) 2012 Free Software Foundation, Inc.\n@@ -3255,7 +3255,7 @@ cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n \n-It was created by ImageMagick $as_me 7.0.8-5, which was\n+It was created by ImageMagick $as_me 7.0.8-6, which was\n generated by GNU Autoconf 2.69.  Invocation command line was\n \n   $ $0 $@\n@@ -4241,7 +4241,7 @@ fi\n \n # Define the identity of the package.\n  PACKAGE='ImageMagick'\n- VERSION='7.0.8-5'\n+ VERSION='7.0.8-6'\n \n \n cat >>confdefs.h <<_ACEOF\n@@ -4551,11 +4551,11 @@ MAGICK_MINOR_VERSION=0\n \n MAGICK_MICRO_VERSION=8\n \n-MAGICK_PATCHLEVEL_VERSION=5\n+MAGICK_PATCHLEVEL_VERSION=6\n \n-MAGICK_VERSION=7.0.8-5\n+MAGICK_VERSION=7.0.8-6\n \n-MAGICK_GIT_REVISION=14506:0e75f0a50:20180703\n+MAGICK_GIT_REVISION=14516:c7537dd70:20180705\n \n \n # Substitute library versioning\n@@ -37632,7 +37632,7 @@ cat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n # report actual input values of CONFIG_FILES etc. instead of their\n # values after options handling.\n ac_log=\"\n-This file was extended by ImageMagick $as_me 7.0.8-5, which was\n+This file was extended by ImageMagick $as_me 7.0.8-6, which was\n generated by GNU Autoconf 2.69.  Invocation command line was\n \n   CONFIG_FILES    = $CONFIG_FILES\n@@ -37699,7 +37699,7 @@ _ACEOF\n cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n ac_cs_config=\"`$as_echo \"$ac_configure_args\" | sed 's\/^ \/\/; s\/[\\\\\"\"\\`\\$]\/\\\\\\\\&\/g'`\"\n ac_cs_version=\"\\\\\n-ImageMagick config.status 7.0.8-5\n+ImageMagick config.status 7.0.8-6\n configured by $0, generated by GNU Autoconf 2.69,\n   with options \\\\\"\\$ac_cs_config\\\\\"\n \n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-14055","CWE_ID":"399","category":"security","commit_id":"4f05e2e2dc1a89f38cd9f0960a6561083d714f1e","commit_message":"From 4f05e2e2dc1a89f38cd9f0960a6561083d714f1e Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Fri, 25 Aug 2017 01:15:30 +0200\nSubject: [PATCH] avformat\/mvdec: Fix DoS due to lack of eof check\n\nFixes: loop.mv\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/mvdec.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/libavformat\/mvdec.c b\/libavformat\/mvdec.c\nindex 0e12c8c6c18..f7aa4cbaecf 100644\n--- a\/libavformat\/mvdec.c\n+++ b\/libavformat\/mvdec.c\n@@ -342,6 +342,8 @@ static int mv_read_header(AVFormatContext *avctx)\n             uint32_t pos   = avio_rb32(pb);\n             uint32_t asize = avio_rb32(pb);\n             uint32_t vsize = avio_rb32(pb);\n+            if (avio_feof(pb))\n+                return AVERROR_INVALIDDATA;\n             avio_skip(pb, 8);\n             av_add_index_entry(ast, pos, timestamp, asize, 0, AVINDEX_KEYFRAME);\n             av_add_index_entry(vst, pos + asize, i, vsize, 0, AVINDEX_KEYFRAME);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2016-10153","CWE_ID":"399","category":"security","commit_id":"a45f795c65b479b4ba107b6ccde29b896d51ee98","commit_message":"From a45f795c65b479b4ba107b6ccde29b896d51ee98 Mon Sep 17 00:00:00 2001\nFrom: Ilya Dryomov <idryomov@gmail.com>\nDate: Fri, 2 Dec 2016 16:35:07 +0100\nSubject: libceph: introduce ceph_crypt() for in-place en\/decryption\n\nStarting with 4.9, kernel stacks may be vmalloced and therefore not\nguaranteed to be physically contiguous; the new CONFIG_VMAP_STACK\noption is enabled by default on x86.  This makes it invalid to use\non-stack buffers with the crypto scatterlist API, as sg_set_buf()\nexpects a logical address and won't work with vmalloced addresses.\n\nThere isn't a different (e.g. kvec-based) crypto API we could switch\nnet\/ceph\/crypto.c to and the current scatterlist.h API isn't getting\nupdated to accommodate this use case.  Allocating a new header and\npadding for each operation is a non-starter, so do the en\/decryption\nin-place on a single pre-assembled (header + data + padding) heap\nbuffer.  This is explicitly supported by the crypto API:\n\n    \"... the caller may provide the same scatter\/gather list for the\n     plaintext and cipher text. After the completion of the cipher\n     operation, the plaintext data is replaced with the ciphertext data\n     in case of an encryption and vice versa for a decryption.\"\n\nSigned-off-by: Ilya Dryomov <idryomov@gmail.com>\nReviewed-by: Sage Weil <sage@redhat.com>\n---\n net\/ceph\/crypto.c | 87 +++++++++++++++++++++++++++++++++++++++++++++++++++++++\n net\/ceph\/crypto.h |  2 ++\n 2 files changed, 89 insertions(+)\n\n","diff_code":"diff --git a\/net\/ceph\/crypto.c b\/net\/ceph\/crypto.c\nindex db2847ac5f12..32099c5c4c75 100644\n--- a\/net\/ceph\/crypto.c\n+++ b\/net\/ceph\/crypto.c\n@@ -526,6 +526,93 @@ int ceph_encrypt2(struct ceph_crypto_key *secret, void *dst, size_t *dst_len,\n \t}\n }\n \n+static int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,\n+\t\t\t  void *buf, int buf_len, int in_len, int *pout_len)\n+{\n+\tstruct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();\n+\tSKCIPHER_REQUEST_ON_STACK(req, tfm);\n+\tstruct sg_table sgt;\n+\tstruct scatterlist prealloc_sg;\n+\tchar iv[AES_BLOCK_SIZE];\n+\tint pad_byte = AES_BLOCK_SIZE - (in_len & (AES_BLOCK_SIZE - 1));\n+\tint crypt_len = encrypt ? in_len + pad_byte : in_len;\n+\tint ret;\n+\n+\tif (IS_ERR(tfm))\n+\t\treturn PTR_ERR(tfm);\n+\n+\tWARN_ON(crypt_len > buf_len);\n+\tif (encrypt)\n+\t\tmemset(buf + in_len, pad_byte, pad_byte);\n+\tret = setup_sgtable(&sgt, &prealloc_sg, buf, crypt_len);\n+\tif (ret)\n+\t\tgoto out_tfm;\n+\n+\tcrypto_skcipher_setkey((void *)tfm, key->key, key->len);\n+\tmemcpy(iv, aes_iv, AES_BLOCK_SIZE);\n+\n+\tskcipher_request_set_tfm(req, tfm);\n+\tskcipher_request_set_callback(req, 0, NULL, NULL);\n+\tskcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);\n+\n+\t\/*\n+\tprint_hex_dump(KERN_ERR, \"key: \", DUMP_PREFIX_NONE, 16, 1,\n+\t\t       key->key, key->len, 1);\n+\tprint_hex_dump(KERN_ERR, \" in: \", DUMP_PREFIX_NONE, 16, 1,\n+\t\t       buf, crypt_len, 1);\n+\t*\/\n+\tif (encrypt)\n+\t\tret = crypto_skcipher_encrypt(req);\n+\telse\n+\t\tret = crypto_skcipher_decrypt(req);\n+\tskcipher_request_zero(req);\n+\tif (ret) {\n+\t\tpr_err(\"%s %scrypt failed: %d\\n\", __func__,\n+\t\t       encrypt ? \"en\" : \"de\", ret);\n+\t\tgoto out_sgt;\n+\t}\n+\t\/*\n+\tprint_hex_dump(KERN_ERR, \"out: \", DUMP_PREFIX_NONE, 16, 1,\n+\t\t       buf, crypt_len, 1);\n+\t*\/\n+\n+\tif (encrypt) {\n+\t\t*pout_len = crypt_len;\n+\t} else {\n+\t\tpad_byte = *(char *)(buf + in_len - 1);\n+\t\tif (pad_byte > 0 && pad_byte <= AES_BLOCK_SIZE &&\n+\t\t    in_len >= pad_byte) {\n+\t\t\t*pout_len = in_len - pad_byte;\n+\t\t} else {\n+\t\t\tpr_err(\"%s got bad padding %d on in_len %d\\n\",\n+\t\t\t       __func__, pad_byte, in_len);\n+\t\t\tret = -EPERM;\n+\t\t\tgoto out_sgt;\n+\t\t}\n+\t}\n+\n+out_sgt:\n+\tteardown_sgtable(&sgt);\n+out_tfm:\n+\tcrypto_free_skcipher(tfm);\n+\treturn ret;\n+}\n+\n+int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,\n+\t       void *buf, int buf_len, int in_len, int *pout_len)\n+{\n+\tswitch (key->type) {\n+\tcase CEPH_CRYPTO_NONE:\n+\t\t*pout_len = in_len;\n+\t\treturn 0;\n+\tcase CEPH_CRYPTO_AES:\n+\t\treturn ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,\n+\t\t\t\t      pout_len);\n+\tdefault:\n+\t\treturn -ENOTSUPP;\n+\t}\n+}\n+\n static int ceph_key_preparse(struct key_preparsed_payload *prep)\n {\n \tstruct ceph_crypto_key *ckey;\ndiff --git a\/net\/ceph\/crypto.h b\/net\/ceph\/crypto.h\nindex 2e9cab09f37b..73da34e8c62e 100644\n--- a\/net\/ceph\/crypto.h\n+++ b\/net\/ceph\/crypto.h\n@@ -43,6 +43,8 @@ int ceph_encrypt2(struct ceph_crypto_key *secret,\n \t\t  void *dst, size_t *dst_len,\n \t\t  const void *src1, size_t src1_len,\n \t\t  const void *src2, size_t src2_len);\n+int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,\n+\t       void *buf, int buf_len, int in_len, int *pout_len);\n int ceph_crypto_init(void);\n void ceph_crypto_shutdown(void);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2009-3613","CWE_ID":"399","category":"security","commit_id":"a866bbf6aacf95f849810079442a20be118ce905","commit_message":"From a866bbf6aacf95f849810079442a20be118ce905 Mon Sep 17 00:00:00 2001\nFrom: Francois Romieu <romieu@fr.zoreil.com>\nDate: Tue, 26 Aug 2008 21:56:06 +0200\nSubject: r8169: balance pci_map \/ pci_unmap pair\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe leak hurts with swiotlb and jumbo frames.\n\nFix http:\/\/bugzilla.kernel.org\/show_bug.cgi?id=9468.\n\nHeavily hinted by Ilpo J\u00e4rvinen <ilpo.jarvinen@helsinki.fi>.\n\nSigned-off-by: Francois Romieu <romieu@fr.zoreil.com>\nTested-by: Alistair John Strachan <alistair@devzero.co.uk>\nTested-by: Timothy J Fontaine <tjfontaine@atxconsulting.com>\nCc: Edward Hsu <edward_hsu@realtek.com.tw>\nSigned-off-by: Jeff Garzik <jgarzik@redhat.com>\n---\n drivers\/net\/r8169.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/net\/r8169.c b\/drivers\/net\/r8169.c\nindex a3e3895e5032..0f6f9747d255 100644\n--- a\/drivers\/net\/r8169.c\n+++ b\/drivers\/net\/r8169.c\n@@ -2792,7 +2792,7 @@ static int rtl8169_rx_interrupt(struct net_device *dev,\n \t\t\t\t\tpkt_size, PCI_DMA_FROMDEVICE);\n \t\t\t\trtl8169_mark_to_asic(desc, tp->rx_buf_sz);\n \t\t\t} else {\n-\t\t\t\tpci_unmap_single(pdev, addr, pkt_size,\n+\t\t\t\tpci_unmap_single(pdev, addr, tp->rx_buf_sz,\n \t\t\t\t\t\t PCI_DMA_FROMDEVICE);\n \t\t\t\ttp->Rx_skbuff[entry] = NULL;\n \t\t\t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-6638","CWE_ID":"399","category":"security","commit_id":"fdf5af0daf8019cec2396cdef8fb042d80fe71fa","commit_message":"From fdf5af0daf8019cec2396cdef8fb042d80fe71fa Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <eric.dumazet@gmail.com>\nDate: Fri, 2 Dec 2011 23:41:42 +0000\nSubject: tcp: drop SYN+FIN messages\n\nDenys Fedoryshchenko reported that SYN+FIN attacks were bringing his\nlinux machines to their limits.\n\nDont call conn_request() if the TCP flags includes SYN flag\n\nReported-by: Denys Fedoryshchenko <denys@visp.net.lb>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp_input.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/net\/ipv4\/tcp_input.c b\/net\/ipv4\/tcp_input.c\nindex 78dd38cd5496..0cbb44076cfa 100644\n--- a\/net\/ipv4\/tcp_input.c\n+++ b\/net\/ipv4\/tcp_input.c\n@@ -5811,6 +5811,8 @@ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n \t\t\tgoto discard;\n \n \t\tif (th->syn) {\n+\t\t\tif (th->fin)\n+\t\t\t\tgoto discard;\n \t\t\tif (icsk->icsk_af_ops->conn_request(sk, skb) < 0)\n \t\t\t\treturn 1;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-2390","CWE_ID":"399","category":"security","commit_id":"c50ac050811d6485616a193eb0f37bfbd191cc89","commit_message":"From c50ac050811d6485616a193eb0f37bfbd191cc89 Mon Sep 17 00:00:00 2001\nFrom: Dave Hansen <dave@linux.vnet.ibm.com>\nDate: Tue, 29 May 2012 15:06:46 -0700\nSubject: [PATCH] hugetlb: fix resv_map leak in error path\n\nWhen called for anonymous (non-shared) mappings, hugetlb_reserve_pages()\ndoes a resv_map_alloc().  It depends on code in hugetlbfs's\nvm_ops->close() to release that allocation.\n\nHowever, in the mmap() failure path, we do a plain unmap_region() without\nthe remove_vma() which actually calls vm_ops->close().\n\nThis is a decent fix.  This leak could get reintroduced if new code (say,\nafter hugetlb_reserve_pages() in hugetlbfs_file_mmap()) decides to return\nan error.  But, I think it would have to unroll the reservation anyway.\n\nChristoph's test case:\n\n\thttp:\/\/marc.info\/?l=linux-mm&m=133728900729735\n\nThis patch applies to 3.4 and later.  A version for earlier kernels is at\nhttps:\/\/lkml.org\/lkml\/2012\/5\/22\/418.\n\nSigned-off-by: Dave Hansen <dave@linux.vnet.ibm.com>\nAcked-by: Mel Gorman <mel@csn.ul.ie>\nAcked-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nReported-by: Christoph Lameter <cl@linux.com>\nTested-by: Christoph Lameter <cl@linux.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\t[2.6.32+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/hugetlb.c | 28 ++++++++++++++++++++++------\n 1 file changed, 22 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/mm\/hugetlb.c b\/mm\/hugetlb.c\nindex 41a647dfb7381..285a81e87ec85 100644\n--- a\/mm\/hugetlb.c\n+++ b\/mm\/hugetlb.c\n@@ -2157,6 +2157,15 @@ static void hugetlb_vm_op_open(struct vm_area_struct *vma)\n \t\tkref_get(&reservations->refs);\n }\n \n+static void resv_map_put(struct vm_area_struct *vma)\n+{\n+\tstruct resv_map *reservations = vma_resv_map(vma);\n+\n+\tif (!reservations)\n+\t\treturn;\n+\tkref_put(&reservations->refs, resv_map_release);\n+}\n+\n static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n {\n \tstruct hstate *h = hstate_vma(vma);\n@@ -2173,7 +2182,7 @@ static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n \t\treserve = (end - start) -\n \t\t\tregion_count(&reservations->regions, start, end);\n \n-\t\tkref_put(&reservations->refs, resv_map_release);\n+\t\tresv_map_put(vma);\n \n \t\tif (reserve) {\n \t\t\thugetlb_acct_memory(h, -reserve);\n@@ -2991,12 +3000,16 @@ int hugetlb_reserve_pages(struct inode *inode,\n \t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n \t}\n \n-\tif (chg < 0)\n-\t\treturn chg;\n+\tif (chg < 0) {\n+\t\tret = chg;\n+\t\tgoto out_err;\n+\t}\n \n \t\/* There must be enough pages in the subpool for the mapping *\/\n-\tif (hugepage_subpool_get_pages(spool, chg))\n-\t\treturn -ENOSPC;\n+\tif (hugepage_subpool_get_pages(spool, chg)) {\n+\t\tret = -ENOSPC;\n+\t\tgoto out_err;\n+\t}\n \n \t\/*\n \t * Check enough hugepages are available for the reservation.\n@@ -3005,7 +3018,7 @@ int hugetlb_reserve_pages(struct inode *inode,\n \tret = hugetlb_acct_memory(h, chg);\n \tif (ret < 0) {\n \t\thugepage_subpool_put_pages(spool, chg);\n-\t\treturn ret;\n+\t\tgoto out_err;\n \t}\n \n \t\/*\n@@ -3022,6 +3035,9 @@ int hugetlb_reserve_pages(struct inode *inode,\n \tif (!vma || vma->vm_flags & VM_MAYSHARE)\n \t\tregion_add(&inode->i_mapping->private_list, from, to);\n \treturn 0;\n+out_err:\n+\tresv_map_put(vma);\n+\treturn ret;\n }\n \n void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-3697","CWE_ID":"399","category":"security","commit_id":"ff94dd35673bba1476594299d31ce8293b8bd223","commit_message":"From ff94dd35673bba1476594299d31ce8293b8bd223 Mon Sep 17 00:00:00 2001\nFrom: \"Alan T. DeKok\" <aland@freeradius.org>\nDate: Wed, 30 Jun 2010 21:58:27 +0200\nSubject: [PATCH] Do not delete \"old\" requests until they are free.\n\nIf the request is in the queue for 30+ seconds, do NOT delete it.\nInstead, mark it as \"STOP PROCESSING\", and do \"wait_for_child_to_die\",\nwhich waits for a child thread to pick it up, and acknowledge that it's\ndone.  Once it's marked done, we can finally clean it up.\n\nThis may be the underlying issue behind bug #35\n---\n src\/main\/event.c | 66 +++++++++++++++++++++++++-----------------------\n 1 file changed, 34 insertions(+), 32 deletions(-)\n\n","diff_code":"diff --git a\/src\/main\/event.c b\/src\/main\/event.c\nindex e3b32a89d5..6ed7847f32 100644\n--- a\/src\/main\/event.c\n+++ b\/src\/main\/event.c\n@@ -479,6 +479,7 @@ static void wait_for_child_to_die(void *ctx)\n \tREQUEST *request = ctx;\n \n \trad_assert(request->magic == REQUEST_MAGIC);\n+\tremove_from_request_hash(request);\n \n \t\/*\n \t *\tIf it's still queued (waiting for a thread to pick it\n@@ -490,14 +491,15 @@ static void wait_for_child_to_die(void *ctx)\n \t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n \n \t\t\/*\n-\t\t *\tCap delay at five minutes.\n+\t\t *\tCap delay at max_request_time\n \t\t *\/\n-\t\tif (request->delay < (USEC * 60 * 5)) {\n+\t\tif (request->delay < (USEC * request->root->max_request_time)) {\n \t\t\trequest->delay += (request->delay >> 1);\n \t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n \t\t\t       request->number, request->component, request->module);\n \t\t} else {\n-\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n+\t\t\trequest->delay = USEC * request->root->max_request_time;\n+\t\t\tRDEBUG2(\"WARNING: Child is still stuck for request %u\",\n \t\t\t\trequest->number);\n \t\t}\n \t\ttv_add(&request->when, request->delay);\n@@ -507,7 +509,6 @@ static void wait_for_child_to_die(void *ctx)\n \t}\n \n \tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n-\tremove_from_request_hash(request);\n \n #ifdef WITH_PROXY\n \tif (request->proxy) {\n@@ -1140,6 +1141,25 @@ static void wait_a_bit(void *ctx)\n \tswitch (request->child_state) {\n \tcase REQUEST_QUEUED:\n \tcase REQUEST_RUNNING:\n+\t\t\/*\n+\t\t *\tIf we're not thread-capable, OR we're capable,\n+\t\t *\tbut have been told to run without threads,\n+\t\t *\tcomplain when the requests is queued for a\n+\t\t *\tthread, or running in a child thread.\n+\t\t *\/\n+#ifdef HAVE_PTHREAD_H\n+\t\tif (!have_children)\n+#endif\n+\t\t{\n+\t\t\trad_assert(\"We do not have threads, but the request is marked as queued or running in a child thread\" == NULL);\n+\t\t\tbreak;\n+\t\t}\n+\n+#ifdef HAVE_PTHREAD_H\n+\t\t\/*\n+\t\t *\tIf we have threads, wait for the child thread\n+\t\t *\tto stop.\n+\t\t *\/\n \t\twhen = request->received;\n \t\twhen.tv_sec += request->root->max_request_time;\n \n@@ -1156,24 +1176,18 @@ static void wait_a_bit(void *ctx)\n \t\t *\tRequest still has more time.  Continue\n \t\t *\twaiting.\n \t\t *\/\n-\t\tif (timercmp(&now, &when, <) ||\n-\t\t    ((request->listener->type == RAD_LISTEN_DETAIL) &&\n-\t\t     (request->child_state == REQUEST_QUEUED))) {\n+\t\tif (timercmp(&now, &when, <)) {\n \t\t\tif (request->delay < (USEC \/ 10)) {\n \t\t\t\trequest->delay = USEC \/ 10;\n \t\t\t}\n \t\t\trequest->delay += request->delay >> 1;\n \n-#ifdef WITH_DETAIL\n \t\t\t\/*\n-\t\t\t *\tCap wait at some sane value for detail\n-\t\t\t *\tfiles.\n+\t\t\t *\tCap delays at something reasonable.\n \t\t\t *\/\n-\t\t\tif ((request->listener->type == RAD_LISTEN_DETAIL) &&\n-\t\t\t    (request->delay > (request->root->max_request_time * USEC))) {\n+\t\t\tif (request->delay > (request->root->max_request_time * USEC)) {\n \t\t\t\trequest->delay = request->root->max_request_time * USEC;\n \t\t\t}\n-#endif\n \n \t\t\trequest->when = now;\n \t\t\ttv_add(&request->when, request->delay);\n@@ -1181,7 +1195,8 @@ static void wait_a_bit(void *ctx)\n \t\t\tbreak;\n \t\t}\n \n-#if defined(HAVE_PTHREAD_H)\n+\t\trequest->master_state = REQUEST_STOP_PROCESSING;\n+\n \t\t\/*\n \t\t *\tA child thread MAY still be running on the\n \t\t *\trequest.  Ask the thread to stop working on\n@@ -1189,31 +1204,18 @@ static void wait_a_bit(void *ctx)\n \t\t *\/\n \t\tif (have_children &&\n \t\t    (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0)) {\n-\t\t\trequest->master_state = REQUEST_STOP_PROCESSING;\n-\n \t\t\tradlog(L_ERR, \"WARNING: Unresponsive child for request %u, in module %s component %s\",\n \t\t\t       request->number,\n \t\t\t       request->module ? request->module : \"<server core>\",\n \t\t\t       request->component ? request->component : \"<server core>\");\n-\t\t\t\n-\t\t\trequest->delay = USEC \/ 4;\n-\t\t\ttv_add(&request->when, request->delay);\n-\t\t\tcallback = wait_for_child_to_die;\n-\t\t\tbreak;\n \t\t}\n+\t\t\t\n+\t\trequest->delay = USEC;\n+\t\ttv_add(&request->when, request->delay);\n+\t\tcallback = wait_for_child_to_die;\n+\t\tbreak;\n #endif\n \n-\t\t\/*\n-\t\t *\tElse no child thread is processing the\n-\t\t *\trequest.  We probably should have just marked\n-\t\t *\tthe request as 'done' elsewhere, like in the\n-\t\t *\tpost-proxy-fail handler.  But doing that would\n-\t\t *\tinvolve checking for max_request_time in\n-\t\t *\tmultiple places, so this may be simplest.\n-\t\t *\/\n-\t\trequest->child_state = REQUEST_DONE;\n-\t\t\/* FALL-THROUGH *\/\n-\n \t\t\/*\n \t\t *\tMark the request as no longer running,\n \t\t *\tand clean it up.\n","owner":"alandekok","repo":"freeradius-server","source":"cve"},{"CVE_ID":"CVE-2017-18258","CWE_ID":"399","category":"security","commit_id":"e2a9122b8dde53d320750451e9907a7dcb2ca8bb","commit_message":"From e2a9122b8dde53d320750451e9907a7dcb2ca8bb Mon Sep 17 00:00:00 2001\nFrom: Nick Wellnhofer <wellnhofer@aevum.de>\nDate: Thu, 7 Sep 2017 18:36:01 +0200\nSubject: [PATCH] Set memory limit for LZMA decompression\n\nOtherwise malicious LZMA compressed files could consume large amounts\nof memory when decompressed.\n\nAccording to the xz man page, files compressed with `xz -9` currently\nrequire 65 MB to decompress, so set the limit to 100 MB.\n\nShould fix bug 786696.\n---\n xzlib.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/xzlib.c b\/xzlib.c\nindex 782957f6..f43632bd 100644\n--- a\/xzlib.c\n+++ b\/xzlib.c\n@@ -408,7 +408,7 @@ xz_head(xz_statep state)\n         state->strm = init;\n         state->strm.avail_in = 0;\n         state->strm.next_in = NULL;\n-        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {\n+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {\n             xmlFree(state->out);\n             xmlFree(state->in);\n             state->size = 0;\n-- \n2.21.0\n\n","owner":"GNOME","repo":"libxml2","source":"cve"},{"CVE_ID":"CVE-2010-4251","CWE_ID":"399","category":"security","commit_id":"8eae939f1400326b06d0c9afe53d2a484a326871","commit_message":"From 8eae939f1400326b06d0c9afe53d2a484a326871 Mon Sep 17 00:00:00 2001\nFrom: Zhu Yi <yi.zhu@intel.com>\nDate: Thu, 4 Mar 2010 18:01:40 +0000\nSubject: net: add limit for socket backlog\n\nWe got system OOM while running some UDP netperf testing on the loopback\ndevice. The case is multiple senders sent stream UDP packets to a single\nreceiver via loopback on local host. Of course, the receiver is not able\nto handle all the packets in time. But we surprisingly found that these\npackets were not discarded due to the receiver's sk->sk_rcvbuf limit.\nInstead, they are kept queuing to sk->sk_backlog and finally ate up all\nthe memory. We believe this is a secure hole that a none privileged user\ncan crash the system.\n\nThe root cause for this problem is, when the receiver is doing\n__release_sock() (i.e. after userspace recv, kernel udp_recvmsg ->\nskb_free_datagram_locked -> release_sock), it moves skbs from backlog to\nsk_receive_queue with the softirq enabled. In the above case, multiple\nbusy senders will almost make it an endless loop. The skbs in the\nbacklog end up eat all the system memory.\n\nThe issue is not only for UDP. Any protocols using socket backlog is\npotentially affected. The patch adds limit for socket backlog so that\nthe backlog size cannot be expanded endlessly.\n\nReported-by: Alex Shi <alex.shi@intel.com>\nCc: David Miller <davem@davemloft.net>\nCc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>\nCc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru\nCc: \"Pekka Savola (ipv6)\" <pekkas@netcore.fi>\nCc: Patrick McHardy <kaber@trash.net>\nCc: Vlad Yasevich <vladislav.yasevich@hp.com>\nCc: Sridhar Samudrala <sri@us.ibm.com>\nCc: Jon Maloy <jon.maloy@ericsson.com>\nCc: Allan Stephens <allan.stephens@windriver.com>\nCc: Andrew Hendry <andrew.hendry@gmail.com>\nSigned-off-by: Zhu Yi <yi.zhu@intel.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nAcked-by: Arnaldo Carvalho de Melo <acme@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/sock.h | 15 ++++++++++++++-\n net\/core\/sock.c    | 16 ++++++++++++++--\n 2 files changed, 28 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/sock.h b\/include\/net\/sock.h\nindex 6cb1676e409a..2516d76f043c 100644\n--- a\/include\/net\/sock.h\n+++ b\/include\/net\/sock.h\n@@ -253,6 +253,8 @@ struct sock {\n \tstruct {\n \t\tstruct sk_buff *head;\n \t\tstruct sk_buff *tail;\n+\t\tint len;\n+\t\tint limit;\n \t} sk_backlog;\n \twait_queue_head_t\t*sk_sleep;\n \tstruct dst_entry\t*sk_dst_cache;\n@@ -589,7 +591,7 @@ static inline int sk_stream_memory_free(struct sock *sk)\n \treturn sk->sk_wmem_queued < sk->sk_sndbuf;\n }\n \n-\/* The per-socket spinlock must be held here. *\/\n+\/* OOB backlog add *\/\n static inline void sk_add_backlog(struct sock *sk, struct sk_buff *skb)\n {\n \tif (!sk->sk_backlog.tail) {\n@@ -601,6 +603,17 @@ static inline void sk_add_backlog(struct sock *sk, struct sk_buff *skb)\n \tskb->next = NULL;\n }\n \n+\/* The per-socket spinlock must be held here. *\/\n+static inline int sk_add_backlog_limited(struct sock *sk, struct sk_buff *skb)\n+{\n+\tif (sk->sk_backlog.len >= max(sk->sk_backlog.limit, sk->sk_rcvbuf << 1))\n+\t\treturn -ENOBUFS;\n+\n+\tsk_add_backlog(sk, skb);\n+\tsk->sk_backlog.len += skb->truesize;\n+\treturn 0;\n+}\n+\n static inline int sk_backlog_rcv(struct sock *sk, struct sk_buff *skb)\n {\n \treturn sk->sk_backlog_rcv(sk, skb);\ndiff --git a\/net\/core\/sock.c b\/net\/core\/sock.c\nindex fcd397a762ff..6e22dc973d23 100644\n--- a\/net\/core\/sock.c\n+++ b\/net\/core\/sock.c\n@@ -340,8 +340,12 @@ int sk_receive_skb(struct sock *sk, struct sk_buff *skb, const int nested)\n \t\trc = sk_backlog_rcv(sk, skb);\n \n \t\tmutex_release(&sk->sk_lock.dep_map, 1, _RET_IP_);\n-\t} else\n-\t\tsk_add_backlog(sk, skb);\n+\t} else if (sk_add_backlog_limited(sk, skb)) {\n+\t\tbh_unlock_sock(sk);\n+\t\tatomic_inc(&sk->sk_drops);\n+\t\tgoto discard_and_relse;\n+\t}\n+\n \tbh_unlock_sock(sk);\n out:\n \tsock_put(sk);\n@@ -1139,6 +1143,7 @@ struct sock *sk_clone(const struct sock *sk, const gfp_t priority)\n \t\tsock_lock_init(newsk);\n \t\tbh_lock_sock(newsk);\n \t\tnewsk->sk_backlog.head\t= newsk->sk_backlog.tail = NULL;\n+\t\tnewsk->sk_backlog.len = 0;\n \n \t\tatomic_set(&newsk->sk_rmem_alloc, 0);\n \t\t\/*\n@@ -1542,6 +1547,12 @@ static void __release_sock(struct sock *sk)\n \n \t\tbh_lock_sock(sk);\n \t} while ((skb = sk->sk_backlog.head) != NULL);\n+\n+\t\/*\n+\t * Doing the zeroing here guarantee we can not loop forever\n+\t * while a wild producer attempts to flood us.\n+\t *\/\n+\tsk->sk_backlog.len = 0;\n }\n \n \/**\n@@ -1874,6 +1885,7 @@ void sock_init_data(struct socket *sock, struct sock *sk)\n \tsk->sk_allocation\t=\tGFP_KERNEL;\n \tsk->sk_rcvbuf\t\t=\tsysctl_rmem_default;\n \tsk->sk_sndbuf\t\t=\tsysctl_wmem_default;\n+\tsk->sk_backlog.limit\t=\tsk->sk_rcvbuf << 1;\n \tsk->sk_state\t\t=\tTCP_CLOSE;\n \tsk_set_socket(sk, sock);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10146","CWE_ID":"399","category":"security","commit_id":"aeff00de228bc5a158c2a975ab47845d8a1db456","commit_message":"From aeff00de228bc5a158c2a975ab47845d8a1db456 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sat, 10 Dec 2016 19:51:17 -0500\nSubject: [PATCH] Fix a small memory leak\n\n---\n ChangeLog        | 2 +-\n coders\/caption.c | 2 +-\n coders\/label.c   | 2 +-\n 3 files changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 454a96d846..352f89c671 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,5 @@\n 2016-12-10  6.9.6-8 Cristy  <quetzlzacatenango@image...>\n-  * Release ImageMagick version 6.9.6-8, GIT revision 11218:2f8c6dd:20161210.\n+  * Release ImageMagick version 6.9.6-8, GIT revision 11219:11d48fe:20161210.\n \n 2016-12-07  6.9.6-8 Cristy  <quetzlzacatenango@image...>\n   * Set colorspace to sRGB if -append has non-homogenous colorspaces (reference\ndiff --git a\/coders\/caption.c b\/coders\/caption.c\nindex 728fc5c8aa..350bed6eb4 100644\n--- a\/coders\/caption.c\n+++ b\/coders\/caption.c\n@@ -275,7 +275,7 @@ static Image *ReadCAPTIONImage(const ImageInfo *image_info,\n     draw_info->direction == RightToLeftDirection ? image->columns-\n     metrics.bounds.x2 : -metrics.bounds.x1,0.0),draw_info->gravity ==\n     UndefinedGravity ? metrics.ascent : 0.0);\n-  draw_info->geometry=AcquireString(geometry);\n+  (void) CloneString(&draw_info->geometry,geometry);\n   status=AnnotateImage(image,draw_info);\n   if (image_info->pointsize == 0.0)\n     { \ndiff --git a\/coders\/label.c b\/coders\/label.c\nindex c5fef43ac7..876354e276 100644\n--- a\/coders\/label.c\n+++ b\/coders\/label.c\n@@ -237,7 +237,7 @@ static Image *ReadLABELImage(const ImageInfo *image_info,\n     draw_info->direction == RightToLeftDirection ? image->columns-\n     metrics.bounds.x2 : 0.0,draw_info->gravity == UndefinedGravity ?\n     metrics.ascent : 0.0);\n-  draw_info->geometry=AcquireString(geometry);\n+  (void) CloneString(&draw_info->geometry,geometry);\n   status=AnnotateImage(image,draw_info);\n   if (image_info->pointsize == 0.0)\n     {\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-9304","CWE_ID":"399","category":"security","commit_id":"925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699","commit_message":"From 925bcf3c3b0a28b5b78e25d9efda5c0bf27ae699 Mon Sep 17 00:00:00 2001\nFrom: \"Victor M. Alvarez\" <plusvic@gmail.com>\nDate: Mon, 29 May 2017 16:55:46 +0200\nSubject: [PATCH] Fix issue #674. Move regexp limits to limits.h.\n\n---\n libyara\/include\/yara\/limits.h |  20 ++++\n libyara\/include\/yara\/re.h     |   1 +\n libyara\/re.c                  |  18 +---\n libyara\/re_grammar.c          | 170 ++++++++++++++++++----------------\n libyara\/re_grammar.h          |   2 +-\n libyara\/re_grammar.y          |  14 +++\n 6 files changed, 129 insertions(+), 96 deletions(-)\n\n","diff_code":"diff --git a\/libyara\/include\/yara\/limits.h b\/libyara\/include\/yara\/limits.h\nindex af30d55e..ae4d1ac1 100644\n--- a\/libyara\/include\/yara\/limits.h\n+++ b\/libyara\/include\/yara\/limits.h\n@@ -65,4 +65,24 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n #define LEX_BUF_SIZE                    8192\n \n \n+\/\/ Maximum allowed split ID, also limiting the number of split instructions\n+\/\/ allowed in a regular expression. This number can't be increased\n+\/\/ over 255 without changing RE_SPLIT_ID_TYPE.\n+#define RE_MAX_SPLIT_ID                 128\n+\n+\/\/ Maximum stack size for regexp evaluation\n+#define RE_MAX_STACK                    1024\n+\n+\/\/ Maximum code size for a compiled regexp\n+#define RE_MAX_CODE_SIZE                32768\n+\n+\/\/ Maximum input size scanned by yr_re_exec\n+#define RE_SCAN_LIMIT                   4096\n+\n+\/\/ Maximum number of fibers\n+#define RE_MAX_FIBERS                   1024\n+\n+\/\/ Maximum number of levels in regexp's AST\n+#define RE_MAX_AST_LEVELS               2000\n+\n #endif\ndiff --git a\/libyara\/include\/yara\/re.h b\/libyara\/include\/yara\/re.h\nindex b421e9bc..ebdb1fd8 100644\n--- a\/libyara\/include\/yara\/re.h\n+++ b\/libyara\/include\/yara\/re.h\n@@ -136,6 +136,7 @@ struct RE_NODE\n struct RE_AST\n {\n   uint32_t flags;\n+  uint16_t levels;\n   RE_NODE* root_node;\n };\n \ndiff --git a\/libyara\/re.c b\/libyara\/re.c\nindex de20324b..959979ba 100644\n--- a\/libyara\/re.c\n+++ b\/libyara\/re.c\n@@ -52,23 +52,6 @@ order to avoid confusion with operating system threads.\n #include <yara\/re_lexer.h>\n #include <yara\/hex_lexer.h>\n \n-\/\/ Maximum allowed split ID, also limiting the number of split instructions\n-\/\/ allowed in a regular expression. This number can't be increased\n-\/\/ over 255 without changing RE_SPLIT_ID_TYPE.\n-#define RE_MAX_SPLIT_ID     128\n-\n-\/\/ Maximum stack size for regexp evaluation\n-#define RE_MAX_STACK      1024\n-\n-\/\/ Maximum code size for a compiled regexp\n-#define RE_MAX_CODE_SIZE  32768\n-\n-\/\/ Maximum input size scanned by yr_re_exec\n-#define RE_SCAN_LIMIT     4096\n-\n-\/\/ Maximum number of fibers\n-#define RE_MAX_FIBERS     1024\n-\n \n #define EMIT_BACKWARDS                  0x01\n #define EMIT_DONT_SET_FORWARDS_CODE     0x02\n@@ -268,6 +251,7 @@ int yr_re_ast_create(\n     return ERROR_INSUFFICIENT_MEMORY;\n \n   (*re_ast)->flags = 0;\n+  (*re_ast)->levels = 0;\n   (*re_ast)->root_node = NULL;\n \n   return ERROR_SUCCESS;\ndiff --git a\/libyara\/re_grammar.c b\/libyara\/re_grammar.c\nindex 4122c7d4..51839f6f 100644\n--- a\/libyara\/re_grammar.c\n+++ b\/libyara\/re_grammar.c\n@@ -88,6 +88,14 @@\n #define mark_as_not_fast_regexp() \\\n     ((RE_AST*) yyget_extra(yyscanner))->flags &= ~RE_FLAGS_FAST_REGEXP\n \n+#define incr_ast_levels() \\\n+    if (((RE_AST*) yyget_extra(yyscanner))->levels++ > RE_MAX_AST_LEVELS) \\\n+    { \\\n+      lex_env->last_error_code = ERROR_INVALID_REGULAR_EXPRESSION; \\\n+      YYABORT; \\\n+    }\n+\n+\n #define ERROR_IF(x, error) \\\n     if (x) \\\n     { \\\n@@ -102,7 +110,7 @@\n     } \\\n \n \n-#line 106 \"re_grammar.c\" \/* yacc.c:339  *\/\n+#line 114 \"re_grammar.c\" \/* yacc.c:339  *\/\n \n # ifndef YY_NULLPTR\n #  if defined __cplusplus && 201103L <= __cplusplus\n@@ -170,14 +178,14 @@ extern int re_yydebug;\n \n union YYSTYPE\n {\n-#line 73 \"re_grammar.y\" \/* yacc.c:355  *\/\n+#line 81 \"re_grammar.y\" \/* yacc.c:355  *\/\n \n   int integer;\n   uint32_t range;\n   RE_NODE* re_node;\n   uint8_t* class_vector;\n \n-#line 181 \"re_grammar.c\" \/* yacc.c:355  *\/\n+#line 189 \"re_grammar.c\" \/* yacc.c:355  *\/\n };\n \n typedef union YYSTYPE YYSTYPE;\n@@ -193,7 +201,7 @@ int re_yyparse (void *yyscanner, RE_LEX_ENVIRONMENT *lex_env);\n \n \/* Copy the second part of user declarations.  *\/\n \n-#line 197 \"re_grammar.c\" \/* yacc.c:358  *\/\n+#line 205 \"re_grammar.c\" \/* yacc.c:358  *\/\n \n #ifdef short\n # undef short\n@@ -491,10 +499,10 @@ static const yytype_uint8 yytranslate[] =\n   \/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  *\/\n static const yytype_uint16 yyrline[] =\n {\n-       0,   104,   104,   109,   113,   117,   128,   146,   150,   161,\n-     175,   191,   205,   221,   244,   268,   290,   313,   317,   323,\n-     329,   335,   344,   348,   354,   362,   368,   374,   380,   386,\n-     392,   398\n+       0,   112,   112,   117,   121,   125,   137,   156,   160,   173,\n+     187,   203,   217,   233,   256,   280,   302,   325,   329,   335,\n+     341,   347,   356,   362,   368,   376,   382,   388,   394,   400,\n+     406,   412\n };\n #endif\n \n@@ -1039,33 +1047,33 @@ yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, R\n   switch (yytype)\n     {\n           case 6: \/* _CLASS_  *\/\n-#line 96 \"re_grammar.y\" \/* yacc.c:1257  *\/\n+#line 104 \"re_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_free(((*yyvaluep).class_vector)); }\n-#line 1045 \"re_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1053 \"re_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n     case 26: \/* alternative  *\/\n-#line 97 \"re_grammar.y\" \/* yacc.c:1257  *\/\n+#line 105 \"re_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1051 \"re_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1059 \"re_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n     case 27: \/* concatenation  *\/\n-#line 98 \"re_grammar.y\" \/* yacc.c:1257  *\/\n+#line 106 \"re_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1057 \"re_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1065 \"re_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n     case 28: \/* repeat  *\/\n-#line 99 \"re_grammar.y\" \/* yacc.c:1257  *\/\n+#line 107 \"re_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1063 \"re_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1071 \"re_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n     case 29: \/* single  *\/\n-#line 100 \"re_grammar.y\" \/* yacc.c:1257  *\/\n+#line 108 \"re_grammar.y\" \/* yacc.c:1257  *\/\n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n-#line 1069 \"re_grammar.c\" \/* yacc.c:1257  *\/\n+#line 1077 \"re_grammar.c\" \/* yacc.c:1257  *\/\n         break;\n \n \n@@ -1331,26 +1339,27 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n   switch (yyn)\n     {\n         case 2:\n-#line 105 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 113 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         RE_AST* re_ast = yyget_extra(yyscanner);\n         re_ast->root_node = (yyvsp[0].re_node);\n       }\n-#line 1340 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1348 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 4:\n-#line 114 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 122 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = (yyvsp[0].re_node);\n       }\n-#line 1348 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1356 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 5:\n-#line 118 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 126 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         mark_as_not_fast_regexp();\n+        incr_ast_levels();\n \n         (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-2].re_node), (yyvsp[0].re_node));\n \n@@ -1359,15 +1368,16 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1363 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1372 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 6:\n-#line 129 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 138 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         RE_NODE* node;\n \n         mark_as_not_fast_regexp();\n+        incr_ast_levels();\n \n         node = yr_re_node_create(RE_NODE_EMPTY, NULL, NULL);\n \n@@ -1378,31 +1388,33 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1382 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1392 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 7:\n-#line 147 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 157 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = (yyvsp[0].re_node);\n       }\n-#line 1390 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1400 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 8:\n-#line 151 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 161 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n+        incr_ast_levels();\n+\n         (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));\n \n         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[0].re_node));\n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1402 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1414 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 9:\n-#line 162 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 174 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         RE_AST* re_ast;\n \n@@ -1416,11 +1428,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1420 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1432 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 10:\n-#line 176 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 188 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         RE_AST* re_ast;\n \n@@ -1436,11 +1448,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.re_node)->greedy = FALSE;\n       }\n-#line 1440 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1452 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 11:\n-#line 192 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 204 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         RE_AST* re_ast;\n \n@@ -1454,11 +1466,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         DESTROY_NODE_IF((yyval.re_node) == NULL, (yyvsp[-1].re_node));\n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1458 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1470 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 12:\n-#line 206 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 218 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         RE_AST* re_ast;\n \n@@ -1474,11 +1486,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.re_node)->greedy = FALSE;\n       }\n-#line 1478 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1490 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 13:\n-#line 222 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 234 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         RE_AST* re_ast = yyget_extra(yyscanner);\n         re_ast->flags |= RE_FLAGS_GREEDY;\n@@ -1501,11 +1513,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.re_node)->start = 0;\n         (yyval.re_node)->end = 1;\n       }\n-#line 1505 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1517 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 14:\n-#line 245 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 257 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         RE_AST* re_ast = yyget_extra(yyscanner);\n         re_ast->flags |= RE_FLAGS_UNGREEDY;\n@@ -1529,11 +1541,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.re_node)->end = 1;\n         (yyval.re_node)->greedy = FALSE;\n       }\n-#line 1533 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1545 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 15:\n-#line 269 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 281 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         RE_AST* re_ast = yyget_extra(yyscanner);\n         re_ast->flags |= RE_FLAGS_GREEDY;\n@@ -1555,11 +1567,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.re_node)->start = (yyvsp[0].range) & 0xFFFF;;\n         (yyval.re_node)->end = (yyvsp[0].range) >> 16;;\n       }\n-#line 1559 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1571 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 16:\n-#line 291 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 303 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         RE_AST* re_ast = yyget_extra(yyscanner);\n         re_ast->flags |= RE_FLAGS_UNGREEDY;\n@@ -1582,77 +1594,79 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.re_node)->end = (yyvsp[-1].range) >> 16;;\n         (yyval.re_node)->greedy = FALSE;\n       }\n-#line 1586 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1598 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 17:\n-#line 314 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 326 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = (yyvsp[0].re_node);\n       }\n-#line 1594 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1606 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 18:\n-#line 318 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 330 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_BOUNDARY, NULL, NULL);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1604 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1616 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 19:\n-#line 324 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 336 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_BOUNDARY, NULL, NULL);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1614 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1626 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 20:\n-#line 330 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 342 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_START, NULL, NULL);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1624 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1636 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 21:\n-#line 336 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 348 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_END, NULL, NULL);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1634 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1646 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 22:\n-#line 345 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 357 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n+        incr_ast_levels();\n+\n         (yyval.re_node) = (yyvsp[-1].re_node);\n       }\n-#line 1642 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1656 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 23:\n-#line 349 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 363 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_ANY, NULL, NULL);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1652 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1666 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 24:\n-#line 355 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 369 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL, NULL, NULL);\n \n@@ -1660,71 +1674,71 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.re_node)->value = (yyvsp[0].integer);\n       }\n-#line 1664 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1678 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 25:\n-#line 363 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 377 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_CHAR, NULL, NULL);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1674 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1688 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 26:\n-#line 369 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 383 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_CHAR, NULL, NULL);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1684 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1698 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 27:\n-#line 375 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 389 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_SPACE, NULL, NULL);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1694 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1708 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 28:\n-#line 381 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 395 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n          (yyval.re_node) = yr_re_node_create(RE_NODE_NON_SPACE, NULL, NULL);\n \n          ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1704 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1718 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 29:\n-#line 387 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 401 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_DIGIT, NULL, NULL);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1714 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1728 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 30:\n-#line 393 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 407 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_NON_DIGIT, NULL, NULL);\n \n         ERROR_IF((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);\n       }\n-#line 1724 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1738 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 31:\n-#line 399 \"re_grammar.y\" \/* yacc.c:1646  *\/\n+#line 413 \"re_grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.re_node) = yr_re_node_create(RE_NODE_CLASS, NULL, NULL);\n \n@@ -1732,11 +1746,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.re_node)->class_vector = (yyvsp[0].class_vector);\n       }\n-#line 1736 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1750 \"re_grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n \n-#line 1740 \"re_grammar.c\" \/* yacc.c:1646  *\/\n+#line 1754 \"re_grammar.c\" \/* yacc.c:1646  *\/\n       default: break;\n     }\n   \/* User semantic actions sometimes alter yychar, and that requires\n@@ -1964,5 +1978,5 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n #endif\n   return yyresult;\n }\n-#line 407 \"re_grammar.y\" \/* yacc.c:1906  *\/\n+#line 421 \"re_grammar.y\" \/* yacc.c:1906  *\/\n \ndiff --git a\/libyara\/re_grammar.h b\/libyara\/re_grammar.h\nindex c673bd13..8ba1c56d 100644\n--- a\/libyara\/re_grammar.h\n+++ b\/libyara\/re_grammar.h\n@@ -78,7 +78,7 @@ extern int re_yydebug;\n \n union YYSTYPE\n {\n-#line 73 \"re_grammar.y\" \/* yacc.c:1909  *\/\n+#line 81 \"re_grammar.y\" \/* yacc.c:1909  *\/\n \n   int integer;\n   uint32_t range;\ndiff --git a\/libyara\/re_grammar.y b\/libyara\/re_grammar.y\nindex 9a22b44c..9e88d24e 100644\n--- a\/libyara\/re_grammar.y\n+++ b\/libyara\/re_grammar.y\n@@ -46,6 +46,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n #define mark_as_not_fast_regexp() \\\n     ((RE_AST*) yyget_extra(yyscanner))->flags &= ~RE_FLAGS_FAST_REGEXP\n \n+#define incr_ast_levels() \\\n+    if (((RE_AST*) yyget_extra(yyscanner))->levels++ > RE_MAX_AST_LEVELS) \\\n+    { \\\n+      lex_env->last_error_code = ERROR_INVALID_REGULAR_EXPRESSION; \\\n+      YYABORT; \\\n+    }\n+\n+\n #define ERROR_IF(x, error) \\\n     if (x) \\\n     { \\\n@@ -117,6 +125,7 @@ alternative\n     | alternative '|' concatenation\n       {\n         mark_as_not_fast_regexp();\n+        incr_ast_levels();\n \n         $$ = yr_re_node_create(RE_NODE_ALT, $1, $3);\n \n@@ -130,6 +139,7 @@ alternative\n         RE_NODE* node;\n \n         mark_as_not_fast_regexp();\n+        incr_ast_levels();\n \n         node = yr_re_node_create(RE_NODE_EMPTY, NULL, NULL);\n \n@@ -149,6 +159,8 @@ concatenation\n       }\n     | concatenation repeat\n       {\n+        incr_ast_levels();\n+\n         $$ = yr_re_node_create(RE_NODE_CONCAT, $1, $2);\n \n         DESTROY_NODE_IF($$ == NULL, $1);\n@@ -343,6 +355,8 @@ repeat\n single\n     : '(' alternative ')'\n       {\n+        incr_ast_levels();\n+\n         $$ = $2;\n       }\n     | '.'\n","owner":"VirusTotal","repo":"yara","source":"cve"},{"CVE_ID":"CVE-2015-8953","CWE_ID":"399","category":"security","commit_id":"ab79efab0a0ba01a74df782eb7fa44b044dae8b5","commit_message":"From ab79efab0a0ba01a74df782eb7fa44b044dae8b5 Mon Sep 17 00:00:00 2001\nFrom: David Howells <dhowells@redhat.com>\nDate: Fri, 18 Sep 2015 11:45:22 +0100\nSubject: [PATCH] ovl: fix dentry reference leak\n\nIn ovl_copy_up_locked(), newdentry is leaked if the function exits through\nout_cleanup as this just to out after calling ovl_cleanup() - which doesn't\nactually release the ref on newdentry.\n\nThe out_cleanup segment should instead exit through out2 as certainly\nnewdentry leaks - and possibly upper does also, though this isn't caught\ngiven the catch of newdentry.\n\nWithout this fix, something like the following is seen:\n\n\tBUG: Dentry ffff880023e9eb20{i=f861,n=#ffff880023e82d90} still in use (1) [unmount of tmpfs tmpfs]\n\tBUG: Dentry ffff880023ece640{i=0,n=bigfile}  still in use (1) [unmount of tmpfs tmpfs]\n\nwhen unmounting the upper layer after an error occurred in copyup.\n\nAn error can be induced by creating a big file in a lower layer with\nsomething like:\n\n\tdd if=\/dev\/zero of=\/lower\/a\/bigfile bs=65536 count=1 seek=$((0xf000))\n\nto create a large file (4.1G).  Overlay an upper layer that is too small\n(on tmpfs might do) and then induce a copy up by opening it writably.\n\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org> # v3.18+\n---\n fs\/overlayfs\/copy_up.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/overlayfs\/copy_up.c b\/fs\/overlayfs\/copy_up.c\nindex b1990ac8fa097..871fcb67be974 100644\n--- a\/fs\/overlayfs\/copy_up.c\n+++ b\/fs\/overlayfs\/copy_up.c\n@@ -267,7 +267,7 @@ static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n \n out_cleanup:\n \tovl_cleanup(wdir, newdentry);\n-\tgoto out;\n+\tgoto out2;\n }\n \n \/*\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-1969","CWE_ID":"399","category":"security","commit_id":"de0cc20c29cb3f056062925395e0f68d2250a46f","commit_message":"From de0cc20c29cb3f056062925395e0f68d2250a46f Mon Sep 17 00:00:00 2001\nFrom: Daniel Veillard <veillard@redhat.com>\nDate: Tue, 12 Feb 2013 16:55:34 +0800\nSubject: [PATCH] Fix some buffer conversion issues\n\nhttps:\/\/bugzilla.gnome.org\/show_bug.cgi?id=690202\n\nBuffer overflow errors originating from xmlBufGetInputBase in 2.9.0\nThe pointers from the context input were not properly reset after\nthat call which can do reallocations.\n---\n HTMLparser.c |  3 +++\n parser.c     | 12 +++++++++++-\n 2 files changed, 14 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/HTMLparser.c b\/HTMLparser.c\nindex a533f375..6b83654d 100644\n--- a\/HTMLparser.c\n+++ b\/HTMLparser.c\n@@ -6054,6 +6054,8 @@ htmlParseChunk(htmlParserCtxtPtr ctxt, const char *chunk, int size,\n \t    if ((in->encoder != NULL) && (in->buffer != NULL) &&\n \t\t    (in->raw != NULL)) {\n \t\tint nbchars;\n+\t\tsize_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n+\t\tsize_t current = ctxt->input->cur - ctxt->input->base;\n \n \t\tnbchars = xmlCharEncInput(in);\n \t\tif (nbchars < 0) {\n@@ -6061,6 +6063,7 @@ htmlParseChunk(htmlParserCtxtPtr ctxt, const char *chunk, int size,\n \t\t\t         \"encoder error\\n\", NULL, NULL);\n \t\t    return(XML_ERR_INVALID_ENCODING);\n \t\t}\n+\t\txmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n \t    }\n \t}\n     }\ndiff --git a\/parser.c b\/parser.c\nindex 31f90d60..1c99051f 100644\n--- a\/parser.c\n+++ b\/parser.c\n@@ -12126,7 +12126,7 @@ xmldecl_done:\n                 remain = 0;\n             }\n         }\n-\tres =xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+\tres = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n \tif (res < 0) {\n \t    ctxt->errNo = XML_PARSER_EOF;\n \t    ctxt->disableSAX = 1;\n@@ -12143,6 +12143,8 @@ xmldecl_done:\n \t    if ((in->encoder != NULL) && (in->buffer != NULL) &&\n \t\t    (in->raw != NULL)) {\n \t\tint nbchars;\n+\t\tsize_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n+\t\tsize_t current = ctxt->input->cur - ctxt->input->base;\n \n \t\tnbchars = xmlCharEncInput(in);\n \t\tif (nbchars < 0) {\n@@ -12151,6 +12153,7 @@ xmldecl_done:\n \t\t\t\t    \"xmlParseChunk: encoder error\\n\");\n \t\t    return(XML_ERR_INVALID_ENCODING);\n \t\t}\n+\t\txmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n \t    }\n \t}\n     }\n@@ -12190,7 +12193,14 @@ xmldecl_done:\n     }\n     if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n         (ctxt->input->buf != NULL)) {\n+\tsize_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,\n+\t\t\t\t\t ctxt->input);\n+\tsize_t current = ctxt->input->cur - ctxt->input->base;\n+\n \txmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n+\n+\txmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,\n+\t\t\t      base, current);\n     }\n     if (terminate) {\n \t\/*\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-3934","CWE_ID":"399","category":"security","commit_id":"247d30a7dba6684ccce4508424f35fd58465e535","commit_message":"From 247d30a7dba6684ccce4508424f35fd58465e535 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Wed, 25 Jan 2012 21:10:29 +0100\nSubject: [PATCH] vp3: Copy all 3 frames for thread updates.\n\nThis fixes a double release of the current frame on deinit.\nFixes CVE-2011-3934\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/vp3.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/vp3.c b\/libavcodec\/vp3.c\nindex 738ae9fd25..b5daafcefb 100644\n--- a\/libavcodec\/vp3.c\n+++ b\/libavcodec\/vp3.c\n@@ -1859,7 +1859,7 @@ static int vp3_update_thread_context(AVCodecContext *dst, const AVCodecContext *\n         ||s->width != s1->width\n         ||s->height!= s1->height) {\n         if (s != s1)\n-            copy_fields(s, s1, golden_frame, current_frame);\n+            copy_fields(s, s1, golden_frame, keyframe);\n         return -1;\n     }\n \n-- \n2.11.0\n\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2011-2189","CWE_ID":"399","category":"security","commit_id":"2b035b39970740722598f7a9d548835f9bdd730f","commit_message":"From 2b035b39970740722598f7a9d548835f9bdd730f Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <eric@conroxe.ebiederm.org>\nDate: Sun, 29 Nov 2009 22:25:27 +0000\nSubject: net: Batch network namespace destruction.\n\nIt is fairly common to kill several network namespaces at once.  Either\nbecause they are nested one inside the other or because they are cooperating\nin multiple machine networking experiments.  As the network stack control logic\ndoes not parallelize easily batch up multiple network namespaces existing\ntogether.\n\nTo get the full benefit of batching the virtual network devices to be\nremoved must be all removed in one batch.  For that purpose I have added\na loop after the last network device operations have run that batches\nup all remaining network devices and deletes them.\n\nAn extra benefit is that the reorganization slightly shrinks the size\nof the per network namespace data structures replaceing a work_struct\nwith a list_head.\n\nIn a trivial test with 4K namespaces this change reduced the cost of\na destroying 4K namespaces from 7+ minutes (at 12% cpu) to 44 seconds\n(at 60% cpu).  The bulk of that 44s was spent in inet_twsk_purge.\n\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/net_namespace.h |  2 +-\n net\/core\/net_namespace.c    | 66 +++++++++++++++++++++++++++++++++++++++------\n 2 files changed, 59 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/net_namespace.h b\/include\/net\/net_namespace.h\nindex 0addd45038ac..d69b4796030f 100644\n--- a\/include\/net\/net_namespace.h\n+++ b\/include\/net\/net_namespace.h\n@@ -42,7 +42,7 @@ struct net {\n \t\t\t\t\t\t *\/\n #endif\n \tstruct list_head\tlist;\t\t\/* list of network namespaces *\/\n-\tstruct work_struct\twork;\t\t\/* work struct for freeing *\/\n+\tstruct list_head\tcleanup_list;\t\/* namespaces on death row *\/\n \n \tstruct proc_dir_entry \t*proc_net;\n \tstruct proc_dir_entry \t*proc_net_stat;\ndiff --git a\/net\/core\/net_namespace.c b\/net\/core\/net_namespace.c\nindex 86ed7f44d083..a42caa2b909b 100644\n--- a\/net\/core\/net_namespace.c\n+++ b\/net\/core\/net_namespace.c\n@@ -8,8 +8,10 @@\n #include <linux\/idr.h>\n #include <linux\/rculist.h>\n #include <linux\/nsproxy.h>\n+#include <linux\/netdevice.h>\n #include <net\/net_namespace.h>\n #include <net\/netns\/generic.h>\n+#include <net\/rtnetlink.h>\n \n \/*\n  *\tOur network namespace constructor\/destructor lists\n@@ -27,6 +29,20 @@ EXPORT_SYMBOL(init_net);\n \n #define INITIAL_NET_GEN_PTRS\t13 \/* +1 for len +2 for rcu_head *\/\n \n+static void unregister_netdevices(struct net *net, struct list_head *list)\n+{\n+\tstruct net_device *dev;\n+\t\/* At exit all network devices most be removed from a network\n+\t * namespace.  Do this in the reverse order of registeration.\n+\t *\/\n+\tfor_each_netdev_reverse(net, dev) {\n+\t\tif (dev->rtnl_link_ops)\n+\t\t\tdev->rtnl_link_ops->dellink(dev, list);\n+\t\telse\n+\t\t\tunregister_netdevice_queue(dev, list);\n+\t}\n+}\n+\n \/*\n  * setup_net runs the initializers for the network namespace object.\n  *\/\n@@ -59,6 +75,13 @@ out_undo:\n \tlist_for_each_entry_continue_reverse(ops, &pernet_list, list) {\n \t\tif (ops->exit)\n \t\t\tops->exit(net);\n+\t\tif (&ops->list == first_device) {\n+\t\t\tLIST_HEAD(dev_kill_list);\n+\t\t\trtnl_lock();\n+\t\t\tunregister_netdevices(net, &dev_kill_list);\n+\t\t\tunregister_netdevice_many(&dev_kill_list);\n+\t\t\trtnl_unlock();\n+\t\t}\n \t}\n \n \trcu_barrier();\n@@ -147,18 +170,26 @@ struct net *copy_net_ns(unsigned long flags, struct net *old_net)\n \treturn net_create();\n }\n \n+static DEFINE_SPINLOCK(cleanup_list_lock);\n+static LIST_HEAD(cleanup_list);  \/* Must hold cleanup_list_lock to touch *\/\n+\n static void cleanup_net(struct work_struct *work)\n {\n \tstruct pernet_operations *ops;\n-\tstruct net *net;\n+\tstruct net *net, *tmp;\n+\tLIST_HEAD(net_kill_list);\n \n-\tnet = container_of(work, struct net, work);\n+\t\/* Atomically snapshot the list of namespaces to cleanup *\/\n+\tspin_lock_irq(&cleanup_list_lock);\n+\tlist_replace_init(&cleanup_list, &net_kill_list);\n+\tspin_unlock_irq(&cleanup_list_lock);\n \n \tmutex_lock(&net_mutex);\n \n \t\/* Don't let anyone else find us. *\/\n \trtnl_lock();\n-\tlist_del_rcu(&net->list);\n+\tlist_for_each_entry(net, &net_kill_list, cleanup_list)\n+\t\tlist_del_rcu(&net->list);\n \trtnl_unlock();\n \n \t\/*\n@@ -170,8 +201,18 @@ static void cleanup_net(struct work_struct *work)\n \n \t\/* Run all of the network namespace exit methods *\/\n \tlist_for_each_entry_reverse(ops, &pernet_list, list) {\n-\t\tif (ops->exit)\n-\t\t\tops->exit(net);\n+\t\tif (ops->exit) {\n+\t\t\tlist_for_each_entry(net, &net_kill_list, cleanup_list)\n+\t\t\t\tops->exit(net);\n+\t\t}\n+\t\tif (&ops->list == first_device) {\n+\t\t\tLIST_HEAD(dev_kill_list);\n+\t\t\trtnl_lock();\n+\t\t\tlist_for_each_entry(net, &net_kill_list, cleanup_list)\n+\t\t\t\tunregister_netdevices(net, &dev_kill_list);\n+\t\t\tunregister_netdevice_many(&dev_kill_list);\n+\t\t\trtnl_unlock();\n+\t\t}\n \t}\n \n \tmutex_unlock(&net_mutex);\n@@ -182,14 +223,23 @@ static void cleanup_net(struct work_struct *work)\n \trcu_barrier();\n \n \t\/* Finally it is safe to free my network namespace structure *\/\n-\tnet_free(net);\n+\tlist_for_each_entry_safe(net, tmp, &net_kill_list, cleanup_list) {\n+\t\tlist_del_init(&net->cleanup_list);\n+\t\tnet_free(net);\n+\t}\n }\n+static DECLARE_WORK(net_cleanup_work, cleanup_net);\n \n void __put_net(struct net *net)\n {\n \t\/* Cleanup the network namespace in process context *\/\n-\tINIT_WORK(&net->work, cleanup_net);\n-\tqueue_work(netns_wq, &net->work);\n+\tunsigned long flags;\n+\n+\tspin_lock_irqsave(&cleanup_list_lock, flags);\n+\tlist_add(&net->cleanup_list, &cleanup_list);\n+\tspin_unlock_irqrestore(&cleanup_list_lock, flags);\n+\n+\tqueue_work(netns_wq, &net_cleanup_work);\n }\n EXPORT_SYMBOL_GPL(__put_net);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2008-3686","CWE_ID":"399","category":"security","commit_id":"5e0115e500fe9dd2ca11e6f92db9123204f1327a","commit_message":"From 5e0115e500fe9dd2ca11e6f92db9123204f1327a Mon Sep 17 00:00:00 2001\nFrom: Brian Haley <brian.haley@hp.com>\nDate: Wed, 13 Aug 2008 01:58:57 -0700\nSubject: ipv6: Fix OOPS, ip -f inet6 route get fec0::1, linux-2.6.26,\n ip6_route_output, rt6_fill_node+0x175\n\nAlexey Dobriyan wrote:\n> On Thu, Aug 07, 2008 at 07:00:56PM +0200, John Gumb wrote:\n>> Scenario: no ipv6 default route set.\n>\n>> # ip -f inet6 route get fec0::1\n>>\n>> BUG: unable to handle kernel NULL pointer dereference at 00000000\n>> IP: [<c0369b85>] rt6_fill_node+0x175\/0x3b0\n>> EIP is at rt6_fill_node+0x175\/0x3b0\n>\n> 0xffffffff80424dd3 is in rt6_fill_node (net\/ipv6\/route.c:2191).\n> 2186                    } else\n> 2187    #endif\n> 2188                            NLA_PUT_U32(skb, RTA_IIF, iif);\n> 2189            } else if (dst) {\n> 2190                    struct in6_addr saddr_buf;\n> 2191      ====>         if (ipv6_dev_get_saddr(ip6_dst_idev(&rt->u.dst)->dev,\n>\t\t\t\t\t       ^^^^^^^^^^^^^^^^^^^^^^^^\n>\t\t\t\t\t\t\t\t\t\t\tNULL\n>\n> 2192                                           dst, 0, &saddr_buf) == 0)\n> 2193                            NLA_PUT(skb, RTA_PREFSRC, 16, &saddr_buf);\n> 2194            }\n\nThe commit that changed this can't be reverted easily, but the patch\nbelow works for me.\n\nFix NULL de-reference in rt6_fill_node() when there's no IPv6 input\ndevice present in the dst entry.\n\nSigned-off-by: Brian Haley <brian.haley@hp.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/route.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/route.c b\/net\/ipv6\/route.c\nindex 5a3e87e4b18f..41b165ffb369 100644\n--- a\/net\/ipv6\/route.c\n+++ b\/net\/ipv6\/route.c\n@@ -2187,8 +2187,9 @@ static int rt6_fill_node(struct sk_buff *skb, struct rt6_info *rt,\n #endif\n \t\t\tNLA_PUT_U32(skb, RTA_IIF, iif);\n \t} else if (dst) {\n+\t\tstruct inet6_dev *idev = ip6_dst_idev(&rt->u.dst);\n \t\tstruct in6_addr saddr_buf;\n-\t\tif (ipv6_dev_get_saddr(ip6_dst_idev(&rt->u.dst)->dev,\n+\t\tif (ipv6_dev_get_saddr(idev ? idev->dev : NULL,\n \t\t\t\t       dst, 0, &saddr_buf) == 0)\n \t\t\tNLA_PUT(skb, RTA_PREFSRC, 16, &saddr_buf);\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-0058","CWE_ID":"399","category":"security","commit_id":"802f43594d6e4d2ac61086d239153c17873a0428","commit_message":"From 802f43594d6e4d2ac61086d239153c17873a0428 Mon Sep 17 00:00:00 2001\nFrom: Gleb Natapov <gleb@redhat.com>\nDate: Sun, 8 Jan 2012 17:07:28 +0200\nSubject: [PATCH] Unused iocbs in a batch should not be accounted as active.\n\ncommit 69e4747ee9727d660b88d7e1efe0f4afcb35db1b upstream.\n\nSince commit 080d676de095 (\"aio: allocate kiocbs in batches\") iocbs are\nallocated in a batch during processing of first iocbs.  All iocbs in a\nbatch are automatically added to ctx->active_reqs list and accounted in\nctx->reqs_active.\n\nIf one (not the last one) of iocbs submitted by an user fails, further\niocbs are not processed, but they are still present in ctx->active_reqs\nand accounted in ctx->reqs_active.  This causes process to stuck in a D\nstate in wait_for_all_aios() on exit since ctx->reqs_active will never\ngo down to zero.  Furthermore since kiocb_batch_free() frees iocb\nwithout removing it from active_reqs list the list become corrupted\nwhich may cause oops.\n\nFix this by removing iocb from ctx->active_reqs and updating\nctx->reqs_active in kiocb_batch_free().\n\nSigned-off-by: Gleb Natapov <gleb@redhat.com>\nReviewed-by: Jeff Moyer <jmoyer@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>\n---\n fs\/aio.c | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/aio.c b\/fs\/aio.c\nindex 78c514cfd212d..969beb0e22311 100644\n--- a\/fs\/aio.c\n+++ b\/fs\/aio.c\n@@ -476,14 +476,21 @@ static void kiocb_batch_init(struct kiocb_batch *batch, long total)\n \tbatch->count = total;\n }\n \n-static void kiocb_batch_free(struct kiocb_batch *batch)\n+static void kiocb_batch_free(struct kioctx *ctx, struct kiocb_batch *batch)\n {\n \tstruct kiocb *req, *n;\n \n+\tif (list_empty(&batch->head))\n+\t\treturn;\n+\n+\tspin_lock_irq(&ctx->ctx_lock);\n \tlist_for_each_entry_safe(req, n, &batch->head, ki_batch) {\n \t\tlist_del(&req->ki_batch);\n+\t\tlist_del(&req->ki_list);\n \t\tkmem_cache_free(kiocb_cachep, req);\n+\t\tctx->reqs_active--;\n \t}\n+\tspin_unlock_irq(&ctx->ctx_lock);\n }\n \n \/*\n@@ -1742,7 +1749,7 @@ long do_io_submit(aio_context_t ctx_id, long nr,\n \t}\n \tblk_finish_plug(&plug);\n \n-\tkiocb_batch_free(&batch);\n+\tkiocb_batch_free(ctx, &batch);\n \tput_ioctx(ctx);\n \treturn i ? i : ret;\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5993","CWE_ID":"399","category":"security","commit_id":"6eb13f7a2dcf391ec9e19b4c2a79e68305f63c22","commit_message":"From 6eb13f7a2dcf391ec9e19b4c2a79e68305f63c22 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Mon, 26 Dec 2016 21:23:45 -0500\nSubject: vrend: fix memory leak in int blit context\n\nThe 'blit_ctx->initialised' is not setted to true.\nEvery time init blit context, it will create a new\n'blit_ctx->gl_context' thus causing a memory leak.\nThis patch avoid this.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n src\/vrend_blitter.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/src\/vrend_blitter.c b\/src\/vrend_blitter.c\nindex 86c2061..035c409 100644\n--- a\/src\/vrend_blitter.c\n+++ b\/src\/vrend_blitter.c\n@@ -361,6 +361,7 @@ static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n       return;\n    }\n \n+   blit_ctx->initialised = true;\n    ctx_params.shared = true;\n    ctx_params.major_ver = VREND_GL_VER_MAJOR;\n    ctx_params.minor_ver = VREND_GL_VER_MINOR;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-8086","CWE_ID":"399","category":"security","commit_id":"4ffcdef4277a91af15a3c09f7d16af072c29f3f2","commit_message":"From 4ffcdef4277a91af15a3c09f7d16af072c29f3f2 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Fri, 7 Apr 2017 03:48:52 -0700\nSubject: [PATCH] 9pfs: xattr: fix memory leak in v9fs_list_xattr\n\nFree 'orig_value' in error path.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Greg Kurz <groug@kaod.org>\n---\n hw\/9pfs\/9p-xattr.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/hw\/9pfs\/9p-xattr.c b\/hw\/9pfs\/9p-xattr.c\nindex eec160b..d05c1a1 100644\n--- a\/hw\/9pfs\/9p-xattr.c\n+++ b\/hw\/9pfs\/9p-xattr.c\n@@ -108,6 +108,7 @@ ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n     g_free(name);\n     close_preserve_errno(dirfd);\n     if (xattr_len < 0) {\n+        g_free(orig_value);\n         return -1;\n     }\n \n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4125","CWE_ID":"399","category":"security","commit_id":"307f2fb95e9b96b3577916e73d92e104f8f26494","commit_message":"From 307f2fb95e9b96b3577916e73d92e104f8f26494 Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Fri, 12 Jul 2013 23:46:33 +0200\nSubject: [PATCH] ipv6: only static routes qualify for equal cost multipathing\n\nStatic routes in this case are non-expiring routes which did not get\nconfigured by autoconf or by icmpv6 redirects.\n\nTo make sure we actually get an ecmp route while searching for the first\none in this fib6_node's leafs, also make sure it matches the ecmp route\nassumptions.\n\nv2:\na) Removed RTF_EXPIRE check in dst.from chain. The check of RTF_ADDRCONF\n   already ensures that this route, even if added again without\n   RTF_EXPIRES (in case of a RA announcement with infinite timeout),\n   does not cause the rt6i_nsiblings logic to go wrong if a later RA\n   updates the expiration time later.\n\nv3:\na) Allow RTF_EXPIRES routes to enter the ecmp route set. We have to do so,\n   because an pmtu event could update the RTF_EXPIRES flag and we would\n   not count this route, if another route joins this set. We now filter\n   only for RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC, which are flags that\n   don't get changed after rt6_info construction.\n\nCc: Nicolas Dichtel <nicolas.dichtel@6wind.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/ip6_fib.c | 15 +++++++++++----\n 1 file changed, 11 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/ip6_fib.c b\/net\/ipv6\/ip6_fib.c\nindex 192dd1a0e1881..5fc9c7a68d8d1 100644\n--- a\/net\/ipv6\/ip6_fib.c\n+++ b\/net\/ipv6\/ip6_fib.c\n@@ -632,6 +632,12 @@ static struct fib6_node * fib6_add_1(struct fib6_node *root, void *addr,\n \treturn ln;\n }\n \n+static inline bool rt6_qualify_for_ecmp(struct rt6_info *rt)\n+{\n+\treturn (rt->rt6i_flags & (RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC)) ==\n+\t       RTF_GATEWAY;\n+}\n+\n \/*\n  *\tInsert routing information in a node.\n  *\/\n@@ -646,6 +652,7 @@ static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,\n \tint add = (!info->nlh ||\n \t\t   (info->nlh->nlmsg_flags & NLM_F_CREATE));\n \tint found = 0;\n+\tbool rt_can_ecmp = rt6_qualify_for_ecmp(rt);\n \n \tins = &fn->leaf;\n \n@@ -691,9 +698,8 @@ static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,\n \t\t\t * To avoid long list, we only had siblings if the\n \t\t\t * route have a gateway.\n \t\t\t *\/\n-\t\t\tif (rt->rt6i_flags & RTF_GATEWAY &&\n-\t\t\t    !(rt->rt6i_flags & RTF_EXPIRES) &&\n-\t\t\t    !(iter->rt6i_flags & RTF_EXPIRES))\n+\t\t\tif (rt_can_ecmp &&\n+\t\t\t    rt6_qualify_for_ecmp(iter))\n \t\t\t\trt->rt6i_nsiblings++;\n \t\t}\n \n@@ -715,7 +721,8 @@ static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,\n \t\t\/* Find the first route that have the same metric *\/\n \t\tsibling = fn->leaf;\n \t\twhile (sibling) {\n-\t\t\tif (sibling->rt6i_metric == rt->rt6i_metric) {\n+\t\t\tif (sibling->rt6i_metric == rt->rt6i_metric &&\n+\t\t\t    rt6_qualify_for_ecmp(sibling)) {\n \t\t\t\tlist_add_tail(&rt->rt6i_siblings,\n \t\t\t\t\t      &sibling->rt6i_siblings);\n \t\t\t\tbreak;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-1601","CWE_ID":"399","category":"security","commit_id":"9c895160d25a76c21b65bad141b08e8d4f99afef","commit_message":"From 9c895160d25a76c21b65bad141b08e8d4f99afef Mon Sep 17 00:00:00 2001\nFrom: Avi Kivity <avi@redhat.com>\nDate: Wed, 9 May 2012 16:10:42 +0300\nSubject: [PATCH] KVM: Ensure all vcpus are consistent with in-kernel irqchip\n settings\n\n(cherry picked from commit 3e515705a1f46beb1c942bb8043c16f8ac7b1e9e)\n\nIf some vcpus are created before KVM_CREATE_IRQCHIP, then\nirqchip_in_kernel() and vcpu->arch.apic will be inconsistent, leading\nto potential NULL pointer dereferences.\n\nFix by:\n- ensuring that no vcpus are installed when KVM_CREATE_IRQCHIP is called\n- ensuring that a vcpu has an apic if it is installed after KVM_CREATE_IRQCHIP\n\nThis is somewhat long winded because vcpu->arch.apic is created without\nkvm->lock held.\n\nBased on earlier patch by Michael Ellerman.\n\nSigned-off-by: Michael Ellerman <michael@ellerman.id.au>\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n arch\/ia64\/kvm\/kvm-ia64.c | 5 +++++\n arch\/x86\/kvm\/x86.c       | 8 ++++++++\n include\/linux\/kvm_host.h | 7 +++++++\n virt\/kvm\/kvm_main.c      | 4 ++++\n 4 files changed, 24 insertions(+)\n\n","diff_code":"diff --git a\/arch\/ia64\/kvm\/kvm-ia64.c b\/arch\/ia64\/kvm\/kvm-ia64.c\nindex 405052002493b..8c25855f73a82 100644\n--- a\/arch\/ia64\/kvm\/kvm-ia64.c\n+++ b\/arch\/ia64\/kvm\/kvm-ia64.c\n@@ -1169,6 +1169,11 @@ static enum hrtimer_restart hlt_timer_fn(struct hrtimer *data)\n \n #define PALE_RESET_ENTRY    0x80000000ffffffb0UL\n \n+bool kvm_vcpu_compatible(struct kvm_vcpu *vcpu)\n+{\n+\treturn irqchip_in_kernel(vcpu->kcm) == (vcpu->arch.apic != NULL);\n+}\n+\n int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n {\n \tstruct kvm_vcpu *v;\ndiff --git a\/arch\/x86\/kvm\/x86.c b\/arch\/x86\/kvm\/x86.c\nindex 410b6b0565abd..8d1c6c6ecc9e8 100644\n--- a\/arch\/x86\/kvm\/x86.c\n+++ b\/arch\/x86\/kvm\/x86.c\n@@ -3131,6 +3131,9 @@ long kvm_arch_vm_ioctl(struct file *filp,\n \t\tr = -EEXIST;\n \t\tif (kvm->arch.vpic)\n \t\t\tgoto create_irqchip_unlock;\n+\t\tr = -EINVAL;\n+\t\tif (atomic_read(&kvm->online_vcpus))\n+\t\t\tgoto create_irqchip_unlock;\n \t\tr = -ENOMEM;\n \t\tvpic = kvm_create_pic(kvm);\n \t\tif (vpic) {\n@@ -5956,6 +5959,11 @@ void kvm_arch_check_processor_compat(void *rtn)\n \tkvm_x86_ops->check_processor_compatibility(rtn);\n }\n \n+bool kvm_vcpu_compatible(struct kvm_vcpu *vcpu)\n+{\n+\treturn irqchip_in_kernel(vcpu->kvm) == (vcpu->arch.apic != NULL);\n+}\n+\n int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n {\n \tstruct page *page;\ndiff --git a\/include\/linux\/kvm_host.h b\/include\/linux\/kvm_host.h\nindex bc2172077d9d2..4c4e83d22dcee 100644\n--- a\/include\/linux\/kvm_host.h\n+++ b\/include\/linux\/kvm_host.h\n@@ -775,6 +775,13 @@ static inline bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n {\n \treturn vcpu->kvm->bsp_vcpu_id == vcpu->vcpu_id;\n }\n+\n+bool kvm_vcpu_compatible(struct kvm_vcpu *vcpu);\n+\n+#else\n+\n+static inline bool kvm_vcpu_compatible(struct kvm_vcpu *vcpu) { return true; }\n+\n #endif\n \n #ifdef __KVM_HAVE_DEVICE_ASSIGNMENT\ndiff --git a\/virt\/kvm\/kvm_main.c b\/virt\/kvm\/kvm_main.c\nindex 4c68c1e875b58..785822896ced6 100644\n--- a\/virt\/kvm\/kvm_main.c\n+++ b\/virt\/kvm\/kvm_main.c\n@@ -1720,6 +1720,10 @@ static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n \t\tgoto vcpu_destroy;\n \n \tmutex_lock(&kvm->lock);\n+\tif (!kvm_vcpu_compatible(vcpu)) {\n+\t\tr = -EINVAL;\n+\t\tgoto unlock_vcpu_destroy;\n+\t}\n \tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n \t\tr = -EINVAL;\n \t\tgoto unlock_vcpu_destroy;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5507","CWE_ID":"399","category":"security","commit_id":"4493d9ca1124564da17f9b628ef9d0f1a6be9738","commit_message":"From 4493d9ca1124564da17f9b628ef9d0f1a6be9738 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 10 Jan 2017 20:14:38 -0500\nSubject: [PATCH] ...\n\n---\n ChangeLog    |  5 +++++\n coders\/mpc.c | 14 +++++++-------\n 2 files changed, 12 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 328896c145..83b274c8ce 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,8 @@\n+2017-01-10  6.9.7-4 Cristy  <quetzlzacatenango@image...>\n+  * Recognize XML policy closing tags (reference\n+    https:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=3&t=31182).\n+  * Fix memory leak in MPC image format.\n+\n 2017-01-07  6.9.7-3 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 6.9.7-3, GIT revision 11280:7d65a81:20170107.\n \ndiff --git a\/coders\/mpc.c b\/coders\/mpc.c\nindex eda0c36cb2..89fead527f 100644\n--- a\/coders\/mpc.c\n+++ b\/coders\/mpc.c\n@@ -67,6 +67,7 @@\n #include \"magick\/profile.h\"\n #include \"magick\/property.h\"\n #include \"magick\/quantum-private.h\"\n+#include \"magick\/resource_.h\"\n #include \"magick\/static.h\"\n #include \"magick\/statistic.h\"\n #include \"magick\/string_.h\"\n@@ -841,7 +842,9 @@ static Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         \/*\n           Create image colormap.\n         *\/\n-        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n+        image->colormap=(PixelPacket *) AcquireQuantumMemory(image->colors+1,\n+          sizeof(*image->colormap));\n+        if (image->colormap == (PixelPacket *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         if (image->colors != 0)\n           {\n@@ -930,12 +933,9 @@ static Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n-    status=SetImageExtent(image,image->columns,image->rows);\n-    if (status == MagickFalse)\n-      {\n-        InheritException(exception,&image->exception);\n-        return(DestroyImageList(image));\n-      }\n+    if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n+        (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n+      ThrowReaderException(ImageError,\"WidthOrHeightExceedsLimit\");\n     \/*\n       Attach persistent pixel cache.\n     *\/\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2014-3507","CWE_ID":"399","category":"security","commit_id":"d0a4b7d1a2948fce38515b8d862f43e7ba0ebf74","commit_message":"From d0a4b7d1a2948fce38515b8d862f43e7ba0ebf74 Mon Sep 17 00:00:00 2001\nFrom: Adam Langley <agl@imperialviolet.org>\nDate: Fri, 6 Jun 2014 14:30:33 -0700\nSubject: [PATCH] Fix memory leak from zero-length DTLS fragments.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nThe |pqueue_insert| function can fail if one attempts to insert a\nduplicate sequence number. When handling a fragment of an out of\nsequence message, |dtls1_process_out_of_seq_message| would not call\n|dtls1_reassemble_fragment| if the fragment's length was zero. It would\nthen allocate a fresh fragment and attempt to insert it, but ignore the\nreturn value, leaking the fragment.\n\nThis allows an attacker to exhaust the memory of a DTLS peer.\n\nFixes CVE-2014-3507\n\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Emilia K\u00c3\u00a4sper <emilia@openssl.org>\n---\n ssl\/d1_both.c | 22 +++++++++++++++++++---\n 1 file changed, 19 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ssl\/d1_both.c b\/ssl\/d1_both.c\nindex c5beea8824..4d8d2d15ba 100644\n--- a\/ssl\/d1_both.c\n+++ b\/ssl\/d1_both.c\n@@ -616,6 +616,9 @@ dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n \t    msg_hdr->msg_len > dtls1_max_handshake_message_len(s))\n \t\tgoto err;\n \n+\tif (frag_len == 0)\n+\t\treturn DTLS1_HM_FRAGMENT_RETRY;\n+\n \t\/* Try to find item in queue *\/\n \tmemset(seq64be,0,sizeof(seq64be));\n \tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n@@ -693,7 +696,12 @@ dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n \t\t\tgoto err;\n \t\t\t}\n \n-\t\tpqueue_insert(s->d1->buffered_messages, item);\n+\t\titem = pqueue_insert(s->d1->buffered_messages, item);\n+\t\t\/* pqueue_insert fails iff a duplicate item is inserted.\n+\t\t * However, |item| cannot be a duplicate. If it were,\n+\t\t * |pqueue_find|, above, would have returned it and control\n+\t\t * would never have reached this branch. *\/\n+\t\tOPENSSL_assert(item != NULL);\n \t\t}\n \n \treturn DTLS1_HM_FRAGMENT_RETRY;\n@@ -751,7 +759,7 @@ dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n \t\t}\n \telse\n \t\t{\n-\t\tif (frag_len && frag_len < msg_hdr->msg_len)\n+\t\tif (frag_len < msg_hdr->msg_len)\n \t\t\treturn dtls1_reassemble_fragment(s, msg_hdr, ok);\n \n \t\tif (frag_len > dtls1_max_handshake_message_len(s))\n@@ -780,7 +788,15 @@ dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n \t\tif ( item == NULL)\n \t\t\tgoto err;\n \n-\t\tpqueue_insert(s->d1->buffered_messages, item);\n+\t\titem = pqueue_insert(s->d1->buffered_messages, item);\n+\t\t\/* pqueue_insert fails iff a duplicate item is inserted.\n+\t\t * However, |item| cannot be a duplicate. If it were,\n+\t\t * |pqueue_find|, above, would have returned it. Then, either\n+\t\t * |frag_len| != |msg_hdr->msg_len| in which case |item| is set\n+\t\t * to NULL and it will have been processed with\n+\t\t * |dtls1_reassemble_fragment|, above, or the record will have\n+\t\t * been discarded. *\/\n+\t\tOPENSSL_assert(item != NULL);\n \t\t}\n \n \treturn DTLS1_HM_FRAGMENT_RETRY;\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-13311","CWE_ID":"399","category":"security","commit_id":"4a334bbf5584de37c6f5a47c380a531c8c4b140a","commit_message":"From 4a334bbf5584de37c6f5a47c380a531c8c4b140a Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 1 Jul 2019 19:53:59 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1623\n\n---\n MagickWand\/mogrify.c   | 22 ++++++++++++++++-\n MagickWand\/operation.c | 54 +++++++++++++++++++++++++++++++-----------\n 2 files changed, 61 insertions(+), 15 deletions(-)\n\n","diff_code":"diff --git a\/MagickWand\/mogrify.c b\/MagickWand\/mogrify.c\nindex 150b679230..9f7eb6b551 100644\n--- a\/MagickWand\/mogrify.c\n+++ b\/MagickWand\/mogrify.c\n@@ -7824,6 +7824,9 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n             clut_image=RemoveFirstImageFromList(images);\n             if (clut_image == (Image *) NULL)\n               {\n+                (void) ThrowMagickException(exception,GetMagickModule(),\n+                  OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+                image=DestroyImage(image);\n                 status=MagickFalse;\n                 break;\n               }\n@@ -7896,6 +7899,9 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n             reconstruct_image=RemoveFirstImageFromList(images);\n             if (reconstruct_image == (Image *) NULL)\n               {\n+                (void) ThrowMagickException(exception,GetMagickModule(),\n+                  OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+                image=DestroyImage(image);\n                 status=MagickFalse;\n                 break;\n               }\n@@ -7976,7 +7982,13 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n             new_images=RemoveFirstImageFromList(images);\n             source_image=RemoveFirstImageFromList(images);\n             if (source_image == (Image *) NULL)\n-              break; \/* FUTURE - produce Exception, rather than silent fail *\/\n+              {\n+                (void) ThrowMagickException(exception,GetMagickModule(),\n+                  OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+                new_images=DestroyImage(new_images);\n+                status=MagickFalse;\n+                break;\n+              }\n \n             \/* FUTURE: this should not be here! - should be part of -geometry *\/\n             if (source_image->geometry != (char *) NULL)\n@@ -8228,6 +8240,9 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n             hald_image=RemoveFirstImageFromList(images);\n             if (hald_image == (Image *) NULL)\n               {\n+                (void) ThrowMagickException(exception,GetMagickModule(),\n+                  OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+                image=DestroyImage(image);\n                 status=MagickFalse;\n                 break;\n               }\n@@ -8257,11 +8272,16 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n             phase_image=RemoveFirstImageFromList(images);\n             if (phase_image == (Image *) NULL)\n               {\n+                (void) ThrowMagickException(exception,GetMagickModule(),\n+                  OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+                magnitude_image=DestroyImage(magnitude_image);\n                 status=MagickFalse;\n                 break;\n               }\n             fourier_image=InverseFourierTransformImage(magnitude_image,\n               phase_image,*option == '-' ? MagickTrue : MagickFalse,exception);\n+            magnitude_image=DestroyImage(magnitude_image);\n+            phase_image=DestroyImage(phase_image);\n             if (fourier_image == (Image *) NULL)\n               break;\n             if (*images != (Image *) NULL)\ndiff --git a\/MagickWand\/operation.c b\/MagickWand\/operation.c\nindex b874574346..57a29ac91f 100644\n--- a\/MagickWand\/operation.c\n+++ b\/MagickWand\/operation.c\n@@ -3821,10 +3821,16 @@ WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n              _images.\n           *\/\n           new_images=RemoveFirstImageFromList(&_images);\n-          clut_image=RemoveLastImageFromList(&_images);\n+          clut_image=RemoveFirstImageFromList(&_images);\n           \/* FUTURE - produce Exception, rather than silent fail *\/\n           if (clut_image == (Image *) NULL)\n-            break;\n+            {\n+              (void) ThrowMagickException(_exception,GetMagickModule(),\n+                OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+              new_images=DestroyImage(new_images);\n+              status=MagickFalse;\n+              break;\n+            }\n           (void) ClutImage(new_images,clut_image,new_images->interpolate,\n             _exception);\n           clut_image=DestroyImage(clut_image);\n@@ -3868,8 +3874,11 @@ WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n           reconstruct_image=RemoveFirstImageFromList(&_images);\n           \/* FUTURE - produce Exception, rather than silent fail *\/\n           if (reconstruct_image == (Image *) NULL)\n-            { \n+            {\n+              (void) ThrowMagickException(_exception,GetMagickModule(),\n+                OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n               image=DestroyImage(image);\n+              status=MagickFalse;\n               break;\n             }\n           metric=UndefinedErrorMetric;\n@@ -3931,7 +3940,13 @@ WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n           new_images=RemoveFirstImageFromList(&_images);\n           source_image=RemoveFirstImageFromList(&_images);\n           if (source_image == (Image *) NULL)\n-            break; \/* FUTURE - produce Exception, rather than silent fail *\/\n+            {\n+              (void) ThrowMagickException(_exception,GetMagickModule(),\n+                OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+              new_images=DestroyImage(new_images);\n+              status=MagickFalse;\n+              break;\n+            }\n \n           \/* FUTURE - this should not be here! - should be part of -geometry *\/\n           if (source_image->geometry != (char *) NULL)\n@@ -4121,7 +4136,13 @@ WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n           new_images=RemoveFirstImageFromList(&_images);\n           hald_image=RemoveLastImageFromList(&_images);\n           if (hald_image == (Image *) NULL)\n-            break;\n+            {\n+              (void) ThrowMagickException(_exception,GetMagickModule(),\n+                OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+              new_images=DestroyImage(new_images);\n+              status=MagickFalse;\n+              break;\n+            }\n           (void) HaldClutImage(new_images,hald_image,_exception);\n           hald_image=DestroyImage(hald_image);\n           break;\n@@ -4136,15 +4157,20 @@ WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n             *magnitude_image,\n             *phase_image;\n \n-           magnitude_image=RemoveFirstImageFromList(&_images);\n-           phase_image=RemoveFirstImageFromList(&_images);\n-          \/* FUTURE - produce Exception, rather than silent fail *\/\n-           if (phase_image == (Image *) NULL)\n-             break;\n-           new_images=InverseFourierTransformImage(magnitude_image,phase_image,\n-             IsNormalOp,_exception);\n-           magnitude_image=DestroyImage(magnitude_image);\n-           phase_image=DestroyImage(phase_image);\n+          magnitude_image=RemoveFirstImageFromList(&_images);\n+          phase_image=RemoveFirstImageFromList(&_images);\n+          if (phase_image == (Image *) NULL)\n+            {\n+              (void) ThrowMagickException(_exception,GetMagickModule(),\n+                OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+              magnitude_image=DestroyImage(magnitude_image);\n+              status=MagickFalse;\n+              break;\n+            }\n+          new_images=InverseFourierTransformImage(magnitude_image,phase_image,\n+            IsNormalOp,_exception);\n+          magnitude_image=DestroyImage(magnitude_image);\n+          phase_image=DestroyImage(phase_image);\n           break;\n         }\n       if (LocaleCompare(\"insert\",option+1) == 0)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2010-4250","CWE_ID":"399","category":"security","commit_id":"a2ae4cc9a16e211c8a128ba10d22a85431f093ab","commit_message":"From a2ae4cc9a16e211c8a128ba10d22a85431f093ab Mon Sep 17 00:00:00 2001\nFrom: Eric Paris <eparis@redhat.com>\nDate: Tue, 23 Nov 2010 18:18:37 -0500\nSubject: [PATCH] inotify: stop kernel memory leak on file creation failure\n\nIf inotify_init is unable to allocate a new file for the new inotify\ngroup we leak the new group.  This patch drops the reference on the\ngroup on file allocation failure.\n\nReported-by: Vegard Nossum <vegard.nossum@gmail.com>\ncc: stable@kernel.org\nSigned-off-by: Eric Paris <eparis@redhat.com>\n---\n fs\/notify\/inotify\/inotify_user.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/fs\/notify\/inotify\/inotify_user.c b\/fs\/notify\/inotify\/inotify_user.c\nindex 444c305a468c5..4cd5d5d78f9fa 100644\n--- a\/fs\/notify\/inotify\/inotify_user.c\n+++ b\/fs\/notify\/inotify\/inotify_user.c\n@@ -752,6 +752,7 @@ SYSCALL_DEFINE1(inotify_init1, int, flags)\n \tif (ret >= 0)\n \t\treturn ret;\n \n+\tfsnotify_put_group(group);\n \tatomic_dec(&user->inotify_devs);\n out_free_uid:\n \tfree_uid(user);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-2779","CWE_ID":"399","category":"security","commit_id":"b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8","commit_message":"From b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8 Mon Sep 17 00:00:00 2001\nFrom: Michael Marley <michael@michaelmarley.com>\nDate: Sat, 21 Feb 2015 07:33:57 -0500\nSubject: [PATCH] Improve the message-splitting algorithm for PRIVMSG and CTCP\n\nThis introduces a new message splitting algorithm based on\nQTextBoundaryFinder.  It works by first starting with the entire\nmessage to be sent, encoding it, and checking to see if it is over\nthe maximum message length.  If it is, it uses QTBF to find the\nword boundary most immediately preceding the maximum length.  If no\nsuitable boundary can be found, it falls back to searching for\ngrapheme boundaries.  It repeats this process until the entire\nmessage has been sent.\n\nUnlike what it replaces, the new splitting code is not recursive\nand cannot cause stack overflows.  Additionally, if it is unable\nto split a string, it will give up gracefully and not crash the\ncore or cause a thread to run away.\n\nThis patch fixes two bugs.  The first is garbage characters caused\nby accidentally splitting the string in the middle of a multibyte\ncharacter.  Since the new code splits at a character level instead\nof a byte level, this will no longer be an issue.  The second is\nthe core crash caused by sending an overlength CTCP query (\"\/me\")\ncontaining only multibyte characters.  This bug was caused by the\nold CTCP splitter using the byte index from lastParamOverrun() as\na character index for a QString.\n---\n src\/core\/corebasichandler.cpp     |  3 ++\n src\/core\/corebasichandler.h       |  1 +\n src\/core\/corenetwork.cpp          | 86 +++++++++++++++++++++++++++++++\n src\/core\/corenetwork.h            |  5 ++\n src\/core\/coreuserinputhandler.cpp | 72 +++++++++-----------------\n src\/core\/coreuserinputhandler.h   |  2 +-\n src\/core\/ctcpparser.cpp           | 26 ++--------\n 7 files changed, 124 insertions(+), 71 deletions(-)\n\n","diff_code":"diff --git a\/src\/core\/corebasichandler.cpp b\/src\/core\/corebasichandler.cpp\nindex dfa8a9964..fbfc76c2f 100644\n--- a\/src\/core\/corebasichandler.cpp\n+++ b\/src\/core\/corebasichandler.cpp\n@@ -33,6 +33,9 @@ CoreBasicHandler::CoreBasicHandler(CoreNetwork *parent)\n     connect(this, SIGNAL(putCmd(QString, const QList<QByteArray> &, const QByteArray &)),\n         network(), SLOT(putCmd(QString, const QList<QByteArray> &, const QByteArray &)));\n \n+    connect(this, SIGNAL(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)),\n+        network(), SLOT(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)));\n+\n     connect(this, SIGNAL(putRawLine(const QByteArray &)),\n         network(), SLOT(putRawLine(const QByteArray &)));\n }\ndiff --git a\/src\/core\/corebasichandler.h b\/src\/core\/corebasichandler.h\nindex 20d057fc4..a4b5a7f1f 100644\n--- a\/src\/core\/corebasichandler.h\n+++ b\/src\/core\/corebasichandler.h\n@@ -55,6 +55,7 @@ class CoreBasicHandler : public BasicHandler\n signals:\n     void displayMsg(Message::Type, BufferInfo::Type, const QString &target, const QString &text, const QString &sender = \"\", Message::Flags flags = Message::None);\n     void putCmd(const QString &cmd, const QList<QByteArray> &params, const QByteArray &prefix = QByteArray());\n+    void putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix = QByteArray());\n     void putRawLine(const QByteArray &msg);\n \n protected:\ndiff --git a\/src\/core\/corenetwork.cpp b\/src\/core\/corenetwork.cpp\nindex 7e9ce2681..932af6fc4 100644\n--- a\/src\/core\/corenetwork.cpp\n+++ b\/src\/core\/corenetwork.cpp\n@@ -284,6 +284,16 @@ void CoreNetwork::putCmd(const QString &cmd, const QList<QByteArray> &params, co\n }\n \n \n+void CoreNetwork::putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix)\n+{\n+    QListIterator<QList<QByteArray>> i(params);\n+    while (i.hasNext()) {\n+        QList<QByteArray> msg = i.next();\n+        putCmd(cmd, msg, prefix);\n+    }\n+}\n+\n+\n void CoreNetwork::setChannelJoined(const QString &channel)\n {\n     _autoWhoQueue.prepend(channel.toLower()); \/\/ prepend so this new chan is the first to be checked\n@@ -980,3 +990,79 @@ void CoreNetwork::requestSetNetworkInfo(const NetworkInfo &info)\n         }\n     }\n }\n+\n+\n+QList<QList<QByteArray>> CoreNetwork::splitMessage(const QString &cmd, const QString &message, std::function<QList<QByteArray>(QString &)> cmdGenerator)\n+{\n+    QString wrkMsg(message);\n+    QList<QList<QByteArray>> msgsToSend;\n+\n+    \/\/ do while (wrkMsg.size() > 0)\n+    do {\n+        \/\/ First, check to see if the whole message can be sent at once.  The\n+        \/\/ cmdGenerator function is passed in by the caller and is used to encode\n+        \/\/ and encrypt (if applicable) the message, since different callers might\n+        \/\/ want to use different encoding or encode different values.\n+        int splitPos = wrkMsg.size();\n+        QList<QByteArray> initialSplitMsgEnc = cmdGenerator(wrkMsg);\n+        int initialOverrun = userInputHandler()->lastParamOverrun(cmd, initialSplitMsgEnc);\n+\n+        if (initialOverrun) {\n+            \/\/ If the message was too long to be sent, first try splitting it along\n+            \/\/ word boundaries with QTextBoundaryFinder.\n+            QString splitMsg(wrkMsg);\n+            QTextBoundaryFinder qtbf(QTextBoundaryFinder::Word, splitMsg);\n+            qtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n+            QList<QByteArray> splitMsgEnc;\n+            int overrun = initialOverrun;\n+\n+            while (overrun) {\n+                splitPos = qtbf.toPreviousBoundary();\n+\n+                \/\/ splitPos==-1 means the QTBF couldn't find a split point at all and\n+                \/\/ splitPos==0 means the QTBF could only find a boundary at the beginning of\n+                \/\/ the string.  Neither one of these works for us.\n+                if (splitPos > 0) {\n+                    \/\/ If a split point could be found, split the message there, calculate the\n+                    \/\/ overrun, and continue with the loop.\n+                    splitMsg = splitMsg.left(splitPos);\n+                    splitMsgEnc = cmdGenerator(splitMsg);\n+                    overrun = userInputHandler()->lastParamOverrun(cmd, splitMsgEnc);\n+                }\n+                else {\n+                    \/\/ If a split point could not be found (the beginning of the message\n+                    \/\/ is reached without finding a split point short enough to send) and we\n+                    \/\/ are still in Word mode, switch to Grapheme mode.  We also need to restore\n+                    \/\/ the full wrkMsg to splitMsg, since splitMsg may have been cut down during\n+                    \/\/ the previous attempt to find a split point.\n+                    if (qtbf.type() == QTextBoundaryFinder::Word) {\n+                        splitMsg = wrkMsg;\n+                        splitPos = splitMsg.size();\n+                        QTextBoundaryFinder graphemeQtbf(QTextBoundaryFinder::Grapheme, splitMsg);\n+                        graphemeQtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n+                        qtbf = graphemeQtbf;\n+                    }\n+                    else {\n+                        \/\/ If the QTBF fails to find a split point in Grapheme mode, we give up.\n+                        \/\/ This should never happen, but it should be handled anyway.\n+                        qWarning() << \"Unexpected failure to split message!\";\n+                        return msgsToSend;\n+                    }\n+                }\n+            }\n+\n+            \/\/ Once a message of sendable length has been found, remove it from the wrkMsg and\n+            \/\/ add it to the list of messages to be sent.\n+            wrkMsg.remove(0, splitPos);\n+            msgsToSend.append(splitMsgEnc);\n+        }\n+        else{\n+            \/\/ If the entire remaining message is short enough to be sent all at once, remove\n+            \/\/ it from the wrkMsg and add it to the list of messages to be sent.\n+            wrkMsg.remove(0, splitPos);\n+            msgsToSend.append(initialSplitMsgEnc);\n+        }\n+    } while (wrkMsg.size() > 0);\n+\n+    return msgsToSend;\n+}\ndiff --git a\/src\/core\/corenetwork.h b\/src\/core\/corenetwork.h\nindex 87121bab3..05565a47b 100644\n--- a\/src\/core\/corenetwork.h\n+++ b\/src\/core\/corenetwork.h\n@@ -40,6 +40,8 @@\n \n #include \"coresession.h\"\n \n+#include <functional>\n+\n class CoreIdentity;\n class CoreUserInputHandler;\n class CoreIgnoreListManager;\n@@ -93,6 +95,8 @@ class CoreNetwork : public Network\n     inline quint16 localPort() const { return socket.localPort(); }\n     inline quint16 peerPort() const { return socket.peerPort(); }\n \n+    QList<QList<QByteArray>> splitMessage(const QString &cmd, const QString &message, std::function<QList<QByteArray>(QString &)> cmdGenerator);\n+\n public slots:\n     virtual void setMyNick(const QString &mynick);\n \n@@ -112,6 +116,7 @@ public slots:\n     void userInput(BufferInfo bufferInfo, QString msg);\n     void putRawLine(QByteArray input);\n     void putCmd(const QString &cmd, const QList<QByteArray> &params, const QByteArray &prefix = QByteArray());\n+    void putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix = QByteArray());\n \n     void setChannelJoined(const QString &channel);\n     void setChannelParted(const QString &channel);\ndiff --git a\/src\/core\/coreuserinputhandler.cpp b\/src\/core\/coreuserinputhandler.cpp\nindex 33d1f67a8..72ac99602 100644\n--- a\/src\/core\/coreuserinputhandler.cpp\n+++ b\/src\/core\/coreuserinputhandler.cpp\n@@ -473,12 +473,16 @@ void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString\n         return;\n \n     QString target = msg.section(' ', 0, 0);\n-    QByteArray encMsg = userEncode(target, msg.section(' ', 1));\n+    QString msgSection = msg.section(' ', 1);\n+\n+    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n+        return userEncode(target, message);\n+    };\n \n #ifdef HAVE_QCA2\n-    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));\n+    putPrivmsg(target, msgSection, encodeFunc, network()->cipher(target));\n #else\n-    putPrivmsg(serverEncode(target), encMsg);\n+    putPrivmsg(target, msgSection, encodeFunc);\n #endif\n }\n \n@@ -594,11 +598,14 @@ void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString\n     if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n         return;  \/\/ server buffer\n \n-    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n+    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n+        return channelEncode(target, message);\n+    };\n+\n #ifdef HAVE_QCA2\n-    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n+    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc, network()->cipher(bufferInfo.bufferName()));\n #else\n-    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n+    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc);\n #endif\n     emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n }\n@@ -763,56 +770,23 @@ void CoreUserInputHandler::defaultHandler(QString cmd, const BufferInfo &bufferI\n }\n \n \n-void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)\n+void CoreUserInputHandler::putPrivmsg(const QString &target, const QString &message, std::function<QByteArray(const QString &, const QString &)> encodeFunc, Cipher *cipher)\n {\n-    \/\/ Encrypted messages need special care. There's no clear relation between cleartext and encrypted message length,\n-    \/\/ so we can't just compute the maxSplitPos. Instead, we need to loop through the splitpoints until the crypted\n-    \/\/ version is short enough...\n-    \/\/ TODO: check out how the various possible encryption methods behave length-wise and make\n-    \/\/       this clean by predicting the length of the crypted msg.\n-    \/\/       For example, blowfish-ebc seems to create 8-char chunks.\n+    QString cmd(\"PRIVMSG\");\n+    QByteArray targetEnc = serverEncode(target);\n \n-    static const char *cmd = \"PRIVMSG\";\n-    static const char *splitter = \" .,-!?\";\n+    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {\n+        QByteArray splitMsgEnc = encodeFunc(target, splitMsg);\n \n-    int maxSplitPos = message.count();\n-    int splitPos = maxSplitPos;\n-    forever {\n-        QByteArray crypted = message.left(splitPos);\n-        bool isEncrypted = false;\n #ifdef HAVE_QCA2\n-        if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {\n-            isEncrypted = cipher->encrypt(crypted);\n+        if (cipher && !cipher->key().isEmpty() && !splitMsg.isEmpty()) {\n+            cipher->encrypt(splitMsgEnc);\n         }\n #endif\n-        int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);\n-        if (overrun) {\n-            \/\/ In case this is not an encrypted msg, we can just cut off at the end\n-            if (!isEncrypted)\n-                maxSplitPos = message.count() - overrun;\n-\n-            splitPos = -1;\n-            for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n-                splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \/\/ keep split char on old line\n-            }\n-            if (splitPos <= 0 || splitPos > maxSplitPos)\n-                splitPos = maxSplitPos;\n-\n-            maxSplitPos = splitPos - 1;\n-            if (maxSplitPos <= 0) { \/\/ this should never happen, but who knows...\n-                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());\n-                return;\n-            }\n-            continue; \/\/ we never come back here for !encrypted!\n-        }\n-\n-        \/\/ now we have found a valid splitpos (or didn't need to split to begin with)\n-        putCmd(cmd, QList<QByteArray>() << target << crypted);\n-        if (splitPos < message.count())\n-            putPrivmsg(target, message.mid(splitPos), cipher);\n+        return QList<QByteArray>() << targetEnc << splitMsgEnc;\n+    };\n \n-        return;\n-    }\n+    putCmd(cmd, network()->splitMessage(cmd, message, cmdGenerator));\n }\n \n \ndiff --git a\/src\/core\/coreuserinputhandler.h b\/src\/core\/coreuserinputhandler.h\nindex 69a429ee8..6e69ce605 100644\n--- a\/src\/core\/coreuserinputhandler.h\n+++ b\/src\/core\/coreuserinputhandler.h\n@@ -88,7 +88,7 @@ public slots:\n private:\n     void doMode(const BufferInfo& bufferInfo, const QChar &addOrRemove, const QChar &mode, const QString &nickList);\n     void banOrUnban(const BufferInfo &bufferInfo, const QString &text, bool ban);\n-    void putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher = 0);\n+    void putPrivmsg(const QString &target, const QString &message, std::function<QByteArray(const QString &, const QString &)> encodeFunc, Cipher *cipher = 0);\n \n #ifdef HAVE_QCA2\n     QByteArray encrypt(const QString &target, const QByteArray &message, bool *didEncrypt = 0) const;\ndiff --git a\/src\/core\/ctcpparser.cpp b\/src\/core\/ctcpparser.cpp\nindex fba3d13e9..37b0af3e9 100644\n--- a\/src\/core\/ctcpparser.cpp\n+++ b\/src\/core\/ctcpparser.cpp\n@@ -312,29 +312,13 @@ QByteArray CtcpParser::pack(const QByteArray &ctcpTag, const QByteArray &message\n \n void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)\n {\n-    QList<QByteArray> params;\n-    params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));\n-\n-    static const char *splitter = \" .,-!?\";\n-    int maxSplitPos = message.count();\n-    int splitPos = maxSplitPos;\n+    QString cmd(\"PRIVMSG\");\n \n-    int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);\n-    if (overrun) {\n-        maxSplitPos = message.count() - overrun -2;\n-        splitPos = -1;\n-        for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n-            splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \/\/ keep split char on old line\n-        }\n-        if (splitPos <= 0 || splitPos > maxSplitPos)\n-            splitPos = maxSplitPos;\n-\n-        params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));\n-    }\n-    net->putCmd(\"PRIVMSG\", params);\n+    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {\n+        return QList<QByteArray>() << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, splitMsg)));\n+    };\n \n-    if (splitPos < message.count())\n-        query(net, bufname, ctcpTag, message.mid(splitPos));\n+    net->putCmd(cmd, net->splitMessage(cmd, message, cmdGenerator));\n }\n \n \n","owner":"quassel","repo":"quassel","source":"cve"},{"CVE_ID":"CVE-2011-3946","CWE_ID":"399","category":"security","commit_id":"9decfc17bb76da34734296048d390b176abf404c","commit_message":"From 9decfc17bb76da34734296048d390b176abf404c Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Thu, 26 Jan 2012 19:31:01 +0100\nSubject: [PATCH] h264_sei: Fix infinite loop.\n\nFixes not yet fixed parts of CVE-2011-3946.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/h264_sei.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/h264_sei.c b\/libavcodec\/h264_sei.c\nindex 374e53dfcf..80d70e513c 100644\n--- a\/libavcodec\/h264_sei.c\n+++ b\/libavcodec\/h264_sei.c\n@@ -169,11 +169,15 @@ int ff_h264_decode_sei(H264Context *h){\n \n         type=0;\n         do{\n+            if (get_bits_left(&s->gb) < 8)\n+                return -1;\n             type+= show_bits(&s->gb, 8);\n         }while(get_bits(&s->gb, 8) == 255);\n \n         size=0;\n         do{\n+            if (get_bits_left(&s->gb) < 8)\n+                return -1;\n             size+= show_bits(&s->gb, 8);\n         }while(get_bits(&s->gb, 8) == 255);\n \n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-8858","CWE_ID":"399","category":"security","commit_id":"ec165c392ca54317dbe3064a8c200de6531e89ad","commit_message":"From ec165c392ca54317dbe3064a8c200de6531e89ad Mon Sep 17 00:00:00 2001\nFrom: \"markus@openbsd.org\" <markus@openbsd.org>\nDate: Mon, 10 Oct 2016 19:28:48 +0000\nSubject: [PATCH] upstream commit\n\nUnregister the KEXINIT handler after message has been\nreceived. Otherwise an unauthenticated peer can repeat the KEXINIT and cause\nallocation of up to 128MB -- until the connection is closed. Reported by\nshilei-c at 360.cn\n\nUpstream-ID: 43649ae12a27ef94290db16d1a98294588b75c05\n---\n kex.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/kex.c b\/kex.c\nindex 3f97f8c00..6a94bc535 100644\n--- a\/kex.c\n+++ b\/kex.c\n@@ -1,4 +1,4 @@\n-\/* $OpenBSD: kex.c,v 1.126 2016\/09\/28 21:44:52 djm Exp $ *\/\n+\/* $OpenBSD: kex.c,v 1.127 2016\/10\/10 19:28:48 markus Exp $ *\/\n \/*\n  * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n  *\n@@ -481,6 +481,7 @@ kex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n \tif (kex == NULL)\n \t\treturn SSH_ERR_INVALID_ARGUMENT;\n \n+\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL);\n \tptr = sshpkt_ptr(ssh, &dlen);\n \tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n \t\treturn r;\n","owner":"openssh","repo":"openssh-portable","source":"cve"},{"CVE_ID":"CVE-2019-7396","CWE_ID":"399","category":"security","commit_id":"748a03651e5b138bcaf160d15133de2f4b1b89ce","commit_message":"From 748a03651e5b138bcaf160d15133de2f4b1b89ce Mon Sep 17 00:00:00 2001\nFrom: Cristy <mikayla-grace@urban-warrior.org>\nDate: Sun, 20 Jan 2019 11:01:24 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1452\n\n---\n coders\/sixel.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/coders\/sixel.c b\/coders\/sixel.c\nindex a8a658f352..ae32db8749 100644\n--- a\/coders\/sixel.c\n+++ b\/coders\/sixel.c\n@@ -1057,6 +1057,7 @@ static Image *ReadSIXELImage(const ImageInfo *image_info,ExceptionInfo *exceptio\n   if (sixel_decode(image,(unsigned char *) sixel_buffer,&sixel_pixels,&image->columns,&image->rows,&sixel_palette,&image->colors,exception) == MagickFalse)\n     {\n       sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n+      sixel_pixels=(unsigned char *) RelinquishMagickMemory(sixel_pixels);\n       ThrowReaderException(CorruptImageError,\"CorruptImage\");\n     }\n   sixel_buffer=(char *) RelinquishMagickMemory(sixel_buffer);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-7348","CWE_ID":"399","category":"security","commit_id":"d558023207e008a4476a3b7bb8706b2a2bf5d84f","commit_message":"From d558023207e008a4476a3b7bb8706b2a2bf5d84f Mon Sep 17 00:00:00 2001\nFrom: Sasha Levin <sasha.levin@oracle.com>\nDate: Tue, 19 Nov 2013 17:33:02 -0500\nSubject: [PATCH] aio: prevent double free in ioctx_alloc\n\nioctx_alloc() calls aio_setup_ring() to allocate a ring. If aio_setup_ring()\nfails to do so it would call aio_free_ring() before returning, but\nioctx_alloc() would call aio_free_ring() again causing a double free of\nthe ring.\n\nThis is easily reproducible from userspace.\n\nSigned-off-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: Benjamin LaHaise <bcrl@kvack.org>\n---\n fs\/aio.c | 1 -\n 1 file changed, 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/aio.c b\/fs\/aio.c\nindex ee77dc13d5b22..63135331cec27 100644\n--- a\/fs\/aio.c\n+++ b\/fs\/aio.c\n@@ -610,7 +610,6 @@ static struct kioctx *ioctx_alloc(unsigned nr_events)\n err_cleanup:\n \taio_nr_sub(ctx->max_reqs);\n err:\n-\taio_free_ring(ctx);\n \tfree_percpu(ctx->cpu);\n \tfree_percpu(ctx->reqs.pcpu_count);\n \tfree_percpu(ctx->users.pcpu_count);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-6888","CWE_ID":"399","category":"security","commit_id":"4f47b63e9c971e6391590caf00a0f2a5ed612e67","commit_message":"From 4f47b63e9c971e6391590caf00a0f2a5ed612e67 Mon Sep 17 00:00:00 2001\nFrom: Erik de Castro Lopo <erikd@mega-nerd.com>\nDate: Sat, 8 Apr 2017 18:34:49 +1000\nSubject: [PATCH] stream_decoder.c: Fix a memory leak\n\nLeak reported by Secunia Research.\n---\n src\/libFLAC\/stream_decoder.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/src\/libFLAC\/stream_decoder.c b\/src\/libFLAC\/stream_decoder.c\nindex 14d5fe7f..a5527511 100644\n--- a\/src\/libFLAC\/stream_decoder.c\n+++ b\/src\/libFLAC\/stream_decoder.c\n@@ -1753,6 +1753,9 @@ FLAC__bool read_metadata_vorbiscomment_(FLAC__StreamDecoder *decoder, FLAC__Stre\n \t\t\t\t\t}\n \t\t\t\t\tmemset (obj->comments[i].entry, 0, obj->comments[i].length) ;\n \t\t\t\t\tif (!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->comments[i].entry, obj->comments[i].length)) {\n+\t\t\t\t\t\t\/* Current i-th entry is bad, so we delete it. *\/\n+\t\t\t\t\t\tfree (obj->comments[i].entry) ;\n+\t\t\t\t\t\tobj->comments[i].entry = NULL ;\n \t\t\t\t\t\tobj->num_comments = i;\n \t\t\t\t\t\tgoto skip;\n \t\t\t\t\t}\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-13301","CWE_ID":"399","category":"security","commit_id":"f595a1985233c399a05c0c37cc41de16a90dd025","commit_message":"From f595a1985233c399a05c0c37cc41de16a90dd025 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sat, 15 Jun 2019 22:02:18 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1589\n\n---\n MagickCore\/annotate.c | 13 +++++++++++--\n 1 file changed, 11 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/MagickCore\/annotate.c b\/MagickCore\/annotate.c\nindex a1145780ac..494720211e 100644\n--- a\/MagickCore\/annotate.c\n+++ b\/MagickCore\/annotate.c\n@@ -274,7 +274,11 @@ MagickExport MagickBooleanType AnnotateImage(Image *image,\n       number_lines++;\n   textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist));\n   if (textlist == (char **) NULL)\n-    return(MagickFalse);\n+    {\n+      annotate_info=DestroyDrawInfo(annotate_info);\n+      annotate=DestroyDrawInfo(annotate);\n+      return(MagickFalse);\n+    }\n   p=text;\n   for (i=0; i < number_lines; i++)\n   {\n@@ -303,7 +307,12 @@ MagickExport MagickBooleanType AnnotateImage(Image *image,\n       (void) ParseGeometry(annotate_info->geometry,&geometry_info);\n     }\n   if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n-    return(MagickFalse);\n+    {\n+      annotate_info=DestroyDrawInfo(annotate_info);\n+      annotate=DestroyDrawInfo(annotate);\n+      textlist=(char **) RelinquishMagickMemory(textlist);\n+      return(MagickFalse);\n+    }\n   if (IsGrayColorspace(image->colorspace) != MagickFalse)\n     (void) SetImageColorspace(image,sRGBColorspace,exception);\n   status=MagickTrue;\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2015-7540","CWE_ID":"399","category":"security","commit_id":"530d50a1abdcdf4d1775652d4c456c1274d83d8d","commit_message":"From 530d50a1abdcdf4d1775652d4c456c1274d83d8d Mon Sep 17 00:00:00 2001\nFrom: Jeremy Allison <jra@samba.org>\nDate: Mon, 22 Sep 2014 16:08:26 -0700\nSubject: [PATCH] CVE-2015-7540: s4: libcli: ldap message - Ensure all asn1_XX\n returns are checked.\n\nBUG: https:\/\/bugzilla.samba.org\/show_bug.cgi?id=9187\n\nSigned-off-by: Jeremy Allison <jra@samba.org>\nReviewed-by: Ronnie Sahlberg <ronniesahlberg@gmail.com>\n\nAutobuild-User(master): Jeremy Allison <jra@samba.org>\nAutobuild-Date(master): Fri Sep 26 03:15:00 CEST 2014 on sn-devel-104\n\n(cherry picked from commit 69a7e3cfdc8dbba9c8dcfdfae82d2894c7247e15)\n---\n libcli\/ldap\/ldap_message.c          | 786 ++++++++++++++--------------\n libcli\/ldap\/ldap_message.h          |   2 +-\n source4\/libcli\/ldap\/ldap_controls.c |   8 +-\n 3 files changed, 401 insertions(+), 395 deletions(-)\n\n","diff_code":"diff --git a\/libcli\/ldap\/ldap_message.c b\/libcli\/ldap\/ldap_message.c\nindex 1c5542c0d90..ba94f4ccfac 100644\n--- a\/libcli\/ldap\/ldap_message.c\n+++ b\/libcli\/ldap\/ldap_message.c\n@@ -229,31 +229,31 @@ static bool ldap_push_filter(struct asn1_data *data, struct ldb_parse_tree *tree\n \tswitch (tree->operation) {\n \tcase LDB_OP_AND:\n \tcase LDB_OP_OR:\n-\t\tasn1_push_tag(data, ASN1_CONTEXT(tree->operation==LDB_OP_AND?0:1));\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(tree->operation==LDB_OP_AND?0:1))) return false;\n \t\tfor (i=0; i<tree->u.list.num_elements; i++) {\n \t\t\tif (!ldap_push_filter(data, tree->u.list.elements[i])) {\n \t\t\t\treturn false;\n \t\t\t}\n \t\t}\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) return false;\n \t\tbreak;\n \n \tcase LDB_OP_NOT:\n-\t\tasn1_push_tag(data, ASN1_CONTEXT(2));\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(2))) return false;\n \t\tif (!ldap_push_filter(data, tree->u.isnot.child)) {\n \t\t\treturn false;\n \t\t}\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) return false;\n \t\tbreak;\n \n \tcase LDB_OP_EQUALITY:\n \t\t\/* equality test *\/\n-\t\tasn1_push_tag(data, ASN1_CONTEXT(3));\n-\t\tasn1_write_OctetString(data, tree->u.equality.attr,\n-\t\t\t\t      strlen(tree->u.equality.attr));\n-\t\tasn1_write_OctetString(data, tree->u.equality.value.data,\n-\t\t\t\t      tree->u.equality.value.length);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(3))) return false;\n+\t\tif (!asn1_write_OctetString(data, tree->u.equality.attr,\n+\t\t\t\t      strlen(tree->u.equality.attr))) return false;\n+\t\tif (!asn1_write_OctetString(data, tree->u.equality.value.data,\n+\t\t\t\t      tree->u.equality.value.length)) return false;\n+\t\tif (!asn1_pop_tag(data)) return false;\n \t\tbreak;\n \n \tcase LDB_OP_SUBSTRING:\n@@ -266,16 +266,16 @@ static bool ldap_push_filter(struct asn1_data *data, struct ldb_parse_tree *tree\n \t\t\t\t  any     [1] LDAPString,\n \t\t\t\t  final   [2] LDAPString } }\n \t\t*\/\n-\t\tasn1_push_tag(data, ASN1_CONTEXT(4));\n-\t\tasn1_write_OctetString(data, tree->u.substring.attr, strlen(tree->u.substring.attr));\n-\t\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(4))) return false;\n+\t\tif (!asn1_write_OctetString(data, tree->u.substring.attr, strlen(tree->u.substring.attr))) return false;\n+\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) return false;\n \n \t\tif (tree->u.substring.chunks && tree->u.substring.chunks[0]) {\n \t\t\ti = 0;\n \t\t\tif (!tree->u.substring.start_with_wildcard) {\n-\t\t\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(0));\n-\t\t\t\tasn1_write_DATA_BLOB_LDAPString(data, tree->u.substring.chunks[i]);\n-\t\t\t\tasn1_pop_tag(data);\n+\t\t\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(0))) return false;\n+\t\t\t\tif (!asn1_write_DATA_BLOB_LDAPString(data, tree->u.substring.chunks[i])) return false;\n+\t\t\t\tif (!asn1_pop_tag(data)) return false;\n \t\t\t\ti++;\n \t\t\t}\n \t\t\twhile (tree->u.substring.chunks[i]) {\n@@ -287,51 +287,51 @@ static bool ldap_push_filter(struct asn1_data *data, struct ldb_parse_tree *tree\n \t\t\t\t} else {\n \t\t\t\t\tctx = 1;\n \t\t\t\t}\n-\t\t\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(ctx));\n-\t\t\t\tasn1_write_DATA_BLOB_LDAPString(data, tree->u.substring.chunks[i]);\n-\t\t\t\tasn1_pop_tag(data);\n+\t\t\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(ctx))) return false;\n+\t\t\t\tif (!asn1_write_DATA_BLOB_LDAPString(data, tree->u.substring.chunks[i])) return false;\n+\t\t\t\tif (!asn1_pop_tag(data)) return false;\n \t\t\t\ti++;\n \t\t\t}\n \t\t}\n-\t\tasn1_pop_tag(data);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) return false;\n+\t\tif (!asn1_pop_tag(data)) return false;\n \t\tbreak;\n \n \tcase LDB_OP_GREATER:\n \t\t\/* greaterOrEqual test *\/\n-\t\tasn1_push_tag(data, ASN1_CONTEXT(5));\n-\t\tasn1_write_OctetString(data, tree->u.comparison.attr,\n-\t\t\t\t      strlen(tree->u.comparison.attr));\n-\t\tasn1_write_OctetString(data, tree->u.comparison.value.data,\n-\t\t\t\t      tree->u.comparison.value.length);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(5))) return false;\n+\t\tif (!asn1_write_OctetString(data, tree->u.comparison.attr,\n+\t\t\t\t      strlen(tree->u.comparison.attr))) return false;\n+\t\tif (!asn1_write_OctetString(data, tree->u.comparison.value.data,\n+\t\t\t\t      tree->u.comparison.value.length)) return false;\n+\t\tif (!asn1_pop_tag(data)) return false;\n \t\tbreak;\n \n \tcase LDB_OP_LESS:\n \t\t\/* lessOrEqual test *\/\n-\t\tasn1_push_tag(data, ASN1_CONTEXT(6));\n-\t\tasn1_write_OctetString(data, tree->u.comparison.attr,\n-\t\t\t\t      strlen(tree->u.comparison.attr));\n-\t\tasn1_write_OctetString(data, tree->u.comparison.value.data,\n-\t\t\t\t      tree->u.comparison.value.length);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(6))) return false;\n+\t\tif (!asn1_write_OctetString(data, tree->u.comparison.attr,\n+\t\t\t\t      strlen(tree->u.comparison.attr))) return false;\n+\t\tif (!asn1_write_OctetString(data, tree->u.comparison.value.data,\n+\t\t\t\t      tree->u.comparison.value.length)) return false;\n+\t\tif (!asn1_pop_tag(data)) return false;\n \t\tbreak;\n \n \tcase LDB_OP_PRESENT:\n \t\t\/* present test *\/\n-\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(7));\n-\t\tasn1_write_LDAPString(data, tree->u.present.attr);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(7))) return false;\n+\t\tif (!asn1_write_LDAPString(data, tree->u.present.attr)) return false;\n+\t\tif (!asn1_pop_tag(data)) return false;\n \t\treturn !data->has_error;\n \n \tcase LDB_OP_APPROX:\n \t\t\/* approx test *\/\n-\t\tasn1_push_tag(data, ASN1_CONTEXT(8));\n-\t\tasn1_write_OctetString(data, tree->u.comparison.attr,\n-\t\t\t\t      strlen(tree->u.comparison.attr));\n-\t\tasn1_write_OctetString(data, tree->u.comparison.value.data,\n-\t\t\t\t      tree->u.comparison.value.length);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(8))) return false;\n+\t\tif (!asn1_write_OctetString(data, tree->u.comparison.attr,\n+\t\t\t\t      strlen(tree->u.comparison.attr))) return false;\n+\t\tif (!asn1_write_OctetString(data, tree->u.comparison.value.data,\n+\t\t\t\t      tree->u.comparison.value.length)) return false;\n+\t\tif (!asn1_pop_tag(data)) return false;\n \t\tbreak;\n \n \tcase LDB_OP_EXTENDED:\n@@ -343,24 +343,24 @@ static bool ldap_push_filter(struct asn1_data *data, struct ldb_parse_tree *tree\n \t\t  dnAttributes    [4] BOOLEAN DEFAULT FALSE\n \t\t  }\n \t\t*\/\n-\t\tasn1_push_tag(data, ASN1_CONTEXT(9));\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(9))) return false;\n \t\tif (tree->u.extended.rule_id) {\n-\t\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(1));\n-\t\t\tasn1_write_LDAPString(data, tree->u.extended.rule_id);\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(1))) return false;\n+\t\t\tif (!asn1_write_LDAPString(data, tree->u.extended.rule_id)) return false;\n+\t\t\tif (!asn1_pop_tag(data)) return false;\n \t\t}\n \t\tif (tree->u.extended.attr) {\n-\t\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(2));\n-\t\t\tasn1_write_LDAPString(data, tree->u.extended.attr);\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(2))) return false;\n+\t\t\tif (!asn1_write_LDAPString(data, tree->u.extended.attr)) return false;\n+\t\t\tif (!asn1_pop_tag(data)) return false;\n \t\t}\n-\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(3));\n-\t\tasn1_write_DATA_BLOB_LDAPString(data, &tree->u.extended.value);\n-\t\tasn1_pop_tag(data);\n-\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(4));\n-\t\tasn1_write_uint8(data, tree->u.extended.dnAttributes);\n-\t\tasn1_pop_tag(data);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(3))) return false;\n+\t\tif (!asn1_write_DATA_BLOB_LDAPString(data, &tree->u.extended.value)) return false;\n+\t\tif (!asn1_pop_tag(data)) return false;\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(4))) return false;\n+\t\tif (!asn1_write_uint8(data, tree->u.extended.dnAttributes)) return false;\n+\t\tif (!asn1_pop_tag(data)) return false;\n+\t\tif (!asn1_pop_tag(data)) return false;\n \t\tbreak;\n \n \tdefault:\n@@ -369,20 +369,21 @@ static bool ldap_push_filter(struct asn1_data *data, struct ldb_parse_tree *tree\n \treturn !data->has_error;\n }\n \n-static void ldap_encode_response(struct asn1_data *data, struct ldap_Result *result)\n+static bool ldap_encode_response(struct asn1_data *data, struct ldap_Result *result)\n {\n-\tasn1_write_enumerated(data, result->resultcode);\n-\tasn1_write_OctetString(data, result->dn,\n-\t\t\t       (result->dn) ? strlen(result->dn) : 0);\n-\tasn1_write_OctetString(data, result->errormessage,\n+\tif (!asn1_write_enumerated(data, result->resultcode)) return false;\n+\tif (!asn1_write_OctetString(data, result->dn,\n+\t\t\t       (result->dn) ? strlen(result->dn) : 0)) return false;\n+\tif (!asn1_write_OctetString(data, result->errormessage,\n \t\t\t       (result->errormessage) ?\n-\t\t\t       strlen(result->errormessage) : 0);\n+\t\t\t       strlen(result->errormessage) : 0)) return false;\n \tif (result->referral) {\n-\t\tasn1_push_tag(data, ASN1_CONTEXT(3));\n-\t\tasn1_write_OctetString(data, result->referral,\n-\t\t\t\t       strlen(result->referral));\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(3))) return false;\n+\t\tif (!asn1_write_OctetString(data, result->referral,\n+\t\t\t\t       strlen(result->referral))) return false;\n+\t\tif (!asn1_pop_tag(data)) return false;\n \t}\n+\treturn true;\n }\n \n _PUBLIC_ bool ldap_encode(struct ldap_message *msg,\n@@ -394,286 +395,286 @@ _PUBLIC_ bool ldap_encode(struct ldap_message *msg,\n \n \tif (!data) return false;\n \n-\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n-\tasn1_write_Integer(data, msg->messageid);\n+\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) goto err;\n+\tif (!asn1_write_Integer(data, msg->messageid)) goto err;\n \n \tswitch (msg->type) {\n \tcase LDAP_TAG_BindRequest: {\n \t\tstruct ldap_BindRequest *r = &msg->r.BindRequest;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tasn1_write_Integer(data, r->version);\n-\t\tasn1_write_OctetString(data, r->dn,\n-\t\t\t\t       (r->dn != NULL) ? strlen(r->dn) : 0);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!asn1_write_Integer(data, r->version)) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->dn,\n+\t\t\t\t       (r->dn != NULL) ? strlen(r->dn) : 0)) goto err;\n \n \t\tswitch (r->mechanism) {\n \t\tcase LDAP_AUTH_MECH_SIMPLE:\n \t\t\t\/* context, primitive *\/\n-\t\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(0));\n-\t\t\tasn1_write(data, r->creds.password,\n-\t\t\t\t   strlen(r->creds.password));\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(0))) goto err;\n+\t\t\tif (!asn1_write(data, r->creds.password,\n+\t\t\t\t   strlen(r->creds.password))) goto err;\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n \t\t\tbreak;\n \t\tcase LDAP_AUTH_MECH_SASL:\n \t\t\t\/* context, constructed *\/\n-\t\t\tasn1_push_tag(data, ASN1_CONTEXT(3));\n-\t\t\tasn1_write_OctetString(data, r->creds.SASL.mechanism,\n-\t\t\t\t\t       strlen(r->creds.SASL.mechanism));\n+\t\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(3))) goto err;\n+\t\t\tif (!asn1_write_OctetString(data, r->creds.SASL.mechanism,\n+\t\t\t\t\t       strlen(r->creds.SASL.mechanism))) goto err;\n \t\t\tif (r->creds.SASL.secblob) {\n-\t\t\t\tasn1_write_OctetString(data, r->creds.SASL.secblob->data,\n-\t\t\t\t\t\t       r->creds.SASL.secblob->length);\n+\t\t\t\tif (!asn1_write_OctetString(data, r->creds.SASL.secblob->data,\n+\t\t\t\t\t\t       r->creds.SASL.secblob->length)) goto err;\n \t\t\t}\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\treturn false;\n+\t\t\tgoto err;\n \t\t}\n \n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_BindResponse: {\n \t\tstruct ldap_BindResponse *r = &msg->r.BindResponse;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tldap_encode_response(data, &r->response);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!ldap_encode_response(data, &r->response)) goto err;\n \t\tif (r->SASL.secblob) {\n-\t\t\tasn1_write_ContextSimple(data, 7, r->SASL.secblob);\n+\t\t\tif (!asn1_write_ContextSimple(data, 7, r->SASL.secblob)) goto err;\n \t\t}\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_UnbindRequest: {\n \/*\t\tstruct ldap_UnbindRequest *r = &msg->r.UnbindRequest; *\/\n-\t\tasn1_push_tag(data, ASN1_APPLICATION_SIMPLE(msg->type));\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION_SIMPLE(msg->type))) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_SearchRequest: {\n \t\tstruct ldap_SearchRequest *r = &msg->r.SearchRequest;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tasn1_write_OctetString(data, r->basedn, strlen(r->basedn));\n-\t\tasn1_write_enumerated(data, r->scope);\n-\t\tasn1_write_enumerated(data, r->deref);\n-\t\tasn1_write_Integer(data, r->sizelimit);\n-\t\tasn1_write_Integer(data, r->timelimit);\n-\t\tasn1_write_BOOLEAN(data, r->attributesonly);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->basedn, strlen(r->basedn))) goto err;\n+\t\tif (!asn1_write_enumerated(data, r->scope)) goto err;\n+\t\tif (!asn1_write_enumerated(data, r->deref)) goto err;\n+\t\tif (!asn1_write_Integer(data, r->sizelimit)) goto err;\n+\t\tif (!asn1_write_Integer(data, r->timelimit)) goto err;\n+\t\tif (!asn1_write_BOOLEAN(data, r->attributesonly)) goto err;\n \n \t\tif (!ldap_push_filter(data, r->tree)) {\n-\t\t\treturn false;\n+\t\t\tgoto err;\n \t\t}\n \n-\t\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n+\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) goto err;\n \t\tfor (i=0; i<r->num_attributes; i++) {\n-\t\t\tasn1_write_OctetString(data, r->attributes[i],\n-\t\t\t\t\t       strlen(r->attributes[i]));\n+\t\t\tif (!asn1_write_OctetString(data, r->attributes[i],\n+\t\t\t\t\t       strlen(r->attributes[i]))) goto err;\n \t\t}\n-\t\tasn1_pop_tag(data);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_SearchResultEntry: {\n \t\tstruct ldap_SearchResEntry *r = &msg->r.SearchResultEntry;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tasn1_write_OctetString(data, r->dn, strlen(r->dn));\n-\t\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->dn, strlen(r->dn))) goto err;\n+\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) goto err;\n \t\tfor (i=0; i<r->num_attributes; i++) {\n \t\t\tstruct ldb_message_element *attr = &r->attributes[i];\n-\t\t\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n-\t\t\tasn1_write_OctetString(data, attr->name,\n-\t\t\t\t\t       strlen(attr->name));\n-\t\t\tasn1_push_tag(data, ASN1_SEQUENCE(1));\n+\t\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) goto err;\n+\t\t\tif (!asn1_write_OctetString(data, attr->name,\n+\t\t\t\t\t       strlen(attr->name))) goto err;\n+\t\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(1))) goto err;\n \t\t\tfor (j=0; j<attr->num_values; j++) {\n-\t\t\t\tasn1_write_OctetString(data,\n+\t\t\t\tif (!asn1_write_OctetString(data,\n \t\t\t\t\t\t       attr->values[j].data,\n-\t\t\t\t\t\t       attr->values[j].length);\n+\t\t\t\t\t\t       attr->values[j].length)) goto err;\n \t\t\t}\n-\t\t\tasn1_pop_tag(data);\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n \t\t}\n-\t\tasn1_pop_tag(data);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_SearchResultDone: {\n \t\tstruct ldap_Result *r = &msg->r.SearchResultDone;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tldap_encode_response(data, r);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!ldap_encode_response(data, r)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_ModifyRequest: {\n \t\tstruct ldap_ModifyRequest *r = &msg->r.ModifyRequest;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tasn1_write_OctetString(data, r->dn, strlen(r->dn));\n-\t\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->dn, strlen(r->dn))) goto err;\n+\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) goto err;\n \n \t\tfor (i=0; i<r->num_mods; i++) {\n \t\t\tstruct ldb_message_element *attrib = &r->mods[i].attrib;\n-\t\t\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n-\t\t\tasn1_write_enumerated(data, r->mods[i].type);\n-\t\t\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n-\t\t\tasn1_write_OctetString(data, attrib->name,\n-\t\t\t\t\t       strlen(attrib->name));\n-\t\t\tasn1_push_tag(data, ASN1_SET);\n+\t\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) goto err;\n+\t\t\tif (!asn1_write_enumerated(data, r->mods[i].type)) goto err;\n+\t\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) goto err;\n+\t\t\tif (!asn1_write_OctetString(data, attrib->name,\n+\t\t\t\t\t       strlen(attrib->name))) goto err;\n+\t\t\tif (!asn1_push_tag(data, ASN1_SET)) goto err;\n \t\t\tfor (j=0; j<attrib->num_values; j++) {\n-\t\t\t\tasn1_write_OctetString(data,\n+\t\t\t\tif (!asn1_write_OctetString(data,\n \t\t\t\t\t\t       attrib->values[j].data,\n-\t\t\t\t\t\t       attrib->values[j].length);\n+\t\t\t\t\t\t       attrib->values[j].length)) goto err;\n \t\n \t\t\t}\n-\t\t\tasn1_pop_tag(data);\n-\t\t\tasn1_pop_tag(data);\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n \t\t}\n \t\t\n-\t\tasn1_pop_tag(data);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_ModifyResponse: {\n \t\tstruct ldap_Result *r = &msg->r.ModifyResponse;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tldap_encode_response(data, r);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!ldap_encode_response(data, r)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_AddRequest: {\n \t\tstruct ldap_AddRequest *r = &msg->r.AddRequest;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tasn1_write_OctetString(data, r->dn, strlen(r->dn));\n-\t\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->dn, strlen(r->dn))) goto err;\n+\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) goto err;\n \n \t\tfor (i=0; i<r->num_attributes; i++) {\n \t\t\tstruct ldb_message_element *attrib = &r->attributes[i];\n-\t\t\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n-\t\t\tasn1_write_OctetString(data, attrib->name,\n-\t\t\t\t\t       strlen(attrib->name));\n-\t\t\tasn1_push_tag(data, ASN1_SET);\n+\t\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) goto err;\n+\t\t\tif (!asn1_write_OctetString(data, attrib->name,\n+\t\t\t\t\t       strlen(attrib->name))) goto err;\n+\t\t\tif (!asn1_push_tag(data, ASN1_SET)) goto err;\n \t\t\tfor (j=0; j<r->attributes[i].num_values; j++) {\n-\t\t\t\tasn1_write_OctetString(data,\n+\t\t\t\tif (!asn1_write_OctetString(data,\n \t\t\t\t\t\t       attrib->values[j].data,\n-\t\t\t\t\t\t       attrib->values[j].length);\n+\t\t\t\t\t\t       attrib->values[j].length)) goto err;\n \t\t\t}\n-\t\t\tasn1_pop_tag(data);\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n \t\t}\n-\t\tasn1_pop_tag(data);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_AddResponse: {\n \t\tstruct ldap_Result *r = &msg->r.AddResponse;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tldap_encode_response(data, r);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!ldap_encode_response(data, r)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_DelRequest: {\n \t\tstruct ldap_DelRequest *r = &msg->r.DelRequest;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION_SIMPLE(msg->type));\n-\t\tasn1_write(data, r->dn, strlen(r->dn));\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION_SIMPLE(msg->type))) goto err;\n+\t\tif (!asn1_write(data, r->dn, strlen(r->dn))) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_DelResponse: {\n \t\tstruct ldap_Result *r = &msg->r.DelResponse;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tldap_encode_response(data, r);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!ldap_encode_response(data, r)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_ModifyDNRequest: {\n \t\tstruct ldap_ModifyDNRequest *r = &msg->r.ModifyDNRequest;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tasn1_write_OctetString(data, r->dn, strlen(r->dn));\n-\t\tasn1_write_OctetString(data, r->newrdn, strlen(r->newrdn));\n-\t\tasn1_write_BOOLEAN(data, r->deleteolddn);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->dn, strlen(r->dn))) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->newrdn, strlen(r->newrdn))) goto err;\n+\t\tif (!asn1_write_BOOLEAN(data, r->deleteolddn)) goto err;\n \t\tif (r->newsuperior) {\n-\t\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(0));\n-\t\t\tasn1_write(data, r->newsuperior,\n-\t\t\t\t   strlen(r->newsuperior));\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(0))) goto err;\n+\t\t\tif (!asn1_write(data, r->newsuperior,\n+\t\t\t\t   strlen(r->newsuperior))) goto err;\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n \t\t}\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_ModifyDNResponse: {\n \t\tstruct ldap_Result *r = &msg->r.ModifyDNResponse;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tldap_encode_response(data, r);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!ldap_encode_response(data, r)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_CompareRequest: {\n \t\tstruct ldap_CompareRequest *r = &msg->r.CompareRequest;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tasn1_write_OctetString(data, r->dn, strlen(r->dn));\n-\t\tasn1_push_tag(data, ASN1_SEQUENCE(0));\n-\t\tasn1_write_OctetString(data, r->attribute,\n-\t\t\t\t       strlen(r->attribute));\n-\t\tasn1_write_OctetString(data, r->value.data,\n-\t\t\t\t       r->value.length);\n-\t\tasn1_pop_tag(data);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->dn, strlen(r->dn))) goto err;\n+\t\tif (!asn1_push_tag(data, ASN1_SEQUENCE(0))) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->attribute,\n+\t\t\t\t       strlen(r->attribute))) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->value.data,\n+\t\t\t\t       r->value.length)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_CompareResponse: {\n \t\tstruct ldap_Result *r = &msg->r.ModifyDNResponse;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tldap_encode_response(data, r);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!ldap_encode_response(data, r)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_AbandonRequest: {\n \t\tstruct ldap_AbandonRequest *r = &msg->r.AbandonRequest;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION_SIMPLE(msg->type));\n-\t\tasn1_write_implicit_Integer(data, r->messageid);\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION_SIMPLE(msg->type))) goto err;\n+\t\tif (!asn1_write_implicit_Integer(data, r->messageid)) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_SearchResultReference: {\n \t\tstruct ldap_SearchResRef *r = &msg->r.SearchResultReference;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tasn1_write_OctetString(data, r->referral, strlen(r->referral));\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!asn1_write_OctetString(data, r->referral, strlen(r->referral))) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_ExtendedRequest: {\n \t\tstruct ldap_ExtendedRequest *r = &msg->r.ExtendedRequest;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(0));\n-\t\tasn1_write(data, r->oid, strlen(r->oid));\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(0))) goto err;\n+\t\tif (!asn1_write(data, r->oid, strlen(r->oid))) goto err;\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tif (r->value) {\n-\t\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(1));\n-\t\t\tasn1_write(data, r->value->data, r->value->length);\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(1))) goto err;\n+\t\t\tif (!asn1_write(data, r->value->data, r->value->length)) goto err;\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n \t\t}\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tcase LDAP_TAG_ExtendedResponse: {\n \t\tstruct ldap_ExtendedResponse *r = &msg->r.ExtendedResponse;\n-\t\tasn1_push_tag(data, ASN1_APPLICATION(msg->type));\n-\t\tldap_encode_response(data, &r->response);\n+\t\tif (!asn1_push_tag(data, ASN1_APPLICATION(msg->type))) goto err;\n+\t\tif (!ldap_encode_response(data, &r->response)) goto err;\n \t\tif (r->oid) {\n-\t\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(10));\n-\t\t\tasn1_write(data, r->oid, strlen(r->oid));\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(10))) goto err;\n+\t\t\tif (!asn1_write(data, r->oid, strlen(r->oid))) goto err;\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n \t\t}\n \t\tif (r->value) {\n-\t\t\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(11));\n-\t\t\tasn1_write(data, r->value->data, r->value->length);\n-\t\t\tasn1_pop_tag(data);\n+\t\t\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(11))) goto err;\n+\t\t\tif (!asn1_write(data, r->value->data, r->value->length)) goto err;\n+\t\t\tif (!asn1_pop_tag(data)) goto err;\n \t\t}\n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t\tbreak;\n \t}\n \tdefault:\n-\t\treturn false;\n+\t\tgoto err;\n \t}\n \n \tif (msg->controls != NULL) {\n-\t\tasn1_push_tag(data, ASN1_CONTEXT(0));\n+\t\tif (!asn1_push_tag(data, ASN1_CONTEXT(0))) goto err;\n \t\t\n \t\tfor (i = 0; msg->controls[i] != NULL; i++) {\n \t\t\tif (!ldap_encode_control(mem_ctx, data,\n@@ -681,23 +682,24 @@ _PUBLIC_ bool ldap_encode(struct ldap_message *msg,\n \t\t\t\t\t\t msg->controls[i])) {\n \t\t\t\tDEBUG(0,(\"Unable to encode control %s\\n\",\n \t\t\t\t\t msg->controls[i]->oid));\n-\t\t\t\treturn false;\n+\t\t\t\tgoto err;\n \t\t\t}\n \t\t}\n \n-\t\tasn1_pop_tag(data);\n+\t\tif (!asn1_pop_tag(data)) goto err;\n \t}\n \n-\tasn1_pop_tag(data);\n-\n-\tif (data->has_error) {\n-\t\tasn1_free(data);\n-\t\treturn false;\n-\t}\n+\tif (!asn1_pop_tag(data)) goto err;\n \n \t*result = data_blob_talloc(mem_ctx, data->data, data->length);\n \tasn1_free(data);\n+\n \treturn true;\n+\n+  err:\n+\n+\tasn1_free(data);\n+\treturn false;\n }\n \n static const char *blob2string_talloc(TALLOC_CTX *mem_ctx,\n@@ -721,20 +723,21 @@ bool asn1_read_OctetString_talloc(TALLOC_CTX *mem_ctx,\n \treturn true;\n }\n \n-static void ldap_decode_response(TALLOC_CTX *mem_ctx,\n+static bool ldap_decode_response(TALLOC_CTX *mem_ctx,\n \t\t\t\t struct asn1_data *data,\n \t\t\t\t struct ldap_Result *result)\n {\n-\tasn1_read_enumerated(data, &result->resultcode);\n-\tasn1_read_OctetString_talloc(mem_ctx, data, &result->dn);\n-\tasn1_read_OctetString_talloc(mem_ctx, data, &result->errormessage);\n+\tif (!asn1_read_enumerated(data, &result->resultcode)) return false;\n+\tif (!asn1_read_OctetString_talloc(mem_ctx, data, &result->dn)) return false;\n+\tif (!asn1_read_OctetString_talloc(mem_ctx, data, &result->errormessage)) return false;\n \tif (asn1_peek_tag(data, ASN1_CONTEXT(3))) {\n-\t\tasn1_start_tag(data, ASN1_CONTEXT(3));\n-\t\tasn1_read_OctetString_talloc(mem_ctx, data, &result->referral);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, ASN1_CONTEXT(3))) return false;\n+\t\tif (!asn1_read_OctetString_talloc(mem_ctx, data, &result->referral)) return false;\n+\t\tif (!asn1_end_tag(data)) return false;\n \t} else {\n \t\tresult->referral = NULL;\n \t}\n+\treturn true;\n }\n \n static struct ldb_val **ldap_decode_substring(TALLOC_CTX *mem_ctx, struct ldb_val **chunks, int chunk_num, char *value)\n@@ -835,10 +838,10 @@ static struct ldb_parse_tree *ldap_decode_filter_tree(TALLOC_CTX *mem_ctx,\n \t\tconst char *attrib;\n \t\tDATA_BLOB value;\n \n-\t\tasn1_start_tag(data, ASN1_CONTEXT(filter_tag));\n-\t\tasn1_read_OctetString_talloc(mem_ctx, data, &attrib);\n-\t\tasn1_read_OctetString(data, mem_ctx, &value);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, ASN1_CONTEXT(filter_tag))) goto failed;\n+\t\tif (!asn1_read_OctetString_talloc(mem_ctx, data, &attrib)) goto failed;\n+\t\tif (!asn1_read_OctetString(data, mem_ctx, &value)) goto failed;\n+\t\tif (!asn1_end_tag(data)) goto failed;\n \t\tif ((data->has_error) || (attrib == NULL) || (value.data == NULL)) {\n \t\t\tgoto failed;\n \t\t}\n@@ -874,13 +877,13 @@ static struct ldb_parse_tree *ldap_decode_filter_tree(TALLOC_CTX *mem_ctx,\n \t\t}\n \n \t\twhile (asn1_tag_remaining(data)) {\n-\t\t\tasn1_peek_uint8(data, &subs_tag);\n+\t\t\tif (!asn1_peek_uint8(data, &subs_tag)) goto failed;\n \t\t\tsubs_tag &= 0x1f;\t\/* strip off the asn1 stuff *\/\n \t\t\tif (subs_tag > 2) goto failed;\n \n-\t\t\tasn1_start_tag(data, ASN1_CONTEXT_SIMPLE(subs_tag));\n-\t\t\tasn1_read_LDAPString(data, mem_ctx, &value);\n-\t\t\tasn1_end_tag(data);\n+\t\t\tif (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(subs_tag))) goto failed;\n+\t\t\tif (!asn1_read_LDAPString(data, mem_ctx, &value)) goto failed;\n+\t\t\tif (!asn1_end_tag(data)) goto failed;\n \n \t\t\tswitch (subs_tag) {\n \t\t\tcase 0:\n@@ -947,10 +950,10 @@ static struct ldb_parse_tree *ldap_decode_filter_tree(TALLOC_CTX *mem_ctx,\n \t\tconst char *attrib;\n \t\tDATA_BLOB value;\n \n-\t\tasn1_start_tag(data, ASN1_CONTEXT(filter_tag));\n-\t\tasn1_read_OctetString_talloc(mem_ctx, data, &attrib);\n-\t\tasn1_read_OctetString(data, mem_ctx, &value);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, ASN1_CONTEXT(filter_tag))) goto failed;\n+\t\tif (!asn1_read_OctetString_talloc(mem_ctx, data, &attrib)) goto failed;\n+\t\tif (!asn1_read_OctetString(data, mem_ctx, &value)) goto failed;\n+\t\tif (!asn1_end_tag(data)) goto failed;\n \t\tif ((data->has_error) || (attrib == NULL) || (value.data == NULL)) {\n \t\t\tgoto failed;\n \t\t}\n@@ -966,10 +969,10 @@ static struct ldb_parse_tree *ldap_decode_filter_tree(TALLOC_CTX *mem_ctx,\n \t\tconst char *attrib;\n \t\tDATA_BLOB value;\n \n-\t\tasn1_start_tag(data, ASN1_CONTEXT(filter_tag));\n-\t\tasn1_read_OctetString_talloc(mem_ctx, data, &attrib);\n-\t\tasn1_read_OctetString(data, mem_ctx, &value);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, ASN1_CONTEXT(filter_tag))) goto failed;\n+\t\tif (!asn1_read_OctetString_talloc(mem_ctx, data, &attrib)) goto failed;\n+\t\tif (!asn1_read_OctetString(data, mem_ctx, &value)) goto failed;\n+\t\tif (!asn1_end_tag(data)) goto failed;\n \t\tif ((data->has_error) || (attrib == NULL) || (value.data == NULL)) {\n \t\t\tgoto failed;\n \t\t}\n@@ -1004,10 +1007,10 @@ static struct ldb_parse_tree *ldap_decode_filter_tree(TALLOC_CTX *mem_ctx,\n \t\tconst char *attrib;\n \t\tDATA_BLOB value;\n \n-\t\tasn1_start_tag(data, ASN1_CONTEXT(filter_tag));\n-\t\tasn1_read_OctetString_talloc(mem_ctx, data, &attrib);\n-\t\tasn1_read_OctetString(data, mem_ctx, &value);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, ASN1_CONTEXT(filter_tag))) goto failed;\n+\t\tif (!asn1_read_OctetString_talloc(mem_ctx, data, &attrib)) goto failed;\n+\t\tif (!asn1_read_OctetString(data, mem_ctx, &value)) goto failed;\n+\t\tif (!asn1_end_tag(data)) goto failed;\n \t\tif ((data->has_error) || (attrib == NULL) || (value.data == NULL)) {\n \t\t\tgoto failed;\n \t\t}\n@@ -1030,18 +1033,18 @@ static struct ldb_parse_tree *ldap_decode_filter_tree(TALLOC_CTX *mem_ctx,\n \t\t   we need to check we properly implement --SSS *\/ \n \t\t\/* either oid or type must be defined *\/\n \t\tif (asn1_peek_tag(data, ASN1_CONTEXT_SIMPLE(1))) { \/* optional *\/\n-\t\t\tasn1_start_tag(data, ASN1_CONTEXT_SIMPLE(1));\n-\t\t\tasn1_read_LDAPString(data, ret, &oid);\n-\t\t\tasn1_end_tag(data);\n+\t\t\tif (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(1))) goto failed;\n+\t\t\tif (!asn1_read_LDAPString(data, ret, &oid)) goto failed;\n+\t\t\tif (!asn1_end_tag(data)) goto failed;\n \t\t}\n \t\tif (asn1_peek_tag(data, ASN1_CONTEXT_SIMPLE(2))) {\t\/* optional  *\/\n-\t\t\tasn1_start_tag(data, ASN1_CONTEXT_SIMPLE(2));\n-\t\t\tasn1_read_LDAPString(data, ret, &attr);\n-\t\t\tasn1_end_tag(data);\n+\t\t\tif (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(2))) goto failed;\n+\t\t\tif (!asn1_read_LDAPString(data, ret, &attr)) goto failed;\n+\t\t\tif (!asn1_end_tag(data)) goto failed;\n \t\t}\n-\t\tasn1_start_tag(data, ASN1_CONTEXT_SIMPLE(3));\n-\t\tasn1_read_LDAPString(data, ret, &value);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(3))) goto failed;\n+\t\tif (!asn1_read_LDAPString(data, ret, &value)) goto failed;\n+\t\tif (!asn1_end_tag(data)) goto failed;\n \t\t\/* dnAttributes is marked as BOOLEAN DEFAULT FALSE\n \t\t   it is not marked as OPTIONAL but openldap tools\n \t\t   do not set this unless it is to be set as TRUE\n@@ -1049,9 +1052,9 @@ static struct ldb_parse_tree *ldap_decode_filter_tree(TALLOC_CTX *mem_ctx,\n \t\t   seems that AD always requires the dnAttributes\n \t\t   boolean value to be set *\/\n \t\tif (asn1_peek_tag(data, ASN1_CONTEXT_SIMPLE(4))) {\n-\t\t\tasn1_start_tag(data, ASN1_CONTEXT_SIMPLE(4));\n-\t\t\tasn1_read_uint8(data, &dnAttributes);\n-\t\t\tasn1_end_tag(data);\n+\t\t\tif (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(4))) goto failed;\n+\t\t\tif (!asn1_read_uint8(data, &dnAttributes)) goto failed;\n+\t\t\tif (!asn1_end_tag(data)) goto failed;\n \t\t} else {\n \t\t\tdnAttributes = 0;\n \t\t}\n@@ -1099,45 +1102,45 @@ failed:\n }\n \n \/* Decode a single LDAP attribute, possibly containing multiple values *\/\n-static void ldap_decode_attrib(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n+static bool ldap_decode_attrib(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n \t\t\t       struct ldb_message_element *attrib)\n {\n-\tasn1_start_tag(data, ASN1_SEQUENCE(0));\n-\tasn1_read_OctetString_talloc(mem_ctx, data, &attrib->name);\n-\tasn1_start_tag(data, ASN1_SET);\n+\tif (!asn1_start_tag(data, ASN1_SEQUENCE(0))) return false;\n+\tif (!asn1_read_OctetString_talloc(mem_ctx, data, &attrib->name)) return false;\n+\tif (!asn1_start_tag(data, ASN1_SET)) return false;\n \twhile (asn1_peek_tag(data, ASN1_OCTET_STRING)) {\n \t\tDATA_BLOB blob;\n-\t\tasn1_read_OctetString(data, mem_ctx, &blob);\n+\t\tif (!asn1_read_OctetString(data, mem_ctx, &blob)) return false;\n \t\tadd_value_to_attrib(mem_ctx, &blob, attrib);\n \t}\n-\tasn1_end_tag(data);\n-\tasn1_end_tag(data);\n-\t\n+\tif (!asn1_end_tag(data)) return false;\n+\treturn asn1_end_tag(data);\n }\n \n \/* Decode a set of LDAP attributes, as found in the dereference control *\/\n-void ldap_decode_attribs_bare(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n+bool ldap_decode_attribs_bare(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n \t\t\t      struct ldb_message_element **attributes,\n \t\t\t      int *num_attributes)\n {\n \twhile (asn1_peek_tag(data, ASN1_SEQUENCE(0))) {\n \t\tstruct ldb_message_element attrib;\n \t\tZERO_STRUCT(attrib);\n-\t\tldap_decode_attrib(mem_ctx, data, &attrib);\n+\t\tif (!ldap_decode_attrib(mem_ctx, data, &attrib)) return false;\n \t\tadd_attrib_to_array_talloc(mem_ctx, &attrib,\n \t\t\t\t\t   attributes, num_attributes);\n \t}\n+\treturn true;\n }\n \n \/* Decode a set of LDAP attributes, as found in a search entry *\/\n-static void ldap_decode_attribs(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n+static bool ldap_decode_attribs(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n \t\t\t\tstruct ldb_message_element **attributes,\n \t\t\t\tint *num_attributes)\n {\n-\tasn1_start_tag(data, ASN1_SEQUENCE(0));\n-\tldap_decode_attribs_bare(mem_ctx, data, \n-\t\t\t\t attributes, num_attributes);\n-\tasn1_end_tag(data);\n+\tif (!asn1_start_tag(data, ASN1_SEQUENCE(0))) return false;\n+\tif (!ldap_decode_attribs_bare(mem_ctx, data,\n+\t\t\t\t attributes, num_attributes)) return false;\n+\treturn asn1_end_tag(data);\n }\n \n \/* This routine returns LDAP status codes *\/\n@@ -1148,46 +1151,45 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n {\n \tuint8_t tag;\n \n-\tasn1_start_tag(data, ASN1_SEQUENCE(0));\n-\tasn1_read_Integer(data, &msg->messageid);\n+\tif (!asn1_start_tag(data, ASN1_SEQUENCE(0))) goto prot_err;\n+\tif (!asn1_read_Integer(data, &msg->messageid)) goto prot_err;\n \n-\tif (!asn1_peek_uint8(data, &tag))\n-\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\tif (!asn1_peek_uint8(data, &tag)) goto prot_err;\n \n \tswitch(tag) {\n \n \tcase ASN1_APPLICATION(LDAP_TAG_BindRequest): {\n \t\tstruct ldap_BindRequest *r = &msg->r.BindRequest;\n \t\tmsg->type = LDAP_TAG_BindRequest;\n-\t\tasn1_start_tag(data, tag);\n-\t\tasn1_read_Integer(data, &r->version);\n-\t\tasn1_read_OctetString_talloc(msg, data, &r->dn);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!asn1_read_Integer(data, &r->version)) goto prot_err;\n+\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->dn)) goto prot_err;\n \t\tif (asn1_peek_tag(data, ASN1_CONTEXT_SIMPLE(0))) {\n \t\t\tint pwlen;\n \t\t\tr->creds.password = \"\";\n \t\t\tr->mechanism = LDAP_AUTH_MECH_SIMPLE;\n-\t\t\tasn1_start_tag(data, ASN1_CONTEXT_SIMPLE(0));\n+\t\t\tif (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(0))) goto prot_err;\n \t\t\tpwlen = asn1_tag_remaining(data);\n \t\t\tif (pwlen == -1) {\n-\t\t\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\t\t\t\tgoto prot_err;\n \t\t\t}\n \t\t\tif (pwlen != 0) {\n \t\t\t\tchar *pw = talloc_array(msg, char, pwlen+1);\n \t\t\t\tif (!pw) {\n \t\t\t\t\treturn NT_STATUS_LDAP(LDAP_OPERATIONS_ERROR);\n \t\t\t\t}\n-\t\t\t\tasn1_read(data, pw, pwlen);\n+\t\t\t\tif (!asn1_read(data, pw, pwlen)) goto prot_err;\n \t\t\t\tpw[pwlen] = '\\0';\n \t\t\t\tr->creds.password = pw;\n \t\t\t}\n-\t\t\tasn1_end_tag(data);\n+\t\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\t} else if (asn1_peek_tag(data, ASN1_CONTEXT(3))){\n-\t\t\tasn1_start_tag(data, ASN1_CONTEXT(3));\n+\t\t\tif (!asn1_start_tag(data, ASN1_CONTEXT(3))) goto prot_err;\n \t\t\tr->mechanism = LDAP_AUTH_MECH_SASL;\n-\t\t\tasn1_read_OctetString_talloc(msg, data, &r->creds.SASL.mechanism);\n+\t\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->creds.SASL.mechanism)) goto prot_err;\n \t\t\tif (asn1_peek_tag(data, ASN1_OCTET_STRING)) { \/* optional *\/\n \t\t\t\tDATA_BLOB tmp_blob = data_blob(NULL, 0);\n-\t\t\t\tasn1_read_OctetString(data, msg, &tmp_blob);\n+\t\t\t\tif (!asn1_read_OctetString(data, msg, &tmp_blob)) goto prot_err;\n \t\t\t\tr->creds.SASL.secblob = talloc(msg, DATA_BLOB);\n \t\t\t\tif (!r->creds.SASL.secblob) {\n \t\t\t\t\treturn NT_STATUS_LDAP(LDAP_OPERATIONS_ERROR);\n@@ -1198,23 +1200,23 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\t\t} else {\n \t\t\t\tr->creds.SASL.secblob = NULL;\n \t\t\t}\n-\t\t\tasn1_end_tag(data);\n+\t\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\t} else {\n \t\t\t\/* Neither Simple nor SASL bind *\/\n-\t\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\t\t\tgoto prot_err;\n \t\t}\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_BindResponse): {\n \t\tstruct ldap_BindResponse *r = &msg->r.BindResponse;\n \t\tmsg->type = LDAP_TAG_BindResponse;\n-\t\tasn1_start_tag(data, tag);\n-\t\tldap_decode_response(msg, data, &r->response);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!ldap_decode_response(msg, data, &r->response)) goto prot_err;\n \t\tif (asn1_peek_tag(data, ASN1_CONTEXT_SIMPLE(7))) {\n \t\t\tDATA_BLOB tmp_blob = data_blob(NULL, 0);\n-\t\t\tasn1_read_ContextSimple(data, 7, &tmp_blob);\n+\t\t\tif (!asn1_read_ContextSimple(data, 7, &tmp_blob)) goto prot_err;\n \t\t\tr->SASL.secblob = talloc(msg, DATA_BLOB);\n \t\t\tif (!r->SASL.secblob) {\n \t\t\t\treturn NT_STATUS_LDAP(LDAP_OPERATIONS_ERROR);\n@@ -1225,14 +1227,14 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\t} else {\n \t\t\tr->SASL.secblob = NULL;\n \t\t}\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION_SIMPLE(LDAP_TAG_UnbindRequest): {\n \t\tmsg->type = LDAP_TAG_UnbindRequest;\n-\t\tasn1_start_tag(data, tag);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n@@ -1241,41 +1243,41 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\tint sizelimit, timelimit;\n \t\tconst char **attrs = NULL;\n \t\tmsg->type = LDAP_TAG_SearchRequest;\n-\t\tasn1_start_tag(data, tag);\n-\t\tasn1_read_OctetString_talloc(msg, data, &r->basedn);\n-\t\tasn1_read_enumerated(data, (int *)(void *)&(r->scope));\n-\t\tasn1_read_enumerated(data, (int *)(void *)&(r->deref));\n-\t\tasn1_read_Integer(data, &sizelimit);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->basedn)) goto prot_err;\n+\t\tif (!asn1_read_enumerated(data, (int *)(void *)&(r->scope))) goto prot_err;\n+\t\tif (!asn1_read_enumerated(data, (int *)(void *)&(r->deref))) goto prot_err;\n+\t\tif (!asn1_read_Integer(data, &sizelimit)) goto prot_err;\n \t\tr->sizelimit = sizelimit;\n-\t\tasn1_read_Integer(data, &timelimit);\n+\t\tif (!asn1_read_Integer(data, &timelimit)) goto prot_err;\n \t\tr->timelimit = timelimit;\n-\t\tasn1_read_BOOLEAN(data, &r->attributesonly);\n+\t\tif (!asn1_read_BOOLEAN(data, &r->attributesonly)) goto prot_err;\n \n \t\tr->tree = ldap_decode_filter_tree(msg, data);\n \t\tif (r->tree == NULL) {\n-\t\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\t\t\tgoto prot_err;\n \t\t}\n \n-\t\tasn1_start_tag(data, ASN1_SEQUENCE(0));\n+\t\tif (!asn1_start_tag(data, ASN1_SEQUENCE(0))) goto prot_err;\n \n \t\tr->num_attributes = 0;\n \t\tr->attributes = NULL;\n \n-\t\twhile (asn1_tag_remaining(data) > 0) {\t\t\t\t\t\n+\t\twhile (asn1_tag_remaining(data) > 0) {\n \n \t\t\tconst char *attr;\n \t\t\tif (!asn1_read_OctetString_talloc(msg, data,\n \t\t\t\t\t\t\t  &attr))\n-\t\t\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\t\t\t\tgoto prot_err;\n \t\t\tif (!add_string_to_array(msg, attr,\n \t\t\t\t\t\t &attrs,\n \t\t\t\t\t\t &r->num_attributes))\n-\t\t\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\t\t\t\tgoto prot_err;\n \t\t}\n \t\tr->attributes = attrs;\n \n-\t\tasn1_end_tag(data);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n@@ -1284,38 +1286,38 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\tmsg->type = LDAP_TAG_SearchResultEntry;\n \t\tr->attributes = NULL;\n \t\tr->num_attributes = 0;\n-\t\tasn1_start_tag(data, tag);\n-\t\tasn1_read_OctetString_talloc(msg, data, &r->dn);\n-\t\tldap_decode_attribs(msg, data, &r->attributes,\n-\t\t\t\t    &r->num_attributes);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->dn)) goto prot_err;\n+\t\tif (!ldap_decode_attribs(msg, data, &r->attributes,\n+\t\t\t\t    &r->num_attributes)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_SearchResultDone): {\n \t\tstruct ldap_Result *r = &msg->r.SearchResultDone;\n \t\tmsg->type = LDAP_TAG_SearchResultDone;\n-\t\tasn1_start_tag(data, tag);\n-\t\tldap_decode_response(msg, data, r);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!ldap_decode_response(msg, data, r)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_SearchResultReference): {\n \t\tstruct ldap_SearchResRef *r = &msg->r.SearchResultReference;\n \t\tmsg->type = LDAP_TAG_SearchResultReference;\n-\t\tasn1_start_tag(data, tag);\n-\t\tasn1_read_OctetString_talloc(msg, data, &r->referral);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->referral)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_ModifyRequest): {\n \t\tstruct ldap_ModifyRequest *r = &msg->r.ModifyRequest;\n \t\tmsg->type = LDAP_TAG_ModifyRequest;\n-\t\tasn1_start_tag(data, ASN1_APPLICATION(LDAP_TAG_ModifyRequest));\n-\t\tasn1_read_OctetString_talloc(msg, data, &r->dn);\n-\t\tasn1_start_tag(data, ASN1_SEQUENCE(0));\n+\t\tif (!asn1_start_tag(data, ASN1_APPLICATION(LDAP_TAG_ModifyRequest))) goto prot_err;\n+\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->dn)) goto prot_err;\n+\t\tif (!asn1_start_tag(data, ASN1_SEQUENCE(0))) goto prot_err;\n \n \t\tr->num_mods = 0;\n \t\tr->mods = NULL;\n@@ -1324,52 +1326,52 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\t\tstruct ldap_mod mod;\n \t\t\tint v;\n \t\t\tZERO_STRUCT(mod);\n-\t\t\tasn1_start_tag(data, ASN1_SEQUENCE(0));\n-\t\t\tasn1_read_enumerated(data, &v);\n+\t\t\tif (!asn1_start_tag(data, ASN1_SEQUENCE(0))) goto prot_err;\n+\t\t\tif (!asn1_read_enumerated(data, &v)) goto prot_err;\n \t\t\tmod.type = v;\n-\t\t\tldap_decode_attrib(msg, data, &mod.attrib);\n-\t\t\tasn1_end_tag(data);\n+\t\t\tif (!ldap_decode_attrib(msg, data, &mod.attrib)) goto prot_err;\n+\t\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\t\tif (!add_mod_to_array_talloc(msg, &mod,\n \t\t\t\t\t\t     &r->mods, &r->num_mods)) {\n \t\t\t\treturn NT_STATUS_LDAP(LDAP_OPERATIONS_ERROR);\n \t\t\t}\n \t\t}\n \n-\t\tasn1_end_tag(data);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_ModifyResponse): {\n \t\tstruct ldap_Result *r = &msg->r.ModifyResponse;\n \t\tmsg->type = LDAP_TAG_ModifyResponse;\n-\t\tasn1_start_tag(data, tag);\n-\t\tldap_decode_response(msg, data, r);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!ldap_decode_response(msg, data, r)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_AddRequest): {\n \t\tstruct ldap_AddRequest *r = &msg->r.AddRequest;\n \t\tmsg->type = LDAP_TAG_AddRequest;\n-\t\tasn1_start_tag(data, tag);\n-\t\tasn1_read_OctetString_talloc(msg, data, &r->dn);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->dn)) goto prot_err;\n \n \t\tr->attributes = NULL;\n \t\tr->num_attributes = 0;\n-\t\tldap_decode_attribs(msg, data, &r->attributes,\n-\t\t\t\t    &r->num_attributes);\n+\t\tif (!ldap_decode_attribs(msg, data, &r->attributes,\n+\t\t\t\t    &r->num_attributes)) goto prot_err;\n \n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_AddResponse): {\n \t\tstruct ldap_Result *r = &msg->r.AddResponse;\n \t\tmsg->type = LDAP_TAG_AddResponse;\n-\t\tasn1_start_tag(data, tag);\n-\t\tldap_decode_response(msg, data, r);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!ldap_decode_response(msg, data, r)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n@@ -1378,102 +1380,102 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\tint len;\n \t\tchar *dn;\n \t\tmsg->type = LDAP_TAG_DelRequest;\n-\t\tasn1_start_tag(data,\n-\t\t\t       ASN1_APPLICATION_SIMPLE(LDAP_TAG_DelRequest));\n+\t\tif (!asn1_start_tag(data,\n+\t\t\t       ASN1_APPLICATION_SIMPLE(LDAP_TAG_DelRequest))) goto prot_err;\n \t\tlen = asn1_tag_remaining(data);\n \t\tif (len == -1) {\n-\t\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\t\t\tgoto prot_err;\n \t\t}\n \t\tdn = talloc_array(msg, char, len+1);\n \t\tif (dn == NULL)\n \t\t\tbreak;\n-\t\tasn1_read(data, dn, len);\n+\t\tif (!asn1_read(data, dn, len)) goto prot_err;\n \t\tdn[len] = '\\0';\n \t\tr->dn = dn;\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_DelResponse): {\n \t\tstruct ldap_Result *r = &msg->r.DelResponse;\n \t\tmsg->type = LDAP_TAG_DelResponse;\n-\t\tasn1_start_tag(data, tag);\n-\t\tldap_decode_response(msg, data, r);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!ldap_decode_response(msg, data, r)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_ModifyDNRequest): {\n \t\tstruct ldap_ModifyDNRequest *r = &msg->r.ModifyDNRequest;\n \t\tmsg->type = LDAP_TAG_ModifyDNRequest;\n-\t\tasn1_start_tag(data,\n-\t\t\t       ASN1_APPLICATION(LDAP_TAG_ModifyDNRequest));\n-\t\tasn1_read_OctetString_talloc(msg, data, &r->dn);\n-\t\tasn1_read_OctetString_talloc(msg, data, &r->newrdn);\n-\t\tasn1_read_BOOLEAN(data, &r->deleteolddn);\n+\t\tif (!asn1_start_tag(data,\n+\t\t\t       ASN1_APPLICATION(LDAP_TAG_ModifyDNRequest))) goto prot_err;\n+\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->dn)) goto prot_err;\n+\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->newrdn)) goto prot_err;\n+\t\tif (!asn1_read_BOOLEAN(data, &r->deleteolddn)) goto prot_err;\n \t\tr->newsuperior = NULL;\n \t\tif (asn1_tag_remaining(data) > 0) {\n \t\t\tint len;\n \t\t\tchar *newsup;\n-\t\t\tasn1_start_tag(data, ASN1_CONTEXT_SIMPLE(0));\n+\t\t\tif (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(0))) goto prot_err;\n \t\t\tlen = asn1_tag_remaining(data);\n \t\t\tif (len == -1) {\n-\t\t\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\t\t\t\tgoto prot_err;\n \t\t\t}\n \t\t\tnewsup = talloc_array(msg, char, len+1);\n \t\t\tif (newsup == NULL) {\n \t\t\t\treturn NT_STATUS_LDAP(LDAP_OPERATIONS_ERROR);\n \t\t\t}\n-\t\t\tasn1_read(data, newsup, len);\n+\t\t\tif (!asn1_read(data, newsup, len)) goto prot_err;\n \t\t\tnewsup[len] = '\\0';\n \t\t\tr->newsuperior = newsup;\n-\t\t\tasn1_end_tag(data);\n+\t\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\t}\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_ModifyDNResponse): {\n \t\tstruct ldap_Result *r = &msg->r.ModifyDNResponse;\n \t\tmsg->type = LDAP_TAG_ModifyDNResponse;\n-\t\tasn1_start_tag(data, tag);\n-\t\tldap_decode_response(msg, data, r);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!ldap_decode_response(msg, data, r)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_CompareRequest): {\n \t\tstruct ldap_CompareRequest *r = &msg->r.CompareRequest;\n \t\tmsg->type = LDAP_TAG_CompareRequest;\n-\t\tasn1_start_tag(data,\n-\t\t\t       ASN1_APPLICATION(LDAP_TAG_CompareRequest));\n-\t\tasn1_read_OctetString_talloc(msg, data, &r->dn);\n-\t\tasn1_start_tag(data, ASN1_SEQUENCE(0));\n-\t\tasn1_read_OctetString_talloc(msg, data, &r->attribute);\n-\t\tasn1_read_OctetString(data, msg, &r->value);\n+\t\tif (!asn1_start_tag(data,\n+\t\t\t       ASN1_APPLICATION(LDAP_TAG_CompareRequest))) goto prot_err;\n+\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->dn)) goto prot_err;\n+\t\tif (!asn1_start_tag(data, ASN1_SEQUENCE(0))) goto prot_err;\n+\t\tif (!asn1_read_OctetString_talloc(msg, data, &r->attribute)) goto prot_err;\n+\t\tif (!asn1_read_OctetString(data, msg, &r->value)) goto prot_err;\n \t\tif (r->value.data) {\n \t\t\ttalloc_steal(msg, r->value.data);\n \t\t}\n-\t\tasn1_end_tag(data);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION(LDAP_TAG_CompareResponse): {\n \t\tstruct ldap_Result *r = &msg->r.CompareResponse;\n \t\tmsg->type = LDAP_TAG_CompareResponse;\n-\t\tasn1_start_tag(data, tag);\n-\t\tldap_decode_response(msg, data, r);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!ldap_decode_response(msg, data, r)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n \tcase ASN1_APPLICATION_SIMPLE(LDAP_TAG_AbandonRequest): {\n \t\tstruct ldap_AbandonRequest *r = &msg->r.AbandonRequest;\n \t\tmsg->type = LDAP_TAG_AbandonRequest;\n-\t\tasn1_start_tag(data, tag);\n-\t\tasn1_read_implicit_Integer(data, &r->messageid);\n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!asn1_read_implicit_Integer(data, &r->messageid)) goto prot_err;\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n@@ -1482,9 +1484,9 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\tDATA_BLOB tmp_blob = data_blob(NULL, 0);\n \n \t\tmsg->type = LDAP_TAG_ExtendedRequest;\n-\t\tasn1_start_tag(data,tag);\n+\t\tif (!asn1_start_tag(data,tag)) goto prot_err;\n \t\tif (!asn1_read_ContextSimple(data, 0, &tmp_blob)) {\n-\t\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\t\t\tgoto prot_err;\n \t\t}\n \t\tr->oid = blob2string_talloc(msg, tmp_blob);\n \t\tdata_blob_free(&tmp_blob);\n@@ -1493,7 +1495,7 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\t}\n \n \t\tif (asn1_peek_tag(data, ASN1_CONTEXT_SIMPLE(1))) {\n-\t\t\tasn1_read_ContextSimple(data, 1, &tmp_blob);\n+\t\t\tif (!asn1_read_ContextSimple(data, 1, &tmp_blob)) goto prot_err;\n \t\t\tr->value = talloc(msg, DATA_BLOB);\n \t\t\tif (!r->value) {\n \t\t\t\treturn NT_STATUS_LDAP(LDAP_OPERATIONS_ERROR);\n@@ -1504,7 +1506,7 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\t\tr->value = NULL;\n \t\t}\n \n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n \n@@ -1513,11 +1515,11 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\tDATA_BLOB tmp_blob = data_blob(NULL, 0);\n \n \t\tmsg->type = LDAP_TAG_ExtendedResponse;\n-\t\tasn1_start_tag(data, tag);\t\t\n-\t\tldap_decode_response(msg, data, &r->response);\n+\t\tif (!asn1_start_tag(data, tag)) goto prot_err;\n+\t\tif (!ldap_decode_response(msg, data, &r->response)) goto prot_err;\n \n \t\tif (asn1_peek_tag(data, ASN1_CONTEXT_SIMPLE(10))) {\n-\t\t\tasn1_read_ContextSimple(data, 1, &tmp_blob);\n+\t\t\tif (!asn1_read_ContextSimple(data, 1, &tmp_blob)) goto prot_err;\n \t\t\tr->oid = blob2string_talloc(msg, tmp_blob);\n \t\t\tdata_blob_free(&tmp_blob);\n \t\t\tif (!r->oid) {\n@@ -1528,7 +1530,7 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\t}\n \n \t\tif (asn1_peek_tag(data, ASN1_CONTEXT_SIMPLE(11))) {\n-\t\t\tasn1_read_ContextSimple(data, 1, &tmp_blob);\n+\t\t\tif (!asn1_read_ContextSimple(data, 1, &tmp_blob)) goto prot_err;\n \t\t\tr->value = talloc(msg, DATA_BLOB);\n \t\t\tif (!r->value) {\n \t\t\t\treturn NT_STATUS_LDAP(LDAP_OPERATIONS_ERROR);\n@@ -1539,11 +1541,11 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\t\tr->value = NULL;\n \t\t}\n \n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t\tbreak;\n \t}\n-\tdefault: \n-\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\tdefault:\n+\t\tgoto prot_err;\n \t}\n \n \tmsg->controls = NULL;\n@@ -1554,7 +1556,7 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\tstruct ldb_control **ctrl = NULL;\n \t\tbool *decoded = NULL;\n \n-\t\tasn1_start_tag(data, ASN1_CONTEXT(0));\n+\t\tif (!asn1_start_tag(data, ASN1_CONTEXT(0))) goto prot_err;\n \n \t\twhile (asn1_peek_tag(data, ASN1_SEQUENCE(0))) {\n \t\t\tDATA_BLOB value;\n@@ -1576,9 +1578,9 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\t\t}\n \n \t\t\tif (!ldap_decode_control_wrapper(ctrl[i], data, ctrl[i], &value)) {\n-\t\t\t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n+\t\t\t\tgoto prot_err;\n \t\t\t}\n-\t\t\t\n+\n \t\t\tif (!ldap_decode_control_value(ctrl[i], value,\n \t\t\t\t\t\t       control_handlers,\n \t\t\t\t\t\t       ctrl[i])) {\n@@ -1603,14 +1605,18 @@ _PUBLIC_ NTSTATUS ldap_decode(struct asn1_data *data,\n \t\tmsg->controls = ctrl;\n \t\tmsg->controls_decoded = decoded;\n \n-\t\tasn1_end_tag(data);\n+\t\tif (!asn1_end_tag(data)) goto prot_err;\n \t}\n \n-\tasn1_end_tag(data);\n+\tif (!asn1_end_tag(data)) goto prot_err;\n \tif ((data->has_error) || (data->nesting != NULL)) {\n \t\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n \t}\n \treturn NT_STATUS_OK;\n+\n+  prot_err:\n+\n+\treturn NT_STATUS_LDAP(LDAP_PROTOCOL_ERROR);\n }\n \n \ndiff --git a\/libcli\/ldap\/ldap_message.h b\/libcli\/ldap\/ldap_message.h\nindex b41f7f5497b..2f64881c053 100644\n--- a\/libcli\/ldap\/ldap_message.h\n+++ b\/libcli\/ldap\/ldap_message.h\n@@ -228,7 +228,7 @@ bool asn1_read_OctetString_talloc(TALLOC_CTX *mem_ctx,\n \t\t\t\t  struct asn1_data *data,\n \t\t\t\t  const char **result);\n \n-void ldap_decode_attribs_bare(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n+bool ldap_decode_attribs_bare(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n \t\t\t      struct ldb_message_element **attributes,\n \t\t\t      int *num_attributes);\n \ndiff --git a\/source4\/libcli\/ldap\/ldap_controls.c b\/source4\/libcli\/ldap\/ldap_controls.c\nindex 17d96f6f9d7..983082bdd22 100644\n--- a\/source4\/libcli\/ldap\/ldap_controls.c\n+++ b\/source4\/libcli\/ldap\/ldap_controls.c\n@@ -1187,10 +1187,10 @@ static bool decode_openldap_dereference(void *mem_ctx, DATA_BLOB in, void *_out)\n \t\t\tif (!asn1_start_tag(data, ASN1_CONTEXT(0))) {\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\t\n-\t\t\tldap_decode_attribs_bare(r, data, &r[i]->attributes,\n-\t\t\t\t\t\t &r[i]->num_attributes);\n-\t\t\t\n+\t\t\tif (!ldap_decode_attribs_bare(r, data, &r[i]->attributes,\n+\t\t\t\t\t\t &r[i]->num_attributes)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n \t\t\tif (!asn1_end_tag(data)) {\n \t\t\t\treturn false;\n \t\t\t}\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-6834","CWE_ID":"399","category":"security","commit_id":"ead315e43ea0c2ca3491209c6c8db8ce3f2bbe05","commit_message":"From ead315e43ea0c2ca3491209c6c8db8ce3f2bbe05 Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Thu, 4 Aug 2016 13:00:14 +0530\nSubject: [PATCH] net: check fragment length during fragmentation\n\nNetwork transport abstraction layer supports packet fragmentation.\nWhile fragmenting a packet, it checks for more fragments from\npacket length and current fragment length. It is susceptible\nto an infinite loop, if the current fragment length is zero.\nAdd check to avoid it.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nReviewed-by: Dmitry Fleytman <dmitry@daynix.com>\nCC: qemu-stable@nongnu.org\nSigned-off-by: Jason Wang <jasowang@redhat.com>\n---\n hw\/net\/net_tx_pkt.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/net\/net_tx_pkt.c b\/hw\/net\/net_tx_pkt.c\nindex efd43b4..53dfaa2 100644\n--- a\/hw\/net\/net_tx_pkt.c\n+++ b\/hw\/net\/net_tx_pkt.c\n@@ -590,7 +590,7 @@ static bool net_tx_pkt_do_sw_fragmentation(struct NetTxPkt *pkt,\n \n         fragment_offset += fragment_len;\n \n-    } while (more_frags);\n+    } while (fragment_len && more_frags);\n \n     return true;\n }\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-2498","CWE_ID":"399","category":"security","commit_id":"8d22746c9e5af80ff4304aef440986403a5072e2","commit_message":"From 8d22746c9e5af80ff4304aef440986403a5072e2 Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Sat, 12 Jun 2010 01:32:20 +0200\nSubject: Fix Savannah bug #30106.\n\nPoint numbers for FreeType's implementation of hinting masks are\ncollected before the final number of points of a glyph has been\ndetermined; in particular, the code for handling the `endchar'\nopcode can reduce the number of points.\n\n* src\/pshinter\/pshalgo.c (psh_glyph_find_strong_points): Assure that\n`end_point' is not larger than `glyph->num_points'.\n---\n ChangeLog              | 12 ++++++++++++\n src\/pshinter\/pshalgo.c | 12 +++++++++---\n 2 files changed, 21 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 13755a0..d75d2f9 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,17 @@\n 2010-06-11  Werner Lemberg  <wl@gnu.org>\n \n+\tFix Savannah bug #30106.\n+\n+\tPoint numbers for FreeType's implementation of hinting masks are\n+\tcollected before the final number of points of a glyph has been\n+\tdetermined; in particular, the code for handling the `endchar'\n+\topcode can reduce the number of points.\n+\n+\t* src\/pshinter\/pshalgo.c (psh_glyph_find_strong_points): Assure that\n+\t`end_point' is not larger than `glyph->num_points'.\n+\n+2010-06-11  Werner Lemberg  <wl@gnu.org>\n+\n \t[cff]: Improve debugging output.\n \n \t* src\/cff\/cffgload.c (cff_decoder_parse_charstrings)\ndiff --git a\/src\/pshinter\/pshalgo.c b\/src\/pshinter\/pshalgo.c\nindex 417dcee..4b08785 100644\n--- a\/src\/pshinter\/pshalgo.c\n+++ b\/src\/pshinter\/pshalgo.c\n@@ -4,7 +4,8 @@\n \/*                                                                         *\/\n \/*    PostScript hinting algorithm (body).                                 *\/\n \/*                                                                         *\/\n-\/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by      *\/\n+\/*  Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010   *\/\n+\/*            by                                                           *\/\n \/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      *\/\n \/*                                                                         *\/\n \/*  This file is part of the FreeType project, and may only be used        *\/\n@@ -1690,7 +1691,10 @@\n     \/* process secondary hints to `selected' points *\/\n     if ( num_masks > 1 && glyph->num_points > 0 )\n     {\n-      first = mask->end_point;\n+      \/* the `endchar' op can reduce the number of points *\/\n+      first = mask->end_point > glyph->num_points\n+                ? glyph->num_points\n+                : mask->end_point;\n       mask++;\n       for ( ; num_masks > 1; num_masks--, mask++ )\n       {\n@@ -1698,7 +1702,9 @@\n         FT_Int   count;\n \n \n-        next  = mask->end_point;\n+        next  = mask->end_point > glyph->num_points\n+                  ? glyph->num_points\n+                  : mask->end_point;\n         count = next - first;\n         if ( count > 0 )\n         {\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-0991","CWE_ID":"399","category":"security","commit_id":"3f8ee42b8c867d9a4c18c22657840d072cca5c3a","commit_message":"From 3f8ee42b8c867d9a4c18c22657840d072cca5c3a Mon Sep 17 00:00:00 2001\nFrom: Rodrigo Kumpera <kumpera@gmail.com>\nDate: Tue, 1 Feb 2011 19:10:08 +0100\nSubject: [PATCH]     Don't use finalization to cleanup dynamic methods.\n\n        * reflection.c: Use a reference queue to cleanup\n        dynamic methods instead of finalization.\n\n        * runtime.c: Shutdown the dynamic method queue\n        before runtime cleanup begins.\n\n        * DynamicMethod.cs: No longer finalizable.\n\n        * icall-def.h: Remove unused dynamic method icall.\n\n        Fixes #660422\n\n    Implement a reference queue API.\n\n        * gc.c: A reference queue allows one to queue\n        callbcks for when objects are collected.\n        It allows for safe cleanup of objects that can\n        only be done when it is effectively collected.\n        The major difference with regular finalization\n        is that the collector makes sure the object\n        was collected - and can't be resurrected.\n\n        * gc-internal.h: Export entrypoints for the\n        new API.\n---\n ...\/System.Reflection.Emit\/DynamicMethod.cs   |  8 ---\n mono\/metadata\/icall-def.h                     |  1 -\n mono\/metadata\/object-internals.h              |  3 +\n mono\/metadata\/reflection.c                    | 58 +++++++++++++++----\n 4 files changed, 50 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/mcs\/class\/corlib\/System.Reflection.Emit\/DynamicMethod.cs b\/mcs\/class\/corlib\/System.Reflection.Emit\/DynamicMethod.cs\nindex aea1f20b54ce..cfdcc7af3fe3 100644\n--- a\/mcs\/class\/corlib\/System.Reflection.Emit\/DynamicMethod.cs\n+++ b\/mcs\/class\/corlib\/System.Reflection.Emit\/DynamicMethod.cs\n@@ -130,9 +130,6 @@ public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool\n \t\t[MethodImplAttribute(MethodImplOptions.InternalCall)]\n \t\tprivate extern void create_dynamic_method (DynamicMethod m);\n \n-\t\t[MethodImplAttribute(MethodImplOptions.InternalCall)]\n-\t\tprivate extern void destroy_dynamic_method (DynamicMethod m);\n-\n \t\tprivate void CreateDynMethod () {\n \t\t\tif (mhandle.Value == IntPtr.Zero) {\n \t\t\t\tif (ilgen == null || (ILGenerator.Mono_GetCurrentOffset (ilgen) == 0))\n@@ -161,11 +158,6 @@ public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool\n \t\t\t}\n \t\t}\n \n-\t\t~DynamicMethod ()\n-\t\t{\n-\t\t\tdestroy_dynamic_method (this);\n-\t\t}\n-\n \t\t[ComVisible (true)]\n \t\tpublic Delegate CreateDelegate (Type delegateType)\n \t\t{\ndiff --git a\/mono\/metadata\/icall-def.h b\/mono\/metadata\/icall-def.h\nindex 17fd84289714..895b9aa5d038 100644\n--- a\/mono\/metadata\/icall-def.h\n+++ b\/mono\/metadata\/icall-def.h\n@@ -513,7 +513,6 @@ ICALL(DERIVEDTYPE_1, \"create_unmanaged_type\", mono_reflection_create_unmanaged_t\n \n ICALL_TYPE(DYNM, \"System.Reflection.Emit.DynamicMethod\", DYNM_1)\n ICALL(DYNM_1, \"create_dynamic_method\", mono_reflection_create_dynamic_method)\n-ICALL(DYNM_2, \"destroy_dynamic_method\", mono_reflection_destroy_dynamic_method)\n \n ICALL_TYPE(ENUMB, \"System.Reflection.Emit.EnumBuilder\", ENUMB_1)\n ICALL(ENUMB_1, \"setup_enum_type\", ves_icall_EnumBuilder_setup_enum_type)\ndiff --git a\/mono\/metadata\/object-internals.h b\/mono\/metadata\/object-internals.h\nindex 6ef472d31bea..d1f03deb0481 100644\n--- a\/mono\/metadata\/object-internals.h\n+++ b\/mono\/metadata\/object-internals.h\n@@ -1448,6 +1448,9 @@ mono_string_to_utf8_checked (MonoString *s, MonoError *error) MONO_INTERNAL;\n gboolean\n mono_class_is_reflection_method_or_constructor (MonoClass *class) MONO_INTERNAL;\n \n+void\n+mono_reflection_shutdown (void) MONO_INTERNAL;\n+\n #endif \/* __MONO_OBJECT_INTERNALS_H__ *\/\n \n \ndiff --git a\/mono\/metadata\/reflection.c b\/mono\/metadata\/reflection.c\nindex b3818d58b39e..f8bec5c1a0f1 100644\n--- a\/mono\/metadata\/reflection.c\n+++ b\/mono\/metadata\/reflection.c\n@@ -11064,15 +11064,56 @@ mono_reflection_sighelper_get_signature_field (MonoReflectionSigHelper *sig)\n \treturn result;\n }\n \n+typedef struct {\n+\tMonoMethod *handle;\n+\tMonoDomain *domain;\n+} DynamicMethodReleaseData;\n+\t\n+static MonoReferenceQueue *dynamic_method_queue;\n+\n+void\n+mono_reflection_shutdown (void)\n+{\n+\tMonoReferenceQueue *queue;\n+\tmono_loader_lock ();\n+\tqueue = dynamic_method_queue;\n+\tdynamic_method_queue = NULL;\n+\tif (queue)\n+\t\tmono_gc_reference_queue_free (queue);\n+\tmono_loader_unlock ();\n+}\n+\n+static void\n+free_dynamic_method (void *dynamic_method)\n+{\n+\tDynamicMethodReleaseData *data = dynamic_method;\n+\n+\tmono_runtime_free_method (data->domain, data->handle);\n+\tg_free (data);\n+}\n+\n void \n mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n {\n+\tMonoReferenceQueue *queue;\n+\tMonoMethod *handle;\n+\tDynamicMethodReleaseData *release_data;\n \tReflectionMethodBuilder rmb;\n \tMonoMethodSignature *sig;\n \tMonoClass *klass;\n \tGSList *l;\n \tint i;\n \n+\tif (mono_runtime_is_shutting_down ())\n+\t\tmono_raise_exception (mono_get_exception_invalid_operation (\"\"));\n+\n+\tif (!(queue = dynamic_method_queue)) {\n+\t\tmono_loader_lock ();\n+\t\tif (!(queue = dynamic_method_queue))\n+\t\t\tqueue = dynamic_method_queue = mono_gc_reference_queue_new (free_dynamic_method);\n+\t\tmono_loader_unlock ();\n+\t}\n+\n \tsig = dynamic_method_to_signature (mb);\n \n \treflection_methodbuilder_from_dynamic_method (&rmb, mb);\n@@ -11130,7 +11171,12 @@ mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n \n \tklass = mb->owner ? mono_class_from_mono_type (mono_reflection_type_get_handle ((MonoReflectionType*)mb->owner)) : mono_defaults.object_class;\n \n-\tmb->mhandle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n+\tmb->mhandle = handle = reflection_methodbuilder_to_mono_method (klass, &rmb, sig);\n+\trelease_data = g_new (DynamicMethodReleaseData, 1);\n+\trelease_data->handle = handle;\n+\trelease_data->domain = mono_object_get_domain ((MonoObject*)mb);\n+\tif (!mono_gc_reference_queue_add (queue, (MonoObject*)mb, release_data))\n+\t\tg_free (release_data);\n \n \t\/* Fix up refs entries pointing at us *\/\n \tfor (l = mb->referenced_by; l; l = l->next) {\n@@ -11156,16 +11202,6 @@ mono_reflection_create_dynamic_method (MonoReflectionDynamicMethod *mb)\n \n #endif \/* DISABLE_REFLECTION_EMIT *\/\n \n-void\n-mono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb)\n-{\n-\tg_assert (mb);\n-\n-\tif (mb->mhandle)\n-\t\tmono_runtime_free_method (\n-\t\t\tmono_object_get_domain ((MonoObject*)mb), mb->mhandle);\n-}\n-\n \/**\n  * \n  * mono_reflection_is_valid_dynamic_token:\n","owner":"mono","repo":"mono","source":"cve"},{"CVE_ID":"CVE-2017-5579","CWE_ID":"399","category":"security","commit_id":"8409dc884a201bf74b30a9d232b6bbdd00cb7e2b","commit_message":"From 8409dc884a201bf74b30a9d232b6bbdd00cb7e2b Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Wed, 4 Jan 2017 00:43:16 -0800\nSubject: [PATCH] serial: fix memory leak in serial exit\n\nThe serial_exit_core function doesn't free some resources.\nThis can lead memory leak when hotplug and unplug. This\npatch avoid this.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nMessage-Id: <586cb5ab.f31d9d0a.38ac3.acf2@mx.google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n hw\/char\/serial.c | 10 ++++++++++\n 1 file changed, 10 insertions(+)\n\n","diff_code":"diff --git a\/hw\/char\/serial.c b\/hw\/char\/serial.c\nindex ffbacd8..67b18ed 100644\n--- a\/hw\/char\/serial.c\n+++ b\/hw\/char\/serial.c\n@@ -906,6 +906,16 @@ void serial_realize_core(SerialState *s, Error **errp)\n void serial_exit_core(SerialState *s)\n {\n     qemu_chr_fe_deinit(&s->chr);\n+\n+    timer_del(s->modem_status_poll);\n+    timer_free(s->modem_status_poll);\n+\n+    timer_del(s->fifo_timeout_timer);\n+    timer_free(s->fifo_timeout_timer);\n+\n+    fifo8_destroy(&s->recv_fifo);\n+    fifo8_destroy(&s->xmit_fifo);\n+\n     qemu_unregister_reset(serial_reset, s);\n }\n \n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-18075","CWE_ID":"399","category":"security","commit_id":"d76c68109f37cb85b243a1cf0f40313afd2bae68","commit_message":"From d76c68109f37cb85b243a1cf0f40313afd2bae68 Mon Sep 17 00:00:00 2001\nFrom: Eric Biggers <ebiggers@google.com>\nDate: Wed, 20 Dec 2017 14:28:25 -0800\nSubject: [PATCH] crypto: pcrypt - fix freeing pcrypt instances\n\npcrypt is using the old way of freeing instances, where the ->free()\nmethod specified in the 'struct crypto_template' is passed a pointer to\nthe 'struct crypto_instance'.  But the crypto_instance is being\nkfree()'d directly, which is incorrect because the memory was actually\nallocated as an aead_instance, which contains the crypto_instance at a\nnonzero offset.  Thus, the wrong pointer was being kfree()'d.\n\nFix it by switching to the new way to free aead_instance's where the\n->free() method is specified in the aead_instance itself.\n\nReported-by: syzbot <syzkaller@googlegroups.com>\nFixes: 0496f56065e0 (\"crypto: pcrypt - Add support for new AEAD interface\")\nCc: <stable@vger.kernel.org> # v4.2+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\n---\n crypto\/pcrypt.c | 19 ++++++++++---------\n 1 file changed, 10 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/pcrypt.c b\/crypto\/pcrypt.c\nindex ee9cfb99fe256..f8ec3d4ba4a80 100644\n--- a\/crypto\/pcrypt.c\n+++ b\/crypto\/pcrypt.c\n@@ -254,6 +254,14 @@ static void pcrypt_aead_exit_tfm(struct crypto_aead *tfm)\n \tcrypto_free_aead(ctx->child);\n }\n \n+static void pcrypt_free(struct aead_instance *inst)\n+{\n+\tstruct pcrypt_instance_ctx *ctx = aead_instance_ctx(inst);\n+\n+\tcrypto_drop_aead(&ctx->spawn);\n+\tkfree(inst);\n+}\n+\n static int pcrypt_init_instance(struct crypto_instance *inst,\n \t\t\t\tstruct crypto_alg *alg)\n {\n@@ -319,6 +327,8 @@ static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,\n \tinst->alg.encrypt = pcrypt_aead_encrypt;\n \tinst->alg.decrypt = pcrypt_aead_decrypt;\n \n+\tinst->free = pcrypt_free;\n+\n \terr = aead_register_instance(tmpl, inst);\n \tif (err)\n \t\tgoto out_drop_aead;\n@@ -349,14 +359,6 @@ static int pcrypt_create(struct crypto_template *tmpl, struct rtattr **tb)\n \treturn -EINVAL;\n }\n \n-static void pcrypt_free(struct crypto_instance *inst)\n-{\n-\tstruct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);\n-\n-\tcrypto_drop_aead(&ctx->spawn);\n-\tkfree(inst);\n-}\n-\n static int pcrypt_cpumask_change_notify(struct notifier_block *self,\n \t\t\t\t\tunsigned long val, void *data)\n {\n@@ -469,7 +471,6 @@ static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)\n static struct crypto_template pcrypt_tmpl = {\n \t.name = \"pcrypt\",\n \t.create = pcrypt_create,\n-\t.free = pcrypt_free,\n \t.module = THIS_MODULE,\n };\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-7395","CWE_ID":"399","category":"security","commit_id":"8a43abefb38c5e29138e1c9c515b313363541c06","commit_message":"From 8a43abefb38c5e29138e1c9c515b313363541c06 Mon Sep 17 00:00:00 2001\nFrom: Cristy <mikayla-grace@urban-warrior.org>\nDate: Sun, 20 Jan 2019 11:04:31 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1451\n\n---\n coders\/psd.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex 95dd4e6bb2..7bbd3af4ea 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -2782,6 +2782,8 @@ static size_t WritePSDChannel(const PSDInfo *psd_info,\n       if (deflateInit(&stream,level) != Z_OK)\n         {\n           quantum_info=DestroyQuantumInfo(quantum_info);\n+          compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n+            compressed_pixels);\n           return(0);\n         }\n     }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-1667","CWE_ID":"399","category":"security","commit_id":"d59e31fc729d8a39a774f03bc6bc457029a7aef2","commit_message":"From d59e31fc729d8a39a774f03bc6bc457029a7aef2 Mon Sep 17 00:00:00 2001\nFrom: Yves Orton <demerphq@gmail.com>\nDate: Tue, 12 Feb 2013 10:53:05 +0100\nSubject: [PATCH] Prevent premature hsplit() calls, and only trigger REHASH\n after hsplit()\n\nTriggering a hsplit due to long chain length allows an attacker\nto create a carefully chosen set of keys which can cause the hash\nto use 2 * (2**32) * sizeof(void *) bytes ram. AKA a DOS via memory\nexhaustion. Doing so also takes non trivial time.\n\nEliminating this check, and only inspecting chain length after a\nnormal hsplit() (triggered when keys>buckets) prevents the attack\nentirely, and makes such attacks relatively benign.\n\n(cherry picked from commit f1220d61455253b170e81427c9d0357831ca0fac)\n---\n ext\/Hash-Util-FieldHash\/t\/10_hash.t | 18 ++++++++++++++++--\n hv.c                                | 35 ++++++++---------------------------\n t\/op\/hash.t                         | 20 +++++++++++++++++---\n 3 files changed, 41 insertions(+), 32 deletions(-)\n\n","diff_code":"diff --git a\/ext\/Hash-Util-FieldHash\/t\/10_hash.t b\/ext\/Hash-Util-FieldHash\/t\/10_hash.t\nindex 2cfb4e81fa..d58f053d97 100644\n--- a\/ext\/Hash-Util-FieldHash\/t\/10_hash.t\n+++ b\/ext\/Hash-Util-FieldHash\/t\/10_hash.t\n@@ -38,15 +38,29 @@ use constant START     => \"a\";\n \n # some initial hash data\n fieldhash my %h2;\n-%h2 = map {$_ => 1} 'a'..'cc';\n+my $counter= \"a\";\n+$h2{$counter++}++ while $counter ne 'cd';\n \n ok (!Internals::HvREHASH(%h2), \n     \"starting with pre-populated non-pathological hash (rehash flag if off)\");\n \n my @keys = get_keys(\\%h2);\n+my $buckets= buckets(\\%h2);\n $h2{$_}++ for @keys;\n+$h2{$counter++}++ while buckets(\\%h2) == $buckets; # force a split\n ok (Internals::HvREHASH(%h2), \n-    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash\");\n+    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash after split\");\n+\n+# returns the number of buckets in a hash\n+sub buckets {\n+    my $hr = shift;\n+    my $keys_buckets= scalar(%$hr);\n+    if ($keys_buckets=~m!\/([0-9]+)\\z!) {\n+        return 0+$1;\n+    } else {\n+        return 8;\n+    }\n+}\n \n sub get_keys {\n     my $hr = shift;\ndiff --git a\/hv.c b\/hv.c\nindex 2be1feb7f4..abb9d7648f 100644\n--- a\/hv.c\n+++ b\/hv.c\n@@ -35,7 +35,8 @@ holds the key and hash value.\n #define PERL_HASH_INTERNAL_ACCESS\n #include \"perl.h\"\n \n-#define HV_MAX_LENGTH_BEFORE_SPLIT 14\n+#define HV_MAX_LENGTH_BEFORE_REHASH 14\n+#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) \/* HvTOTALKEYS(hv) > HvMAX(hv) *\/\n \n static const char S_strtab_error[]\n     = \"Cannot modify shared string table in hv_%s\";\n@@ -794,29 +795,9 @@ Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,\n     if (masked_flags & HVhek_ENABLEHVKFLAGS)\n \tHvHASKFLAGS_on(hv);\n \n-    {\n-\tconst HE *counter = HeNEXT(entry);\n-\n-\txhv->xhv_keys++; \/* HvTOTALKEYS(hv)++ *\/\n-\tif (!counter) {\t\t\t\t\/* initial entry? *\/\n-\t} else if (xhv->xhv_keys > xhv->xhv_max) {\n-\t\t\/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit\n-\t\t   bucket splits on a rehashed hash, as we're not going to\n-\t\t   split it again, and if someone is lucky (evil) enough to\n-\t\t   get all the keys in one list they could exhaust our memory\n-\t\t   as we repeatedly double the number of buckets on every\n-\t\t   entry. Linear search feels a less worse thing to do.  *\/\n-\t    hsplit(hv);\n-\t} else if(!HvREHASH(hv)) {\n-\t    U32 n_links = 1;\n-\n-\t    while ((counter = HeNEXT(counter)))\n-\t\tn_links++;\n-\n-\t    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {\n-\t\thsplit(hv);\n-\t    }\n-\t}\n+    xhv->xhv_keys++; \/* HvTOTALKEYS(hv)++ *\/\n+    if ( SHOULD_DO_HSPLIT(xhv) ) {\n+        hsplit(hv);\n     }\n \n     if (return_svp) {\n@@ -1192,7 +1173,7 @@ S_hsplit(pTHX_ HV *hv)\n \n \n     \/* Pick your policy for \"hashing isn't working\" here:  *\/\n-    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT \/* split worked?  *\/\n+    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH \/* split worked?  *\/\n \t|| HvREHASH(hv)) {\n \treturn;\n     }\n@@ -2831,8 +2812,8 @@ S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)\n \n \txhv->xhv_keys++; \/* HvTOTALKEYS(hv)++ *\/\n \tif (!next) {\t\t\t\/* initial entry? *\/\n-\t} else if (xhv->xhv_keys > xhv->xhv_max \/* HvKEYS(hv) > HvMAX(hv) *\/) {\n-\t\thsplit(PL_strtab);\n+\t} else if ( SHOULD_DO_HSPLIT(xhv) ) {\n+            hsplit(PL_strtab);\n \t}\n     }\n \ndiff --git a\/t\/op\/hash.t b\/t\/op\/hash.t\nindex 278bea7e14..201260acbc 100644\n--- a\/t\/op\/hash.t\n+++ b\/t\/op\/hash.t\n@@ -39,22 +39,36 @@ use constant THRESHOLD => 14;\n use constant START     => \"a\";\n \n # some initial hash data\n-my %h2 = map {$_ => 1} 'a'..'cc';\n+my %h2;\n+my $counter= \"a\";\n+$h2{$counter++}++ while $counter ne 'cd';\n \n ok (!Internals::HvREHASH(%h2), \n     \"starting with pre-populated non-pathological hash (rehash flag if off)\");\n \n my @keys = get_keys(\\%h2);\n+my $buckets= buckets(\\%h2);\n $h2{$_}++ for @keys;\n+$h2{$counter++}++ while buckets(\\%h2) == $buckets; # force a split\n ok (Internals::HvREHASH(%h2), \n-    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash\");\n+    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash after split\");\n+\n+# returns the number of buckets in a hash\n+sub buckets {\n+    my $hr = shift;\n+    my $keys_buckets= scalar(%$hr);\n+    if ($keys_buckets=~m!\/([0-9]+)\\z!) {\n+        return 0+$1;\n+    } else {\n+        return 8;\n+    }\n+}\n \n sub get_keys {\n     my $hr = shift;\n \n     # the minimum of bits required to mount the attack on a hash\n     my $min_bits = log(THRESHOLD)\/log(2);\n-\n     # if the hash has already been populated with a significant amount\n     # of entries the number of mask bits can be higher\n     my $keys = scalar keys %$hr;\n-- \n2.15.1-424-g9478a660812\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-6252","CWE_ID":"399","category":"security","commit_id":"7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5","commit_message":"From 7932c0bd7740f4cd2aa168d3ce0199e7af7d72d5 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>\nDate: Fri, 17 Jul 2015 15:32:03 +0200\nSubject: vhost: actually track log eventfd file\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nWhile reviewing vhost log code, I found out that log_file is never\nset. Note: I haven't tested the change (QEMU doesn't use LOG_FD yet).\n\nCc: stable@vger.kernel.org\nSigned-off-by: Marc-Andr\u00e9 Lureau <marcandre.lureau@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\n---\n drivers\/vhost\/vhost.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/drivers\/vhost\/vhost.c b\/drivers\/vhost\/vhost.c\nindex a9fe859f43c8..95bdb90fd7f0 100644\n--- a\/drivers\/vhost\/vhost.c\n+++ b\/drivers\/vhost\/vhost.c\n@@ -995,6 +995,7 @@ long vhost_dev_ioctl(struct vhost_dev *d, unsigned int ioctl, void __user *argp)\n \t\t}\n \t\tif (eventfp != d->log_file) {\n \t\t\tfilep = d->log_file;\n+\t\t\td->log_file = eventfp;\n \t\t\tctx = d->log_ctx;\n \t\t\td->log_ctx = eventfp ?\n \t\t\t\teventfd_ctx_fileget(eventfp) : NULL;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2017-14054","CWE_ID":"399","category":"security","commit_id":"124eb202e70678539544f6268efc98131f19fa49","commit_message":"From 124eb202e70678539544f6268efc98131f19fa49 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?=E5=AD=99=E6=B5=A9=20and=20=E5=BC=A0=E6=B4=AA=E4=BA=AE=28?=\n =?UTF-8?q?=E6=9C=9B=E5=88=9D=29?= <tony.sh and wangchu.zhl@alibaba-inc.com>\nDate: Fri, 25 Aug 2017 01:15:28 +0200\nSubject: [PATCH] avformat\/rmdec: Fix DoS due to lack of eof check\n\nFixes: loop.ivr\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/rmdec.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavformat\/rmdec.c b\/libavformat\/rmdec.c\nindex 178eaea57d8..d6d7d9cd841 100644\n--- a\/libavformat\/rmdec.c\n+++ b\/libavformat\/rmdec.c\n@@ -1223,8 +1223,11 @@ static int ivr_read_header(AVFormatContext *s)\n             av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);\n         } else if (type == 4) {\n             av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);\n-            for (j = 0; j < len; j++)\n+            for (j = 0; j < len; j++) {\n+                if (avio_feof(pb))\n+                    return AVERROR_INVALIDDATA;\n                 av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));\n+            }\n             av_log(s, AV_LOG_DEBUG, \"'\\n\");\n         } else if (len == 4 && type == 3 && !strncmp(key, \"StreamCount\", tlen)) {\n             nb_streams = value = avio_rb32(pb);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2014-1445","CWE_ID":"399","category":"security","commit_id":"2b13d06c9584b4eb773f1e80bbaedab9a1c344e1","commit_message":"From 2b13d06c9584b4eb773f1e80bbaedab9a1c344e1 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Salva=20Peir=C3=B3?= <speiro@ai2.upv.es>\nDate: Wed, 16 Oct 2013 12:46:50 +0200\nSubject: wanxl: fix info leak in ioctl\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe wanxl_ioctl() code fails to initialize the two padding bytes of\nstruct sync_serial_settings after the ->loopback member. Add an explicit\nmemset(0) before filling the structure to avoid the info leak.\n\nSigned-off-by: Salva Peir\u00f3 <speiro@ai2.upv.es>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/wan\/wanxl.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/drivers\/net\/wan\/wanxl.c b\/drivers\/net\/wan\/wanxl.c\nindex 6a24a5a70cc7..4c0a69779b89 100644\n--- a\/drivers\/net\/wan\/wanxl.c\n+++ b\/drivers\/net\/wan\/wanxl.c\n@@ -355,6 +355,7 @@ static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n \t\t\tifr->ifr_settings.size = size; \/* data size wanted *\/\n \t\t\treturn -ENOBUFS;\n \t\t}\n+\t\tmemset(&line, 0, sizeof(line));\n \t\tline.clock_type = get_status(port)->clocking;\n \t\tline.clock_rate = 0;\n \t\tline.loopback = 0;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-0991","CWE_ID":"399","category":"security","commit_id":"8eb1189099e02372fd45ca1c67230eccf1edddc0","commit_message":"From 8eb1189099e02372fd45ca1c67230eccf1edddc0 Mon Sep 17 00:00:00 2001\nFrom: Rodrigo Kumpera <kumpera@gmail.com>\nDate: Tue, 1 Feb 2011 16:15:59 +0100\nSubject: [PATCH] Implement a reference queue API.\n\n\t* gc.c: A reference queue allows one to queue\n\tcallbcks for when objects are collected.\n\tIt allows for safe cleanup of objects that can\n\tonly be done when it is effectively collected.\n\tThe major difference with regular finalization\n\tis that the collector makes sure the object\n\twas collected - and can't be resurrected.\n\n\t* gc-internal.h: Export entrypoints for the\n\tnew API.\n---\n mono\/metadata\/gc-internal.h |  23 ++++++\n mono\/metadata\/gc.c          | 141 ++++++++++++++++++++++++++++++++++++\n 2 files changed, 164 insertions(+)\n\n","diff_code":"diff --git a\/mono\/metadata\/gc-internal.h b\/mono\/metadata\/gc-internal.h\nindex 16d31f09e0ad..fb2af22e4970 100644\n--- a\/mono\/metadata\/gc-internal.h\n+++ b\/mono\/metadata\/gc-internal.h\n@@ -335,5 +335,28 @@ gboolean mono_gc_precise_stack_mark_enabled (void) MONO_INTERNAL;\n \n FILE *mono_gc_get_logfile (void) MONO_INTERNAL;\n \n+typedef void (*mono_reference_queue_callback) (void *user_data);\n+\n+typedef struct _MonoReferenceQueue MonoReferenceQueue;\n+typedef struct _RefQueueEntry RefQueueEntry;\n+\n+struct _RefQueueEntry {\n+\tvoid *dis_link;\n+\tvoid *user_data;\n+\tRefQueueEntry *next;\n+};\n+\n+struct _MonoReferenceQueue {\n+\tRefQueueEntry *queue;\n+\tmono_reference_queue_callback callback;\n+\tMonoReferenceQueue *next;\n+\tgboolean should_be_deleted;\n+};\n+\n+MonoReferenceQueue* mono_gc_reference_queue_new (mono_reference_queue_callback callback) MONO_INTERNAL;\n+void mono_gc_reference_queue_free (MonoReferenceQueue *queue) MONO_INTERNAL;\n+gboolean mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data) MONO_INTERNAL;\n+\n+\n #endif \/* __MONO_METADATA_GC_INTERNAL_H__ *\/\n \ndiff --git a\/mono\/metadata\/gc.c b\/mono\/metadata\/gc.c\nindex fd29cd9dfe70..2208a7a7ff66 100644\n--- a\/mono\/metadata\/gc.c\n+++ b\/mono\/metadata\/gc.c\n@@ -54,6 +54,7 @@ static gboolean finalizing_root_domain = FALSE;\n #define mono_finalizer_lock() EnterCriticalSection (&finalizer_mutex)\n #define mono_finalizer_unlock() LeaveCriticalSection (&finalizer_mutex)\n static CRITICAL_SECTION finalizer_mutex;\n+static CRITICAL_SECTION reference_queue_mutex;\n \n static GSList *domains_to_finalize= NULL;\n static MonoMList *threads_to_finalize = NULL;\n@@ -64,6 +65,7 @@ static void object_register_finalizer (MonoObject *obj, void (*callback)(void *,\n \n static void mono_gchandle_set_target (guint32 gchandle, MonoObject *obj);\n \n+static void reference_queue_proccess_all (void);\n #ifndef HAVE_NULL_GC\n static HANDLE pending_done_event;\n static HANDLE shutdown_event;\n@@ -1065,6 +1067,8 @@ finalizer_thread (gpointer unused)\n \t\tmono_attach_maybe_start ();\n #endif\n \n+\t\treference_queue_proccess_all ();\n+\n \t\tif (domains_to_finalize) {\n \t\t\tmono_finalizer_lock ();\n \t\t\tif (domains_to_finalize) {\n@@ -1083,6 +1087,7 @@ finalizer_thread (gpointer unused)\n \t\t *\/\n \t\tmono_gc_invoke_finalizers ();\n \n+\n \t\tSetEvent (pending_done_event);\n \t}\n \n@@ -1097,6 +1102,7 @@ mono_gc_init (void)\n \tInitializeCriticalSection (&allocator_section);\n \n \tInitializeCriticalSection (&finalizer_mutex);\n+\tInitializeCriticalSection (&reference_queue_mutex);\n \n \tMONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_NORMAL].entries);\n \tMONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_PINNED].entries);\n@@ -1174,6 +1180,7 @@ mono_gc_cleanup (void)\n \tDeleteCriticalSection (&handle_section);\n \tDeleteCriticalSection (&allocator_section);\n \tDeleteCriticalSection (&finalizer_mutex);\n+\tDeleteCriticalSection (&reference_queue_mutex);\n }\n \n #else\n@@ -1292,3 +1299,137 @@ mono_gc_alloc_mature (MonoVTable *vtable)\n \treturn mono_object_new_specific (vtable);\n }\n #endif\n+\n+\n+static MonoReferenceQueue *ref_queues;\n+\n+static void\n+ref_list_remove_element (RefQueueEntry **prev, RefQueueEntry *element)\n+{\n+\tdo {\n+\t\t\/* Guard if head is changed concurrently. *\/\n+\t\twhile (*prev != element)\n+\t\t\tprev = &(*prev)->next;\n+\t} while (prev && InterlockedCompareExchangePointer ((void*)prev, element->next, element) != element);\n+}\n+\n+static void\n+ref_list_push (RefQueueEntry **head, RefQueueEntry *value)\n+{\n+\tRefQueueEntry *current;\n+\tdo {\n+\t\tcurrent = *head;\n+\t\tvalue->next = current;\n+\t} while (InterlockedCompareExchangePointer ((void*)head, value, current) != current);\n+}\n+\n+static void\n+reference_queue_proccess (MonoReferenceQueue *queue)\n+{\n+\tRefQueueEntry **iter = &queue->queue;\n+\tRefQueueEntry *entry;\n+\twhile ((entry = *iter)) {\n+\t\tif (queue->should_be_deleted || !mono_gc_weak_link_get (&entry->dis_link)) {\n+\t\t\tref_list_remove_element (iter, entry);\n+\t\t\tmono_gc_weak_link_remove (&entry->dis_link);\n+\t\t\tqueue->callback (entry->user_data);\n+\t\t\tg_free (entry);\n+\t\t} else {\n+\t\t\titer = &entry->next;\n+\t\t}\n+\t}\n+}\n+\n+static void\n+reference_queue_proccess_all (void)\n+{\n+\tMonoReferenceQueue **iter;\n+\tMonoReferenceQueue *queue = ref_queues;\n+\tfor (; queue; queue = queue->next)\n+\t\treference_queue_proccess (queue);\n+\n+restart:\n+\tEnterCriticalSection (&reference_queue_mutex);\n+\tfor (iter = &ref_queues; *iter;) {\n+\t\tqueue = *iter;\n+\t\tif (!queue->should_be_deleted) {\n+\t\t\titer = &queue->next;\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif (queue->queue) {\n+\t\t\tLeaveCriticalSection (&reference_queue_mutex);\n+\t\t\treference_queue_proccess (queue);\n+\t\t\tgoto restart;\n+\t\t}\n+\t\t*iter = queue->next;\n+\t\tg_free (queue);\n+\t}\n+\tLeaveCriticalSection (&reference_queue_mutex);\n+}\n+\n+\/**\n+ * mono_gc_reference_queue_new:\n+ * @callback callback used when processing dead entries.\n+ *\n+ * Create a new reference queue used to process collected objects.\n+ * A reference queue let you queue the pair (managed object, user data).\n+ * Once the managed object is collected @callback will be called\n+ * in the finalizer thread with 'user data' as argument.\n+ *\n+ * The callback is called without any locks held.\n+ *\/\n+MonoReferenceQueue*\n+mono_gc_reference_queue_new (mono_reference_queue_callback callback)\n+{\n+\tMonoReferenceQueue *res = g_new0 (MonoReferenceQueue, 1);\n+\tres->callback = callback;\n+\n+\tEnterCriticalSection (&reference_queue_mutex);\n+\tres->next = ref_queues;\n+\tref_queues = res;\n+\tLeaveCriticalSection (&reference_queue_mutex);\n+\n+\treturn res;\n+}\n+\n+\/**\n+ * mono_gc_reference_queue_add:\n+ * @queue the queue to add the reference to.\n+ * @obj the object to be watched for collection\n+ * @user_data parameter to be passed to the queue callback\n+ *\n+ * Queue an object to be watched for collection.\n+ *\n+ * @returns false if the queue is scheduled to be freed.\n+ *\/\n+gboolean\n+mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data)\n+{\n+\tRefQueueEntry *head;\n+\tRefQueueEntry *entry;\n+\tif (queue->should_be_deleted)\n+\t\treturn FALSE;\n+\n+\tentry = g_new0 (RefQueueEntry, 1);\n+\tentry->user_data = user_data;\n+\tmono_gc_weak_link_add (&entry->dis_link, obj, TRUE);\n+\tref_list_push (&queue->queue, entry);\n+\treturn TRUE;\n+}\n+\n+\/**\n+ * mono_gc_reference_queue_free:\n+ * @queue the queue that should be deleted.\n+ *\n+ * This operation signals that @queue should be deleted. This operation is deferred\n+ * as it happens on the finalizer thread.\n+ *\n+ * After this call, no further objects can be queued. It's the responsibility of the\n+ * caller to make sure that no further attempt to access queue will be made.\n+ *\/\n+void\n+mono_gc_reference_queue_free (MonoReferenceQueue *queue)\n+{\n+\tqueue->should_be_deleted = TRUE;\n+}\n+\n","owner":"mono","repo":"mono","source":"cve"},{"CVE_ID":"CVE-2015-7540","CWE_ID":"399","category":"security","commit_id":"9d989c9dd7a5b92d0c5d65287935471b83b6e884","commit_message":"From 9d989c9dd7a5b92d0c5d65287935471b83b6e884 Mon Sep 17 00:00:00 2001\nFrom: Jeremy Allison <jra@samba.org>\nDate: Thu, 18 Sep 2014 13:58:45 -0700\nSubject: [PATCH] CVE-2015-7540: lib: util: Check *every* asn1 return call and\n early return.\n\nBUG: https:\/\/bugzilla.samba.org\/show_bug.cgi?id=9187\n\nSigned-off-by: Jeremy Allison <jra@samba.org>\nReviewed-by: Volker Lendecke <Volker.Lendecke@SerNet.DE>\n\nAutobuild-User(master): Jeremy Allison <jra@samba.org>\nAutobuild-Date(master): Fri Sep 19 01:29:00 CEST 2014 on sn-devel-104\n\n(cherry picked from commit b9d3fd4cc551df78a7b066ee8ce43bbaa3ff994a)\n---\n lib\/util\/asn1.c | 106 ++++++++++++++++++++----------------------------\n 1 file changed, 45 insertions(+), 61 deletions(-)\n\n","diff_code":"diff --git a\/lib\/util\/asn1.c b\/lib\/util\/asn1.c\nindex 70637a3e065..ec294503b59 100644\n--- a\/lib\/util\/asn1.c\n+++ b\/lib\/util\/asn1.c\n@@ -326,87 +326,76 @@ bool asn1_write_OID(struct asn1_data *data, const char *OID)\n \/* write an octet string *\/\n bool asn1_write_OctetString(struct asn1_data *data, const void *p, size_t length)\n {\n-\tasn1_push_tag(data, ASN1_OCTET_STRING);\n-\tasn1_write(data, p, length);\n-\tasn1_pop_tag(data);\n-\treturn !data->has_error;\n+\tif (!asn1_push_tag(data, ASN1_OCTET_STRING)) return false;\n+\tif (!asn1_write(data, p, length)) return false;\n+\treturn asn1_pop_tag(data);\n }\n \n \/* write a LDAP string *\/\n bool asn1_write_LDAPString(struct asn1_data *data, const char *s)\n {\n-\tasn1_write(data, s, strlen(s));\n-\treturn !data->has_error;\n+\treturn asn1_write(data, s, strlen(s));\n }\n \n \/* write a LDAP string from a DATA_BLOB *\/\n bool asn1_write_DATA_BLOB_LDAPString(struct asn1_data *data, const DATA_BLOB *s)\n {\n-\tasn1_write(data, s->data, s->length);\n-\treturn !data->has_error;\n+\treturn asn1_write(data, s->data, s->length);\n }\n \n \/* write a general string *\/\n bool asn1_write_GeneralString(struct asn1_data *data, const char *s)\n {\n-\tasn1_push_tag(data, ASN1_GENERAL_STRING);\n-\tasn1_write_LDAPString(data, s);\n-\tasn1_pop_tag(data);\n-\treturn !data->has_error;\n+\tif (!asn1_push_tag(data, ASN1_GENERAL_STRING)) return false;\n+\tif (!asn1_write_LDAPString(data, s)) return false;\n+\treturn asn1_pop_tag(data);\n }\n \n bool asn1_write_ContextSimple(struct asn1_data *data, uint8_t num, DATA_BLOB *blob)\n {\n-\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(num));\n-\tasn1_write(data, blob->data, blob->length);\n-\tasn1_pop_tag(data);\n-\treturn !data->has_error;\n+\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(num))) return false;\n+\tif (!asn1_write(data, blob->data, blob->length)) return false;\n+\treturn asn1_pop_tag(data);\n }\n \n \/* write a BOOLEAN *\/\n bool asn1_write_BOOLEAN(struct asn1_data *data, bool v)\n {\n-\tasn1_push_tag(data, ASN1_BOOLEAN);\n-\tasn1_write_uint8(data, v ? 0xFF : 0);\n-\tasn1_pop_tag(data);\n-\treturn !data->has_error;\n+\tif (!asn1_push_tag(data, ASN1_BOOLEAN)) return false;\n+\tif (!asn1_write_uint8(data, v ? 0xFF : 0)) return false;\n+\treturn asn1_pop_tag(data);\n }\n \n bool asn1_read_BOOLEAN(struct asn1_data *data, bool *v)\n {\n \tuint8_t tmp = 0;\n-\tasn1_start_tag(data, ASN1_BOOLEAN);\n-\tasn1_read_uint8(data, &tmp);\n+\tif (!asn1_start_tag(data, ASN1_BOOLEAN)) return false;\n+\t*v = false;\n+\tif (!asn1_read_uint8(data, &tmp)) return false;\n \tif (tmp == 0xFF) {\n \t\t*v = true;\n-\t} else {\n-\t\t*v = false;\n \t}\n-\tasn1_end_tag(data);\n-\treturn !data->has_error;\n+\treturn asn1_end_tag(data);\n }\n \n \/* write a BOOLEAN in a simple context *\/\n bool asn1_write_BOOLEAN_context(struct asn1_data *data, bool v, int context)\n {\n-\tasn1_push_tag(data, ASN1_CONTEXT_SIMPLE(context));\n-\tasn1_write_uint8(data, v ? 0xFF : 0);\n-\tasn1_pop_tag(data);\n-\treturn !data->has_error;\n+\tif (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(context))) return false;\n+\tif (!asn1_write_uint8(data, v ? 0xFF : 0)) return false;\n+\treturn asn1_pop_tag(data);\n }\n \n bool asn1_read_BOOLEAN_context(struct asn1_data *data, bool *v, int context)\n {\n \tuint8_t tmp = 0;\n-\tasn1_start_tag(data, ASN1_CONTEXT_SIMPLE(context));\n-\tasn1_read_uint8(data, &tmp);\n+\tif (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(context))) return false;\n+\t*v = false;\n+\tif (!asn1_read_uint8(data, &tmp)) return false;\n \tif (tmp == 0xFF) {\n \t\t*v = true;\n-\t} else {\n-\t\t*v = false;\n \t}\n-\tasn1_end_tag(data);\n-\treturn !data->has_error;\n+\treturn asn1_end_tag(data);\n }\n \n \/* check a BOOLEAN *\/\n@@ -414,12 +403,12 @@ bool asn1_check_BOOLEAN(struct asn1_data *data, bool v)\n {\n \tuint8_t b = 0;\n \n-\tasn1_read_uint8(data, &b);\n+\tif (!asn1_read_uint8(data, &b)) return false;\n \tif (b != ASN1_BOOLEAN) {\n \t\tdata->has_error = true;\n \t\treturn false;\n \t}\n-\tasn1_read_uint8(data, &b);\n+\tif (!asn1_read_uint8(data, &b)) return false;\n \tif (b != v) {\n \t\tdata->has_error = true;\n \t\treturn false;\n@@ -770,9 +759,8 @@ bool asn1_read_OID(struct asn1_data *data, TALLOC_CTX *mem_ctx, char **OID)\n \t\treturn false;\n \t}\n \n-\tasn1_read(data, blob.data, len);\n-\tasn1_end_tag(data);\n-\tif (data->has_error) {\n+\tif (!asn1_read(data, blob.data, len)) return false;\n+\tif (!asn1_end_tag(data)) {\n \t\tdata_blob_free(&blob);\n \t\treturn false;\n \t}\n@@ -817,9 +805,8 @@ bool asn1_read_LDAPString(struct asn1_data *data, TALLOC_CTX *mem_ctx, char **s)\n \t\tdata->has_error = true;\n \t\treturn false;\n \t}\n-\tasn1_read(data, *s, len);\n \t(*s)[len] = 0;\n-\treturn !data->has_error;\n+\treturn asn1_read(data, *s, len);\n }\n \n \n@@ -848,17 +835,17 @@ bool asn1_read_OctetString(struct asn1_data *data, TALLOC_CTX *mem_ctx, DATA_BLO\n \t\tdata->has_error = true;\n \t\treturn false;\n \t}\n-\tasn1_read(data, blob->data, len);\n-\tasn1_end_tag(data);\n+\tif (!asn1_read(data, blob->data, len)) goto err;\n+\tif (!asn1_end_tag(data)) goto err;\n \tblob->length--;\n \tblob->data[len] = 0;\n-\t\n-\tif (data->has_error) {\n-\t\tdata_blob_free(blob);\n-\t\t*blob = data_blob_null;\n-\t\treturn false;\n-\t}\n \treturn true;\n+\n+  err:\n+\n+\tdata_blob_free(blob);\n+\t*blob = data_blob_null;\n+\treturn false;\n }\n \n bool asn1_read_ContextSimple(struct asn1_data *data, uint8_t num, DATA_BLOB *blob)\n@@ -876,9 +863,8 @@ bool asn1_read_ContextSimple(struct asn1_data *data, uint8_t num, DATA_BLOB *blo\n \t\tdata->has_error = true;\n \t\treturn false;\n \t}\n-\tasn1_read(data, blob->data, len);\n-\tasn1_end_tag(data);\n-\treturn !data->has_error;\n+\tif (!asn1_read(data, blob->data, len)) return false;\n+\treturn asn1_end_tag(data);\n }\n \n \/* read an integer without tag*\/\n@@ -966,8 +952,8 @@ bool asn1_check_enumerated(struct asn1_data *data, int v)\n {\n \tuint8_t b;\n \tif (!asn1_start_tag(data, ASN1_ENUMERATED)) return false;\n-\tasn1_read_uint8(data, &b);\n-\tasn1_end_tag(data);\n+\tif (!asn1_read_uint8(data, &b)) return false;\n+\tif (!asn1_end_tag(data)) return false;\n \n \tif (v != b)\n \t\tdata->has_error = false;\n@@ -979,9 +965,8 @@ bool asn1_check_enumerated(struct asn1_data *data, int v)\n bool asn1_write_enumerated(struct asn1_data *data, uint8_t v)\n {\n \tif (!asn1_push_tag(data, ASN1_ENUMERATED)) return false;\n-\tasn1_write_uint8(data, v);\n-\tasn1_pop_tag(data);\n-\treturn !data->has_error;\n+\tif (!asn1_write_uint8(data, v)) return false;\n+\treturn asn1_pop_tag(data);\n }\n \n \/*\n@@ -1022,8 +1007,7 @@ NTSTATUS asn1_full_tag(DATA_BLOB blob, uint8_t tag, size_t *packet_size)\n \n \tasn1->data = blob.data;\n \tasn1->length = blob.length;\n-\tasn1_start_tag(asn1, tag);\n-\tif (asn1->has_error) {\n+\tif (!asn1_start_tag(asn1, tag)) {\n \t\ttalloc_free(asn1);\n \t\treturn STATUS_MORE_ENTRIES;\n \t}\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5548","CWE_ID":"399","category":"security","commit_id":"05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655","commit_message":"From 05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655 Mon Sep 17 00:00:00 2001\nFrom: Stefan Schmidt <stefan@osg.samsung.com>\nDate: Thu, 15 Dec 2016 18:40:14 +0100\nSubject: ieee802154: atusb: do not use the stack for buffers to make them DMA\n able\n\nFrom 4.9 we should really avoid using the stack here as this will not be DMA\nable on various platforms. This changes the buffers already being present in\ntime of 4.9 being released. This should go into stable as well.\n\nReported-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Stefan Schmidt <stefan@osg.samsung.com>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>\n---\n drivers\/net\/ieee802154\/atusb.c | 31 +++++++++++++++++++++++++++----\n 1 file changed, 27 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/ieee802154\/atusb.c b\/drivers\/net\/ieee802154\/atusb.c\nindex 1253f864737a..fa3e8c34b26c 100644\n--- a\/drivers\/net\/ieee802154\/atusb.c\n+++ b\/drivers\/net\/ieee802154\/atusb.c\n@@ -117,13 +117,26 @@ static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n {\n \tstruct usb_device *usb_dev = atusb->usb_dev;\n \tint ret;\n+\tuint8_t *buffer;\n \tuint8_t value;\n \n+\tbuffer = kmalloc(1, GFP_KERNEL);\n+\tif (!buffer)\n+\t\treturn -ENOMEM;\n+\n \tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n \tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n \t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n-\t\t\t\t0, reg, &value, 1, 1000);\n-\treturn ret >= 0 ? value : ret;\n+\t\t\t\t0, reg, buffer, 1, 1000);\n+\n+\tif (ret >= 0) {\n+\t\tvalue = buffer[0];\n+\t\tkfree(buffer);\n+\t\treturn value;\n+\t} else {\n+\t\tkfree(buffer);\n+\t\treturn ret;\n+\t}\n }\n \n static int atusb_write_subreg(struct atusb *atusb, uint8_t reg, uint8_t mask,\n@@ -608,9 +621,13 @@ static const struct ieee802154_ops atusb_ops = {\n static int atusb_get_and_show_revision(struct atusb *atusb)\n {\n \tstruct usb_device *usb_dev = atusb->usb_dev;\n-\tunsigned char buffer[3];\n+\tunsigned char *buffer;\n \tint ret;\n \n+\tbuffer = kmalloc(3, GFP_KERNEL);\n+\tif (!buffer)\n+\t\treturn -ENOMEM;\n+\n \t\/* Get a couple of the ATMega Firmware values *\/\n \tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n \t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n@@ -631,15 +648,20 @@ static int atusb_get_and_show_revision(struct atusb *atusb)\n \t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n \t}\n \n+\tkfree(buffer);\n \treturn ret;\n }\n \n static int atusb_get_and_show_build(struct atusb *atusb)\n {\n \tstruct usb_device *usb_dev = atusb->usb_dev;\n-\tchar build[ATUSB_BUILD_SIZE + 1];\n+\tchar *build;\n \tint ret;\n \n+\tbuild = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);\n+\tif (!build)\n+\t\treturn -ENOMEM;\n+\n \tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n \t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n \t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n@@ -648,6 +670,7 @@ static int atusb_get_and_show_build(struct atusb *atusb)\n \t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n \t}\n \n+\tkfree(build);\n \treturn ret;\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-5312","CWE_ID":"399","category":"security","commit_id":"69030714cde66d525a8884bda01b9e8f0abf8e1e","commit_message":"From 69030714cde66d525a8884bda01b9e8f0abf8e1e Mon Sep 17 00:00:00 2001\nFrom: David Drysdale <drysdale@google.com>\nDate: Fri, 20 Nov 2015 11:13:45 +0800\nSubject: [PATCH] CVE-2015-5312 Another entity expansion issue\n\nFor https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=756733\nIt is one case where the code in place to detect entities expansions\nfailed to exit when the situation was detected, leading to DoS\nProblem reported by Kostya Serebryany @ Google\nPatch provided by David Drysdale @ Google\n---\n parser.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/parser.c b\/parser.c\nindex b7b66682..da6e7292 100644\n--- a\/parser.c\n+++ b\/parser.c\n@@ -2806,6 +2806,10 @@ xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n \t\t\t                      0, 0, 0);\n \t\tctxt->depth--;\n \n+\t\tif ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||\n+\t\t    (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))\n+\t\t    goto int_error;\n+\n \t\tif (rep != NULL) {\n \t\t    current = rep;\n \t\t    while (*current != 0) { \/* non input consuming loop *\/\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9059","CWE_ID":"399","category":"security","commit_id":"51f567777799c9d85a778302b9eb61cf15214a98","commit_message":"From 51f567777799c9d85a778302b9eb61cf15214a98 Mon Sep 17 00:00:00 2001\nFrom: \"J. Bruce Fields\" <bfields@redhat.com>\nDate: Thu, 6 Apr 2017 22:36:31 -0400\nSubject: [PATCH 01\/26] nfsd: check for oversized NFSv2\/v3 arguments\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nA client can append random data to the end of an NFSv2 or NFSv3 RPC call\nwithout our complaining; we'll just stop parsing at the end of the\nexpected data and ignore the rest.\n\nEncoded arguments and replies are stored together in an array of pages,\nand if a call is too large it could leave inadequate space for the\nreply.  This is normally OK because NFS RPC's typically have either\nshort arguments and long replies (like READ) or long arguments and short\nreplies (like WRITE).  But a client that sends an incorrectly long reply\ncan violate those assumptions.  This was observed to cause crashes.\n\nSo, insist that the argument not be any longer than we expect.\n\nAlso, several operations increment rq_next_page in the decode routine\nbefore checking the argument size, which can leave rq_next_page pointing\nwell past the end of the page array, causing trouble later in\nsvc_free_pages.\n\nAs followup we may also want to rewrite the encoding routines to check\nmore carefully that they aren't running off the end of the page array.\n\nReported-by: Tuomas Haanp\u00e4\u00e4 <thaan@synopsys.com>\nReported-by: Ari Kauppi <ari@synopsys.com>\nCc: stable@vger.kernel.org\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/nfsd\/nfs3xdr.c          | 23 +++++++++++++++++------\n fs\/nfsd\/nfsxdr.c           | 13 ++++++++++---\n include\/linux\/sunrpc\/svc.h |  3 +--\n 3 files changed, 28 insertions(+), 11 deletions(-)\n\nFrom 16719199a43f0740113041fb34a0854b1d7f2111 Mon Sep 17 00:00:00 2001\nFrom: \"Dmitry V. Levin\" <ldv@altlinux.org>\nDate: Wed, 1 Mar 2017 03:12:03 +0300\nSubject: [PATCH 02\/26] uapi: fix linux\/nfsd\/cld.h userspace compilation errors\n\nInclude <linux\/types.h> and consistently use types it provides\nto fix the following linux\/nfsd\/cld.h userspace compilation errors:\n\n\/usr\/include\/linux\/nfsd\/cld.h:40:2: error: unknown type name 'uint16_t'\n  uint16_t cn_len;    \/* length of cm_id *\/\n\/usr\/include\/linux\/nfsd\/cld.h:46:2: error: unknown type name 'uint8_t'\n  uint8_t  cm_vers;  \/* upcall version *\/\n\/usr\/include\/linux\/nfsd\/cld.h:47:2: error: unknown type name 'uint8_t'\n  uint8_t  cm_cmd;   \/* upcall command *\/\n\/usr\/include\/linux\/nfsd\/cld.h:48:2: error: unknown type name 'int16_t'\n  int16_t  cm_status;  \/* return code *\/\n\/usr\/include\/linux\/nfsd\/cld.h:49:2: error: unknown type name 'uint32_t'\n  uint32_t cm_xid;   \/* transaction id *\/\n\/usr\/include\/linux\/nfsd\/cld.h:51:3: error: unknown type name 'int64_t'\n   int64_t  cm_gracetime; \/* grace period start time *\/\n\nSigned-off-by: Dmitry V. Levin <ldv@altlinux.org>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/uapi\/linux\/nfsd\/cld.h | 14 ++++++++------\n 1 file changed, 8 insertions(+), 6 deletions(-)\n\nFrom 2f10fdcb6a1c5f26246339d3b606131fae483c44 Mon Sep 17 00:00:00 2001\nFrom: NeilBrown <neilb@suse.com>\nDate: Thu, 23 Mar 2017 16:57:36 +0800\nSubject: [PATCH 03\/26] nfsd4: remove pointless strdup_if_nonnull\n\nkstrdup() already checks for NULL.\n\n(Brought to our attention by Jason Yann noticing (from sparse output)\nthat it should have been declared static.)\n\nSigned-off-by: NeilBrown <neilb@suse.com>\nReported-by: Jason Yan <yanaijie@huawei.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/nfsd\/nfs4state.c | 25 ++++++-------------------\n 1 file changed, 6 insertions(+), 19 deletions(-)\n\nFrom 99bbf6ecc694dfe0b026e15359c5aa2a60b97a93 Mon Sep 17 00:00:00 2001\nFrom: NeilBrown <neilb@suse.com>\nDate: Wed, 15 Mar 2017 12:40:44 +1100\nSubject: [PATCH 04\/26] NFS: don't try to cross a mountpount when there isn't\n one there.\n\nconsider the sequence of commands:\n mkdir -p \/import\/nfs \/import\/bind \/import\/etc\n mount --bind \/ \/import\/bind\n mount --make-private \/import\/bind\n mount --bind \/import\/etc \/import\/bind\/etc\n\n exportfs -o rw,no_root_squash,crossmnt,async,no_subtree_check localhost:\/\n mount -o vers=4 localhost:\/ \/import\/nfs\n ls -l \/import\/nfs\/etc\n\nYou would not expect this to report a stale file handle.\nYet it does.\n\nThe manipulations under \/import\/bind cause the dentry for\n\/etc to get the DCACHE_MOUNTED flag set, even though nothing\nis mounted on \/etc.  This causes nfsd to call\nnfsd_cross_mnt() even though there is no mountpoint.  So an\nupcall to mountd for \"\/etc\" is performed.\n\nThe 'crossmnt' flag on the export of \/ causes mountd to\nreport that \/etc is exported as it is a descendant of \/.  It\nassumes the kernel wouldn't ask about something that wasn't\na mountpoint.  The filehandle returned identifies the\nfilesystem and the inode number of \/etc.\n\nWhen this filehandle is presented to rpc.mountd, via\n\"nfsd.fh\", the inode cannot be found associated with any\nname in \/etc\/exports, or with any mountpoint listed by\ngetmntent().  So rpc.mountd says the filehandle doesn't\nexist. Hence ESTALE.\n\nThis is fixed by teaching nfsd not to trust DCACHE_MOUNTED\ntoo much.  It is just a hint, not a guarantee.\nChange nfsd_mountpoint() to return '1' for a certain mountpoint,\n'2' for a possible mountpoint, and 0 otherwise.\n\nThen change nfsd_crossmnt() to check if follow_down()\nactually found a mountpount and, if not, to avoid performing\na lookup if the location is not known to certainly require\nan export-point.\n\nSigned-off-by: NeilBrown <neilb@suse.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/nfsd\/vfs.c | 24 ++++++++++++++++++++----\n 1 file changed, 20 insertions(+), 4 deletions(-)\n\nFrom 17f5f7f506aaca985b95df7ef7fc2ff49c36a8e9 Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:05:36 -0400\nSubject: [PATCH 05\/26] svcrdma: Move send_wr to svc_rdma_op_ctxt\n\nClean up: Move the ib_send_wr off the stack, and move common code\nto post a Send Work Request into a helper.\n\nThis is a refactoring change only.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/svc_rdma.h            |  4 ++\n net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c | 11 +---\n net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c      | 64 +++++++++++++---------\n 3 files changed, 44 insertions(+), 35 deletions(-)\n\nFrom 6e6092ca305ad785c605d7e313727aad96c228a5 Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:05:44 -0400\nSubject: [PATCH 06\/26] svcrdma: Add svc_rdma_map_reply_hdr()\n\nIntroduce a helper to DMA-map a reply's transport header before\nsending it. This will in part replace the map vector cache.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/svc_rdma.h            |  3 ++\n net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c | 36 ++++---------\n net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c      | 61 +++++++++++++++++-----\n 3 files changed, 62 insertions(+), 38 deletions(-)\n\nFrom b623589dbacbc786c2fffc85113a1dc1a331e2ca Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:05:52 -0400\nSubject: [PATCH 07\/26] svcrdma: Eliminate RPCRDMA_SQ_DEPTH_MULT\n\nThe Send Queue depth is temporarily reduced to 1 SQE per credit. The\nnew rdma_rw API does an internal computation, during QP creation, to\nincrease the depth of the Send Queue to handle RDMA Read and Write\noperations.\n\nThis change has to come before the NFSD code paths are updated to\nuse the rdma_rw API. Without this patch, rdma_rw_init_qp() increases\nthe size of the SQ too much, resulting in memory allocation failures\nduring QP creation.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/svc_rdma.h          | 1 -\n net\/sunrpc\/xprtrdma\/svc_rdma.c           | 2 --\n net\/sunrpc\/xprtrdma\/svc_rdma_transport.c | 2 +-\n 3 files changed, 1 insertion(+), 4 deletions(-)\n\nFrom c55ab0707b2817046ad48d6c87a6b764119a2458 Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:06:00 -0400\nSubject: [PATCH 08\/26] svcrdma: Add helper to save pages under I\/O\n\nClean up: extract the logic to save pages under I\/O into a helper to\nadd a big documenting comment without adding clutter in the send\npath.\n\nThis is a refactoring change only.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nReviewed-by: Sagi Grimberg <sagi@grimberg.me>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c | 31 ++++++++++++++++-----------\n 1 file changed, 18 insertions(+), 13 deletions(-)\n\nFrom c238c4c034f857d12d7efbf9934d96b8bb68fbc7 Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:06:08 -0400\nSubject: [PATCH 09\/26] svcrdma: Clean up svc_rdma_get_inv_rkey()\n\nReplace C structure-based XDR decoding with more portable code that\ninstead uses pointer arithmetic.\n\nThis is a refactoring change only.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c | 39 ++++++++++++---------------\n 1 file changed, 17 insertions(+), 22 deletions(-)\n\nFrom f13193f50b64e2e0c87706b838d6b9895626a892 Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:06:16 -0400\nSubject: [PATCH 10\/26] svcrdma: Introduce local rdma_rw API helpers\n\nThe plan is to replace the local bespoke code that constructs and\nposts RDMA Read and Write Work Requests with calls to the rdma_rw\nAPI. This shares code with other RDMA-enabled ULPs that manages the\ngory details of buffer registration and posting Work Requests.\n\nSome design notes:\n\n o The structure of RPC-over-RDMA transport headers is flexible,\n   allowing multiple segments per Reply with arbitrary alignment,\n   each with a unique R_key. Write and Send WRs continue to be\n   built and posted in separate code paths. However, one whole\n   chunk (with one or more RDMA segments apiece) gets exactly\n   one ib_post_send and one work completion.\n\n o svc_xprt reference counting is modified, since a chain of\n   rdma_rw_ctx structs generates one completion, no matter how\n   many Write WRs are posted.\n\n o The current code builds the transport header as it is construct-\n   ing Write WRs. I've replaced that with marshaling of transport\n   header data items in a separate step. This is because the exact\n   structure of client-provided segments may not align with the\n   components of the server's reply xdr_buf, or the pages in the\n   page list. Thus parts of each client-provided segment may be\n   written at different points in the send path.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/svc_rdma.h          |  11 +\n net\/sunrpc\/Kconfig                       |   1 +\n net\/sunrpc\/xprtrdma\/Makefile             |   2 +-\n net\/sunrpc\/xprtrdma\/svc_rdma_rw.c        | 512 +++++++++++++++++++++++\n net\/sunrpc\/xprtrdma\/svc_rdma_transport.c |   4 +\n 5 files changed, 529 insertions(+), 1 deletion(-)\n create mode 100644 net\/sunrpc\/xprtrdma\/svc_rdma_rw.c\n\nFrom 9a6a180b7867ceceeeab88a6f011bac23174b939 Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:06:25 -0400\nSubject: [PATCH 11\/26] svcrdma: Use rdma_rw API in RPC reply path\n\nThe current svcrdma sendto code path posts one RDMA Write WR at a\ntime. Each of these Writes typically carries a small number of pages\n(for instance, up to 30 pages for mlx4 devices). That means a 1MB\nNFS READ reply requires 9 ib_post_send() calls for the Write WRs,\nand one for the Send WR carrying the actual RPC Reply message.\n\nInstead, use the new rdma_rw API. The details of Write WR chain\nconstruction and memory registration are taken care of in the RDMA\ncore. svcrdma can focus on the details of the RPC-over-RDMA\nprotocol. This gives three main benefits:\n\n1. All Write WRs for one RDMA segment are posted in a single chain.\nAs few as one ib_post_send() for each Write chunk.\n\n2. The Write path can now use FRWR to register the Write buffers.\nIf the device's maximum page list depth is large, this means a\nsingle Write WR is needed for each RPC's Write chunk data.\n\n3. The new code introduces support for RPCs that carry both a Write\nlist and a Reply chunk. This combination can be used for an NFSv4\nREAD where the data payload is large, and thus is removed from the\nPayload Stream, but the Payload Stream is still larger than the\ninline threshold.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/svc_rdma.h            |   1 -\n net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c |   6 +-\n net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c      | 696 ++++++++++-----------\n net\/sunrpc\/xprtrdma\/svc_rdma_transport.c   |   2 +\n 4 files changed, 350 insertions(+), 355 deletions(-)\n\nFrom 6b19cc5ca2f78ebc88f5d39ba6a94197bb392fcc Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:06:33 -0400\nSubject: [PATCH 12\/26] svcrdma: Clean up RDMA_ERROR path\n\nNow that svc_rdma_sendto has been renovated, svc_rdma_send_error can\nbe refactored to reduce code duplication and remove C structure-\nbased XDR encoding. It is also relocated to the source file that\ncontains its only caller.\n\nThis is a refactoring change only.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nReviewed-by: Sagi Grimberg <sagi@grimberg.me>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/rpc_rdma.h         |  3 ++\n include\/linux\/sunrpc\/svc_rdma.h         |  5 ---\n net\/sunrpc\/xprtrdma\/svc_rdma_marshal.c  | 19 ---------\n net\/sunrpc\/xprtrdma\/svc_rdma_recvfrom.c | 52 ++++++++++++++++++++++++-\n net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c   | 43 --------------------\n 5 files changed, 54 insertions(+), 68 deletions(-)\n\nFrom 4757d90b15d851b9986bfca745eacc176359c13d Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:06:41 -0400\nSubject: [PATCH 13\/26] svcrdma: Report Write\/Reply chunk overruns\n\nObserved at Connectathon 2017.\n\nIf a client has underestimated the size of a Write or Reply chunk,\nthe Linux server writes as much payload data as it can, then it\nrecognizes there was a problem and closes the connection without\nsending the transport header.\n\nThis creates a couple of problems:\n\n<> The client never receives indication of the server-side failure,\n   so it continues to retransmit the bad RPC. Forward progress on\n   the transport is blocked.\n\n<> The reply payload pages are not moved out of the svc_rqst, thus\n   they can be released by the RPC server before the RDMA Writes\n   have completed.\n\nThe new rdma_rw-ized helpers return a distinct error code when a\nWrite\/Reply chunk overrun occurs, so it's now easy for the caller\n(svc_rdma_sendto) to recognize this case.\n\nInstead of dropping the connection, post an RDMA_ERROR message. The\nclient now sees an RDMA_ERROR and can properly terminate the RPC\ntransaction.\n\nAs part of the new logic, set up the same delayed release for these\npayload pages as would have occurred in the normal case.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nReviewed-by: Sagi Grimberg <sagi@grimberg.me>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c | 58 ++++++++++++++++++++++++++-\n 1 file changed, 56 insertions(+), 2 deletions(-)\n\nFrom f5821c76b2c9c2fb98b276c0bf6a101bfe9050a3 Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:06:49 -0400\nSubject: [PATCH 14\/26] svcrdma: Clean up RPC-over-RDMA backchannel reply\n processing\n\nReplace C structure-based XDR decoding with pointer arithmetic.\nPointer arithmetic is considered more portable.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/svc_rdma.h            |  2 +-\n net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c | 18 +++++++++++----\n net\/sunrpc\/xprtrdma\/svc_rdma_recvfrom.c    | 27 ++++++++++++----------\n 3 files changed, 30 insertions(+), 17 deletions(-)\n\nFrom ded8d19641a605232ab48f5d27f542648beba3cc Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:06:57 -0400\nSubject: [PATCH 15\/26] svcrdma: Reduce size of sge array in struct\n svc_rdma_op_ctxt\n\nThe sge array in struct svc_rdma_op_ctxt is no longer used for\nsending RDMA Write WRs. It need only accommodate the construction of\nSend and Receive WRs. The maximum inline size is the largest payload\nit needs to handle now.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nReviewed-by: Sagi Grimberg <sagi@grimberg.me>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/svc_rdma.h | 9 +++++++--\n net\/sunrpc\/xprtrdma\/svc_rdma.c  | 6 +++---\n 2 files changed, 10 insertions(+), 5 deletions(-)\n\nFrom 68cc4636bbbca89b9fedcf46d8b6bee444fc5e4e Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:07:05 -0400\nSubject: [PATCH 16\/26] svcrdma: Remove unused RDMA Write completion handler\n\nClean up. All RDMA Write completions are now handled by\nsvc_rdma_wc_write_ctx.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/svc_rdma.h          |  1 -\n net\/sunrpc\/xprtrdma\/svc_rdma_transport.c | 18 ------------------\n 2 files changed, 19 deletions(-)\n\nFrom 2cf32924c68a22783e6f630e1b5345a80aa1a376 Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:07:13 -0400\nSubject: [PATCH 17\/26] svcrdma: Remove the req_map cache\n\nreq_maps are no longer used by the send path and can thus be removed.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nReviewed-by: Sagi Grimberg <sagi@grimberg.me>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/svc_rdma.h          | 34 +---------\n net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c    | 68 -------------------\n net\/sunrpc\/xprtrdma\/svc_rdma_transport.c | 84 ------------------------\n 3 files changed, 1 insertion(+), 185 deletions(-)\n\nFrom dadf3e435debb85dfcf28c157012047153a21a97 Mon Sep 17 00:00:00 2001\nFrom: Chuck Lever <chuck.lever@oracle.com>\nDate: Sun, 9 Apr 2017 13:07:21 -0400\nSubject: [PATCH 18\/26] svcrdma: Clean out old XDR encoders\n\nClean up: These have been replaced and are no longer used.\n\nSigned-off-by: Chuck Lever <chuck.lever@oracle.com>\nReviewed-by: Sagi Grimberg <sagi@grimberg.me>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n include\/linux\/sunrpc\/svc_rdma.h        |  4 --\n net\/sunrpc\/xprtrdma\/svc_rdma_marshal.c | 70 --------------------------\n 2 files changed, 74 deletions(-)\n\nFrom e56efe9322c5bec9ad4f301c8102fcd630694b4c Mon Sep 17 00:00:00 2001\nFrom: Colin Ian King <colin.king@canonical.com>\nDate: Sat, 8 Apr 2017 18:09:59 +0100\nSubject: [PATCH 19\/26] lockd: remove redundant check on block\n\nA null check followed by a return is being performed already, so block\nis always non-null at the second check on block, hence we can remove\nthis redundant null-check (Detected by PVS-Studio).  Also re-work\ncomment to clean up a check-patch warning.\n\nSigned-off-by: Colin Ian King <colin.king@canonical.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/lockd\/svclock.c | 18 +++++++++---------\n 1 file changed, 9 insertions(+), 9 deletions(-)\n\nFrom df807fffaabde625fa9adb82e3e5b88cdaa5709a Mon Sep 17 00:00:00 2001\nFrom: Kinglong Mee <kinglongmee@gmail.com>\nDate: Thu, 27 Apr 2017 11:13:38 +0800\nSubject: [PATCH 20\/26] NFSv4.x\/callback: Create the callback service through\n svc_create_pooled\n\nAs the comments for svc_set_num_threads() said,\n\" Destroying threads relies on the service threads filling in\nrqstp->rq_task, which only the nfs ones do.  Assumes the serv\nhas been created using svc_create_pooled().\"\n\nIf creating service through svc_create(), the svc_pool_map_put()\nwill be called in svc_destroy(), but the pool map isn't used.\nSo that, the reference of pool map will be drop, the next using\nof pool map will get a zero npools.\n\n[  137.992130] divide error: 0000 [#1] SMP\n[  137.992148] Modules linked in: nfsd(E) nfsv4 nfs fscache fuse tun bridge stp llc ip_set nfnetlink vmw_vsock_vmci_transport vsock snd_seq_midi snd_seq_midi_event vmw_balloon coretemp crct10dif_pclmul crc32_pclmul ppdev ghash_clmulni_intel intel_rapl_perf joydev snd_ens1371 gameport snd_ac97_codec ac97_bus snd_seq snd_pcm snd_rawmidi snd_timer snd_seq_device snd soundcore parport_pc parport nfit acpi_cpufreq tpm_tis tpm_tis_core tpm vmw_vmci i2c_piix4 shpchp auth_rpcgss nfs_acl lockd(E) grace sunrpc(E) xfs libcrc32c vmwgfx drm_kms_helper ttm crc32c_intel drm e1000 mptspi scsi_transport_spi serio_raw mptscsih mptbase ata_generic pata_acpi [last unloaded: nfsd]\n[  137.992336] CPU: 0 PID: 4514 Comm: rpc.nfsd Tainted: G            E   4.11.0-rc8+ #536\n[  137.992777] Hardware name: VMware, Inc. VMware Virtual Platform\/440BX Desktop Reference Platform, BIOS 6.00 07\/02\/2015\n[  137.993757] task: ffff955984101d00 task.stack: ffff9873c2604000\n[  137.994231] RIP: 0010:svc_pool_for_cpu+0x2b\/0x80 [sunrpc]\n[  137.994768] RSP: 0018:ffff9873c2607c18 EFLAGS: 00010246\n[  137.995227] RAX: 0000000000000000 RBX: ffff95598376f000 RCX: 0000000000000002\n[  137.995673] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff9559944aec00\n[  137.996156] RBP: ffff9873c2607c18 R08: ffff9559944aec28 R09: 0000000000000000\n[  137.996609] R10: 0000000001080002 R11: 0000000000000000 R12: ffff95598376f010\n[  137.997063] R13: ffff95598376f018 R14: ffff9559944aec28 R15: ffff9559944aec00\n[  137.997584] FS:  00007f755529eb40(0000) GS:ffff9559bb600000(0000) knlGS:0000000000000000\n[  137.998048] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  137.998548] CR2: 000055f3aecd9660 CR3: 0000000084290000 CR4: 00000000001406f0\n[  137.999052] Call Trace:\n[  137.999517]  svc_xprt_do_enqueue+0xef\/0x260 [sunrpc]\n[  138.000028]  svc_xprt_received+0x47\/0x90 [sunrpc]\n[  138.000487]  svc_add_new_perm_xprt+0x76\/0x90 [sunrpc]\n[  138.000981]  svc_addsock+0x14b\/0x200 [sunrpc]\n[  138.001424]  ? recalc_sigpending+0x1b\/0x50\n[  138.001860]  ? __getnstimeofday64+0x41\/0xd0\n[  138.002346]  ? do_gettimeofday+0x29\/0x90\n[  138.002779]  write_ports+0x255\/0x2c0 [nfsd]\n[  138.003202]  ? _copy_from_user+0x4e\/0x80\n[  138.003676]  ? write_recoverydir+0x100\/0x100 [nfsd]\n[  138.004098]  nfsctl_transaction_write+0x48\/0x80 [nfsd]\n[  138.004544]  __vfs_write+0x37\/0x160\n[  138.004982]  ? selinux_file_permission+0xd7\/0x110\n[  138.005401]  ? security_file_permission+0x3b\/0xc0\n[  138.005865]  vfs_write+0xb5\/0x1a0\n[  138.006267]  SyS_write+0x55\/0xc0\n[  138.006654]  entry_SYSCALL_64_fastpath+0x1a\/0xa9\n[  138.007071] RIP: 0033:0x7f7554b9dc30\n[  138.007437] RSP: 002b:00007ffc9f92c788 EFLAGS: 00000246 ORIG_RAX: 0000000000000001\n[  138.007807] RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00007f7554b9dc30\n[  138.008168] RDX: 0000000000000002 RSI: 00005640cd536640 RDI: 0000000000000003\n[  138.008573] RBP: 00007ffc9f92c780 R08: 0000000000000001 R09: 0000000000000002\n[  138.008918] R10: 0000000000000064 R11: 0000000000000246 R12: 0000000000000004\n[  138.009254] R13: 00005640cdbf77a0 R14: 00005640cdbf7720 R15: 00007ffc9f92c238\n[  138.009610] Code: 0f 1f 44 00 00 48 8b 87 98 00 00 00 55 48 89 e5 48 83 78 08 00 74 10 8b 05 07 42 02 00 83 f8 01 74 40 83 f8 02 74 19 31 c0 31 d2 <f7> b7 88 00 00 00 5d 89 d0 48 c1 e0 07 48 03 87 90 00 00 00 c3\n[  138.010664] RIP: svc_pool_for_cpu+0x2b\/0x80 [sunrpc] RSP: ffff9873c2607c18\n[  138.011061] ---[ end trace b3468224cafa7d11 ]---\n\nSigned-off-by: Kinglong Mee <kinglongmee@gmail.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/nfs\/callback.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\nFrom 9e0d87680d689f1758185851c3da6eafb16e71e1 Mon Sep 17 00:00:00 2001\nFrom: Trond Myklebust <trond.myklebust@primarydata.com>\nDate: Wed, 26 Apr 2017 11:55:26 -0400\nSubject: [PATCH 21\/26] SUNRPC: Refactor svc_set_num_threads()\n\nRefactor to separate out the functions of starting and stopping threads\nso that they can be used in other helpers.\n\nSigned-off-by: Trond Myklebust <trond.myklebust@primarydata.com>\nTested-and-reviewed-by: Kinglong Mee <kinglongmee@gmail.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n net\/sunrpc\/svc.c | 96 +++++++++++++++++++++++++++++-------------------\n 1 file changed, 58 insertions(+), 38 deletions(-)\n\nFrom ed6473ddc704a2005b9900ca08e236ebb2d8540a Mon Sep 17 00:00:00 2001\nFrom: Trond Myklebust <trond.myklebust@primarydata.com>\nDate: Wed, 26 Apr 2017 11:55:27 -0400\nSubject: [PATCH 22\/26] NFSv4: Fix callback server shutdown\n\nWe want to use kthread_stop() in order to ensure the threads are\nshut down before we tear down the nfs_callback_info in nfs_callback_down.\n\nTested-and-reviewed-by: Kinglong Mee <kinglongmee@gmail.com>\nReported-by: Kinglong Mee <kinglongmee@gmail.com>\nFixes: bb6aeba736ba9 (\"NFSv4.x: Switch to using svc_set_num_threads()...\")\nSigned-off-by: Trond Myklebust <trond.myklebust@primarydata.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/nfs\/callback.c          | 24 ++++++++++++++++--------\n include\/linux\/sunrpc\/svc.h |  1 +\n net\/sunrpc\/svc.c           | 38 ++++++++++++++++++++++++++++++++++++++\n 3 files changed, 55 insertions(+), 8 deletions(-)\n\nFrom efda760fe95ea15291853c8fa9235c32d319cd98 Mon Sep 17 00:00:00 2001\nFrom: \"J. Bruce Fields\" <bfields@redhat.com>\nDate: Tue, 28 Mar 2017 21:25:08 -0400\nSubject: [PATCH 23\/26] lockd: fix lockd shutdown race\n\nAs reported by David Jeffery: \"a signal was sent to lockd while lockd\nwas shutting down from a request to stop nfs.  The signal causes lockd\nto call restart_grace() which puts the lockd_net structure on the grace\nlist.  If this signal is received at the wrong time, it will occur after\nlockd_down_net() has called locks_end_grace() but before\nlockd_down_net() stops the lockd thread.  This leads to lockd putting\nthe lockd_net structure back on the grace list, then exiting without\nanything removing it from the list.\"\n\nSo, perform the final locks_end_grace() from the the lockd thread; this\nensures it's serialized with respect to restart_grace().\n\nReported-by: David Jeffery <djeffery@redhat.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/lockd\/svc.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\nFrom b550a32e60a4941994b437a8d662432a486235a5 Mon Sep 17 00:00:00 2001\nFrom: Ari Kauppi <ari@synopsys.com>\nDate: Fri, 5 May 2017 16:07:55 -0400\nSubject: [PATCH 24\/26] nfsd: fix undefined behavior in nfsd4_layout_verify\n\n  UBSAN: Undefined behaviour in fs\/nfsd\/nfs4proc.c:1262:34\n  shift exponent 128 is too large for 32-bit type 'int'\n\nDepending on compiler+architecture, this may cause the check for\nlayout_type to succeed for overly large values (which seems to be the\ncase with amd64). The large value will be later used in de-referencing\nnfsd4_layout_ops for function pointers.\n\nReported-by: Jani Tuovila <tuovila@synopsys.com>\nSigned-off-by: Ari Kauppi <ari@synopsys.com>\n[colin.king@canonical.com: use LAYOUT_TYPE_MAX instead of 32]\nCc: stable@vger.kernel.org\nReviewed-by: Dan Carpenter <dan.carpenter@oracle.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/nfsd\/nfs4proc.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\nFrom f961e3f2acae94b727380c0b74e2d3954d0edf79 Mon Sep 17 00:00:00 2001\nFrom: \"J. Bruce Fields\" <bfields@redhat.com>\nDate: Fri, 5 May 2017 16:17:57 -0400\nSubject: [PATCH 25\/26] nfsd: encoders mustn't use unitialized values in error\n cases\n\nIn error cases, lgp->lg_layout_type may be out of bounds; so we\nshouldn't be using it until after the check of nfserr.\n\nThis was seen to crash nfsd threads when the server receives a LAYOUTGET\nrequest with a large layout type.\n\nGETDEVICEINFO has the same problem.\n\nReported-by: Ari Kauppi <Ari.Kauppi@synopsys.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nCc: stable@vger.kernel.org\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/nfsd\/nfs4xdr.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\nFrom b26b78cb726007533d81fdf90a62e915002ef5c8 Mon Sep 17 00:00:00 2001\nFrom: Trond Myklebust <trond.myklebust@primarydata.com>\nDate: Tue, 9 May 2017 16:24:59 -0400\nSubject: [PATCH 26\/26] nfsd: Fix up the \"supattr_exclcreat\" attributes\n\nIf an NFSv4 client asks us for the supattr_exclcreat, then we must\nnot return attributes that are unsupported by this minor version.\n\nSigned-off-by: Trond Myklebust <trond.myklebust@primarydata.com>\nFixes: 75976de6556f (\"NFSD: Return word2 bitmask if setting security..,\")\nCc: stable@vger.kernel.org\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/nfsd\/nfs4xdr.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/fs\/nfsd\/nfs3xdr.c b\/fs\/nfsd\/nfs3xdr.c\nindex 452334694a5d1..12feac6ee2fd4 100644\n--- a\/fs\/nfsd\/nfs3xdr.c\n+++ b\/fs\/nfsd\/nfs3xdr.c\n@@ -334,8 +334,11 @@ nfs3svc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n \tif (!p)\n \t\treturn 0;\n \tp = xdr_decode_hyper(p, &args->offset);\n-\n \targs->count = ntohl(*p++);\n+\n+\tif (!xdr_argsize_check(rqstp, p))\n+\t\treturn 0;\n+\n \tlen = min(args->count, max_blocksize);\n \n \t\/* set up the kvec *\/\n@@ -349,7 +352,7 @@ nfs3svc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n \t\tv++;\n \t}\n \targs->vlen = v;\n-\treturn xdr_argsize_check(rqstp, p);\n+\treturn 1;\n }\n \n int\n@@ -541,9 +544,11 @@ nfs3svc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p,\n \tp = decode_fh(p, &args->fh);\n \tif (!p)\n \t\treturn 0;\n+\tif (!xdr_argsize_check(rqstp, p))\n+\t\treturn 0;\n \targs->buffer = page_address(*(rqstp->rq_next_page++));\n \n-\treturn xdr_argsize_check(rqstp, p);\n+\treturn 1;\n }\n \n int\n@@ -569,10 +574,14 @@ nfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n \targs->verf   = p; p += 2;\n \targs->dircount = ~0;\n \targs->count  = ntohl(*p++);\n+\n+\tif (!xdr_argsize_check(rqstp, p))\n+\t\treturn 0;\n+\n \targs->count  = min_t(u32, args->count, PAGE_SIZE);\n \targs->buffer = page_address(*(rqstp->rq_next_page++));\n \n-\treturn xdr_argsize_check(rqstp, p);\n+\treturn 1;\n }\n \n int\n@@ -590,6 +599,9 @@ nfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, __be32 *p,\n \targs->dircount = ntohl(*p++);\n \targs->count    = ntohl(*p++);\n \n+\tif (!xdr_argsize_check(rqstp, p))\n+\t\treturn 0;\n+\n \tlen = args->count = min(args->count, max_blocksize);\n \twhile (len > 0) {\n \t\tstruct page *p = *(rqstp->rq_next_page++);\n@@ -597,8 +609,7 @@ nfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, __be32 *p,\n \t\t\targs->buffer = page_address(p);\n \t\tlen -= PAGE_SIZE;\n \t}\n-\n-\treturn xdr_argsize_check(rqstp, p);\n+\treturn 1;\n }\n \n int\ndiff --git a\/fs\/nfsd\/nfsxdr.c b\/fs\/nfsd\/nfsxdr.c\nindex de07ff6257778..6a4947a3f4fa8 100644\n--- a\/fs\/nfsd\/nfsxdr.c\n+++ b\/fs\/nfsd\/nfsxdr.c\n@@ -257,6 +257,9 @@ nfssvc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n \tlen = args->count     = ntohl(*p++);\n \tp++; \/* totalcount - unused *\/\n \n+\tif (!xdr_argsize_check(rqstp, p))\n+\t\treturn 0;\n+\n \tlen = min_t(unsigned int, len, NFSSVC_MAXBLKSIZE_V2);\n \n \t\/* set up somewhere to store response.\n@@ -272,7 +275,7 @@ nfssvc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n \t\tv++;\n \t}\n \targs->vlen = v;\n-\treturn xdr_argsize_check(rqstp, p);\n+\treturn 1;\n }\n \n int\n@@ -362,9 +365,11 @@ nfssvc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd_readli\n \tp = decode_fh(p, &args->fh);\n \tif (!p)\n \t\treturn 0;\n+\tif (!xdr_argsize_check(rqstp, p))\n+\t\treturn 0;\n \targs->buffer = page_address(*(rqstp->rq_next_page++));\n \n-\treturn xdr_argsize_check(rqstp, p);\n+\treturn 1;\n }\n \n int\n@@ -402,9 +407,11 @@ nfssvc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n \targs->cookie = ntohl(*p++);\n \targs->count  = ntohl(*p++);\n \targs->count  = min_t(u32, args->count, PAGE_SIZE);\n+\tif (!xdr_argsize_check(rqstp, p))\n+\t\treturn 0;\n \targs->buffer = page_address(*(rqstp->rq_next_page++));\n \n-\treturn xdr_argsize_check(rqstp, p);\n+\treturn 1;\n }\n \n \/*\ndiff --git a\/include\/linux\/sunrpc\/svc.h b\/include\/linux\/sunrpc\/svc.h\nindex e770abeed32d7..6ef19cf658b40 100644\n--- a\/include\/linux\/sunrpc\/svc.h\n+++ b\/include\/linux\/sunrpc\/svc.h\n@@ -336,8 +336,7 @@ xdr_argsize_check(struct svc_rqst *rqstp, __be32 *p)\n {\n \tchar *cp = (char *)p;\n \tstruct kvec *vec = &rqstp->rq_arg.head[0];\n-\treturn cp >= (char*)vec->iov_base\n-\t\t&& cp <= (char*)vec->iov_base + vec->iov_len;\n+\treturn cp == (char *)vec->iov_base + vec->iov_len;\n }\n \n static inline int\n\ndiff --git a\/include\/uapi\/linux\/nfsd\/cld.h b\/include\/uapi\/linux\/nfsd\/cld.h\nindex f14a9ab06f1f7..ec260274be0ce 100644\n--- a\/include\/uapi\/linux\/nfsd\/cld.h\n+++ b\/include\/uapi\/linux\/nfsd\/cld.h\n@@ -22,6 +22,8 @@\n #ifndef _NFSD_CLD_H\n #define _NFSD_CLD_H\n \n+#include <linux\/types.h>\n+\n \/* latest upcall version available *\/\n #define CLD_UPCALL_VERSION 1\n \n@@ -37,18 +39,18 @@ enum cld_command {\n \n \/* representation of long-form NFSv4 client ID *\/\n struct cld_name {\n-\tuint16_t\tcn_len;\t\t\t\t\/* length of cm_id *\/\n+\t__u16\t\tcn_len;\t\t\t\t\/* length of cm_id *\/\n \tunsigned char\tcn_id[NFS4_OPAQUE_LIMIT];\t\/* client-provided *\/\n } __attribute__((packed));\n \n \/* message struct for communication with userspace *\/\n struct cld_msg {\n-\tuint8_t\t\tcm_vers;\t\t\/* upcall version *\/\n-\tuint8_t\t\tcm_cmd;\t\t\t\/* upcall command *\/\n-\tint16_t\t\tcm_status;\t\t\/* return code *\/\n-\tuint32_t\tcm_xid;\t\t\t\/* transaction id *\/\n+\t__u8\t\tcm_vers;\t\t\/* upcall version *\/\n+\t__u8\t\tcm_cmd;\t\t\t\/* upcall command *\/\n+\t__s16\t\tcm_status;\t\t\/* return code *\/\n+\t__u32\t\tcm_xid;\t\t\t\/* transaction id *\/\n \tunion {\n-\t\tint64_t\t\tcm_gracetime;\t\/* grace period start time *\/\n+\t\t__s64\t\tcm_gracetime;\t\/* grace period start time *\/\n \t\tstruct cld_name\tcm_name;\n \t} __attribute__((packed)) cm_u;\n } __attribute__((packed));\n\ndiff --git a\/fs\/nfsd\/nfs4state.c b\/fs\/nfsd\/nfs4state.c\nindex e9ef50addddb4..22002fb75a182 100644\n--- a\/fs\/nfsd\/nfs4state.c\n+++ b\/fs\/nfsd\/nfs4state.c\n@@ -1912,28 +1912,15 @@ static void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n \ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n }\n \n-int strdup_if_nonnull(char **target, char *source)\n-{\n-\tif (source) {\n-\t\t*target = kstrdup(source, GFP_KERNEL);\n-\t\tif (!*target)\n-\t\t\treturn -ENOMEM;\n-\t} else\n-\t\t*target = NULL;\n-\treturn 0;\n-}\n-\n static int copy_cred(struct svc_cred *target, struct svc_cred *source)\n {\n-\tint ret;\n+\ttarget->cr_principal = kstrdup(source->cr_principal, GFP_KERNEL);\n+\ttarget->cr_raw_principal = kstrdup(source->cr_raw_principal,\n+\t\t\t\t\t\t\t\tGFP_KERNEL);\n+\tif ((source->cr_principal && ! target->cr_principal) ||\n+\t    (source->cr_raw_principal && ! target->cr_raw_principal))\n+\t\treturn -ENOMEM;\n \n-\tret = strdup_if_nonnull(&target->cr_principal, source->cr_principal);\n-\tif (ret)\n-\t\treturn ret;\n-\tret = strdup_if_nonnull(&target->cr_raw_principal,\n-\t\t\t\t\tsource->cr_raw_principal);\n-\tif (ret)\n-\t\treturn ret;\n \ttarget->cr_flavor = source->cr_flavor;\n \ttarget->cr_uid = source->cr_uid;\n \ttarget->cr_gid = source->cr_gid;\n\ndiff --git a\/fs\/nfsd\/vfs.c b\/fs\/nfsd\/vfs.c\nindex 19d50f600e8d4..04cafaa94bf70 100644\n--- a\/fs\/nfsd\/vfs.c\n+++ b\/fs\/nfsd\/vfs.c\n@@ -94,6 +94,12 @@ nfsd_cross_mnt(struct svc_rqst *rqstp, struct dentry **dpp,\n \terr = follow_down(&path);\n \tif (err < 0)\n \t\tgoto out;\n+\tif (path.mnt == exp->ex_path.mnt && path.dentry == dentry &&\n+\t    nfsd_mountpoint(dentry, exp) == 2) {\n+\t\t\/* This is only a mountpoint in some other namespace *\/\n+\t\tpath_put(&path);\n+\t\tgoto out;\n+\t}\n \n \texp2 = rqst_exp_get_by_name(rqstp, &path);\n \tif (IS_ERR(exp2)) {\n@@ -167,16 +173,26 @@ static int nfsd_lookup_parent(struct svc_rqst *rqstp, struct dentry *dparent, st\n \/*\n  * For nfsd purposes, we treat V4ROOT exports as though there was an\n  * export at *every* directory.\n+ * We return:\n+ * '1' if this dentry *must* be an export point,\n+ * '2' if it might be, if there is really a mount here, and\n+ * '0' if there is no chance of an export point here.\n  *\/\n int nfsd_mountpoint(struct dentry *dentry, struct svc_export *exp)\n {\n-\tif (d_mountpoint(dentry))\n+\tif (!d_inode(dentry))\n+\t\treturn 0;\n+\tif (exp->ex_flags & NFSEXP_V4ROOT)\n \t\treturn 1;\n \tif (nfsd4_is_junction(dentry))\n \t\treturn 1;\n-\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n-\t\treturn 0;\n-\treturn d_inode(dentry) != NULL;\n+\tif (d_mountpoint(dentry))\n+\t\t\/*\n+\t\t * Might only be a mountpoint in a different namespace,\n+\t\t * but we need to check.\n+\t\t *\/\n+\t\treturn 2;\n+\treturn 0;\n }\n \n __be32\n\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex b105f73e3ca26..287db5c179d8f 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -85,6 +85,7 @@ struct svc_rdma_op_ctxt {\n \tenum dma_data_direction direction;\n \tint count;\n \tunsigned int mapped_sges;\n+\tstruct ib_send_wr send_wr;\n \tstruct ib_sge sge[RPCSVC_MAXPAGES];\n \tstruct page *pages[RPCSVC_MAXPAGES];\n };\n@@ -227,6 +228,9 @@ extern int rdma_read_chunk_frmr(struct svcxprt_rdma *, struct svc_rqst *,\n \/* svc_rdma_sendto.c *\/\n extern int svc_rdma_map_xdr(struct svcxprt_rdma *, struct xdr_buf *,\n \t\t\t    struct svc_rdma_req_map *, bool);\n+extern int svc_rdma_post_send_wr(struct svcxprt_rdma *rdma,\n+\t\t\t\t struct svc_rdma_op_ctxt *ctxt,\n+\t\t\t\t int num_sge, u32 inv_rkey);\n extern int svc_rdma_sendto(struct svc_rqst *);\n extern void svc_rdma_send_error(struct svcxprt_rdma *, struct rpcrdma_msg *,\n \t\t\t\tint);\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\nindex ff1df40f0d261..f12f39c189c3c 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\n@@ -104,7 +104,6 @@ static int svc_rdma_bc_sendto(struct svcxprt_rdma *rdma,\n \tstruct xdr_buf *sndbuf = &rqst->rq_snd_buf;\n \tstruct svc_rdma_op_ctxt *ctxt;\n \tstruct svc_rdma_req_map *vec;\n-\tstruct ib_send_wr send_wr;\n \tint ret;\n \n \tvec = svc_rdma_get_req_map(rdma);\n@@ -132,15 +131,7 @@ static int svc_rdma_bc_sendto(struct svcxprt_rdma *rdma,\n \t}\n \tsvc_rdma_count_mappings(rdma, ctxt);\n \n-\tmemset(&send_wr, 0, sizeof(send_wr));\n-\tctxt->cqe.done = svc_rdma_wc_send;\n-\tsend_wr.wr_cqe = &ctxt->cqe;\n-\tsend_wr.sg_list = ctxt->sge;\n-\tsend_wr.num_sge = 1;\n-\tsend_wr.opcode = IB_WR_SEND;\n-\tsend_wr.send_flags = IB_SEND_SIGNALED;\n-\n-\tret = svc_rdma_send(rdma, &send_wr);\n+\tret = svc_rdma_post_send_wr(rdma, ctxt, 1, 0);\n \tif (ret) {\n \t\tret = -EIO;\n \t\tgoto out_unmap;\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\nindex 515221b16d095..f90b40d0932f4 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n@@ -435,6 +435,43 @@ static int send_reply_chunks(struct svcxprt_rdma *xprt,\n \treturn -EIO;\n }\n \n+\/**\n+ * svc_rdma_post_send_wr - Set up and post one Send Work Request\n+ * @rdma: controlling transport\n+ * @ctxt: op_ctxt for transmitting the Send WR\n+ * @num_sge: number of SGEs to send\n+ * @inv_rkey: R_key argument to Send With Invalidate, or zero\n+ *\n+ * Returns:\n+ *\t%0 if the Send* was posted successfully,\n+ *\t%-ENOTCONN if the connection was lost or dropped,\n+ *\t%-EINVAL if there was a problem with the Send we built,\n+ *\t%-ENOMEM if ib_post_send failed.\n+ *\/\n+int svc_rdma_post_send_wr(struct svcxprt_rdma *rdma,\n+\t\t\t  struct svc_rdma_op_ctxt *ctxt, int num_sge,\n+\t\t\t  u32 inv_rkey)\n+{\n+\tstruct ib_send_wr *send_wr = &ctxt->send_wr;\n+\n+\tdprintk(\"svcrdma: posting Send WR with %u sge(s)\\n\", num_sge);\n+\n+\tsend_wr->next = NULL;\n+\tctxt->cqe.done = svc_rdma_wc_send;\n+\tsend_wr->wr_cqe = &ctxt->cqe;\n+\tsend_wr->sg_list = ctxt->sge;\n+\tsend_wr->num_sge = num_sge;\n+\tsend_wr->send_flags = IB_SEND_SIGNALED;\n+\tif (inv_rkey) {\n+\t\tsend_wr->opcode = IB_WR_SEND_WITH_INV;\n+\t\tsend_wr->ex.invalidate_rkey = inv_rkey;\n+\t} else {\n+\t\tsend_wr->opcode = IB_WR_SEND;\n+\t}\n+\n+\treturn svc_rdma_send(rdma, send_wr);\n+}\n+\n \/* This function prepares the portion of the RPCRDMA message to be\n  * sent in the RDMA_SEND. This function is called after data sent via\n  * RDMA has already been transmitted. There are three cases:\n@@ -460,7 +497,6 @@ static int send_reply(struct svcxprt_rdma *rdma,\n \t\t      u32 inv_rkey)\n {\n \tstruct svc_rdma_op_ctxt *ctxt;\n-\tstruct ib_send_wr send_wr;\n \tu32 xdr_off;\n \tint sge_no;\n \tint sge_bytes;\n@@ -524,19 +560,8 @@ static int send_reply(struct svcxprt_rdma *rdma,\n \t\tpr_err(\"svcrdma: Too many sges (%d)\\n\", sge_no);\n \t\tgoto err;\n \t}\n-\tmemset(&send_wr, 0, sizeof send_wr);\n-\tctxt->cqe.done = svc_rdma_wc_send;\n-\tsend_wr.wr_cqe = &ctxt->cqe;\n-\tsend_wr.sg_list = ctxt->sge;\n-\tsend_wr.num_sge = sge_no;\n-\tif (inv_rkey) {\n-\t\tsend_wr.opcode = IB_WR_SEND_WITH_INV;\n-\t\tsend_wr.ex.invalidate_rkey = inv_rkey;\n-\t} else\n-\t\tsend_wr.opcode = IB_WR_SEND;\n-\tsend_wr.send_flags =  IB_SEND_SIGNALED;\n \n-\tret = svc_rdma_send(rdma, &send_wr);\n+\tret = svc_rdma_post_send_wr(rdma, ctxt, sge_no, inv_rkey);\n \tif (ret)\n \t\tgoto err;\n \n@@ -652,7 +677,6 @@ int svc_rdma_sendto(struct svc_rqst *rqstp)\n void svc_rdma_send_error(struct svcxprt_rdma *xprt, struct rpcrdma_msg *rmsgp,\n \t\t\t int status)\n {\n-\tstruct ib_send_wr err_wr;\n \tstruct page *p;\n \tstruct svc_rdma_op_ctxt *ctxt;\n \tenum rpcrdma_errcode err;\n@@ -692,17 +716,7 @@ void svc_rdma_send_error(struct svcxprt_rdma *xprt, struct rpcrdma_msg *rmsgp,\n \t}\n \tsvc_rdma_count_mappings(xprt, ctxt);\n \n-\t\/* Prepare SEND WR *\/\n-\tmemset(&err_wr, 0, sizeof(err_wr));\n-\tctxt->cqe.done = svc_rdma_wc_send;\n-\terr_wr.wr_cqe = &ctxt->cqe;\n-\terr_wr.sg_list = ctxt->sge;\n-\terr_wr.num_sge = 1;\n-\terr_wr.opcode = IB_WR_SEND;\n-\terr_wr.send_flags = IB_SEND_SIGNALED;\n-\n-\t\/* Post It *\/\n-\tret = svc_rdma_send(xprt, &err_wr);\n+\tret = svc_rdma_post_send_wr(xprt, ctxt, 1, 0);\n \tif (ret) {\n \t\tdprintk(\"svcrdma: Error %d posting send for protocol error\\n\",\n \t\t\tret);\n\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex 287db5c179d8f..002a46d1faa1c 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -228,6 +228,9 @@ extern int rdma_read_chunk_frmr(struct svcxprt_rdma *, struct svc_rqst *,\n \/* svc_rdma_sendto.c *\/\n extern int svc_rdma_map_xdr(struct svcxprt_rdma *, struct xdr_buf *,\n \t\t\t    struct svc_rdma_req_map *, bool);\n+extern int svc_rdma_map_reply_hdr(struct svcxprt_rdma *rdma,\n+\t\t\t\t  struct svc_rdma_op_ctxt *ctxt,\n+\t\t\t\t  __be32 *rdma_resp, unsigned int len);\n extern int svc_rdma_post_send_wr(struct svcxprt_rdma *rdma,\n \t\t\t\t struct svc_rdma_op_ctxt *ctxt,\n \t\t\t\t int num_sge, u32 inv_rkey);\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\nindex f12f39c189c3c..0305b33d482fc 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\n@@ -101,50 +101,36 @@ int svc_rdma_handle_bc_reply(struct rpc_xprt *xprt, struct rpcrdma_msg *rmsgp,\n static int svc_rdma_bc_sendto(struct svcxprt_rdma *rdma,\n \t\t\t      struct rpc_rqst *rqst)\n {\n-\tstruct xdr_buf *sndbuf = &rqst->rq_snd_buf;\n \tstruct svc_rdma_op_ctxt *ctxt;\n-\tstruct svc_rdma_req_map *vec;\n \tint ret;\n \n-\tvec = svc_rdma_get_req_map(rdma);\n-\tret = svc_rdma_map_xdr(rdma, sndbuf, vec, false);\n-\tif (ret)\n+\tctxt = svc_rdma_get_context(rdma);\n+\n+\t\/* rpcrdma_bc_send_request builds the transport header and\n+\t * the backchannel RPC message in the same buffer. Thus only\n+\t * one SGE is needed to send both.\n+\t *\/\n+\tret = svc_rdma_map_reply_hdr(rdma, ctxt, rqst->rq_buffer,\n+\t\t\t\t     rqst->rq_snd_buf.len);\n+\tif (ret < 0)\n \t\tgoto out_err;\n \n \tret = svc_rdma_repost_recv(rdma, GFP_NOIO);\n \tif (ret)\n \t\tgoto out_err;\n \n-\tctxt = svc_rdma_get_context(rdma);\n-\tctxt->pages[0] = virt_to_page(rqst->rq_buffer);\n-\tctxt->count = 1;\n-\n-\tctxt->direction = DMA_TO_DEVICE;\n-\tctxt->sge[0].lkey = rdma->sc_pd->local_dma_lkey;\n-\tctxt->sge[0].length = sndbuf->len;\n-\tctxt->sge[0].addr =\n-\t    ib_dma_map_page(rdma->sc_cm_id->device, ctxt->pages[0], 0,\n-\t\t\t    sndbuf->len, DMA_TO_DEVICE);\n-\tif (ib_dma_mapping_error(rdma->sc_cm_id->device, ctxt->sge[0].addr)) {\n-\t\tret = -EIO;\n-\t\tgoto out_unmap;\n-\t}\n-\tsvc_rdma_count_mappings(rdma, ctxt);\n-\n \tret = svc_rdma_post_send_wr(rdma, ctxt, 1, 0);\n-\tif (ret) {\n-\t\tret = -EIO;\n+\tif (ret)\n \t\tgoto out_unmap;\n-\t}\n \n out_err:\n-\tsvc_rdma_put_req_map(rdma, vec);\n \tdprintk(\"svcrdma: %s returns %d\\n\", __func__, ret);\n \treturn ret;\n \n out_unmap:\n \tsvc_rdma_unmap_dma(ctxt);\n \tsvc_rdma_put_context(ctxt, 1);\n+\tret = -EIO;\n \tgoto out_err;\n }\n \ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\nindex f90b40d0932f4..a7dc71daa7762 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n@@ -217,6 +217,49 @@ static u32 svc_rdma_get_inv_rkey(struct rpcrdma_msg *rdma_argp,\n \treturn 0;\n }\n \n+static int svc_rdma_dma_map_page(struct svcxprt_rdma *rdma,\n+\t\t\t\t struct svc_rdma_op_ctxt *ctxt,\n+\t\t\t\t unsigned int sge_no,\n+\t\t\t\t struct page *page,\n+\t\t\t\t unsigned int offset,\n+\t\t\t\t unsigned int len)\n+{\n+\tstruct ib_device *dev = rdma->sc_cm_id->device;\n+\tdma_addr_t dma_addr;\n+\n+\tdma_addr = ib_dma_map_page(dev, page, offset, len, DMA_TO_DEVICE);\n+\tif (ib_dma_mapping_error(dev, dma_addr))\n+\t\treturn -EIO;\n+\n+\tctxt->sge[sge_no].addr = dma_addr;\n+\tctxt->sge[sge_no].length = len;\n+\tctxt->sge[sge_no].lkey = rdma->sc_pd->local_dma_lkey;\n+\tsvc_rdma_count_mappings(rdma, ctxt);\n+\treturn 0;\n+}\n+\n+\/**\n+ * svc_rdma_map_reply_hdr - DMA map the transport header buffer\n+ * @rdma: controlling transport\n+ * @ctxt: op_ctxt for the Send WR\n+ * @rdma_resp: buffer containing transport header\n+ * @len: length of transport header\n+ *\n+ * Returns:\n+ *\t%0 if the header is DMA mapped,\n+ *\t%-EIO if DMA mapping failed.\n+ *\/\n+int svc_rdma_map_reply_hdr(struct svcxprt_rdma *rdma,\n+\t\t\t   struct svc_rdma_op_ctxt *ctxt,\n+\t\t\t   __be32 *rdma_resp,\n+\t\t\t   unsigned int len)\n+{\n+\tctxt->direction = DMA_TO_DEVICE;\n+\tctxt->pages[0] = virt_to_page(rdma_resp);\n+\tctxt->count = 1;\n+\treturn svc_rdma_dma_map_page(rdma, ctxt, 0, ctxt->pages[0], 0, len);\n+}\n+\n \/* Assumptions:\n  * - The specified write_len can be represented in sc_max_sge * PAGE_SIZE\n  *\/\n@@ -699,22 +742,14 @@ void svc_rdma_send_error(struct svcxprt_rdma *xprt, struct rpcrdma_msg *rmsgp,\n \t\terr = ERR_VERS;\n \tlength = svc_rdma_xdr_encode_error(xprt, rmsgp, err, va);\n \n+\t\/* Map transport header; no RPC message payload *\/\n \tctxt = svc_rdma_get_context(xprt);\n-\tctxt->direction = DMA_TO_DEVICE;\n-\tctxt->count = 1;\n-\tctxt->pages[0] = p;\n-\n-\t\/* Prepare SGE for local address *\/\n-\tctxt->sge[0].lkey = xprt->sc_pd->local_dma_lkey;\n-\tctxt->sge[0].length = length;\n-\tctxt->sge[0].addr = ib_dma_map_page(xprt->sc_cm_id->device,\n-\t\t\t\t\t    p, 0, length, DMA_TO_DEVICE);\n-\tif (ib_dma_mapping_error(xprt->sc_cm_id->device, ctxt->sge[0].addr)) {\n-\t\tdprintk(\"svcrdma: Error mapping buffer for protocol error\\n\");\n-\t\tsvc_rdma_put_context(ctxt, 1);\n+\tret = svc_rdma_map_reply_hdr(xprt, ctxt, &rmsgp->rm_xid, length);\n+\tif (ret) {\n+\t\tdprintk(\"svcrdma: Error %d mapping send for protocol error\\n\",\n+\t\t\tret);\n \t\treturn;\n \t}\n-\tsvc_rdma_count_mappings(xprt, ctxt);\n \n \tret = svc_rdma_post_send_wr(xprt, ctxt, 1, 0);\n \tif (ret) {\n\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex 002a46d1faa1c..11d5aa123f17b 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -182,7 +182,6 @@ struct svcxprt_rdma {\n \/* The default ORD value is based on two outstanding full-size writes with a\n  * page size of 4k, or 32k * 2 ops \/ 4k = 16 outstanding RDMA_READ.  *\/\n #define RPCRDMA_ORD             (64\/4)\n-#define RPCRDMA_SQ_DEPTH_MULT   8\n #define RPCRDMA_MAX_REQUESTS    32\n #define RPCRDMA_MAX_REQ_SIZE    4096\n \ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma.c b\/net\/sunrpc\/xprtrdma\/svc_rdma.c\nindex c846ca9f1ebaa..9124441746470 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma.c\n@@ -247,8 +247,6 @@ int svc_rdma_init(void)\n \tdprintk(\"SVCRDMA Module Init, register RPC RDMA transport\\n\");\n \tdprintk(\"\\tsvcrdma_ord      : %d\\n\", svcrdma_ord);\n \tdprintk(\"\\tmax_requests     : %u\\n\", svcrdma_max_requests);\n-\tdprintk(\"\\tsq_depth         : %u\\n\",\n-\t\tsvcrdma_max_requests * RPCRDMA_SQ_DEPTH_MULT);\n \tdprintk(\"\\tmax_bc_requests  : %u\\n\", svcrdma_max_bc_requests);\n \tdprintk(\"\\tmax_inline       : %d\\n\", svcrdma_max_req_size);\n \ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\nindex fc8f14c7bfec6..e1097cc6d1eb3 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\n@@ -1014,7 +1014,7 @@ static struct svc_xprt *svc_rdma_accept(struct svc_xprt *xprt)\n \t\t\t\t\t    svcrdma_max_bc_requests);\n \tnewxprt->sc_rq_depth = newxprt->sc_max_requests +\n \t\t\t       newxprt->sc_max_bc_requests;\n-\tnewxprt->sc_sq_depth = RPCRDMA_SQ_DEPTH_MULT * newxprt->sc_rq_depth;\n+\tnewxprt->sc_sq_depth = newxprt->sc_rq_depth;\n \tatomic_set(&newxprt->sc_sq_avail, newxprt->sc_sq_depth);\n \n \tif (!svc_rdma_prealloc_ctxts(newxprt))\n\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\nindex a7dc71daa7762..2798f3ea0020d 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n@@ -478,6 +478,23 @@ static int send_reply_chunks(struct svcxprt_rdma *xprt,\n \treturn -EIO;\n }\n \n+\/* The svc_rqst and all resources it owns are released as soon as\n+ * svc_rdma_sendto returns. Transfer pages under I\/O to the ctxt\n+ * so they are released by the Send completion handler.\n+ *\/\n+static void svc_rdma_save_io_pages(struct svc_rqst *rqstp,\n+\t\t\t\t   struct svc_rdma_op_ctxt *ctxt)\n+{\n+\tint i, pages = rqstp->rq_next_page - rqstp->rq_respages;\n+\n+\tctxt->count += pages;\n+\tfor (i = 0; i < pages; i++) {\n+\t\tctxt->pages[i + 1] = rqstp->rq_respages[i];\n+\t\trqstp->rq_respages[i] = NULL;\n+\t}\n+\trqstp->rq_next_page = rqstp->rq_respages + 1;\n+}\n+\n \/**\n  * svc_rdma_post_send_wr - Set up and post one Send Work Request\n  * @rdma: controlling transport\n@@ -543,8 +560,6 @@ static int send_reply(struct svcxprt_rdma *rdma,\n \tu32 xdr_off;\n \tint sge_no;\n \tint sge_bytes;\n-\tint page_no;\n-\tint pages;\n \tint ret = -EIO;\n \n \t\/* Prepare the context *\/\n@@ -587,17 +602,7 @@ static int send_reply(struct svcxprt_rdma *rdma,\n \t\tgoto err;\n \t}\n \n-\t\/* Save all respages in the ctxt and remove them from the\n-\t * respages array. They are our pages until the I\/O\n-\t * completes.\n-\t *\/\n-\tpages = rqstp->rq_next_page - rqstp->rq_respages;\n-\tfor (page_no = 0; page_no < pages; page_no++) {\n-\t\tctxt->pages[page_no+1] = rqstp->rq_respages[page_no];\n-\t\tctxt->count++;\n-\t\trqstp->rq_respages[page_no] = NULL;\n-\t}\n-\trqstp->rq_next_page = rqstp->rq_respages + 1;\n+\tsvc_rdma_save_io_pages(rqstp, ctxt);\n \n \tif (sge_no > rdma->sc_max_sge) {\n \t\tpr_err(\"svcrdma: Too many sges (%d)\\n\", sge_no);\n\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\nindex 2798f3ea0020d..2eb3df698e11b 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n@@ -189,32 +189,25 @@ static void svc_rdma_get_write_arrays(struct rpcrdma_msg *rmsgp,\n  * Invalidate, and responder chooses one rkey to invalidate.\n  *\n  * Find a candidate rkey to invalidate when sending a reply.  Picks the\n- * first rkey it finds in the chunks lists.\n+ * first R_key it finds in the chunk lists.\n  *\n  * Returns zero if RPC's chunk lists are empty.\n  *\/\n-static u32 svc_rdma_get_inv_rkey(struct rpcrdma_msg *rdma_argp,\n-\t\t\t\t struct rpcrdma_write_array *wr_ary,\n-\t\t\t\t struct rpcrdma_write_array *rp_ary)\n+static u32 svc_rdma_get_inv_rkey(__be32 *rdma_argp,\n+\t\t\t\t __be32 *wr_lst, __be32 *rp_ch)\n {\n-\tstruct rpcrdma_read_chunk *rd_ary;\n-\tstruct rpcrdma_segment *arg_ch;\n-\n-\trd_ary = (struct rpcrdma_read_chunk *)&rdma_argp->rm_body.rm_chunks[0];\n-\tif (rd_ary->rc_discrim != xdr_zero)\n-\t\treturn be32_to_cpu(rd_ary->rc_target.rs_handle);\n-\n-\tif (wr_ary && be32_to_cpu(wr_ary->wc_nchunks)) {\n-\t\targ_ch = &wr_ary->wc_array[0].wc_target;\n-\t\treturn be32_to_cpu(arg_ch->rs_handle);\n-\t}\n-\n-\tif (rp_ary && be32_to_cpu(rp_ary->wc_nchunks)) {\n-\t\targ_ch = &rp_ary->wc_array[0].wc_target;\n-\t\treturn be32_to_cpu(arg_ch->rs_handle);\n-\t}\n+\t__be32 *p;\n \n-\treturn 0;\n+\tp = rdma_argp + rpcrdma_fixed_maxsz;\n+\tif (*p != xdr_zero)\n+\t\tp += 2;\n+\telse if (wr_lst && be32_to_cpup(wr_lst + 1))\n+\t\tp = wr_lst + 2;\n+\telse if (rp_ch && be32_to_cpup(rp_ch + 1))\n+\t\tp = rp_ch + 2;\n+\telse\n+\t\treturn 0;\n+\treturn be32_to_cpup(p);\n }\n \n static int svc_rdma_dma_map_page(struct svcxprt_rdma *rdma,\n@@ -650,7 +643,9 @@ int svc_rdma_sendto(struct svc_rqst *rqstp)\n \n \tinv_rkey = 0;\n \tif (rdma->sc_snd_w_inv)\n-\t\tinv_rkey = svc_rdma_get_inv_rkey(rdma_argp, wr_ary, rp_ary);\n+\t\tinv_rkey = svc_rdma_get_inv_rkey(&rdma_argp->rm_xid,\n+\t\t\t\t\t\t (__be32 *)wr_ary,\n+\t\t\t\t\t\t (__be32 *)rp_ary);\n \n \t\/* Build an req vec for the XDR *\/\n \tvec = svc_rdma_get_req_map(rdma);\n\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex 11d5aa123f17b..ca08671fb7e2b 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -145,12 +145,15 @@ struct svcxprt_rdma {\n \tu32\t\t     sc_max_requests;\t\/* Max requests *\/\n \tu32\t\t     sc_max_bc_requests;\/* Backward credits *\/\n \tint                  sc_max_req_size;\t\/* Size of each RQ WR buf *\/\n+\tu8\t\t     sc_port_num;\n \n \tstruct ib_pd         *sc_pd;\n \n \tspinlock_t\t     sc_ctxt_lock;\n \tstruct list_head     sc_ctxts;\n \tint\t\t     sc_ctxt_used;\n+\tspinlock_t\t     sc_rw_ctxt_lock;\n+\tstruct list_head     sc_rw_ctxts;\n \tspinlock_t\t     sc_map_lock;\n \tstruct list_head     sc_maps;\n \n@@ -224,6 +227,14 @@ extern int rdma_read_chunk_frmr(struct svcxprt_rdma *, struct svc_rqst *,\n \t\t\t\tstruct svc_rdma_op_ctxt *, int *, u32 *,\n \t\t\t\tu32, u32, u64, bool);\n \n+\/* svc_rdma_rw.c *\/\n+extern void svc_rdma_destroy_rw_ctxts(struct svcxprt_rdma *rdma);\n+extern int svc_rdma_send_write_chunk(struct svcxprt_rdma *rdma,\n+\t\t\t\t     __be32 *wr_ch, struct xdr_buf *xdr);\n+extern int svc_rdma_send_reply_chunk(struct svcxprt_rdma *rdma,\n+\t\t\t\t     __be32 *rp_ch, bool writelist,\n+\t\t\t\t     struct xdr_buf *xdr);\n+\n \/* svc_rdma_sendto.c *\/\n extern int svc_rdma_map_xdr(struct svcxprt_rdma *, struct xdr_buf *,\n \t\t\t    struct svc_rdma_req_map *, bool);\ndiff --git a\/net\/sunrpc\/Kconfig b\/net\/sunrpc\/Kconfig\nindex 04ce2c0b660e0..ac09ca8032965 100644\n--- a\/net\/sunrpc\/Kconfig\n+++ b\/net\/sunrpc\/Kconfig\n@@ -52,6 +52,7 @@ config SUNRPC_XPRT_RDMA\n \ttristate \"RPC-over-RDMA transport\"\n \tdepends on SUNRPC && INFINIBAND && INFINIBAND_ADDR_TRANS\n \tdefault SUNRPC && INFINIBAND\n+\tselect SG_POOL\n \thelp\n \t  This option allows the NFS client and server to use RDMA\n \t  transports (InfiniBand, iWARP, or RoCE).\ndiff --git a\/net\/sunrpc\/xprtrdma\/Makefile b\/net\/sunrpc\/xprtrdma\/Makefile\nindex ef19fa42c50ff..c1ae8142ab734 100644\n--- a\/net\/sunrpc\/xprtrdma\/Makefile\n+++ b\/net\/sunrpc\/xprtrdma\/Makefile\n@@ -4,5 +4,5 @@ rpcrdma-y := transport.o rpc_rdma.o verbs.o \\\n \tfmr_ops.o frwr_ops.o \\\n \tsvc_rdma.o svc_rdma_backchannel.o svc_rdma_transport.o \\\n \tsvc_rdma_marshal.o svc_rdma_sendto.o svc_rdma_recvfrom.o \\\n-\tmodule.o\n+\tsvc_rdma_rw.o module.o\n rpcrdma-$(CONFIG_SUNRPC_BACKCHANNEL) += backchannel.o\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_rw.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_rw.c\nnew file mode 100644\nindex 0000000000000..0cf6202776933\n--- \/dev\/null\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_rw.c\n@@ -0,0 +1,512 @@\n+\/*\n+ * Copyright (c) 2016 Oracle.  All rights reserved.\n+ *\n+ * Use the core R\/W API to move RPC-over-RDMA Read and Write chunks.\n+ *\/\n+\n+#include <linux\/sunrpc\/rpc_rdma.h>\n+#include <linux\/sunrpc\/svc_rdma.h>\n+#include <linux\/sunrpc\/debug.h>\n+\n+#include <rdma\/rw.h>\n+\n+#define RPCDBG_FACILITY\tRPCDBG_SVCXPRT\n+\n+\/* Each R\/W context contains state for one chain of RDMA Read or\n+ * Write Work Requests.\n+ *\n+ * Each WR chain handles a single contiguous server-side buffer,\n+ * because scatterlist entries after the first have to start on\n+ * page alignment. xdr_buf iovecs cannot guarantee alignment.\n+ *\n+ * Each WR chain handles only one R_key. Each RPC-over-RDMA segment\n+ * from a client may contain a unique R_key, so each WR chain moves\n+ * up to one segment at a time.\n+ *\n+ * The scatterlist makes this data structure over 4KB in size. To\n+ * make it less likely to fail, and to handle the allocation for\n+ * smaller I\/O requests without disabling bottom-halves, these\n+ * contexts are created on demand, but cached and reused until the\n+ * controlling svcxprt_rdma is destroyed.\n+ *\/\n+struct svc_rdma_rw_ctxt {\n+\tstruct list_head\trw_list;\n+\tstruct rdma_rw_ctx\trw_ctx;\n+\tint\t\t\trw_nents;\n+\tstruct sg_table\t\trw_sg_table;\n+\tstruct scatterlist\trw_first_sgl[0];\n+};\n+\n+static inline struct svc_rdma_rw_ctxt *\n+svc_rdma_next_ctxt(struct list_head *list)\n+{\n+\treturn list_first_entry_or_null(list, struct svc_rdma_rw_ctxt,\n+\t\t\t\t\trw_list);\n+}\n+\n+static struct svc_rdma_rw_ctxt *\n+svc_rdma_get_rw_ctxt(struct svcxprt_rdma *rdma, unsigned int sges)\n+{\n+\tstruct svc_rdma_rw_ctxt *ctxt;\n+\n+\tspin_lock(&rdma->sc_rw_ctxt_lock);\n+\n+\tctxt = svc_rdma_next_ctxt(&rdma->sc_rw_ctxts);\n+\tif (ctxt) {\n+\t\tlist_del(&ctxt->rw_list);\n+\t\tspin_unlock(&rdma->sc_rw_ctxt_lock);\n+\t} else {\n+\t\tspin_unlock(&rdma->sc_rw_ctxt_lock);\n+\t\tctxt = kmalloc(sizeof(*ctxt) +\n+\t\t\t       SG_CHUNK_SIZE * sizeof(struct scatterlist),\n+\t\t\t       GFP_KERNEL);\n+\t\tif (!ctxt)\n+\t\t\tgoto out;\n+\t\tINIT_LIST_HEAD(&ctxt->rw_list);\n+\t}\n+\n+\tctxt->rw_sg_table.sgl = ctxt->rw_first_sgl;\n+\tif (sg_alloc_table_chained(&ctxt->rw_sg_table, sges,\n+\t\t\t\t   ctxt->rw_sg_table.sgl)) {\n+\t\tkfree(ctxt);\n+\t\tctxt = NULL;\n+\t}\n+out:\n+\treturn ctxt;\n+}\n+\n+static void svc_rdma_put_rw_ctxt(struct svcxprt_rdma *rdma,\n+\t\t\t\t struct svc_rdma_rw_ctxt *ctxt)\n+{\n+\tsg_free_table_chained(&ctxt->rw_sg_table, true);\n+\n+\tspin_lock(&rdma->sc_rw_ctxt_lock);\n+\tlist_add(&ctxt->rw_list, &rdma->sc_rw_ctxts);\n+\tspin_unlock(&rdma->sc_rw_ctxt_lock);\n+}\n+\n+\/**\n+ * svc_rdma_destroy_rw_ctxts - Free accumulated R\/W contexts\n+ * @rdma: transport about to be destroyed\n+ *\n+ *\/\n+void svc_rdma_destroy_rw_ctxts(struct svcxprt_rdma *rdma)\n+{\n+\tstruct svc_rdma_rw_ctxt *ctxt;\n+\n+\twhile ((ctxt = svc_rdma_next_ctxt(&rdma->sc_rw_ctxts)) != NULL) {\n+\t\tlist_del(&ctxt->rw_list);\n+\t\tkfree(ctxt);\n+\t}\n+}\n+\n+\/* A chunk context tracks all I\/O for moving one Read or Write\n+ * chunk. This is a a set of rdma_rw's that handle data movement\n+ * for all segments of one chunk.\n+ *\n+ * These are small, acquired with a single allocator call, and\n+ * no more than one is needed per chunk. They are allocated on\n+ * demand, and not cached.\n+ *\/\n+struct svc_rdma_chunk_ctxt {\n+\tstruct ib_cqe\t\tcc_cqe;\n+\tstruct svcxprt_rdma\t*cc_rdma;\n+\tstruct list_head\tcc_rwctxts;\n+\tint\t\t\tcc_sqecount;\n+\tenum dma_data_direction cc_dir;\n+};\n+\n+static void svc_rdma_cc_init(struct svcxprt_rdma *rdma,\n+\t\t\t     struct svc_rdma_chunk_ctxt *cc,\n+\t\t\t     enum dma_data_direction dir)\n+{\n+\tcc->cc_rdma = rdma;\n+\tsvc_xprt_get(&rdma->sc_xprt);\n+\n+\tINIT_LIST_HEAD(&cc->cc_rwctxts);\n+\tcc->cc_sqecount = 0;\n+\tcc->cc_dir = dir;\n+}\n+\n+static void svc_rdma_cc_release(struct svc_rdma_chunk_ctxt *cc)\n+{\n+\tstruct svcxprt_rdma *rdma = cc->cc_rdma;\n+\tstruct svc_rdma_rw_ctxt *ctxt;\n+\n+\twhile ((ctxt = svc_rdma_next_ctxt(&cc->cc_rwctxts)) != NULL) {\n+\t\tlist_del(&ctxt->rw_list);\n+\n+\t\trdma_rw_ctx_destroy(&ctxt->rw_ctx, rdma->sc_qp,\n+\t\t\t\t    rdma->sc_port_num, ctxt->rw_sg_table.sgl,\n+\t\t\t\t    ctxt->rw_nents, cc->cc_dir);\n+\t\tsvc_rdma_put_rw_ctxt(rdma, ctxt);\n+\t}\n+\tsvc_xprt_put(&rdma->sc_xprt);\n+}\n+\n+\/* State for sending a Write or Reply chunk.\n+ *  - Tracks progress of writing one chunk over all its segments\n+ *  - Stores arguments for the SGL constructor functions\n+ *\/\n+struct svc_rdma_write_info {\n+\t\/* write state of this chunk *\/\n+\tunsigned int\t\twi_seg_off;\n+\tunsigned int\t\twi_seg_no;\n+\tunsigned int\t\twi_nsegs;\n+\t__be32\t\t\t*wi_segs;\n+\n+\t\/* SGL constructor arguments *\/\n+\tstruct xdr_buf\t\t*wi_xdr;\n+\tunsigned char\t\t*wi_base;\n+\tunsigned int\t\twi_next_off;\n+\n+\tstruct svc_rdma_chunk_ctxt\twi_cc;\n+};\n+\n+static struct svc_rdma_write_info *\n+svc_rdma_write_info_alloc(struct svcxprt_rdma *rdma, __be32 *chunk)\n+{\n+\tstruct svc_rdma_write_info *info;\n+\n+\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n+\tif (!info)\n+\t\treturn info;\n+\n+\tinfo->wi_seg_off = 0;\n+\tinfo->wi_seg_no = 0;\n+\tinfo->wi_nsegs = be32_to_cpup(++chunk);\n+\tinfo->wi_segs = ++chunk;\n+\tsvc_rdma_cc_init(rdma, &info->wi_cc, DMA_TO_DEVICE);\n+\treturn info;\n+}\n+\n+static void svc_rdma_write_info_free(struct svc_rdma_write_info *info)\n+{\n+\tsvc_rdma_cc_release(&info->wi_cc);\n+\tkfree(info);\n+}\n+\n+\/**\n+ * svc_rdma_write_done - Write chunk completion\n+ * @cq: controlling Completion Queue\n+ * @wc: Work Completion\n+ *\n+ * Pages under I\/O are freed by a subsequent Send completion.\n+ *\/\n+static void svc_rdma_write_done(struct ib_cq *cq, struct ib_wc *wc)\n+{\n+\tstruct ib_cqe *cqe = wc->wr_cqe;\n+\tstruct svc_rdma_chunk_ctxt *cc =\n+\t\t\tcontainer_of(cqe, struct svc_rdma_chunk_ctxt, cc_cqe);\n+\tstruct svcxprt_rdma *rdma = cc->cc_rdma;\n+\tstruct svc_rdma_write_info *info =\n+\t\t\tcontainer_of(cc, struct svc_rdma_write_info, wi_cc);\n+\n+\tatomic_add(cc->cc_sqecount, &rdma->sc_sq_avail);\n+\twake_up(&rdma->sc_send_wait);\n+\n+\tif (unlikely(wc->status != IB_WC_SUCCESS)) {\n+\t\tset_bit(XPT_CLOSE, &rdma->sc_xprt.xpt_flags);\n+\t\tif (wc->status != IB_WC_WR_FLUSH_ERR)\n+\t\t\tpr_err(\"svcrdma: write ctx: %s (%u\/0x%x)\\n\",\n+\t\t\t       ib_wc_status_msg(wc->status),\n+\t\t\t       wc->status, wc->vendor_err);\n+\t}\n+\n+\tsvc_rdma_write_info_free(info);\n+}\n+\n+\/* This function sleeps when the transport's Send Queue is congested.\n+ *\n+ * Assumptions:\n+ * - If ib_post_send() succeeds, only one completion is expected,\n+ *   even if one or more WRs are flushed. This is true when posting\n+ *   an rdma_rw_ctx or when posting a single signaled WR.\n+ *\/\n+static int svc_rdma_post_chunk_ctxt(struct svc_rdma_chunk_ctxt *cc)\n+{\n+\tstruct svcxprt_rdma *rdma = cc->cc_rdma;\n+\tstruct svc_xprt *xprt = &rdma->sc_xprt;\n+\tstruct ib_send_wr *first_wr, *bad_wr;\n+\tstruct list_head *tmp;\n+\tstruct ib_cqe *cqe;\n+\tint ret;\n+\n+\tfirst_wr = NULL;\n+\tcqe = &cc->cc_cqe;\n+\tlist_for_each(tmp, &cc->cc_rwctxts) {\n+\t\tstruct svc_rdma_rw_ctxt *ctxt;\n+\n+\t\tctxt = list_entry(tmp, struct svc_rdma_rw_ctxt, rw_list);\n+\t\tfirst_wr = rdma_rw_ctx_wrs(&ctxt->rw_ctx, rdma->sc_qp,\n+\t\t\t\t\t   rdma->sc_port_num, cqe, first_wr);\n+\t\tcqe = NULL;\n+\t}\n+\n+\tdo {\n+\t\tif (atomic_sub_return(cc->cc_sqecount,\n+\t\t\t\t      &rdma->sc_sq_avail) > 0) {\n+\t\t\tret = ib_post_send(rdma->sc_qp, first_wr, &bad_wr);\n+\t\t\tif (ret)\n+\t\t\t\tbreak;\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tatomic_inc(&rdma_stat_sq_starve);\n+\t\tatomic_add(cc->cc_sqecount, &rdma->sc_sq_avail);\n+\t\twait_event(rdma->sc_send_wait,\n+\t\t\t   atomic_read(&rdma->sc_sq_avail) > cc->cc_sqecount);\n+\t} while (1);\n+\n+\tpr_err(\"svcrdma: ib_post_send failed (%d)\\n\", ret);\n+\tset_bit(XPT_CLOSE, &xprt->xpt_flags);\n+\n+\t\/* If even one was posted, there will be a completion. *\/\n+\tif (bad_wr != first_wr)\n+\t\treturn 0;\n+\n+\tatomic_add(cc->cc_sqecount, &rdma->sc_sq_avail);\n+\twake_up(&rdma->sc_send_wait);\n+\treturn -ENOTCONN;\n+}\n+\n+\/* Build and DMA-map an SGL that covers one kvec in an xdr_buf\n+ *\/\n+static void svc_rdma_vec_to_sg(struct svc_rdma_write_info *info,\n+\t\t\t       unsigned int len,\n+\t\t\t       struct svc_rdma_rw_ctxt *ctxt)\n+{\n+\tstruct scatterlist *sg = ctxt->rw_sg_table.sgl;\n+\n+\tsg_set_buf(&sg[0], info->wi_base, len);\n+\tinfo->wi_base += len;\n+\n+\tctxt->rw_nents = 1;\n+}\n+\n+\/* Build and DMA-map an SGL that covers part of an xdr_buf's pagelist.\n+ *\/\n+static void svc_rdma_pagelist_to_sg(struct svc_rdma_write_info *info,\n+\t\t\t\t    unsigned int remaining,\n+\t\t\t\t    struct svc_rdma_rw_ctxt *ctxt)\n+{\n+\tunsigned int sge_no, sge_bytes, page_off, page_no;\n+\tstruct xdr_buf *xdr = info->wi_xdr;\n+\tstruct scatterlist *sg;\n+\tstruct page **page;\n+\n+\tpage_off = (info->wi_next_off + xdr->page_base) & ~PAGE_MASK;\n+\tpage_no = (info->wi_next_off + xdr->page_base) >> PAGE_SHIFT;\n+\tpage = xdr->pages + page_no;\n+\tinfo->wi_next_off += remaining;\n+\tsg = ctxt->rw_sg_table.sgl;\n+\tsge_no = 0;\n+\tdo {\n+\t\tsge_bytes = min_t(unsigned int, remaining,\n+\t\t\t\t  PAGE_SIZE - page_off);\n+\t\tsg_set_page(sg, *page, sge_bytes, page_off);\n+\n+\t\tremaining -= sge_bytes;\n+\t\tsg = sg_next(sg);\n+\t\tpage_off = 0;\n+\t\tsge_no++;\n+\t\tpage++;\n+\t} while (remaining);\n+\n+\tctxt->rw_nents = sge_no;\n+}\n+\n+\/* Construct RDMA Write WRs to send a portion of an xdr_buf containing\n+ * an RPC Reply.\n+ *\/\n+static int\n+svc_rdma_build_writes(struct svc_rdma_write_info *info,\n+\t\t      void (*constructor)(struct svc_rdma_write_info *info,\n+\t\t\t\t\t  unsigned int len,\n+\t\t\t\t\t  struct svc_rdma_rw_ctxt *ctxt),\n+\t\t      unsigned int remaining)\n+{\n+\tstruct svc_rdma_chunk_ctxt *cc = &info->wi_cc;\n+\tstruct svcxprt_rdma *rdma = cc->cc_rdma;\n+\tstruct svc_rdma_rw_ctxt *ctxt;\n+\t__be32 *seg;\n+\tint ret;\n+\n+\tcc->cc_cqe.done = svc_rdma_write_done;\n+\tseg = info->wi_segs + info->wi_seg_no * rpcrdma_segment_maxsz;\n+\tdo {\n+\t\tunsigned int write_len;\n+\t\tu32 seg_length, seg_handle;\n+\t\tu64 seg_offset;\n+\n+\t\tif (info->wi_seg_no >= info->wi_nsegs)\n+\t\t\tgoto out_overflow;\n+\n+\t\tseg_handle = be32_to_cpup(seg);\n+\t\tseg_length = be32_to_cpup(seg + 1);\n+\t\txdr_decode_hyper(seg + 2, &seg_offset);\n+\t\tseg_offset += info->wi_seg_off;\n+\n+\t\twrite_len = min(remaining, seg_length - info->wi_seg_off);\n+\t\tctxt = svc_rdma_get_rw_ctxt(rdma,\n+\t\t\t\t\t    (write_len >> PAGE_SHIFT) + 2);\n+\t\tif (!ctxt)\n+\t\t\tgoto out_noctx;\n+\n+\t\tconstructor(info, write_len, ctxt);\n+\t\tret = rdma_rw_ctx_init(&ctxt->rw_ctx, rdma->sc_qp,\n+\t\t\t\t       rdma->sc_port_num, ctxt->rw_sg_table.sgl,\n+\t\t\t\t       ctxt->rw_nents, 0, seg_offset,\n+\t\t\t\t       seg_handle, DMA_TO_DEVICE);\n+\t\tif (ret < 0)\n+\t\t\tgoto out_initerr;\n+\n+\t\tlist_add(&ctxt->rw_list, &cc->cc_rwctxts);\n+\t\tcc->cc_sqecount += ret;\n+\t\tif (write_len == seg_length - info->wi_seg_off) {\n+\t\t\tseg += 4;\n+\t\t\tinfo->wi_seg_no++;\n+\t\t\tinfo->wi_seg_off = 0;\n+\t\t} else {\n+\t\t\tinfo->wi_seg_off += write_len;\n+\t\t}\n+\t\tremaining -= write_len;\n+\t} while (remaining);\n+\n+\treturn 0;\n+\n+out_overflow:\n+\tdprintk(\"svcrdma: inadequate space in Write chunk (%u)\\n\",\n+\t\tinfo->wi_nsegs);\n+\treturn -E2BIG;\n+\n+out_noctx:\n+\tdprintk(\"svcrdma: no R\/W ctxs available\\n\");\n+\treturn -ENOMEM;\n+\n+out_initerr:\n+\tsvc_rdma_put_rw_ctxt(rdma, ctxt);\n+\tpr_err(\"svcrdma: failed to map pagelist (%d)\\n\", ret);\n+\treturn -EIO;\n+}\n+\n+\/* Send one of an xdr_buf's kvecs by itself. To send a Reply\n+ * chunk, the whole RPC Reply is written back to the client.\n+ * This function writes either the head or tail of the xdr_buf\n+ * containing the Reply.\n+ *\/\n+static int svc_rdma_send_xdr_kvec(struct svc_rdma_write_info *info,\n+\t\t\t\t  struct kvec *vec)\n+{\n+\tinfo->wi_base = vec->iov_base;\n+\treturn svc_rdma_build_writes(info, svc_rdma_vec_to_sg,\n+\t\t\t\t     vec->iov_len);\n+}\n+\n+\/* Send an xdr_buf's page list by itself. A Write chunk is\n+ * just the page list. a Reply chunk is the head, page list,\n+ * and tail. This function is shared between the two types\n+ * of chunk.\n+ *\/\n+static int svc_rdma_send_xdr_pagelist(struct svc_rdma_write_info *info,\n+\t\t\t\t      struct xdr_buf *xdr)\n+{\n+\tinfo->wi_xdr = xdr;\n+\tinfo->wi_next_off = 0;\n+\treturn svc_rdma_build_writes(info, svc_rdma_pagelist_to_sg,\n+\t\t\t\t     xdr->page_len);\n+}\n+\n+\/**\n+ * svc_rdma_send_write_chunk - Write all segments in a Write chunk\n+ * @rdma: controlling RDMA transport\n+ * @wr_ch: Write chunk provided by client\n+ * @xdr: xdr_buf containing the data payload\n+ *\n+ * Returns a non-negative number of bytes the chunk consumed, or\n+ *\t%-E2BIG if the payload was larger than the Write chunk,\n+ *\t%-ENOMEM if rdma_rw context pool was exhausted,\n+ *\t%-ENOTCONN if posting failed (connection is lost),\n+ *\t%-EIO if rdma_rw initialization failed (DMA mapping, etc).\n+ *\/\n+int svc_rdma_send_write_chunk(struct svcxprt_rdma *rdma, __be32 *wr_ch,\n+\t\t\t      struct xdr_buf *xdr)\n+{\n+\tstruct svc_rdma_write_info *info;\n+\tint ret;\n+\n+\tif (!xdr->page_len)\n+\t\treturn 0;\n+\n+\tinfo = svc_rdma_write_info_alloc(rdma, wr_ch);\n+\tif (!info)\n+\t\treturn -ENOMEM;\n+\n+\tret = svc_rdma_send_xdr_pagelist(info, xdr);\n+\tif (ret < 0)\n+\t\tgoto out_err;\n+\n+\tret = svc_rdma_post_chunk_ctxt(&info->wi_cc);\n+\tif (ret < 0)\n+\t\tgoto out_err;\n+\treturn xdr->page_len;\n+\n+out_err:\n+\tsvc_rdma_write_info_free(info);\n+\treturn ret;\n+}\n+\n+\/**\n+ * svc_rdma_send_reply_chunk - Write all segments in the Reply chunk\n+ * @rdma: controlling RDMA transport\n+ * @rp_ch: Reply chunk provided by client\n+ * @writelist: true if client provided a Write list\n+ * @xdr: xdr_buf containing an RPC Reply\n+ *\n+ * Returns a non-negative number of bytes the chunk consumed, or\n+ *\t%-E2BIG if the payload was larger than the Reply chunk,\n+ *\t%-ENOMEM if rdma_rw context pool was exhausted,\n+ *\t%-ENOTCONN if posting failed (connection is lost),\n+ *\t%-EIO if rdma_rw initialization failed (DMA mapping, etc).\n+ *\/\n+int svc_rdma_send_reply_chunk(struct svcxprt_rdma *rdma, __be32 *rp_ch,\n+\t\t\t      bool writelist, struct xdr_buf *xdr)\n+{\n+\tstruct svc_rdma_write_info *info;\n+\tint consumed, ret;\n+\n+\tinfo = svc_rdma_write_info_alloc(rdma, rp_ch);\n+\tif (!info)\n+\t\treturn -ENOMEM;\n+\n+\tret = svc_rdma_send_xdr_kvec(info, &xdr->head[0]);\n+\tif (ret < 0)\n+\t\tgoto out_err;\n+\tconsumed = xdr->head[0].iov_len;\n+\n+\t\/* Send the page list in the Reply chunk only if the\n+\t * client did not provide Write chunks.\n+\t *\/\n+\tif (!writelist && xdr->page_len) {\n+\t\tret = svc_rdma_send_xdr_pagelist(info, xdr);\n+\t\tif (ret < 0)\n+\t\t\tgoto out_err;\n+\t\tconsumed += xdr->page_len;\n+\t}\n+\n+\tif (xdr->tail[0].iov_len) {\n+\t\tret = svc_rdma_send_xdr_kvec(info, &xdr->tail[0]);\n+\t\tif (ret < 0)\n+\t\t\tgoto out_err;\n+\t\tconsumed += xdr->tail[0].iov_len;\n+\t}\n+\n+\tret = svc_rdma_post_chunk_ctxt(&info->wi_cc);\n+\tif (ret < 0)\n+\t\tgoto out_err;\n+\treturn consumed;\n+\n+out_err:\n+\tsvc_rdma_write_info_free(info);\n+\treturn ret;\n+}\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\nindex e1097cc6d1eb3..b25c50992a95c 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\n@@ -561,6 +561,7 @@ static struct svcxprt_rdma *rdma_create_xprt(struct svc_serv *serv,\n \tINIT_LIST_HEAD(&cma_xprt->sc_read_complete_q);\n \tINIT_LIST_HEAD(&cma_xprt->sc_frmr_q);\n \tINIT_LIST_HEAD(&cma_xprt->sc_ctxts);\n+\tINIT_LIST_HEAD(&cma_xprt->sc_rw_ctxts);\n \tINIT_LIST_HEAD(&cma_xprt->sc_maps);\n \tinit_waitqueue_head(&cma_xprt->sc_send_wait);\n \n@@ -568,6 +569,7 @@ static struct svcxprt_rdma *rdma_create_xprt(struct svc_serv *serv,\n \tspin_lock_init(&cma_xprt->sc_rq_dto_lock);\n \tspin_lock_init(&cma_xprt->sc_frmr_q_lock);\n \tspin_lock_init(&cma_xprt->sc_ctxt_lock);\n+\tspin_lock_init(&cma_xprt->sc_rw_ctxt_lock);\n \tspin_lock_init(&cma_xprt->sc_map_lock);\n \n \t\/*\n@@ -999,6 +1001,7 @@ static struct svc_xprt *svc_rdma_accept(struct svc_xprt *xprt)\n \t\tnewxprt, newxprt->sc_cm_id);\n \n \tdev = newxprt->sc_cm_id->device;\n+\tnewxprt->sc_port_num = newxprt->sc_cm_id->port_num;\n \n \t\/* Qualify the transport resource defaults with the\n \t * capabilities of this particular device *\/\n@@ -1248,6 +1251,7 @@ static void __svc_rdma_free(struct work_struct *work)\n \t}\n \n \trdma_dealloc_frmr_q(rdma);\n+\tsvc_rdma_destroy_rw_ctxts(rdma);\n \tsvc_rdma_destroy_ctxts(rdma);\n \tsvc_rdma_destroy_maps(rdma);\n \n\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex ca08671fb7e2b..599ee03ee3fb1 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -212,7 +212,6 @@ extern int svc_rdma_xdr_decode_req(struct xdr_buf *);\n extern int svc_rdma_xdr_encode_error(struct svcxprt_rdma *,\n \t\t\t\t     struct rpcrdma_msg *,\n \t\t\t\t     enum rpcrdma_errcode, __be32 *);\n-extern void svc_rdma_xdr_encode_write_list(struct rpcrdma_msg *, int);\n extern void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *, int);\n extern void svc_rdma_xdr_encode_array_chunk(struct rpcrdma_write_array *, int,\n \t\t\t\t\t    __be32, __be64, u32);\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\nindex 0305b33d482fc..bf185b79c98fb 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\n@@ -90,9 +90,9 @@ int svc_rdma_handle_bc_reply(struct rpc_xprt *xprt, struct rpcrdma_msg *rmsgp,\n  * Caller holds the connection's mutex and has already marshaled\n  * the RPC\/RDMA request.\n  *\n- * This is similar to svc_rdma_reply, but takes an rpc_rqst\n- * instead, does not support chunks, and avoids blocking memory\n- * allocation.\n+ * This is similar to svc_rdma_send_reply_msg, but takes a struct\n+ * rpc_rqst instead, does not support chunks, and avoids blocking\n+ * memory allocation.\n  *\n  * XXX: There is still an opportunity to block in svc_rdma_send()\n  * if there are no SQ entries to post the Send. This may occur if\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\nindex 2eb3df698e11b..ce62b78e5bc92 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n@@ -1,4 +1,5 @@\n \/*\n+ * Copyright (c) 2016 Oracle. All rights reserved.\n  * Copyright (c) 2014 Open Grid Computing, Inc. All rights reserved.\n  * Copyright (c) 2005-2006 Network Appliance, Inc. All rights reserved.\n  *\n@@ -40,6 +41,63 @@\n  * Author: Tom Tucker <tom@opengridcomputing.com>\n  *\/\n \n+\/* Operation\n+ *\n+ * The main entry point is svc_rdma_sendto. This is called by the\n+ * RPC server when an RPC Reply is ready to be transmitted to a client.\n+ *\n+ * The passed-in svc_rqst contains a struct xdr_buf which holds an\n+ * XDR-encoded RPC Reply message. sendto must construct the RPC-over-RDMA\n+ * transport header, post all Write WRs needed for this Reply, then post\n+ * a Send WR conveying the transport header and the RPC message itself to\n+ * the client.\n+ *\n+ * svc_rdma_sendto must fully transmit the Reply before returning, as\n+ * the svc_rqst will be recycled as soon as sendto returns. Remaining\n+ * resources referred to by the svc_rqst are also recycled at that time.\n+ * Therefore any resources that must remain longer must be detached\n+ * from the svc_rqst and released later.\n+ *\n+ * Page Management\n+ *\n+ * The I\/O that performs Reply transmission is asynchronous, and may\n+ * complete well after sendto returns. Thus pages under I\/O must be\n+ * removed from the svc_rqst before sendto returns.\n+ *\n+ * The logic here depends on Send Queue and completion ordering. Since\n+ * the Send WR is always posted last, it will always complete last. Thus\n+ * when it completes, it is guaranteed that all previous Write WRs have\n+ * also completed.\n+ *\n+ * Write WRs are constructed and posted. Each Write segment gets its own\n+ * svc_rdma_rw_ctxt, allowing the Write completion handler to find and\n+ * DMA-unmap the pages under I\/O for that Write segment. The Write\n+ * completion handler does not release any pages.\n+ *\n+ * When the Send WR is constructed, it also gets its own svc_rdma_op_ctxt.\n+ * The ownership of all of the Reply's pages are transferred into that\n+ * ctxt, the Send WR is posted, and sendto returns.\n+ *\n+ * The svc_rdma_op_ctxt is presented when the Send WR completes. The\n+ * Send completion handler finally releases the Reply's pages.\n+ *\n+ * This mechanism also assumes that completions on the transport's Send\n+ * Completion Queue do not run in parallel. Otherwise a Write completion\n+ * and Send completion running at the same time could release pages that\n+ * are still DMA-mapped.\n+ *\n+ * Error Handling\n+ *\n+ * - If the Send WR is posted successfully, it will either complete\n+ *   successfully, or get flushed. Either way, the Send completion\n+ *   handler releases the Reply's pages.\n+ * - If the Send WR cannot be not posted, the forward path releases\n+ *   the Reply's pages.\n+ *\n+ * This handles the case, without the use of page reference counting,\n+ * where two different Write segments send portions of the same page.\n+ *\/\n+\n #include <linux\/sunrpc\/debug.h>\n #include <linux\/sunrpc\/rpc_rdma.h>\n #include <linux\/spinlock.h>\n@@ -55,6 +113,133 @@ static u32 xdr_padsize(u32 len)\n \treturn (len & 3) ? (4 - (len & 3)) : 0;\n }\n \n+\/* Returns length of transport header, in bytes.\n+ *\/\n+static unsigned int svc_rdma_reply_hdr_len(__be32 *rdma_resp)\n+{\n+\tunsigned int nsegs;\n+\t__be32 *p;\n+\n+\tp = rdma_resp;\n+\n+\t\/* RPC-over-RDMA V1 replies never have a Read list. *\/\n+\tp += rpcrdma_fixed_maxsz + 1;\n+\n+\t\/* Skip Write list. *\/\n+\twhile (*p++ != xdr_zero) {\n+\t\tnsegs = be32_to_cpup(p++);\n+\t\tp += nsegs * rpcrdma_segment_maxsz;\n+\t}\n+\n+\t\/* Skip Reply chunk. *\/\n+\tif (*p++ != xdr_zero) {\n+\t\tnsegs = be32_to_cpup(p++);\n+\t\tp += nsegs * rpcrdma_segment_maxsz;\n+\t}\n+\n+\treturn (unsigned long)p - (unsigned long)rdma_resp;\n+}\n+\n+\/* One Write chunk is copied from Call transport header to Reply\n+ * transport header. Each segment's length field is updated to\n+ * reflect number of bytes consumed in the segment.\n+ *\n+ * Returns number of segments in this chunk.\n+ *\/\n+static unsigned int xdr_encode_write_chunk(__be32 *dst, __be32 *src,\n+\t\t\t\t\t   unsigned int remaining)\n+{\n+\tunsigned int i, nsegs;\n+\tu32 seg_len;\n+\n+\t\/* Write list discriminator *\/\n+\t*dst++ = *src++;\n+\n+\t\/* number of segments in this chunk *\/\n+\tnsegs = be32_to_cpup(src);\n+\t*dst++ = *src++;\n+\n+\tfor (i = nsegs; i; i--) {\n+\t\t\/* segment's RDMA handle *\/\n+\t\t*dst++ = *src++;\n+\n+\t\t\/* bytes returned in this segment *\/\n+\t\tseg_len = be32_to_cpu(*src);\n+\t\tif (remaining >= seg_len) {\n+\t\t\t\/* entire segment was consumed *\/\n+\t\t\t*dst = *src;\n+\t\t\tremaining -= seg_len;\n+\t\t} else {\n+\t\t\t\/* segment only partly filled *\/\n+\t\t\t*dst = cpu_to_be32(remaining);\n+\t\t\tremaining = 0;\n+\t\t}\n+\t\tdst++; src++;\n+\n+\t\t\/* segment's RDMA offset *\/\n+\t\t*dst++ = *src++;\n+\t\t*dst++ = *src++;\n+\t}\n+\n+\treturn nsegs;\n+}\n+\n+\/* The client provided a Write list in the Call message. Fill in\n+ * the segments in the first Write chunk in the Reply's transport\n+ * header with the number of bytes consumed in each segment.\n+ * Remaining chunks are returned unused.\n+ *\n+ * Assumptions:\n+ *  - Client has provided only one Write chunk\n+ *\/\n+static void svc_rdma_xdr_encode_write_list(__be32 *rdma_resp, __be32 *wr_ch,\n+\t\t\t\t\t   unsigned int consumed)\n+{\n+\tunsigned int nsegs;\n+\t__be32 *p, *q;\n+\n+\t\/* RPC-over-RDMA V1 replies never have a Read list. *\/\n+\tp = rdma_resp + rpcrdma_fixed_maxsz + 1;\n+\n+\tq = wr_ch;\n+\twhile (*q != xdr_zero) {\n+\t\tnsegs = xdr_encode_write_chunk(p, q, consumed);\n+\t\tq += 2 + nsegs * rpcrdma_segment_maxsz;\n+\t\tp += 2 + nsegs * rpcrdma_segment_maxsz;\n+\t\tconsumed = 0;\n+\t}\n+\n+\t\/* Terminate Write list *\/\n+\t*p++ = xdr_zero;\n+\n+\t\/* Reply chunk discriminator; may be replaced later *\/\n+\t*p = xdr_zero;\n+}\n+\n+\/* The client provided a Reply chunk in the Call message. Fill in\n+ * the segments in the Reply chunk in the Reply message with the\n+ * number of bytes consumed in each segment.\n+ *\n+ * Assumptions:\n+ * - Reply can always fit in the provided Reply chunk\n+ *\/\n+static void svc_rdma_xdr_encode_reply_chunk(__be32 *rdma_resp, __be32 *rp_ch,\n+\t\t\t\t\t    unsigned int consumed)\n+{\n+\t__be32 *p;\n+\n+\t\/* Find the Reply chunk in the Reply's xprt header.\n+\t * RPC-over-RDMA V1 replies never have a Read list.\n+\t *\/\n+\tp = rdma_resp + rpcrdma_fixed_maxsz + 1;\n+\n+\t\/* Skip past Write list *\/\n+\twhile (*p++ != xdr_zero)\n+\t\tp += 1 + be32_to_cpup(p) * rpcrdma_segment_maxsz;\n+\n+\txdr_encode_write_chunk(p, rp_ch, consumed);\n+}\n+\n int svc_rdma_map_xdr(struct svcxprt_rdma *xprt,\n \t\t     struct xdr_buf *xdr,\n \t\t     struct svc_rdma_req_map *vec,\n@@ -123,45 +308,14 @@ int svc_rdma_map_xdr(struct svcxprt_rdma *xprt,\n \treturn 0;\n }\n \n-static dma_addr_t dma_map_xdr(struct svcxprt_rdma *xprt,\n-\t\t\t      struct xdr_buf *xdr,\n-\t\t\t      u32 xdr_off, size_t len, int dir)\n-{\n-\tstruct page *page;\n-\tdma_addr_t dma_addr;\n-\tif (xdr_off < xdr->head[0].iov_len) {\n-\t\t\/* This offset is in the head *\/\n-\t\txdr_off += (unsigned long)xdr->head[0].iov_base & ~PAGE_MASK;\n-\t\tpage = virt_to_page(xdr->head[0].iov_base);\n-\t} else {\n-\t\txdr_off -= xdr->head[0].iov_len;\n-\t\tif (xdr_off < xdr->page_len) {\n-\t\t\t\/* This offset is in the page list *\/\n-\t\t\txdr_off += xdr->page_base;\n-\t\t\tpage = xdr->pages[xdr_off >> PAGE_SHIFT];\n-\t\t\txdr_off &= ~PAGE_MASK;\n-\t\t} else {\n-\t\t\t\/* This offset is in the tail *\/\n-\t\t\txdr_off -= xdr->page_len;\n-\t\t\txdr_off += (unsigned long)\n-\t\t\t\txdr->tail[0].iov_base & ~PAGE_MASK;\n-\t\t\tpage = virt_to_page(xdr->tail[0].iov_base);\n-\t\t}\n-\t}\n-\tdma_addr = ib_dma_map_page(xprt->sc_cm_id->device, page, xdr_off,\n-\t\t\t\t   min_t(size_t, PAGE_SIZE, len), dir);\n-\treturn dma_addr;\n-}\n-\n \/* Parse the RPC Call's transport header.\n  *\/\n-static void svc_rdma_get_write_arrays(struct rpcrdma_msg *rmsgp,\n-\t\t\t\t      struct rpcrdma_write_array **write,\n-\t\t\t\t      struct rpcrdma_write_array **reply)\n+static void svc_rdma_get_write_arrays(__be32 *rdma_argp,\n+\t\t\t\t      __be32 **write, __be32 **reply)\n {\n \t__be32 *p;\n \n-\tp = (__be32 *)&rmsgp->rm_body.rm_chunks[0];\n+\tp = rdma_argp + rpcrdma_fixed_maxsz;\n \n \t\/* Read list *\/\n \twhile (*p++ != xdr_zero)\n@@ -169,7 +323,7 @@ static void svc_rdma_get_write_arrays(struct rpcrdma_msg *rmsgp,\n \n \t\/* Write list *\/\n \tif (*p != xdr_zero) {\n-\t\t*write = (struct rpcrdma_write_array *)p;\n+\t\t*write = p;\n \t\twhile (*p++ != xdr_zero)\n \t\t\tp += 1 + be32_to_cpu(*p) * 4;\n \t} else {\n@@ -179,7 +333,7 @@ static void svc_rdma_get_write_arrays(struct rpcrdma_msg *rmsgp,\n \n \t\/* Reply chunk *\/\n \tif (*p != xdr_zero)\n-\t\t*reply = (struct rpcrdma_write_array *)p;\n+\t\t*reply = p;\n \telse\n \t\t*reply = NULL;\n }\n@@ -210,6 +364,32 @@ static u32 svc_rdma_get_inv_rkey(__be32 *rdma_argp,\n \treturn be32_to_cpup(p);\n }\n \n+\/* ib_dma_map_page() is used here because svc_rdma_dma_unmap()\n+ * is used during completion to DMA-unmap this memory, and\n+ * it uses ib_dma_unmap_page() exclusively.\n+ *\/\n+static int svc_rdma_dma_map_buf(struct svcxprt_rdma *rdma,\n+\t\t\t\tstruct svc_rdma_op_ctxt *ctxt,\n+\t\t\t\tunsigned int sge_no,\n+\t\t\t\tunsigned char *base,\n+\t\t\t\tunsigned int len)\n+{\n+\tunsigned long offset = (unsigned long)base & ~PAGE_MASK;\n+\tstruct ib_device *dev = rdma->sc_cm_id->device;\n+\tdma_addr_t dma_addr;\n+\n+\tdma_addr = ib_dma_map_page(dev, virt_to_page(base),\n+\t\t\t\t   offset, len, DMA_TO_DEVICE);\n+\tif (ib_dma_mapping_error(dev, dma_addr))\n+\t\treturn -EIO;\n+\n+\tctxt->sge[sge_no].addr = dma_addr;\n+\tctxt->sge[sge_no].length = len;\n+\tctxt->sge[sge_no].lkey = rdma->sc_pd->local_dma_lkey;\n+\tsvc_rdma_count_mappings(rdma, ctxt);\n+\treturn 0;\n+}\n+\n static int svc_rdma_dma_map_page(struct svcxprt_rdma *rdma,\n \t\t\t\t struct svc_rdma_op_ctxt *ctxt,\n \t\t\t\t unsigned int sge_no,\n@@ -253,222 +433,73 @@ int svc_rdma_map_reply_hdr(struct svcxprt_rdma *rdma,\n \treturn svc_rdma_dma_map_page(rdma, ctxt, 0, ctxt->pages[0], 0, len);\n }\n \n-\/* Assumptions:\n- * - The specified write_len can be represented in sc_max_sge * PAGE_SIZE\n+\/* Load the xdr_buf into the ctxt's sge array, and DMA map each\n+ * element as it is added.\n+ *\n+ * Returns the number of sge elements loaded on success, or\n+ * a negative errno on failure.\n  *\/\n-static int send_write(struct svcxprt_rdma *xprt, struct svc_rqst *rqstp,\n-\t\t      u32 rmr, u64 to,\n-\t\t      u32 xdr_off, int write_len,\n-\t\t      struct svc_rdma_req_map *vec)\n+static int svc_rdma_map_reply_msg(struct svcxprt_rdma *rdma,\n+\t\t\t\t  struct svc_rdma_op_ctxt *ctxt,\n+\t\t\t\t  struct xdr_buf *xdr, __be32 *wr_lst)\n {\n-\tstruct ib_rdma_wr write_wr;\n-\tstruct ib_sge *sge;\n-\tint xdr_sge_no;\n-\tint sge_no;\n-\tint sge_bytes;\n-\tint sge_off;\n-\tint bc;\n-\tstruct svc_rdma_op_ctxt *ctxt;\n+\tunsigned int len, sge_no, remaining, page_off;\n+\tstruct page **ppages;\n+\tunsigned char *base;\n+\tu32 xdr_pad;\n+\tint ret;\n \n-\tif (vec->count > RPCSVC_MAXPAGES) {\n-\t\tpr_err(\"svcrdma: Too many pages (%lu)\\n\", vec->count);\n-\t\treturn -EIO;\n-\t}\n+\tsge_no = 1;\n \n-\tdprintk(\"svcrdma: RDMA_WRITE rmr=%x, to=%llx, xdr_off=%d, \"\n-\t\t\"write_len=%d, vec->sge=%p, vec->count=%lu\\n\",\n-\t\trmr, (unsigned long long)to, xdr_off,\n-\t\twrite_len, vec->sge, vec->count);\n+\tret = svc_rdma_dma_map_buf(rdma, ctxt, sge_no++,\n+\t\t\t\t   xdr->head[0].iov_base,\n+\t\t\t\t   xdr->head[0].iov_len);\n+\tif (ret < 0)\n+\t\treturn ret;\n \n-\tctxt = svc_rdma_get_context(xprt);\n-\tctxt->direction = DMA_TO_DEVICE;\n-\tsge = ctxt->sge;\n-\n-\t\/* Find the SGE associated with xdr_off *\/\n-\tfor (bc = xdr_off, xdr_sge_no = 1; bc && xdr_sge_no < vec->count;\n-\t     xdr_sge_no++) {\n-\t\tif (vec->sge[xdr_sge_no].iov_len > bc)\n-\t\t\tbreak;\n-\t\tbc -= vec->sge[xdr_sge_no].iov_len;\n-\t}\n+\t\/* If a Write chunk is present, the xdr_buf's page list\n+\t * is not included inline. However the Upper Layer may\n+\t * have added XDR padding in the tail buffer, and that\n+\t * should not be included inline.\n+\t *\/\n+\tif (wr_lst) {\n+\t\tbase = xdr->tail[0].iov_base;\n+\t\tlen = xdr->tail[0].iov_len;\n+\t\txdr_pad = xdr_padsize(xdr->page_len);\n \n-\tsge_off = bc;\n-\tbc = write_len;\n-\tsge_no = 0;\n-\n-\t\/* Copy the remaining SGE *\/\n-\twhile (bc != 0) {\n-\t\tsge_bytes = min_t(size_t,\n-\t\t\t  bc, vec->sge[xdr_sge_no].iov_len-sge_off);\n-\t\tsge[sge_no].length = sge_bytes;\n-\t\tsge[sge_no].addr =\n-\t\t\tdma_map_xdr(xprt, &rqstp->rq_res, xdr_off,\n-\t\t\t\t    sge_bytes, DMA_TO_DEVICE);\n-\t\txdr_off += sge_bytes;\n-\t\tif (ib_dma_mapping_error(xprt->sc_cm_id->device,\n-\t\t\t\t\t sge[sge_no].addr))\n-\t\t\tgoto err;\n-\t\tsvc_rdma_count_mappings(xprt, ctxt);\n-\t\tsge[sge_no].lkey = xprt->sc_pd->local_dma_lkey;\n-\t\tctxt->count++;\n-\t\tsge_off = 0;\n-\t\tsge_no++;\n-\t\txdr_sge_no++;\n-\t\tif (xdr_sge_no > vec->count) {\n-\t\t\tpr_err(\"svcrdma: Too many sges (%d)\\n\", xdr_sge_no);\n-\t\t\tgoto err;\n+\t\tif (len && xdr_pad) {\n+\t\t\tbase += xdr_pad;\n+\t\t\tlen -= xdr_pad;\n \t\t}\n-\t\tbc -= sge_bytes;\n-\t\tif (sge_no == xprt->sc_max_sge)\n-\t\t\tbreak;\n-\t}\n-\n-\t\/* Prepare WRITE WR *\/\n-\tmemset(&write_wr, 0, sizeof write_wr);\n-\tctxt->cqe.done = svc_rdma_wc_write;\n-\twrite_wr.wr.wr_cqe = &ctxt->cqe;\n-\twrite_wr.wr.sg_list = &sge[0];\n-\twrite_wr.wr.num_sge = sge_no;\n-\twrite_wr.wr.opcode = IB_WR_RDMA_WRITE;\n-\twrite_wr.wr.send_flags = IB_SEND_SIGNALED;\n-\twrite_wr.rkey = rmr;\n-\twrite_wr.remote_addr = to;\n-\n-\t\/* Post It *\/\n-\tatomic_inc(&rdma_stat_write);\n-\tif (svc_rdma_send(xprt, &write_wr.wr))\n-\t\tgoto err;\n-\treturn write_len - bc;\n- err:\n-\tsvc_rdma_unmap_dma(ctxt);\n-\tsvc_rdma_put_context(ctxt, 0);\n-\treturn -EIO;\n-}\n \n-noinline\n-static int send_write_chunks(struct svcxprt_rdma *xprt,\n-\t\t\t     struct rpcrdma_write_array *wr_ary,\n-\t\t\t     struct rpcrdma_msg *rdma_resp,\n-\t\t\t     struct svc_rqst *rqstp,\n-\t\t\t     struct svc_rdma_req_map *vec)\n-{\n-\tu32 xfer_len = rqstp->rq_res.page_len;\n-\tint write_len;\n-\tu32 xdr_off;\n-\tint chunk_off;\n-\tint chunk_no;\n-\tint nchunks;\n-\tstruct rpcrdma_write_array *res_ary;\n-\tint ret;\n-\n-\tres_ary = (struct rpcrdma_write_array *)\n-\t\t&rdma_resp->rm_body.rm_chunks[1];\n-\n-\t\/* Write chunks start at the pagelist *\/\n-\tnchunks = be32_to_cpu(wr_ary->wc_nchunks);\n-\tfor (xdr_off = rqstp->rq_res.head[0].iov_len, chunk_no = 0;\n-\t     xfer_len && chunk_no < nchunks;\n-\t     chunk_no++) {\n-\t\tstruct rpcrdma_segment *arg_ch;\n-\t\tu64 rs_offset;\n-\n-\t\targ_ch = &wr_ary->wc_array[chunk_no].wc_target;\n-\t\twrite_len = min(xfer_len, be32_to_cpu(arg_ch->rs_length));\n-\n-\t\t\/* Prepare the response chunk given the length actually\n-\t\t * written *\/\n-\t\txdr_decode_hyper((__be32 *)&arg_ch->rs_offset, &rs_offset);\n-\t\tsvc_rdma_xdr_encode_array_chunk(res_ary, chunk_no,\n-\t\t\t\t\t\targ_ch->rs_handle,\n-\t\t\t\t\t\targ_ch->rs_offset,\n-\t\t\t\t\t\twrite_len);\n-\t\tchunk_off = 0;\n-\t\twhile (write_len) {\n-\t\t\tret = send_write(xprt, rqstp,\n-\t\t\t\t\t be32_to_cpu(arg_ch->rs_handle),\n-\t\t\t\t\t rs_offset + chunk_off,\n-\t\t\t\t\t xdr_off,\n-\t\t\t\t\t write_len,\n-\t\t\t\t\t vec);\n-\t\t\tif (ret <= 0)\n-\t\t\t\tgoto out_err;\n-\t\t\tchunk_off += ret;\n-\t\t\txdr_off += ret;\n-\t\t\txfer_len -= ret;\n-\t\t\twrite_len -= ret;\n-\t\t}\n+\t\tgoto tail;\n \t}\n-\t\/* Update the req with the number of chunks actually used *\/\n-\tsvc_rdma_xdr_encode_write_list(rdma_resp, chunk_no);\n \n-\treturn rqstp->rq_res.page_len;\n+\tppages = xdr->pages + (xdr->page_base >> PAGE_SHIFT);\n+\tpage_off = xdr->page_base & ~PAGE_MASK;\n+\tremaining = xdr->page_len;\n+\twhile (remaining) {\n+\t\tlen = min_t(u32, PAGE_SIZE - page_off, remaining);\n \n-out_err:\n-\tpr_err(\"svcrdma: failed to send write chunks, rc=%d\\n\", ret);\n-\treturn -EIO;\n-}\n-\n-noinline\n-static int send_reply_chunks(struct svcxprt_rdma *xprt,\n-\t\t\t     struct rpcrdma_write_array *rp_ary,\n-\t\t\t     struct rpcrdma_msg *rdma_resp,\n-\t\t\t     struct svc_rqst *rqstp,\n-\t\t\t     struct svc_rdma_req_map *vec)\n-{\n-\tu32 xfer_len = rqstp->rq_res.len;\n-\tint write_len;\n-\tu32 xdr_off;\n-\tint chunk_no;\n-\tint chunk_off;\n-\tint nchunks;\n-\tstruct rpcrdma_segment *ch;\n-\tstruct rpcrdma_write_array *res_ary;\n-\tint ret;\n+\t\tret = svc_rdma_dma_map_page(rdma, ctxt, sge_no++,\n+\t\t\t\t\t    *ppages++, page_off, len);\n+\t\tif (ret < 0)\n+\t\t\treturn ret;\n \n-\t\/* XXX: need to fix when reply lists occur with read-list and or\n-\t * write-list *\/\n-\tres_ary = (struct rpcrdma_write_array *)\n-\t\t&rdma_resp->rm_body.rm_chunks[2];\n-\n-\t\/* xdr offset starts at RPC message *\/\n-\tnchunks = be32_to_cpu(rp_ary->wc_nchunks);\n-\tfor (xdr_off = 0, chunk_no = 0;\n-\t     xfer_len && chunk_no < nchunks;\n-\t     chunk_no++) {\n-\t\tu64 rs_offset;\n-\t\tch = &rp_ary->wc_array[chunk_no].wc_target;\n-\t\twrite_len = min(xfer_len, be32_to_cpu(ch->rs_length));\n-\n-\t\t\/* Prepare the reply chunk given the length actually\n-\t\t * written *\/\n-\t\txdr_decode_hyper((__be32 *)&ch->rs_offset, &rs_offset);\n-\t\tsvc_rdma_xdr_encode_array_chunk(res_ary, chunk_no,\n-\t\t\t\t\t\tch->rs_handle, ch->rs_offset,\n-\t\t\t\t\t\twrite_len);\n-\t\tchunk_off = 0;\n-\t\twhile (write_len) {\n-\t\t\tret = send_write(xprt, rqstp,\n-\t\t\t\t\t be32_to_cpu(ch->rs_handle),\n-\t\t\t\t\t rs_offset + chunk_off,\n-\t\t\t\t\t xdr_off,\n-\t\t\t\t\t write_len,\n-\t\t\t\t\t vec);\n-\t\t\tif (ret <= 0)\n-\t\t\t\tgoto out_err;\n-\t\t\tchunk_off += ret;\n-\t\t\txdr_off += ret;\n-\t\t\txfer_len -= ret;\n-\t\t\twrite_len -= ret;\n-\t\t}\n+\t\tremaining -= len;\n+\t\tpage_off = 0;\n \t}\n-\t\/* Update the req with the number of chunks actually used *\/\n-\tsvc_rdma_xdr_encode_reply_array(res_ary, chunk_no);\n \n-\treturn rqstp->rq_res.len;\n+\tbase = xdr->tail[0].iov_base;\n+\tlen = xdr->tail[0].iov_len;\n+tail:\n+\tif (len) {\n+\t\tret = svc_rdma_dma_map_buf(rdma, ctxt, sge_no++, base, len);\n+\t\tif (ret < 0)\n+\t\t\treturn ret;\n+\t}\n \n-out_err:\n-\tpr_err(\"svcrdma: failed to send reply chunks, rc=%d\\n\", ret);\n-\treturn -EIO;\n+\treturn sge_no - 1;\n }\n \n \/* The svc_rqst and all resources it owns are released as soon as\n@@ -525,90 +556,66 @@ int svc_rdma_post_send_wr(struct svcxprt_rdma *rdma,\n \treturn svc_rdma_send(rdma, send_wr);\n }\n \n-\/* This function prepares the portion of the RPCRDMA message to be\n- * sent in the RDMA_SEND. This function is called after data sent via\n- * RDMA has already been transmitted. There are three cases:\n- * - The RPCRDMA header, RPC header, and payload are all sent in a\n- *   single RDMA_SEND. This is the \"inline\" case.\n- * - The RPCRDMA header and some portion of the RPC header and data\n- *   are sent via this RDMA_SEND and another portion of the data is\n- *   sent via RDMA.\n- * - The RPCRDMA header [NOMSG] is sent in this RDMA_SEND and the RPC\n- *   header and data are all transmitted via RDMA.\n- * In all three cases, this function prepares the RPCRDMA header in\n- * sge[0], the 'type' parameter indicates the type to place in the\n- * RPCRDMA header, and the 'byte_count' field indicates how much of\n- * the XDR to include in this RDMA_SEND. NB: The offset of the payload\n- * to send is zero in the XDR.\n+\/* Prepare the portion of the RPC Reply that will be transmitted\n+ * via RDMA Send. The RPC-over-RDMA transport header is prepared\n+ * in sge[0], and the RPC xdr_buf is prepared in following sges.\n+ *\n+ * Depending on whether a Write list or Reply chunk is present,\n+ * the server may send all, a portion of, or none of the xdr_buf.\n+ * In the latter case, only the transport header (sge[0]) is\n+ * transmitted.\n+ *\n+ * RDMA Send is the last step of transmitting an RPC reply. Pages\n+ * involved in the earlier RDMA Writes are here transferred out\n+ * of the rqstp and into the ctxt's page array. These pages are\n+ * DMA unmapped by each Write completion, but the subsequent Send\n+ * completion finally releases these pages.\n+ *\n+ * Assumptions:\n+ * - The Reply's transport header will never be larger than a page.\n  *\/\n-static int send_reply(struct svcxprt_rdma *rdma,\n-\t\t      struct svc_rqst *rqstp,\n-\t\t      struct page *page,\n-\t\t      struct rpcrdma_msg *rdma_resp,\n-\t\t      struct svc_rdma_req_map *vec,\n-\t\t      int byte_count,\n-\t\t      u32 inv_rkey)\n+static int svc_rdma_send_reply_msg(struct svcxprt_rdma *rdma,\n+\t\t\t\t   __be32 *rdma_argp, __be32 *rdma_resp,\n+\t\t\t\t   struct svc_rqst *rqstp,\n+\t\t\t\t   __be32 *wr_lst, __be32 *rp_ch)\n {\n \tstruct svc_rdma_op_ctxt *ctxt;\n-\tu32 xdr_off;\n-\tint sge_no;\n-\tint sge_bytes;\n-\tint ret = -EIO;\n+\tu32 inv_rkey;\n+\tint ret;\n+\n+\tdprintk(\"svcrdma: sending %s reply: head=%zu, pagelen=%u, tail=%zu\\n\",\n+\t\t(rp_ch ? \"RDMA_NOMSG\" : \"RDMA_MSG\"),\n+\t\trqstp->rq_res.head[0].iov_len,\n+\t\trqstp->rq_res.page_len,\n+\t\trqstp->rq_res.tail[0].iov_len);\n \n-\t\/* Prepare the context *\/\n \tctxt = svc_rdma_get_context(rdma);\n-\tctxt->direction = DMA_TO_DEVICE;\n-\tctxt->pages[0] = page;\n-\tctxt->count = 1;\n \n-\t\/* Prepare the SGE for the RPCRDMA Header *\/\n-\tctxt->sge[0].lkey = rdma->sc_pd->local_dma_lkey;\n-\tctxt->sge[0].length =\n-\t    svc_rdma_xdr_get_reply_hdr_len((__be32 *)rdma_resp);\n-\tctxt->sge[0].addr =\n-\t    ib_dma_map_page(rdma->sc_cm_id->device, page, 0,\n-\t\t\t    ctxt->sge[0].length, DMA_TO_DEVICE);\n-\tif (ib_dma_mapping_error(rdma->sc_cm_id->device, ctxt->sge[0].addr))\n+\tret = svc_rdma_map_reply_hdr(rdma, ctxt, rdma_resp,\n+\t\t\t\t     svc_rdma_reply_hdr_len(rdma_resp));\n+\tif (ret < 0)\n \t\tgoto err;\n-\tsvc_rdma_count_mappings(rdma, ctxt);\n-\n-\tctxt->direction = DMA_TO_DEVICE;\n \n-\t\/* Map the payload indicated by 'byte_count' *\/\n-\txdr_off = 0;\n-\tfor (sge_no = 1; byte_count && sge_no < vec->count; sge_no++) {\n-\t\tsge_bytes = min_t(size_t, vec->sge[sge_no].iov_len, byte_count);\n-\t\tbyte_count -= sge_bytes;\n-\t\tctxt->sge[sge_no].addr =\n-\t\t\tdma_map_xdr(rdma, &rqstp->rq_res, xdr_off,\n-\t\t\t\t    sge_bytes, DMA_TO_DEVICE);\n-\t\txdr_off += sge_bytes;\n-\t\tif (ib_dma_mapping_error(rdma->sc_cm_id->device,\n-\t\t\t\t\t ctxt->sge[sge_no].addr))\n+\tif (!rp_ch) {\n+\t\tret = svc_rdma_map_reply_msg(rdma, ctxt,\n+\t\t\t\t\t     &rqstp->rq_res, wr_lst);\n+\t\tif (ret < 0)\n \t\t\tgoto err;\n-\t\tsvc_rdma_count_mappings(rdma, ctxt);\n-\t\tctxt->sge[sge_no].lkey = rdma->sc_pd->local_dma_lkey;\n-\t\tctxt->sge[sge_no].length = sge_bytes;\n-\t}\n-\tif (byte_count != 0) {\n-\t\tpr_err(\"svcrdma: Could not map %d bytes\\n\", byte_count);\n-\t\tgoto err;\n \t}\n \n \tsvc_rdma_save_io_pages(rqstp, ctxt);\n \n-\tif (sge_no > rdma->sc_max_sge) {\n-\t\tpr_err(\"svcrdma: Too many sges (%d)\\n\", sge_no);\n-\t\tgoto err;\n-\t}\n-\n-\tret = svc_rdma_post_send_wr(rdma, ctxt, sge_no, inv_rkey);\n+\tinv_rkey = 0;\n+\tif (rdma->sc_snd_w_inv)\n+\t\tinv_rkey = svc_rdma_get_inv_rkey(rdma_argp, wr_lst, rp_ch);\n+\tret = svc_rdma_post_send_wr(rdma, ctxt, 1 + ret, inv_rkey);\n \tif (ret)\n \t\tgoto err;\n \n \treturn 0;\n \n- err:\n+err:\n+\tpr_err(\"svcrdma: failed to post Send WR (%d)\\n\", ret);\n \tsvc_rdma_unmap_dma(ctxt);\n \tsvc_rdma_put_context(ctxt, 1);\n \treturn ret;\n@@ -618,41 +625,36 @@ void svc_rdma_prep_reply_hdr(struct svc_rqst *rqstp)\n {\n }\n \n+\/**\n+ * svc_rdma_sendto - Transmit an RPC reply\n+ * @rqstp: processed RPC request, reply XDR already in ::rq_res\n+ *\n+ * Any resources still associated with @rqstp are released upon return.\n+ * If no reply message was possible, the connection is closed.\n+ *\n+ * Returns:\n+ *\t%0 if an RPC reply has been successfully posted,\n+ *\t%-ENOMEM if a resource shortage occurred (connection is lost),\n+ *\t%-ENOTCONN if posting failed (connection is lost).\n+ *\/\n int svc_rdma_sendto(struct svc_rqst *rqstp)\n {\n \tstruct svc_xprt *xprt = rqstp->rq_xprt;\n \tstruct svcxprt_rdma *rdma =\n \t\tcontainer_of(xprt, struct svcxprt_rdma, sc_xprt);\n-\tstruct rpcrdma_msg *rdma_argp;\n-\tstruct rpcrdma_msg *rdma_resp;\n-\tstruct rpcrdma_write_array *wr_ary, *rp_ary;\n-\tint ret;\n-\tint inline_bytes;\n+\t__be32 *p, *rdma_argp, *rdma_resp, *wr_lst, *rp_ch;\n+\tstruct xdr_buf *xdr = &rqstp->rq_res;\n \tstruct page *res_page;\n-\tstruct svc_rdma_req_map *vec;\n-\tu32 inv_rkey;\n-\t__be32 *p;\n-\n-\tdprintk(\"svcrdma: sending response for rqstp=%p\\n\", rqstp);\n+\tint ret;\n \n-\t\/* Get the RDMA request header. The receive logic always\n-\t * places this at the start of page 0.\n+\t\/* Find the call's chunk lists to decide how to send the reply.\n+\t * Receive places the Call's xprt header at the start of page 0.\n \t *\/\n \trdma_argp = page_address(rqstp->rq_pages[0]);\n-\tsvc_rdma_get_write_arrays(rdma_argp, &wr_ary, &rp_ary);\n+\tsvc_rdma_get_write_arrays(rdma_argp, &wr_lst, &rp_ch);\n \n-\tinv_rkey = 0;\n-\tif (rdma->sc_snd_w_inv)\n-\t\tinv_rkey = svc_rdma_get_inv_rkey(&rdma_argp->rm_xid,\n-\t\t\t\t\t\t (__be32 *)wr_ary,\n-\t\t\t\t\t\t (__be32 *)rp_ary);\n-\n-\t\/* Build an req vec for the XDR *\/\n-\tvec = svc_rdma_get_req_map(rdma);\n-\tret = svc_rdma_map_xdr(rdma, &rqstp->rq_res, vec, wr_ary != NULL);\n-\tif (ret)\n-\t\tgoto err0;\n-\tinline_bytes = rqstp->rq_res.len;\n+\tdprintk(\"svcrdma: preparing response for XID 0x%08x\\n\",\n+\t\tbe32_to_cpup(rdma_argp));\n \n \t\/* Create the RDMA response header. xprt->xpt_mutex,\n \t * acquired in svc_send(), serializes RPC replies. The\n@@ -666,54 +668,46 @@ int svc_rdma_sendto(struct svc_rqst *rqstp)\n \t\tgoto err0;\n \trdma_resp = page_address(res_page);\n \n-\tp = &rdma_resp->rm_xid;\n-\t*p++ = rdma_argp->rm_xid;\n-\t*p++ = rdma_argp->rm_vers;\n+\tp = rdma_resp;\n+\t*p++ = *rdma_argp;\n+\t*p++ = *(rdma_argp + 1);\n \t*p++ = rdma->sc_fc_credits;\n-\t*p++ = rp_ary ? rdma_nomsg : rdma_msg;\n+\t*p++ = rp_ch ? rdma_nomsg : rdma_msg;\n \n \t\/* Start with empty chunks *\/\n \t*p++ = xdr_zero;\n \t*p++ = xdr_zero;\n \t*p   = xdr_zero;\n \n-\t\/* Send any write-chunk data and build resp write-list *\/\n-\tif (wr_ary) {\n-\t\tret = send_write_chunks(rdma, wr_ary, rdma_resp, rqstp, vec);\n+\tif (wr_lst) {\n+\t\t\/* XXX: Presume the client sent only one Write chunk *\/\n+\t\tret = svc_rdma_send_write_chunk(rdma, wr_lst, xdr);\n \t\tif (ret < 0)\n \t\t\tgoto err1;\n-\t\tinline_bytes -= ret + xdr_padsize(ret);\n+\t\tsvc_rdma_xdr_encode_write_list(rdma_resp, wr_lst, ret);\n \t}\n-\n-\t\/* Send any reply-list data and update resp reply-list *\/\n-\tif (rp_ary) {\n-\t\tret = send_reply_chunks(rdma, rp_ary, rdma_resp, rqstp, vec);\n+\tif (rp_ch) {\n+\t\tret = svc_rdma_send_reply_chunk(rdma, rp_ch, wr_lst, xdr);\n \t\tif (ret < 0)\n \t\t\tgoto err1;\n-\t\tinline_bytes -= ret;\n+\t\tsvc_rdma_xdr_encode_reply_chunk(rdma_resp, rp_ch, ret);\n \t}\n \n-\t\/* Post a fresh Receive buffer _before_ sending the reply *\/\n \tret = svc_rdma_post_recv(rdma, GFP_KERNEL);\n \tif (ret)\n \t\tgoto err1;\n-\n-\tret = send_reply(rdma, rqstp, res_page, rdma_resp, vec,\n-\t\t\t inline_bytes, inv_rkey);\n+\tret = svc_rdma_send_reply_msg(rdma, rdma_argp, rdma_resp, rqstp,\n+\t\t\t\t      wr_lst, rp_ch);\n \tif (ret < 0)\n \t\tgoto err0;\n-\n-\tsvc_rdma_put_req_map(rdma, vec);\n-\tdprintk(\"svcrdma: send_reply returns %d\\n\", ret);\n-\treturn ret;\n+\treturn 0;\n \n  err1:\n \tput_page(res_page);\n  err0:\n-\tsvc_rdma_put_req_map(rdma, vec);\n \tpr_err(\"svcrdma: Could not send reply, err=%d. Closing transport.\\n\",\n \t       ret);\n-\tset_bit(XPT_CLOSE, &rdma->sc_xprt.xpt_flags);\n+\tset_bit(XPT_CLOSE, &xprt->xpt_flags);\n \treturn -ENOTCONN;\n }\n \ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\nindex b25c50992a95c..237c377c1e06b 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\n@@ -1053,6 +1053,8 @@ static struct svc_xprt *svc_rdma_accept(struct svc_xprt *xprt)\n \tmemset(&qp_attr, 0, sizeof qp_attr);\n \tqp_attr.event_handler = qp_event_handler;\n \tqp_attr.qp_context = &newxprt->sc_xprt;\n+\tqp_attr.port_num = newxprt->sc_cm_id->port_num;\n+\tqp_attr.cap.max_rdma_ctxs = newxprt->sc_max_requests;\n \tqp_attr.cap.max_send_wr = newxprt->sc_sq_depth;\n \tqp_attr.cap.max_recv_wr = newxprt->sc_rq_depth;\n \tqp_attr.cap.max_send_sge = newxprt->sc_max_sge;\n\ndiff --git a\/include\/linux\/sunrpc\/rpc_rdma.h b\/include\/linux\/sunrpc\/rpc_rdma.h\nindex 245fc59b73247..b7e85b341a54f 100644\n--- a\/include\/linux\/sunrpc\/rpc_rdma.h\n+++ b\/include\/linux\/sunrpc\/rpc_rdma.h\n@@ -143,6 +143,9 @@ enum rpcrdma_proc {\n #define rdma_done\tcpu_to_be32(RDMA_DONE)\n #define rdma_error\tcpu_to_be32(RDMA_ERROR)\n \n+#define err_vers\tcpu_to_be32(ERR_VERS)\n+#define err_chunk\tcpu_to_be32(ERR_CHUNK)\n+\n \/*\n  * Private extension to RPC-over-RDMA Version One.\n  * Message passed during RDMA-CM connection set-up.\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex 599ee03ee3fb1..a770d200f6076 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -209,9 +209,6 @@ extern int svc_rdma_handle_bc_reply(struct rpc_xprt *xprt,\n \n \/* svc_rdma_marshal.c *\/\n extern int svc_rdma_xdr_decode_req(struct xdr_buf *);\n-extern int svc_rdma_xdr_encode_error(struct svcxprt_rdma *,\n-\t\t\t\t     struct rpcrdma_msg *,\n-\t\t\t\t     enum rpcrdma_errcode, __be32 *);\n extern void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *, int);\n extern void svc_rdma_xdr_encode_array_chunk(struct rpcrdma_write_array *, int,\n \t\t\t\t\t    __be32, __be64, u32);\n@@ -244,8 +241,6 @@ extern int svc_rdma_post_send_wr(struct svcxprt_rdma *rdma,\n \t\t\t\t struct svc_rdma_op_ctxt *ctxt,\n \t\t\t\t int num_sge, u32 inv_rkey);\n extern int svc_rdma_sendto(struct svc_rqst *);\n-extern void svc_rdma_send_error(struct svcxprt_rdma *, struct rpcrdma_msg *,\n-\t\t\t\tint);\n \n \/* svc_rdma_transport.c *\/\n extern void svc_rdma_wc_send(struct ib_cq *, struct ib_wc *);\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_marshal.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_marshal.c\nindex 1c4aabf0f6577..ae58a897eca01 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_marshal.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_marshal.c\n@@ -167,25 +167,6 @@ int svc_rdma_xdr_decode_req(struct xdr_buf *rq_arg)\n \treturn -EINVAL;\n }\n \n-int svc_rdma_xdr_encode_error(struct svcxprt_rdma *xprt,\n-\t\t\t      struct rpcrdma_msg *rmsgp,\n-\t\t\t      enum rpcrdma_errcode err, __be32 *va)\n-{\n-\t__be32 *startp = va;\n-\n-\t*va++ = rmsgp->rm_xid;\n-\t*va++ = rmsgp->rm_vers;\n-\t*va++ = xprt->sc_fc_credits;\n-\t*va++ = rdma_error;\n-\t*va++ = cpu_to_be32(err);\n-\tif (err == ERR_VERS) {\n-\t\t*va++ = rpcrdma_version;\n-\t\t*va++ = rpcrdma_version;\n-\t}\n-\n-\treturn (int)((unsigned long)va - (unsigned long)startp);\n-}\n-\n \/**\n  * svc_rdma_xdr_get_reply_hdr_length - Get length of Reply transport header\n  * @rdma_resp: buffer containing Reply transport header\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_recvfrom.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_recvfrom.c\nindex f7b2daf72a865..7435cb666f424 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_recvfrom.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_recvfrom.c\n@@ -558,6 +558,56 @@ static void rdma_read_complete(struct svc_rqst *rqstp,\n \trqstp->rq_arg.buflen = head->arg.buflen;\n }\n \n+static void svc_rdma_send_error(struct svcxprt_rdma *xprt,\n+\t\t\t\t__be32 *rdma_argp, int status)\n+{\n+\tstruct svc_rdma_op_ctxt *ctxt;\n+\t__be32 *p, *err_msgp;\n+\tunsigned int length;\n+\tstruct page *page;\n+\tint ret;\n+\n+\tret = svc_rdma_repost_recv(xprt, GFP_KERNEL);\n+\tif (ret)\n+\t\treturn;\n+\n+\tpage = alloc_page(GFP_KERNEL);\n+\tif (!page)\n+\t\treturn;\n+\terr_msgp = page_address(page);\n+\n+\tp = err_msgp;\n+\t*p++ = *rdma_argp;\n+\t*p++ = *(rdma_argp + 1);\n+\t*p++ = xprt->sc_fc_credits;\n+\t*p++ = rdma_error;\n+\tif (status == -EPROTONOSUPPORT) {\n+\t\t*p++ = err_vers;\n+\t\t*p++ = rpcrdma_version;\n+\t\t*p++ = rpcrdma_version;\n+\t} else {\n+\t\t*p++ = err_chunk;\n+\t}\n+\tlength = (unsigned long)p - (unsigned long)err_msgp;\n+\n+\t\/* Map transport header; no RPC message payload *\/\n+\tctxt = svc_rdma_get_context(xprt);\n+\tret = svc_rdma_map_reply_hdr(xprt, ctxt, err_msgp, length);\n+\tif (ret) {\n+\t\tdprintk(\"svcrdma: Error %d mapping send for protocol error\\n\",\n+\t\t\tret);\n+\t\treturn;\n+\t}\n+\n+\tret = svc_rdma_post_send_wr(xprt, ctxt, 1, 0);\n+\tif (ret) {\n+\t\tdprintk(\"svcrdma: Error %d posting send for protocol error\\n\",\n+\t\t\tret);\n+\t\tsvc_rdma_unmap_dma(ctxt);\n+\t\tsvc_rdma_put_context(ctxt, 1);\n+\t}\n+}\n+\n \/* By convention, backchannel calls arrive via rdma_msg type\n  * messages, and never populate the chunk lists. This makes\n  * the RPC\/RDMA header small and fixed in size, so it is\n@@ -686,7 +736,7 @@ int svc_rdma_recvfrom(struct svc_rqst *rqstp)\n \treturn ret;\n \n out_err:\n-\tsvc_rdma_send_error(rdma_xprt, rmsgp, ret);\n+\tsvc_rdma_send_error(rdma_xprt, &rmsgp->rm_xid, ret);\n \tsvc_rdma_put_context(ctxt, 0);\n \treturn 0;\n \ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\nindex ce62b78e5bc92..0b646e8f23c7f 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n@@ -710,46 +710,3 @@ int svc_rdma_sendto(struct svc_rqst *rqstp)\n \tset_bit(XPT_CLOSE, &xprt->xpt_flags);\n \treturn -ENOTCONN;\n }\n-\n-void svc_rdma_send_error(struct svcxprt_rdma *xprt, struct rpcrdma_msg *rmsgp,\n-\t\t\t int status)\n-{\n-\tstruct page *p;\n-\tstruct svc_rdma_op_ctxt *ctxt;\n-\tenum rpcrdma_errcode err;\n-\t__be32 *va;\n-\tint length;\n-\tint ret;\n-\n-\tret = svc_rdma_repost_recv(xprt, GFP_KERNEL);\n-\tif (ret)\n-\t\treturn;\n-\n-\tp = alloc_page(GFP_KERNEL);\n-\tif (!p)\n-\t\treturn;\n-\tva = page_address(p);\n-\n-\t\/* XDR encode an error reply *\/\n-\terr = ERR_CHUNK;\n-\tif (status == -EPROTONOSUPPORT)\n-\t\terr = ERR_VERS;\n-\tlength = svc_rdma_xdr_encode_error(xprt, rmsgp, err, va);\n-\n-\t\/* Map transport header; no RPC message payload *\/\n-\tctxt = svc_rdma_get_context(xprt);\n-\tret = svc_rdma_map_reply_hdr(xprt, ctxt, &rmsgp->rm_xid, length);\n-\tif (ret) {\n-\t\tdprintk(\"svcrdma: Error %d mapping send for protocol error\\n\",\n-\t\t\tret);\n-\t\treturn;\n-\t}\n-\n-\tret = svc_rdma_post_send_wr(xprt, ctxt, 1, 0);\n-\tif (ret) {\n-\t\tdprintk(\"svcrdma: Error %d posting send for protocol error\\n\",\n-\t\t\tret);\n-\t\tsvc_rdma_unmap_dma(ctxt);\n-\t\tsvc_rdma_put_context(ctxt, 1);\n-\t}\n-}\n\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\nindex 0b646e8f23c7f..e514f6864a939 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n@@ -621,6 +621,48 @@ static int svc_rdma_send_reply_msg(struct svcxprt_rdma *rdma,\n \treturn ret;\n }\n \n+\/* Given the client-provided Write and Reply chunks, the server was not\n+ * able to form a complete reply. Return an RDMA_ERROR message so the\n+ * client can retire this RPC transaction. As above, the Send completion\n+ * routine releases payload pages that were part of a previous RDMA Write.\n+ *\n+ * Remote Invalidation is skipped for simplicity.\n+ *\/\n+static int svc_rdma_send_error_msg(struct svcxprt_rdma *rdma,\n+\t\t\t\t   __be32 *rdma_resp, struct svc_rqst *rqstp)\n+{\n+\tstruct svc_rdma_op_ctxt *ctxt;\n+\t__be32 *p;\n+\tint ret;\n+\n+\tctxt = svc_rdma_get_context(rdma);\n+\n+\t\/* Replace the original transport header with an\n+\t * RDMA_ERROR response. XID etc are preserved.\n+\t *\/\n+\tp = rdma_resp + 3;\n+\t*p++ = rdma_error;\n+\t*p   = err_chunk;\n+\n+\tret = svc_rdma_map_reply_hdr(rdma, ctxt, rdma_resp, 20);\n+\tif (ret < 0)\n+\t\tgoto err;\n+\n+\tsvc_rdma_save_io_pages(rqstp, ctxt);\n+\n+\tret = svc_rdma_post_send_wr(rdma, ctxt, 1 + ret, 0);\n+\tif (ret)\n+\t\tgoto err;\n+\n+\treturn 0;\n+\n+err:\n+\tpr_err(\"svcrdma: failed to post Send WR (%d)\\n\", ret);\n+\tsvc_rdma_unmap_dma(ctxt);\n+\tsvc_rdma_put_context(ctxt, 1);\n+\treturn ret;\n+}\n+\n void svc_rdma_prep_reply_hdr(struct svc_rqst *rqstp)\n {\n }\n@@ -683,13 +725,13 @@ int svc_rdma_sendto(struct svc_rqst *rqstp)\n \t\t\/* XXX: Presume the client sent only one Write chunk *\/\n \t\tret = svc_rdma_send_write_chunk(rdma, wr_lst, xdr);\n \t\tif (ret < 0)\n-\t\t\tgoto err1;\n+\t\t\tgoto err2;\n \t\tsvc_rdma_xdr_encode_write_list(rdma_resp, wr_lst, ret);\n \t}\n \tif (rp_ch) {\n \t\tret = svc_rdma_send_reply_chunk(rdma, rp_ch, wr_lst, xdr);\n \t\tif (ret < 0)\n-\t\t\tgoto err1;\n+\t\t\tgoto err2;\n \t\tsvc_rdma_xdr_encode_reply_chunk(rdma_resp, rp_ch, ret);\n \t}\n \n@@ -702,6 +744,18 @@ int svc_rdma_sendto(struct svc_rqst *rqstp)\n \t\tgoto err0;\n \treturn 0;\n \n+ err2:\n+\tif (ret != -E2BIG)\n+\t\tgoto err1;\n+\n+\tret = svc_rdma_post_recv(rdma, GFP_KERNEL);\n+\tif (ret)\n+\t\tgoto err1;\n+\tret = svc_rdma_send_error_msg(rdma, rdma_resp, rqstp);\n+\tif (ret < 0)\n+\t\tgoto err0;\n+\treturn 0;\n+\n  err1:\n \tput_page(res_page);\n  err0:\n\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex a770d200f6076..44d642bbfce68 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -204,7 +204,7 @@ static inline void svc_rdma_count_mappings(struct svcxprt_rdma *rdma,\n \n \/* svc_rdma_backchannel.c *\/\n extern int svc_rdma_handle_bc_reply(struct rpc_xprt *xprt,\n-\t\t\t\t    struct rpcrdma_msg *rmsgp,\n+\t\t\t\t    __be32 *rdma_resp,\n \t\t\t\t    struct xdr_buf *rcvbuf);\n \n \/* svc_rdma_marshal.c *\/\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\nindex bf185b79c98fb..c676ed0efb5af 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_backchannel.c\n@@ -12,7 +12,17 @@\n \n #undef SVCRDMA_BACKCHANNEL_DEBUG\n \n-int svc_rdma_handle_bc_reply(struct rpc_xprt *xprt, struct rpcrdma_msg *rmsgp,\n+\/**\n+ * svc_rdma_handle_bc_reply - Process incoming backchannel reply\n+ * @xprt: controlling backchannel transport\n+ * @rdma_resp: pointer to incoming transport header\n+ * @rcvbuf: XDR buffer into which to decode the reply\n+ *\n+ * Returns:\n+ *\t%0 if @rcvbuf is filled in, xprt_complete_rqst called,\n+ *\t%-EAGAIN if server should call ->recvfrom again.\n+ *\/\n+int svc_rdma_handle_bc_reply(struct rpc_xprt *xprt, __be32 *rdma_resp,\n \t\t\t     struct xdr_buf *rcvbuf)\n {\n \tstruct rpcrdma_xprt *r_xprt = rpcx_to_rdmax(xprt);\n@@ -27,13 +37,13 @@ int svc_rdma_handle_bc_reply(struct rpc_xprt *xprt, struct rpcrdma_msg *rmsgp,\n \n \tp = (__be32 *)src->iov_base;\n \tlen = src->iov_len;\n-\txid = rmsgp->rm_xid;\n+\txid = *rdma_resp;\n \n #ifdef SVCRDMA_BACKCHANNEL_DEBUG\n \tpr_info(\"%s: xid=%08x, length=%zu\\n\",\n \t\t__func__, be32_to_cpu(xid), len);\n \tpr_info(\"%s: RPC\/RDMA: %*ph\\n\",\n-\t\t__func__, (int)RPCRDMA_HDRLEN_MIN, rmsgp);\n+\t\t__func__, (int)RPCRDMA_HDRLEN_MIN, rdma_resp);\n \tpr_info(\"%s:      RPC: %*ph\\n\",\n \t\t__func__, (int)len, p);\n #endif\n@@ -53,7 +63,7 @@ int svc_rdma_handle_bc_reply(struct rpc_xprt *xprt, struct rpcrdma_msg *rmsgp,\n \t\tgoto out_unlock;\n \tmemcpy(dst->iov_base, p, len);\n \n-\tcredits = be32_to_cpu(rmsgp->rm_credit);\n+\tcredits = be32_to_cpup(rdma_resp + 2);\n \tif (credits == 0)\n \t\tcredits = 1;\t\/* don't deadlock *\/\n \telse if (credits > r_xprt->rx_buf.rb_bc_max_requests)\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_recvfrom.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_recvfrom.c\nindex 7435cb666f424..27a99bf5b1a6f 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_recvfrom.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_recvfrom.c\n@@ -613,28 +613,30 @@ static void svc_rdma_send_error(struct svcxprt_rdma *xprt,\n  * the RPC\/RDMA header small and fixed in size, so it is\n  * straightforward to check the RPC header's direction field.\n  *\/\n-static bool\n-svc_rdma_is_backchannel_reply(struct svc_xprt *xprt, struct rpcrdma_msg *rmsgp)\n+static bool svc_rdma_is_backchannel_reply(struct svc_xprt *xprt,\n+\t\t\t\t\t  __be32 *rdma_resp)\n {\n-\t__be32 *p = (__be32 *)rmsgp;\n+\t__be32 *p;\n \n \tif (!xprt->xpt_bc_xprt)\n \t\treturn false;\n \n-\tif (rmsgp->rm_type != rdma_msg)\n+\tp = rdma_resp + 3;\n+\tif (*p++ != rdma_msg)\n \t\treturn false;\n-\tif (rmsgp->rm_body.rm_chunks[0] != xdr_zero)\n+\n+\tif (*p++ != xdr_zero)\n \t\treturn false;\n-\tif (rmsgp->rm_body.rm_chunks[1] != xdr_zero)\n+\tif (*p++ != xdr_zero)\n \t\treturn false;\n-\tif (rmsgp->rm_body.rm_chunks[2] != xdr_zero)\n+\tif (*p++ != xdr_zero)\n \t\treturn false;\n \n-\t\/* sanity *\/\n-\tif (p[7] != rmsgp->rm_xid)\n+\t\/* XID sanity *\/\n+\tif (*p++ != *rdma_resp)\n \t\treturn false;\n \t\/* call direction *\/\n-\tif (p[8] == cpu_to_be32(RPC_CALL))\n+\tif (*p == cpu_to_be32(RPC_CALL))\n \t\treturn false;\n \n \treturn true;\n@@ -700,8 +702,9 @@ int svc_rdma_recvfrom(struct svc_rqst *rqstp)\n \t\tgoto out_drop;\n \trqstp->rq_xprt_hlen = ret;\n \n-\tif (svc_rdma_is_backchannel_reply(xprt, rmsgp)) {\n-\t\tret = svc_rdma_handle_bc_reply(xprt->xpt_bc_xprt, rmsgp,\n+\tif (svc_rdma_is_backchannel_reply(xprt, &rmsgp->rm_xid)) {\n+\t\tret = svc_rdma_handle_bc_reply(xprt->xpt_bc_xprt,\n+\t\t\t\t\t       &rmsgp->rm_xid,\n \t\t\t\t\t       &rqstp->rq_arg);\n \t\tsvc_rdma_put_context(ctxt, 0);\n \t\tif (ret)\n\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex 44d642bbfce68..e84b775567847 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -48,6 +48,12 @@\n #include <rdma\/rdma_cm.h>\n #define SVCRDMA_DEBUG\n \n+\/* Default and maximum inline threshold sizes *\/\n+enum {\n+\tRPCRDMA_DEF_INLINE_THRESH = 4096,\n+\tRPCRDMA_MAX_INLINE_THRESH = 65536\n+};\n+\n \/* RPC\/RDMA parameters and stats *\/\n extern unsigned int svcrdma_ord;\n extern unsigned int svcrdma_max_requests;\n@@ -86,7 +92,7 @@ struct svc_rdma_op_ctxt {\n \tint count;\n \tunsigned int mapped_sges;\n \tstruct ib_send_wr send_wr;\n-\tstruct ib_sge sge[RPCSVC_MAXPAGES];\n+\tstruct ib_sge sge[1 + RPCRDMA_MAX_INLINE_THRESH \/ PAGE_SIZE];\n \tstruct page *pages[RPCSVC_MAXPAGES];\n };\n \n@@ -186,7 +192,6 @@ struct svcxprt_rdma {\n  * page size of 4k, or 32k * 2 ops \/ 4k = 16 outstanding RDMA_READ.  *\/\n #define RPCRDMA_ORD             (64\/4)\n #define RPCRDMA_MAX_REQUESTS    32\n-#define RPCRDMA_MAX_REQ_SIZE    4096\n \n \/* Typical ULP usage of BC requests is NFSv4.1 backchannel. Our\n  * current NFSv4.1 implementation supports one backchannel slot.\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma.c b\/net\/sunrpc\/xprtrdma\/svc_rdma.c\nindex 9124441746470..a4a8f6989ee74 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma.c\n@@ -58,9 +58,9 @@ unsigned int svcrdma_max_requests = RPCRDMA_MAX_REQUESTS;\n unsigned int svcrdma_max_bc_requests = RPCRDMA_MAX_BC_REQUESTS;\n static unsigned int min_max_requests = 4;\n static unsigned int max_max_requests = 16384;\n-unsigned int svcrdma_max_req_size = RPCRDMA_MAX_REQ_SIZE;\n-static unsigned int min_max_inline = 4096;\n-static unsigned int max_max_inline = 65536;\n+unsigned int svcrdma_max_req_size = RPCRDMA_DEF_INLINE_THRESH;\n+static unsigned int min_max_inline = RPCRDMA_DEF_INLINE_THRESH;\n+static unsigned int max_max_inline = RPCRDMA_MAX_INLINE_THRESH;\n \n atomic_t rdma_stat_recv;\n atomic_t rdma_stat_read;\n\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex e84b775567847..f58c5349beb7d 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -249,7 +249,6 @@ extern int svc_rdma_sendto(struct svc_rqst *);\n \n \/* svc_rdma_transport.c *\/\n extern void svc_rdma_wc_send(struct ib_cq *, struct ib_wc *);\n-extern void svc_rdma_wc_write(struct ib_cq *, struct ib_wc *);\n extern void svc_rdma_wc_reg(struct ib_cq *, struct ib_wc *);\n extern void svc_rdma_wc_read(struct ib_cq *, struct ib_wc *);\n extern void svc_rdma_wc_inv(struct ib_cq *, struct ib_wc *);\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\nindex 237c377c1e06b..1597ca8ba3c08 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\n@@ -473,24 +473,6 @@ void svc_rdma_wc_send(struct ib_cq *cq, struct ib_wc *wc)\n \tsvc_rdma_put_context(ctxt, 1);\n }\n \n-\/**\n- * svc_rdma_wc_write - Invoked by RDMA provider for each polled Write WC\n- * @cq:        completion queue\n- * @wc:        completed WR\n- *\n- *\/\n-void svc_rdma_wc_write(struct ib_cq *cq, struct ib_wc *wc)\n-{\n-\tstruct ib_cqe *cqe = wc->wr_cqe;\n-\tstruct svc_rdma_op_ctxt *ctxt;\n-\n-\tsvc_rdma_send_wc_common_put(cq, wc, \"write\");\n-\n-\tctxt = container_of(cqe, struct svc_rdma_op_ctxt, cqe);\n-\tsvc_rdma_unmap_dma(ctxt);\n-\tsvc_rdma_put_context(ctxt, 0);\n-}\n-\n \/**\n  * svc_rdma_wc_reg - Invoked by RDMA provider for each polled FASTREG WC\n  * @cq:        completion queue\n\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex f58c5349beb7d..479bb7f652330 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -96,23 +96,6 @@ struct svc_rdma_op_ctxt {\n \tstruct page *pages[RPCSVC_MAXPAGES];\n };\n \n-\/*\n- * NFS_ requests are mapped on the client side by the chunk lists in\n- * the RPCRDMA header. During the fetching of the RPC from the client\n- * and the writing of the reply to the client, the memory in the\n- * client and the memory in the server must be mapped as contiguous\n- * vaddr\/len for access by the hardware. These data strucures keep\n- * these mappings.\n- *\n- * For an RDMA_WRITE, the 'sge' maps the RPC REPLY. For RDMA_READ, the\n- * 'sge' in the svc_rdma_req_map maps the server side RPC reply and the\n- * 'ch' field maps the read-list of the RPCRDMA header to the 'sge'\n- * mapping of the reply.\n- *\/\n-struct svc_rdma_chunk_sge {\n-\tint start;\t\t\/* sge no for this chunk *\/\n-\tint count;\t\t\/* sge count for this chunk *\/\n-};\n struct svc_rdma_fastreg_mr {\n \tstruct ib_mr *mr;\n \tstruct scatterlist *sg;\n@@ -121,15 +104,7 @@ struct svc_rdma_fastreg_mr {\n \tenum dma_data_direction direction;\n \tstruct list_head frmr_list;\n };\n-struct svc_rdma_req_map {\n-\tstruct list_head free;\n-\tunsigned long count;\n-\tunion {\n-\t\tstruct kvec sge[RPCSVC_MAXPAGES];\n-\t\tstruct svc_rdma_chunk_sge ch[RPCSVC_MAXPAGES];\n-\t\tunsigned long lkey[RPCSVC_MAXPAGES];\n-\t};\n-};\n+\n #define RDMACTXT_F_LAST_CTXT\t2\n \n #define\tSVCRDMA_DEVCAP_FAST_REG\t\t1\t\/* fast mr registration *\/\n@@ -160,8 +135,6 @@ struct svcxprt_rdma {\n \tint\t\t     sc_ctxt_used;\n \tspinlock_t\t     sc_rw_ctxt_lock;\n \tstruct list_head     sc_rw_ctxts;\n-\tspinlock_t\t     sc_map_lock;\n-\tstruct list_head     sc_maps;\n \n \tstruct list_head     sc_rq_dto_q;\n \tspinlock_t\t     sc_rq_dto_lock;\n@@ -237,8 +210,6 @@ extern int svc_rdma_send_reply_chunk(struct svcxprt_rdma *rdma,\n \t\t\t\t     struct xdr_buf *xdr);\n \n \/* svc_rdma_sendto.c *\/\n-extern int svc_rdma_map_xdr(struct svcxprt_rdma *, struct xdr_buf *,\n-\t\t\t    struct svc_rdma_req_map *, bool);\n extern int svc_rdma_map_reply_hdr(struct svcxprt_rdma *rdma,\n \t\t\t\t  struct svc_rdma_op_ctxt *ctxt,\n \t\t\t\t  __be32 *rdma_resp, unsigned int len);\n@@ -259,9 +230,6 @@ extern int svc_rdma_create_listen(struct svc_serv *, int, struct sockaddr *);\n extern struct svc_rdma_op_ctxt *svc_rdma_get_context(struct svcxprt_rdma *);\n extern void svc_rdma_put_context(struct svc_rdma_op_ctxt *, int);\n extern void svc_rdma_unmap_dma(struct svc_rdma_op_ctxt *ctxt);\n-extern struct svc_rdma_req_map *svc_rdma_get_req_map(struct svcxprt_rdma *);\n-extern void svc_rdma_put_req_map(struct svcxprt_rdma *,\n-\t\t\t\t struct svc_rdma_req_map *);\n extern struct svc_rdma_fastreg_mr *svc_rdma_get_frmr(struct svcxprt_rdma *);\n extern void svc_rdma_put_frmr(struct svcxprt_rdma *,\n \t\t\t      struct svc_rdma_fastreg_mr *);\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\nindex e514f6864a939..1736337f3a557 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_sendto.c\n@@ -240,74 +240,6 @@ static void svc_rdma_xdr_encode_reply_chunk(__be32 *rdma_resp, __be32 *rp_ch,\n \txdr_encode_write_chunk(p, rp_ch, consumed);\n }\n \n-int svc_rdma_map_xdr(struct svcxprt_rdma *xprt,\n-\t\t     struct xdr_buf *xdr,\n-\t\t     struct svc_rdma_req_map *vec,\n-\t\t     bool write_chunk_present)\n-{\n-\tint sge_no;\n-\tu32 sge_bytes;\n-\tu32 page_bytes;\n-\tu32 page_off;\n-\tint page_no;\n-\n-\tif (xdr->len !=\n-\t    (xdr->head[0].iov_len + xdr->page_len + xdr->tail[0].iov_len)) {\n-\t\tpr_err(\"svcrdma: %s: XDR buffer length error\\n\", __func__);\n-\t\treturn -EIO;\n-\t}\n-\n-\t\/* Skip the first sge, this is for the RPCRDMA header *\/\n-\tsge_no = 1;\n-\n-\t\/* Head SGE *\/\n-\tvec->sge[sge_no].iov_base = xdr->head[0].iov_base;\n-\tvec->sge[sge_no].iov_len = xdr->head[0].iov_len;\n-\tsge_no++;\n-\n-\t\/* pages SGE *\/\n-\tpage_no = 0;\n-\tpage_bytes = xdr->page_len;\n-\tpage_off = xdr->page_base;\n-\twhile (page_bytes) {\n-\t\tvec->sge[sge_no].iov_base =\n-\t\t\tpage_address(xdr->pages[page_no]) + page_off;\n-\t\tsge_bytes = min_t(u32, page_bytes, (PAGE_SIZE - page_off));\n-\t\tpage_bytes -= sge_bytes;\n-\t\tvec->sge[sge_no].iov_len = sge_bytes;\n-\n-\t\tsge_no++;\n-\t\tpage_no++;\n-\t\tpage_off = 0; \/* reset for next time through loop *\/\n-\t}\n-\n-\t\/* Tail SGE *\/\n-\tif (xdr->tail[0].iov_len) {\n-\t\tunsigned char *base = xdr->tail[0].iov_base;\n-\t\tsize_t len = xdr->tail[0].iov_len;\n-\t\tu32 xdr_pad = xdr_padsize(xdr->page_len);\n-\n-\t\tif (write_chunk_present && xdr_pad) {\n-\t\t\tbase += xdr_pad;\n-\t\t\tlen -= xdr_pad;\n-\t\t}\n-\n-\t\tif (len) {\n-\t\t\tvec->sge[sge_no].iov_base = base;\n-\t\t\tvec->sge[sge_no].iov_len = len;\n-\t\t\tsge_no++;\n-\t\t}\n-\t}\n-\n-\tdprintk(\"svcrdma: %s: sge_no %d page_no %d \"\n-\t\t\"page_base %u page_len %u head_len %zu tail_len %zu\\n\",\n-\t\t__func__, sge_no, page_no, xdr->page_base, xdr->page_len,\n-\t\txdr->head[0].iov_len, xdr->tail[0].iov_len);\n-\n-\tvec->count = sge_no;\n-\treturn 0;\n-}\n-\n \/* Parse the RPC Call's transport header.\n  *\/\n static void svc_rdma_get_write_arrays(__be32 *rdma_argp,\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\nindex 1597ca8ba3c08..a9d9cb1ba4c60 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_transport.c\n@@ -272,85 +272,6 @@ static void svc_rdma_destroy_ctxts(struct svcxprt_rdma *xprt)\n \t}\n }\n \n-static struct svc_rdma_req_map *alloc_req_map(gfp_t flags)\n-{\n-\tstruct svc_rdma_req_map *map;\n-\n-\tmap = kmalloc(sizeof(*map), flags);\n-\tif (map)\n-\t\tINIT_LIST_HEAD(&map->free);\n-\treturn map;\n-}\n-\n-static bool svc_rdma_prealloc_maps(struct svcxprt_rdma *xprt)\n-{\n-\tunsigned int i;\n-\n-\t\/* One for each receive buffer on this connection. *\/\n-\ti = xprt->sc_max_requests;\n-\n-\twhile (i--) {\n-\t\tstruct svc_rdma_req_map *map;\n-\n-\t\tmap = alloc_req_map(GFP_KERNEL);\n-\t\tif (!map) {\n-\t\t\tdprintk(\"svcrdma: No memory for request map\\n\");\n-\t\t\treturn false;\n-\t\t}\n-\t\tlist_add(&map->free, &xprt->sc_maps);\n-\t}\n-\treturn true;\n-}\n-\n-struct svc_rdma_req_map *svc_rdma_get_req_map(struct svcxprt_rdma *xprt)\n-{\n-\tstruct svc_rdma_req_map *map = NULL;\n-\n-\tspin_lock(&xprt->sc_map_lock);\n-\tif (list_empty(&xprt->sc_maps))\n-\t\tgoto out_empty;\n-\n-\tmap = list_first_entry(&xprt->sc_maps,\n-\t\t\t       struct svc_rdma_req_map, free);\n-\tlist_del_init(&map->free);\n-\tspin_unlock(&xprt->sc_map_lock);\n-\n-out:\n-\tmap->count = 0;\n-\treturn map;\n-\n-out_empty:\n-\tspin_unlock(&xprt->sc_map_lock);\n-\n-\t\/* Pre-allocation amount was incorrect *\/\n-\tmap = alloc_req_map(GFP_NOIO);\n-\tif (map)\n-\t\tgoto out;\n-\n-\tWARN_ONCE(1, \"svcrdma: empty request map list?\\n\");\n-\treturn NULL;\n-}\n-\n-void svc_rdma_put_req_map(struct svcxprt_rdma *xprt,\n-\t\t\t  struct svc_rdma_req_map *map)\n-{\n-\tspin_lock(&xprt->sc_map_lock);\n-\tlist_add(&map->free, &xprt->sc_maps);\n-\tspin_unlock(&xprt->sc_map_lock);\n-}\n-\n-static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)\n-{\n-\twhile (!list_empty(&xprt->sc_maps)) {\n-\t\tstruct svc_rdma_req_map *map;\n-\n-\t\tmap = list_first_entry(&xprt->sc_maps,\n-\t\t\t\t       struct svc_rdma_req_map, free);\n-\t\tlist_del(&map->free);\n-\t\tkfree(map);\n-\t}\n-}\n-\n \/* QP event handler *\/\n static void qp_event_handler(struct ib_event *event, void *context)\n {\n@@ -544,7 +465,6 @@ static struct svcxprt_rdma *rdma_create_xprt(struct svc_serv *serv,\n \tINIT_LIST_HEAD(&cma_xprt->sc_frmr_q);\n \tINIT_LIST_HEAD(&cma_xprt->sc_ctxts);\n \tINIT_LIST_HEAD(&cma_xprt->sc_rw_ctxts);\n-\tINIT_LIST_HEAD(&cma_xprt->sc_maps);\n \tinit_waitqueue_head(&cma_xprt->sc_send_wait);\n \n \tspin_lock_init(&cma_xprt->sc_lock);\n@@ -552,7 +472,6 @@ static struct svcxprt_rdma *rdma_create_xprt(struct svc_serv *serv,\n \tspin_lock_init(&cma_xprt->sc_frmr_q_lock);\n \tspin_lock_init(&cma_xprt->sc_ctxt_lock);\n \tspin_lock_init(&cma_xprt->sc_rw_ctxt_lock);\n-\tspin_lock_init(&cma_xprt->sc_map_lock);\n \n \t\/*\n \t * Note that this implies that the underlying transport support\n@@ -1004,8 +923,6 @@ static struct svc_xprt *svc_rdma_accept(struct svc_xprt *xprt)\n \n \tif (!svc_rdma_prealloc_ctxts(newxprt))\n \t\tgoto errout;\n-\tif (!svc_rdma_prealloc_maps(newxprt))\n-\t\tgoto errout;\n \n \t\/*\n \t * Limit ORD based on client limit, local device limit, and\n@@ -1237,7 +1154,6 @@ static void __svc_rdma_free(struct work_struct *work)\n \trdma_dealloc_frmr_q(rdma);\n \tsvc_rdma_destroy_rw_ctxts(rdma);\n \tsvc_rdma_destroy_ctxts(rdma);\n-\tsvc_rdma_destroy_maps(rdma);\n \n \t\/* Destroy the QP if present (not a listener) *\/\n \tif (rdma->sc_qp && !IS_ERR(rdma->sc_qp))\n\ndiff --git a\/include\/linux\/sunrpc\/svc_rdma.h b\/include\/linux\/sunrpc\/svc_rdma.h\nindex 479bb7f652330..f3787d800ba46 100644\n--- a\/include\/linux\/sunrpc\/svc_rdma.h\n+++ b\/include\/linux\/sunrpc\/svc_rdma.h\n@@ -187,10 +187,6 @@ extern int svc_rdma_handle_bc_reply(struct rpc_xprt *xprt,\n \n \/* svc_rdma_marshal.c *\/\n extern int svc_rdma_xdr_decode_req(struct xdr_buf *);\n-extern void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *, int);\n-extern void svc_rdma_xdr_encode_array_chunk(struct rpcrdma_write_array *, int,\n-\t\t\t\t\t    __be32, __be64, u32);\n-extern unsigned int svc_rdma_xdr_get_reply_hdr_len(__be32 *rdma_resp);\n \n \/* svc_rdma_recvfrom.c *\/\n extern int svc_rdma_recvfrom(struct svc_rqst *);\ndiff --git a\/net\/sunrpc\/xprtrdma\/svc_rdma_marshal.c b\/net\/sunrpc\/xprtrdma\/svc_rdma_marshal.c\nindex ae58a897eca01..bdcf7d85a3dc0 100644\n--- a\/net\/sunrpc\/xprtrdma\/svc_rdma_marshal.c\n+++ b\/net\/sunrpc\/xprtrdma\/svc_rdma_marshal.c\n@@ -166,73 +166,3 @@ int svc_rdma_xdr_decode_req(struct xdr_buf *rq_arg)\n \tdprintk(\"svcrdma: failed to parse transport header\\n\");\n \treturn -EINVAL;\n }\n-\n-\/**\n- * svc_rdma_xdr_get_reply_hdr_length - Get length of Reply transport header\n- * @rdma_resp: buffer containing Reply transport header\n- *\n- * Returns length of transport header, in bytes.\n- *\/\n-unsigned int svc_rdma_xdr_get_reply_hdr_len(__be32 *rdma_resp)\n-{\n-\tunsigned int nsegs;\n-\t__be32 *p;\n-\n-\tp = rdma_resp;\n-\n-\t\/* RPC-over-RDMA V1 replies never have a Read list. *\/\n-\tp += rpcrdma_fixed_maxsz + 1;\n-\n-\t\/* Skip Write list. *\/\n-\twhile (*p++ != xdr_zero) {\n-\t\tnsegs = be32_to_cpup(p++);\n-\t\tp += nsegs * rpcrdma_segment_maxsz;\n-\t}\n-\n-\t\/* Skip Reply chunk. *\/\n-\tif (*p++ != xdr_zero) {\n-\t\tnsegs = be32_to_cpup(p++);\n-\t\tp += nsegs * rpcrdma_segment_maxsz;\n-\t}\n-\n-\treturn (unsigned long)p - (unsigned long)rdma_resp;\n-}\n-\n-void svc_rdma_xdr_encode_write_list(struct rpcrdma_msg *rmsgp, int chunks)\n-{\n-\tstruct rpcrdma_write_array *ary;\n-\n-\t\/* no read-list *\/\n-\trmsgp->rm_body.rm_chunks[0] = xdr_zero;\n-\n-\t\/* write-array discrim *\/\n-\tary = (struct rpcrdma_write_array *)\n-\t\t&rmsgp->rm_body.rm_chunks[1];\n-\tary->wc_discrim = xdr_one;\n-\tary->wc_nchunks = cpu_to_be32(chunks);\n-\n-\t\/* write-list terminator *\/\n-\tary->wc_array[chunks].wc_target.rs_handle = xdr_zero;\n-\n-\t\/* reply-array discriminator *\/\n-\tary->wc_array[chunks].wc_target.rs_length = xdr_zero;\n-}\n-\n-void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *ary,\n-\t\t\t\t int chunks)\n-{\n-\tary->wc_discrim = xdr_one;\n-\tary->wc_nchunks = cpu_to_be32(chunks);\n-}\n-\n-void svc_rdma_xdr_encode_array_chunk(struct rpcrdma_write_array *ary,\n-\t\t\t\t     int chunk_no,\n-\t\t\t\t     __be32 rs_handle,\n-\t\t\t\t     __be64 rs_offset,\n-\t\t\t\t     u32 write_len)\n-{\n-\tstruct rpcrdma_segment *seg = &ary->wc_array[chunk_no].wc_target;\n-\tseg->rs_handle = rs_handle;\n-\tseg->rs_offset = rs_offset;\n-\tseg->rs_length = cpu_to_be32(write_len);\n-}\n\ndiff --git a\/fs\/lockd\/svclock.c b\/fs\/lockd\/svclock.c\nindex 5581e020644bd..3507c80d1d4b9 100644\n--- a\/fs\/lockd\/svclock.c\n+++ b\/fs\/lockd\/svclock.c\n@@ -870,15 +870,15 @@ nlmsvc_grant_reply(struct nlm_cookie *cookie, __be32 status)\n \tif (!(block = nlmsvc_find_block(cookie)))\n \t\treturn;\n \n-\tif (block) {\n-\t\tif (status == nlm_lck_denied_grace_period) {\n-\t\t\t\/* Try again in a couple of seconds *\/\n-\t\t\tnlmsvc_insert_block(block, 10 * HZ);\n-\t\t} else {\n-\t\t\t\/* Lock is now held by client, or has been rejected.\n-\t\t\t * In both cases, the block should be removed. *\/\n-\t\t\tnlmsvc_unlink_block(block);\n-\t\t}\n+\tif (status == nlm_lck_denied_grace_period) {\n+\t\t\/* Try again in a couple of seconds *\/\n+\t\tnlmsvc_insert_block(block, 10 * HZ);\n+\t} else {\n+\t\t\/*\n+\t\t * Lock is now held by client, or has been rejected.\n+\t\t * In both cases, the block should be removed.\n+\t\t *\/\n+\t\tnlmsvc_unlink_block(block);\n \t}\n \tnlmsvc_release_block(block);\n }\n\ndiff --git a\/fs\/nfs\/callback.c b\/fs\/nfs\/callback.c\nindex 773774531aff5..c5e27ebd8da8b 100644\n--- a\/fs\/nfs\/callback.c\n+++ b\/fs\/nfs\/callback.c\n@@ -280,7 +280,7 @@ static struct svc_serv *nfs_callback_create_svc(int minorversion)\n \t\tprintk(KERN_WARNING \"nfs_callback_create_svc: no kthread, %d users??\\n\",\n \t\t\tcb_info->users);\n \n-\tserv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);\n+\tserv = svc_create_pooled(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);\n \tif (!serv) {\n \t\tprintk(KERN_ERR \"nfs_callback_create_svc: create service failed\\n\");\n \t\treturn ERR_PTR(-ENOMEM);\n\ndiff --git a\/net\/sunrpc\/svc.c b\/net\/sunrpc\/svc.c\nindex a08aeb56b8e45..98dc33ae738b9 100644\n--- a\/net\/sunrpc\/svc.c\n+++ b\/net\/sunrpc\/svc.c\n@@ -702,59 +702,32 @@ choose_victim(struct svc_serv *serv, struct svc_pool *pool, unsigned int *state)\n \treturn task;\n }\n \n-\/*\n- * Create or destroy enough new threads to make the number\n- * of threads the given number.  If `pool' is non-NULL, applies\n- * only to threads in that pool, otherwise round-robins between\n- * all pools.  Caller must ensure that mutual exclusion between this and\n- * server startup or shutdown.\n- *\n- * Destroying threads relies on the service threads filling in\n- * rqstp->rq_task, which only the nfs ones do.  Assumes the serv\n- * has been created using svc_create_pooled().\n- *\n- * Based on code that used to be in nfsd_svc() but tweaked\n- * to be pool-aware.\n- *\/\n-int\n-svc_set_num_threads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n+\/* create new threads *\/\n+static int\n+svc_start_kthreads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n {\n \tstruct svc_rqst\t*rqstp;\n \tstruct task_struct *task;\n \tstruct svc_pool *chosen_pool;\n-\tint error = 0;\n \tunsigned int state = serv->sv_nrthreads-1;\n \tint node;\n \n-\tif (pool == NULL) {\n-\t\t\/* The -1 assumes caller has done a svc_get() *\/\n-\t\tnrservs -= (serv->sv_nrthreads-1);\n-\t} else {\n-\t\tspin_lock_bh(&pool->sp_lock);\n-\t\tnrservs -= pool->sp_nrthreads;\n-\t\tspin_unlock_bh(&pool->sp_lock);\n-\t}\n-\n-\t\/* create new threads *\/\n-\twhile (nrservs > 0) {\n+\tdo {\n \t\tnrservs--;\n \t\tchosen_pool = choose_pool(serv, pool, &state);\n \n \t\tnode = svc_pool_map_get_node(chosen_pool->sp_id);\n \t\trqstp = svc_prepare_thread(serv, chosen_pool, node);\n-\t\tif (IS_ERR(rqstp)) {\n-\t\t\terror = PTR_ERR(rqstp);\n-\t\t\tbreak;\n-\t\t}\n+\t\tif (IS_ERR(rqstp))\n+\t\t\treturn PTR_ERR(rqstp);\n \n \t\t__module_get(serv->sv_ops->svo_module);\n \t\ttask = kthread_create_on_node(serv->sv_ops->svo_function, rqstp,\n \t\t\t\t\t      node, \"%s\", serv->sv_name);\n \t\tif (IS_ERR(task)) {\n-\t\t\terror = PTR_ERR(task);\n \t\t\tmodule_put(serv->sv_ops->svo_module);\n \t\t\tsvc_exit_thread(rqstp);\n-\t\t\tbreak;\n+\t\t\treturn PTR_ERR(task);\n \t\t}\n \n \t\trqstp->rq_task = task;\n@@ -763,15 +736,62 @@ svc_set_num_threads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n \n \t\tsvc_sock_update_bufs(serv);\n \t\twake_up_process(task);\n-\t}\n+\t} while (nrservs > 0);\n+\n+\treturn 0;\n+}\n+\n+\n+\/* destroy old threads *\/\n+static int\n+svc_signal_kthreads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n+{\n+\tstruct task_struct *task;\n+\tunsigned int state = serv->sv_nrthreads-1;\n+\n \t\/* destroy old threads *\/\n-\twhile (nrservs < 0 &&\n-\t       (task = choose_victim(serv, pool, &state)) != NULL) {\n+\tdo {\n+\t\ttask = choose_victim(serv, pool, &state);\n+\t\tif (task == NULL)\n+\t\t\tbreak;\n \t\tsend_sig(SIGINT, task, 1);\n \t\tnrservs++;\n+\t} while (nrservs < 0);\n+\n+\treturn 0;\n+}\n+\n+\/*\n+ * Create or destroy enough new threads to make the number\n+ * of threads the given number.  If `pool' is non-NULL, applies\n+ * only to threads in that pool, otherwise round-robins between\n+ * all pools.  Caller must ensure that mutual exclusion between this and\n+ * server startup or shutdown.\n+ *\n+ * Destroying threads relies on the service threads filling in\n+ * rqstp->rq_task, which only the nfs ones do.  Assumes the serv\n+ * has been created using svc_create_pooled().\n+ *\n+ * Based on code that used to be in nfsd_svc() but tweaked\n+ * to be pool-aware.\n+ *\/\n+int\n+svc_set_num_threads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n+{\n+\tif (pool == NULL) {\n+\t\t\/* The -1 assumes caller has done a svc_get() *\/\n+\t\tnrservs -= (serv->sv_nrthreads-1);\n+\t} else {\n+\t\tspin_lock_bh(&pool->sp_lock);\n+\t\tnrservs -= pool->sp_nrthreads;\n+\t\tspin_unlock_bh(&pool->sp_lock);\n \t}\n \n-\treturn error;\n+\tif (nrservs > 0)\n+\t\treturn svc_start_kthreads(serv, pool, nrservs);\n+\tif (nrservs < 0)\n+\t\treturn svc_signal_kthreads(serv, pool, nrservs);\n+\treturn 0;\n }\n EXPORT_SYMBOL_GPL(svc_set_num_threads);\n \n\ndiff --git a\/fs\/nfs\/callback.c b\/fs\/nfs\/callback.c\nindex c5e27ebd8da8b..73a1f928226c0 100644\n--- a\/fs\/nfs\/callback.c\n+++ b\/fs\/nfs\/callback.c\n@@ -76,7 +76,10 @@ nfs4_callback_svc(void *vrqstp)\n \n \tset_freezable();\n \n-\twhile (!kthread_should_stop()) {\n+\twhile (!kthread_freezable_should_stop(NULL)) {\n+\n+\t\tif (signal_pending(current))\n+\t\t\tflush_signals(current);\n \t\t\/*\n \t\t * Listen for a request on the socket\n \t\t *\/\n@@ -85,6 +88,8 @@ nfs4_callback_svc(void *vrqstp)\n \t\t\tcontinue;\n \t\tsvc_process(rqstp);\n \t}\n+\tsvc_exit_thread(rqstp);\n+\tmodule_put_and_exit(0);\n \treturn 0;\n }\n \n@@ -103,9 +108,10 @@ nfs41_callback_svc(void *vrqstp)\n \n \tset_freezable();\n \n-\twhile (!kthread_should_stop()) {\n-\t\tif (try_to_freeze())\n-\t\t\tcontinue;\n+\twhile (!kthread_freezable_should_stop(NULL)) {\n+\n+\t\tif (signal_pending(current))\n+\t\t\tflush_signals(current);\n \n \t\tprepare_to_wait(&serv->sv_cb_waitq, &wq, TASK_INTERRUPTIBLE);\n \t\tspin_lock_bh(&serv->sv_cb_lock);\n@@ -121,11 +127,13 @@ nfs41_callback_svc(void *vrqstp)\n \t\t\t\terror);\n \t\t} else {\n \t\t\tspin_unlock_bh(&serv->sv_cb_lock);\n-\t\t\tschedule();\n+\t\t\tif (!kthread_should_stop())\n+\t\t\t\tschedule();\n \t\t\tfinish_wait(&serv->sv_cb_waitq, &wq);\n \t\t}\n-\t\tflush_signals(current);\n \t}\n+\tsvc_exit_thread(rqstp);\n+\tmodule_put_and_exit(0);\n \treturn 0;\n }\n \n@@ -221,14 +229,14 @@ static int nfs_callback_up_net(int minorversion, struct svc_serv *serv,\n static struct svc_serv_ops nfs40_cb_sv_ops = {\n \t.svo_function\t\t= nfs4_callback_svc,\n \t.svo_enqueue_xprt\t= svc_xprt_do_enqueue,\n-\t.svo_setup\t\t= svc_set_num_threads,\n+\t.svo_setup\t\t= svc_set_num_threads_sync,\n \t.svo_module\t\t= THIS_MODULE,\n };\n #if defined(CONFIG_NFS_V4_1)\n static struct svc_serv_ops nfs41_cb_sv_ops = {\n \t.svo_function\t\t= nfs41_callback_svc,\n \t.svo_enqueue_xprt\t= svc_xprt_do_enqueue,\n-\t.svo_setup\t\t= svc_set_num_threads,\n+\t.svo_setup\t\t= svc_set_num_threads_sync,\n \t.svo_module\t\t= THIS_MODULE,\n };\n \ndiff --git a\/include\/linux\/sunrpc\/svc.h b\/include\/linux\/sunrpc\/svc.h\nindex 6ef19cf658b40..94631026f79c5 100644\n--- a\/include\/linux\/sunrpc\/svc.h\n+++ b\/include\/linux\/sunrpc\/svc.h\n@@ -473,6 +473,7 @@ void\t\t   svc_pool_map_put(void);\n struct svc_serv *  svc_create_pooled(struct svc_program *, unsigned int,\n \t\t\tstruct svc_serv_ops *);\n int\t\t   svc_set_num_threads(struct svc_serv *, struct svc_pool *, int);\n+int\t\t   svc_set_num_threads_sync(struct svc_serv *, struct svc_pool *, int);\n int\t\t   svc_pool_stats_open(struct svc_serv *serv, struct file *file);\n void\t\t   svc_destroy(struct svc_serv *);\n void\t\t   svc_shutdown_net(struct svc_serv *, struct net *);\ndiff --git a\/net\/sunrpc\/svc.c b\/net\/sunrpc\/svc.c\nindex 98dc33ae738b9..bc0f5a0ecbdce 100644\n--- a\/net\/sunrpc\/svc.c\n+++ b\/net\/sunrpc\/svc.c\n@@ -795,6 +795,44 @@ svc_set_num_threads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n }\n EXPORT_SYMBOL_GPL(svc_set_num_threads);\n \n+\/* destroy old threads *\/\n+static int\n+svc_stop_kthreads(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n+{\n+\tstruct task_struct *task;\n+\tunsigned int state = serv->sv_nrthreads-1;\n+\n+\t\/* destroy old threads *\/\n+\tdo {\n+\t\ttask = choose_victim(serv, pool, &state);\n+\t\tif (task == NULL)\n+\t\t\tbreak;\n+\t\tkthread_stop(task);\n+\t\tnrservs++;\n+\t} while (nrservs < 0);\n+\treturn 0;\n+}\n+\n+int\n+svc_set_num_threads_sync(struct svc_serv *serv, struct svc_pool *pool, int nrservs)\n+{\n+\tif (pool == NULL) {\n+\t\t\/* The -1 assumes caller has done a svc_get() *\/\n+\t\tnrservs -= (serv->sv_nrthreads-1);\n+\t} else {\n+\t\tspin_lock_bh(&pool->sp_lock);\n+\t\tnrservs -= pool->sp_nrthreads;\n+\t\tspin_unlock_bh(&pool->sp_lock);\n+\t}\n+\n+\tif (nrservs > 0)\n+\t\treturn svc_start_kthreads(serv, pool, nrservs);\n+\tif (nrservs < 0)\n+\t\treturn svc_stop_kthreads(serv, pool, nrservs);\n+\treturn 0;\n+}\n+EXPORT_SYMBOL_GPL(svc_set_num_threads_sync);\n+\n \/*\n  * Called from a server thread as it's exiting. Caller must hold the \"service\n  * mutex\" for the service.\n\ndiff --git a\/fs\/lockd\/svc.c b\/fs\/lockd\/svc.c\nindex e7c8b9c76e485..5d481e8a1b5d0 100644\n--- a\/fs\/lockd\/svc.c\n+++ b\/fs\/lockd\/svc.c\n@@ -132,6 +132,8 @@ lockd(void *vrqstp)\n {\n \tint\t\terr = 0;\n \tstruct svc_rqst *rqstp = vrqstp;\n+\tstruct net *net = &init_net;\n+\tstruct lockd_net *ln = net_generic(net, lockd_net_id);\n \n \t\/* try_to_freeze() is called from svc_recv() *\/\n \tset_freezable();\n@@ -176,6 +178,8 @@ lockd(void *vrqstp)\n \tif (nlmsvc_ops)\n \t\tnlmsvc_invalidate_all();\n \tnlm_shutdown_hosts();\n+\tcancel_delayed_work_sync(&ln->grace_period_end);\n+\tlocks_end_grace(&ln->lockd_manager);\n \treturn 0;\n }\n \n@@ -270,8 +274,6 @@ static void lockd_down_net(struct svc_serv *serv, struct net *net)\n \tif (ln->nlmsvc_users) {\n \t\tif (--ln->nlmsvc_users == 0) {\n \t\t\tnlm_shutdown_hosts_net(net);\n-\t\t\tcancel_delayed_work_sync(&ln->grace_period_end);\n-\t\t\tlocks_end_grace(&ln->lockd_manager);\n \t\t\tsvc_shutdown_net(serv, net);\n \t\t\tdprintk(\"lockd_down_net: per-net data destroyed; net=%p\\n\", net);\n \t\t}\n\ndiff --git a\/fs\/nfsd\/nfs4proc.c b\/fs\/nfsd\/nfs4proc.c\nindex d86031b6ad793..c453a1998e003 100644\n--- a\/fs\/nfsd\/nfs4proc.c\n+++ b\/fs\/nfsd\/nfs4proc.c\n@@ -1259,7 +1259,8 @@ nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n \t\treturn NULL;\n \t}\n \n-\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n+\tif (layout_type >= LAYOUT_TYPE_MAX ||\n+\t    !(exp->ex_layout_types & (1 << layout_type))) {\n \t\tdprintk(\"%s: layout type %d not supported\\n\",\n \t\t\t__func__, layout_type);\n \t\treturn NULL;\n\ndiff --git a\/fs\/nfsd\/nfs4xdr.c b\/fs\/nfsd\/nfs4xdr.c\nindex 33017d652b1da..8e9652f37f1fc 100644\n--- a\/fs\/nfsd\/nfs4xdr.c\n+++ b\/fs\/nfsd\/nfs4xdr.c\n@@ -4119,8 +4119,7 @@ nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n \t\tstruct nfsd4_getdeviceinfo *gdev)\n {\n \tstruct xdr_stream *xdr = &resp->xdr;\n-\tconst struct nfsd4_layout_ops *ops =\n-\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n+\tconst struct nfsd4_layout_ops *ops;\n \tu32 starting_len = xdr->buf->len, needed_len;\n \t__be32 *p;\n \n@@ -4137,6 +4136,7 @@ nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n \n \t\/* If maxcount is 0 then just update notifications *\/\n \tif (gdev->gd_maxcount != 0) {\n+\t\tops = nfsd4_layout_ops[gdev->gd_layout_type];\n \t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n \t\tif (nfserr) {\n \t\t\t\/*\n@@ -4189,8 +4189,7 @@ nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n \t\tstruct nfsd4_layoutget *lgp)\n {\n \tstruct xdr_stream *xdr = &resp->xdr;\n-\tconst struct nfsd4_layout_ops *ops =\n-\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n+\tconst struct nfsd4_layout_ops *ops;\n \t__be32 *p;\n \n \tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n@@ -4213,6 +4212,7 @@ nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n \t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n \t*p++ = cpu_to_be32(lgp->lg_layout_type);\n \n+\tops = nfsd4_layout_ops[lgp->lg_layout_type];\n \tnfserr = ops->encode_layoutget(xdr, lgp);\n out:\n \tkfree(lgp->lg_content);\n\ndiff --git a\/fs\/nfsd\/nfs4xdr.c b\/fs\/nfsd\/nfs4xdr.c\nindex 8e9652f37f1fc..26780d53a6f94 100644\n--- a\/fs\/nfsd\/nfs4xdr.c\n+++ b\/fs\/nfsd\/nfs4xdr.c\n@@ -2831,9 +2831,14 @@ nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n \t}\n #endif \/* CONFIG_NFSD_PNFS *\/\n \tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n-\t\tstatus = nfsd4_encode_bitmap(xdr, NFSD_SUPPATTR_EXCLCREAT_WORD0,\n-\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD1,\n-\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD2);\n+\t\tu32 supp[3];\n+\n+\t\tmemcpy(supp, nfsd_suppattrs[minorversion], sizeof(supp));\n+\t\tsupp[0] &= NFSD_SUPPATTR_EXCLCREAT_WORD0;\n+\t\tsupp[1] &= NFSD_SUPPATTR_EXCLCREAT_WORD1;\n+\t\tsupp[2] &= NFSD_SUPPATTR_EXCLCREAT_WORD2;\n+\n+\t\tstatus = nfsd4_encode_bitmap(xdr, supp[0], supp[1], supp[2]);\n \t\tif (status)\n \t\t\tgoto out;\n \t}\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-4668","CWE_ID":"399","category":"security","commit_id":"5478755616ae2ef1ce144dded589b62b2a50d575","commit_message":"From 5478755616ae2ef1ce144dded589b62b2a50d575 Mon Sep 17 00:00:00 2001\nFrom: Xiaotian Feng <dfeng@redhat.com>\nDate: Mon, 29 Nov 2010 10:03:55 +0100\nSubject: block: check for proper length of iov entries earlier in\n blk_rq_map_user_iov()\n\ncommit 9284bcf checks for proper length of iov entries in\nblk_rq_map_user_iov(). But if the map is unaligned, kernel\nwill break out the loop without checking for the proper length.\nSo we need to check the proper length before the unalign check.\n\nSigned-off-by: Xiaotian Feng <dfeng@redhat.com>\nCc: stable@kernel.org\nSigned-off-by: Jens Axboe <jaxboe@fusionio.com>\n---\n block\/blk-map.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/block\/blk-map.c b\/block\/blk-map.c\nindex 5d5dbe47c228..e663ac2d8e68 100644\n--- a\/block\/blk-map.c\n+++ b\/block\/blk-map.c\n@@ -201,12 +201,13 @@ int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n \tfor (i = 0; i < iov_count; i++) {\n \t\tunsigned long uaddr = (unsigned long)iov[i].iov_base;\n \n+\t\tif (!iov[i].iov_len)\n+\t\t\treturn -EINVAL;\n+\n \t\tif (uaddr & queue_dma_alignment(q)) {\n \t\t\tunaligned = 1;\n \t\t\tbreak;\n \t\t}\n-\t\tif (!iov[i].iov_len)\n-\t\t\treturn -EINVAL;\n \t}\n \n \tif (unaligned || (q->dma_pad_mask & len) || map_data)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-2133","CWE_ID":"399","category":"security","commit_id":"90481622d75715bfcb68501280a917dbfe516029","commit_message":"From 90481622d75715bfcb68501280a917dbfe516029 Mon Sep 17 00:00:00 2001\nFrom: David Gibson <david@gibson.dropbear.id.au>\nDate: Wed, 21 Mar 2012 16:34:12 -0700\nSubject: [PATCH] hugepages: fix use after free bug in \"quota\" handling\n\nhugetlbfs_{get,put}_quota() are badly named.  They don't interact with the\ngeneral quota handling code, and they don't much resemble its behaviour.\nRather than being about maintaining limits on on-disk block usage by\nparticular users, they are instead about maintaining limits on in-memory\npage usage (including anonymous MAP_PRIVATE copied-on-write pages)\nassociated with a particular hugetlbfs filesystem instance.\n\nWorse, they work by having callbacks to the hugetlbfs filesystem code from\nthe low-level page handling code, in particular from free_huge_page().\nThis is a layering violation of itself, but more importantly, if the\nkernel does a get_user_pages() on hugepages (which can happen from KVM\namongst others), then the free_huge_page() can be delayed until after the\nassociated inode has already been freed.  If an unmount occurs at the\nwrong time, even the hugetlbfs superblock where the \"quota\" limits are\nstored may have been freed.\n\nAndrew Barry proposed a patch to fix this by having hugepages, instead of\nstoring a pointer to their address_space and reaching the superblock from\nthere, had the hugepages store pointers directly to the superblock,\nbumping the reference count as appropriate to avoid it being freed.\nAndrew Morton rejected that version, however, on the grounds that it made\nthe existing layering violation worse.\n\nThis is a reworked version of Andrew's patch, which removes the extra, and\nsome of the existing, layering violation.  It works by introducing the\nconcept of a hugepage \"subpool\" at the lower hugepage mm layer - that is a\nfinite logical pool of hugepages to allocate from.  hugetlbfs now creates\na subpool for each filesystem instance with a page limit set, and a\npointer to the subpool gets added to each allocated hugepage, instead of\nthe address_space pointer used now.  The subpool has its own lifetime and\nis only freed once all pages in it _and_ all other references to it (i.e.\nsuperblocks) are gone.\n\nsubpools are optional - a NULL subpool pointer is taken by the code to\nmean that no subpool limits are in effect.\n\nPrevious discussion of this bug found in:  \"Fix refcounting in hugetlbfs\nquota handling.\". See:  https:\/\/lkml.org\/lkml\/2011\/8\/11\/28 or\nhttp:\/\/marc.info\/?l=linux-mm&m=126928970510627&w=1\n\nv2: Fixed a bug spotted by Hillf Danton, and removed the extra parameter to\nalloc_huge_page() - since it already takes the vma, it is not necessary.\n\nSigned-off-by: Andrew Barry <abarry@cray.com>\nSigned-off-by: David Gibson <david@gibson.dropbear.id.au>\nCc: Hugh Dickins <hughd@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Minchan Kim <minchan.kim@gmail.com>\nCc: Hillf Danton <dhillf@gmail.com>\nCc: Paul Mackerras <paulus@samba.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/hugetlbfs\/inode.c    |  54 +++++++---------\n include\/linux\/hugetlb.h |  14 +++--\n mm\/hugetlb.c            | 135 ++++++++++++++++++++++++++++++++--------\n 3 files changed, 139 insertions(+), 64 deletions(-)\n\n","diff_code":"diff --git a\/fs\/hugetlbfs\/inode.c b\/fs\/hugetlbfs\/inode.c\nindex 4fbd9fccd5503..7913e32521676 100644\n--- a\/fs\/hugetlbfs\/inode.c\n+++ b\/fs\/hugetlbfs\/inode.c\n@@ -626,9 +626,15 @@ static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n \t\tspin_lock(&sbinfo->stat_lock);\n \t\t\/* If no limits set, just report 0 for max\/free\/used\n \t\t * blocks, like simple_statfs() *\/\n-\t\tif (sbinfo->max_blocks >= 0) {\n-\t\t\tbuf->f_blocks = sbinfo->max_blocks;\n-\t\t\tbuf->f_bavail = buf->f_bfree = sbinfo->free_blocks;\n+\t\tif (sbinfo->spool) {\n+\t\t\tlong free_pages;\n+\n+\t\t\tspin_lock(&sbinfo->spool->lock);\n+\t\t\tbuf->f_blocks = sbinfo->spool->max_hpages;\n+\t\t\tfree_pages = sbinfo->spool->max_hpages\n+\t\t\t\t- sbinfo->spool->used_hpages;\n+\t\t\tbuf->f_bavail = buf->f_bfree = free_pages;\n+\t\t\tspin_unlock(&sbinfo->spool->lock);\n \t\t\tbuf->f_files = sbinfo->max_inodes;\n \t\t\tbuf->f_ffree = sbinfo->free_inodes;\n \t\t}\n@@ -644,6 +650,10 @@ static void hugetlbfs_put_super(struct super_block *sb)\n \n \tif (sbi) {\n \t\tsb->s_fs_info = NULL;\n+\n+\t\tif (sbi->spool)\n+\t\t\thugepage_put_subpool(sbi->spool);\n+\n \t\tkfree(sbi);\n \t}\n }\n@@ -874,10 +884,14 @@ hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n \tsb->s_fs_info = sbinfo;\n \tsbinfo->hstate = config.hstate;\n \tspin_lock_init(&sbinfo->stat_lock);\n-\tsbinfo->max_blocks = config.nr_blocks;\n-\tsbinfo->free_blocks = config.nr_blocks;\n \tsbinfo->max_inodes = config.nr_inodes;\n \tsbinfo->free_inodes = config.nr_inodes;\n+\tsbinfo->spool = NULL;\n+\tif (config.nr_blocks != -1) {\n+\t\tsbinfo->spool = hugepage_new_subpool(config.nr_blocks);\n+\t\tif (!sbinfo->spool)\n+\t\t\tgoto out_free;\n+\t}\n \tsb->s_maxbytes = MAX_LFS_FILESIZE;\n \tsb->s_blocksize = huge_page_size(config.hstate);\n \tsb->s_blocksize_bits = huge_page_shift(config.hstate);\n@@ -896,38 +910,12 @@ hugetlbfs_fill_super(struct super_block *sb, void *data, int silent)\n \tsb->s_root = root;\n \treturn 0;\n out_free:\n+\tif (sbinfo->spool)\n+\t\tkfree(sbinfo->spool);\n \tkfree(sbinfo);\n \treturn -ENOMEM;\n }\n \n-int hugetlb_get_quota(struct address_space *mapping, long delta)\n-{\n-\tint ret = 0;\n-\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\n-\n-\tif (sbinfo->free_blocks > -1) {\n-\t\tspin_lock(&sbinfo->stat_lock);\n-\t\tif (sbinfo->free_blocks - delta >= 0)\n-\t\t\tsbinfo->free_blocks -= delta;\n-\t\telse\n-\t\t\tret = -ENOMEM;\n-\t\tspin_unlock(&sbinfo->stat_lock);\n-\t}\n-\n-\treturn ret;\n-}\n-\n-void hugetlb_put_quota(struct address_space *mapping, long delta)\n-{\n-\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\n-\n-\tif (sbinfo->free_blocks > -1) {\n-\t\tspin_lock(&sbinfo->stat_lock);\n-\t\tsbinfo->free_blocks += delta;\n-\t\tspin_unlock(&sbinfo->stat_lock);\n-\t}\n-}\n-\n static struct dentry *hugetlbfs_mount(struct file_system_type *fs_type,\n \tint flags, const char *dev_name, void *data)\n {\ndiff --git a\/include\/linux\/hugetlb.h b\/include\/linux\/hugetlb.h\nindex 7adc4923e7acb..cf0181738c9ef 100644\n--- a\/include\/linux\/hugetlb.h\n+++ b\/include\/linux\/hugetlb.h\n@@ -14,6 +14,15 @@ struct user_struct;\n #include <linux\/shm.h>\n #include <asm\/tlbflush.h>\n \n+struct hugepage_subpool {\n+\tspinlock_t lock;\n+\tlong count;\n+\tlong max_hpages, used_hpages;\n+};\n+\n+struct hugepage_subpool *hugepage_new_subpool(long nr_blocks);\n+void hugepage_put_subpool(struct hugepage_subpool *spool);\n+\n int PageHuge(struct page *page);\n \n void reset_vma_resv_huge_pages(struct vm_area_struct *vma);\n@@ -129,12 +138,11 @@ enum {\n \n #ifdef CONFIG_HUGETLBFS\n struct hugetlbfs_sb_info {\n-\tlong\tmax_blocks;   \/* blocks allowed *\/\n-\tlong\tfree_blocks;  \/* blocks free *\/\n \tlong\tmax_inodes;   \/* inodes allowed *\/\n \tlong\tfree_inodes;  \/* inodes free *\/\n \tspinlock_t\tstat_lock;\n \tstruct hstate *hstate;\n+\tstruct hugepage_subpool *spool;\n };\n \n static inline struct hugetlbfs_sb_info *HUGETLBFS_SB(struct super_block *sb)\n@@ -146,8 +154,6 @@ extern const struct file_operations hugetlbfs_file_operations;\n extern const struct vm_operations_struct hugetlb_vm_ops;\n struct file *hugetlb_file_setup(const char *name, size_t size, vm_flags_t acct,\n \t\t\t\tstruct user_struct **user, int creat_flags);\n-int hugetlb_get_quota(struct address_space *mapping, long delta);\n-void hugetlb_put_quota(struct address_space *mapping, long delta);\n \n static inline int is_file_hugepages(struct file *file)\n {\ndiff --git a\/mm\/hugetlb.c b\/mm\/hugetlb.c\nindex b1c3148773344..afa057a1d3fe6 100644\n--- a\/mm\/hugetlb.c\n+++ b\/mm\/hugetlb.c\n@@ -53,6 +53,84 @@ static unsigned long __initdata default_hstate_size;\n  *\/\n static DEFINE_SPINLOCK(hugetlb_lock);\n \n+static inline void unlock_or_release_subpool(struct hugepage_subpool *spool)\n+{\n+\tbool free = (spool->count == 0) && (spool->used_hpages == 0);\n+\n+\tspin_unlock(&spool->lock);\n+\n+\t\/* If no pages are used, and no other handles to the subpool\n+\t * remain, free the subpool the subpool remain *\/\n+\tif (free)\n+\t\tkfree(spool);\n+}\n+\n+struct hugepage_subpool *hugepage_new_subpool(long nr_blocks)\n+{\n+\tstruct hugepage_subpool *spool;\n+\n+\tspool = kmalloc(sizeof(*spool), GFP_KERNEL);\n+\tif (!spool)\n+\t\treturn NULL;\n+\n+\tspin_lock_init(&spool->lock);\n+\tspool->count = 1;\n+\tspool->max_hpages = nr_blocks;\n+\tspool->used_hpages = 0;\n+\n+\treturn spool;\n+}\n+\n+void hugepage_put_subpool(struct hugepage_subpool *spool)\n+{\n+\tspin_lock(&spool->lock);\n+\tBUG_ON(!spool->count);\n+\tspool->count--;\n+\tunlock_or_release_subpool(spool);\n+}\n+\n+static int hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n+\t\t\t\t      long delta)\n+{\n+\tint ret = 0;\n+\n+\tif (!spool)\n+\t\treturn 0;\n+\n+\tspin_lock(&spool->lock);\n+\tif ((spool->used_hpages + delta) <= spool->max_hpages) {\n+\t\tspool->used_hpages += delta;\n+\t} else {\n+\t\tret = -ENOMEM;\n+\t}\n+\tspin_unlock(&spool->lock);\n+\n+\treturn ret;\n+}\n+\n+static void hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n+\t\t\t\t       long delta)\n+{\n+\tif (!spool)\n+\t\treturn;\n+\n+\tspin_lock(&spool->lock);\n+\tspool->used_hpages -= delta;\n+\t\/* If hugetlbfs_put_super couldn't free spool due to\n+\t* an outstanding quota reference, free it now. *\/\n+\tunlock_or_release_subpool(spool);\n+}\n+\n+static inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n+{\n+\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n+}\n+\n+static inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)\n+{\n+\treturn subpool_inode(vma->vm_file->f_dentry->d_inode);\n+}\n+\n \/*\n  * Region tracking -- allows tracking of reservations and instantiated pages\n  *                    across the pages in a mapping.\n@@ -540,9 +618,9 @@ static void free_huge_page(struct page *page)\n \t *\/\n \tstruct hstate *h = page_hstate(page);\n \tint nid = page_to_nid(page);\n-\tstruct address_space *mapping;\n+\tstruct hugepage_subpool *spool =\n+\t\t(struct hugepage_subpool *)page_private(page);\n \n-\tmapping = (struct address_space *) page_private(page);\n \tset_page_private(page, 0);\n \tpage->mapping = NULL;\n \tBUG_ON(page_count(page));\n@@ -558,8 +636,7 @@ static void free_huge_page(struct page *page)\n \t\tenqueue_huge_page(h, page);\n \t}\n \tspin_unlock(&hugetlb_lock);\n-\tif (mapping)\n-\t\thugetlb_put_quota(mapping, 1);\n+\thugepage_subpool_put_pages(spool, 1);\n }\n \n static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n@@ -977,11 +1054,12 @@ static void return_unused_surplus_pages(struct hstate *h,\n \/*\n  * Determine if the huge page at addr within the vma has an associated\n  * reservation.  Where it does not we will need to logically increase\n- * reservation and actually increase quota before an allocation can occur.\n- * Where any new reservation would be required the reservation change is\n- * prepared, but not committed.  Once the page has been quota'd allocated\n- * an instantiated the change should be committed via vma_commit_reservation.\n- * No action is required on failure.\n+ * reservation and actually increase subpool usage before an allocation\n+ * can occur.  Where any new reservation would be required the\n+ * reservation change is prepared, but not committed.  Once the page\n+ * has been allocated from the subpool and instantiated the change should\n+ * be committed via vma_commit_reservation.  No action is required on\n+ * failure.\n  *\/\n static long vma_needs_reservation(struct hstate *h,\n \t\t\tstruct vm_area_struct *vma, unsigned long addr)\n@@ -1030,24 +1108,24 @@ static void vma_commit_reservation(struct hstate *h,\n static struct page *alloc_huge_page(struct vm_area_struct *vma,\n \t\t\t\t    unsigned long addr, int avoid_reserve)\n {\n+\tstruct hugepage_subpool *spool = subpool_vma(vma);\n \tstruct hstate *h = hstate_vma(vma);\n \tstruct page *page;\n-\tstruct address_space *mapping = vma->vm_file->f_mapping;\n-\tstruct inode *inode = mapping->host;\n \tlong chg;\n \n \t\/*\n-\t * Processes that did not create the mapping will have no reserves and\n-\t * will not have accounted against quota. Check that the quota can be\n-\t * made before satisfying the allocation\n-\t * MAP_NORESERVE mappings may also need pages and quota allocated\n-\t * if no reserve mapping overlaps.\n+\t * Processes that did not create the mapping will have no\n+\t * reserves and will not have accounted against subpool\n+\t * limit. Check that the subpool limit can be made before\n+\t * satisfying the allocation MAP_NORESERVE mappings may also\n+\t * need pages and subpool limit allocated allocated if no reserve\n+\t * mapping overlaps.\n \t *\/\n \tchg = vma_needs_reservation(h, vma, addr);\n \tif (chg < 0)\n \t\treturn ERR_PTR(-VM_FAULT_OOM);\n \tif (chg)\n-\t\tif (hugetlb_get_quota(inode->i_mapping, chg))\n+\t\tif (hugepage_subpool_get_pages(spool, chg))\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \n \tspin_lock(&hugetlb_lock);\n@@ -1057,12 +1135,12 @@ static struct page *alloc_huge_page(struct vm_area_struct *vma,\n \tif (!page) {\n \t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n \t\tif (!page) {\n-\t\t\thugetlb_put_quota(inode->i_mapping, chg);\n+\t\t\thugepage_subpool_put_pages(spool, chg);\n \t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n \t\t}\n \t}\n \n-\tset_page_private(page, (unsigned long) mapping);\n+\tset_page_private(page, (unsigned long)spool);\n \n \tvma_commit_reservation(h, vma, addr);\n \n@@ -2083,6 +2161,7 @@ static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n {\n \tstruct hstate *h = hstate_vma(vma);\n \tstruct resv_map *reservations = vma_resv_map(vma);\n+\tstruct hugepage_subpool *spool = subpool_vma(vma);\n \tunsigned long reserve;\n \tunsigned long start;\n \tunsigned long end;\n@@ -2098,7 +2177,7 @@ static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n \n \t\tif (reserve) {\n \t\t\thugetlb_acct_memory(h, -reserve);\n-\t\t\thugetlb_put_quota(vma->vm_file->f_mapping, reserve);\n+\t\t\thugepage_subpool_put_pages(spool, reserve);\n \t\t}\n \t}\n }\n@@ -2331,7 +2410,7 @@ static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,\n \t *\/\n \taddress = address & huge_page_mask(h);\n \tpgoff = vma_hugecache_offset(h, vma, address);\n-\tmapping = (struct address_space *)page_private(page);\n+\tmapping = vma->vm_file->f_dentry->d_inode->i_mapping;\n \n \t\/*\n \t * Take the mapping lock for the duration of the table walk. As\n@@ -2884,11 +2963,12 @@ int hugetlb_reserve_pages(struct inode *inode,\n {\n \tlong ret, chg;\n \tstruct hstate *h = hstate_inode(inode);\n+\tstruct hugepage_subpool *spool = subpool_inode(inode);\n \n \t\/*\n \t * Only apply hugepage reservation if asked. At fault time, an\n \t * attempt will be made for VM_NORESERVE to allocate a page\n-\t * and filesystem quota without using reserves\n+\t * without using reserves\n \t *\/\n \tif (vm_flags & VM_NORESERVE)\n \t\treturn 0;\n@@ -2915,17 +2995,17 @@ int hugetlb_reserve_pages(struct inode *inode,\n \tif (chg < 0)\n \t\treturn chg;\n \n-\t\/* There must be enough filesystem quota for the mapping *\/\n-\tif (hugetlb_get_quota(inode->i_mapping, chg))\n+\t\/* There must be enough pages in the subpool for the mapping *\/\n+\tif (hugepage_subpool_get_pages(spool, chg))\n \t\treturn -ENOSPC;\n \n \t\/*\n \t * Check enough hugepages are available for the reservation.\n-\t * Hand back the quota if there are not\n+\t * Hand the pages back to the subpool if there are not\n \t *\/\n \tret = hugetlb_acct_memory(h, chg);\n \tif (ret < 0) {\n-\t\thugetlb_put_quota(inode->i_mapping, chg);\n+\t\thugepage_subpool_put_pages(spool, chg);\n \t\treturn ret;\n \t}\n \n@@ -2949,12 +3029,13 @@ void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)\n {\n \tstruct hstate *h = hstate_inode(inode);\n \tlong chg = region_truncate(&inode->i_mapping->private_list, offset);\n+\tstruct hugepage_subpool *spool = subpool_inode(inode);\n \n \tspin_lock(&inode->i_lock);\n \tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n \tspin_unlock(&inode->i_lock);\n \n-\thugetlb_put_quota(inode->i_mapping, (chg - freed));\n+\thugepage_subpool_put_pages(spool, (chg - freed));\n \thugetlb_acct_memory(h, -(chg - freed));\n }\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-1797","CWE_ID":"399","category":"security","commit_id":"0b79459b482e85cb7426aa7da683a9f2c97aeae1","commit_message":"From 0b79459b482e85cb7426aa7da683a9f2c97aeae1 Mon Sep 17 00:00:00 2001\nFrom: Andy Honig <ahonig@google.com>\nDate: Wed, 20 Feb 2013 14:48:10 -0800\nSubject: KVM: x86: Convert MSR_KVM_SYSTEM_TIME to use gfn_to_hva_cache\n functions (CVE-2013-1797)\n\nThere is a potential use after free issue with the handling of\nMSR_KVM_SYSTEM_TIME.  If the guest specifies a GPA in a movable or removable\nmemory such as frame buffers then KVM might continue to write to that\naddress even after it's removed via KVM_SET_USER_MEMORY_REGION.  KVM pins\nthe page in memory so it's unlikely to cause an issue, but if the user\nspace component re-purposes the memory previously used for the guest, then\nthe guest will be able to corrupt that memory.\n\nTested: Tested against kvmclock unit test\n\nSigned-off-by: Andrew Honig <ahonig@google.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\n---\n arch\/x86\/include\/asm\/kvm_host.h |  4 ++--\n arch\/x86\/kvm\/x86.c              | 47 ++++++++++++++++++-----------------------\n 2 files changed, 22 insertions(+), 29 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/kvm_host.h b\/arch\/x86\/include\/asm\/kvm_host.h\nindex 635a74d22409..4979778cc7fb 100644\n--- a\/arch\/x86\/include\/asm\/kvm_host.h\n+++ b\/arch\/x86\/include\/asm\/kvm_host.h\n@@ -414,8 +414,8 @@ struct kvm_vcpu_arch {\n \tgpa_t time;\n \tstruct pvclock_vcpu_time_info hv_clock;\n \tunsigned int hw_tsc_khz;\n-\tunsigned int time_offset;\n-\tstruct page *time_page;\n+\tstruct gfn_to_hva_cache pv_time;\n+\tbool pv_time_enabled;\n \t\/* set guest stopped flag in pvclock flags field *\/\n \tbool pvclock_set_guest_stopped_request;\n \ndiff --git a\/arch\/x86\/kvm\/x86.c b\/arch\/x86\/kvm\/x86.c\nindex 2ade60c25402..f19ac0aca60d 100644\n--- a\/arch\/x86\/kvm\/x86.c\n+++ b\/arch\/x86\/kvm\/x86.c\n@@ -1406,10 +1406,9 @@ static int kvm_guest_time_update(struct kvm_vcpu *v)\n \tunsigned long flags, this_tsc_khz;\n \tstruct kvm_vcpu_arch *vcpu = &v->arch;\n \tstruct kvm_arch *ka = &v->kvm->arch;\n-\tvoid *shared_kaddr;\n \ts64 kernel_ns, max_kernel_ns;\n \tu64 tsc_timestamp, host_tsc;\n-\tstruct pvclock_vcpu_time_info *guest_hv_clock;\n+\tstruct pvclock_vcpu_time_info guest_hv_clock;\n \tu8 pvclock_flags;\n \tbool use_master_clock;\n \n@@ -1463,7 +1462,7 @@ static int kvm_guest_time_update(struct kvm_vcpu *v)\n \n \tlocal_irq_restore(flags);\n \n-\tif (!vcpu->time_page)\n+\tif (!vcpu->pv_time_enabled)\n \t\treturn 0;\n \n \t\/*\n@@ -1525,12 +1524,12 @@ static int kvm_guest_time_update(struct kvm_vcpu *v)\n \t *\/\n \tvcpu->hv_clock.version += 2;\n \n-\tshared_kaddr = kmap_atomic(vcpu->time_page);\n-\n-\tguest_hv_clock = shared_kaddr + vcpu->time_offset;\n+\tif (unlikely(kvm_read_guest_cached(v->kvm, &vcpu->pv_time,\n+\t\t&guest_hv_clock, sizeof(guest_hv_clock))))\n+\t\treturn 0;\n \n \t\/* retain PVCLOCK_GUEST_STOPPED if set in guest copy *\/\n-\tpvclock_flags = (guest_hv_clock->flags & PVCLOCK_GUEST_STOPPED);\n+\tpvclock_flags = (guest_hv_clock.flags & PVCLOCK_GUEST_STOPPED);\n \n \tif (vcpu->pvclock_set_guest_stopped_request) {\n \t\tpvclock_flags |= PVCLOCK_GUEST_STOPPED;\n@@ -1543,12 +1542,9 @@ static int kvm_guest_time_update(struct kvm_vcpu *v)\n \n \tvcpu->hv_clock.flags = pvclock_flags;\n \n-\tmemcpy(shared_kaddr + vcpu->time_offset, &vcpu->hv_clock,\n-\t       sizeof(vcpu->hv_clock));\n-\n-\tkunmap_atomic(shared_kaddr);\n-\n-\tmark_page_dirty(v->kvm, vcpu->time >> PAGE_SHIFT);\n+\tkvm_write_guest_cached(v->kvm, &vcpu->pv_time,\n+\t\t\t\t&vcpu->hv_clock,\n+\t\t\t\tsizeof(vcpu->hv_clock));\n \treturn 0;\n }\n \n@@ -1837,10 +1833,7 @@ static int kvm_pv_enable_async_pf(struct kvm_vcpu *vcpu, u64 data)\n \n static void kvmclock_reset(struct kvm_vcpu *vcpu)\n {\n-\tif (vcpu->arch.time_page) {\n-\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n-\t\tvcpu->arch.time_page = NULL;\n-\t}\n+\tvcpu->arch.pv_time_enabled = false;\n }\n \n static void accumulate_steal_time(struct kvm_vcpu *vcpu)\n@@ -1947,6 +1940,7 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n \t\tbreak;\n \tcase MSR_KVM_SYSTEM_TIME_NEW:\n \tcase MSR_KVM_SYSTEM_TIME: {\n+\t\tu64 gpa_offset;\n \t\tkvmclock_reset(vcpu);\n \n \t\tvcpu->arch.time = data;\n@@ -1956,19 +1950,17 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n \t\tif (!(data & 1))\n \t\t\tbreak;\n \n-\t\t\/* ...but clean it before doing the actual write *\/\n-\t\tvcpu->arch.time_offset = data & ~(PAGE_MASK | 1);\n+\t\tgpa_offset = data & ~(PAGE_MASK | 1);\n \n \t\t\/* Check that the address is 32-byte aligned. *\/\n-\t\tif (vcpu->arch.time_offset &\n-\t\t\t\t(sizeof(struct pvclock_vcpu_time_info) - 1))\n+\t\tif (gpa_offset & (sizeof(struct pvclock_vcpu_time_info) - 1))\n \t\t\tbreak;\n \n-\t\tvcpu->arch.time_page =\n-\t\t\t\tgfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);\n-\n-\t\tif (is_error_page(vcpu->arch.time_page))\n-\t\t\tvcpu->arch.time_page = NULL;\n+\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n+\t\t     &vcpu->arch.pv_time, data & ~1ULL))\n+\t\t\tvcpu->arch.pv_time_enabled = false;\n+\t\telse\n+\t\t\tvcpu->arch.pv_time_enabled = true;\n \n \t\tbreak;\n \t}\n@@ -2972,7 +2964,7 @@ static int kvm_vcpu_ioctl_x86_set_xcrs(struct kvm_vcpu *vcpu,\n  *\/\n static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n {\n-\tif (!vcpu->arch.time_page)\n+\tif (!vcpu->arch.pv_time_enabled)\n \t\treturn -EINVAL;\n \tvcpu->arch.pvclock_set_guest_stopped_request = true;\n \tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n@@ -6723,6 +6715,7 @@ int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)\n \t\tgoto fail_free_wbinvd_dirty_mask;\n \n \tvcpu->arch.ia32_tsc_adjust_msr = 0x0;\n+\tvcpu->arch.pv_time_enabled = false;\n \tkvm_async_pf_hash_reset(vcpu);\n \tkvm_pmu_init(vcpu);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-13311","CWE_ID":"399","category":"security","commit_id":"bb812022d0bc12107db215c981cab0b1ccd73d91","commit_message":"From bb812022d0bc12107db215c981cab0b1ccd73d91 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 1 Jul 2019 19:53:22 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1623\n\n---\n wand\/mogrify.c | 20 +++++++++++++++++---\n 1 file changed, 17 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/wand\/mogrify.c b\/wand\/mogrify.c\nindex fca494d2c..430446a01 100644\n--- a\/wand\/mogrify.c\n+++ b\/wand\/mogrify.c\n@@ -7844,6 +7844,9 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n             clut_image=RemoveFirstImageFromList(images);\n             if (clut_image == (Image *) NULL)\n               {\n+                (void) ThrowMagickException(exception,GetMagickModule(),\n+                  OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+                image=DestroyImage(image);\n                 status=MagickFalse;\n                 break;\n               }\n@@ -7888,9 +7891,6 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n           }\n         if (LocaleCompare(\"compare\",option+1) == 0)\n           {\n-            const char\n-              *option;\n-\n             double\n               distortion;\n \n@@ -7911,6 +7911,9 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n             reconstruct_image=RemoveFirstImageFromList(images);\n             if (reconstruct_image == (Image *) NULL)\n               {\n+                (void) ThrowMagickException(exception,GetMagickModule(),\n+                  OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+                image=DestroyImage(image);\n                 status=MagickFalse;\n                 break;\n               }\n@@ -7966,6 +7969,9 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n             composite_image=RemoveFirstImageFromList(images);\n             if (composite_image == (Image *) NULL)\n               {\n+                (void) ThrowMagickException(exception,GetMagickModule(),\n+                  OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+                image=DestroyImage(image);\n                 status=MagickFalse;\n                 break;\n               }\n@@ -8197,6 +8203,9 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n             hald_image=RemoveFirstImageFromList(images);\n             if (hald_image == (Image *) NULL)\n               {\n+                (void) ThrowMagickException(exception,GetMagickModule(),\n+                  OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+                image=DestroyImage(image);\n                 status=MagickFalse;\n                 break;\n               }\n@@ -8227,11 +8236,16 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n             phase_image=RemoveFirstImageFromList(images);\n             if (phase_image == (Image *) NULL)\n               {\n+                (void) ThrowMagickException(exception,GetMagickModule(),\n+                  OptionError,\"ImageSequenceRequired\",\"`%s'\",option);\n+                magnitude_image=DestroyImage(magnitude_image);\n                 status=MagickFalse;\n                 break;\n               }\n             fourier_image=InverseFourierTransformImage(magnitude_image,\n               phase_image,*option == '-' ? MagickTrue : MagickFalse,exception);\n+            magnitude_image=DestroyImage(magnitude_image);\n+            phase_image=DestroyImage(phase_image);\n             if (fourier_image == (Image *) NULL)\n               break;\n             if (*images != (Image *) NULL)\n","owner":"ImageMagick","repo":"ImageMagick6","source":"cve"},{"CVE_ID":"CVE-2015-1792","CWE_ID":"399","category":"security","commit_id":"cd30f03ac5bf2962f44bd02ae8d88245dff2f12c","commit_message":"From cd30f03ac5bf2962f44bd02ae8d88245dff2f12c Mon Sep 17 00:00:00 2001\nFrom: \"Dr. Stephen Henson\" <steve@openssl.org>\nDate: Sun, 22 Dec 2013 00:35:29 +0000\nSubject: [PATCH] Canonicalise input in CMS_verify.\n\nIf content is detached and not binary mode translate the input to\nCRLF format. Before this change the input was verified verbatim\nwhich lead to a discrepancy between sign and verify.\n---\n crypto\/cms\/cms_smime.c | 94 ++++++++++++++++++++++++++++++++----------\n 1 file changed, 73 insertions(+), 21 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/cms\/cms_smime.c b\/crypto\/cms\/cms_smime.c\nindex 204595b908c..8f1aa38ccc5 100644\n--- a\/crypto\/cms\/cms_smime.c\n+++ b\/crypto\/cms\/cms_smime.c\n@@ -60,21 +60,28 @@\n #include \"cms_lcl.h\"\n #include \"asn1_locl.h\"\n \n-static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\n+static BIO *cms_get_text_bio(BIO *out, unsigned int flags)\n \t{\n-\tunsigned char buf[4096];\n-\tint r = 0, i;\n-\tBIO *tmpout = NULL;\n-\n+\tBIO *rbio;\n \tif (out == NULL)\n-\t\ttmpout = BIO_new(BIO_s_null());\n+\t\trbio = BIO_new(BIO_s_null());\n \telse if (flags & CMS_TEXT)\n \t\t{\n-\t\ttmpout = BIO_new(BIO_s_mem());\n-\t\tBIO_set_mem_eof_return(tmpout, 0);\n+\t\trbio = BIO_new(BIO_s_mem());\n+\t\tBIO_set_mem_eof_return(rbio, 0);\n \t\t}\n \telse\n-\t\ttmpout = out;\n+\t\trbio = out;\n+\treturn rbio;\n+\t}\n+\n+static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\n+\t{\n+\tunsigned char buf[4096];\n+\tint r = 0, i;\n+\tBIO *tmpout;\n+\n+\ttmpout = cms_get_text_bio(out, flags);\n \n \tif(!tmpout)\n \t\t{\n@@ -142,7 +149,7 @@ static void do_free_upto(BIO *f, BIO *upto)\n \t\t\tBIO_free(f);\n \t\t\tf = tbio;\n \t\t\t}\n-\t\twhile (f != upto);\n+\t\twhile (f && f != upto);\n \t\t}\n \telse\n \t\tBIO_free_all(f);\n@@ -323,7 +330,7 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,\n \tSTACK_OF(X509_CRL) *crls = NULL;\n \tX509 *signer;\n \tint i, scount = 0, ret = 0;\n-\tBIO *cmsbio = NULL, *tmpin = NULL;\n+\tBIO *cmsbio = NULL, *tmpin = NULL, *tmpout = NULL;\n \n \tif (!dcont && !check_content(cms))\n \t\treturn 0;\n@@ -406,15 +413,48 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,\n \t\t}\n \telse\n \t\ttmpin = dcont;\n-\t\t\n+\t\/* If not binary mode and detached generate digests by *writing*\n+\t * through the BIO. That makes it possible to canonicalise the\n+\t * input.\n+\t *\/\n+\tif (!(flags & SMIME_BINARY) && dcont)\n+\t\t{\n+\t\t\/* Create output BIO so we can either handle text or to\n+\t\t * ensure included content doesn't override detached content.\n+\t\t *\/\n+\t\ttmpout = cms_get_text_bio(out, flags);\n+\t\tif(!tmpout)\n+\t\t\t{\n+\t\t\tCMSerr(CMS_F_CMS_VERIFY,ERR_R_MALLOC_FAILURE);\n+\t\t\tgoto err;\n+\t\t\t}\n+\t\tcmsbio = CMS_dataInit(cms, tmpout);\n+\t\tif (!cmsbio)\n+\t\t\tgoto err;\n+\t\t\/* Don't use SMIME_TEXT for verify: it adds headers and\n+\t\t * we want to remove them.\n+\t\t *\/\n+\t\tSMIME_crlf_copy(dcont, cmsbio, flags & ~SMIME_TEXT);\n \n-\tcmsbio=CMS_dataInit(cms, tmpin);\n-\tif (!cmsbio)\n-\t\tgoto err;\n+\t\tif(flags & CMS_TEXT)\n+\t\t\t{\n+\t\t\tif (!SMIME_text(tmpout, out))\n+\t\t\t\t{\n+\t\t\t\tCMSerr(CMS_F_CMS_VERIFY,CMS_R_SMIME_TEXT_ERROR);\n+\t\t\t\tgoto err;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\telse\n+\t\t{\n+\t\tcmsbio=CMS_dataInit(cms, tmpin);\n+\t\tif (!cmsbio)\n+\t\t\tgoto err;\n \n-\tif (!cms_copy_content(out, cmsbio, flags))\n-\t\tgoto err;\n+\t\tif (!cms_copy_content(out, cmsbio, flags))\n+\t\t\tgoto err;\n \n+\t\t}\n \tif (!(flags & CMS_NO_CONTENT_VERIFY))\n \t\t{\n \t\tfor (i = 0; i < sk_CMS_SignerInfo_num(sinfos); i++)\n@@ -432,11 +472,23 @@ int CMS_verify(CMS_ContentInfo *cms, STACK_OF(X509) *certs,\n \tret = 1;\n \n \terr:\n-\t\n-\tif (dcont && (tmpin == dcont))\n-\t\tdo_free_upto(cmsbio, dcont);\n+\tif (!(flags & SMIME_BINARY) && dcont)\n+\t\t{\n+\t\tdo_free_upto(cmsbio, tmpout);\n+\t\tif (tmpin != dcont)\n+\t\t\tBIO_free(tmpin);\n+\t\t}\n \telse\n-\t\tBIO_free_all(cmsbio);\n+\t\t{\n+\n+\t\tif (dcont && (tmpin == dcont))\n+\t\t\tdo_free_upto(cmsbio, dcont);\n+\t\telse\n+\t\t\tBIO_free_all(cmsbio);\n+\t\t}\n+\n+\tif (tmpout && out != tmpout)\n+\t\tBIO_free_all(tmpout);\n \n \tif (cms_certs)\n \t\tsk_X509_pop_free(cms_certs, X509_free);\n","owner":"openssl","repo":"openssl","source":"cve"},{"CVE_ID":"CVE-2017-6499","CWE_ID":"399","category":"security","commit_id":"3358f060fc182551822576b2c0a8850faab5d543","commit_message":"From 3358f060fc182551822576b2c0a8850faab5d543 Mon Sep 17 00:00:00 2001\nFrom: Dirk Lemstra <dirk@git.imagemagick.org>\nDate: Thu, 9 Feb 2017 21:53:23 +0100\nSubject: [PATCH] Fixed memory leak when creating nested exceptions in\n Magick++.\n\n---\n ChangeLog                  |  4 ++++\n Magick++\/lib\/Exception.cpp | 14 ++++++++++----\n 2 files changed, 14 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 019b68c845..79d93e7f7b 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,7 @@\n+2017-02-09  6.9.7-8 Dirk Lemstra <dirk@lem.....org>\n+  * Fixed memory leak when creating nested exceptions in Magick++ (reference\n+    https:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=23&p=142634)\n+\n 2017-02-06  6.9.7-8 Cristy  <quetzlzacatenango@image...>\n   * Eliminate bogus assertion (reference\n     https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/372).\ndiff --git a\/Magick++\/lib\/Exception.cpp b\/Magick++\/lib\/Exception.cpp\nindex 92ca629707..8ef34bc0a0 100644\n--- a\/Magick++\/lib\/Exception.cpp\n+++ b\/Magick++\/lib\/Exception.cpp\n@@ -852,12 +852,18 @@ MagickPPExport void Magick::throwException(ExceptionInfo *exception_,\n             exception_->description) != 0))\n           {\n             if (nestedException == (Exception *) NULL)\n-              nestedException=createException(p);\n+              {\n+                nestedException=createException(p);\n+                q=nestedException;\n+              }\n             else\n               {\n-                q=createException(p);\n-                nestedException->nested(q);\n-                nestedException=q;\n+                Exception\n+                  *r;\n+\n+                r=createException(p);\n+                q->nested(r);\n+                q=r;\n               }\n           }\n       }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-11447","CWE_ID":"399","category":"security","commit_id":"8c10b9247509c0484b55330458846115131ec2ae","commit_message":"From 8c10b9247509c0484b55330458846115131ec2ae Mon Sep 17 00:00:00 2001\nFrom: Dirk Lemstra <dirk@git.imagemagick.org>\nDate: Mon, 19 Jun 2017 23:00:54 +0200\nSubject: [PATCH] Fixed potential memory leak.\n\n---\n coders\/screenshot.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/coders\/screenshot.c b\/coders\/screenshot.c\nindex b0d9c2e8e3..50b20546aa 100644\n--- a\/coders\/screenshot.c\n+++ b\/coders\/screenshot.c\n@@ -165,16 +165,16 @@ static Image *ReadSCREENSHOTImage(const ImageInfo *image_info,\n       screen->columns=(size_t) GetDeviceCaps(hDC,HORZRES);\n       screen->rows=(size_t) GetDeviceCaps(hDC,VERTRES);\n       screen->storage_class=DirectClass;\n+      if (image == (Image *) NULL)\n+        image=screen;\n+      else\n+        AppendImageToList(&image,screen);\n       status=SetImageExtent(screen,screen->columns,screen->rows);\n       if (status == MagickFalse)\n         {\n           InheritException(exception,&image->exception);\n           return(DestroyImageList(image));\n         }\n-      if (image == (Image *) NULL)\n-        image=screen;\n-      else\n-        AppendImageToList(&image,screen);\n \n       bitmapDC=CreateCompatibleDC(hDC);\n       if (bitmapDC == (HDC) NULL)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2014-8116","CWE_ID":"399","category":"security","commit_id":"d7cdad007c507e6c79f51f058dd77fab70ceb9f6","commit_message":"From d7cdad007c507e6c79f51f058dd77fab70ceb9f6 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Sat, 22 Nov 2014 23:57:44 +0000\nSubject: [PATCH] Stop reporting bad capabilities after the first few.\n\n---\n src\/readelf.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/readelf.c b\/src\/readelf.c\nindex dd4672b44..20fcb7fbe 100644\n--- a\/src\/readelf.c\n+++ b\/src\/readelf.c\n@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.104 2014\/10\/17 15:49:00 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.105 2014\/11\/22 16:04:29 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -919,6 +919,7 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \tElf32_Shdr sh32;\n \tElf64_Shdr sh64;\n \tint stripped = 1;\n+\tsize_t nbadcap = 0;\n \tvoid *nbuf;\n \toff_t noff, coff, name_off;\n \tuint64_t cap_hw1 = 0;\t\/* SunOS 5.x hardware capabilites *\/\n@@ -1007,6 +1008,8 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \t\t\t\tgoto skip;\n \t\t\t}\n \n+\t\t\tif (nbadcap > 5)\n+\t\t\t\tbreak;\n \t\t\tif (lseek(fd, xsh_offset, SEEK_SET) == (off_t)-1) {\n \t\t\t\tfile_badseek(ms);\n \t\t\t\treturn -1;\n@@ -1072,6 +1075,8 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \t\t\t\t\t    (unsigned long long)xcap_tag,\n \t\t\t\t\t    (unsigned long long)xcap_val) == -1)\n \t\t\t\t\t\treturn -1;\n+\t\t\t\t\tif (nbadcap++ > 2)\n+\t\t\t\t\t\tcoff = xsh_size;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t}\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2014-9420","CWE_ID":"399","category":"security","commit_id":"f54e18f1b831c92f6512d2eedb224cd63d607d3d","commit_message":"From f54e18f1b831c92f6512d2eedb224cd63d607d3d Mon Sep 17 00:00:00 2001\nFrom: Jan Kara <jack@suse.cz>\nDate: Mon, 15 Dec 2014 14:22:46 +0100\nSubject: isofs: Fix infinite looping over CE entries\n\nRock Ridge extensions define so called Continuation Entries (CE) which\ndefine where is further space with Rock Ridge data. Corrupted isofs\nimage can contain arbitrarily long chain of these, including a one\ncontaining loop and thus causing kernel to end in an infinite loop when\ntraversing these entries.\n\nLimit the traversal to 32 entries which should be more than enough space\nto store all the Rock Ridge data.\n\nReported-by: P J P <ppandit@redhat.com>\nCC: stable@vger.kernel.org\nSigned-off-by: Jan Kara <jack@suse.cz>\n---\n fs\/isofs\/rock.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/fs\/isofs\/rock.c b\/fs\/isofs\/rock.c\nindex f488bbae541a..bb63254ed848 100644\n--- a\/fs\/isofs\/rock.c\n+++ b\/fs\/isofs\/rock.c\n@@ -30,6 +30,7 @@ struct rock_state {\n \tint cont_size;\n \tint cont_extent;\n \tint cont_offset;\n+\tint cont_loops;\n \tstruct inode *inode;\n };\n \n@@ -73,6 +74,9 @@ static void init_rock_state(struct rock_state *rs, struct inode *inode)\n \trs->inode = inode;\n }\n \n+\/* Maximum number of Rock Ridge continuation entries *\/\n+#define RR_MAX_CE_ENTRIES 32\n+\n \/*\n  * Returns 0 if the caller should continue scanning, 1 if the scan must end\n  * and -ve on error.\n@@ -105,6 +109,8 @@ static int rock_continue(struct rock_state *rs)\n \t\t\tgoto out;\n \t\t}\n \t\tret = -EIO;\n+\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n+\t\t\tgoto out;\n \t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n \t\tif (bh) {\n \t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-4308","CWE_ID":"399","category":"security","commit_id":"78f1ddbb498283c2445c11b0dfa666424c301803","commit_message":"From 78f1ddbb498283c2445c11b0dfa666424c301803 Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Mon, 27 Jul 2009 23:09:47 -0400\nSubject: ext4: Avoid null pointer dereference when decoding EROFS w\/o a\n journal\n\nWe need to check to make sure a journal is present before checking the\njournal flags in ext4_decode_error().\n\nSigned-off-by: Eric Sesterhenn <eric.sesterhenn@lsexperts.de>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\n---\n fs\/ext4\/super.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/super.c b\/fs\/ext4\/super.c\nindex 8f4f079e6b9a..fe3f376b7df2 100644\n--- a\/fs\/ext4\/super.c\n+++ b\/fs\/ext4\/super.c\n@@ -344,7 +344,8 @@ static const char *ext4_decode_error(struct super_block *sb, int errno,\n \t\terrstr = \"Out of memory\";\n \t\tbreak;\n \tcase -EROFS:\n-\t\tif (!sb || EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT)\n+\t\tif (!sb || (EXT4_SB(sb)->s_journal &&\n+\t\t\t    EXT4_SB(sb)->s_journal->j_flags & JBD2_ABORT))\n \t\t\terrstr = \"Journal has aborted\";\n \t\telse\n \t\t\terrstr = \"Readonly filesystem\";\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-7300","CWE_ID":"399","category":"security","commit_id":"f02b007337e61436aaa0e81a86ad707b6d277378","commit_message":"From f02b007337e61436aaa0e81a86ad707b6d277378 Mon Sep 17 00:00:00 2001\nFrom: Adel Gadllah <adel.gadllah@gmail.com>\nDate: Sat, 27 Sep 2014 13:35:22 +0200\nSubject: [PATCH] shell-screenshot: Only allow one screenshot request at a time\n per sender\n\nWe currently allow infinite number of screenshot requests to be active at\nthe same time, which can \"dos\" the system and cause OOM.\n\nSo fail subsequent requests for the same sender when a screenshot operation\nis already running.\n\nhttps:\/\/bugzilla.gnome.org\/show_bug.cgi?id=737456\n---\n js\/ui\/screenshot.js    |  60 +++++++++++--\n src\/shell-screenshot.c | 195 ++++++++++++++++++++++-------------------\n src\/shell-screenshot.h |   5 +-\n 3 files changed, 159 insertions(+), 101 deletions(-)\n\n","diff_code":"diff --git a\/js\/ui\/screenshot.js b\/js\/ui\/screenshot.js\nindex 2f17729b9..81094dd20 100644\n--- a\/js\/ui\/screenshot.js\n+++ b\/js\/ui\/screenshot.js\n@@ -65,9 +65,41 @@ const ScreenshotService = new Lang.Class({\n         this._dbusImpl = Gio.DBusExportedObject.wrapJSObject(ScreenshotIface, this);\n         this._dbusImpl.export(Gio.DBus.session, '\/org\/gnome\/Shell\/Screenshot');\n \n+        this._screenShooter = new Map();\n+\n         Gio.DBus.session.own_name('org.gnome.Shell.Screenshot', Gio.BusNameOwnerFlags.REPLACE, null, null);\n     },\n \n+    _createScreenshot: function(invocation) {\n+        let sender = invocation.get_sender();\n+        if (this._screenShooter.has(sender)) {\n+            invocation.return_value(GLib.Variant.new('(bs)', [false, '']));\n+            return null;\n+        }\n+\n+        let shooter = new Shell.Screenshot();\n+        shooter._watchNameId =\n+                        Gio.bus_watch_name(Gio.BusType.SESSION, sender, 0, null,\n+                                           Lang.bind(this, this._onNameVanished));\n+\n+        this._screenShooter.set(sender, shooter);\n+\n+        return shooter;\n+    },\n+\n+    _onNameVanished: function(connection, name) {\n+        this._removeShooterForSender(name);\n+    },\n+\n+    _removeShooterForSender: function(sender) {\n+        let shooter = this._screenShooter.get(sender);\n+        if (!shooter)\n+            return;\n+\n+        Gio.bus_unwatch_name(shooter._watchNameId);\n+        this._screenShooter.delete(sender);\n+    },\n+\n     _checkArea: function(x, y, width, height) {\n         return x >= 0 && y >= 0 &&\n                width > 0 && height > 0 &&\n@@ -76,9 +108,15 @@ const ScreenshotService = new Lang.Class({\n     },\n \n     _onScreenshotComplete: function(obj, result, area, filenameUsed, flash, invocation) {\n-        if (flash && result) {\n-            let flashspot = new Flashspot(area);\n-            flashspot.fire();\n+        if (result) {\n+            if (flash) {\n+                let flashspot = new Flashspot(area);\n+                flashspot.fire(Lang.bind(this, function() {\n+                    this._removeShooterForSender(invocation.get_sender());\n+                }));\n+            }\n+            else\n+                this._removeShooterForSender(invocation.get_sender());\n         }\n \n         let retval = GLib.Variant.new('(bs)', [result, filenameUsed]);\n@@ -112,7 +150,9 @@ const ScreenshotService = new Lang.Class({\n                                             \"Invalid params\");\n             return;\n         }\n-        let screenshot = new Shell.Screenshot();\n+        let screenshot = this._createScreenshot(invocation);\n+        if (!screenshot)\n+            return;\n         screenshot.screenshot_area (x, y, width, height, filename,\n                                 Lang.bind(this, this._onScreenshotComplete,\n                                           flash, invocation));\n@@ -120,7 +160,9 @@ const ScreenshotService = new Lang.Class({\n \n     ScreenshotWindowAsync : function (params, invocation) {\n         let [include_frame, include_cursor, flash, filename] = params;\n-        let screenshot = new Shell.Screenshot();\n+        let screenshot = this._createScreenshot(invocation);\n+        if (!screenshot)\n+            return;\n         screenshot.screenshot_window (include_frame, include_cursor, filename,\n                                   Lang.bind(this, this._onScreenshotComplete,\n                                             flash, invocation));\n@@ -128,7 +170,9 @@ const ScreenshotService = new Lang.Class({\n \n     ScreenshotAsync : function (params, invocation) {\n         let [include_cursor, flash, filename] = params;\n-        let screenshot = new Shell.Screenshot();\n+        let screenshot = this._createScreenshot(invocation);\n+        if (!screenshot)\n+            return;\n         screenshot.screenshot(include_cursor, filename,\n                           Lang.bind(this, this._onScreenshotComplete,\n                                     flash, invocation));\n@@ -302,7 +346,7 @@ const Flashspot = new Lang.Class({\n         this.actor.set_position(area.x, area.y);\n     },\n \n-    fire: function() {\n+    fire: function(doneCallback) {\n         this.actor.show();\n         this.actor.opacity = 255;\n         Tweener.addTween(this.actor,\n@@ -310,6 +354,8 @@ const Flashspot = new Lang.Class({\n                            time: FLASHSPOT_ANIMATION_OUT_TIME,\n                            transition: 'easeOutQuad',\n                            onComplete: Lang.bind(this, function() {\n+                               if (doneCallback)\n+                                   doneCallback();\n                                this.destroy();\n                            })\n                          });\ndiff --git a\/src\/shell-screenshot.c b\/src\/shell-screenshot.c\nindex f637aa956..fc099a6e5 100644\n--- a\/src\/shell-screenshot.c\n+++ b\/src\/shell-screenshot.c\n@@ -23,12 +23,12 @@ struct _ShellScreenshot\n {\n   GObject parent_instance;\n \n-  ShellGlobal *global;\n+  ShellScreenshotPrivate *priv;\n };\n \n-\/* Used for async screenshot grabbing *\/\n-typedef struct _screenshot_data {\n-  ShellScreenshot  *screenshot;\n+struct _ShellScreenshotPrivate\n+{\n+  ShellGlobal *global;\n \n   char *filename;\n   char *filename_used;\n@@ -39,9 +39,9 @@ typedef struct _screenshot_data {\n   gboolean include_cursor;\n \n   ShellScreenshotCallback callback;\n-} _screenshot_data;\n+};\n \n-G_DEFINE_TYPE(ShellScreenshot, shell_screenshot, G_TYPE_OBJECT);\n+G_DEFINE_TYPE_WITH_PRIVATE (ShellScreenshot, shell_screenshot, G_TYPE_OBJECT);\n \n static void\n shell_screenshot_class_init (ShellScreenshotClass *screenshot_class)\n@@ -52,7 +52,8 @@ shell_screenshot_class_init (ShellScreenshotClass *screenshot_class)\n static void\n shell_screenshot_init (ShellScreenshot *screenshot)\n {\n-  screenshot->global = shell_global_get ();\n+  screenshot->priv = shell_screenshot_get_instance_private (screenshot);\n+  screenshot->priv->global = shell_global_get ();\n }\n \n static void\n@@ -60,18 +61,18 @@ on_screenshot_written (GObject *source,\n                        GAsyncResult *result,\n                        gpointer user_data)\n {\n-  _screenshot_data *screenshot_data = (_screenshot_data*) user_data;\n-  if (screenshot_data->callback)\n-    screenshot_data->callback (screenshot_data->screenshot,\n-                               g_simple_async_result_get_op_res_gboolean (G_SIMPLE_ASYNC_RESULT (result)),\n-                               &screenshot_data->screenshot_area,\n-                               screenshot_data->filename_used);\n-\n-  cairo_surface_destroy (screenshot_data->image);\n-  g_object_unref (screenshot_data->screenshot);\n-  g_free (screenshot_data->filename);\n-  g_free (screenshot_data->filename_used);\n-  g_free (screenshot_data);\n+  ShellScreenshot *screenshot = SHELL_SCREENSHOT (source);\n+  ShellScreenshotPrivate *priv = screenshot->priv;\n+\n+  if (priv->callback)\n+    priv->callback (screenshot,\n+                    g_simple_async_result_get_op_res_gboolean (G_SIMPLE_ASYNC_RESULT (result)),\n+                    &priv->screenshot_area,\n+                    priv->filename_used);\n+\n+  g_clear_pointer (&priv->image, cairo_surface_destroy);\n+  g_clear_pointer (&priv->filename, g_free);\n+  g_clear_pointer (&priv->filename_used, g_free);\n }\n \n \/* called in an I\/O thread *\/\n@@ -170,12 +171,15 @@ write_screenshot_thread (GSimpleAsyncResult *result,\n {\n   cairo_status_t status;\n   GOutputStream *stream;\n-  _screenshot_data *screenshot_data = g_async_result_get_user_data (G_ASYNC_RESULT (result));\n+  ShellScreenshot *screenshot = SHELL_SCREENSHOT (object);\n+  ShellScreenshotPrivate *priv;\n+\n+  g_assert (screenshot != NULL);\n \n-  g_assert (screenshot_data != NULL);\n+  priv = screenshot->priv;\n \n-  stream = prepare_write_stream (screenshot_data->filename,\n-                                 &screenshot_data->filename_used);\n+  stream = prepare_write_stream (priv->filename,\n+                                 &priv->filename_used);\n \n   if (stream == NULL)\n     status = CAIRO_STATUS_FILE_NOT_FOUND;\n@@ -183,10 +187,10 @@ write_screenshot_thread (GSimpleAsyncResult *result,\n     {\n       GdkPixbuf *pixbuf;\n \n-      pixbuf = gdk_pixbuf_get_from_surface (screenshot_data->image,\n+      pixbuf = gdk_pixbuf_get_from_surface (priv->image,\n                                             0, 0,\n-                                            cairo_image_surface_get_width (screenshot_data->image),\n-                                            cairo_image_surface_get_height (screenshot_data->image));\n+                                            cairo_image_surface_get_width (priv->image),\n+                                            cairo_image_surface_get_height (priv->image));\n \n       if (gdk_pixbuf_save_to_stream (pixbuf, stream, \"png\", NULL, NULL,\n                                     \"tEXt::Software\", \"gnome-screenshot\", NULL))\n@@ -204,7 +208,7 @@ write_screenshot_thread (GSimpleAsyncResult *result,\n }\n \n static void\n-do_grab_screenshot (_screenshot_data *screenshot_data,\n+do_grab_screenshot (ShellScreenshot *screenshot,\n                     int               x,\n                     int               y,\n                     int               width,\n@@ -215,16 +219,17 @@ do_grab_screenshot (_screenshot_data *screenshot_data,\n   CoglContext *context;\n   int stride;\n   guchar *data;\n+  ShellScreenshotPrivate *priv = screenshot->priv;\n \n   backend = clutter_get_default_backend ();\n   context = clutter_backend_get_cogl_context (backend);\n \n-  screenshot_data->image = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,\n-                                                       width, height);\n+  priv->image = cairo_image_surface_create (CAIRO_FORMAT_ARGB32,\n+                                            width, height);\n \n \n-  data = cairo_image_surface_get_data (screenshot_data->image);\n-  stride = cairo_image_surface_get_stride (screenshot_data->image);\n+  data = cairo_image_surface_get_data (priv->image);\n+  stride = cairo_image_surface_get_stride (priv->image);\n \n   bitmap = cogl_bitmap_new_for_data (context,\n                                      width,\n@@ -237,7 +242,7 @@ do_grab_screenshot (_screenshot_data *screenshot_data,\n                                             COGL_READ_PIXELS_COLOR_BUFFER,\n                                             bitmap);\n \n-  cairo_surface_mark_dirty (screenshot_data->image);\n+  cairo_surface_mark_dirty (priv->image);\n   cogl_object_unref (bitmap);\n }\n \n@@ -310,17 +315,19 @@ _draw_cursor_image (MetaCursorTracker     *tracker,\n \n static void\n grab_screenshot (ClutterActor *stage,\n-                 _screenshot_data *screenshot_data)\n+                 ShellScreenshot *screenshot)\n {\n-  MetaScreen *screen = shell_global_get_screen (screenshot_data->screenshot->global);\n+  MetaScreen *screen;\n   MetaCursorTracker *tracker;\n   int width, height;\n   GSimpleAsyncResult *result;\n   GSettings *settings;\n+  ShellScreenshotPrivate *priv = screenshot->priv;\n \n+  screen = shell_global_get_screen (priv->global);\n   meta_screen_get_size (screen, &width, &height);\n \n-  do_grab_screenshot (screenshot_data, 0, 0, width, height);\n+  do_grab_screenshot (screenshot, 0, 0, width, height);\n \n   if (meta_screen_get_n_monitors (screen) > 1)\n     {\n@@ -346,7 +353,7 @@ grab_screenshot (ClutterActor *stage,\n       cairo_region_xor (stage_region, screen_region);\n       cairo_region_destroy (screen_region);\n \n-      cr = cairo_create (screenshot_data->image);\n+      cr = cairo_create (priv->image);\n \n       for (i = 0; i < cairo_region_num_rectangles (stage_region); i++)\n         {\n@@ -360,41 +367,42 @@ grab_screenshot (ClutterActor *stage,\n       cairo_region_destroy (stage_region);\n     }\n \n-  screenshot_data->screenshot_area.x = 0;\n-  screenshot_data->screenshot_area.y = 0;\n-  screenshot_data->screenshot_area.width = width;\n-  screenshot_data->screenshot_area.height = height;\n+  priv->screenshot_area.x = 0;\n+  priv->screenshot_area.y = 0;\n+  priv->screenshot_area.width = width;\n+  priv->screenshot_area.height = height;\n \n   settings = g_settings_new (A11Y_APPS_SCHEMA);\n-  if (screenshot_data->include_cursor &&\n+  if (priv->include_cursor &&\n       !g_settings_get_boolean (settings, MAGNIFIER_ACTIVE_KEY))\n     {\n       tracker = meta_cursor_tracker_get_for_screen (screen);\n-      _draw_cursor_image (tracker, screenshot_data->image, screenshot_data->screenshot_area);\n+      _draw_cursor_image (tracker, priv->image, priv->screenshot_area);\n     }\n   g_object_unref (settings);\n \n-  g_signal_handlers_disconnect_by_func (stage, (void *)grab_screenshot, (gpointer)screenshot_data);\n+  g_signal_handlers_disconnect_by_func (stage, (void *)grab_screenshot, (gpointer)screenshot);\n \n-  result = g_simple_async_result_new (NULL, on_screenshot_written, (gpointer)screenshot_data, grab_screenshot);\n+  result = g_simple_async_result_new (G_OBJECT (screenshot), on_screenshot_written, NULL, grab_screenshot);\n   g_simple_async_result_run_in_thread (result, write_screenshot_thread, G_PRIORITY_DEFAULT, NULL);\n   g_object_unref (result);\n }\n \n static void\n grab_area_screenshot (ClutterActor *stage,\n-                      _screenshot_data *screenshot_data)\n+                      ShellScreenshot *screenshot)\n {\n   GSimpleAsyncResult *result;\n+  ShellScreenshotPrivate *priv = screenshot->priv;\n \n-  do_grab_screenshot (screenshot_data,\n-                      screenshot_data->screenshot_area.x,\n-                      screenshot_data->screenshot_area.y,\n-                      screenshot_data->screenshot_area.width,\n-                      screenshot_data->screenshot_area.height);\n+  do_grab_screenshot (screenshot,\n+                      priv->screenshot_area.x,\n+                      priv->screenshot_area.y,\n+                      priv->screenshot_area.width,\n+                      priv->screenshot_area.height);\n \n-  g_signal_handlers_disconnect_by_func (stage, (void *)grab_area_screenshot, (gpointer)screenshot_data);\n-  result = g_simple_async_result_new (NULL, on_screenshot_written, (gpointer)screenshot_data, grab_area_screenshot);\n+  g_signal_handlers_disconnect_by_func (stage, (void *)grab_area_screenshot, (gpointer)screenshot);\n+  result = g_simple_async_result_new (G_OBJECT (screenshot), on_screenshot_written, NULL, grab_area_screenshot);\n   g_simple_async_result_run_in_thread (result, write_screenshot_thread, G_PRIORITY_DEFAULT, NULL);\n   g_object_unref (result);\n }\n@@ -418,16 +426,21 @@ shell_screenshot_screenshot (ShellScreenshot *screenshot,\n                              ShellScreenshotCallback callback)\n {\n   ClutterActor *stage;\n-  _screenshot_data *data = g_new0 (_screenshot_data, 1);\n+  ShellScreenshotPrivate *priv = screenshot->priv;\n+\n+  if (priv->filename != NULL) {\n+    if (callback)\n+      callback (screenshot, FALSE, NULL, \"\");\n+    return;\n+  }\n \n-  data->screenshot = g_object_ref (screenshot);\n-  data->filename = g_strdup (filename);\n-  data->callback = callback;\n-  data->include_cursor = include_cursor;\n+  priv->filename = g_strdup (filename);\n+  priv->callback = callback;\n+  priv->include_cursor = include_cursor;\n \n-  stage = CLUTTER_ACTOR (shell_global_get_stage (screenshot->global));\n+  stage = CLUTTER_ACTOR (shell_global_get_stage (priv->global));\n \n-  g_signal_connect_after (stage, \"paint\", G_CALLBACK (grab_screenshot), (gpointer)data);\n+  g_signal_connect_after (stage, \"paint\", G_CALLBACK (grab_screenshot), (gpointer)screenshot);\n \n   clutter_actor_queue_redraw (stage);\n }\n@@ -457,19 +470,24 @@ shell_screenshot_screenshot_area (ShellScreenshot *screenshot,\n                                   ShellScreenshotCallback callback)\n {\n   ClutterActor *stage;\n-  _screenshot_data *data = g_new0 (_screenshot_data, 1);\n+  ShellScreenshotPrivate *priv = screenshot->priv;\n \n-  data->screenshot = g_object_ref (screenshot);\n-  data->filename = g_strdup (filename);\n-  data->screenshot_area.x = x;\n-  data->screenshot_area.y = y;\n-  data->screenshot_area.width = width;\n-  data->screenshot_area.height = height;\n-  data->callback = callback;\n+  if (priv->filename != NULL) {\n+    if (callback)\n+      callback (screenshot, FALSE, NULL, \"\");\n+    return;\n+  }\n \n-  stage = CLUTTER_ACTOR (shell_global_get_stage (screenshot->global));\n+  priv->filename = g_strdup (filename);\n+  priv->screenshot_area.x = x;\n+  priv->screenshot_area.y = y;\n+  priv->screenshot_area.width = width;\n+  priv->screenshot_area.height = height;\n+  priv->callback = callback;\n \n-  g_signal_connect_after (stage, \"paint\", G_CALLBACK (grab_area_screenshot), (gpointer)data);\n+  stage = CLUTTER_ACTOR (shell_global_get_stage (priv->global));\n+\n+  g_signal_connect_after (stage, \"paint\", G_CALLBACK (grab_area_screenshot), (gpointer)screenshot);\n \n   clutter_actor_queue_redraw (stage);\n }\n@@ -496,10 +514,9 @@ shell_screenshot_screenshot_window (ShellScreenshot *screenshot,\n {\n   GSimpleAsyncResult *result;\n   GSettings *settings;\n+  ShellScreenshotPrivate *priv = screenshot->priv;\n \n-  _screenshot_data *screenshot_data = g_new0 (_screenshot_data, 1);\n-\n-  MetaScreen *screen = shell_global_get_screen (screenshot->global);\n+  MetaScreen *screen = shell_global_get_screen (priv->global);\n   MetaCursorTracker *tracker;\n   MetaDisplay *display = meta_screen_get_display (screen);\n   MetaWindow *window = meta_display_get_focus_window (display);\n@@ -509,20 +526,14 @@ shell_screenshot_screenshot_window (ShellScreenshot *screenshot,\n   MetaRectangle rect;\n   cairo_rectangle_int_t clip;\n \n-  screenshot_data->screenshot = g_object_ref (screenshot);\n-  screenshot_data->filename = g_strdup (filename);\n-  screenshot_data->callback = callback;\n-\n-  if (!window)\n-    {\n-      screenshot_data->filename_used = g_strdup (\"\");\n-      result = g_simple_async_result_new (NULL, on_screenshot_written, (gpointer)screenshot_data, shell_screenshot_screenshot_window);\n-      g_simple_async_result_set_op_res_gboolean (result, FALSE);\n-      g_simple_async_result_complete (result);\n-      g_object_unref (result);\n+  if (priv->filename != NULL || !window) {\n+    if (callback)\n+      callback (screenshot, FALSE, NULL, \"\");\n+    return;\n+  }\n \n-      return;\n-    }\n+  priv->filename = g_strdup (filename);\n+  priv->callback = callback;\n \n   window_actor = CLUTTER_ACTOR (meta_window_get_compositor_private (window));\n   clutter_actor_get_position (window_actor, &actor_x, &actor_y);\n@@ -532,26 +543,26 @@ shell_screenshot_screenshot_window (ShellScreenshot *screenshot,\n   if (!include_frame)\n     meta_window_frame_rect_to_client_rect (window, &rect, &rect);\n \n-  screenshot_data->screenshot_area.x = rect.x;\n-  screenshot_data->screenshot_area.y = rect.y;\n+  priv->screenshot_area.x = rect.x;\n+  priv->screenshot_area.y = rect.y;\n   clip.x = rect.x - (gint) actor_x;\n   clip.y = rect.y - (gint) actor_y;\n \n-  clip.width = screenshot_data->screenshot_area.width = rect.width;\n-  clip.height = screenshot_data->screenshot_area.height = rect.height;\n+  clip.width = priv->screenshot_area.width = rect.width;\n+  clip.height = priv->screenshot_area.height = rect.height;\n \n   stex = META_SHAPED_TEXTURE (meta_window_actor_get_texture (META_WINDOW_ACTOR (window_actor)));\n-  screenshot_data->image = meta_shaped_texture_get_image (stex, &clip);\n+  priv->image = meta_shaped_texture_get_image (stex, &clip);\n \n   settings = g_settings_new (A11Y_APPS_SCHEMA);\n   if (include_cursor && !g_settings_get_boolean (settings, MAGNIFIER_ACTIVE_KEY))\n     {\n       tracker = meta_cursor_tracker_get_for_screen (screen);\n-      _draw_cursor_image (tracker, screenshot_data->image, screenshot_data->screenshot_area);\n+      _draw_cursor_image (tracker, priv->image, priv->screenshot_area);\n     }\n   g_object_unref (settings);\n \n-  result = g_simple_async_result_new (NULL, on_screenshot_written, (gpointer)screenshot_data, shell_screenshot_screenshot_window);\n+  result = g_simple_async_result_new (G_OBJECT (screenshot), on_screenshot_written, NULL, shell_screenshot_screenshot_window);\n   g_simple_async_result_run_in_thread (result, write_screenshot_thread, G_PRIORITY_DEFAULT, NULL);\n   g_object_unref (result);\n }\ndiff --git a\/src\/shell-screenshot.h b\/src\/shell-screenshot.h\nindex 76925f31c..0b8ab1c61 100644\n--- a\/src\/shell-screenshot.h\n+++ b\/src\/shell-screenshot.h\n@@ -11,8 +11,9 @@\n  *\n  *\/\n \n-typedef struct _ShellScreenshot      ShellScreenshot;\n-typedef struct _ShellScreenshotClass ShellScreenshotClass;\n+typedef struct _ShellScreenshot         ShellScreenshot;\n+typedef struct _ShellScreenshotPrivate  ShellScreenshotPrivate;\n+typedef struct _ShellScreenshotClass    ShellScreenshotClass;\n \n #define SHELL_TYPE_SCREENSHOT              (shell_screenshot_get_type ())\n #define SHELL_SCREENSHOT(object)           (G_TYPE_CHECK_INSTANCE_CAST ((object), SHELL_TYPE_SCREENSHOT, ShellScreenshot))\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2008-3275","CWE_ID":"399","category":"security","commit_id":"d70b67c8bc72ee23b55381bd6a884f4796692f77","commit_message":"From d70b67c8bc72ee23b55381bd6a884f4796692f77 Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <mszeredi@suse.cz>\nDate: Wed, 2 Jul 2008 21:30:15 +0200\nSubject: [patch] vfs: fix lookup on deleted directory\n\nLookup can install a child dentry for a deleted directory.  This keeps\nthe directory dentry alive, and the inode pinned in the cache and on\ndisk, even after all external references have gone away.\n\nThis isn't a big problem normally, since memory pressure or umount\nwill clear out the directory dentry and its children, releasing the\ninode.  But for UBIFS this causes problems because its orphan area can\noverflow.\n\nFix this by returning ENOENT for all lookups on a S_DEAD directory\nbefore creating a child dentry.\n\nThanks to Zoltan Sogor for noticing this while testing UBIFS, and\nArtem for the excellent analysis of the problem and testing.\n\nReported-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>\nTested-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n fs\/namei.c | 19 +++++++++++++++++--\n 1 file changed, 17 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/namei.c b\/fs\/namei.c\nindex 01e67dddcc3d..3b26a240ade9 100644\n--- a\/fs\/namei.c\n+++ b\/fs\/namei.c\n@@ -519,7 +519,14 @@ static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, s\n \t *\/\n \tresult = d_lookup(parent, name);\n \tif (!result) {\n-\t\tstruct dentry * dentry = d_alloc(parent, name);\n+\t\tstruct dentry *dentry;\n+\n+\t\t\/* Don't create child dentry for a dead directory. *\/\n+\t\tresult = ERR_PTR(-ENOENT);\n+\t\tif (IS_DEADDIR(dir))\n+\t\t\tgoto out_unlock;\n+\n+\t\tdentry = d_alloc(parent, name);\n \t\tresult = ERR_PTR(-ENOMEM);\n \t\tif (dentry) {\n \t\t\tresult = dir->i_op->lookup(dir, dentry, nd);\n@@ -528,6 +535,7 @@ static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, s\n \t\t\telse\n \t\t\t\tresult = dentry;\n \t\t}\n+out_unlock:\n \t\tmutex_unlock(&dir->i_mutex);\n \t\treturn result;\n \t}\n@@ -1317,7 +1325,14 @@ static struct dentry *__lookup_hash(struct qstr *name,\n \n \tdentry = cached_lookup(base, name, nd);\n \tif (!dentry) {\n-\t\tstruct dentry *new = d_alloc(base, name);\n+\t\tstruct dentry *new;\n+\n+\t\t\/* Don't create child dentry for a dead directory. *\/\n+\t\tdentry = ERR_PTR(-ENOENT);\n+\t\tif (IS_DEADDIR(inode))\n+\t\t\tgoto out;\n+\n+\t\tnew = d_alloc(base, name);\n \t\tdentry = ERR_PTR(-ENOMEM);\n \t\tif (!new)\n \t\t\tgoto out;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2016-3156","CWE_ID":"399","category":"security","commit_id":"fbd40ea0180a2d328c5adc61414dc8bab9335ce2","commit_message":"From fbd40ea0180a2d328c5adc61414dc8bab9335ce2 Mon Sep 17 00:00:00 2001\nFrom: \"David S. Miller\" <davem@davemloft.net>\nDate: Sun, 13 Mar 2016 23:28:00 -0400\nSubject: [PATCH] ipv4: Don't do expensive useless work during inetdev destroy.\n\nWhen an inetdev is destroyed, every address assigned to the interface\nis removed.  And in this scenerio we do two pointless things which can\nbe very expensive if the number of assigned interfaces is large:\n\n1) Address promotion.  We are deleting all addresses, so there is no\n   point in doing this.\n\n2) A full nf conntrack table purge for every address.  We only need to\n   do this once, as is already caught by the existing\n   masq_dev_notifier so masq_inet_event() can skip this.\n\nReported-by: Solar Designer <solar@openwall.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\nTested-by: Cyrill Gorcunov <gorcunov@openvz.org>\n---\n net\/ipv4\/devinet.c                          |  4 ++++\n net\/ipv4\/fib_frontend.c                     |  4 ++++\n net\/ipv4\/netfilter\/nf_nat_masquerade_ipv4.c | 12 ++++++++++--\n 3 files changed, 18 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/devinet.c b\/net\/ipv4\/devinet.c\nindex 65e76a48382c6..e333bc86bd39d 100644\n--- a\/net\/ipv4\/devinet.c\n+++ b\/net\/ipv4\/devinet.c\n@@ -334,6 +334,9 @@ static void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\n \n \tASSERT_RTNL();\n \n+\tif (in_dev->dead)\n+\t\tgoto no_promotions;\n+\n \t\/* 1. Deleting primary ifaddr forces deletion all secondaries\n \t * unless alias promotion is set\n \t **\/\n@@ -380,6 +383,7 @@ static void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap,\n \t\t\tfib_del_ifaddr(ifa, ifa1);\n \t}\n \n+no_promotions:\n \t\/* 2. Unlink it *\/\n \n \t*ifap = ifa1->ifa_next;\ndiff --git a\/net\/ipv4\/fib_frontend.c b\/net\/ipv4\/fib_frontend.c\nindex 4734475930601..21add552e56a2 100644\n--- a\/net\/ipv4\/fib_frontend.c\n+++ b\/net\/ipv4\/fib_frontend.c\n@@ -922,6 +922,9 @@ void fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)\n \t\tsubnet = 1;\n \t}\n \n+\tif (in_dev->dead)\n+\t\tgoto no_promotions;\n+\n \t\/* Deletion is more complicated than add.\n \t * We should take care of not to delete too much :-)\n \t *\n@@ -997,6 +1000,7 @@ void fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)\n \t\t}\n \t}\n \n+no_promotions:\n \tif (!(ok & BRD_OK))\n \t\tfib_magic(RTM_DELROUTE, RTN_BROADCAST, ifa->ifa_broadcast, 32, prim);\n \tif (subnet && ifa->ifa_prefixlen < 31) {\ndiff --git a\/net\/ipv4\/netfilter\/nf_nat_masquerade_ipv4.c b\/net\/ipv4\/netfilter\/nf_nat_masquerade_ipv4.c\nindex c6eb42100e9a7..ea91058b5f6f4 100644\n--- a\/net\/ipv4\/netfilter\/nf_nat_masquerade_ipv4.c\n+++ b\/net\/ipv4\/netfilter\/nf_nat_masquerade_ipv4.c\n@@ -108,10 +108,18 @@ static int masq_inet_event(struct notifier_block *this,\n \t\t\t   unsigned long event,\n \t\t\t   void *ptr)\n {\n-\tstruct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;\n+\tstruct in_device *idev = ((struct in_ifaddr *)ptr)->ifa_dev;\n \tstruct netdev_notifier_info info;\n \n-\tnetdev_notifier_info_init(&info, dev);\n+\t\/* The masq_dev_notifier will catch the case of the device going\n+\t * down.  So if the inetdev is dead and being destroyed we have\n+\t * no work to do.  Otherwise this is an individual address removal\n+\t * and we have to perform the flush.\n+\t *\/\n+\tif (idev->dead)\n+\t\treturn NOTIFY_DONE;\n+\n+\tnetdev_notifier_info_init(&info, idev->dev);\n \treturn masq_device_event(this, event, &info);\n }\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-5011","CWE_ID":"399","category":"security","commit_id":"7164a1c34d18831ac61c6744ad14ce916d389b3f","commit_message":"From 7164a1c34d18831ac61c6744ad14ce916d389b3f Mon Sep 17 00:00:00 2001\nFrom: Karel Zak <kzak@redhat.com>\nDate: Thu, 7 Jul 2016 14:22:41 +0200\nSubject: libblkid: ignore extended partition at zero offset\n\nIf the extended partition starts at zero LBA then MBR is interpreted\nas EBR and all is recursively parsed... result is out-of-memory.\n\n MBR --extended-partition--> EBR --> MBR --> ENB --> MBR ...\n\nNote that such PT is not possible to create by standard partitioning\ntools.\n\nAddresses: https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=1349536\nSigned-off-by: Karel Zak <kzak@redhat.com>\n---\n libblkid\/src\/partitions\/dos.c | 14 ++++++++++++--\n 1 file changed, 12 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libblkid\/src\/partitions\/dos.c b\/libblkid\/src\/partitions\/dos.c\nindex 9bba32f3b..e79f124f8 100644\n--- a\/libblkid\/src\/partitions\/dos.c\n+++ b\/libblkid\/src\/partitions\/dos.c\n@@ -47,6 +47,12 @@ static int parse_dos_extended(blkid_probe pr, blkid_parttable tab,\n \tint ct_nodata = 0;\t\/* count ext.partitions without data partitions *\/\n \tint i;\n \n+\tDBG(LOWPROBE, ul_debug(\"parse EBR [start=%d, size=%d]\", ex_start\/ssf, ex_size\/ssf));\n+\tif (ex_start == 0) {\n+\t\tDBG(LOWPROBE, ul_debug(\"Bad offset in primary extended partition -- ignore\"));\n+\t\treturn 0;\n+\t}\n+\n \twhile (1) {\n \t\tstruct dos_partition *p, *p0;\n \t\tuint32_t start, size;\n@@ -116,8 +122,12 @@ static int parse_dos_extended(blkid_probe pr, blkid_parttable tab,\n \t\t\tstart = dos_partition_get_start(p) * ssf;\n \t\t\tsize = dos_partition_get_size(p) * ssf;\n \n-\t\t\tif (size && is_extended(p))\n-\t\t\t\tbreak;\n+\t\t\tif (size && is_extended(p)) {\n+\t\t\t\tif (start == 0)\n+\t\t\t\t\tDBG(LOWPROBE, ul_debug(\"#%d: EBR link offset is zero -- ignore\", i + 1));\n+\t\t\t\telse\n+\t\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\tif (i == 4)\n \t\t\tgoto leave;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-10810","CWE_ID":"399","category":"security","commit_id":"385aee965b4e4c36551c362a334378d2985b722a","commit_message":"From 385aee965b4e4c36551c362a334378d2985b722a Mon Sep 17 00:00:00 2001\nFrom: Gerd Hoffmann <kraxel@redhat.com>\nDate: Thu, 6 Apr 2017 17:59:40 +0200\nSubject: drm\/virtio: don't leak bo on drm_gem_object_init failure\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nReported-by: \u674e\u5f3a <liqiang6-s@360.cn>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nLink: http:\/\/patchwork.freedesktop.org\/patch\/msgid\/20170406155941.458-1-kraxel@redhat.com\n---\n drivers\/gpu\/drm\/virtio\/virtgpu_object.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/gpu\/drm\/virtio\/virtgpu_object.c b\/drivers\/gpu\/drm\/virtio\/virtgpu_object.c\nindex 1483daebe057..6f66b7347cd0 100644\n--- a\/drivers\/gpu\/drm\/virtio\/virtgpu_object.c\n+++ b\/drivers\/gpu\/drm\/virtio\/virtgpu_object.c\n@@ -81,8 +81,10 @@ int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n \t\treturn -ENOMEM;\n \tsize = roundup(size, PAGE_SIZE);\n \tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n-\tif (ret != 0)\n+\tif (ret != 0) {\n+\t\tkfree(bo);\n \t\treturn ret;\n+\t}\n \tbo->dumb = false;\n \tvirtio_gpu_init_ttm_placement(bo, pinned);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-2189","CWE_ID":"399","category":"security","commit_id":"f875bae065334907796da12523f9df85c89f5712","commit_message":"From f875bae065334907796da12523f9df85c89f5712 Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Sun, 29 Nov 2009 22:25:28 +0000\nSubject: net: Automatically allocate per namespace data.\n\nTo get the full benefit of batched network namespace cleanup netowrk\ndevice deletion needs to be performed by the generic code.  When\nusing register_pernet_gen_device and freeing the data in exit_net\nit is impossible to delay allocation until after exit_net has called\nas the device uninit methods are no longer safe.\n\nTo correct this, and to simplify working with per network namespace data\nI have moved allocation and deletion of per network namespace data into\nthe network namespace core.  The core now frees the data only after\nall of the network namespace exit routines have run.\n\nNow it is only required to set the new fields .id and .size\nin the pernet_operations structure if you want network namespace\ndata to be managed for you automatically.\n\nThis makes the current register_pernet_gen_device and\nregister_pernet_gen_subsys routines unnecessary.  For the moment\nI have left them as compatibility wrappers in net_namespace.h\nThey will be removed once all of the users have been updated.\n\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/net_namespace.h |  28 ++++++-\n net\/core\/net_namespace.c    | 188 ++++++++++++++++++++++++--------------------\n 2 files changed, 126 insertions(+), 90 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/net_namespace.h b\/include\/net\/net_namespace.h\nindex d69b4796030f..080774b9dbf3 100644\n--- a\/include\/net\/net_namespace.h\n+++ b\/include\/net\/net_namespace.h\n@@ -236,6 +236,8 @@ struct pernet_operations {\n \tstruct list_head list;\n \tint (*init)(struct net *net);\n \tvoid (*exit)(struct net *net);\n+\tint *id;\n+\tsize_t size;\n };\n \n \/*\n@@ -259,12 +261,30 @@ struct pernet_operations {\n  *\/\n extern int register_pernet_subsys(struct pernet_operations *);\n extern void unregister_pernet_subsys(struct pernet_operations *);\n-extern int register_pernet_gen_subsys(int *id, struct pernet_operations *);\n-extern void unregister_pernet_gen_subsys(int id, struct pernet_operations *);\n extern int register_pernet_device(struct pernet_operations *);\n extern void unregister_pernet_device(struct pernet_operations *);\n-extern int register_pernet_gen_device(int *id, struct pernet_operations *);\n-extern void unregister_pernet_gen_device(int id, struct pernet_operations *);\n+\n+static inline int register_pernet_gen_subsys(int *id, struct pernet_operations *ops)\n+{\n+\tops->id = id;\n+\treturn register_pernet_subsys(ops);\n+}\n+\n+static inline void unregister_pernet_gen_subsys(int id, struct pernet_operations *ops)\n+{\n+\treturn unregister_pernet_subsys(ops);\n+}\n+\n+static inline int register_pernet_gen_device(int *id, struct pernet_operations *ops)\n+{\n+\tops->id = id;\n+\treturn register_pernet_device(ops);\n+}\n+\n+static inline void unregister_pernet_gen_device(int id, struct pernet_operations *ops)\n+{\n+\treturn unregister_pernet_device(ops);\n+}\n \n struct ctl_path;\n struct ctl_table;\ndiff --git a\/net\/core\/net_namespace.c b\/net\/core\/net_namespace.c\nindex a42caa2b909b..9679ad292da9 100644\n--- a\/net\/core\/net_namespace.c\n+++ b\/net\/core\/net_namespace.c\n@@ -43,13 +43,40 @@ static void unregister_netdevices(struct net *net, struct list_head *list)\n \t}\n }\n \n+static int ops_init(const struct pernet_operations *ops, struct net *net)\n+{\n+\tint err;\n+\tif (ops->id && ops->size) {\n+\t\tvoid *data = kzalloc(ops->size, GFP_KERNEL);\n+\t\tif (!data)\n+\t\t\treturn -ENOMEM;\n+\n+\t\terr = net_assign_generic(net, *ops->id, data);\n+\t\tif (err) {\n+\t\t\tkfree(data);\n+\t\t\treturn err;\n+\t\t}\n+\t}\n+\tif (ops->init)\n+\t\treturn ops->init(net);\n+\treturn 0;\n+}\n+\n+static void ops_free(const struct pernet_operations *ops, struct net *net)\n+{\n+\tif (ops->id && ops->size) {\n+\t\tint id = *ops->id;\n+\t\tkfree(net_generic(net, id));\n+\t}\n+}\n+\n \/*\n  * setup_net runs the initializers for the network namespace object.\n  *\/\n static __net_init int setup_net(struct net *net)\n {\n \t\/* Must be called with net_mutex held *\/\n-\tstruct pernet_operations *ops;\n+\tconst struct pernet_operations *ops, *saved_ops;\n \tint error = 0;\n \n \tatomic_set(&net->count, 1);\n@@ -59,11 +86,9 @@ static __net_init int setup_net(struct net *net)\n #endif\n \n \tlist_for_each_entry(ops, &pernet_list, list) {\n-\t\tif (ops->init) {\n-\t\t\terror = ops->init(net);\n-\t\t\tif (error < 0)\n-\t\t\t\tgoto out_undo;\n-\t\t}\n+\t\terror = ops_init(ops, net);\n+\t\tif (error < 0)\n+\t\t\tgoto out_undo;\n \t}\n out:\n \treturn error;\n@@ -72,6 +97,7 @@ out_undo:\n \t\/* Walk through the list backwards calling the exit functions\n \t * for the pernet modules whose init functions did not fail.\n \t *\/\n+\tsaved_ops = ops;\n \tlist_for_each_entry_continue_reverse(ops, &pernet_list, list) {\n \t\tif (ops->exit)\n \t\t\tops->exit(net);\n@@ -83,6 +109,9 @@ out_undo:\n \t\t\trtnl_unlock();\n \t\t}\n \t}\n+\tops = saved_ops;\n+\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n+\t\tops_free(ops, net);\n \n \trcu_barrier();\n \tgoto out;\n@@ -175,7 +204,7 @@ static LIST_HEAD(cleanup_list);  \/* Must hold cleanup_list_lock to touch *\/\n \n static void cleanup_net(struct work_struct *work)\n {\n-\tstruct pernet_operations *ops;\n+\tconst struct pernet_operations *ops;\n \tstruct net *net, *tmp;\n \tLIST_HEAD(net_kill_list);\n \n@@ -214,6 +243,13 @@ static void cleanup_net(struct work_struct *work)\n \t\t\trtnl_unlock();\n \t\t}\n \t}\n+\t\/* Free the net generic variables *\/\n+\tlist_for_each_entry_reverse(ops, &pernet_list, list) {\n+\t\tif (ops->size && ops->id) {\n+\t\t\tlist_for_each_entry(net, &net_kill_list, cleanup_list)\n+\t\t\t\tops_free(ops, net);\n+\t\t}\n+\t}\n \n \tmutex_unlock(&net_mutex);\n \n@@ -309,16 +345,16 @@ static int __init net_ns_init(void)\n pure_initcall(net_ns_init);\n \n #ifdef CONFIG_NET_NS\n-static int register_pernet_operations(struct list_head *list,\n-\t\t\t\t      struct pernet_operations *ops)\n+static int __register_pernet_operations(struct list_head *list,\n+\t\t\t\t\tstruct pernet_operations *ops)\n {\n \tstruct net *net, *undo_net;\n \tint error;\n \n \tlist_add_tail(&ops->list, list);\n-\tif (ops->init) {\n+\tif (ops->init || (ops->id && ops->size)) {\n \t\tfor_each_net(net) {\n-\t\t\terror = ops->init(net);\n+\t\t\terror = ops_init(ops, net);\n \t\t\tif (error)\n \t\t\t\tgoto out_undo;\n \t\t}\n@@ -336,10 +372,18 @@ out_undo:\n \t\t}\n \t}\n undone:\n+\tif (ops->size && ops->id) {\n+\t\tfor_each_net(undo_net) {\n+\t\t\tif (net_eq(undo_net, net))\n+\t\t\t\tgoto freed;\n+\t\t\tops_free(ops, undo_net);\n+\t\t}\n+\t}\n+freed:\n \treturn error;\n }\n \n-static void unregister_pernet_operations(struct pernet_operations *ops)\n+static void __unregister_pernet_operations(struct pernet_operations *ops)\n {\n \tstruct net *net;\n \n@@ -347,27 +391,66 @@ static void unregister_pernet_operations(struct pernet_operations *ops)\n \tif (ops->exit)\n \t\tfor_each_net(net)\n \t\t\tops->exit(net);\n+\tif (ops->id && ops->size)\n+\t\tfor_each_net(net)\n+\t\t\tops_free(ops, net);\n }\n \n #else\n \n-static int register_pernet_operations(struct list_head *list,\n-\t\t\t\t      struct pernet_operations *ops)\n+static int __register_pernet_operations(struct list_head *list,\n+\t\t\t\t\tstruct pernet_operations *ops)\n {\n-\tif (ops->init == NULL)\n-\t\treturn 0;\n-\treturn ops->init(&init_net);\n+\tint err = 0;\n+\terr = ops_init(ops, &init_net);\n+\tif (err)\n+\t\tops_free(ops, &init_net);\n+\treturn err;\n+\t\n }\n \n-static void unregister_pernet_operations(struct pernet_operations *ops)\n+static void __unregister_pernet_operations(struct pernet_operations *ops)\n {\n \tif (ops->exit)\n \t\tops->exit(&init_net);\n+\tops_free(ops, &init_net);\n }\n-#endif\n+\n+#endif \/* CONFIG_NET_NS *\/\n \n static DEFINE_IDA(net_generic_ids);\n \n+static int register_pernet_operations(struct list_head *list,\n+\t\t\t\t      struct pernet_operations *ops)\n+{\n+\tint error;\n+\n+\tif (ops->id) {\n+again:\n+\t\terror = ida_get_new_above(&net_generic_ids, 1, ops->id);\n+\t\tif (error < 0) {\n+\t\t\tif (error == -EAGAIN) {\n+\t\t\t\tida_pre_get(&net_generic_ids, GFP_KERNEL);\n+\t\t\t\tgoto again;\n+\t\t\t}\n+\t\t\treturn error;\n+\t\t}\n+\t}\n+\terror = __register_pernet_operations(list, ops);\n+\tif (error && ops->id)\n+\t\tida_remove(&net_generic_ids, *ops->id);\n+\n+\treturn error;\n+}\n+\n+static void unregister_pernet_operations(struct pernet_operations *ops)\n+{\n+\t\n+\t__unregister_pernet_operations(ops);\n+\tif (ops->id)\n+\t\tida_remove(&net_generic_ids, *ops->id);\n+}\n+\n \/**\n  *      register_pernet_subsys - register a network namespace subsystem\n  *\t@ops:  pernet operations structure for the subsystem\n@@ -414,38 +497,6 @@ void unregister_pernet_subsys(struct pernet_operations *module)\n }\n EXPORT_SYMBOL_GPL(unregister_pernet_subsys);\n \n-int register_pernet_gen_subsys(int *id, struct pernet_operations *ops)\n-{\n-\tint rv;\n-\n-\tmutex_lock(&net_mutex);\n-again:\n-\trv = ida_get_new_above(&net_generic_ids, 1, id);\n-\tif (rv < 0) {\n-\t\tif (rv == -EAGAIN) {\n-\t\t\tida_pre_get(&net_generic_ids, GFP_KERNEL);\n-\t\t\tgoto again;\n-\t\t}\n-\t\tgoto out;\n-\t}\n-\trv = register_pernet_operations(first_device, ops);\n-\tif (rv < 0)\n-\t\tida_remove(&net_generic_ids, *id);\n-out:\n-\tmutex_unlock(&net_mutex);\n-\treturn rv;\n-}\n-EXPORT_SYMBOL_GPL(register_pernet_gen_subsys);\n-\n-void unregister_pernet_gen_subsys(int id, struct pernet_operations *ops)\n-{\n-\tmutex_lock(&net_mutex);\n-\tunregister_pernet_operations(ops);\n-\tida_remove(&net_generic_ids, id);\n-\tmutex_unlock(&net_mutex);\n-}\n-EXPORT_SYMBOL_GPL(unregister_pernet_gen_subsys);\n-\n \/**\n  *      register_pernet_device - register a network namespace device\n  *\t@ops:  pernet operations structure for the subsystem\n@@ -477,30 +528,6 @@ int register_pernet_device(struct pernet_operations *ops)\n }\n EXPORT_SYMBOL_GPL(register_pernet_device);\n \n-int register_pernet_gen_device(int *id, struct pernet_operations *ops)\n-{\n-\tint error;\n-\tmutex_lock(&net_mutex);\n-again:\n-\terror = ida_get_new_above(&net_generic_ids, 1, id);\n-\tif (error) {\n-\t\tif (error == -EAGAIN) {\n-\t\t\tida_pre_get(&net_generic_ids, GFP_KERNEL);\n-\t\t\tgoto again;\n-\t\t}\n-\t\tgoto out;\n-\t}\n-\terror = register_pernet_operations(&pernet_list, ops);\n-\tif (error)\n-\t\tida_remove(&net_generic_ids, *id);\n-\telse if (first_device == &pernet_list)\n-\t\tfirst_device = &ops->list;\n-out:\n-\tmutex_unlock(&net_mutex);\n-\treturn error;\n-}\n-EXPORT_SYMBOL_GPL(register_pernet_gen_device);\n-\n \/**\n  *      unregister_pernet_device - unregister a network namespace netdevice\n  *\t@ops: pernet operations structure to manipulate\n@@ -520,17 +547,6 @@ void unregister_pernet_device(struct pernet_operations *ops)\n }\n EXPORT_SYMBOL_GPL(unregister_pernet_device);\n \n-void unregister_pernet_gen_device(int id, struct pernet_operations *ops)\n-{\n-\tmutex_lock(&net_mutex);\n-\tif (&ops->list == first_device)\n-\t\tfirst_device = first_device->next;\n-\tunregister_pernet_operations(ops);\n-\tida_remove(&net_generic_ids, id);\n-\tmutex_unlock(&net_mutex);\n-}\n-EXPORT_SYMBOL_GPL(unregister_pernet_gen_device);\n-\n static void net_generic_release(struct rcu_head *rcu)\n {\n \tstruct net_generic *ng;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-8116","CWE_ID":"399","category":"security","commit_id":"b4c01141e5367f247b84dcaf6aefbb4e741842b8","commit_message":"From b4c01141e5367f247b84dcaf6aefbb4e741842b8 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Sat, 22 Nov 2014 16:04:29 +0000\nSubject: [PATCH] - limit the number of program and section header number of\n sections to be   processed to avoid excessive processing time. - if a bad\n note is found, return 0 to stop processing immediately.\n\n---\n src\/elfclass.h | 24 ++++++++++++++++--------\n src\/readelf.c  | 20 ++++++++++++++++----\n 2 files changed, 32 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/src\/elfclass.h b\/src\/elfclass.h\nindex 010958a42..0826ce321 100644\n--- a\/src\/elfclass.h\n+++ b\/src\/elfclass.h\n@@ -35,10 +35,12 @@\n \tswitch (type) {\n #ifdef ELFCORE\n \tcase ET_CORE:\n+\t\tphnum = elf_getu16(swap, elfhdr.e_phnum);\n+\t\tif (phnum > MAX_PHNUM)\n+\t\t\treturn toomany(ms, \"program\", phnum);\n \t\tflags |= FLAGS_IS_CORE;\n \t\tif (dophn_core(ms, clazz, swap, fd,\n-\t\t    (off_t)elf_getu(swap, elfhdr.e_phoff),\n-\t\t    elf_getu16(swap, elfhdr.e_phnum), \n+\t\t    (off_t)elf_getu(swap, elfhdr.e_phoff), phnum,\n \t\t    (size_t)elf_getu16(swap, elfhdr.e_phentsize),\n \t\t    fsize, &flags) == -1)\n \t\t\treturn -1;\n@@ -46,18 +48,24 @@\n #endif\n \tcase ET_EXEC:\n \tcase ET_DYN:\n+\t\tphnum = elf_getu16(swap, elfhdr.e_phnum);\n+\t\tif (phnum > MAX_PHNUM)\n+\t\t\treturn toomany(ms, \"program\", phnum);\n+\t\tshnum = elf_getu16(swap, elfhdr.e_shnum);\n+\t\tif (shnum > MAX_SHNUM)\n+\t\t\treturn toomany(ms, \"section\", shnum);\n \t\tif (dophn_exec(ms, clazz, swap, fd,\n-\t\t    (off_t)elf_getu(swap, elfhdr.e_phoff),\n-\t\t    elf_getu16(swap, elfhdr.e_phnum), \n+\t\t    (off_t)elf_getu(swap, elfhdr.e_phoff), phnum,\n \t\t    (size_t)elf_getu16(swap, elfhdr.e_phentsize),\n-\t\t    fsize, &flags, elf_getu16(swap, elfhdr.e_shnum))\n-\t\t    == -1)\n+\t\t    fsize, &flags, shnum) == -1)\n \t\t\treturn -1;\n \t\t\/*FALLTHROUGH*\/\n \tcase ET_REL:\n+\t\tshnum = elf_getu16(swap, elfhdr.e_shnum);\n+\t\tif (shnum > MAX_SHNUM)\n+\t\t\treturn toomany(ms, \"section\", shnum);\n \t\tif (doshn(ms, clazz, swap, fd,\n-\t\t    (off_t)elf_getu(swap, elfhdr.e_shoff),\n-\t\t    elf_getu16(swap, elfhdr.e_shnum),\n+\t\t    (off_t)elf_getu(swap, elfhdr.e_shoff), shnum,\n \t\t    (size_t)elf_getu16(swap, elfhdr.e_shentsize),\n \t\t    fsize, &flags, elf_getu16(swap, elfhdr.e_machine),\n \t\t    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)\ndiff --git a\/src\/readelf.c b\/src\/readelf.c\nindex 9ebdebd61..dd4672b44 100644\n--- a\/src\/readelf.c\n+++ b\/src\/readelf.c\n@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.103 2014\/05\/02 02:25:10 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.104 2014\/10\/17 15:49:00 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -60,6 +60,18 @@ private uint16_t getu16(int, uint16_t);\n private uint32_t getu32(int, uint32_t);\n private uint64_t getu64(int, uint64_t);\n \n+#define MAX_PHNUM\t256\n+#define\tMAX_SHNUM\t1024\n+\n+private int\n+toomany(struct magic_set *ms, const char *name, uint16_t num)\n+{\n+\tif (file_printf(ms, \", too many %s header sections (%u)\", name, num\n+\t    ) == -1)\n+\t\treturn -1;\n+\treturn 0;\n+}\n+\n private uint16_t\n getu16(int swap, uint16_t value)\n {\n@@ -499,13 +511,13 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \tif (namesz & 0x80000000) {\n \t    (void)file_printf(ms, \", bad note name size 0x%lx\",\n \t\t(unsigned long)namesz);\n-\t    return offset;\n+\t    return 0;\n \t}\n \n \tif (descsz & 0x80000000) {\n \t    (void)file_printf(ms, \", bad note description size 0x%lx\",\n \t\t(unsigned long)descsz);\n-\t    return offset;\n+\t    return 0;\n \t}\n \n \n@@ -1240,7 +1252,7 @@ file_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,\n \tint flags = 0;\n \tElf32_Ehdr elf32hdr;\n \tElf64_Ehdr elf64hdr;\n-\tuint16_t type;\n+\tuint16_t type, phnum, shnum;\n \n \tif (ms->flags & (MAGIC_MIME|MAGIC_APPLE))\n \t\treturn 0;\n","owner":"glensc","repo":"file","source":"cve"},{"CVE_ID":"CVE-2016-7421","CWE_ID":"399","category":"security","commit_id":"d251157ac1928191af851d199a9ff255d330bec9","commit_message":"From d251157ac1928191af851d199a9ff255d330bec9 Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Wed, 14 Sep 2016 15:09:12 +0530\nSubject: [PATCH] scsi: pvscsi: limit process IO loop to ring size\n\nVmware Paravirtual SCSI emulator while processing IO requests\ncould run into an infinite loop if 'pvscsi_ring_pop_req_descr'\nalways returned positive value. Limit IO loop to the ring size.\n\nCc: qemu-stable@nongnu.org\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-Id: <1473845952-30785-1-git-send-email-ppandit@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n hw\/scsi\/vmw_pvscsi.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/scsi\/vmw_pvscsi.c b\/hw\/scsi\/vmw_pvscsi.c\nindex babac5a..a5ce7de 100644\n--- a\/hw\/scsi\/vmw_pvscsi.c\n+++ b\/hw\/scsi\/vmw_pvscsi.c\n@@ -247,8 +247,11 @@ static hwaddr\n pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n {\n     uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n+    uint32_t ring_size = PVSCSI_MAX_NUM_PAGES_REQ_RING\n+                            * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n \n-    if (ready_ptr != mgr->consumed_ptr) {\n+    if (ready_ptr != mgr->consumed_ptr\n+        && ready_ptr - mgr->consumed_ptr < ring_size) {\n         uint32_t next_ready_ptr =\n             mgr->consumed_ptr++ & mgr->txr_len_mask;\n         uint32_t next_ready_page =\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-13296","CWE_ID":"399","category":"security","commit_id":"ce08a3691a8ac29125e29fc41967b3737fa3f425","commit_message":"From ce08a3691a8ac29125e29fc41967b3737fa3f425 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 18 Jun 2019 15:17:06 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1604\n\n---\n MagickWand\/operation.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/MagickWand\/operation.c b\/MagickWand\/operation.c\nindex f53cf6dca7..2edf8d4b87 100644\n--- a\/MagickWand\/operation.c\n+++ b\/MagickWand\/operation.c\n@@ -3868,7 +3868,10 @@ WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n           reconstruct_image=RemoveFirstImageFromList(&_images);\n           \/* FUTURE - produce Exception, rather than silent fail *\/\n           if (reconstruct_image == (Image *) NULL)\n-            break;\n+            { \n+              image=DestroyImage(image);\n+              break;\n+            }\n           metric=UndefinedErrorMetric;\n           option=GetImageOption(_image_info,\"metric\");\n           if (option != (const char *) NULL)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-7156","CWE_ID":"399","category":"security","commit_id":"49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8","commit_message":"From 49adc5d3f8c6bb75e55ebfeab109c5c37dea65e8 Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Tue, 6 Sep 2016 02:20:43 +0530\nSubject: [PATCH] scsi: pvscsi: limit loop to fetch SG list\n\nIn PVSCSI paravirtual SCSI bus, pvscsi_convert_sglist can take a very\nlong time or go into an infinite loop due to two different bugs:\n\n1) the request descriptor data length is defined to be 64 bit. While\nbuilding SG list from a request descriptor, it gets truncated to 32bit\nin routine 'pvscsi_convert_sglist'. This could lead to an infinite loop\nsituation large 'dataLen' values when data_length is cast to uint32_t and\nchunk_size becomes always zero.  Fix this by removing the incorrect cast.\n\n2) pvscsi_get_next_sg_elem can be called arbitrarily many times if the\nelement has a zero length.  Get out of the loop early when this happens,\nby introducing an upper limit on the number of SG list elements.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-Id: <1473108643-12983-1-git-send-email-ppandit@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n hw\/scsi\/vmw_pvscsi.c | 11 ++++++-----\n 1 file changed, 6 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/hw\/scsi\/vmw_pvscsi.c b\/hw\/scsi\/vmw_pvscsi.c\nindex 4245c15..babac5a 100644\n--- a\/hw\/scsi\/vmw_pvscsi.c\n+++ b\/hw\/scsi\/vmw_pvscsi.c\n@@ -40,6 +40,8 @@\n #define PVSCSI_MAX_DEVS                   (64)\n #define PVSCSI_MSIX_NUM_VECTORS           (1)\n \n+#define PVSCSI_MAX_SG_ELEM                2048\n+\n #define PVSCSI_MAX_CMD_DATA_WORDS \\\n     (sizeof(PVSCSICmdDescSetupRings)\/sizeof(uint32_t))\n \n@@ -628,17 +630,16 @@ pvscsi_queue_pending_descriptor(PVSCSIState *s, SCSIDevice **d,\n static void\n pvscsi_convert_sglist(PVSCSIRequest *r)\n {\n-    int chunk_size;\n+    uint32_t chunk_size, elmcnt = 0;\n     uint64_t data_length = r->req.dataLen;\n     PVSCSISGState sg = r->sg;\n-    while (data_length) {\n-        while (!sg.resid) {\n+    while (data_length && elmcnt < PVSCSI_MAX_SG_ELEM) {\n+        while (!sg.resid && elmcnt++ < PVSCSI_MAX_SG_ELEM) {\n             pvscsi_get_next_sg_elem(&sg);\n             trace_pvscsi_convert_sglist(r->req.context, r->sg.dataAddr,\n                                         r->sg.resid);\n         }\n-        assert(data_length > 0);\n-        chunk_size = MIN((unsigned) data_length, sg.resid);\n+        chunk_size = MIN(data_length, sg.resid);\n         if (chunk_size) {\n             qemu_sglist_add(&r->sgl, sg.dataAddr, chunk_size);\n         }\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-6003","CWE_ID":"399","category":"security","commit_id":"c593ae84cfcde8fea45787e53950e0ac71e9ca97","commit_message":"From c593ae84cfcde8fea45787e53950e0ac71e9ca97 Mon Sep 17 00:00:00 2001\nFrom: Nikos Mavrogiannopoulos <nmav@redhat.com>\nDate: Thu, 4 Jan 2018 10:52:05 +0100\nSubject: _asn1_decode_simple_ber: restrict the levels of recursion to 3\n\nOn indefinite string decoding, setting a maximum level of recursions\nprotects the BER decoder from a stack exhaustion due to large amounts\nof recursion.\n\nSigned-off-by: Nikos Mavrogiannopoulos <nmav@redhat.com>\n---\n lib\/decoding.c | 21 +++++++++++++++++++--\n 1 file changed, 19 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/lib\/decoding.c b\/lib\/decoding.c\nindex 2240b09..0ee35d3 100644\n--- a\/lib\/decoding.c\n+++ b\/lib\/decoding.c\n@@ -45,6 +45,13 @@\n \n #define DECODE_FLAG_HAVE_TAG 1\n #define DECODE_FLAG_INDEFINITE (1<<1)\n+\/* On indefinite string decoding, allow this maximum levels\n+ * of recursion. Allowing infinite recursion, makes the BER\n+ * decoder susceptible to stack exhaustion due to that recursion.\n+ *\/\n+#define DECODE_FLAG_LEVEL1 (1<<2)\n+#define DECODE_FLAG_LEVEL2 (1<<3)\n+#define DECODE_FLAG_LEVEL3 (1<<4)\n \n #define DECR_LEN(l, s) do { \\\n \t  l -= s; \\\n@@ -2216,7 +2223,8 @@ _asn1_decode_simple_ber (unsigned int etype, const unsigned char *der,\n     }\n \n   \/* indefinite constructed *\/\n-  if (((dflags & DECODE_FLAG_INDEFINITE) || class == ASN1_CLASS_STRUCTURED) && ETYPE_IS_STRING(etype))\n+  if ((((dflags & DECODE_FLAG_INDEFINITE) || class == ASN1_CLASS_STRUCTURED) && ETYPE_IS_STRING(etype)) &&\n+      !(dflags & DECODE_FLAG_LEVEL3))\n     {\n       len_len = 1;\n \n@@ -2236,8 +2244,17 @@ _asn1_decode_simple_ber (unsigned int etype, const unsigned char *der,\n       do\n         {\n           unsigned tmp_len;\n+          unsigned flags = DECODE_FLAG_HAVE_TAG;\n+\n+          if (dflags & DECODE_FLAG_LEVEL1)\n+                flags |= DECODE_FLAG_LEVEL2;\n+          else if (dflags & DECODE_FLAG_LEVEL2)\n+\t\tflags |= DECODE_FLAG_LEVEL3;\n+\t  else\n+\t\tflags |= DECODE_FLAG_LEVEL1;\n \n-          result = asn1_decode_simple_ber(etype, p, der_len, &out, &out_len, &tmp_len);\n+          result = _asn1_decode_simple_ber(etype, p, der_len, &out, &out_len, &tmp_len,\n+                                           flags);\n           if (result != ASN1_SUCCESS)\n             {\n               warn();\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4130","CWE_ID":"399","category":"security","commit_id":"53488f0275d6c8a121af49f7ac817d09ce68090d","commit_message":"From 53488f0275d6c8a121af49f7ac817d09ce68090d Mon Sep 17 00:00:00 2001\nFrom: David Gibson <david@gibson.dropbear.id.au>\nDate: Fri, 5 Jul 2013 17:11:46 +1000\nSubject: Use RING_FOREACH_SAFE in red_channel.c functions which are missing it\n\nCurrently, both red_channel_pipes_add_type() and\nred_channel_pipes_add_empty_msg() use plaing RING_FOREACH() which is not\nsafe versus removals from the ring within the loop body.\n\nAlthough it's rare, such a removal can occur in both cases.  In the case\nof red_channel_pipes_add_type() we have:\n    red_channel_pipes_add_type()\n    -> red_channel_client_pipe_add_type()\n        -> red_channel_client_push()\n\nAnd in the case of red_channel_client_pipes_add_empty_msg() we have:\n    red_channel_client_pipes_add_empty_msg()\n    -> red_channel_client_pipe_add_empty_msg()\n        -> red_channel_client_push()\n\nBut red_channel_client_push() can cause a removal from the clients ring if\na network error occurs:\n    red_channel_client_push()\n    -> red_channel_client_send()\n        -> red_peer_handle_outgoing()\n            -> handler->cb->on_error callback\n            =  red_channel_client_default_peer_on_error()\n                -> red_channel_client_disconnect()\n                    -> red_channel_remove_client()\n                        -> ring_remove()\n\nWhen this error path does occur, the assertion in RING_FOREACH()'s\nring_next() trips, and the process containing the spice server is aborted.\ni.e. your whole VM dies, as a result of an unfortunately timed network\nerror on the spice channel.\n\nPlease apply.\n\nSigned-off-by: David Gibson <dgibson@redhat.com>\n---\n server\/red_channel.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/server\/red_channel.c b\/server\/red_channel.c\nindex c0b1781..8742008 100644\n--- a\/server\/red_channel.c\n+++ b\/server\/red_channel.c\n@@ -1572,9 +1572,9 @@ void red_channel_client_pipe_add_type(RedChannelClient *rcc, int pipe_item_type)\n \n void red_channel_pipes_add_type(RedChannel *channel, int pipe_item_type)\n {\n-    RingItem *link;\n+    RingItem *link, *next;\n \n-    RING_FOREACH(link, &channel->clients) {\n+    RING_FOREACH_SAFE(link, next, &channel->clients) {\n         red_channel_client_pipe_add_type(\n             SPICE_CONTAINEROF(link, RedChannelClient, channel_link),\n             pipe_item_type);\n@@ -1593,9 +1593,9 @@ void red_channel_client_pipe_add_empty_msg(RedChannelClient *rcc, int msg_type)\n \n void red_channel_pipes_add_empty_msg(RedChannel *channel, int msg_type)\n {\n-    RingItem *link;\n+    RingItem *link, *next;\n \n-    RING_FOREACH(link, &channel->clients) {\n+    RING_FOREACH_SAFE(link, next, &channel->clients) {\n         red_channel_client_pipe_add_empty_msg(\n             SPICE_CONTAINEROF(link, RedChannelClient, channel_link),\n             msg_type);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-2015","CWE_ID":"399","category":"security","commit_id":"0e9a9a1ad619e7e987815d20262d36a2f95717ca","commit_message":"From 0e9a9a1ad619e7e987815d20262d36a2f95717ca Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Thu, 27 Dec 2012 01:42:50 -0500\nSubject: ext4: avoid hang when mounting non-journal filesystems with orphan\n list\n\nWhen trying to mount a file system which does not contain a journal,\nbut which does have a orphan list containing an inode which needs to\nbe truncated, the mount call with hang forever in\next4_orphan_cleanup() because ext4_orphan_del() will return\nimmediately without removing the inode from the orphan list, leading\nto an uninterruptible loop in kernel code which will busy out one of\nthe CPU's on the system.\n\nThis can be trivially reproduced by trying to mount the file system\nfound in tests\/f_orphan_extents_inode\/image.gz from the e2fsprogs\nsource tree.  If a malicious user were to put this on a USB stick, and\nmount it on a Linux desktop which has automatic mounts enabled, this\ncould be considered a potential denial of service attack.  (Not a big\ndeal in practice, but professional paranoids worry about such things,\nand have even been known to allocate CVE numbers for such problems.)\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nReviewed-by: Zheng Liu <wenqing.lz@taobao.com>\nCc: stable@vger.kernel.org\n---\n fs\/ext4\/namei.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/namei.c b\/fs\/ext4\/namei.c\nindex cac448282331..8990165346ee 100644\n--- a\/fs\/ext4\/namei.c\n+++ b\/fs\/ext4\/namei.c\n@@ -2648,7 +2648,8 @@ int ext4_orphan_del(handle_t *handle, struct inode *inode)\n \tstruct ext4_iloc iloc;\n \tint err = 0;\n \n-\tif (!EXT4_SB(inode->i_sb)->s_journal)\n+\tif ((!EXT4_SB(inode->i_sb)->s_journal) &&\n+\t    !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS))\n \t\treturn 0;\n \n \tmutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9745","CWE_ID":"399","category":"security","commit_id":"df14e6c0b9592cbb24d5381dfc6106b14f915e75","commit_message":"From df14e6c0b9592cbb24d5381dfc6106b14f915e75 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Simon=20B=C3=BCnzli?= <zeniko@gmail.com>\nDate: Wed, 19 Feb 2014 08:42:52 +0100\nSubject: Fix Savannah bug #41590.\n\n* src\/type1\/t1load.c (parse_encoding): Protect against invalid\nnumber.\n---\n ChangeLog          | 7 +++++++\n src\/type1\/t1load.c | 7 +++++++\n 2 files changed, 14 insertions(+)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 945962f..c1d5aea 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -4,6 +4,13 @@\n \n \t* src\/autofit\/hbshim.c: Include `afglobal.h' and `aftypes.h'.\n \n+2014-02-19  Simon B\u00fcnzli  <zeniko@gmail.com>\n+\n+\tFix Savannah bug #41590.\n+\n+\t* src\/type1\/t1load.c (parse_encoding): Protect against invalid\n+\tnumber.\n+\n 2014-02-12  Dave Arnold  <darnold@adobe.com>\n \n \t[cff] Optimize by using `FT_MulDiv'.\ndiff --git a\/src\/type1\/t1load.c b\/src\/type1\/t1load.c\nindex d4171d9..e2da956 100644\n--- a\/src\/type1\/t1load.c\n+++ b\/src\/type1\/t1load.c\n@@ -1274,6 +1274,13 @@\n           {\n             charcode = (FT_Int)T1_ToInt( parser );\n             T1_Skip_Spaces( parser );\n+\n+            \/* protect against invalid charcode *\/\n+            if ( cur == parser->root.cursor )\n+            {\n+              parser->root.error = FT_THROW( Unknown_File_Format );\n+              return;\n+            }\n           }\n \n           cur = parser->root.cursor;\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-2636","CWE_ID":"399","category":"security","commit_id":"c085c49920b2f900ba716b4ca1c1a55ece9872cc","commit_message":"From c085c49920b2f900ba716b4ca1c1a55ece9872cc Mon Sep 17 00:00:00 2001\nFrom: Mathias Krause <minipli@googlemail.com>\nDate: Sat, 9 Mar 2013 05:52:19 +0000\nSubject: [PATCH] bridge: fix mdb info leaks\n\nThe bridging code discloses heap and stack bytes via the RTM_GETMDB\nnetlink interface and via the notify messages send to group RTNLGRP_MDB\nafer a successful add\/del.\n\nFix both cases by initializing all unset members\/padding bytes with\nmemset(0).\n\nCc: Stephen Hemminger <stephen@networkplumber.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/bridge\/br_mdb.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/net\/bridge\/br_mdb.c b\/net\/bridge\/br_mdb.c\nindex 9f97b850fc651..ee79f3f20383c 100644\n--- a\/net\/bridge\/br_mdb.c\n+++ b\/net\/bridge\/br_mdb.c\n@@ -80,6 +80,7 @@ static int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,\n \t\t\t\tport = p->port;\n \t\t\t\tif (port) {\n \t\t\t\t\tstruct br_mdb_entry e;\n+\t\t\t\t\tmemset(&e, 0, sizeof(e));\n \t\t\t\t\te.ifindex = port->dev->ifindex;\n \t\t\t\t\te.state = p->state;\n \t\t\t\t\tif (p->addr.proto == htons(ETH_P_IP))\n@@ -136,6 +137,7 @@ static int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n \t\t\t\tbreak;\n \n \t\t\tbpm = nlmsg_data(nlh);\n+\t\t\tmemset(bpm, 0, sizeof(*bpm));\n \t\t\tbpm->ifindex = dev->ifindex;\n \t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n \t\t\t\tgoto out;\n@@ -171,6 +173,7 @@ static int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n \t\treturn -EMSGSIZE;\n \n \tbpm = nlmsg_data(nlh);\n+\tmemset(bpm, 0, sizeof(*bpm));\n \tbpm->family  = AF_BRIDGE;\n \tbpm->ifindex = dev->ifindex;\n \tnest = nla_nest_start(skb, MDBA_MDB);\n@@ -228,6 +231,7 @@ void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n {\n \tstruct br_mdb_entry entry;\n \n+\tmemset(&entry, 0, sizeof(entry));\n \tentry.ifindex = port->dev->ifindex;\n \tentry.addr.proto = group->proto;\n \tentry.addr.u.ip4 = group->u.ip4;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-12995","CWE_ID":"399","category":"security","commit_id":"3a76fd7c95fced2c2f8c8148a9055c3a542eff29","commit_message":"From 3a76fd7c95fced2c2f8c8148a9055c3a542eff29 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Fri, 10 Feb 2017 18:52:17 -0800\nSubject: [PATCH] CVE-2017-12995\/Check for DNS compression pointers that don't\n point backwards.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThis is what BIND 9.11.0-P2 does; it not only detects pointers that\nloop, as \"point backwards\" means \"point before anything we've processed\nso far, including what we're processing right now\", so the pointer can't\npoint to itself (as that's what we're processing right now).\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).\n\nAlso, add some infinite-pointer-loop captures.\n\nMore checks should be done.  We might, for example, want to make sure\nthe upper 2 bits of the label length\/pointer byte are 00 or 11, and that\nif we encounter a pointer and jump backwards to what we think is a label\nthe label ends before the beginning of the last label we processed, to\nmake sure the pointer doesn't point backwards into the *middle* of a\nlabel, and also make sure the entire name is <= 255 bytes long.\n---\n print-domain.c        |  37 +++++++++++++++++++------------------\n tests\/TESTLIST        |   9 +++++++++\n tests\/dns-zlip-1.out  |   1 +\n tests\/dns-zlip-1.pcap | Bin 0 -> 117 bytes\n tests\/dns-zlip-2.out  |   1 +\n tests\/dns-zlip-2.pcap | Bin 0 -> 117 bytes\n tests\/dns-zlip-3.out  |   1 +\n tests\/dns-zlip-3.pcap | Bin 0 -> 187 bytes\n tests\/dns_fwdptr.out  |   2 ++\n tests\/dns_fwdptr.pcap | Bin 0 -> 63247 bytes\n 10 files changed, 33 insertions(+), 18 deletions(-)\n create mode 100644 tests\/dns-zlip-1.out\n create mode 100644 tests\/dns-zlip-1.pcap\n create mode 100644 tests\/dns-zlip-2.out\n create mode 100644 tests\/dns-zlip-2.pcap\n create mode 100644 tests\/dns-zlip-3.out\n create mode 100644 tests\/dns-zlip-3.pcap\n create mode 100644 tests\/dns_fwdptr.out\n create mode 100644 tests\/dns_fwdptr.pcap\n\n","diff_code":"diff --git a\/print-domain.c b\/print-domain.c\nindex d0b6996fd..9a2b9e856 100644\n--- a\/print-domain.c\n+++ b\/print-domain.c\n@@ -151,15 +151,14 @@ ns_nprint(netdissect_options *ndo,\n \tregister u_int i, l;\n \tregister const u_char *rp = NULL;\n \tregister int compress = 0;\n-\tint chars_processed;\n \tint elt;\n-\tint data_size = ndo->ndo_snapend - bp;\n+\tu_int offset, max_offset;\n \n \tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\treturn(NULL);\n \tif (!ND_TTEST2(*cp, 1))\n \t\treturn(NULL);\n-\tchars_processed = 1;\n+\tmax_offset = (u_int)(cp - bp);\n \tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n \t\tcompress = 0;\n \t\trp = cp + l;\n@@ -174,24 +173,28 @@ ns_nprint(netdissect_options *ndo,\n \t\t\t\t}\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n-\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n+\t\t\t\toffset = (((i << 8) | *cp) & 0x3fff);\n+\t\t\t\t\/*\n+\t\t\t\t * This must move backwards in the packet.\n+\t\t\t\t * No RFC explicitly says that, but BIND's\n+\t\t\t\t * name decompression code requires it,\n+\t\t\t\t * as a way of preventing infinite loops\n+\t\t\t\t * and other bad behavior, and it's probably\n+\t\t\t\t * what was intended (compress by pointing\n+\t\t\t\t * to domain name suffixes already seen in\n+\t\t\t\t * the packet).\n+\t\t\t\t *\/\n+\t\t\t\tif (offset >= max_offset) {\n+\t\t\t\t\tND_PRINT((ndo, \"<BAD PTR>\"));\n+\t\t\t\t\treturn(NULL);\n+\t\t\t\t}\n+\t\t\t\tmax_offset = offset;\n+\t\t\t\tcp = bp + offset;\n \t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\t\treturn(NULL);\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n \t\t\t\ti = *cp++;\n-\t\t\t\tchars_processed++;\n-\n-\t\t\t\t\/*\n-\t\t\t\t * If we've looked at every character in\n-\t\t\t\t * the message, this pointer will make\n-\t\t\t\t * us look at some character again,\n-\t\t\t\t * which means we're looping.\n-\t\t\t\t *\/\n-\t\t\t\tif (chars_processed >= data_size) {\n-\t\t\t\t\tND_PRINT((ndo, \"<LOOP>\"));\n-\t\t\t\t\treturn (NULL);\n-\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n@@ -212,14 +215,12 @@ ns_nprint(netdissect_options *ndo,\n \t\t\t}\n \n \t\t\tcp += l;\n-\t\t\tchars_processed += l;\n \t\t\tND_PRINT((ndo, \".\"));\n \t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\treturn(NULL);\n \t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\treturn(NULL);\n \t\t\ti = *cp++;\n-\t\t\tchars_processed++;\n \t\t\tif (!compress)\n \t\t\t\trp += l + 1;\n \t\t}\ndiff --git a\/tests\/TESTLIST b\/tests\/TESTLIST\nindex ec627cb82..0ddc63e39 100644\n--- a\/tests\/TESTLIST\n+++ b\/tests\/TESTLIST\n@@ -474,6 +474,7 @@ zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n+dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap\n@@ -483,3 +484,11 @@ rtp-seg-fault-2  rtp-seg-fault-2.pcap  rtp-seg-fault-2.out  -v -T rtp\n # NFS tests\n # fuzzed pcap\n nfs-seg-fault-1  nfs-seg-fault-1.pcap  nfs-seg-fault-1.out\n+\n+# DNS infinite loop tests\n+#\n+# See http:\/\/marc.info\/?l=tcpdump-workers&m=95552439022555\n+#\n+dns-zlip-1\t\tdns-zlip-1.pcap\t\tdns-zlip-1.out\n+dns-zlip-2\t\tdns-zlip-2.pcap\t\tdns-zlip-2.out\n+dns-zlip-3\t\tdns-zlip-3.pcap\t\tdns-zlip-3.out\ndiff --git a\/tests\/dns-zlip-1.out b\/tests\/dns-zlip-1.out\nnew file mode 100644\nindex 000000000..ce12748da\n--- \/dev\/null\n+++ b\/tests\/dns-zlip-1.out\n@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 60777 Type49159 (Class 49168)? <BAD PTR>[|domain]\ndiff --git a\/tests\/dns-zlip-1.pcap b\/tests\/dns-zlip-1.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..4ec844c0fc9fd0572e10b1cb91a871e49ce2a80b\nGIT binary patch\nliteral 117\nzcmca|c+)~A1{MYwaA0F#U<7jHQ$JhOU*Kf$1+qbyAz{kvP<@62{@L>%a4@(sFxXpn\nzGB7v@wpDNeHB1VTi2#~m%D~aI{cR>tHOL4cIKXp&{eZv$@dFA6)DIXO_<tTK#>l`3\nE0Nt`1ivR!s\n\nliteral 0\nHcmV?d00001\n\ndiff --git a\/tests\/dns-zlip-2.out b\/tests\/dns-zlip-2.out\nnew file mode 100644\nindex 000000000..dbabefbfc\n--- \/dev\/null\n+++ b\/tests\/dns-zlip-2.out\n@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 18992 Type49164 (Class 49168)? <BAD PTR>[|domain]\ndiff --git a\/tests\/dns-zlip-2.pcap b\/tests\/dns-zlip-2.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..5f74f226499430dd893fb19b5e3135b491e50385\nGIT binary patch\nliteral 117\nzcmca|c+)~A1{MYwaA0F#U<7g^Q$Jh$N#S7d1+qbyAz{kvP<@62{@L>%a4@(sFxcC4\nzGB7v@wpMTfHB1VTi2#~m%D|!e%F6(#8e{|z9N;^^b3ovL_yL6j>IV!C{67yAV`N|i\nE0M$4e)&Kwi\n\nliteral 0\nHcmV?d00001\n\ndiff --git a\/tests\/dns-zlip-3.out b\/tests\/dns-zlip-3.out\nnew file mode 100644\nindex 000000000..beb173045\n--- \/dev\/null\n+++ b\/tests\/dns-zlip-3.out\n@@ -0,0 +1 @@\n+IP 10.0.0.1.1024 > 146.84.28.88.53: 65483 Type49164 (Class 49164)? thisleetostringwillcrashyourlittlenameserverforsurehahahahahah.<BAD PTR>[|domain]\ndiff --git a\/tests\/dns-zlip-3.pcap b\/tests\/dns-zlip-3.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..c0c076a636551554f6553ebe6fe214f0e5202074\nGIT binary patch\nliteral 187\nzcmca|c+)~A1{MYwaA0F#U<7iurhc~A_JEOLGLQ|z3<*<Shw3vN@XwzAfP=x6fuYs5\nzlYzlOu*HZAs9{owOa#yjQw9!=^#7-UszF8ofn7;PW^qnxYDs=^Nl|8AdU<9}PI6IV\noaYki+X;DsQNl8v>USe))acWUnYEfE#QE_QeYDOX)9^k<T0fp^4hyVZp\n\nliteral 0\nHcmV?d00001\n\ndiff --git a\/tests\/dns_fwdptr.out b\/tests\/dns_fwdptr.out\nnew file mode 100644\nindex 000000000..4a37b7fb3\n--- \/dev\/null\n+++ b\/tests\/dns_fwdptr.out\n@@ -0,0 +1,2 @@\n+be:af:ca:ce:ff:ff > de:ad:be:ef:00:01, ethertype IPv4 (0x0800), length 63207: (tos 0x0, ttl 128, id 36039, offset 0, flags [none], proto UDP (17), length 63193)\n+    156.118.17.235.53 > 156.118.27.229.500: [udp sum ok] 51584 zoneRef NoChange*|$ [64259q] q: Type507 (Class 769)? M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{^C.M-{.^AM-{ .M-{^C^A.<BAD PTR>[|domain]\ndiff --git a\/tests\/dns_fwdptr.pcap b\/tests\/dns_fwdptr.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..67a8461197684db8a1fc5658aed7a5db3d077af1\nGIT binary patch\nliteral 63247\nzcmeIuF=_%q6b9foZUVN}HeMnJun1{$6FX~r1uw8o4iEw!Ko&v>Nnw>DNns}z7Td@c\nzT1)~#urui-e8UWnfuEnp_x3ouYsEzzPR<eO@cEwW=I1T%=XIp{!|NjFc3emEF?o&{\nzb#ABSu(K(L-BnzrZS(a0`7+A&zDTEUuQ;7K>e)?y(Rq~rQ@Jn!0t5&UAV7cs0RjXF\nz5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk\nz1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs\nz0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ\nzfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZ;EV+>cSSnm_3TD~009C7\nz2oNAZfB*pk1PBlyK!5-N0t5&UAV7cs0RjXF5FkK+009C72oNAZfB*pk1PBlyK!5-N\nW0t5&UAVA=s3#91Z6jfCXs__?|920r~\n\nliteral 0\nHcmV?d00001\n\n","owner":"the-tcpdump-group","repo":"tcpdump","source":"cve"},{"CVE_ID":"CVE-2010-3880","CWE_ID":"399","category":"security","commit_id":"22e76c849d505d87c5ecf3d3e6742a65f0ff4860","commit_message":"From 22e76c849d505d87c5ecf3d3e6742a65f0ff4860 Mon Sep 17 00:00:00 2001\nFrom: Nelson Elhage <nelhage@ksplice.com>\nDate: Wed, 3 Nov 2010 16:35:41 +0000\nSubject: inet_diag: Make sure we actually run the same bytecode we audited.\n\nWe were using nlmsg_find_attr() to look up the bytecode by attribute when\nauditing, but then just using the first attribute when actually running\nbytecode. So, if we received a message with two attribute elements, where only\nthe second had type INET_DIAG_REQ_BYTECODE, we would validate and run different\nbytecode strings.\n\nFix this by consistently using nlmsg_find_attr everywhere.\n\nSigned-off-by: Nelson Elhage <nelhage@ksplice.com>\nSigned-off-by: Thomas Graf <tgraf@infradead.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/inet_diag.c | 27 ++++++++++++++++-----------\n 1 file changed, 16 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/inet_diag.c b\/net\/ipv4\/inet_diag.c\nindex ba8042665849..2ada17129fce 100644\n--- a\/net\/ipv4\/inet_diag.c\n+++ b\/net\/ipv4\/inet_diag.c\n@@ -490,9 +490,11 @@ static int inet_csk_diag_dump(struct sock *sk,\n {\n \tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n \n-\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {\n+\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {\n \t\tstruct inet_diag_entry entry;\n-\t\tstruct rtattr *bc = (struct rtattr *)(r + 1);\n+\t\tconst struct nlattr *bc = nlmsg_find_attr(cb->nlh,\n+\t\t\t\t\t\t\t  sizeof(*r),\n+\t\t\t\t\t\t\t  INET_DIAG_REQ_BYTECODE);\n \t\tstruct inet_sock *inet = inet_sk(sk);\n \n \t\tentry.family = sk->sk_family;\n@@ -512,7 +514,7 @@ static int inet_csk_diag_dump(struct sock *sk,\n \t\tentry.dport = ntohs(inet->inet_dport);\n \t\tentry.userlocks = sk->sk_userlocks;\n \n-\t\tif (!inet_diag_bc_run(RTA_DATA(bc), RTA_PAYLOAD(bc), &entry))\n+\t\tif (!inet_diag_bc_run(nla_data(bc), nla_len(bc), &entry))\n \t\t\treturn 0;\n \t}\n \n@@ -527,9 +529,11 @@ static int inet_twsk_diag_dump(struct inet_timewait_sock *tw,\n {\n \tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n \n-\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {\n+\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {\n \t\tstruct inet_diag_entry entry;\n-\t\tstruct rtattr *bc = (struct rtattr *)(r + 1);\n+\t\tconst struct nlattr *bc = nlmsg_find_attr(cb->nlh,\n+\t\t\t\t\t\t\t  sizeof(*r),\n+\t\t\t\t\t\t\t  INET_DIAG_REQ_BYTECODE);\n \n \t\tentry.family = tw->tw_family;\n #if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)\n@@ -548,7 +552,7 @@ static int inet_twsk_diag_dump(struct inet_timewait_sock *tw,\n \t\tentry.dport = ntohs(tw->tw_dport);\n \t\tentry.userlocks = 0;\n \n-\t\tif (!inet_diag_bc_run(RTA_DATA(bc), RTA_PAYLOAD(bc), &entry))\n+\t\tif (!inet_diag_bc_run(nla_data(bc), nla_len(bc), &entry))\n \t\t\treturn 0;\n \t}\n \n@@ -618,7 +622,7 @@ static int inet_diag_dump_reqs(struct sk_buff *skb, struct sock *sk,\n \tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n \tstruct inet_connection_sock *icsk = inet_csk(sk);\n \tstruct listen_sock *lopt;\n-\tstruct rtattr *bc = NULL;\n+\tconst struct nlattr *bc = NULL;\n \tstruct inet_sock *inet = inet_sk(sk);\n \tint j, s_j;\n \tint reqnum, s_reqnum;\n@@ -638,8 +642,9 @@ static int inet_diag_dump_reqs(struct sk_buff *skb, struct sock *sk,\n \tif (!lopt || !lopt->qlen)\n \t\tgoto out;\n \n-\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {\n-\t\tbc = (struct rtattr *)(r + 1);\n+\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {\n+\t\tbc = nlmsg_find_attr(cb->nlh, sizeof(*r),\n+\t\t\t\t     INET_DIAG_REQ_BYTECODE);\n \t\tentry.sport = inet->inet_num;\n \t\tentry.userlocks = sk->sk_userlocks;\n \t}\n@@ -672,8 +677,8 @@ static int inet_diag_dump_reqs(struct sk_buff *skb, struct sock *sk,\n \t\t\t\t\t&ireq->rmt_addr;\n \t\t\t\tentry.dport = ntohs(ireq->rmt_port);\n \n-\t\t\t\tif (!inet_diag_bc_run(RTA_DATA(bc),\n-\t\t\t\t\t\t    RTA_PAYLOAD(bc), &entry))\n+\t\t\t\tif (!inet_diag_bc_run(nla_data(bc),\n+\t\t\t\t\t\t      nla_len(bc), &entry))\n \t\t\t\t\tcontinue;\n \t\t\t}\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3688","CWE_ID":"399","category":"security","commit_id":"26b87c7881006311828bb0ab271a551a62dcceb4","commit_message":"From 26b87c7881006311828bb0ab271a551a62dcceb4 Mon Sep 17 00:00:00 2001\nFrom: Daniel Borkmann <dborkman@redhat.com>\nDate: Thu, 9 Oct 2014 22:55:33 +0200\nSubject: [PATCH] net: sctp: fix remote memory pressure from excessive queueing\n\nThis scenario is not limited to ASCONF, just taken as one\nexample triggering the issue. When receiving ASCONF probes\nin the form of ...\n\n  -------------- INIT[ASCONF; ASCONF_ACK] ------------->\n  <----------- INIT-ACK[ASCONF; ASCONF_ACK] ------------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n  ---- ASCONF_a; [ASCONF_b; ...; ASCONF_n;] JUNK ------>\n  [...]\n  ---- ASCONF_m; [ASCONF_o; ...; ASCONF_z;] JUNK ------>\n\n... where ASCONF_a, ASCONF_b, ..., ASCONF_z are good-formed\nASCONFs and have increasing serial numbers, we process such\nASCONF chunk(s) marked with !end_of_packet and !singleton,\nsince we have not yet reached the SCTP packet end. SCTP does\nonly do verification on a chunk by chunk basis, as an SCTP\npacket is nothing more than just a container of a stream of\nchunks which it eats up one by one.\n\nWe could run into the case that we receive a packet with a\nmalformed tail, above marked as trailing JUNK. All previous\nchunks are here goodformed, so the stack will eat up all\nprevious chunks up to this point. In case JUNK does not fit\ninto a chunk header and there are no more other chunks in\nthe input queue, or in case JUNK contains a garbage chunk\nheader, but the encoded chunk length would exceed the skb\ntail, or we came here from an entirely different scenario\nand the chunk has pdiscard=1 mark (without having had a flush\npoint), it will happen, that we will excessively queue up\nthe association's output queue (a correct final chunk may\nthen turn it into a response flood when flushing the\nqueue ;)): I ran a simple script with incremental ASCONF\nserial numbers and could see the server side consuming\nexcessive amount of RAM [before\/after: up to 2GB and more].\n\nThe issue at heart is that the chunk train basically ends\nwith !end_of_packet and !singleton markers and since commit\n2e3216cd54b1 (\"sctp: Follow security requirement of responding\nwith 1 packet\") therefore preventing an output queue flush\npoint in sctp_do_sm() -> sctp_cmd_interpreter() on the input\nchunk (chunk = event_arg) even though local_cork is set,\nbut its precedence has changed since then. In the normal\ncase, the last chunk with end_of_packet=1 would trigger the\nqueue flush to accommodate possible outgoing bundling.\n\nIn the input queue, sctp_inq_pop() seems to do the right thing\nin terms of discarding invalid chunks. So, above JUNK will\nnot enter the state machine and instead be released and exit\nthe sctp_assoc_bh_rcv() chunk processing loop. It's simply\nthe flush point being missing at loop exit. Adding a try-flush\napproach on the output queue might not work as the underlying\ninfrastructure might be long gone at this point due to the\nside-effect interpreter run.\n\nOne possibility, albeit a bit of a kludge, would be to defer\ninvalid chunk freeing into the state machine in order to\npossibly trigger packet discards and thus indirectly a queue\nflush on error. It would surely be better to discard chunks\nas in the current, perhaps better controlled environment, but\ngoing back and forth, it's simply architecturally not possible.\nI tried various trailing JUNK attack cases and it seems to\nlook good now.\n\nJoint work with Vlad Yasevich.\n\nFixes: 2e3216cd54b1 (\"sctp: Follow security requirement of responding with 1 packet\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/sctp\/inqueue.c      | 33 +++++++--------------------------\n net\/sctp\/sm_statefuns.c |  3 +++\n 2 files changed, 10 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/net\/sctp\/inqueue.c b\/net\/sctp\/inqueue.c\nindex 4de12afa13d42..7e8a16c77039e 100644\n--- a\/net\/sctp\/inqueue.c\n+++ b\/net\/sctp\/inqueue.c\n@@ -140,18 +140,9 @@ struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n \t\t} else {\n \t\t\t\/* Nothing to do. Next chunk in the packet, please. *\/\n \t\t\tch = (sctp_chunkhdr_t *) chunk->chunk_end;\n-\n \t\t\t\/* Force chunk->skb->data to chunk->chunk_end.  *\/\n-\t\t\tskb_pull(chunk->skb,\n-\t\t\t\t chunk->chunk_end - chunk->skb->data);\n-\n-\t\t\t\/* Verify that we have at least chunk headers\n-\t\t\t * worth of buffer left.\n-\t\t\t *\/\n-\t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\n-\t\t\t\tsctp_chunk_free(chunk);\n-\t\t\t\tchunk = queue->in_progress = NULL;\n-\t\t\t}\n+\t\t\tskb_pull(chunk->skb, chunk->chunk_end - chunk->skb->data);\n+\t\t\t\/* We are guaranteed to pull a SCTP header. *\/\n \t\t}\n \t}\n \n@@ -187,24 +178,14 @@ struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n \tskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\n \tchunk->subh.v = NULL; \/* Subheader is no longer valid.  *\/\n \n-\tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\n+\tif (chunk->chunk_end + sizeof(sctp_chunkhdr_t) <\n+\t    skb_tail_pointer(chunk->skb)) {\n \t\t\/* This is not a singleton *\/\n \t\tchunk->singleton = 0;\n \t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n-\t\t\/* RFC 2960, Section 6.10  Bundling\n-\t\t *\n-\t\t * Partial chunks MUST NOT be placed in an SCTP packet.\n-\t\t * If the receiver detects a partial chunk, it MUST drop\n-\t\t * the chunk.\n-\t\t *\n-\t\t * Since the end of the chunk is past the end of our buffer\n-\t\t * (which contains the whole packet, we can freely discard\n-\t\t * the whole packet.\n-\t\t *\/\n-\t\tsctp_chunk_free(chunk);\n-\t\tchunk = queue->in_progress = NULL;\n-\n-\t\treturn NULL;\n+\t\t\/* Discard inside state machine. *\/\n+\t\tchunk->pdiscard = 1;\n+\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n \t} else {\n \t\t\/* We are at the end of the packet, so mark the chunk\n \t\t * in case we need to send a SACK.\ndiff --git a\/net\/sctp\/sm_statefuns.c b\/net\/sctp\/sm_statefuns.c\nindex bdea3dfbad31a..3ee27b7704ffb 100644\n--- a\/net\/sctp\/sm_statefuns.c\n+++ b\/net\/sctp\/sm_statefuns.c\n@@ -170,6 +170,9 @@ sctp_chunk_length_valid(struct sctp_chunk *chunk,\n {\n \t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n \n+\t\/* Previously already marked? *\/\n+\tif (unlikely(chunk->pdiscard))\n+\t\treturn 0;\n \tif (unlikely(chunk_length < required_length))\n \t\treturn 0;\n \n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4243","CWE_ID":"399","category":"security","commit_id":"3c77f845722158206a7209c45ccddc264d19319c","commit_message":"From 3c77f845722158206a7209c45ccddc264d19319c Mon Sep 17 00:00:00 2001\nFrom: Oleg Nesterov <oleg@redhat.com>\nDate: Tue, 30 Nov 2010 20:55:34 +0100\nSubject: exec: make argv\/envp memory visible to oom-killer\n\nBrad Spengler published a local memory-allocation DoS that\nevades the OOM-killer (though not the virtual memory RLIMIT):\nhttp:\/\/www.grsecurity.net\/~spender\/64bit_dos.c\n\nexecve()->copy_strings() can allocate a lot of memory, but\nthis is not visible to oom-killer, nobody can see the nascent\nbprm->mm and take it into account.\n\nWith this patch get_arg_page() increments current's MM_ANONPAGES\ncounter every time we allocate the new page for argv\/envp. When\ndo_execve() succeds or fails, we change this counter back.\n\nTechnically this is not 100% correct, we can't know if the new\npage is swapped out and turn MM_ANONPAGES into MM_SWAPENTS, but\nI don't think this really matters and everything becomes correct\nonce exec changes ->mm or fails.\n\nReported-by: Brad Spengler <spender@grsecurity.net>\nReviewed-and-discussed-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/exec.c               | 32 ++++++++++++++++++++++++++++++--\n include\/linux\/binfmts.h |  1 +\n 2 files changed, 31 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/exec.c b\/fs\/exec.c\nindex 99d33a1371e9..4303b9035fe7 100644\n--- a\/fs\/exec.c\n+++ b\/fs\/exec.c\n@@ -164,6 +164,25 @@ out:\n \n #ifdef CONFIG_MMU\n \n+static void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n+{\n+\tstruct mm_struct *mm = current->mm;\n+\tlong diff = (long)(pages - bprm->vma_pages);\n+\n+\tif (!mm || !diff)\n+\t\treturn;\n+\n+\tbprm->vma_pages = pages;\n+\n+#ifdef SPLIT_RSS_COUNTING\n+\tadd_mm_counter(mm, MM_ANONPAGES, diff);\n+#else\n+\tspin_lock(&mm->page_table_lock);\n+\tadd_mm_counter(mm, MM_ANONPAGES, diff);\n+\tspin_unlock(&mm->page_table_lock);\n+#endif\n+}\n+\n static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n \t\tint write)\n {\n@@ -186,6 +205,8 @@ static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n \t\tunsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;\n \t\tstruct rlimit *rlim;\n \n+\t\tacct_arg_size(bprm, size \/ PAGE_SIZE);\n+\n \t\t\/*\n \t\t * We've historically supported up to 32 pages (ARG_MAX)\n \t\t * of argument strings even with small stacks\n@@ -276,6 +297,10 @@ static bool valid_arg_len(struct linux_binprm *bprm, long len)\n \n #else\n \n+static inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n+{\n+}\n+\n static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n \t\tint write)\n {\n@@ -1003,6 +1028,7 @@ int flush_old_exec(struct linux_binprm * bprm)\n \t\/*\n \t * Release all of the old mmap stuff\n \t *\/\n+\tacct_arg_size(bprm, 0);\n \tretval = exec_mmap(bprm->mm);\n \tif (retval)\n \t\tgoto out;\n@@ -1426,8 +1452,10 @@ int do_execve(const char * filename,\n \treturn retval;\n \n out:\n-\tif (bprm->mm)\n-\t\tmmput (bprm->mm);\n+\tif (bprm->mm) {\n+\t\tacct_arg_size(bprm, 0);\n+\t\tmmput(bprm->mm);\n+\t}\n \n out_file:\n \tif (bprm->file) {\ndiff --git a\/include\/linux\/binfmts.h b\/include\/linux\/binfmts.h\nindex a065612fc928..7c87796d20da 100644\n--- a\/include\/linux\/binfmts.h\n+++ b\/include\/linux\/binfmts.h\n@@ -29,6 +29,7 @@ struct linux_binprm{\n \tchar buf[BINPRM_BUF_SIZE];\n #ifdef CONFIG_MMU\n \tstruct vm_area_struct *vma;\n+\tunsigned long vma_pages;\n #else\n # define MAX_ARG_PAGES\t32\n \tstruct page *page[MAX_ARG_PAGES];\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-8925","CWE_ID":"399","category":"security","commit_id":"30572418b445d85fcfe6c8fe84c947d2606767d8","commit_message":"From 30572418b445d85fcfe6c8fe84c947d2606767d8 Mon Sep 17 00:00:00 2001\nFrom: Johan Hovold <johan@kernel.org>\nDate: Mon, 6 Mar 2017 17:36:38 +0100\nSubject: [PATCH] USB: serial: omninet: fix reference leaks at open\n\nThis driver needlessly took another reference to the tty on open, a\nreference which was then never released on close. This lead to not just\na leak of the tty, but also a driver reference leak that prevented the\ndriver from being unloaded after a port had once been opened.\n\nFixes: 4a90f09b20f4 (\"tty: usb-serial krefs\")\nCc: stable <stable@vger.kernel.org>\t# 2.6.28\nSigned-off-by: Johan Hovold <johan@kernel.org>\n---\n drivers\/usb\/serial\/omninet.c | 6 ------\n 1 file changed, 6 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/usb\/serial\/omninet.c b\/drivers\/usb\/serial\/omninet.c\nindex a180b17d24323..76564b3bebb9b 100644\n--- a\/drivers\/usb\/serial\/omninet.c\n+++ b\/drivers\/usb\/serial\/omninet.c\n@@ -142,12 +142,6 @@ static int omninet_port_remove(struct usb_serial_port *port)\n \n static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n {\n-\tstruct usb_serial\t*serial = port->serial;\n-\tstruct usb_serial_port\t*wport;\n-\n-\twport = serial->port[1];\n-\ttty_port_tty_set(&wport->port, tty);\n-\n \treturn usb_serial_generic_open(tty, port);\n }\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-7757","CWE_ID":"399","category":"security","commit_id":"4a491b1ab11ca0556d2fda1ff1301e862a2d44c4","commit_message":"From 4a491b1ab11ca0556d2fda1ff1301e862a2d44c4 Mon Sep 17 00:00:00 2001\nFrom: Jason Yan <yanaijie@huawei.com>\nDate: Thu, 4 Jan 2018 21:04:31 +0800\nSubject: scsi: libsas: fix memory leak in sas_smp_get_phy_events()\n\nWe've got a memory leak with the following producer:\n\nwhile true;\ndo cat \/sys\/class\/sas_phy\/phy-1:0:12\/invalid_dword_count >\/dev\/null;\ndone\n\nThe buffer req is allocated and not freed after we return. Fix it.\n\nFixes: 2908d778ab3e (\"[SCSI] aic94xx: new driver\")\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nCC: John Garry <john.garry@huawei.com>\nCC: chenqilin <chenqilin2@huawei.com>\nCC: chenxiang <chenxiang66@hisilicon.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Hannes Reinecke <hare@suse.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>\n---\n drivers\/scsi\/libsas\/sas_expander.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/drivers\/scsi\/libsas\/sas_expander.c b\/drivers\/scsi\/libsas\/sas_expander.c\nindex ca1566237ae7..1de59c0fdbc0 100644\n--- a\/drivers\/scsi\/libsas\/sas_expander.c\n+++ b\/drivers\/scsi\/libsas\/sas_expander.c\n@@ -695,6 +695,7 @@ int sas_smp_get_phy_events(struct sas_phy *phy)\n \tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n \n  out:\n+\tkfree(req);\n \tkfree(resp);\n \treturn res;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-2385","CWE_ID":"399","category":"security","commit_id":"9791768705528e911bfca6c4d8aa88139035060e","commit_message":"From 9791768705528e911bfca6c4d8aa88139035060e Mon Sep 17 00:00:00 2001\nFrom: Keith Winstein <keithw@mit.edu>\nDate: Tue, 15 May 2012 23:46:09 -0400\nSubject: [PATCH] Cap escape sequence parameters to prevent long loops.\n\nFixes #271 github issue.\n---\n src\/terminal\/terminaldispatcher.cc | 5 +++++\n src\/terminal\/terminaldispatcher.h  | 3 +++\n 2 files changed, 8 insertions(+)\n\n","diff_code":"diff --git a\/src\/terminal\/terminaldispatcher.cc b\/src\/terminal\/terminaldispatcher.cc\nindex ae02bff3..de07b80d 100644\n--- a\/src\/terminal\/terminaldispatcher.cc\n+++ b\/src\/terminal\/terminaldispatcher.cc\n@@ -116,6 +116,11 @@ int Dispatcher::getparam( size_t N, int defaultval )\n   if ( parsed_params.size() > N ) {\n     ret = parsed_params[ N ];\n   }\n+\n+  if ( ret > PARAM_MAX ) {\n+    ret = defaultval;\n+  }\n+\n   if ( ret < 1 ) ret = defaultval;\n \n   return ret;\ndiff --git a\/src\/terminal\/terminaldispatcher.h b\/src\/terminal\/terminaldispatcher.h\nindex bdad3c1a..f5f801c1 100644\n--- a\/src\/terminal\/terminaldispatcher.h\n+++ b\/src\/terminal\/terminaldispatcher.h\n@@ -77,6 +77,9 @@ namespace Terminal {\n     void parse_params( void );\n \n   public:\n+    static const int PARAM_MAX = 65535;\n+    \/* prevent evil escape sequences from causing long loops *\/\n+\n     std::string terminal_to_host; \/* this is the reply string *\/\n \n     Dispatcher();\n","owner":"keithw","repo":"mosh","source":"cve"},{"CVE_ID":"CVE-2010-3873","CWE_ID":"399","category":"security","commit_id":"a6331d6f9a4298173b413cf99a40cc86a9d92c37","commit_message":"From a6331d6f9a4298173b413cf99a40cc86a9d92c37 Mon Sep 17 00:00:00 2001\nFrom: andrew hendry <andrew.hendry@gmail.com>\nDate: Wed, 3 Nov 2010 12:54:53 +0000\nSubject: memory corruption in X.25 facilities parsing\n\nSigned-of-by: Andrew Hendry <andrew.hendry@gmail.com>\n\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/x25\/x25_facilities.c | 8 ++++----\n net\/x25\/x25_in.c         | 2 ++\n 2 files changed, 6 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/net\/x25\/x25_facilities.c b\/net\/x25\/x25_facilities.c\nindex 771bab00754b..3a8c4c419cd4 100644\n--- a\/net\/x25\/x25_facilities.c\n+++ b\/net\/x25\/x25_facilities.c\n@@ -134,15 +134,15 @@ int x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,\n \t\tcase X25_FAC_CLASS_D:\n \t\t\tswitch (*p) {\n \t\t\tcase X25_FAC_CALLING_AE:\n-\t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN)\n-\t\t\t\t\tbreak;\n+\t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)\n+\t\t\t\t\treturn 0;\n \t\t\t\tdte_facs->calling_len = p[2];\n \t\t\t\tmemcpy(dte_facs->calling_ae, &p[3], p[1] - 1);\n \t\t\t\t*vc_fac_mask |= X25_MASK_CALLING_AE;\n \t\t\t\tbreak;\n \t\t\tcase X25_FAC_CALLED_AE:\n-\t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN)\n-\t\t\t\t\tbreak;\n+\t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)\n+\t\t\t\t\treturn 0;\n \t\t\t\tdte_facs->called_len = p[2];\n \t\t\t\tmemcpy(dte_facs->called_ae, &p[3], p[1] - 1);\n \t\t\t\t*vc_fac_mask |= X25_MASK_CALLED_AE;\ndiff --git a\/net\/x25\/x25_in.c b\/net\/x25\/x25_in.c\nindex 63178961efac..f729f022be69 100644\n--- a\/net\/x25\/x25_in.c\n+++ b\/net\/x25\/x25_in.c\n@@ -119,6 +119,8 @@ static int x25_state1_machine(struct sock *sk, struct sk_buff *skb, int frametyp\n \t\t\t\t\t\t&x25->vc_facil_mask);\n \t\t\tif (len > 0)\n \t\t\t\tskb_pull(skb, len);\n+\t\t\telse\n+\t\t\t\treturn -1;\n \t\t\t\/*\n \t\t\t *\tCopy any Call User Data.\n \t\t\t *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-14172","CWE_ID":"399","category":"security","commit_id":"8598a497e2d1f556a34458cf54b40ba40674734c","commit_message":"From 8598a497e2d1f556a34458cf54b40ba40674734c Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 31 Aug 2017 11:07:36 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/715\n\n---\n coders\/ps.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/coders\/ps.c b\/coders\/ps.c\nindex cdd3c3b762..5aba02773b 100644\n--- a\/coders\/ps.c\n+++ b\/coders\/ps.c\n@@ -659,6 +659,8 @@ static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         if (count != 1)\n           continue;\n         length=extent;\n+        if (length > GetBlobSize(image))\n+          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         profile=BlobToStringInfo((const void *) NULL,length);\n         if (profile != (StringInfo *) NULL)\n           {\n@@ -1051,6 +1053,7 @@ ModuleExport size_t RegisterPSImage(void)\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n+  entry->seekable_stream=MagickTrue;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n   entry->seekable_stream=MagickTrue;\n@@ -1062,6 +1065,7 @@ ModuleExport size_t RegisterPSImage(void)\n   entry=SetMagickInfo(\"EPS\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n+  entry->seekable_stream=MagickTrue;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n@@ -1073,6 +1077,7 @@ ModuleExport size_t RegisterPSImage(void)\n   entry=SetMagickInfo(\"EPSF\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n+  entry->seekable_stream=MagickTrue;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n@@ -1084,6 +1089,7 @@ ModuleExport size_t RegisterPSImage(void)\n   entry=SetMagickInfo(\"EPSI\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n+  entry->seekable_stream=MagickTrue;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->adjoin=MagickFalse;\n   entry->blob_support=MagickFalse;\n@@ -1096,6 +1102,7 @@ ModuleExport size_t RegisterPSImage(void)\n   entry=SetMagickInfo(\"PS\");\n   entry->decoder=(DecodeImageHandler *) ReadPSImage;\n   entry->encoder=(EncodeImageHandler *) WritePSImage;\n+  entry->seekable_stream=MagickTrue;\n   entry->magick=(IsImageFormatHandler *) IsPS;\n   entry->mime_type=ConstantString(\"application\/postscript\");\n   entry->module=ConstantString(\"PS\");\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2011-1479","CWE_ID":"399","category":"security","commit_id":"d0de4dc584ec6aa3b26fffea320a8457827768fc","commit_message":"From d0de4dc584ec6aa3b26fffea320a8457827768fc Mon Sep 17 00:00:00 2001\nFrom: Eric Paris <eparis@redhat.com>\nDate: Tue, 5 Apr 2011 17:20:50 -0400\nSubject: inotify: fix double free\/corruption of stuct user\n\nOn an error path in inotify_init1 a normal user can trigger a double\nfree of struct user.  This is a regression introduced by a2ae4cc9a16e\n(\"inotify: stop kernel memory leak on file creation failure\").\n\nWe fix this by making sure that if a group exists the user reference is\ndropped when the group is cleaned up.  We should not explictly drop the\nreference on error and also drop the reference when the group is cleaned\nup.\n\nThe new lifetime rules are that an inotify group lives from\ninotify_new_group to the last fsnotify_put_group.  Since the struct user\nand inotify_devs are directly tied to this lifetime they are only\nchanged\/updated in those two locations.  We get rid of all special\ncasing of struct user or user->inotify_devs.\n\nSigned-off-by: Eric Paris <eparis@redhat.com>\nCc: stable@kernel.org (2.6.37 and up)\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/notify\/inotify\/inotify_fsnotify.c |  1 +\n fs\/notify\/inotify\/inotify_user.c     | 39 ++++++++++++------------------------\n 2 files changed, 14 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/fs\/notify\/inotify\/inotify_fsnotify.c b\/fs\/notify\/inotify\/inotify_fsnotify.c\nindex a91b69a6a291..0348d0c8f65e 100644\n--- a\/fs\/notify\/inotify\/inotify_fsnotify.c\n+++ b\/fs\/notify\/inotify\/inotify_fsnotify.c\n@@ -198,6 +198,7 @@ static void inotify_free_group_priv(struct fsnotify_group *group)\n \tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n \tidr_remove_all(&group->inotify_data.idr);\n \tidr_destroy(&group->inotify_data.idr);\n+\tatomic_dec(&group->inotify_data.user->inotify_devs);\n \tfree_uid(group->inotify_data.user);\n }\n \ndiff --git a\/fs\/notify\/inotify\/inotify_user.c b\/fs\/notify\/inotify\/inotify_user.c\nindex bd46e7c8a0ef..8445fbc8985c 100644\n--- a\/fs\/notify\/inotify\/inotify_user.c\n+++ b\/fs\/notify\/inotify\/inotify_user.c\n@@ -290,7 +290,6 @@ static int inotify_fasync(int fd, struct file *file, int on)\n static int inotify_release(struct inode *ignored, struct file *file)\n {\n \tstruct fsnotify_group *group = file->private_data;\n-\tstruct user_struct *user = group->inotify_data.user;\n \n \tpr_debug(\"%s: group=%p\\n\", __func__, group);\n \n@@ -299,8 +298,6 @@ static int inotify_release(struct inode *ignored, struct file *file)\n \t\/* free this group, matching get was inotify_init->fsnotify_obtain_group *\/\n \tfsnotify_put_group(group);\n \n-\tatomic_dec(&user->inotify_devs);\n-\n \treturn 0;\n }\n \n@@ -697,7 +694,7 @@ retry:\n \treturn ret;\n }\n \n-static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n+static struct fsnotify_group *inotify_new_group(unsigned int max_events)\n {\n \tstruct fsnotify_group *group;\n \n@@ -710,8 +707,14 @@ static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsign\n \tspin_lock_init(&group->inotify_data.idr_lock);\n \tidr_init(&group->inotify_data.idr);\n \tgroup->inotify_data.last_wd = 0;\n-\tgroup->inotify_data.user = user;\n \tgroup->inotify_data.fa = NULL;\n+\tgroup->inotify_data.user = get_current_user();\n+\n+\tif (atomic_inc_return(&group->inotify_data.user->inotify_devs) >\n+\t    inotify_max_user_instances) {\n+\t\tfsnotify_put_group(group);\n+\t\treturn ERR_PTR(-EMFILE);\n+\t}\n \n \treturn group;\n }\n@@ -721,7 +724,6 @@ static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsign\n SYSCALL_DEFINE1(inotify_init1, int, flags)\n {\n \tstruct fsnotify_group *group;\n-\tstruct user_struct *user;\n \tint ret;\n \n \t\/* Check the IN_* constants for consistency.  *\/\n@@ -731,31 +733,16 @@ SYSCALL_DEFINE1(inotify_init1, int, flags)\n \tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n \t\treturn -EINVAL;\n \n-\tuser = get_current_user();\n-\tif (unlikely(atomic_read(&user->inotify_devs) >=\n-\t\t\tinotify_max_user_instances)) {\n-\t\tret = -EMFILE;\n-\t\tgoto out_free_uid;\n-\t}\n-\n \t\/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end *\/\n-\tgroup = inotify_new_group(user, inotify_max_queued_events);\n-\tif (IS_ERR(group)) {\n-\t\tret = PTR_ERR(group);\n-\t\tgoto out_free_uid;\n-\t}\n-\n-\tatomic_inc(&user->inotify_devs);\n+\tgroup = inotify_new_group(inotify_max_queued_events);\n+\tif (IS_ERR(group))\n+\t\treturn PTR_ERR(group);\n \n \tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n \t\t\t\t  O_RDONLY | flags);\n-\tif (ret >= 0)\n-\t\treturn ret;\n+\tif (ret < 0)\n+\t\tfsnotify_put_group(group);\n \n-\tfsnotify_put_group(group);\n-\tatomic_dec(&user->inotify_devs);\n-out_free_uid:\n-\tfree_uid(user);\n \treturn ret;\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-1667","CWE_ID":"399","category":"security","commit_id":"9d83adcdf9ab3c1ac7d54d76f3944e57278f0e70","commit_message":"From 9d83adcdf9ab3c1ac7d54d76f3944e57278f0e70 Mon Sep 17 00:00:00 2001\nFrom: Yves Orton <demerphq@gmail.com>\nDate: Tue, 12 Feb 2013 10:53:05 +0100\nSubject: [PATCH] Prevent premature hsplit() calls, and only trigger REHASH\n after hsplit()\n\nTriggering a hsplit due to long chain length allows an attacker\nto create a carefully chosen set of keys which can cause the hash\nto use 2 * (2**32) * sizeof(void *) bytes ram. AKA a DOS via memory\nexhaustion. Doing so also takes non trivial time.\n\nEliminating this check, and only inspecting chain length after a\nnormal hsplit() (triggered when keys>buckets) prevents the attack\nentirely, and makes such attacks relatively benign.\n\n(cherry picked from commit f1220d61455253b170e81427c9d0357831ca0fac)\n---\n ext\/Hash-Util-FieldHash\/t\/10_hash.t | 18 ++++++++++++++++--\n hv.c                                | 26 ++++++--------------------\n t\/op\/hash.t                         | 20 +++++++++++++++++---\n 3 files changed, 39 insertions(+), 25 deletions(-)\n\n","diff_code":"diff --git a\/ext\/Hash-Util-FieldHash\/t\/10_hash.t b\/ext\/Hash-Util-FieldHash\/t\/10_hash.t\nindex 2cfb4e81fa..d58f053d97 100644\n--- a\/ext\/Hash-Util-FieldHash\/t\/10_hash.t\n+++ b\/ext\/Hash-Util-FieldHash\/t\/10_hash.t\n@@ -38,15 +38,29 @@ use constant START     => \"a\";\n \n # some initial hash data\n fieldhash my %h2;\n-%h2 = map {$_ => 1} 'a'..'cc';\n+my $counter= \"a\";\n+$h2{$counter++}++ while $counter ne 'cd';\n \n ok (!Internals::HvREHASH(%h2), \n     \"starting with pre-populated non-pathological hash (rehash flag if off)\");\n \n my @keys = get_keys(\\%h2);\n+my $buckets= buckets(\\%h2);\n $h2{$_}++ for @keys;\n+$h2{$counter++}++ while buckets(\\%h2) == $buckets; # force a split\n ok (Internals::HvREHASH(%h2), \n-    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash\");\n+    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash after split\");\n+\n+# returns the number of buckets in a hash\n+sub buckets {\n+    my $hr = shift;\n+    my $keys_buckets= scalar(%$hr);\n+    if ($keys_buckets=~m!\/([0-9]+)\\z!) {\n+        return 0+$1;\n+    } else {\n+        return 8;\n+    }\n+}\n \n sub get_keys {\n     my $hr = shift;\ndiff --git a\/hv.c b\/hv.c\nindex 89c6456185..865967872a 100644\n--- a\/hv.c\n+++ b\/hv.c\n@@ -35,7 +35,8 @@ holds the key and hash value.\n #define PERL_HASH_INTERNAL_ACCESS\n #include \"perl.h\"\n \n-#define HV_MAX_LENGTH_BEFORE_SPLIT 14\n+#define HV_MAX_LENGTH_BEFORE_REHASH 14\n+#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) \/* HvTOTALKEYS(hv) > HvMAX(hv) *\/\n \n static const char S_strtab_error[]\n     = \"Cannot modify shared string table in hv_%s\";\n@@ -818,23 +819,8 @@ Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,\n \txhv->xhv_keys++; \/* HvTOTALKEYS(hv)++ *\/\n \tif (!counter) {\t\t\t\t\/* initial entry? *\/\n \t    xhv->xhv_fill++; \/* HvFILL(hv)++ *\/\n-\t} else if (xhv->xhv_keys > (IV)xhv->xhv_max) {\n+\t} else if ( SHOULD_DO_HSPLIT(xhv) ) {\n \t    hsplit(hv);\n-\t} else if(!HvREHASH(hv)) {\n-\t    U32 n_links = 1;\n-\n-\t    while ((counter = HeNEXT(counter)))\n-\t\tn_links++;\n-\n-\t    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {\n-\t\t\/* Use only the old HvKEYS(hv) > HvMAX(hv) condition to limit\n-\t\t   bucket splits on a rehashed hash, as we're not going to\n-\t\t   split it again, and if someone is lucky (evil) enough to\n-\t\t   get all the keys in one list they could exhaust our memory\n-\t\t   as we repeatedly double the number of buckets on every\n-\t\t   entry. Linear search feels a less worse thing to do.  *\/\n-\t\thsplit(hv);\n-\t    }\n \t}\n     }\n \n@@ -1180,7 +1166,7 @@ S_hsplit(pTHX_ HV *hv)\n \n \n     \/* Pick your policy for \"hashing isn't working\" here:  *\/\n-    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT \/* split worked?  *\/\n+    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH \/* split worked?  *\/\n \t|| HvREHASH(hv)) {\n \treturn;\n     }\n@@ -2551,8 +2537,8 @@ S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)\n \txhv->xhv_keys++; \/* HvTOTALKEYS(hv)++ *\/\n \tif (!next) {\t\t\t\/* initial entry? *\/\n \t    xhv->xhv_fill++; \/* HvFILL(hv)++ *\/\n-\t} else if (xhv->xhv_keys > (IV)xhv->xhv_max \/* HvKEYS(hv) > HvMAX(hv) *\/) {\n-\t\thsplit(PL_strtab);\n+\t} else if ( SHOULD_DO_HSPLIT(xhv) ) {\n+            hsplit(PL_strtab);\n \t}\n     }\n \ndiff --git a\/t\/op\/hash.t b\/t\/op\/hash.t\nindex 9bde518732..45eb782b65 100644\n--- a\/t\/op\/hash.t\n+++ b\/t\/op\/hash.t\n@@ -39,22 +39,36 @@ use constant THRESHOLD => 14;\n use constant START     => \"a\";\n \n # some initial hash data\n-my %h2 = map {$_ => 1} 'a'..'cc';\n+my %h2;\n+my $counter= \"a\";\n+$h2{$counter++}++ while $counter ne 'cd';\n \n ok (!Internals::HvREHASH(%h2), \n     \"starting with pre-populated non-pathological hash (rehash flag if off)\");\n \n my @keys = get_keys(\\%h2);\n+my $buckets= buckets(\\%h2);\n $h2{$_}++ for @keys;\n+$h2{$counter++}++ while buckets(\\%h2) == $buckets; # force a split\n ok (Internals::HvREHASH(%h2), \n-    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash\");\n+    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash after split\");\n+\n+# returns the number of buckets in a hash\n+sub buckets {\n+    my $hr = shift;\n+    my $keys_buckets= scalar(%$hr);\n+    if ($keys_buckets=~m!\/([0-9]+)\\z!) {\n+        return 0+$1;\n+    } else {\n+        return 8;\n+    }\n+}\n \n sub get_keys {\n     my $hr = shift;\n \n     # the minimum of bits required to mount the attack on a hash\n     my $min_bits = log(THRESHOLD)\/log(2);\n-\n     # if the hash has already been populated with a significant amount\n     # of entries the number of mask bits can be higher\n     my $keys = scalar keys %$hr;\n-- \n2.15.1-424-g9478a660812\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7166","CWE_ID":"399","category":"security","commit_id":"6e06b1c89dd0d16f74894eac4cfc1327a06ee4a0","commit_message":"From 6e06b1c89dd0d16f74894eac4cfc1327a06ee4a0 Mon Sep 17 00:00:00 2001\nFrom: Tim Kientzle <kientzle@acm.org>\nDate: Sat, 10 Jan 2015 12:24:58 -0800\nSubject: [PATCH] Fix a potential crash issue discovered by Alexander\n Cherepanov:\n\nIt seems bsdtar automatically handles stacked compression. This is a\nnice feature but it could be problematic when it's completely\nunlimited.  Most clearly it's illustrated with quines:\n\n$ curl -sRO http:\/\/www.maximumcompression.com\/selfgz.gz\n$ (ulimit -v 10000000 && bsdtar -tvf selfgz.gz)\nbsdtar: Error opening archive: Can't allocate data for gzip decompression\n\nWithout ulimit, bsdtar will eat all available memory. This could also\nbe a problem for other applications using libarchive.\n---\n Makefile.am                                   |  2 +\n libarchive\/archive_read.c                     |  7 ++-\n libarchive\/test\/CMakeLists.txt                |  1 +\n libarchive\/test\/test_read_too_many_filters.c  | 45 +++++++++++++++++++\n ...\/test\/test_read_too_many_filters.gz.uu     | 15 +++++++\n 5 files changed, 68 insertions(+), 2 deletions(-)\n create mode 100644 libarchive\/test\/test_read_too_many_filters.c\n create mode 100644 libarchive\/test\/test_read_too_many_filters.gz.uu\n\n","diff_code":"diff --git a\/Makefile.am b\/Makefile.am\nindex d355eefcf..350e441c5 100644\n--- a\/Makefile.am\n+++ b\/Makefile.am\n@@ -482,6 +482,7 @@ libarchive_test_SOURCES= \\\n \tlibarchive\/test\/test_read_pax_truncated.c \\\n \tlibarchive\/test\/test_read_position.c \\\n \tlibarchive\/test\/test_read_set_format.c \\\n+\tlibarchive\/test\/test_read_too_many_filters.c \\\n \tlibarchive\/test\/test_read_truncated.c \\\n \tlibarchive\/test\/test_read_truncated_filter.c \\\n \tlibarchive\/test\/test_sparse_basic.c \\\n@@ -791,6 +792,7 @@ libarchive_test_EXTRA_DIST=\\\n \tlibarchive\/test\/test_read_splitted_rar_ab.uu \\\n \tlibarchive\/test\/test_read_splitted_rar_ac.uu \\\n \tlibarchive\/test\/test_read_splitted_rar_ad.uu \\\n+\tlibarchive\/test\/test_read_too_many_filters.gz.uu \\\n \tlibarchive\/test\/test_splitted_rar_seek_support_aa.uu \\\n \tlibarchive\/test\/test_splitted_rar_seek_support_ab.uu \\\n \tlibarchive\/test\/test_splitted_rar_seek_support_ac.uu \\\ndiff --git a\/libarchive\/archive_read.c b\/libarchive\/archive_read.c\nindex 02bf8d3aa..8f71a8b93 100644\n--- a\/libarchive\/archive_read.c\n+++ b\/libarchive\/archive_read.c\n@@ -548,13 +548,13 @@ archive_read_open1(struct archive *_a)\n static int\n choose_filters(struct archive_read *a)\n {\n-\tint number_bidders, i, bid, best_bid;\n+\tint number_bidders, i, bid, best_bid, n;\n \tstruct archive_read_filter_bidder *bidder, *best_bidder;\n \tstruct archive_read_filter *filter;\n \tssize_t avail;\n \tint r;\n \n-\tfor (;;) {\n+\tfor (n = 0; n < 25; ++n) {\n \t\tnumber_bidders = sizeof(a->bidders) \/ sizeof(a->bidders[0]);\n \n \t\tbest_bid = 0;\n@@ -600,6 +600,9 @@ choose_filters(struct archive_read *a)\n \t\t\treturn (ARCHIVE_FATAL);\n \t\t}\n \t}\n+\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n+\t    \"Input requires too many filters for decoding\");\n+\treturn (ARCHIVE_FATAL);\n }\n \n \/*\ndiff --git a\/libarchive\/test\/CMakeLists.txt b\/libarchive\/test\/CMakeLists.txt\nindex e23a7c28a..7f8002dec 100644\n--- a\/libarchive\/test\/CMakeLists.txt\n+++ b\/libarchive\/test\/CMakeLists.txt\n@@ -172,6 +172,7 @@ IF(ENABLE_TEST)\n     test_read_pax_truncated.c\n     test_read_position.c\n     test_read_set_format.c\n+    test_read_too_many_filters.c\n     test_read_truncated.c\n     test_read_truncated_filter.c\n     test_sparse_basic.c\ndiff --git a\/libarchive\/test\/test_read_too_many_filters.c b\/libarchive\/test\/test_read_too_many_filters.c\nnew file mode 100644\nindex 000000000..37cab24b4\n--- \/dev\/null\n+++ b\/libarchive\/test\/test_read_too_many_filters.c\n@@ -0,0 +1,45 @@\n+\/*-\n+ * Copyright (c) 2003-2008,2015 Tim Kientzle\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and\/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+#include \"test.h\"\n+\n+DEFINE_TEST(test_read_too_many_filters)\n+{\n+\tconst char *name = \"test_read_too_many_filters.gz\";\n+\tstruct archive *a;\n+\tint r;\n+\n+\tassert((a = archive_read_new()) != NULL);\n+\tr = archive_read_support_filter_gzip(a);\n+\tif (r == ARCHIVE_WARN) {\n+\t\tskipping(\"gzip reading not fully supported on this platform\");\n+\t}\n+\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));\n+\textract_reference_file(name);\n+\tassertEqualIntA(a, ARCHIVE_FATAL,\n+\t    archive_read_open_filename(a, name, 200));\n+\n+\tassertEqualInt(ARCHIVE_OK, archive_read_close(a));\n+\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n+}\ndiff --git a\/libarchive\/test\/test_read_too_many_filters.gz.uu b\/libarchive\/test\/test_read_too_many_filters.gz.uu\nnew file mode 100644\nindex 000000000..6bf6614f3\n--- \/dev\/null\n+++ b\/libarchive\/test\/test_read_too_many_filters.gz.uu\n@@ -0,0 +1,15 @@\n+This is a valid gzip file that decompresses to itself, from\n+  http:\/\/www.maximumcompression.com\/selfgz.gz\n+\n+This is used in test_read_too_many_filters to try to\n+crash libarchive by forcing it to spawn an unending\n+list of gunzip filters.\n+\n+begin 644 test_read_too_many_filters.gz\n+M'XL(`````````P`\/`\/#_'XL(`````````P`\/`\/#_````__\\```#__X)QH5P`\n+M`!X`X?\\```#__P```\/__@G&A7```'@#A_P```\/__````__\\```#__P```\/__\n+M````__\\```#__\\(FAF`!`!0`Z_\\```#__P```\/__PB:&8`$`%`#K_\\(FAF`!\n+M`!0`Z_^9(#6-B\"@Q,C,T`K\/`+```%`#K_P*SP\"P``!0`Z_]\"B\"'$`````\/__\n+>`P!#2DTAT@```$*((<0`````__\\#`$-*32'2````\n+`\n+end\n","owner":"libarchive","repo":"libarchive","source":"cve"},{"CVE_ID":"CVE-2013-1667","CWE_ID":"399","category":"security","commit_id":"6e79fe5714a72b1ef86dc890ff60746cdd19f854","commit_message":"From 6e79fe5714a72b1ef86dc890ff60746cdd19f854 Mon Sep 17 00:00:00 2001\nFrom: Yves Orton <demerphq@gmail.com>\nDate: Tue, 12 Feb 2013 10:53:05 +0100\nSubject: [PATCH] Prevent premature hsplit() calls, and only trigger REHASH\n after hsplit()\n\nTriggering a hsplit due to long chain length allows an attacker\nto create a carefully chosen set of keys which can cause the hash\nto use 2 * (2**32) * sizeof(void *) bytes ram. AKA a DOS via memory\nexhaustion. Doing so also takes non trivial time.\n\nEliminating this check, and only inspecting chain length after a\nnormal hsplit() (triggered when keys>buckets) prevents the attack\nentirely, and makes such attacks relatively benign.\n---\n ext\/Hash-Util-FieldHash\/t\/10_hash.t | 18 ++++++++++++++++--\n hv.c                                | 35 ++++++++---------------------------\n t\/op\/hash.t                         | 20 +++++++++++++++++---\n 3 files changed, 41 insertions(+), 32 deletions(-)\n\n","diff_code":"diff --git a\/ext\/Hash-Util-FieldHash\/t\/10_hash.t b\/ext\/Hash-Util-FieldHash\/t\/10_hash.t\nindex 2cfb4e81fa..d58f053d97 100644\n--- a\/ext\/Hash-Util-FieldHash\/t\/10_hash.t\n+++ b\/ext\/Hash-Util-FieldHash\/t\/10_hash.t\n@@ -38,15 +38,29 @@ use constant START     => \"a\";\n \n # some initial hash data\n fieldhash my %h2;\n-%h2 = map {$_ => 1} 'a'..'cc';\n+my $counter= \"a\";\n+$h2{$counter++}++ while $counter ne 'cd';\n \n ok (!Internals::HvREHASH(%h2), \n     \"starting with pre-populated non-pathological hash (rehash flag if off)\");\n \n my @keys = get_keys(\\%h2);\n+my $buckets= buckets(\\%h2);\n $h2{$_}++ for @keys;\n+$h2{$counter++}++ while buckets(\\%h2) == $buckets; # force a split\n ok (Internals::HvREHASH(%h2), \n-    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash\");\n+    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash after split\");\n+\n+# returns the number of buckets in a hash\n+sub buckets {\n+    my $hr = shift;\n+    my $keys_buckets= scalar(%$hr);\n+    if ($keys_buckets=~m!\/([0-9]+)\\z!) {\n+        return 0+$1;\n+    } else {\n+        return 8;\n+    }\n+}\n \n sub get_keys {\n     my $hr = shift;\ndiff --git a\/hv.c b\/hv.c\nindex 6b662518f6..a031703080 100644\n--- a\/hv.c\n+++ b\/hv.c\n@@ -35,7 +35,8 @@ holds the key and hash value.\n #define PERL_HASH_INTERNAL_ACCESS\n #include \"perl.h\"\n \n-#define HV_MAX_LENGTH_BEFORE_SPLIT 14\n+#define HV_MAX_LENGTH_BEFORE_REHASH 14\n+#define SHOULD_DO_HSPLIT(xhv) ((xhv)->xhv_keys > (xhv)->xhv_max) \/* HvTOTALKEYS(hv) > HvMAX(hv) *\/\n \n static const char S_strtab_error[]\n     = \"Cannot modify shared string table in hv_%s\";\n@@ -798,29 +799,9 @@ Perl_hv_common(pTHX_ HV *hv, SV *keysv, const char *key, STRLEN klen,\n     if (masked_flags & HVhek_ENABLEHVKFLAGS)\n \tHvHASKFLAGS_on(hv);\n \n-    {\n-\tconst HE *counter = HeNEXT(entry);\n-\n-\txhv->xhv_keys++; \/* HvTOTALKEYS(hv)++ *\/\n-\tif (!counter) {\t\t\t\t\/* initial entry? *\/\n-\t} else if (xhv->xhv_keys > xhv->xhv_max) {\n-\t\t\/* Use only the old HvUSEDKEYS(hv) > HvMAX(hv) condition to limit\n-\t\t   bucket splits on a rehashed hash, as we're not going to\n-\t\t   split it again, and if someone is lucky (evil) enough to\n-\t\t   get all the keys in one list they could exhaust our memory\n-\t\t   as we repeatedly double the number of buckets on every\n-\t\t   entry. Linear search feels a less worse thing to do.  *\/\n-\t    hsplit(hv);\n-\t} else if(!HvREHASH(hv)) {\n-\t    U32 n_links = 1;\n-\n-\t    while ((counter = HeNEXT(counter)))\n-\t\tn_links++;\n-\n-\t    if (n_links > HV_MAX_LENGTH_BEFORE_SPLIT) {\n-\t\thsplit(hv);\n-\t    }\n-\t}\n+    xhv->xhv_keys++; \/* HvTOTALKEYS(hv)++ *\/\n+    if ( SHOULD_DO_HSPLIT(xhv) ) {\n+        hsplit(hv);\n     }\n \n     if (return_svp) {\n@@ -1197,7 +1178,7 @@ S_hsplit(pTHX_ HV *hv)\n \n \n     \/* Pick your policy for \"hashing isn't working\" here:  *\/\n-    if (longest_chain <= HV_MAX_LENGTH_BEFORE_SPLIT \/* split worked?  *\/\n+    if (longest_chain <= HV_MAX_LENGTH_BEFORE_REHASH \/* split worked?  *\/\n \t|| HvREHASH(hv)) {\n \treturn;\n     }\n@@ -2782,8 +2763,8 @@ S_share_hek_flags(pTHX_ const char *str, I32 len, register U32 hash, int flags)\n \n \txhv->xhv_keys++; \/* HvTOTALKEYS(hv)++ *\/\n \tif (!next) {\t\t\t\/* initial entry? *\/\n-\t} else if (xhv->xhv_keys > xhv->xhv_max \/* HvUSEDKEYS(hv) > HvMAX(hv) *\/) {\n-\t\thsplit(PL_strtab);\n+\t} else if ( SHOULD_DO_HSPLIT(xhv) ) {\n+            hsplit(PL_strtab);\n \t}\n     }\n \ndiff --git a\/t\/op\/hash.t b\/t\/op\/hash.t\nindex ef757a3bc1..97eb81b9d0 100644\n--- a\/t\/op\/hash.t\n+++ b\/t\/op\/hash.t\n@@ -39,22 +39,36 @@ use constant THRESHOLD => 14;\n use constant START     => \"a\";\n \n # some initial hash data\n-my %h2 = map {$_ => 1} 'a'..'cc';\n+my %h2;\n+my $counter= \"a\";\n+$h2{$counter++}++ while $counter ne 'cd';\n \n ok (!Internals::HvREHASH(%h2), \n     \"starting with pre-populated non-pathological hash (rehash flag if off)\");\n \n my @keys = get_keys(\\%h2);\n+my $buckets= buckets(\\%h2);\n $h2{$_}++ for @keys;\n+$h2{$counter++}++ while buckets(\\%h2) == $buckets; # force a split\n ok (Internals::HvREHASH(%h2), \n-    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash\");\n+    scalar(@keys) . \" colliding into the same bucket keys are triggering rehash after split\");\n+\n+# returns the number of buckets in a hash\n+sub buckets {\n+    my $hr = shift;\n+    my $keys_buckets= scalar(%$hr);\n+    if ($keys_buckets=~m!\/([0-9]+)\\z!) {\n+        return 0+$1;\n+    } else {\n+        return 8;\n+    }\n+}\n \n sub get_keys {\n     my $hr = shift;\n \n     # the minimum of bits required to mount the attack on a hash\n     my $min_bits = log(THRESHOLD)\/log(2);\n-\n     # if the hash has already been populated with a significant amount\n     # of entries the number of mask bits can be higher\n     my $keys = scalar keys %$hr;\n-- \n2.15.1-424-g9478a660812\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-14222","CWE_ID":"399","category":"security","commit_id":"9cb4eb772839c5e1de2855d126bf74ff16d13382","commit_message":"From 9cb4eb772839c5e1de2855d126bf74ff16d13382 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Tue, 5 Sep 2017 00:16:29 +0200\nSubject: [PATCH] avformat\/mov: Fix DoS in read_tfra()\n\nFixes: Missing EOF check in loop\nNo testcase\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/mov.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/libavformat\/mov.c b\/libavformat\/mov.c\nindex 994e9c6ebaf..25197073454 100644\n--- a\/libavformat\/mov.c\n+++ b\/libavformat\/mov.c\n@@ -6094,6 +6094,13 @@ static int read_tfra(MOVContext *mov, AVIOContext *f)\n     }\n     for (i = 0; i < index->item_count; i++) {\n         int64_t time, offset;\n+\n+        if (avio_feof(f)) {\n+            index->item_count = 0;\n+            av_freep(&index->items);\n+            return AVERROR_INVALIDDATA;\n+        }\n+\n         if (version == 1) {\n             time   = avio_rb64(f);\n             offset = avio_rb64(f);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2015-8959","CWE_ID":"399","category":"security","commit_id":"9b428b7af688fe319320aed15f2b94281d1e37b4","commit_message":"From 9b428b7af688fe319320aed15f2b94281d1e37b4 Mon Sep 17 00:00:00 2001\nFrom: cristy <urban-warrior@git.imagemagick.org>\nDate: Sun, 11 Jan 2015 19:12:50 +0000\nSubject: [PATCH]\n\n---\n coders\/dds.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/coders\/dds.c b\/coders\/dds.c\nindex 2145736427..974fdaa65f 100644\n--- a\/coders\/dds.c\n+++ b\/coders\/dds.c\n@@ -2388,8 +2388,8 @@ static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n       {\n         offset = (MagickOffsetType) ((w + 3) \/ 4) * ((h + 3) \/ 4) * texel_size;\n-        (void) SeekBlob(image, offset, SEEK_CUR);\n-\n+        if (SeekBlob(image,offset,SEEK_CUR) < 0)\n+          break;\n         w = DIV2(w);\n         h = DIV2(h);\n       }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-4127","CWE_ID":"399","category":"security","commit_id":"dd7633ecd553a5e304d349aa6f8eb8a0417098c5","commit_message":"From dd7633ecd553a5e304d349aa6f8eb8a0417098c5 Mon Sep 17 00:00:00 2001\nFrom: \"Michael S. Tsirkin\" <mst@redhat.com>\nDate: Sun, 7 Jul 2013 14:26:53 +0300\nSubject: vhost-net: fix use-after-free in vhost_net_flush\n\nvhost_net_ubuf_put_and_wait has a confusing name:\nit will actually also free it's argument.\nThus since commit 1280c27f8e29acf4af2da914e80ec27c3dbd5c01\n    \"vhost-net: flush outstanding DMAs on memory change\"\nvhost_net_flush tries to use the argument after passing it\nto vhost_net_ubuf_put_and_wait, this results\nin use after free.\nTo fix, don't free the argument in vhost_net_ubuf_put_and_wait,\nadd an new API for callers that want to free ubufs.\n\nAcked-by: Asias He <asias@redhat.com>\nAcked-by: Jason Wang <jasowang@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/vhost\/net.c | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/vhost\/net.c b\/drivers\/vhost\/net.c\nindex f80d3dd41d8c..8ca5ac71b845 100644\n--- a\/drivers\/vhost\/net.c\n+++ b\/drivers\/vhost\/net.c\n@@ -150,6 +150,11 @@ static void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)\n {\n \tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n \twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n+}\n+\n+static void vhost_net_ubuf_put_wait_and_free(struct vhost_net_ubuf_ref *ubufs)\n+{\n+\tvhost_net_ubuf_put_and_wait(ubufs);\n \tkfree(ubufs);\n }\n \n@@ -948,7 +953,7 @@ static long vhost_net_set_backend(struct vhost_net *n, unsigned index, int fd)\n \tmutex_unlock(&vq->mutex);\n \n \tif (oldubufs) {\n-\t\tvhost_net_ubuf_put_and_wait(oldubufs);\n+\t\tvhost_net_ubuf_put_wait_and_free(oldubufs);\n \t\tmutex_lock(&vq->mutex);\n \t\tvhost_zerocopy_signal_used(n, vq);\n \t\tmutex_unlock(&vq->mutex);\n@@ -966,7 +971,7 @@ err_used:\n \trcu_assign_pointer(vq->private_data, oldsock);\n \tvhost_net_enable_vq(n, vq);\n \tif (ubufs)\n-\t\tvhost_net_ubuf_put_and_wait(ubufs);\n+\t\tvhost_net_ubuf_put_wait_and_free(ubufs);\n err_ubufs:\n \tfput(sock->file);\n err_vq:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-0841","CWE_ID":"399","category":"security","commit_id":"8973d58b7498fa5100a876815476b81fd1a2412a","commit_message":"From 8973d58b7498fa5100a876815476b81fd1a2412a Mon Sep 17 00:00:00 2001\nFrom: Daniel Veillard <veillard@redhat.com>\nDate: Sat, 4 Feb 2012 19:07:44 +0800\nSubject: [PATCH] Add hash randomization to hash and dict structures\n\nFollowing http:\/\/www.ocert.org\/advisories\/ocert-2011-003.html\nit seems that having hash randomization might be a good idea\nwhen using XML with untrusted data\n* configure.in: lookup for rand, srand and time\n* dict.c: add randomization to dictionaries hash tables\n* hash.c: add randomization to normal hash tables\n---\n configure.in |  1 +\n dict.c       | 81 ++++++++++++++++++++++++++++++++++++----------------\n hash.c       | 38 +++++++++++++++++++++++-\n 3 files changed, 95 insertions(+), 25 deletions(-)\n\n","diff_code":"diff --git a\/configure.in b\/configure.in\nindex fa803750..828b66a9 100644\n--- a\/configure.in\n+++ b\/configure.in\n@@ -512,6 +512,7 @@ AC_CHECK_FUNCS(strdup strndup strerror)\n AC_CHECK_FUNCS(finite isnand fp_class class fpclass)\n AC_CHECK_FUNCS(strftime localtime gettimeofday ftime)\n AC_CHECK_FUNCS(stat _stat signal)\n+AC_CHECK_FUNCS(rand srand time)\n \n dnl Checking the standard string functions availability\n AC_CHECK_FUNCS(printf sprintf fprintf snprintf vfprintf vsprintf vsnprintf sscanf,,\ndiff --git a\/dict.c b\/dict.c\nindex 3eff2315..ae4966bc 100644\n--- a\/dict.c\n+++ b\/dict.c\n@@ -2,7 +2,7 @@\n  * dict.c: dictionary of reusable strings, just used to avoid allocation\n  *         and freeing operations.\n  *\n- * Copyright (C) 2003 Daniel Veillard.\n+ * Copyright (C) 2003-2012 Daniel Veillard.\n  *\n  * Permission to use, copy, modify, and distribute this software for any\n  * purpose with or without fee is hereby granted, provided that the above\n@@ -19,6 +19,28 @@\n #define IN_LIBXML\n #include \"libxml.h\"\n \n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_TIME_H\n+#include <time.h>\n+#endif\n+\n+\/*\n+ * Following http:\/\/www.ocert.org\/advisories\/ocert-2011-003.html\n+ * it seems that having hash randomization might be a good idea\n+ * when using XML with untrusted data\n+ * Note1: that it works correctly only if compiled with WITH_BIG_KEY\n+ *  which is the default.\n+ * Note2: the fast function used for a small dict won't protect very\n+ *  well but since the attack is based on growing a very big hash\n+ *  list we will use the BigKey algo as soon as the hash size grows\n+ *  over MIN_DICT_SIZE so this actually works\n+ *\/\n+#if defined(HAVE_RAND) && defined(HAVE_SRAND) && defined(HAVE_TIME)\n+#define DICT_RANDOMIZATION\n+#endif\n+\n #include <string.h>\n #ifdef HAVE_STDINT_H\n #include <stdint.h>\n@@ -44,23 +66,23 @@ typedef unsigned __int32 uint32_t;\n #define WITH_BIG_KEY\n \n #ifdef WITH_BIG_KEY\n-#define xmlDictComputeKey(dict, name, len)\t\t\t\\\n-    (((dict)->size == MIN_DICT_SIZE) ?\t\t\t\t\\\n-     xmlDictComputeFastKey(name, len) :\t\t\t\t\\\n-     xmlDictComputeBigKey(name, len))\n-\n-#define xmlDictComputeQKey(dict, prefix, plen, name, len)\t\\\n-    (((prefix) == NULL) ?\t\t\t\t\t\\\n-      (xmlDictComputeKey(dict, name, len)) :\t\t\t\\\n-      (((dict)->size == MIN_DICT_SIZE) ?\t\t\t\\\n-       xmlDictComputeFastQKey(prefix, plen, name, len) :\t\\\n-       xmlDictComputeBigQKey(prefix, plen, name, len)))\n+#define xmlDictComputeKey(dict, name, len)                              \\\n+    (((dict)->size == MIN_DICT_SIZE) ?                                  \\\n+     xmlDictComputeFastKey(name, len, (dict)->seed) :                   \\\n+     xmlDictComputeBigKey(name, len, (dict)->seed))\n+\n+#define xmlDictComputeQKey(dict, prefix, plen, name, len)               \\\n+    (((prefix) == NULL) ?                                               \\\n+      (xmlDictComputeKey(dict, name, len)) :                             \\\n+      (((dict)->size == MIN_DICT_SIZE) ?                                \\\n+       xmlDictComputeFastQKey(prefix, plen, name, len, (dict)->seed) :\t\\\n+       xmlDictComputeBigQKey(prefix, plen, name, len, (dict)->seed)))\n \n #else \/* !WITH_BIG_KEY *\/\n-#define xmlDictComputeKey(dict, name, len)\t\t\t\\\n-        xmlDictComputeFastKey(name, len)\n-#define xmlDictComputeQKey(dict, prefix, plen, name, len)\t\\\n-        xmlDictComputeFastQKey(prefix, plen, name, len)\n+#define xmlDictComputeKey(dict, name, len)                              \\\n+        xmlDictComputeFastKey(name, len, (dict)->seed)\n+#define xmlDictComputeQKey(dict, prefix, plen, name, len)               \\\n+        xmlDictComputeFastQKey(prefix, plen, name, len, (dict)->seed)\n #endif \/* WITH_BIG_KEY *\/\n \n \/*\n@@ -98,6 +120,8 @@ struct _xmlDict {\n     xmlDictStringsPtr strings;\n \n     struct _xmlDict *subdict;\n+    \/* used for randomization *\/\n+    int seed;\n };\n \n \/*\n@@ -125,6 +149,9 @@ static int xmlInitializeDict(void) {\n     if ((xmlDictMutex = xmlNewRMutex()) == NULL)\n         return(0);\n \n+#ifdef DICT_RANDOMIZATION\n+    srand(time(NULL));\n+#endif\n     xmlDictInitialized = 1;\n     return(1);\n }\n@@ -277,13 +304,13 @@ found_pool:\n  *\/\n \n static uint32_t\n-xmlDictComputeBigKey(const xmlChar* data, int namelen) {\n+xmlDictComputeBigKey(const xmlChar* data, int namelen, int seed) {\n     uint32_t hash;\n     int i;\n \n     if (namelen <= 0 || data == NULL) return(0);\n \n-    hash = 0;\n+    hash = seed;\n \n     for (i = 0;i < namelen; i++) {\n         hash += data[i];\n@@ -310,12 +337,12 @@ xmlDictComputeBigKey(const xmlChar* data, int namelen) {\n  *\/\n static unsigned long\n xmlDictComputeBigQKey(const xmlChar *prefix, int plen,\n-                      const xmlChar *name, int len)\n+                      const xmlChar *name, int len, int seed)\n {\n     uint32_t hash;\n     int i;\n \n-    hash = 0;\n+    hash = seed;\n \n     for (i = 0;i < plen; i++) {\n         hash += prefix[i];\n@@ -346,8 +373,8 @@ xmlDictComputeBigQKey(const xmlChar *prefix, int plen,\n  * for low hash table fill.\n  *\/\n static unsigned long\n-xmlDictComputeFastKey(const xmlChar *name, int namelen) {\n-    unsigned long value = 0L;\n+xmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {\n+    unsigned long value = seed;\n \n     if (name == NULL) return(0);\n     value = *name;\n@@ -381,9 +408,9 @@ xmlDictComputeFastKey(const xmlChar *name, int namelen) {\n  *\/\n static unsigned long\n xmlDictComputeFastQKey(const xmlChar *prefix, int plen,\n-                       const xmlChar *name, int len)\n+                       const xmlChar *name, int len, int seed)\n {\n-    unsigned long value = 0L;\n+    unsigned long value = (unsigned long) seed;\n \n     if (plen == 0)\n \tvalue += 30 * (unsigned long) ':';\n@@ -460,6 +487,11 @@ xmlDictCreate(void) {\n \tdict->subdict = NULL;\n         if (dict->dict) {\n \t    memset(dict->dict, 0, MIN_DICT_SIZE * sizeof(xmlDictEntry));\n+#ifdef DICT_RANDOMIZATION\n+            dict->seed = rand();\n+#else\n+            dict->seed = 0;\n+#endif\n \t    return(dict);\n         }\n         xmlFree(dict);\n@@ -486,6 +518,7 @@ xmlDictCreateSub(xmlDictPtr sub) {\n #ifdef DICT_DEBUG_PATTERNS\n         fprintf(stderr, \"R\");\n #endif\n+        dict->seed = sub->seed;\n         dict->subdict = sub;\n \txmlDictReference(dict->subdict);\n     }\ndiff --git a\/hash.c b\/hash.c\nindex b78bc2d4..fe1424f2 100644\n--- a\/hash.c\n+++ b\/hash.c\n@@ -3,7 +3,7 @@\n  *\n  * Reference: Your favorite introductory book on algorithms\n  *\n- * Copyright (C) 2000 Bjorn Reese and Daniel Veillard.\n+ * Copyright (C) 2000,2012 Bjorn Reese and Daniel Veillard.\n  *\n  * Permission to use, copy, modify, and distribute this software for any\n  * purpose with or without fee is hereby granted, provided that the above\n@@ -21,6 +21,22 @@\n #include \"libxml.h\"\n \n #include <string.h>\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+#ifdef HAVE_TIME_H\n+#include <time.h>\n+#endif\n+\n+\/*\n+ * Following http:\/\/www.ocert.org\/advisories\/ocert-2011-003.html\n+ * it seems that having hash randomization might be a good idea\n+ * when using XML with untrusted data\n+ *\/\n+#if defined(HAVE_RAND) && defined(HAVE_SRAND) && defined(HAVE_TIME)\n+#define HASH_RANDOMIZATION\n+#endif\n+\n #include <libxml\/parser.h>\n #include <libxml\/hash.h>\n #include <libxml\/xmlmemory.h>\n@@ -31,6 +47,10 @@\n \n \/* #define DEBUG_GROW *\/\n \n+#ifdef HASH_RANDOMIZATION\n+static int hash_initialized = 0;\n+#endif\n+\n \/*\n  * A single entry in the hash table\n  *\/\n@@ -53,6 +73,9 @@ struct _xmlHashTable {\n     int size;\n     int nbElems;\n     xmlDictPtr dict;\n+#ifdef HASH_RANDOMIZATION\n+    int random_seed;\n+#endif\n };\n \n \/*\n@@ -65,6 +88,9 @@ xmlHashComputeKey(xmlHashTablePtr table, const xmlChar *name,\n     unsigned long value = 0L;\n     char ch;\n     \n+#ifdef HASH_RANDOMIZATION\n+    value = table->random_seed;\n+#endif\n     if (name != NULL) {\n \tvalue += 30 * (*name);\n \twhile ((ch = *name++) != 0) {\n@@ -92,6 +118,9 @@ xmlHashComputeQKey(xmlHashTablePtr table,\n     unsigned long value = 0L;\n     char ch;\n     \n+#ifdef HASH_RANDOMIZATION\n+    value = table->random_seed;\n+#endif\n     if (prefix != NULL)\n \tvalue += 30 * (*prefix);\n     else\n@@ -156,6 +185,13 @@ xmlHashCreate(int size) {\n         table->table = xmlMalloc(size * sizeof(xmlHashEntry));\n         if (table->table) {\n   \t    memset(table->table, 0, size * sizeof(xmlHashEntry));\n+#ifdef HASH_RANDOMIZATION\n+            if (!hash_initialized) {\n+                srand(time(NULL));\n+                hash_initialized = 1;\n+            }\n+            table->random_seed = rand();\n+#endif\n   \t    return(table);\n         }\n         xmlFree(table);\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-10021","CWE_ID":"399","category":"security","commit_id":"318aaf34f1179b39fa9c30fa0f3288b645beee39","commit_message":"From 318aaf34f1179b39fa9c30fa0f3288b645beee39 Mon Sep 17 00:00:00 2001\nFrom: Jason Yan <yanaijie@huawei.com>\nDate: Thu, 8 Mar 2018 10:34:53 +0800\nSubject: [PATCH] scsi: libsas: defer ata device eh commands to libata\n\nWhen ata device doing EH, some commands still attached with tasks are\nnot passed to libata when abort failed or recover failed, so libata did\nnot handle these commands. After these commands done, sas task is freed,\nbut ata qc is not freed. This will cause ata qc leak and trigger a\nwarning like below:\n\nWARNING: CPU: 0 PID: 28512 at drivers\/ata\/libata-eh.c:4037\nata_eh_finish+0xb4\/0xcc\nCPU: 0 PID: 28512 Comm: kworker\/u32:2 Tainted: G     W  OE 4.14.0#1\n......\nCall trace:\n[<ffff0000088b7bd0>] ata_eh_finish+0xb4\/0xcc\n[<ffff0000088b8420>] ata_do_eh+0xc4\/0xd8\n[<ffff0000088b8478>] ata_std_error_handler+0x44\/0x8c\n[<ffff0000088b8068>] ata_scsi_port_error_handler+0x480\/0x694\n[<ffff000008875fc4>] async_sas_ata_eh+0x4c\/0x80\n[<ffff0000080f6be8>] async_run_entry_fn+0x4c\/0x170\n[<ffff0000080ebd70>] process_one_work+0x144\/0x390\n[<ffff0000080ec100>] worker_thread+0x144\/0x418\n[<ffff0000080f2c98>] kthread+0x10c\/0x138\n[<ffff0000080855dc>] ret_from_fork+0x10\/0x18\n\nIf ata qc leaked too many, ata tag allocation will fail and io blocked\nfor ever.\n\nAs suggested by Dan Williams, defer ata device commands to libata and\nmerge sas_eh_finish_cmd() with sas_eh_defer_cmd(). libata will handle\nata qcs correctly after this.\n\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nCC: Xiaofei Tan <tanxiaofei@huawei.com>\nCC: John Garry <john.garry@huawei.com>\nCC: Dan Williams <dan.j.williams@intel.com>\nReviewed-by: Dan Williams <dan.j.williams@intel.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>\n---\n drivers\/scsi\/libsas\/sas_scsi_host.c | 33 ++++++++++++-----------------\n 1 file changed, 13 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/scsi\/libsas\/sas_scsi_host.c b\/drivers\/scsi\/libsas\/sas_scsi_host.c\nindex 62672720788928..a372af68d9a94b 100644\n--- a\/drivers\/scsi\/libsas\/sas_scsi_host.c\n+++ b\/drivers\/scsi\/libsas\/sas_scsi_host.c\n@@ -223,6 +223,7 @@ int sas_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmd)\n static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n {\n \tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);\n+\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n \tstruct sas_task *task = TO_SAS_TASK(cmd);\n \n \t\/* At this point, we only get called following an actual abort\n@@ -231,6 +232,14 @@ static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n \t *\/\n \tsas_end_task(cmd, task);\n \n+\tif (dev_is_sata(dev)) {\n+\t\t\/* defer commands to libata so that libata EH can\n+\t\t * handle ata qcs correctly\n+\t\t *\/\n+\t\tlist_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);\n+\t\treturn;\n+\t}\n+\n \t\/* now finish the command and move it on to the error\n \t * handler done list, this also takes it off the\n \t * error handler pending list.\n@@ -238,22 +247,6 @@ static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n \tscsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);\n }\n \n-static void sas_eh_defer_cmd(struct scsi_cmnd *cmd)\n-{\n-\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n-\tstruct sas_ha_struct *ha = dev->port->ha;\n-\tstruct sas_task *task = TO_SAS_TASK(cmd);\n-\n-\tif (!dev_is_sata(dev)) {\n-\t\tsas_eh_finish_cmd(cmd);\n-\t\treturn;\n-\t}\n-\n-\t\/* report the timeout to libata *\/\n-\tsas_end_task(cmd, task);\n-\tlist_move_tail(&cmd->eh_entry, &ha->eh_ata_q);\n-}\n-\n static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n {\n \tstruct scsi_cmnd *cmd, *n;\n@@ -261,7 +254,7 @@ static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd\n \tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n \t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n \t\t    cmd->device->lun == my_cmd->device->lun)\n-\t\t\tsas_eh_defer_cmd(cmd);\n+\t\t\tsas_eh_finish_cmd(cmd);\n \t}\n }\n \n@@ -618,12 +611,12 @@ static void sas_eh_handle_sas_errors(struct Scsi_Host *shost, struct list_head *\n \t\tcase TASK_IS_DONE:\n \t\t\tSAS_DPRINTK(\"%s: task 0x%p is done\\n\", __func__,\n \t\t\t\t    task);\n-\t\t\tsas_eh_defer_cmd(cmd);\n+\t\t\tsas_eh_finish_cmd(cmd);\n \t\t\tcontinue;\n \t\tcase TASK_IS_ABORTED:\n \t\t\tSAS_DPRINTK(\"%s: task 0x%p is aborted\\n\",\n \t\t\t\t    __func__, task);\n-\t\t\tsas_eh_defer_cmd(cmd);\n+\t\t\tsas_eh_finish_cmd(cmd);\n \t\t\tcontinue;\n \t\tcase TASK_IS_AT_LU:\n \t\t\tSAS_DPRINTK(\"task 0x%p is at LU: lu recover\\n\", task);\n@@ -634,7 +627,7 @@ static void sas_eh_handle_sas_errors(struct Scsi_Host *shost, struct list_head *\n \t\t\t\t\t    \"recovered\\n\",\n \t\t\t\t\t    SAS_ADDR(task->dev),\n \t\t\t\t\t    cmd->device->lun);\n-\t\t\t\tsas_eh_defer_cmd(cmd);\n+\t\t\t\tsas_eh_finish_cmd(cmd);\n \t\t\t\tsas_scsi_clear_queue_lu(work_q, cmd);\n \t\t\t\tgoto Again;\n \t\t\t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-7441","CWE_ID":"399","category":"security","commit_id":"741495cb08503fd32a9d22648e63b64390c601f4","commit_message":"From 741495cb08503fd32a9d22648e63b64390c601f4 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Tuomas=20R=C3=A4s=C3=A4nen?= <tuomasjjrasanen@opinsys.fi>\nDate: Wed, 5 Jun 2013 20:42:31 +0300\nSubject: [PATCH] nbd-server: handle modern-style negotiation in a child\n process\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nPreviously, the modern style negotiation was carried out in the root\nserver (listener) process before forking the actual client handler. This\nmade it possible for a malfunctioning or evil client to terminate the\nroot process simply by querying a non-existent export or aborting in the\nmiddle of the negotation process (caused SIGPIPE in the server).\n\nThis commit moves the negotiation process to the child to keep the root\nprocess up and running no matter what happens during the negotiation.\n\nSee http:\/\/sourceforge.net\/mailarchive\/message.php?msg_id=30410146\n\nSigned-off-by: Tuomas R\u00e4s\u00e4nen <tuomasjjrasanen@tjjr.fi>\n---\n nbd-server.c | 169 +++++++++++++++++++++++++++++++++++++++++++++++----\n 1 file changed, 157 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/nbd-server.c b\/nbd-server.c\nindex 392ed9f3..bfc6790e 100644\n--- a\/nbd-server.c\n+++ b\/nbd-server.c\n@@ -2198,6 +2198,161 @@ void destroy_pid_t(gpointer data) {\n \tg_free(data);\n }\n \n+static pid_t\n+spawn_child()\n+{\n+        pid_t pid;\n+        sigset_t newset;\n+        sigset_t oldset;\n+\n+        sigemptyset(&newset);\n+        sigaddset(&newset, SIGCHLD);\n+        sigaddset(&newset, SIGTERM);\n+        sigprocmask(SIG_BLOCK, &newset, &oldset);\n+        pid = fork();\n+        if (pid < 0) {\n+                msg(LOG_ERR, \"Could not fork (%s)\", strerror(errno));\n+                goto out;\n+        }\n+        if (pid > 0) { \/* Parent *\/\n+                pid_t *pidp;\n+\n+                pidp = g_malloc(sizeof(pid_t));\n+                *pidp = pid;\n+                g_hash_table_insert(children, pidp, pidp);\n+                goto out;\n+        }\n+        \/* Child *\/\n+        signal(SIGCHLD, SIG_DFL);\n+        signal(SIGTERM, SIG_DFL);\n+        signal(SIGHUP, SIG_DFL);\n+out:\n+        sigprocmask(SIG_SETMASK, &oldset, NULL);\n+        return pid;\n+}\n+\n+static int\n+socket_accept(const int sock)\n+{\n+        struct sockaddr_storage addrin;\n+        socklen_t addrinlen = sizeof(addrin);\n+        int net;\n+\n+        net = accept(sock, (struct sockaddr *) &addrin, &addrinlen);\n+        if (net < 0) {\n+                err_nonfatal(\"Failed to accept socket connection: %m\");\n+        }\n+\n+        return net;\n+}\n+\n+static void\n+handle_modern_connection(GArray *const servers, const int sock)\n+{\n+        int net;\n+        pid_t pid;\n+        CLIENT *client = NULL;\n+        int sock_flags_old;\n+        int sock_flags_new;\n+\n+        net = socket_accept(sock);\n+        if (net < 0)\n+                return;\n+\n+        if (!dontfork) {\n+                pid = spawn_child();\n+                if (pid) {\n+                        if (pid > 0)\n+                                msg(LOG_INFO, \"Spawned a child process\");\n+                        if (pid < 0)\n+                                msg(LOG_ERR, \"Failed to spawn a child process\");\n+                        close(net);\n+                        return;\n+                }\n+                \/* Child just continues. *\/\n+        }\n+\n+        client = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);\n+        if (!client) {\n+                msg(LOG_ERR, \"Modern initial negotiation failed\");\n+                goto handler_err;\n+        }\n+\n+        if (client->server->max_connections > 0 &&\n+           g_hash_table_size(children) >= client->server->max_connections) {\n+                msg(LOG_ERR, \"Max connections (%d) reached\",\n+                    client->server->max_connections);\n+                goto handler_err;\n+        }\n+\n+        sock_flags_old = fcntl(net, F_GETFL, 0);\n+        if (sock_flags_old == -1) {\n+                msg(LOG_ERR, \"Failed to get socket flags\");\n+                goto handler_err;\n+        }\n+\n+        sock_flags_new = sock_flags_old & ~O_NONBLOCK;\n+        if (sock_flags_new != sock_flags_old &&\n+            fcntl(net, F_SETFL, sock_flags_new) == -1) {\n+                msg(LOG_ERR, \"Failed to set socket to blocking mode\");\n+                goto handler_err;\n+        }\n+\n+        if (set_peername(net, client)) {\n+                msg(LOG_ERR, \"Failed to set peername\");\n+                goto handler_err;\n+        }\n+\n+        if (!authorized_client(client)) {\n+                msg(LOG_INFO, \"Client '%s' is not authorized to access\",\n+                    client->clientname);\n+                goto handler_err;\n+        }\n+\n+        if (!dontfork) {\n+                int i;\n+\n+                \/* Free all root server resources here, because we are\n+                 * currently in the child process serving one specific\n+                 * connection. These are not simply needed anymore. *\/\n+                g_hash_table_destroy(children);\n+                children = NULL;\n+                for (i = 0; i < modernsocks->len; i++) {\n+                        close(g_array_index(modernsocks, int, i));\n+                }\n+                g_array_free(modernsocks, TRUE);\n+\n+                \/* Now that we are in the child process after a\n+                 * succesful negotiation, we do not need the list of\n+                 * servers anymore, get rid of it.*\/\n+\n+                for (i = 0; i < servers->len; i++) {\n+                        const SERVER *const server = &g_array_index(servers, SERVER, i);\n+                        close(server->socket);\n+                }\n+\n+                \/* FALSE does not free the\n+                   actual data. This is required,\n+                   because the client has a\n+                   direct reference into that\n+                   data, and otherwise we get a\n+                   segfault... *\/\n+                g_array_free(servers, FALSE);\n+        }\n+\n+        msg(LOG_INFO, \"Starting to serve\");\n+        serveconnection(client);\n+        exit(EXIT_SUCCESS);\n+\n+handler_err:\n+        g_free(client);\n+        close(net);\n+\n+        if (!dontfork) {\n+                exit(EXIT_FAILURE);\n+        }\n+}\n+\n static void\n handle_connection(GArray *servers, int net, SERVER *serve, CLIENT *client)\n {\n@@ -2425,7 +2580,6 @@ void serveloop(GArray* servers) {\n \n \t\tmemcpy(&rset, &mset, sizeof(fd_set));\n \t\tif(select(max+1, &rset, NULL, NULL, NULL)>0) {\n-\t\t\tint net;\n \n \t\t\tDEBUG(\"accept, \");\n \t\t\tfor(i=0; i < modernsocks->len; i++) {\n@@ -2433,20 +2587,11 @@ void serveloop(GArray* servers) {\n \t\t\t\tif(!FD_ISSET(sock, &rset)) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\tCLIENT *client;\n \n-\t\t\t\tif((net=accept(sock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {\n-\t\t\t\t\terr_nonfatal(\"accept: %m\");\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\tclient = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);\n-\t\t\t\tif(!client) {\n-\t\t\t\t\tclose(net);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t\thandle_connection(servers, net, client->server, client);\n+\t\t\t\thandle_modern_connection(servers, sock);\n \t\t\t}\n \t\t\tfor(i=0; i < servers->len; i++) {\n+\t\t\t\tint net;\n \t\t\t\tSERVER *serve;\n \n \t\t\t\tserve=&(g_array_index(servers, SERVER, i));\n","owner":"yoe","repo":"nbd","source":"cve"},{"CVE_ID":"CVE-2010-4342","CWE_ID":"399","category":"security","commit_id":"4e085e76cbe558b79b54cbab772f61185879bc64","commit_message":"From 4e085e76cbe558b79b54cbab772f61185879bc64 Mon Sep 17 00:00:00 2001\nFrom: \"David S. Miller\" <davem@davemloft.net>\nDate: Wed, 8 Dec 2010 18:42:23 -0800\nSubject: econet: Fix crash in aun_incoming().\n\nUnconditional use of skb->dev won't work here,\ntry to fetch the econet device via skb_dst()->dev\ninstead.\n\nSuggested by Eric Dumazet.\n\nReported-by: Nelson Elhage <nelhage@ksplice.com>\nTested-by: Nelson Elhage <nelhage@ksplice.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/econet\/af_econet.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/econet\/af_econet.c b\/net\/econet\/af_econet.c\nindex f180371fa415..15dcc1a586b4 100644\n--- a\/net\/econet\/af_econet.c\n+++ b\/net\/econet\/af_econet.c\n@@ -851,9 +851,13 @@ static void aun_incoming(struct sk_buff *skb, struct aunhdr *ah, size_t len)\n {\n \tstruct iphdr *ip = ip_hdr(skb);\n \tunsigned char stn = ntohl(ip->saddr) & 0xff;\n+\tstruct dst_entry *dst = skb_dst(skb);\n+\tstruct ec_device *edev = NULL;\n \tstruct sock *sk = NULL;\n \tstruct sk_buff *newskb;\n-\tstruct ec_device *edev = skb->dev->ec_ptr;\n+\n+\tif (dst)\n+\t\tedev = dst->dev->ec_ptr;\n \n \tif (! edev)\n \t\tgoto bad;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-0747","CWE_ID":"399","category":"security","commit_id":"06a279d636734da32bb62dd2f7b0ade666f65d7c","commit_message":"From 06a279d636734da32bb62dd2f7b0ade666f65d7c Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Sat, 17 Jan 2009 18:41:37 -0500\nSubject: ext4: only use i_size_high for regular files\n\nDirectories are not allowed to be bigger than 2GB, so don't use\ni_size_high for anything other than regular files.  E2fsck should\ncomplain about these inodes, but the simplest thing to do for the\nkernel is to only use i_size_high for regular files.\n\nThis prevents an intentially corrupted filesystem from causing the\nkernel to burn a huge amount of CPU and issuing error messages such\nas:\n\nEXT4-fs warning (device loop0): ext4_block_to_path: block 135090028 > max\n\nThanks to David Maciejak from Fortinet's FortiGuard Global Security\nResearch Team for reporting this issue.\n\nhttp:\/\/bugzilla.kernel.org\/show_bug.cgi?id=12375\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org\n---\n fs\/ext4\/ext4.h  | 7 +++++--\n fs\/ext4\/inode.c | 4 ++--\n 2 files changed, 7 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/ext4.h b\/fs\/ext4\/ext4.h\nindex c668e4377d76..aafc9eba1c25 100644\n--- a\/fs\/ext4\/ext4.h\n+++ b\/fs\/ext4\/ext4.h\n@@ -1206,8 +1206,11 @@ static inline void ext4_r_blocks_count_set(struct ext4_super_block *es,\n \n static inline loff_t ext4_isize(struct ext4_inode *raw_inode)\n {\n-\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n-\t\tle32_to_cpu(raw_inode->i_size_lo);\n+\tif (S_ISREG(le16_to_cpu(raw_inode->i_mode)))\n+\t\treturn ((loff_t)le32_to_cpu(raw_inode->i_size_high) << 32) |\n+\t\t\tle32_to_cpu(raw_inode->i_size_lo);\n+\telse\n+\t\treturn (loff_t) le32_to_cpu(raw_inode->i_size_lo);\n }\n \n static inline void ext4_isize_set(struct ext4_inode *raw_inode, loff_t i_size)\ndiff --git a\/fs\/ext4\/inode.c b\/fs\/ext4\/inode.c\nindex a6444cee0c7e..49484ba801c9 100644\n--- a\/fs\/ext4\/inode.c\n+++ b\/fs\/ext4\/inode.c\n@@ -360,9 +360,9 @@ static int ext4_block_to_path(struct inode *inode,\n \t\tfinal = ptrs;\n \t} else {\n \t\text4_warning(inode->i_sb, \"ext4_block_to_path\",\n-\t\t\t\t\"block %lu > max\",\n+\t\t\t\t\"block %lu > max in inode %lu\",\n \t\t\t\ti_block + direct_blocks +\n-\t\t\t\tindirect_blocks + double_blocks);\n+\t\t\t\tindirect_blocks + double_blocks, inode->i_ino);\n \t}\n \tif (boundary)\n \t\t*boundary = final - 1 - (i_block & (ptrs - 1));\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-6697","CWE_ID":"399","category":"security","commit_id":"58c893e834ff20495d007709220881a3ff13f423","commit_message":"From 58c893e834ff20495d007709220881a3ff13f423 Mon Sep 17 00:00:00 2001\nFrom: Adam <Adam@anope.org>\nDate: Tue, 27 Mar 2012 21:39:50 -0400\nSubject: [PATCH] Fixed infinite loop cauesd by invalid dns packets\n\n---\n src\/dns.cpp | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/dns.cpp b\/src\/dns.cpp\nindex be74e6aa34..58cbcca766 100644\n--- a\/src\/dns.cpp\n+++ b\/src\/dns.cpp\n@@ -800,6 +800,8 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)\n \t\t *\/\n \t\tcase DNS_QUERY_CNAME:\n \t\tcase DNS_QUERY_PTR:\n+\t\t{\n+\t\t\tunsigned short lowest_pos = length;\n \t\t\to = 0;\n \t\t\tq = 0;\n \t\t\twhile (q == 0 && i < length && o + 256 < 1023)\n@@ -812,14 +814,18 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)\n \t\t\t\t\ti = ntohs(ptr);\n \n \t\t\t\t\t\/* check that highest two bits are set. if not, we've been had *\/\n-\t\t\t\t\tif (!(i & DN_COMP_BITMASK))\n+\t\t\t\t\tif ((i & DN_COMP_BITMASK) != DN_COMP_BITMASK)\n \t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, \"DN label decompression header is bogus\");\n \n \t\t\t\t\t\/* mask away the two highest bits. *\/\n \t\t\t\t\ti &= ~DN_COMP_BITMASK;\n \n \t\t\t\t\t\/* and decrease length by 12 bytes. *\/\n-\t\t\t\t\ti =- 12;\n+\t\t\t\t\ti -= 12;\n+\n+\t\t\t\t\tif (i >= lowest_pos)\n+\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, \"Invalid decompression pointer\");\n+\t\t\t\t\tlowest_pos = i;\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n@@ -843,6 +849,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)\n \t\t\t\t}\n \t\t\t}\n \t\t\tres[o] = 0;\n+\t\t}\n \t\tbreak;\n \t\tcase DNS_QUERY_AAAA:\n \t\t\tif (rr.rdlength != sizeof(struct in6_addr))\n","owner":"inspircd","repo":"inspircd","source":"cve"},{"CVE_ID":"CVE-2015-2778","CWE_ID":"399","category":"security","commit_id":"b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8","commit_message":"From b5e38970ffd55e2dd9f706ce75af9a8d7730b1b8 Mon Sep 17 00:00:00 2001\nFrom: Michael Marley <michael@michaelmarley.com>\nDate: Sat, 21 Feb 2015 07:33:57 -0500\nSubject: [PATCH] Improve the message-splitting algorithm for PRIVMSG and CTCP\n\nThis introduces a new message splitting algorithm based on\nQTextBoundaryFinder.  It works by first starting with the entire\nmessage to be sent, encoding it, and checking to see if it is over\nthe maximum message length.  If it is, it uses QTBF to find the\nword boundary most immediately preceding the maximum length.  If no\nsuitable boundary can be found, it falls back to searching for\ngrapheme boundaries.  It repeats this process until the entire\nmessage has been sent.\n\nUnlike what it replaces, the new splitting code is not recursive\nand cannot cause stack overflows.  Additionally, if it is unable\nto split a string, it will give up gracefully and not crash the\ncore or cause a thread to run away.\n\nThis patch fixes two bugs.  The first is garbage characters caused\nby accidentally splitting the string in the middle of a multibyte\ncharacter.  Since the new code splits at a character level instead\nof a byte level, this will no longer be an issue.  The second is\nthe core crash caused by sending an overlength CTCP query (\"\/me\")\ncontaining only multibyte characters.  This bug was caused by the\nold CTCP splitter using the byte index from lastParamOverrun() as\na character index for a QString.\n---\n src\/core\/corebasichandler.cpp     |  3 ++\n src\/core\/corebasichandler.h       |  1 +\n src\/core\/corenetwork.cpp          | 86 +++++++++++++++++++++++++++++++\n src\/core\/corenetwork.h            |  5 ++\n src\/core\/coreuserinputhandler.cpp | 72 +++++++++-----------------\n src\/core\/coreuserinputhandler.h   |  2 +-\n src\/core\/ctcpparser.cpp           | 26 ++--------\n 7 files changed, 124 insertions(+), 71 deletions(-)\n\n","diff_code":"diff --git a\/src\/core\/corebasichandler.cpp b\/src\/core\/corebasichandler.cpp\nindex dfa8a9964..fbfc76c2f 100644\n--- a\/src\/core\/corebasichandler.cpp\n+++ b\/src\/core\/corebasichandler.cpp\n@@ -33,6 +33,9 @@ CoreBasicHandler::CoreBasicHandler(CoreNetwork *parent)\n     connect(this, SIGNAL(putCmd(QString, const QList<QByteArray> &, const QByteArray &)),\n         network(), SLOT(putCmd(QString, const QList<QByteArray> &, const QByteArray &)));\n \n+    connect(this, SIGNAL(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)),\n+        network(), SLOT(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)));\n+\n     connect(this, SIGNAL(putRawLine(const QByteArray &)),\n         network(), SLOT(putRawLine(const QByteArray &)));\n }\ndiff --git a\/src\/core\/corebasichandler.h b\/src\/core\/corebasichandler.h\nindex 20d057fc4..a4b5a7f1f 100644\n--- a\/src\/core\/corebasichandler.h\n+++ b\/src\/core\/corebasichandler.h\n@@ -55,6 +55,7 @@ class CoreBasicHandler : public BasicHandler\n signals:\n     void displayMsg(Message::Type, BufferInfo::Type, const QString &target, const QString &text, const QString &sender = \"\", Message::Flags flags = Message::None);\n     void putCmd(const QString &cmd, const QList<QByteArray> &params, const QByteArray &prefix = QByteArray());\n+    void putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix = QByteArray());\n     void putRawLine(const QByteArray &msg);\n \n protected:\ndiff --git a\/src\/core\/corenetwork.cpp b\/src\/core\/corenetwork.cpp\nindex 7e9ce2681..932af6fc4 100644\n--- a\/src\/core\/corenetwork.cpp\n+++ b\/src\/core\/corenetwork.cpp\n@@ -284,6 +284,16 @@ void CoreNetwork::putCmd(const QString &cmd, const QList<QByteArray> &params, co\n }\n \n \n+void CoreNetwork::putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix)\n+{\n+    QListIterator<QList<QByteArray>> i(params);\n+    while (i.hasNext()) {\n+        QList<QByteArray> msg = i.next();\n+        putCmd(cmd, msg, prefix);\n+    }\n+}\n+\n+\n void CoreNetwork::setChannelJoined(const QString &channel)\n {\n     _autoWhoQueue.prepend(channel.toLower()); \/\/ prepend so this new chan is the first to be checked\n@@ -980,3 +990,79 @@ void CoreNetwork::requestSetNetworkInfo(const NetworkInfo &info)\n         }\n     }\n }\n+\n+\n+QList<QList<QByteArray>> CoreNetwork::splitMessage(const QString &cmd, const QString &message, std::function<QList<QByteArray>(QString &)> cmdGenerator)\n+{\n+    QString wrkMsg(message);\n+    QList<QList<QByteArray>> msgsToSend;\n+\n+    \/\/ do while (wrkMsg.size() > 0)\n+    do {\n+        \/\/ First, check to see if the whole message can be sent at once.  The\n+        \/\/ cmdGenerator function is passed in by the caller and is used to encode\n+        \/\/ and encrypt (if applicable) the message, since different callers might\n+        \/\/ want to use different encoding or encode different values.\n+        int splitPos = wrkMsg.size();\n+        QList<QByteArray> initialSplitMsgEnc = cmdGenerator(wrkMsg);\n+        int initialOverrun = userInputHandler()->lastParamOverrun(cmd, initialSplitMsgEnc);\n+\n+        if (initialOverrun) {\n+            \/\/ If the message was too long to be sent, first try splitting it along\n+            \/\/ word boundaries with QTextBoundaryFinder.\n+            QString splitMsg(wrkMsg);\n+            QTextBoundaryFinder qtbf(QTextBoundaryFinder::Word, splitMsg);\n+            qtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n+            QList<QByteArray> splitMsgEnc;\n+            int overrun = initialOverrun;\n+\n+            while (overrun) {\n+                splitPos = qtbf.toPreviousBoundary();\n+\n+                \/\/ splitPos==-1 means the QTBF couldn't find a split point at all and\n+                \/\/ splitPos==0 means the QTBF could only find a boundary at the beginning of\n+                \/\/ the string.  Neither one of these works for us.\n+                if (splitPos > 0) {\n+                    \/\/ If a split point could be found, split the message there, calculate the\n+                    \/\/ overrun, and continue with the loop.\n+                    splitMsg = splitMsg.left(splitPos);\n+                    splitMsgEnc = cmdGenerator(splitMsg);\n+                    overrun = userInputHandler()->lastParamOverrun(cmd, splitMsgEnc);\n+                }\n+                else {\n+                    \/\/ If a split point could not be found (the beginning of the message\n+                    \/\/ is reached without finding a split point short enough to send) and we\n+                    \/\/ are still in Word mode, switch to Grapheme mode.  We also need to restore\n+                    \/\/ the full wrkMsg to splitMsg, since splitMsg may have been cut down during\n+                    \/\/ the previous attempt to find a split point.\n+                    if (qtbf.type() == QTextBoundaryFinder::Word) {\n+                        splitMsg = wrkMsg;\n+                        splitPos = splitMsg.size();\n+                        QTextBoundaryFinder graphemeQtbf(QTextBoundaryFinder::Grapheme, splitMsg);\n+                        graphemeQtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n+                        qtbf = graphemeQtbf;\n+                    }\n+                    else {\n+                        \/\/ If the QTBF fails to find a split point in Grapheme mode, we give up.\n+                        \/\/ This should never happen, but it should be handled anyway.\n+                        qWarning() << \"Unexpected failure to split message!\";\n+                        return msgsToSend;\n+                    }\n+                }\n+            }\n+\n+            \/\/ Once a message of sendable length has been found, remove it from the wrkMsg and\n+            \/\/ add it to the list of messages to be sent.\n+            wrkMsg.remove(0, splitPos);\n+            msgsToSend.append(splitMsgEnc);\n+        }\n+        else{\n+            \/\/ If the entire remaining message is short enough to be sent all at once, remove\n+            \/\/ it from the wrkMsg and add it to the list of messages to be sent.\n+            wrkMsg.remove(0, splitPos);\n+            msgsToSend.append(initialSplitMsgEnc);\n+        }\n+    } while (wrkMsg.size() > 0);\n+\n+    return msgsToSend;\n+}\ndiff --git a\/src\/core\/corenetwork.h b\/src\/core\/corenetwork.h\nindex 87121bab3..05565a47b 100644\n--- a\/src\/core\/corenetwork.h\n+++ b\/src\/core\/corenetwork.h\n@@ -40,6 +40,8 @@\n \n #include \"coresession.h\"\n \n+#include <functional>\n+\n class CoreIdentity;\n class CoreUserInputHandler;\n class CoreIgnoreListManager;\n@@ -93,6 +95,8 @@ class CoreNetwork : public Network\n     inline quint16 localPort() const { return socket.localPort(); }\n     inline quint16 peerPort() const { return socket.peerPort(); }\n \n+    QList<QList<QByteArray>> splitMessage(const QString &cmd, const QString &message, std::function<QList<QByteArray>(QString &)> cmdGenerator);\n+\n public slots:\n     virtual void setMyNick(const QString &mynick);\n \n@@ -112,6 +116,7 @@ public slots:\n     void userInput(BufferInfo bufferInfo, QString msg);\n     void putRawLine(QByteArray input);\n     void putCmd(const QString &cmd, const QList<QByteArray> &params, const QByteArray &prefix = QByteArray());\n+    void putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix = QByteArray());\n \n     void setChannelJoined(const QString &channel);\n     void setChannelParted(const QString &channel);\ndiff --git a\/src\/core\/coreuserinputhandler.cpp b\/src\/core\/coreuserinputhandler.cpp\nindex 33d1f67a8..72ac99602 100644\n--- a\/src\/core\/coreuserinputhandler.cpp\n+++ b\/src\/core\/coreuserinputhandler.cpp\n@@ -473,12 +473,16 @@ void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString\n         return;\n \n     QString target = msg.section(' ', 0, 0);\n-    QByteArray encMsg = userEncode(target, msg.section(' ', 1));\n+    QString msgSection = msg.section(' ', 1);\n+\n+    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n+        return userEncode(target, message);\n+    };\n \n #ifdef HAVE_QCA2\n-    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));\n+    putPrivmsg(target, msgSection, encodeFunc, network()->cipher(target));\n #else\n-    putPrivmsg(serverEncode(target), encMsg);\n+    putPrivmsg(target, msgSection, encodeFunc);\n #endif\n }\n \n@@ -594,11 +598,14 @@ void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString\n     if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n         return;  \/\/ server buffer\n \n-    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n+    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n+        return channelEncode(target, message);\n+    };\n+\n #ifdef HAVE_QCA2\n-    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n+    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc, network()->cipher(bufferInfo.bufferName()));\n #else\n-    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n+    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc);\n #endif\n     emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n }\n@@ -763,56 +770,23 @@ void CoreUserInputHandler::defaultHandler(QString cmd, const BufferInfo &bufferI\n }\n \n \n-void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)\n+void CoreUserInputHandler::putPrivmsg(const QString &target, const QString &message, std::function<QByteArray(const QString &, const QString &)> encodeFunc, Cipher *cipher)\n {\n-    \/\/ Encrypted messages need special care. There's no clear relation between cleartext and encrypted message length,\n-    \/\/ so we can't just compute the maxSplitPos. Instead, we need to loop through the splitpoints until the crypted\n-    \/\/ version is short enough...\n-    \/\/ TODO: check out how the various possible encryption methods behave length-wise and make\n-    \/\/       this clean by predicting the length of the crypted msg.\n-    \/\/       For example, blowfish-ebc seems to create 8-char chunks.\n+    QString cmd(\"PRIVMSG\");\n+    QByteArray targetEnc = serverEncode(target);\n \n-    static const char *cmd = \"PRIVMSG\";\n-    static const char *splitter = \" .,-!?\";\n+    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {\n+        QByteArray splitMsgEnc = encodeFunc(target, splitMsg);\n \n-    int maxSplitPos = message.count();\n-    int splitPos = maxSplitPos;\n-    forever {\n-        QByteArray crypted = message.left(splitPos);\n-        bool isEncrypted = false;\n #ifdef HAVE_QCA2\n-        if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {\n-            isEncrypted = cipher->encrypt(crypted);\n+        if (cipher && !cipher->key().isEmpty() && !splitMsg.isEmpty()) {\n+            cipher->encrypt(splitMsgEnc);\n         }\n #endif\n-        int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);\n-        if (overrun) {\n-            \/\/ In case this is not an encrypted msg, we can just cut off at the end\n-            if (!isEncrypted)\n-                maxSplitPos = message.count() - overrun;\n-\n-            splitPos = -1;\n-            for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n-                splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \/\/ keep split char on old line\n-            }\n-            if (splitPos <= 0 || splitPos > maxSplitPos)\n-                splitPos = maxSplitPos;\n-\n-            maxSplitPos = splitPos - 1;\n-            if (maxSplitPos <= 0) { \/\/ this should never happen, but who knows...\n-                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());\n-                return;\n-            }\n-            continue; \/\/ we never come back here for !encrypted!\n-        }\n-\n-        \/\/ now we have found a valid splitpos (or didn't need to split to begin with)\n-        putCmd(cmd, QList<QByteArray>() << target << crypted);\n-        if (splitPos < message.count())\n-            putPrivmsg(target, message.mid(splitPos), cipher);\n+        return QList<QByteArray>() << targetEnc << splitMsgEnc;\n+    };\n \n-        return;\n-    }\n+    putCmd(cmd, network()->splitMessage(cmd, message, cmdGenerator));\n }\n \n \ndiff --git a\/src\/core\/coreuserinputhandler.h b\/src\/core\/coreuserinputhandler.h\nindex 69a429ee8..6e69ce605 100644\n--- a\/src\/core\/coreuserinputhandler.h\n+++ b\/src\/core\/coreuserinputhandler.h\n@@ -88,7 +88,7 @@ public slots:\n private:\n     void doMode(const BufferInfo& bufferInfo, const QChar &addOrRemove, const QChar &mode, const QString &nickList);\n     void banOrUnban(const BufferInfo &bufferInfo, const QString &text, bool ban);\n-    void putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher = 0);\n+    void putPrivmsg(const QString &target, const QString &message, std::function<QByteArray(const QString &, const QString &)> encodeFunc, Cipher *cipher = 0);\n \n #ifdef HAVE_QCA2\n     QByteArray encrypt(const QString &target, const QByteArray &message, bool *didEncrypt = 0) const;\ndiff --git a\/src\/core\/ctcpparser.cpp b\/src\/core\/ctcpparser.cpp\nindex fba3d13e9..37b0af3e9 100644\n--- a\/src\/core\/ctcpparser.cpp\n+++ b\/src\/core\/ctcpparser.cpp\n@@ -312,29 +312,13 @@ QByteArray CtcpParser::pack(const QByteArray &ctcpTag, const QByteArray &message\n \n void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)\n {\n-    QList<QByteArray> params;\n-    params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));\n-\n-    static const char *splitter = \" .,-!?\";\n-    int maxSplitPos = message.count();\n-    int splitPos = maxSplitPos;\n+    QString cmd(\"PRIVMSG\");\n \n-    int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);\n-    if (overrun) {\n-        maxSplitPos = message.count() - overrun -2;\n-        splitPos = -1;\n-        for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n-            splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \/\/ keep split char on old line\n-        }\n-        if (splitPos <= 0 || splitPos > maxSplitPos)\n-            splitPos = maxSplitPos;\n-\n-        params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));\n-    }\n-    net->putCmd(\"PRIVMSG\", params);\n+    std::function<QList<QByteArray>(QString &)> cmdGenerator = [&] (QString &splitMsg) -> QList<QByteArray> {\n+        return QList<QByteArray>() << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, splitMsg)));\n+    };\n \n-    if (splitPos < message.count())\n-        query(net, bufname, ctcpTag, message.mid(splitPos));\n+    net->putCmd(cmd, net->splitMessage(cmd, message, cmdGenerator));\n }\n \n \n","owner":"quassel","repo":"quassel","source":"cve"},{"CVE_ID":"CVE-2015-8104","CWE_ID":"399","category":"security","commit_id":"cbdb967af3d54993f5814f1cee0ed311a055377d","commit_message":"From cbdb967af3d54993f5814f1cee0ed311a055377d Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Tue, 10 Nov 2015 09:14:39 +0100\nSubject: [PATCH] KVM: svm: unconditionally intercept #DB\n\nThis is needed to avoid the possibility that the guest triggers\nan infinite stream of #DB exceptions (CVE-2015-8104).\n\nVMX is not affected: because it does not save DR6 in the VMCS,\nit already intercepts #DB unconditionally.\n\nReported-by: Jan Beulich <jbeulich@suse.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/svm.c | 14 +++-----------\n 1 file changed, 3 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/svm.c b\/arch\/x86\/kvm\/svm.c\nindex 183926483c3ac..1cc1ffca0d8c3 100644\n--- a\/arch\/x86\/kvm\/svm.c\n+++ b\/arch\/x86\/kvm\/svm.c\n@@ -1020,6 +1020,7 @@ static void init_vmcb(struct vcpu_svm *svm)\n \tset_exception_intercept(svm, UD_VECTOR);\n \tset_exception_intercept(svm, MC_VECTOR);\n \tset_exception_intercept(svm, AC_VECTOR);\n+\tset_exception_intercept(svm, DB_VECTOR);\n \n \tset_intercept(svm, INTERCEPT_INTR);\n \tset_intercept(svm, INTERCEPT_NMI);\n@@ -1554,20 +1555,13 @@ static void svm_set_segment(struct kvm_vcpu *vcpu,\n \tmark_dirty(svm->vmcb, VMCB_SEG);\n }\n \n-static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n+static void update_bp_intercept(struct kvm_vcpu *vcpu)\n {\n \tstruct vcpu_svm *svm = to_svm(vcpu);\n \n-\tclr_exception_intercept(svm, DB_VECTOR);\n \tclr_exception_intercept(svm, BP_VECTOR);\n \n-\tif (svm->nmi_singlestep)\n-\t\tset_exception_intercept(svm, DB_VECTOR);\n-\n \tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n-\t\tif (vcpu->guest_debug &\n-\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n-\t\t\tset_exception_intercept(svm, DB_VECTOR);\n \t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n \t\t\tset_exception_intercept(svm, BP_VECTOR);\n \t} else\n@@ -1673,7 +1667,6 @@ static int db_interception(struct vcpu_svm *svm)\n \t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n \t\t\tsvm->vmcb->save.rflags &=\n \t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n-\t\tupdate_db_bp_intercept(&svm->vcpu);\n \t}\n \n \tif (svm->vcpu.guest_debug &\n@@ -3661,7 +3654,6 @@ static void enable_nmi_window(struct kvm_vcpu *vcpu)\n \t *\/\n \tsvm->nmi_singlestep = true;\n \tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n-\tupdate_db_bp_intercept(vcpu);\n }\n \n static int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)\n@@ -4287,7 +4279,7 @@ static struct kvm_x86_ops svm_x86_ops = {\n \t.vcpu_load = svm_vcpu_load,\n \t.vcpu_put = svm_vcpu_put,\n \n-\t.update_db_bp_intercept = update_db_bp_intercept,\n+\t.update_db_bp_intercept = update_bp_intercept,\n \t.get_msr = svm_get_msr,\n \t.set_msr = svm_set_msr,\n \t.get_segment_base = svm_get_segment_base,\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-16426","CWE_ID":"399","category":"security","commit_id":"03628449b75a93787eb2359412a3980365dda49b","commit_message":"From 03628449b75a93787eb2359412a3980365dda49b Mon Sep 17 00:00:00 2001\nFrom: Frank Morgner <frankmorgner@gmail.com>\nDate: Fri, 29 Jun 2018 15:58:00 +0200\nSubject: [PATCH] iasecc: fixed unbound recursion\n\n---\n src\/libopensc\/card-iasecc.c | 10 +++++-----\n 1 file changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/libopensc\/card-iasecc.c b\/src\/libopensc\/card-iasecc.c\nindex 48d4cea560..b37b833b77 100644\n--- a\/src\/libopensc\/card-iasecc.c\n+++ b\/src\/libopensc\/card-iasecc.c\n@@ -827,16 +827,16 @@ iasecc_select_file(struct sc_card *card, const struct sc_path *path,\n \tsc_log(ctx, \"iasecc_select_file() path:%s\", sc_print_path(path));\n \n \tsc_print_cache(card);\n-\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {\n+\tif (path->type != SC_PATH_TYPE_DF_NAME\n+\t\t\t&& lpath.len >= 2\n+\t\t\t&& lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   {\n \t\tsc_log(ctx, \"EF.ATR(aid:'%s')\", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : \"\");\n \n \t\trv = iasecc_select_mf(card, file_out);\n \t\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n \n-\t\tif (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)\t   {\n-\t\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);\n-\t\t\tlpath.len -=  2;\n-\t\t}\n+\t\tmemmove(&lpath.value[0], &lpath.value[2], lpath.len - 2);\n+\t\tlpath.len -=  2;\n \t}\n \n \tif (lpath.aid.len)\t{\n","owner":"OpenSC","repo":"OpenSC","source":"cve"},{"CVE_ID":"CVE-2010-3698","CWE_ID":"399","category":"security","commit_id":"9581d442b9058d3699b4be568b6e5eae38a41493","commit_message":"From 9581d442b9058d3699b4be568b6e5eae38a41493 Mon Sep 17 00:00:00 2001\nFrom: Avi Kivity <avi@redhat.com>\nDate: Tue, 19 Oct 2010 16:46:55 +0200\nSubject: KVM: Fix fs\/gs reload oops with invalid ldt\n\nkvm reloads the host's fs and gs blindly, however the underlying segment\ndescriptors may be invalid due to the user modifying the ldt after loading\nthem.\n\nFix by using the safe accessors (loadsegment() and load_gs_index()) instead\nof home grown unsafe versions.\n\nThis is CVE-2010-3698.\n\nKVM-Stable-Tag.\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\n---\n arch\/x86\/include\/asm\/kvm_host.h | 24 ------------------------\n arch\/x86\/kvm\/svm.c              | 15 ++++++++++-----\n arch\/x86\/kvm\/vmx.c              | 24 +++++++++---------------\n 3 files changed, 19 insertions(+), 44 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/kvm_host.h b\/arch\/x86\/include\/asm\/kvm_host.h\nindex 502e53f999cf..c52e2eb40a1e 100644\n--- a\/arch\/x86\/include\/asm\/kvm_host.h\n+++ b\/arch\/x86\/include\/asm\/kvm_host.h\n@@ -652,20 +652,6 @@ static inline struct kvm_mmu_page *page_header(hpa_t shadow_page)\n \treturn (struct kvm_mmu_page *)page_private(page);\n }\n \n-static inline u16 kvm_read_fs(void)\n-{\n-\tu16 seg;\n-\tasm(\"mov %%fs, %0\" : \"=g\"(seg));\n-\treturn seg;\n-}\n-\n-static inline u16 kvm_read_gs(void)\n-{\n-\tu16 seg;\n-\tasm(\"mov %%gs, %0\" : \"=g\"(seg));\n-\treturn seg;\n-}\n-\n static inline u16 kvm_read_ldt(void)\n {\n \tu16 ldt;\n@@ -673,16 +659,6 @@ static inline u16 kvm_read_ldt(void)\n \treturn ldt;\n }\n \n-static inline void kvm_load_fs(u16 sel)\n-{\n-\tasm(\"mov %0, %%fs\" : : \"rm\"(sel));\n-}\n-\n-static inline void kvm_load_gs(u16 sel)\n-{\n-\tasm(\"mov %0, %%gs\" : : \"rm\"(sel));\n-}\n-\n static inline void kvm_load_ldt(u16 sel)\n {\n \tasm(\"lldt %0\" : : \"rm\"(sel));\ndiff --git a\/arch\/x86\/kvm\/svm.c b\/arch\/x86\/kvm\/svm.c\nindex 81ed28cb36e6..8a3f9f64f86f 100644\n--- a\/arch\/x86\/kvm\/svm.c\n+++ b\/arch\/x86\/kvm\/svm.c\n@@ -3163,8 +3163,8 @@ static void svm_vcpu_run(struct kvm_vcpu *vcpu)\n \tsync_lapic_to_cr8(vcpu);\n \n \tsave_host_msrs(vcpu);\n-\tfs_selector = kvm_read_fs();\n-\tgs_selector = kvm_read_gs();\n+\tsavesegment(fs, fs_selector);\n+\tsavesegment(gs, gs_selector);\n \tldt_selector = kvm_read_ldt();\n \tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n \t\/* required for live migration with NPT *\/\n@@ -3251,10 +3251,15 @@ static void svm_vcpu_run(struct kvm_vcpu *vcpu)\n \tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n \tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n \n-\tkvm_load_fs(fs_selector);\n-\tkvm_load_gs(gs_selector);\n-\tkvm_load_ldt(ldt_selector);\n \tload_host_msrs(vcpu);\n+\tloadsegment(fs, fs_selector);\n+#ifdef CONFIG_X86_64\n+\tload_gs_index(gs_selector);\n+\twrmsrl(MSR_KERNEL_GS_BASE, current->thread.gs);\n+#else\n+\tloadsegment(gs, gs_selector);\n+#endif\n+\tkvm_load_ldt(ldt_selector);\n \n \treload_tss(vcpu);\n \ndiff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex 49b25eee25ac..7bddfab12013 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -803,7 +803,7 @@ static void vmx_save_host_state(struct kvm_vcpu *vcpu)\n \t *\/\n \tvmx->host_state.ldt_sel = kvm_read_ldt();\n \tvmx->host_state.gs_ldt_reload_needed = vmx->host_state.ldt_sel;\n-\tvmx->host_state.fs_sel = kvm_read_fs();\n+\tsavesegment(fs, vmx->host_state.fs_sel);\n \tif (!(vmx->host_state.fs_sel & 7)) {\n \t\tvmcs_write16(HOST_FS_SELECTOR, vmx->host_state.fs_sel);\n \t\tvmx->host_state.fs_reload_needed = 0;\n@@ -811,7 +811,7 @@ static void vmx_save_host_state(struct kvm_vcpu *vcpu)\n \t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n \t\tvmx->host_state.fs_reload_needed = 1;\n \t}\n-\tvmx->host_state.gs_sel = kvm_read_gs();\n+\tsavesegment(gs, vmx->host_state.gs_sel);\n \tif (!(vmx->host_state.gs_sel & 7))\n \t\tvmcs_write16(HOST_GS_SELECTOR, vmx->host_state.gs_sel);\n \telse {\n@@ -841,27 +841,21 @@ static void vmx_save_host_state(struct kvm_vcpu *vcpu)\n \n static void __vmx_load_host_state(struct vcpu_vmx *vmx)\n {\n-\tunsigned long flags;\n-\n \tif (!vmx->host_state.loaded)\n \t\treturn;\n \n \t++vmx->vcpu.stat.host_state_reload;\n \tvmx->host_state.loaded = 0;\n \tif (vmx->host_state.fs_reload_needed)\n-\t\tkvm_load_fs(vmx->host_state.fs_sel);\n+\t\tloadsegment(fs, vmx->host_state.fs_sel);\n \tif (vmx->host_state.gs_ldt_reload_needed) {\n \t\tkvm_load_ldt(vmx->host_state.ldt_sel);\n-\t\t\/*\n-\t\t * If we have to reload gs, we must take care to\n-\t\t * preserve our gs base.\n-\t\t *\/\n-\t\tlocal_irq_save(flags);\n-\t\tkvm_load_gs(vmx->host_state.gs_sel);\n #ifdef CONFIG_X86_64\n-\t\twrmsrl(MSR_GS_BASE, vmcs_readl(HOST_GS_BASE));\n+\t\tload_gs_index(vmx->host_state.gs_sel);\n+\t\twrmsrl(MSR_KERNEL_GS_BASE, current->thread.gs);\n+#else\n+\t\tloadsegment(gs, vmx->host_state.gs_sel);\n #endif\n-\t\tlocal_irq_restore(flags);\n \t}\n \treload_tss();\n #ifdef CONFIG_X86_64\n@@ -2589,8 +2583,8 @@ static int vmx_vcpu_setup(struct vcpu_vmx *vmx)\n \tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \/* 22.2.4 *\/\n \tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  \/* 22.2.4 *\/\n \tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  \/* 22.2.4 *\/\n-\tvmcs_write16(HOST_FS_SELECTOR, kvm_read_fs());    \/* 22.2.4 *\/\n-\tvmcs_write16(HOST_GS_SELECTOR, kvm_read_gs());    \/* 22.2.4 *\/\n+\tvmcs_write16(HOST_FS_SELECTOR, 0);            \/* 22.2.4 *\/\n+\tvmcs_write16(HOST_GS_SELECTOR, 0);            \/* 22.2.4 *\/\n \tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  \/* 22.2.4 *\/\n #ifdef CONFIG_X86_64\n \trdmsrl(MSR_FS_BASE, a);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-13133","CWE_ID":"399","category":"security","commit_id":"fe3066122ef72c82415811d25e9e3fad622c0a99","commit_message":"From fe3066122ef72c82415811d25e9e3fad622c0a99 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 18 Jun 2019 11:51:46 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1600\n\n---\n coders\/bmp.c  | 2 +-\n coders\/viff.c | 4 ++--\n 2 files changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/coders\/bmp.c b\/coders\/bmp.c\nindex fdabac9502..c964834fe8 100644\n--- a\/coders\/bmp.c\n+++ b\/coders\/bmp.c\n@@ -1506,7 +1506,7 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n             status=MagickFalse;\n-            return((Image *) NULL);\n+            break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\ndiff --git a\/coders\/viff.c b\/coders\/viff.c\nindex 5f89ad15e3..05aac7c556 100644\n--- a\/coders\/viff.c\n+++ b\/coders\/viff.c\n@@ -773,8 +773,8 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,\n         AcquireNextImage(image_info,image,exception);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n-            image=DestroyImageList(image);\n-            return((Image *) NULL);\n+            status=MagickFalse;\n+            break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2009-3613","CWE_ID":"399","category":"security","commit_id":"97d477a914b146e7e6722ded21afa79886ae8ccd","commit_message":"From 97d477a914b146e7e6722ded21afa79886ae8ccd Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?fran=C3=A7ois=20romieu?= <romieu@fr.zoreil.com>\nDate: Sun, 15 Mar 2009 01:09:54 +0000\nSubject: r8169: use hardware auto-padding.\n\nIt shortens the code and fixes the current pci_unmap leak with\npadded skb reported by Dave Jones.\n\nSigned-off-by: Francois Romieu <romieu@fr.zoreil.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/r8169.c | 8 --------\n 1 file changed, 8 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/r8169.c b\/drivers\/net\/r8169.c\nindex b3473401c83a..352da2a43c9f 100644\n--- a\/drivers\/net\/r8169.c\n+++ b\/drivers\/net\/r8169.c\n@@ -3363,13 +3363,6 @@ static int rtl8169_start_xmit(struct sk_buff *skb, struct net_device *dev)\n \t\topts1 |= FirstFrag;\n \t} else {\n \t\tlen = skb->len;\n-\n-\t\tif (unlikely(len < ETH_ZLEN)) {\n-\t\t\tif (skb_padto(skb, ETH_ZLEN))\n-\t\t\t\tgoto err_update_stats;\n-\t\t\tlen = ETH_ZLEN;\n-\t\t}\n-\n \t\topts1 |= FirstFrag | LastFrag;\n \t\ttp->tx_skb[entry].skb = skb;\n \t}\n@@ -3407,7 +3400,6 @@ out:\n err_stop:\n \tnetif_stop_queue(dev);\n \tret = NETDEV_TX_BUSY;\n-err_update_stats:\n \tdev->stats.tx_dropped++;\n \tgoto out;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12989","CWE_ID":"399","category":"security","commit_id":"db24063b01cba8e9d4d88b7d8ac70c9000c104e4","commit_message":"From db24063b01cba8e9d4d88b7d8ac70c9000c104e4 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Tue, 7 Feb 2017 00:13:33 -0800\nSubject: [PATCH] CVE-2017-12989\/RESP: Make sure resp_get_length() advances the\n pointer for invalid lengths.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nMake sure that it always sends *endp before returning and that, for\ninvalid lengths where we don't like a character in the length string,\nwhat it sets *endp to is past the character in question, so we don't\nrun the risk of infinitely looping (or doing something else random) if a\ncharacter in the length is invalid.\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).\n---\n print-resp.c                   |  14 +++++++++++---\n tests\/TESTLIST                 |   1 +\n tests\/resp_4_infiniteloop.out  |   2 ++\n tests\/resp_4_infiniteloop.pcap | Bin 0 -> 1036 bytes\n 4 files changed, 14 insertions(+), 3 deletions(-)\n create mode 100644 tests\/resp_4_infiniteloop.out\n create mode 100644 tests\/resp_4_infiniteloop.pcap\n\n","diff_code":"diff --git a\/print-resp.c b\/print-resp.c\nindex 9d71e21dc..dee22d63a 100644\n--- a\/print-resp.c\n+++ b\/print-resp.c\n@@ -481,8 +481,10 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n         ND_TCHECK(*bp);\n         c = *bp;\n         if (!(c >= '0' && c <= '9')) {\n-            if (!saw_digit)\n+            if (!saw_digit) {\n+                bp++;\n                 goto invalid;\n+            }\n             break;\n         }\n         c -= '0';\n@@ -510,15 +512,19 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n-    if (*bp != '\\r')\n+    if (*bp != '\\r') {\n+        bp++;\n         goto invalid;\n+    }\n     bp++;\n     len--;\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n-    if (*bp != '\\n')\n+    if (*bp != '\\n') {\n+        bp++;\n         goto invalid;\n+    }\n     bp++;\n     len--;\n     *endp = bp;\n@@ -531,8 +537,10 @@ resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, con\n     return (too_large ? -3 : result);\n \n trunc:\n+    *endp = bp;\n     return (-2);\n \n invalid:\n+    *endp = bp;\n     return (-5);\n }\ndiff --git a\/tests\/TESTLIST b\/tests\/TESTLIST\nindex e0f0bb146..ecf54f69b 100644\n--- a\/tests\/TESTLIST\n+++ b\/tests\/TESTLIST\n@@ -468,6 +468,7 @@ zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n telnet-iac-check-oobr\ttelnet-iac-check-oobr.pcap\ttelnet-iac-check-oobr.out\t-vvv -e\n+resp_4_infiniteloop\tresp_4_infiniteloop.pcap\tresp_4_infiniteloop.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap\ndiff --git a\/tests\/resp_4_infiniteloop.out b\/tests\/resp_4_infiniteloop.out\nnew file mode 100644\nindex 000000000..396cb8b39\n--- \/dev\/null\n+++ b\/tests\/resp_4_infiniteloop.out\n@@ -0,0 +1,2 @@\n+00:50:56:b4:08:69 > 00:50:56:b4:4c:2a, ethertype IPv4 (0x0800), length 920: (tos 0x0, ttl 64, id 27576, offset 0, flags [DF], proto TCP (6), length 906)\n+    172.16.8.77.33926 > 172.16.8.149.6379: Flags [P.], cksum 0xa129 (incorrect -> 0xaaa0), seq 3839414413:3839415267, ack 2526552240, win 229, options [nop,nop,TS val 2407226 ecr 24894817], length 854: RESP length negative and not -1 invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid \"4\" \"EVAL\" invalid invalid invalid invalid \"GKMbNZq^@0\" \"stuubt.pack('<ivdMFG4294967245',^V ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''319', 2',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',',', '-1494241318543828858')'L')N))'r')')~D')')E)')')')')')')')'l')')')')')'M-`'o')')'Pp)U)\" invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid invalid \"1\" [|RESP]\ndiff --git a\/tests\/resp_4_infiniteloop.pcap b\/tests\/resp_4_infiniteloop.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..98a79bfb67d0098a747f02c3a945dcf401a98df9\nGIT binary patch\nliteral 1036\nzcmd<$<>fMAU|{gI(UxKa(*L1=g@KpBH6^noIk7;&NY6me2q*^vAhjTM3Q+q0e+C9l\nzpa>g~4+0863}WwK1`<eM29OWJ3;|(Ve6&C$M<xe@D+6;^_6`RI2ezcmYXmrafp}_5\nzo5brUH!k!}o1w6wL4x7wLQSBJj2v7HD!Z*1tM4Xi>6#iFnV1?F7@AvHnwnY~SQ?q}\nza;c1PV8YAg8s_MO2ncs?-z2}NLIwj~uHur?(xei-g2d!(4RxE$vJ_u8cM~H^6H7C5\nzU_h$th$*NKFfcZ>RM$~3Qr8*TP(fYS(8SWj$i&dt(8AQj*uu!d!qh@tQ{6{h(@#@V\npy$HzEtaAa8u0V_ebC7rs)bqi-fC9}>O+=Ewl|>ABxeP%06#yXcv(o?o\n\nliteral 0\nHcmV?d00001\n\n","owner":"the-tcpdump-group","repo":"tcpdump","source":"cve"},{"CVE_ID":"CVE-2015-1788","CWE_ID":"399","category":"security","commit_id":"4924b37ee01f71ae19c94a8934b80eeb2f677932","commit_message":"From 4924b37ee01f71ae19c94a8934b80eeb2f677932 Mon Sep 17 00:00:00 2001\nFrom: Andy Polyakov <appro@openssl.org>\nDate: Thu, 11 Jun 2015 00:18:01 +0200\nSubject: [PATCH] bn\/bn_gf2m.c: avoid infinite loop wich malformed ECParamters.\n\nCVE-2015-1788\n\nReviewed-by: Matt Caswell <matt@openssl.org>\n---\n crypto\/bn\/bn_gf2m.c | 15 ++++++++++-----\n 1 file changed, 10 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/bn\/bn_gf2m.c b\/crypto\/bn\/bn_gf2m.c\nindex 73e1e8f11bb..cd137c36496 100644\n--- a\/crypto\/bn\/bn_gf2m.c\n+++ b\/crypto\/bn\/bn_gf2m.c\n@@ -691,9 +691,10 @@ int BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n     }\n # else\n     {\n-        int i, ubits = BN_num_bits(u), vbits = BN_num_bits(v), \/* v is copy\n-                                                                * of p *\/\n-            top = p->top;\n+        int i;\n+        int ubits = BN_num_bits(u);\n+        int vbits = BN_num_bits(v); \/* v is copy of p *\/\n+        int top = p->top;\n         BN_ULONG *udp, *bdp, *vdp, *cdp;\n \n         bn_wexpand(u, top);\n@@ -737,8 +738,12 @@ int BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n                 ubits--;\n             }\n \n-            if (ubits <= BN_BITS2 && udp[0] == 1)\n-                break;\n+            if (ubits <= BN_BITS2) {\n+                if (udp[0] == 0) \/* poly was reducible *\/\n+                    goto err;\n+                if (udp[0] == 1)\n+                    break;\n+            }\n \n             if (ubits < vbits) {\n                 i = ubits;\n","owner":"openssl","repo":"openssl","source":"cve"},{"CVE_ID":"CVE-2017-18236","CWE_ID":"399","category":"security","commit_id":"fe59605d3520bf2ca4e0a963d194f10e9fee5806","commit_message":"From fe59605d3520bf2ca4e0a963d194f10e9fee5806 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Hubert=20Figui=C3=A8re?= <hub@figuiere.net>\nDate: Fri, 2 Feb 2018 09:55:53 -0500\nSubject: Bug 102484 - Fix an infinite loop in ASF parser.\n\n---\n XMPFiles\/source\/FormatSupport\/ASF_Support.cpp | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/XMPFiles\/source\/FormatSupport\/ASF_Support.cpp b\/XMPFiles\/source\/FormatSupport\/ASF_Support.cpp\nindex 709aea5..95fd192 100644\n--- a\/XMPFiles\/source\/FormatSupport\/ASF_Support.cpp\n+++ b\/XMPFiles\/source\/FormatSupport\/ASF_Support.cpp\n@@ -270,6 +270,8 @@ bool ASF_Support::ReadHeaderObject ( XMP_IO* fileRef, ObjectState& inOutObjectSt\n \n \t\t\t\tthis->ReadHeaderExtensionObject ( fileRef, inOutObjectState, pos, objectBase );\n \n+\t\t\t} else if (objectBase.size == 0) {\n+\t\t\t\tbreak;\n \t\t\t}\n \n \t\t\tpos += objectBase.size;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-3888","CWE_ID":"399","category":"security","commit_id":"89a8640279f8bb78aaf778d1fc5c4a6778f18064","commit_message":"From 89a8640279f8bb78aaf778d1fc5c4a6778f18064 Mon Sep 17 00:00:00 2001\nFrom: David Howells <dhowells@redhat.com>\nDate: Fri, 30 Oct 2009 13:13:26 +0000\nSubject: NOMMU: Don't pass NULL pointers to fput() in do_mmap_pgoff()\n\nDon't pass NULL pointers to fput() in the error handling paths of the NOMMU\ndo_mmap_pgoff() as it can't handle it.\n\nThe following can be used as a test program:\n\n\tint main() { static long long a[1024 * 1024 * 20] = { 0 }; return a;}\n\nWithout the patch, the code oopses in atomic_long_dec_and_test() as called by\nfput() after the kernel complains that it can't allocate that big a chunk of\nmemory.  With the patch, the kernel just complains about the allocation size\nand then the program segfaults during execve() as execve() can't complete the\nallocation of all the new ELF program segments.\n\nReported-by: Robin Getz <rgetz@blackfin.uclinux.org>\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Robin Getz <rgetz@blackfin.uclinux.org>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/nommu.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/mm\/nommu.c b\/mm\/nommu.c\nindex 5189b5aed8c0..9876fa0c3ad3 100644\n--- a\/mm\/nommu.c\n+++ b\/mm\/nommu.c\n@@ -1362,9 +1362,11 @@ share:\n error_just_free:\n \tup_write(&nommu_region_sem);\n error:\n-\tfput(region->vm_file);\n+\tif (region->vm_file)\n+\t\tfput(region->vm_file);\n \tkmem_cache_free(vm_region_jar, region);\n-\tfput(vma->vm_file);\n+\tif (vma->vm_file)\n+\t\tfput(vma->vm_file);\n \tif (vma->vm_flags & VM_EXECUTABLE)\n \t\tremoved_exe_file_vma(vma->vm_mm);\n \tkmem_cache_free(vm_area_cachep, vma);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2010-4352","CWE_ID":"399","category":"security","commit_id":"7d65a3a6ed8815e34a99c680ac3869fde49dbbd4","commit_message":"From 7d65a3a6ed8815e34a99c680ac3869fde49dbbd4 Mon Sep 17 00:00:00 2001\nFrom: Havoc Pennington <hp@pobox.com>\nDate: Sun, 12 Dec 2010 21:08:43 -0500\nSubject: CVE 2010-4352: Reject deeply nested variants\n\nAdd DBUS_INVALID_NESTED_TOO_DEEPLY validity problem and a test that\nshould generate it.\n\nPreviously, we rejected deep nesting in the signature, but\nvariants allow dynamic message nesting, conditional only\non the depth of the message body.\n\nThe nesting limit is 64, which was also the limit in static\nsignatures.  Empirically, dynamic nesting depth observed on my\nFedora 14 system doesn't exceed 2; 64 is really a huge limit.\n\nhttps:\/\/bugs.freedesktop.org\/show_bug.cgi?id=32321\n\nSigned-Off-By: Colin Walters <walters@verbum.org>\nSigned-off-by: Will Thompson <will.thompson@collabora.co.uk>\n---\n dbus\/dbus-marshal-validate.c | 30 ++++++++++++++++----\n dbus\/dbus-marshal-validate.h |  1 +\n dbus\/dbus-message-factory.c  | 65 ++++++++++++++++++++++++++++++++++++++++++++\n doc\/dbus-specification.xml   | 14 ++++++----\n 4 files changed, 99 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/dbus\/dbus-marshal-validate.c b\/dbus\/dbus-marshal-validate.c\nindex aa470fc..b457997 100644\n--- a\/dbus\/dbus-marshal-validate.c\n+++ b\/dbus\/dbus-marshal-validate.c\n@@ -291,16 +291,30 @@ out:\n   return result;\n }\n \n+\/* note: this function is also used to validate the header's values,\n+ * since the header is a valid body with a particular signature.\n+ *\/\n static DBusValidity\n validate_body_helper (DBusTypeReader       *reader,\n                       int                   byte_order,\n                       dbus_bool_t           walk_reader_to_end,\n+                      int                   total_depth,\n                       const unsigned char  *p,\n                       const unsigned char  *end,\n                       const unsigned char **new_p)\n {\n   int current_type;\n \n+  \/* The spec allows arrays and structs to each nest 32, for total\n+   * nesting of 2*32. We want to impose the same limit on \"dynamic\"\n+   * value nesting (not visible in the signature) which is introduced\n+   * by DBUS_TYPE_VARIANT.\n+   *\/\n+  if (total_depth > (DBUS_MAXIMUM_TYPE_RECURSION_DEPTH * 2))\n+    {\n+      return DBUS_INVALID_NESTED_TOO_DEEPLY;\n+    }\n+\n   while ((current_type = _dbus_type_reader_get_current_type (reader)) != DBUS_TYPE_INVALID)\n     {\n       const unsigned char *a;\n@@ -477,7 +491,9 @@ validate_body_helper (DBusTypeReader       *reader,\n                   {\n                     while (p < array_end)\n                       {\n-                        validity = validate_body_helper (&sub, byte_order, FALSE, p, end, &p);\n+                        validity = validate_body_helper (&sub, byte_order, FALSE,\n+                                                         total_depth + 1,\n+                                                         p, end, &p);\n                         if (validity != DBUS_VALID)\n                           return validity;\n                       }\n@@ -594,7 +610,9 @@ validate_body_helper (DBusTypeReader       *reader,\n \n             _dbus_assert (_dbus_type_reader_get_current_type (&sub) != DBUS_TYPE_INVALID);\n \n-            validity = validate_body_helper (&sub, byte_order, FALSE, p, end, &p);\n+            validity = validate_body_helper (&sub, byte_order, FALSE,\n+                                             total_depth + 1,\n+                                             p, end, &p);\n             if (validity != DBUS_VALID)\n               return validity;\n \n@@ -623,7 +641,9 @@ validate_body_helper (DBusTypeReader       *reader,\n \n             _dbus_type_reader_recurse (reader, &sub);\n \n-            validity = validate_body_helper (&sub, byte_order, TRUE, p, end, &p);\n+            validity = validate_body_helper (&sub, byte_order, TRUE,\n+                                             total_depth + 1,\n+                                             p, end, &p);\n             if (validity != DBUS_VALID)\n               return validity;\n           }\n@@ -708,7 +728,7 @@ _dbus_validate_body_with_reason (const DBusString *expected_signature,\n   p = _dbus_string_get_const_data_len (value_str, value_pos, len);\n   end = p + len;\n \n-  validity = validate_body_helper (&reader, byte_order, TRUE, p, end, &p);\n+  validity = validate_body_helper (&reader, byte_order, TRUE, 0, p, end, &p);\n   if (validity != DBUS_VALID)\n     return validity;\n   \n@@ -878,7 +898,7 @@ _dbus_validity_to_error_message (DBusValidity validity)\n     case DBUS_INVALID_DICT_ENTRY_HAS_TOO_MANY_FIELDS:              return \"Dict entry has too many fields\";\n     case DBUS_INVALID_DICT_ENTRY_NOT_INSIDE_ARRAY:                 return \"Dict entry not inside array\";\n     case DBUS_INVALID_DICT_KEY_MUST_BE_BASIC_TYPE:                 return \"Dict key must be basic type\";\n-\n+    case DBUS_INVALID_NESTED_TOO_DEEPLY:                           return \"Variants cannot be used to create a hugely recursive tree of values\";\n     default:\n       return \"Invalid\";\n     }\ndiff --git a\/dbus\/dbus-marshal-validate.h b\/dbus\/dbus-marshal-validate.h\nindex 5817de3..8947a2a 100644\n--- a\/dbus\/dbus-marshal-validate.h\n+++ b\/dbus\/dbus-marshal-validate.h\n@@ -112,6 +112,7 @@ typedef enum\n   DBUS_INVALID_DICT_ENTRY_NOT_INSIDE_ARRAY = 54,\n   DBUS_INVALID_DICT_KEY_MUST_BE_BASIC_TYPE = 55,\n   DBUS_INVALID_MISSING_UNIX_FDS = 56,\n+  DBUS_INVALID_NESTED_TOO_DEEPLY = 57,\n   DBUS_VALIDITY_LAST\n } DBusValidity;\n \ndiff --git a\/dbus\/dbus-message-factory.c b\/dbus\/dbus-message-factory.c\nindex 7432cf2..7ecf827 100644\n--- a\/dbus\/dbus-message-factory.c\n+++ b\/dbus\/dbus-message-factory.c\n@@ -333,6 +333,53 @@ simple_error (void)\n   return message;\n }\n \n+static DBusMessage*\n+message_with_nesting_levels (int levels)\n+{\n+  DBusMessage *message;\n+  dbus_int32_t v_INT32;\n+  DBusMessageIter *parents;\n+  DBusMessageIter *children;\n+  int i;\n+\n+  \/* If levels is higher it breaks sig_refcount in DBusMessageRealIter\n+   * in dbus-message.c, this assert is just to help you know you need\n+   * to fix that if you hit it\n+   *\/\n+  _dbus_assert (levels < 256);\n+\n+  parents = dbus_new(DBusMessageIter, levels + 1);\n+  children = dbus_new(DBusMessageIter, levels + 1);\n+\n+  v_INT32 = 42;\n+  message = simple_method_call ();\n+\n+  i = 0;\n+  dbus_message_iter_init_append (message, &parents[i]);\n+  while (i < levels)\n+    {\n+      dbus_message_iter_open_container (&parents[i], DBUS_TYPE_VARIANT,\n+                                        i == (levels - 1) ?\n+                                        DBUS_TYPE_INT32_AS_STRING :\n+                                        DBUS_TYPE_VARIANT_AS_STRING,\n+                                        &children[i]);\n+      ++i;\n+      parents[i] = children[i-1];\n+    }\n+  --i;\n+  dbus_message_iter_append_basic (&children[i], DBUS_TYPE_INT32, &v_INT32);\n+  while (i >= 0)\n+    {\n+      dbus_message_iter_close_container (&parents[i], &children[i]);\n+      --i;\n+    }\n+\n+  dbus_free(parents);\n+  dbus_free(children);\n+\n+  return message;\n+}\n+\n static dbus_bool_t\n generate_special (DBusMessageDataIter   *iter,\n                   DBusString            *data,\n@@ -735,6 +782,24 @@ generate_special (DBusMessageDataIter   *iter,\n       \n       *expected_validity = DBUS_INVALID_DICT_ENTRY_HAS_NO_FIELDS;\n     }\n+  else if (item_seq == 20)\n+    {\n+      \/* 64 levels of nesting is OK *\/\n+      message = message_with_nesting_levels(64);\n+\n+      generate_from_message (data, expected_validity, message);\n+\n+      *expected_validity = DBUS_VALID;\n+    }\n+  else if (item_seq == 21)\n+    {\n+      \/* 65 levels of nesting is not OK *\/\n+      message = message_with_nesting_levels(65);\n+\n+      generate_from_message (data, expected_validity, message);\n+\n+      *expected_validity = DBUS_INVALID_NESTED_TOO_DEEPLY;\n+    }\n   else\n     {\n       return FALSE;\ndiff --git a\/doc\/dbus-specification.xml b\/doc\/dbus-specification.xml\nindex 9a5d70c..ee5aac5 100644\n--- a\/doc\/dbus-specification.xml\n+++ b\/doc\/dbus-specification.xml\n@@ -620,12 +620,14 @@\n \t      <\/row><row>\n                 <entry><literal>VARIANT<\/literal><\/entry>\n                 <entry>\n-                  A variant type has a marshaled <literal>SIGNATURE<\/literal>\n-                  followed by a marshaled value with the type\n-                  given in the signature.\n-                  Unlike a message signature, the variant signature \n-                  can contain only a single complete type.\n-                  So \"i\", \"ai\" or \"(ii)\" is OK, but \"ii\" is not.\n+                  A variant type has a marshaled\n+                  <literal>SIGNATURE<\/literal> followed by a marshaled\n+                  value with the type given in the signature.  Unlike\n+                  a message signature, the variant signature can\n+                  contain only a single complete type.  So \"i\", \"ai\"\n+                  or \"(ii)\" is OK, but \"ii\" is not.  Use of variants may not\n+                  cause a total message depth to be larger than 64, including\n+\t\t  other container types such as structures.\n                 <\/entry>\n                 <entry>\n                   1 (alignment of the signature)\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8117","CWE_ID":"399","category":"security","commit_id":"6f737ddfadb596d7d4a993f7ed2141ffd664a81c","commit_message":"From 6f737ddfadb596d7d4a993f7ed2141ffd664a81c Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Sun, 23 Nov 2014 13:54:27 +0000\nSubject: [PATCH] - reduce recursion level from 20 to 10 and make a symbolic\n constant for it. - pull out the guts of saving and restoring the output\n buffer into functions   and take care not to overwrite the error message if\n an error happened.\n\n---\n src\/file.h      | 10 +++++++++-\n src\/funcs.c     | 42 +++++++++++++++++++++++++++++++++++++++++-\n src\/softmagic.c | 40 ++++++++++++++++++++++++----------------\n 3 files changed, 74 insertions(+), 18 deletions(-)\n\n","diff_code":"diff --git a\/src\/file.h b\/src\/file.h\nindex fdbc889d9..fa0f616db 100644\n--- a\/src\/file.h\n+++ b\/src\/file.h\n@@ -27,7 +27,7 @@\n  *\/\n \/*\n  * file.h - definitions for file(1) program\n- * @(#)$File: file.h,v 1.154 2014\/09\/10 18:41:51 christos Exp $\n+ * @(#)$File: file.h,v 1.155 2014\/10\/11 15:03:16 christos Exp $\n  *\/\n \n #ifndef __file_h__\n@@ -495,6 +495,14 @@ protected int file_regexec(file_regex_t *, const char *, size_t, regmatch_t *,\n protected void file_regfree(file_regex_t *);\n protected void file_regerror(file_regex_t *, int, struct magic_set *);\n \n+typedef struct {\n+\tchar *buf;\n+\tuint32_t offset;\n+} file_pushbuf_t;\n+\n+protected file_pushbuf_t *file_push_buffer(struct magic_set *);\n+protected char  *file_pop_buffer(struct magic_set *, file_pushbuf_t *);\n+\n #ifndef COMPILE_ONLY\n extern const char *file_names[];\n extern const size_t file_nnames;\ndiff --git a\/src\/funcs.c b\/src\/funcs.c\nindex 1517a79f5..7b87dcfb8 100644\n--- a\/src\/funcs.c\n+++ b\/src\/funcs.c\n@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: funcs.c,v 1.72 2014\/05\/14 23:15:42 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: funcs.c,v 1.73 2014\/09\/10 18:41:51 christos Exp $\")\n #endif\t\/* lint *\/\n \n #include \"magic.h\"\n@@ -491,3 +491,43 @@ file_regerror(file_regex_t *rx, int rc, struct magic_set *ms)\n \tfile_magerror(ms, \"regex error %d for `%s', (%s)\", rc, rx->pat,\n \t    errmsg);\n }\n+\n+protected file_pushbuf_t *\n+file_push_buffer(struct magic_set *ms)\n+{\n+\tfile_pushbuf_t *pb;\n+\n+\tif (ms->event_flags & EVENT_HAD_ERR)\n+\t\treturn NULL;\n+\n+\tif ((pb = (CAST(file_pushbuf_t *, malloc(sizeof(*pb))))) == NULL)\n+\t\treturn NULL;\n+\n+\tpb->buf = ms->o.buf;\n+\tpb->offset = ms->offset;\n+\n+\tms->o.buf = NULL;\n+\tms->offset = 0;\n+\n+\treturn pb;\n+}\n+\n+protected char *\n+file_pop_buffer(struct magic_set *ms, file_pushbuf_t *pb)\n+{\n+\tchar *rbuf;\n+\n+\tif (ms->event_flags & EVENT_HAD_ERR) {\n+\t\tfree(pb->buf);\n+\t\tfree(pb);\n+\t\treturn NULL;\n+\t}\n+\n+\trbuf = ms->o.buf;\n+\n+\tms->o.buf = pb->buf;\n+\tms->offset = pb->offset;\n+\n+\tfree(pb);\n+\treturn rbuf;\n+}\ndiff --git a\/src\/softmagic.c b\/src\/softmagic.c\nindex 2b15f2c39..15dfce59c 100644\n--- a\/src\/softmagic.c\n+++ b\/src\/softmagic.c\n@@ -32,7 +32,7 @@\n #include \"file.h\"\n \n #ifndef\tlint\n-FILE_RCSID(\"@(#)$File: softmagic.c,v 1.196 2014\/11\/07 15:24:14 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: softmagic.c,v 1.197 2014\/11\/11 17:48:23 christos Exp $\")\n #endif\t\/* lint *\/\n \n #include \"magic.h\"\n@@ -63,6 +63,9 @@ private void cvt_32(union VALUETYPE *, const struct magic *);\n private void cvt_64(union VALUETYPE *, const struct magic *);\n \n #define OFFSET_OOB(n, o, i)\t((n) < (o) || (i) > ((n) - (o)))\n+\n+#define MAX_RECURSION_LEVEL\t10\n+\n \/*\n  * softmagic - lookup one file in parsed, in-memory copy of database\n  * Passed the name and FILE * of one file to be typed.\n@@ -1217,14 +1220,15 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n     int flip, int recursion_level, int *printed_something,\n     int *need_separator, int *returnval)\n {\n-\tuint32_t soffset, offset = ms->offset;\n+\tuint32_t offset = ms->offset;\n \tuint32_t lhs;\n+\tfile_pushbuf_t *pb;\n \tint rv, oneed_separator, in_type;\n-\tchar *sbuf, *rbuf;\n+\tchar *rbuf;\n \tunion VALUETYPE *p = &ms->ms_value;\n \tstruct mlist ml;\n \n-\tif (recursion_level >= 20) {\n+\tif (recursion_level >= MAX_RECURSION_LEVEL) {\n \t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n \t\treturn -1;\n \t}\n@@ -1669,19 +1673,23 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \tcase FILE_INDIRECT:\n \t\tif (offset == 0)\n \t\t\treturn 0;\n+\n \t\tif (nbytes < offset)\n \t\t\treturn 0;\n-\t\tsbuf = ms->o.buf;\n-\t\tsoffset = ms->offset;\n-\t\tms->o.buf = NULL;\n-\t\tms->offset = 0;\n+\n+\t\tif ((pb = file_push_buffer(ms)) == NULL)\n+\t\t\treturn -1;\n+\n \t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n \t\t    recursion_level, BINTEST, text);\n+\n \t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n \t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n-\t\trbuf = ms->o.buf;\n-\t\tms->o.buf = sbuf;\n-\t\tms->offset = soffset;\n+\n+\t\trbuf = file_pop_buffer(ms, pb);\n+\t\tif (rbuf == NULL)\n+\t\t\treturn -1;\n+\n \t\tif (rv == 1) {\n \t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n \t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n@@ -1699,13 +1707,13 @@ mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n \tcase FILE_USE:\n \t\tif (nbytes < offset)\n \t\t\treturn 0;\n-\t\tsbuf = m->value.s;\n-\t\tif (*sbuf == '^') {\n-\t\t\tsbuf++;\n+\t\trbuf = m->value.s;\n+\t\tif (*rbuf == '^') {\n+\t\t\trbuf++;\n \t\t\tflip = !flip;\n \t\t}\n-\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n-\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n+\t\tif (file_magicfind(ms, rbuf, &ml) == -1) {\n+\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", rbuf);\n \t\t\treturn -1;\n \t\t}\n \n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2010-5329","CWE_ID":"399","category":"security","commit_id":"fc0a80798576f80ca10b3f6c9c7097f12fd1d64e","commit_message":"From fc0a80798576f80ca10b3f6c9c7097f12fd1d64e Mon Sep 17 00:00:00 2001\nFrom: Laurent Pinchart <laurent.pinchart@ideasonboard.com>\nDate: Mon, 12 Jul 2010 11:09:41 -0300\nSubject: [PATCH] [media] v4l: Share code between video_usercopy and\n video_ioctl2\n\nThe two functions are mostly identical. They handle the copy_from_user\nand copy_to_user operations related with V4L2 ioctls and call the real\nioctl handler.\n\nCreate a __video_usercopy function that implements the core of\nvideo_usercopy and video_ioctl2, and call that function from both.\n\nSigned-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>\nAcked-by: Hans Verkuil <hverkuil@xs4all.nl>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>\n---\n drivers\/media\/video\/v4l2-ioctl.c | 109 ++++---------------------------\n 1 file changed, 11 insertions(+), 98 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/media\/video\/v4l2-ioctl.c b\/drivers\/media\/video\/v4l2-ioctl.c\nindex 7a720745c3fad..db6ec3868347b 100644\n--- a\/drivers\/media\/video\/v4l2-ioctl.c\n+++ b\/drivers\/media\/video\/v4l2-ioctl.c\n@@ -294,101 +294,6 @@ void v4l_printk_ioctl(unsigned int cmd)\n }\n EXPORT_SYMBOL(v4l_printk_ioctl);\n \n-\/*\n- * helper function -- handles userspace copying for ioctl arguments\n- * Obsolete usercopy function - Should be removed soon\n- *\/\n-long\n-video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n-\t\tv4l2_kioctl func)\n-{\n-\tchar\tsbuf[128];\n-\tvoid    *mbuf = NULL;\n-\tvoid\t*parg = NULL;\n-\tlong\terr  = -EINVAL;\n-\tint     is_ext_ctrl;\n-\tsize_t  ctrls_size = 0;\n-\tvoid __user *user_ptr = NULL;\n-\n-\tis_ext_ctrl = (cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS ||\n-\t\t       cmd == VIDIOC_TRY_EXT_CTRLS);\n-\n-\t\/*  Copy arguments into temp kernel buffer  *\/\n-\tswitch (_IOC_DIR(cmd)) {\n-\tcase _IOC_NONE:\n-\t\tparg = NULL;\n-\t\tbreak;\n-\tcase _IOC_READ:\n-\tcase _IOC_WRITE:\n-\tcase (_IOC_WRITE | _IOC_READ):\n-\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n-\t\t\tparg = sbuf;\n-\t\t} else {\n-\t\t\t\/* too big to allocate from stack *\/\n-\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n-\t\t\tif (NULL == mbuf)\n-\t\t\t\treturn -ENOMEM;\n-\t\t\tparg = mbuf;\n-\t\t}\n-\n-\t\terr = -EFAULT;\n-\t\tif (_IOC_DIR(cmd) & _IOC_WRITE)\n-\t\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n-\t\t\t\tgoto out;\n-\t\tbreak;\n-\t}\n-\tif (is_ext_ctrl) {\n-\t\tstruct v4l2_ext_controls *p = parg;\n-\n-\t\t\/* In case of an error, tell the caller that it wasn't\n-\t\t   a specific control that caused it. *\/\n-\t\tp->error_idx = p->count;\n-\t\tuser_ptr = (void __user *)p->controls;\n-\t\tif (p->count) {\n-\t\t\tctrls_size = sizeof(struct v4l2_ext_control) * p->count;\n-\t\t\t\/* Note: v4l2_ext_controls fits in sbuf[] so mbuf is still NULL. *\/\n-\t\t\tmbuf = kmalloc(ctrls_size, GFP_KERNEL);\n-\t\t\terr = -ENOMEM;\n-\t\t\tif (NULL == mbuf)\n-\t\t\t\tgoto out_ext_ctrl;\n-\t\t\terr = -EFAULT;\n-\t\t\tif (copy_from_user(mbuf, user_ptr, ctrls_size))\n-\t\t\t\tgoto out_ext_ctrl;\n-\t\t\tp->controls = mbuf;\n-\t\t}\n-\t}\n-\n-\t\/* call driver *\/\n-\terr = func(file, cmd, parg);\n-\tif (err == -ENOIOCTLCMD)\n-\t\terr = -EINVAL;\n-\tif (is_ext_ctrl) {\n-\t\tstruct v4l2_ext_controls *p = parg;\n-\n-\t\tp->controls = (void *)user_ptr;\n-\t\tif (p->count && err == 0 && copy_to_user(user_ptr, mbuf, ctrls_size))\n-\t\t\terr = -EFAULT;\n-\t\tgoto out_ext_ctrl;\n-\t}\n-\tif (err < 0)\n-\t\tgoto out;\n-\n-out_ext_ctrl:\n-\t\/*  Copy results into user buffer  *\/\n-\tswitch (_IOC_DIR(cmd)) {\n-\tcase _IOC_READ:\n-\tcase (_IOC_WRITE | _IOC_READ):\n-\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n-\t\t\terr = -EFAULT;\n-\t\tbreak;\n-\t}\n-\n-out:\n-\tkfree(mbuf);\n-\treturn err;\n-}\n-EXPORT_SYMBOL(video_usercopy);\n-\n static void dbgbuf(unsigned int cmd, struct video_device *vfd,\n \t\t\t\t\tstruct v4l2_buffer *p)\n {\n@@ -2332,8 +2237,9 @@ static int check_array_args(unsigned int cmd, void *parg, size_t *array_size,\n \treturn ret;\n }\n \n-long video_ioctl2(struct file *file,\n-\t       unsigned int cmd, unsigned long arg)\n+long\n+video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n+\t       v4l2_kioctl func)\n {\n \tchar\tsbuf[128];\n \tvoid    *mbuf = NULL;\n@@ -2395,7 +2301,7 @@ long video_ioctl2(struct file *file,\n \t}\n \n \t\/* Handles IOCTL *\/\n-\terr = __video_do_ioctl(file, cmd, parg);\n+\terr = func(file, cmd, parg);\n \tif (err == -ENOIOCTLCMD)\n \t\terr = -EINVAL;\n \n@@ -2422,4 +2328,11 @@ long video_ioctl2(struct file *file,\n \tkfree(mbuf);\n \treturn err;\n }\n+EXPORT_SYMBOL(video_usercopy);\n+\n+long video_ioctl2(struct file *file,\n+\t       unsigned int cmd, unsigned long arg)\n+{\n+\treturn video_usercopy(file, cmd, arg, __video_do_ioctl);\n+}\n EXPORT_SYMBOL(video_ioctl2);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-12997","CWE_ID":"399","category":"security","commit_id":"34cec721d39c76be1e0a600829a7b17bdfb832b6","commit_message":"From 34cec721d39c76be1e0a600829a7b17bdfb832b6 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Mon, 13 Feb 2017 11:11:42 -0800\nSubject: [PATCH] CVE-2017-12997\/LLDP: Don't use an 8-bit loop counter.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nIf you have a\n\n\tfor (i = 0; i < N; i++)\n\nloop, you'd better make sure that i is big enough to hold N - not N-1,\nN.\n\nThe TLV length here is 9 bits long, not 8 bits long, so an 8-bit loop\ncounter will overflow and you can loop infinitely.\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd tests using the capture files supplied by the reporter(s).\n\nClean up the output a bit while we're at it.\n---\n print-lldp.c                    |   8 +-\n tests\/TESTLIST                  |   2 +\n tests\/lldp-infinite-loop-1.out  | 134 ++++++++++++++++++++++++++\n tests\/lldp-infinite-loop-1.pcap | Bin 0 -> 1795 bytes\n tests\/lldp-infinite-loop-2.out  | 161 ++++++++++++++++++++++++++++++++\n tests\/lldp-infinite-loop-2.pcap | Bin 0 -> 2170 bytes\n 6 files changed, 301 insertions(+), 4 deletions(-)\n create mode 100644 tests\/lldp-infinite-loop-1.out\n create mode 100644 tests\/lldp-infinite-loop-1.pcap\n create mode 100644 tests\/lldp-infinite-loop-2.out\n create mode 100644 tests\/lldp-infinite-loop-2.pcap\n\n","diff_code":"diff --git a\/print-lldp.c b\/print-lldp.c\nindex fbafd6d5a..dfdf1b94a 100644\n--- a\/print-lldp.c\n+++ b\/print-lldp.c\n@@ -651,7 +651,7 @@ lldp_private_8021_print(netdissect_options *ndo,\n     int subtype, hexdump = FALSE;\n     u_int sublen;\n     u_int tval;\n-    uint8_t i;\n+    u_int i;\n \n     if (tlv_len < 4) {\n         return hexdump;\n@@ -787,9 +787,9 @@ lldp_private_8021_print(netdissect_options *ndo,\n         ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));\n         while(i<sublen) {\n         \ttval=*(tptr+i+5);\n-        \tND_PRINT((ndo, \"\\n\\t      Priority: %d, RES: %d, Sel: %d\",\n-        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));\n-        \tND_PRINT((ndo, \"Protocol ID: %d\", EXTRACT_16BITS(tptr + i + 5)));\n+        \tND_PRINT((ndo, \"\\n\\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u\",\n+        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),\n+        \t\t EXTRACT_16BITS(tptr + i + 5)));\n         \ti=i+3;\n         }\n         break;\ndiff --git a\/tests\/TESTLIST b\/tests\/TESTLIST\nindex 5633053bf..ef8bffc74 100644\n--- a\/tests\/TESTLIST\n+++ b\/tests\/TESTLIST\n@@ -479,6 +479,8 @@ dns_fwdptr\t\tdns_fwdptr.pcap\t\t\tdns_fwdptr.out\t\t-vvv -e\n isis-areaaddr-oobr-1\tisis-areaaddr-oobr-1.pcap\tisis-areaaddr-oobr-1.out\t\t-vvv -e\n isis-areaaddr-oobr-2\tisis-areaaddr-oobr-2.pcap\tisis-areaaddr-oobr-2.out\t\t-vvv -e\n isis-extd-ipreach-oobr\tisis-extd-ipreach-oobr.pcap\tisis-extd-ipreach-oobr.out\t\t-vvv -e\n+lldp-infinite-loop-1\tlldp-infinite-loop-1.pcap\tlldp-infinite-loop-1.out\t\t-vvv -e\n+lldp-infinite-loop-2\tlldp-infinite-loop-2.pcap\tlldp-infinite-loop-2.out\t\t-vvv -e\n \n # RTP tests\n # fuzzed pcap\ndiff --git a\/tests\/lldp-infinite-loop-1.out b\/tests\/lldp-infinite-loop-1.out\nnew file mode 100644\nindex 000000000..31ba71007\n--- \/dev\/null\n+++ b\/tests\/lldp-infinite-loop-1.out\n@@ -0,0 +1,134 @@\n+08:00:27:42:ba:59 > 01:80:c2:00:00:0e, ethertype LLDP (0x88cc), length 1755: LLDP, length 1741\n+\tChassis ID TLV (1), length 7\n+\t  Subtype MAC address (4): 08:00:27:42:ba:59\n+\t  0x0000:  0408 0027 42ba 59\n+\tPort ID TLV (2), length 7\n+\t  Subtype MAC address (3): 08:00:27:42:ba:59\n+\t  0x0000:  0308 0027 42ba 59\n+\tTime to Live TLV (3), length 2: TTL 120s\n+\t  0x0000:  0078\n+\tOrganization specific TLV (127), length 6: OUI Ethernet bridged (0x0080c2)\n+\t  Port VLAN Id Subtype (1)\n+\t    port vlan id (PVID): 0\n+\t  0x0000:  0080 c201 0000\n+\tOrganization specific TLV (127), length 7: OUI Ethernet bridged (0x0080c2)\n+\t  Port and Protocol VLAN ID Subtype (2)\n+\t    port and protocol vlan id (PPVID): 0, flags [supported] (0x02)\n+\t  0x0000:  0080 c202 0200 00\n+\tOrganization specific TLV (127), length 14: OUI Ethernet bridged (0x0080c2)\n+\t  VLAN name Subtype (3)\n+\t    vlan id (VID): 1\n+\t    vlan name: default\n+\t  0x0000:  0080 c203 0001 0764 6566 6175 6c74\n+\tOrganization specific TLV (127), length 13: OUI Ethernet bridged (0x0080c2)\n+\t  Protocol Identity Subtype (4)\n+\t    protocol identity: \n+\t  0x0000:  0080 c204 0800 0042 4203 0080 08\n+\tOrganization specific TLV (127), length 263: OUI Ethernet bridged (0x0080c2)\n+\t  Application Priority Subtype (12)\n+\t    RES: 0\n+\t    Application Priority Table\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 6, RES: 0, Sel: 2, Protocol ID: 49676\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 128\n+\t      Priority: 0, RES: 1, Sel: 4, Protocol ID: 3072\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 4, RES: 0, Sel: 0, Protocol ID: 32962\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t      Priority: 0, RES: 0, Sel: 0, Protocol ID: 0\n+\t  0x0000:  0080 c20c 0000 0000 0000 0000 80c2 0c00\n+\t  0x0010:  0000 0000 0000 0080 c20c 0000 0000 0000\n+\t  0x0020:  0000 80c2 0c00 0000 0000 0000 0080 c20c\n+\t  0x0030:  0000 0000 0000 0000 80c2 0c00 0000 0000\n+\t  0x0040:  0000 0080 c20c 0000 0000 0000 0000 80c2\n+\t  0x0050:  0c00 0000 0000 0000 0080 c20c 0000 0000\n+\t  0x0060:  0000 0000 80c2 0c00 0000 0000 0000 0080\n+\t  0x0070:  c20c 0000 0000 0000 0000 80c2 0c00 0000\n+\t  0x0080:  0000 0000 0080 c20c 0000 0000 0000 0000\n+\t  0x0090:  80c2 0c00 0000 0000 0000 0080 c20c 0000\n+\t  0x00a0:  0000 0000 0000 80c2 0c00 0000 0000 0000\n+\t  0x00b0:  0080 c20c 0000 0000 0000 0000 80c2 0c00\n+\t  0x00c0:  0000 0000 0000 0080 c20c 0000 0000 0000\n+\t  0x00d0:  0000 80c2 0c00 0000 0000 0000 0080 c20c\n+\t  0x00e0:  0000 0000 0000 0000 80c2 0c00 0000 0000\n+\t  0x00f0:  0000 0080 c20c 0000 0000 0000 0000 80c2\n+\t  0x0100:  0c00 0000 0000 00\n+\tEnd TLV (0), length 0\ndiff --git a\/tests\/lldp-infinite-loop-1.pcap b\/tests\/lldp-infinite-loop-1.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..232dbbd25dba417ffb46f90c1172d81a87626ec9\nGIT binary patch\nliteral 1795\nzcmca|c+)~A1{MYw`2U}Qff2?5(zn?ln6cpy0|OrigSykM$c{5i>?{x_3p+D}!N$Z;\nz@sEw6;Sf;sKXxF^!~|sU0U68;jO;0?X^EvdCI5JVe4tJSCnsix29EzAbv!W3MwyV1\nh7!8Nfa2U-O&{APEGmM<f@L!36(E;dP`o=i}0|2M@;~)S4\n\nliteral 0\nHcmV?d00001\n\ndiff --git a\/tests\/lldp-infinite-loop-2.out b\/tests\/lldp-infinite-loop-2.out\nnew file mode 100644\nindex 000000000..401668130\n--- \/dev\/null\n+++ b\/tests\/lldp-infinite-loop-2.out\n@@ -0,0 +1,161 @@\n+08:00:27:0d:f1:3c > 01:80:c2:00:00:0e, ethertype LLDP (0x88cc), length 2130: LLDP, length 2116\n+\tChassis ID TLV (1), length 7\n+\t  Subtype MAC address (4): 08:00:27:0d:f1:3c\n+\t  0x0000:  0408 0027 0df1 3c\n+\tPort ID TLV (2), length 7\n+\t  Subtype MAC address (3): 08:00:27:0d:f1:3c\n+\t  0x0000:  0308 0027 0df1 3c\n+\tTime to Live TLV (3), length 2: TTL 120s\n+\t  0x0000:  0078\n+\tOrganization specific TLV (127), length 6: OUI Ethernet bridged (0x0080c2)\n+\t  Port VLAN Id Subtype (1)\n+\t    port vlan id (PVID): 1\n+\t  0x0000:  0080 c201 0001\n+\tOrganization specific TLV (127), length 7: OUI Ethernet bridged (0x0080c2)\n+\t  Port and Protocol VLAN ID Subtype (2)\n+\t    port and protocol vlan id (PPVID): 0, flags [supported] (0x02)\n+\t  0x0000:  0080 c202 0200 00\n+\tOrganization specific TLV (127), length 14: OUI Ethernet bridged (0x0080c2)\n+\t  VLAN name Subtype (3)\n+\t    vlan id (VID): 1\n+\t    vlan name: default\n+\t  0x0000:  0080 c203 0001 0764 6566 6175 6c74\n+\tOrganization specific TLV (127), length 13: OUI Ethernet bridged (0x0080c2)\n+\t  Protocol Identity Subtype (4)\n+\t    protocol identity: \n+\t  0x0000:  0080 c204 0800 0042 4203 0000 03\n+\tOrganization specific TLV (127), length 9: OUI Ethernet bridged (0x0080c2)\n+\t  EVB Subtype (13)\n+\t    EVB Bridge Status\n+\t      RES: 0, BGID: 0, RRCAP: 1, RRCTR: 0\n+\t    EVB Station Status\n+\t      RES: 0, SGID: 0, RRREQ: 0,RRSTAT: 0\n+\t    R: 7, RTE: 21, EVB Mode: EVB Bridge [1]\n+\t    ROL: 0, RWD: 30, RES: 0, ROL: 0, RKA: 15\n+\t  0x0000:  0080 c20d 0200 f55e 0f\n+\tOrganization specific TLV (127), length 266: OUI Ethernet bridged (0x0080c2)\n+\t  CDCP Subtype (14)\n+\t    Role: 0, RES: 0, Scomp: 0 ChnCap: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t    SCID: 3104, SVID: 3584\n+\t    SCID: 0, SVID: 167\n+\t    SCID: 1, SVID: 1\n+\t    SCID: 0, SVID: 194\n+\t    SCID: 224, SVID: 0\n+\t    SCID: 10, SVID: 1792\n+\t    SCID: 256, SVID: 256\n+\t    SCID: 12, SVID: 526\n+\t    SCID: 0, SVID: 0\n+\t    SCID: 2672, SVID: 16\n+\t    SCID: 16, SVID: 0\n+\t  0x0000:  0080 c20e 0000 00a7 0010 0100 00c2 0e00\n+\t  0x0010:  0000 a700 1001 0000 c20e 0000 00a7 0010\n+\t  0x0020:  0100 00c2 0e00 0000 a700 1001 0000 c20e\n+\t  0x0030:  0000 00a7 0010 0100 00c2 0e00 0000 a700\n+\t  0x0040:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x0050:  0e00 0000 a700 1001 0000 c20e 0000 00a7\n+\t  0x0060:  0010 0100 00c2 0e00 0000 a700 1001 0000\n+\t  0x0070:  c20e 0000 00a7 0010 0100 00c2 0e00 0000\n+\t  0x0080:  a700 1001 0000 c20e 0000 00a7 0010 0100\n+\t  0x0090:  00c2 0e00 0000 a700 1001 0000 c20e 0000\n+\t  0x00a0:  00a7 0010 0100 00c2 0e00 0000 a700 1001\n+\t  0x00b0:  0000 c20e 0000 00a7 0010 0100 00c2 0e00\n+\t  0x00c0:  0000 a700 1001 0000 c20e 0000 00a7 0010\n+\t  0x00d0:  0100 00c2 0e00 0000 a700 1001 0000 c20e\n+\t  0x00e0:  0000 00a7 0010 0100 00c2 0e00 0000 a700\n+\t  0x00f0:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x0100:  0e00 0000 a700 1001 0000\n+\tUnknown TLV (97), length 14\n+\t  0x0000:  0000 00a7 0010 0100 00c2 0e00 0000\n+\tUnknown TLV (83), length 256\n+\t  0x0000:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x0010:  0e00 0000 a700 1001 0000 c20e 0000 00a7\n+\t  0x0020:  0010 0100 00c2 0e00 0000 a700 1001 0000\n+\t  0x0030:  c20e 0000 00a7 0010 0100 00c2 0e00 0000\n+\t  0x0040:  a700 1001 0000 c20e 0000 00a7 0010 0100\n+\t  0x0050:  00c2 0e00 0000 a700 1001 0000 c20e 0000\n+\t  0x0060:  00a7 0010 0100 00c2 0e00 0000 a700 1001\n+\t  0x0070:  0000 c20e 0000 00a7 0010 0100 00c2 0e00\n+\t  0x0080:  0000 a700 1001 0000 c20e 0000 00a7 0010\n+\t  0x0090:  0100 00c2 0e00 0000 a700 1001 0000 c20e\n+\t  0x00a0:  0000 00a7 0010 0100 00c2 0e00 0000 a700\n+\t  0x00b0:  1001 0000 c20e 0000 00a7 0010 0100 00c2\n+\t  0x00c0:  0e00 0000 a700 1001 0000 c20e 0000 00a7\n+\t  0x00d0:  0010 0100 00c2 0e00 0000 a700 1001 0000\n+\t  0x00e0:  c20e 0000 00a7 0010 0100 00c2 0e00 0000\n+\t  0x00f0:  a700 1001 0000 c20e 0000 00a7 0010 0100\n+\tEnd TLV (0), length 194\ndiff --git a\/tests\/lldp-infinite-loop-2.pcap b\/tests\/lldp-infinite-loop-2.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e8599831820017b9d2fdbff74db8c38eefc908a3\nGIT binary patch\nliteral 2170\nzcmca|c+)~A1{MYw`2U}Qff2?5(m@;$%-C><fq{>ML7n%bO~)A~b`}Veg`F9~U}Iva\nz_{YZ3aEOtC@gF;oW@2Js_{RriFf%Z+r=+GOmgbcF;|218IvJdtm>C$D|8WAjyi5#V\nw<M{t`0hxS2`<62Z0IeToj)uc%A{fmKbSMcJN7LD8I-^568?^#fxkFnQ07_>#<^TWy\n\nliteral 0\nHcmV?d00001\n\n","owner":"the-tcpdump-group","repo":"tcpdump","source":"cve"},{"CVE_ID":"CVE-2013-4163","CWE_ID":"399","category":"security","commit_id":"75a493e60ac4bbe2e977e7129d6d8cbb0dd236be","commit_message":"From 75a493e60ac4bbe2e977e7129d6d8cbb0dd236be Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Tue, 2 Jul 2013 08:04:05 +0200\nSubject: ipv6: ip6_append_data_mtu did not care about pmtudisc and frag_size\n\nIf the socket had an IPV6_MTU value set, ip6_append_data_mtu lost track\nof this when appending the second frame on a corked socket. This results\nin the following splat:\n\n[37598.993962] ------------[ cut here ]------------\n[37598.994008] kernel BUG at net\/core\/skbuff.c:2064!\n[37598.994008] invalid opcode: 0000 [#1] SMP\n[37598.994008] Modules linked in: tcp_lp uvcvideo videobuf2_vmalloc videobuf2_memops videobuf2_core videodev media vfat fat usb_storage fuse ebtable_nat xt_CHECKSUM bridge stp llc ipt_MASQUERADE nf_conntrack_netbios_ns nf_conntrack_broadcast ip6table_mangle ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 iptable_nat\n+nf_nat_ipv4 nf_nat iptable_mangle nf_conntrack_ipv4 nf_defrag_ipv4 xt_conntrack nf_conntrack ebtable_filter ebtables ip6table_filter ip6_tables be2iscsi iscsi_boot_sysfs bnx2i cnic uio cxgb4i cxgb4 cxgb3i cxgb3 mdio libcxgbi ib_iser rdma_cm ib_addr iw_cm ib_cm ib_sa ib_mad ib_core iscsi_tcp libiscsi_tcp libiscsi\n+scsi_transport_iscsi rfcomm bnep iTCO_wdt iTCO_vendor_support snd_hda_codec_conexant arc4 iwldvm mac80211 snd_hda_intel acpi_cpufreq mperf coretemp snd_hda_codec microcode cdc_wdm cdc_acm\n[37598.994008]  snd_hwdep cdc_ether snd_seq snd_seq_device usbnet mii joydev btusb snd_pcm bluetooth i2c_i801 e1000e lpc_ich mfd_core ptp iwlwifi pps_core snd_page_alloc mei cfg80211 snd_timer thinkpad_acpi snd tpm_tis soundcore rfkill tpm tpm_bios vhost_net tun macvtap macvlan kvm_intel kvm uinput binfmt_misc\n+dm_crypt i915 i2c_algo_bit drm_kms_helper drm i2c_core wmi video\n[37598.994008] CPU 0\n[37598.994008] Pid: 27320, comm: t2 Not tainted 3.9.6-200.fc18.x86_64 #1 LENOVO 27744PG\/27744PG\n[37598.994008] RIP: 0010:[<ffffffff815443a5>]  [<ffffffff815443a5>] skb_copy_and_csum_bits+0x325\/0x330\n[37598.994008] RSP: 0018:ffff88003670da18  EFLAGS: 00010202\n[37598.994008] RAX: ffff88018105c018 RBX: 0000000000000004 RCX: 00000000000006c0\n[37598.994008] RDX: ffff88018105a6c0 RSI: ffff88018105a000 RDI: ffff8801e1b0aa00\n[37598.994008] RBP: ffff88003670da78 R08: 0000000000000000 R09: ffff88018105c040\n[37598.994008] R10: ffff8801e1b0aa00 R11: 0000000000000000 R12: 000000000000fff8\n[37598.994008] R13: 00000000000004fc R14: 00000000ffff0504 R15: 0000000000000000\n[37598.994008] FS:  00007f28eea59740(0000) GS:ffff88023bc00000(0000) knlGS:0000000000000000\n[37598.994008] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[37598.994008] CR2: 0000003d935789e0 CR3: 00000000365cb000 CR4: 00000000000407f0\n[37598.994008] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[37598.994008] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n[37598.994008] Process t2 (pid: 27320, threadinfo ffff88003670c000, task ffff88022c162ee0)\n[37598.994008] Stack:\n[37598.994008]  ffff88022e098a00 ffff88020f973fc0 0000000000000008 00000000000004c8\n[37598.994008]  ffff88020f973fc0 00000000000004c4 ffff88003670da78 ffff8801e1b0a200\n[37598.994008]  0000000000000018 00000000000004c8 ffff88020f973fc0 00000000000004c4\n[37598.994008] Call Trace:\n[37598.994008]  [<ffffffff815fc21f>] ip6_append_data+0xccf\/0xfe0\n[37598.994008]  [<ffffffff8158d9f0>] ? ip_copy_metadata+0x1a0\/0x1a0\n[37598.994008]  [<ffffffff81661f66>] ? _raw_spin_lock_bh+0x16\/0x40\n[37598.994008]  [<ffffffff8161548d>] udpv6_sendmsg+0x1ed\/0xc10\n[37598.994008]  [<ffffffff812a2845>] ? sock_has_perm+0x75\/0x90\n[37598.994008]  [<ffffffff815c3693>] inet_sendmsg+0x63\/0xb0\n[37598.994008]  [<ffffffff812a2973>] ? selinux_socket_sendmsg+0x23\/0x30\n[37598.994008]  [<ffffffff8153a450>] sock_sendmsg+0xb0\/0xe0\n[37598.994008]  [<ffffffff810135d1>] ? __switch_to+0x181\/0x4a0\n[37598.994008]  [<ffffffff8153d97d>] sys_sendto+0x12d\/0x180\n[37598.994008]  [<ffffffff810dfb64>] ? __audit_syscall_entry+0x94\/0xf0\n[37598.994008]  [<ffffffff81020ed1>] ? syscall_trace_enter+0x231\/0x240\n[37598.994008]  [<ffffffff8166a7e7>] tracesys+0xdd\/0xe2\n[37598.994008] Code: fe 07 00 00 48 c7 c7 04 28 a6 81 89 45 a0 4c 89 4d b8 44 89 5d a8 e8 1b ac b1 ff 44 8b 5d a8 4c 8b 4d b8 8b 45 a0 e9 cf fe ff ff <0f> 0b 66 0f 1f 84 00 00 00 00 00 66 66 66 66 90 55 48 89 e5 48\n[37598.994008] RIP  [<ffffffff815443a5>] skb_copy_and_csum_bits+0x325\/0x330\n[37598.994008]  RSP <ffff88003670da18>\n[37599.007323] ---[ end trace d69f6a17f8ac8eee ]---\n\nWhile there, also check if path mtu discovery is activated for this\nsocket. The logic was adapted from ip6_append_data when first writing\non the corked socket.\n\nThis bug was introduced with commit\n0c1833797a5a6ec23ea9261d979aa18078720b74 (\"ipv6: fix incorrect ipsec\nfragment\").\n\nv2:\na) Replace IPV6_PMTU_DISC_DO with IPV6_PMTUDISC_PROBE.\nb) Don't pass ipv6_pinfo to ip6_append_data_mtu (suggestion by Gao\n   feng, thanks!).\nc) Change mtu to unsigned int, else we get a warning about\n   non-matching types because of the min()-macro type-check.\n\nAcked-by: Gao feng <gaofeng@cn.fujitsu.com>\nCc: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/ip6_output.c | 16 ++++++++++------\n 1 file changed, 10 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/ip6_output.c b\/net\/ipv6\/ip6_output.c\nindex dae1949019d7..be7589ef5cf9 100644\n--- a\/net\/ipv6\/ip6_output.c\n+++ b\/net\/ipv6\/ip6_output.c\n@@ -1093,11 +1093,12 @@ static inline struct ipv6_rt_hdr *ip6_rthdr_dup(struct ipv6_rt_hdr *src,\n \treturn src ? kmemdup(src, (src->hdrlen + 1) * 8, gfp) : NULL;\n }\n \n-static void ip6_append_data_mtu(int *mtu,\n+static void ip6_append_data_mtu(unsigned int *mtu,\n \t\t\t\tint *maxfraglen,\n \t\t\t\tunsigned int fragheaderlen,\n \t\t\t\tstruct sk_buff *skb,\n-\t\t\t\tstruct rt6_info *rt)\n+\t\t\t\tstruct rt6_info *rt,\n+\t\t\t\tbool pmtuprobe)\n {\n \tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n \t\tif (skb == NULL) {\n@@ -1109,7 +1110,9 @@ static void ip6_append_data_mtu(int *mtu,\n \t\t\t * this fragment is not first, the headers\n \t\t\t * space is regarded as data space.\n \t\t\t *\/\n-\t\t\t*mtu = dst_mtu(rt->dst.path);\n+\t\t\t*mtu = min(*mtu, pmtuprobe ?\n+\t\t\t\t   rt->dst.dev->mtu :\n+\t\t\t\t   dst_mtu(rt->dst.path));\n \t\t}\n \t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n \t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n@@ -1126,11 +1129,10 @@ int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct inet_cork *cork;\n \tstruct sk_buff *skb, *skb_prev = NULL;\n-\tunsigned int maxfraglen, fragheaderlen;\n+\tunsigned int maxfraglen, fragheaderlen, mtu;\n \tint exthdrlen;\n \tint dst_exthdrlen;\n \tint hh_len;\n-\tint mtu;\n \tint copy;\n \tint err;\n \tint offset = 0;\n@@ -1287,7 +1289,9 @@ alloc_new_skb:\n \t\t\t\/* update mtu and maxfraglen if necessary *\/\n \t\t\tif (skb == NULL || skb_prev == NULL)\n \t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n-\t\t\t\t\t\t    fragheaderlen, skb, rt);\n+\t\t\t\t\t\t    fragheaderlen, skb, rt,\n+\t\t\t\t\t\t    np->pmtudisc ==\n+\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n \n \t\t\tskb_prev = skb;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-1819","CWE_ID":"399","category":"security","commit_id":"213f1fe0d76d30eaed6e5853057defc43e6df2c9","commit_message":"From 213f1fe0d76d30eaed6e5853057defc43e6df2c9 Mon Sep 17 00:00:00 2001\nFrom: Daniel Veillard <veillard@redhat.com>\nDate: Tue, 14 Apr 2015 17:41:48 +0800\nSubject: [PATCH] CVE-2015-1819 Enforce the reader to run in constant memory\n\nOne of the operation on the reader could resolve entities\nleading to the classic expansion issue. Make sure the\nbuffer used for xmlreader operation is bounded.\nIntroduce a new allocation type for the buffers for this effect.\n---\n buf.c                 | 43 ++++++++++++++++++++++++++++++++++++++++++-\n include\/libxml\/tree.h |  3 ++-\n xmlreader.c           | 20 +++++++++++++++++++-\n 3 files changed, 63 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/buf.c b\/buf.c\nindex 6efc7b67..07922ff6 100644\n--- a\/buf.c\n+++ b\/buf.c\n@@ -27,6 +27,7 @@\n #include <libxml\/tree.h>\n #include <libxml\/globals.h>\n #include <libxml\/tree.h>\n+#include <libxml\/parserInternals.h> \/* for XML_MAX_TEXT_LENGTH *\/\n #include \"buf.h\"\n \n #define WITH_BUFFER_COMPAT\n@@ -299,7 +300,8 @@ xmlBufSetAllocationScheme(xmlBufPtr buf,\n     if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||\n         (scheme == XML_BUFFER_ALLOC_EXACT) ||\n         (scheme == XML_BUFFER_ALLOC_HYBRID) ||\n-        (scheme == XML_BUFFER_ALLOC_IMMUTABLE)) {\n+        (scheme == XML_BUFFER_ALLOC_IMMUTABLE) ||\n+\t(scheme == XML_BUFFER_ALLOC_BOUNDED)) {\n \tbuf->alloc = scheme;\n         if (buf->buffer)\n             buf->buffer->alloc = scheme;\n@@ -458,6 +460,18 @@ xmlBufGrowInternal(xmlBufPtr buf, size_t len) {\n     size = buf->use + len + 100;\n #endif\n \n+    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n+        \/*\n+\t * Used to provide parsing limits\n+\t *\/\n+        if ((buf->use + len >= XML_MAX_TEXT_LENGTH) ||\n+\t    (buf->size >= XML_MAX_TEXT_LENGTH)) {\n+\t    xmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n+\t    return(0);\n+\t}\n+\tif (size >= XML_MAX_TEXT_LENGTH)\n+\t    size = XML_MAX_TEXT_LENGTH;\n+    }\n     if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n         size_t start_buf = buf->content - buf->contentIO;\n \n@@ -739,6 +753,15 @@ xmlBufResize(xmlBufPtr buf, size_t size)\n     CHECK_COMPAT(buf)\n \n     if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return(0);\n+    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n+        \/*\n+\t * Used to provide parsing limits\n+\t *\/\n+        if (size >= XML_MAX_TEXT_LENGTH) {\n+\t    xmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n+\t    return(0);\n+\t}\n+    }\n \n     \/* Don't resize if we don't have to *\/\n     if (size < buf->size)\n@@ -867,6 +890,15 @@ xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {\n \n     needSize = buf->use + len + 2;\n     if (needSize > buf->size){\n+\tif (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n+\t    \/*\n+\t     * Used to provide parsing limits\n+\t     *\/\n+\t    if (needSize >= XML_MAX_TEXT_LENGTH) {\n+\t\txmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n+\t\treturn(-1);\n+\t    }\n+\t}\n         if (!xmlBufResize(buf, needSize)){\n \t    xmlBufMemoryError(buf, \"growing buffer\");\n             return XML_ERR_NO_MEMORY;\n@@ -938,6 +970,15 @@ xmlBufAddHead(xmlBufPtr buf, const xmlChar *str, int len) {\n     }\n     needSize = buf->use + len + 2;\n     if (needSize > buf->size){\n+\tif (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n+\t    \/*\n+\t     * Used to provide parsing limits\n+\t     *\/\n+\t    if (needSize >= XML_MAX_TEXT_LENGTH) {\n+\t\txmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n+\t\treturn(-1);\n+\t    }\n+\t}\n         if (!xmlBufResize(buf, needSize)){\n \t    xmlBufMemoryError(buf, \"growing buffer\");\n             return XML_ERR_NO_MEMORY;\ndiff --git a\/include\/libxml\/tree.h b\/include\/libxml\/tree.h\nindex 2f90717c..4a9b3bc6 100644\n--- a\/include\/libxml\/tree.h\n+++ b\/include\/libxml\/tree.h\n@@ -76,7 +76,8 @@ typedef enum {\n     XML_BUFFER_ALLOC_EXACT,\t\/* grow only to the minimal size *\/\n     XML_BUFFER_ALLOC_IMMUTABLE, \/* immutable buffer *\/\n     XML_BUFFER_ALLOC_IO,\t\/* special allocation scheme used for I\/O *\/\n-    XML_BUFFER_ALLOC_HYBRID\t\/* exact up to a threshold, and doubleit thereafter *\/\n+    XML_BUFFER_ALLOC_HYBRID,\t\/* exact up to a threshold, and doubleit thereafter *\/\n+    XML_BUFFER_ALLOC_BOUNDED\t\/* limit the upper size of the buffer *\/\n } xmlBufferAllocationScheme;\n \n \/**\ndiff --git a\/xmlreader.c b\/xmlreader.c\nindex f19e1233..471e7e2a 100644\n--- a\/xmlreader.c\n+++ b\/xmlreader.c\n@@ -2091,6 +2091,9 @@ xmlNewTextReader(xmlParserInputBufferPtr input, const char *URI) {\n \t\t\"xmlNewTextReader : malloc failed\\n\");\n \treturn(NULL);\n     }\n+    \/* no operation on a reader should require a huge buffer *\/\n+    xmlBufSetAllocationScheme(ret->buffer,\n+\t\t\t      XML_BUFFER_ALLOC_BOUNDED);\n     ret->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));\n     if (ret->sax == NULL) {\n \txmlBufFree(ret->buffer);\n@@ -3616,6 +3619,7 @@ xmlTextReaderConstValue(xmlTextReaderPtr reader) {\n \t    return(((xmlNsPtr) node)->href);\n         case XML_ATTRIBUTE_NODE:{\n \t    xmlAttrPtr attr = (xmlAttrPtr) node;\n+\t    const xmlChar *ret;\n \n \t    if ((attr->children != NULL) &&\n \t        (attr->children->type == XML_TEXT_NODE) &&\n@@ -3629,10 +3633,21 @@ xmlTextReaderConstValue(xmlTextReaderPtr reader) {\n                                         \"xmlTextReaderSetup : malloc failed\\n\");\n                         return (NULL);\n                     }\n+\t\t    xmlBufSetAllocationScheme(reader->buffer,\n+\t\t                              XML_BUFFER_ALLOC_BOUNDED);\n                 } else\n                     xmlBufEmpty(reader->buffer);\n \t        xmlBufGetNodeContent(reader->buffer, node);\n-\t\treturn(xmlBufContent(reader->buffer));\n+\t\tret = xmlBufContent(reader->buffer);\n+\t\tif (ret == NULL) {\n+\t\t    \/* error on the buffer best to reallocate *\/\n+\t\t    xmlBufFree(reader->buffer);\n+\t\t    reader->buffer = xmlBufCreateSize(100);\n+\t\t    xmlBufSetAllocationScheme(reader->buffer,\n+\t\t                              XML_BUFFER_ALLOC_BOUNDED);\n+\t\t    ret = BAD_CAST \"\";\n+\t\t}\n+\t\treturn(ret);\n \t    }\n \t    break;\n \t}\n@@ -5131,6 +5146,9 @@ xmlTextReaderSetup(xmlTextReaderPtr reader,\n                         \"xmlTextReaderSetup : malloc failed\\n\");\n         return (-1);\n     }\n+    \/* no operation on a reader should require a huge buffer *\/\n+    xmlBufSetAllocationScheme(reader->buffer,\n+\t\t\t      XML_BUFFER_ALLOC_BOUNDED);\n     if (reader->sax == NULL)\n \treader->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));\n     if (reader->sax == NULL) {\n-- \n2.21.0\n\n","owner":"GNOME","repo":"libxml2","source":"cve"},{"CVE_ID":"CVE-2019-13310","CWE_ID":"399","category":"security","commit_id":"5f21230b657ccd65452dd3d94c5b5401ba691a2d","commit_message":"From 5f21230b657ccd65452dd3d94c5b5401ba691a2d Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 23 Jun 2019 11:46:42 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1616\n\n---\n MagickWand\/mogrify.c   | 3 +++\n MagickWand\/operation.c | 5 ++++-\n 2 files changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/MagickWand\/mogrify.c b\/MagickWand\/mogrify.c\nindex 82b3c0c1c4..150b679230 100644\n--- a\/MagickWand\/mogrify.c\n+++ b\/MagickWand\/mogrify.c\n@@ -7908,6 +7908,8 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n               &distortion,exception);\n             if (difference_image == (Image *) NULL)\n               break;\n+            reconstruct_image=DestroyImage(reconstruct_image);\n+            image=DestroyImage(image);\n             if (*images != (Image *) NULL)\n               *images=DestroyImageList(*images);\n             *images=difference_image;\n@@ -8295,6 +8297,7 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n                    q=GetImageFromList(*images,index-1);\n                    if (q == (Image *) NULL)\n                      {\n+                       p=DestroyImage(p);\n                        (void) ThrowMagickException(exception,GetMagickModule(),\n                          OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                        status=MagickFalse;\ndiff --git a\/MagickWand\/operation.c b\/MagickWand\/operation.c\nindex 9005da5887..b874574346 100644\n--- a\/MagickWand\/operation.c\n+++ b\/MagickWand\/operation.c\n@@ -4171,7 +4171,10 @@ WandPrivate MagickBooleanType CLIListOperatorImages(MagickCLI *cli_wand,\n             {\n                index_image=GetImageFromList(_images,index-1);\n                if (index_image == (Image *) NULL)\n-                 CLIWandExceptArgBreak(OptionError,\"NoSuchImage\",option,arg1);\n+                 {\n+                   insert_image=DestroyImage(insert_image);\n+                   CLIWandExceptArgBreak(OptionError,\"NoSuchImage\",option,arg1);\n+                 }\n               InsertImageInList(&index_image,insert_image);\n             }\n           _images=GetFirstImageInList(index_image);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-2634","CWE_ID":"399","category":"security","commit_id":"29cd8ae0e1a39e239a3a7b67da1986add1199fc0","commit_message":"From 29cd8ae0e1a39e239a3a7b67da1986add1199fc0 Mon Sep 17 00:00:00 2001\nFrom: Mathias Krause <minipli@googlemail.com>\nDate: Sat, 9 Mar 2013 05:52:21 +0000\nSubject: dcbnl: fix various netlink info leaks\n\nThe dcb netlink interface leaks stack memory in various places:\n* perm_addr[] buffer is only filled at max with 12 of the 32 bytes but\n  copied completely,\n* no in-kernel driver fills all fields of an IEEE 802.1Qaz subcommand,\n  so we're leaking up to 58 bytes for ieee_ets structs, up to 136 bytes\n  for ieee_pfc structs, etc.,\n* the same is true for CEE -- no in-kernel driver fills the whole\n  struct,\n\nPrevent all of the above stack info leaks by properly initializing the\nbuffers\/structures involved.\n\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/dcb\/dcbnl.c | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\n","diff_code":"diff --git a\/net\/dcb\/dcbnl.c b\/net\/dcb\/dcbnl.c\nindex 1b588e23cf80..21291f1abcd6 100644\n--- a\/net\/dcb\/dcbnl.c\n+++ b\/net\/dcb\/dcbnl.c\n@@ -284,6 +284,7 @@ static int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlmsghdr *nlh,\n \tif (!netdev->dcbnl_ops->getpermhwaddr)\n \t\treturn -EOPNOTSUPP;\n \n+\tmemset(perm_addr, 0, sizeof(perm_addr));\n \tnetdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);\n \n \treturn nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);\n@@ -1042,6 +1043,7 @@ static int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)\n \n \tif (ops->ieee_getets) {\n \t\tstruct ieee_ets ets;\n+\t\tmemset(&ets, 0, sizeof(ets));\n \t\terr = ops->ieee_getets(netdev, &ets);\n \t\tif (!err &&\n \t\t    nla_put(skb, DCB_ATTR_IEEE_ETS, sizeof(ets), &ets))\n@@ -1050,6 +1052,7 @@ static int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)\n \n \tif (ops->ieee_getmaxrate) {\n \t\tstruct ieee_maxrate maxrate;\n+\t\tmemset(&maxrate, 0, sizeof(maxrate));\n \t\terr = ops->ieee_getmaxrate(netdev, &maxrate);\n \t\tif (!err) {\n \t\t\terr = nla_put(skb, DCB_ATTR_IEEE_MAXRATE,\n@@ -1061,6 +1064,7 @@ static int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)\n \n \tif (ops->ieee_getpfc) {\n \t\tstruct ieee_pfc pfc;\n+\t\tmemset(&pfc, 0, sizeof(pfc));\n \t\terr = ops->ieee_getpfc(netdev, &pfc);\n \t\tif (!err &&\n \t\t    nla_put(skb, DCB_ATTR_IEEE_PFC, sizeof(pfc), &pfc))\n@@ -1094,6 +1098,7 @@ static int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)\n \t\/* get peer info if available *\/\n \tif (ops->ieee_peer_getets) {\n \t\tstruct ieee_ets ets;\n+\t\tmemset(&ets, 0, sizeof(ets));\n \t\terr = ops->ieee_peer_getets(netdev, &ets);\n \t\tif (!err &&\n \t\t    nla_put(skb, DCB_ATTR_IEEE_PEER_ETS, sizeof(ets), &ets))\n@@ -1102,6 +1107,7 @@ static int dcbnl_ieee_fill(struct sk_buff *skb, struct net_device *netdev)\n \n \tif (ops->ieee_peer_getpfc) {\n \t\tstruct ieee_pfc pfc;\n+\t\tmemset(&pfc, 0, sizeof(pfc));\n \t\terr = ops->ieee_peer_getpfc(netdev, &pfc);\n \t\tif (!err &&\n \t\t    nla_put(skb, DCB_ATTR_IEEE_PEER_PFC, sizeof(pfc), &pfc))\n@@ -1280,6 +1286,7 @@ static int dcbnl_cee_fill(struct sk_buff *skb, struct net_device *netdev)\n \t\/* peer info if available *\/\n \tif (ops->cee_peer_getpg) {\n \t\tstruct cee_pg pg;\n+\t\tmemset(&pg, 0, sizeof(pg));\n \t\terr = ops->cee_peer_getpg(netdev, &pg);\n \t\tif (!err &&\n \t\t    nla_put(skb, DCB_ATTR_CEE_PEER_PG, sizeof(pg), &pg))\n@@ -1288,6 +1295,7 @@ static int dcbnl_cee_fill(struct sk_buff *skb, struct net_device *netdev)\n \n \tif (ops->cee_peer_getpfc) {\n \t\tstruct cee_pfc pfc;\n+\t\tmemset(&pfc, 0, sizeof(pfc));\n \t\terr = ops->cee_peer_getpfc(netdev, &pfc);\n \t\tif (!err &&\n \t\t    nla_put(skb, DCB_ATTR_CEE_PEER_PFC, sizeof(pfc), &pfc))\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5973","CWE_ID":"399","category":"security","commit_id":"f89b60f6e5fee3923bedf80e82b4e5efc1bb156b","commit_message":"From f89b60f6e5fee3923bedf80e82b4e5efc1bb156b Mon Sep 17 00:00:00 2001\nFrom: Gerd Hoffmann <kraxel@redhat.com>\nDate: Mon, 6 Feb 2017 13:21:09 +0100\nSubject: [PATCH] xhci: apply limits to loops\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nLimits should be big enough that normal guest should not hit it.\nAdd a tracepoint to log them, just in case.  Also, while being\nat it, log the existing link trb limit too.\n\nReported-by: \u00e6\u009d\u008e\u00e5\u00bc\u00ba <liqiang6-s@360.cn>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nMessage-id: 1486383669-6421-1-git-send-email-kraxel@redhat.com\n---\n hw\/usb\/hcd-xhci.c   | 15 ++++++++++++++-\n hw\/usb\/trace-events |  1 +\n 2 files changed, 15 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/usb\/hcd-xhci.c b\/hw\/usb\/hcd-xhci.c\nindex 54b3901..f3f9579 100644\n--- a\/hw\/usb\/hcd-xhci.c\n+++ b\/hw\/usb\/hcd-xhci.c\n@@ -54,6 +54,8 @@\n #define ER_FULL_HACK\n \n #define TRB_LINK_LIMIT  4\n+#define COMMAND_LIMIT   256\n+#define TRANSFER_LIMIT  256\n \n #define LEN_CAP         0x40\n #define LEN_OPER        (0x400 + 0x10 * MAXPORTS)\n@@ -1032,6 +1034,7 @@ static TRBType xhci_ring_fetch(XHCIState *xhci, XHCIRing *ring, XHCITRB *trb,\n             return type;\n         } else {\n             if (++link_cnt > TRB_LINK_LIMIT) {\n+                trace_usb_xhci_enforced_limit(\"trb-link\");\n                 return 0;\n             }\n             ring->dequeue = xhci_mask64(trb->parameter);\n@@ -2150,6 +2153,7 @@ static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n     XHCIRing *ring;\n     USBEndpoint *ep = NULL;\n     uint64_t mfindex;\n+    unsigned int count = 0;\n     int length;\n     int i;\n \n@@ -2262,6 +2266,10 @@ static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n             epctx->retry = xfer;\n             break;\n         }\n+        if (count++ > TRANSFER_LIMIT) {\n+            trace_usb_xhci_enforced_limit(\"transfers\");\n+            break;\n+        }\n     }\n     epctx->kick_active--;\n \n@@ -2734,7 +2742,7 @@ static void xhci_process_commands(XHCIState *xhci)\n     TRBType type;\n     XHCIEvent event = {ER_COMMAND_COMPLETE, CC_SUCCESS};\n     dma_addr_t addr;\n-    unsigned int i, slotid = 0;\n+    unsigned int i, slotid = 0, count = 0;\n \n     DPRINTF(\"xhci_process_commands()\\n\");\n     if (!xhci_running(xhci)) {\n@@ -2848,6 +2856,11 @@ static void xhci_process_commands(XHCIState *xhci)\n         }\n         event.slotid = slotid;\n         xhci_event(xhci, &event, 0);\n+\n+        if (count++ > COMMAND_LIMIT) {\n+            trace_usb_xhci_enforced_limit(\"commands\");\n+            return;\n+        }\n     }\n }\n \ndiff --git a\/hw\/usb\/trace-events b\/hw\/usb\/trace-events\nindex fdd1d29..0c323d4 100644\n--- a\/hw\/usb\/trace-events\n+++ b\/hw\/usb\/trace-events\n@@ -174,6 +174,7 @@ usb_xhci_xfer_retry(void *xfer) \"%p\"\n usb_xhci_xfer_success(void *xfer, uint32_t bytes) \"%p: len %d\"\n usb_xhci_xfer_error(void *xfer, uint32_t ret) \"%p: ret %d\"\n usb_xhci_unimplemented(const char *item, int nr) \"%s (0x%x)\"\n+usb_xhci_enforced_limit(const char *item) \"%s\"\n \n # hw\/usb\/desc.c\n usb_desc_device(int addr, int len, int ret) \"dev %d query device, len %d, ret %d\"\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8785","CWE_ID":"399","category":"security","commit_id":"3ca8138f014a913f98e6ef40e939868e1e9ea876","commit_message":"From 3ca8138f014a913f98e6ef40e939868e1e9ea876 Mon Sep 17 00:00:00 2001\nFrom: Roman Gushchin <klamm@yandex-team.ru>\nDate: Mon, 12 Oct 2015 16:33:44 +0300\nSubject: [PATCH] fuse: break infinite loop in fuse_fill_write_pages()\n\nI got a report about unkillable task eating CPU. Further\ninvestigation shows, that the problem is in the fuse_fill_write_pages()\nfunction. If iov's first segment has zero length, we get an infinite\nloop, because we never reach iov_iter_advance() call.\n\nFix this by calling iov_iter_advance() before repeating an attempt to\ncopy data from userspace.\n\nA similar problem is described in 124d3b7041f (\"fix writev regression:\npan hanging unkillable and un-straceable\"). If zero-length segmend\nis followed by segment with invalid address,\niov_iter_fault_in_readable() checks only first segment (zero-length),\niov_iter_copy_from_user_atomic() skips it, fails at second and\nreturns zero -> goto again without skipping zero-length segment.\n\nPatch calls iov_iter_advance() before goto again: we'll skip zero-length\nsegment at second iteraction and iov_iter_fault_in_readable() will detect\ninvalid address.\n\nSpecial thanks to Konstantin Khlebnikov, who helped a lot with the commit\ndescription.\n\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Maxim Patlasov <mpatlasov@parallels.com>\nCc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\nSigned-off-by: Roman Gushchin <klamm@yandex-team.ru>\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nFixes: ea9b9907b82a (\"fuse: implement perform_write\")\nCc: <stable@vger.kernel.org>\n---\n fs\/fuse\/file.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/fuse\/file.c b\/fs\/fuse\/file.c\nindex f523f2f04c196..195476a24148b 100644\n--- a\/fs\/fuse\/file.c\n+++ b\/fs\/fuse\/file.c\n@@ -1049,6 +1049,7 @@ static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n \t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n \t\tflush_dcache_page(page);\n \n+\t\tiov_iter_advance(ii, tmp);\n \t\tif (!tmp) {\n \t\t\tunlock_page(page);\n \t\t\tpage_cache_release(page);\n@@ -1061,7 +1062,6 @@ static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n \t\treq->page_descs[req->num_pages].length = tmp;\n \t\treq->num_pages++;\n \n-\t\tiov_iter_advance(ii, tmp);\n \t\tcount += tmp;\n \t\tpos += tmp;\n \t\toffset += tmp;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-8481","CWE_ID":"399","category":"security","commit_id":"a430c9166312e1aa3d80bce32374233bdbfeba32","commit_message":"From a430c9166312e1aa3d80bce32374233bdbfeba32 Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Thu, 23 Oct 2014 14:54:14 +0200\nSubject: [PATCH] KVM: emulate: avoid accessing NULL ctxt->memopp\n\nA failure to decode the instruction can cause a NULL pointer access.\nThis is fixed simply by moving the \"done\" label as close as possible\nto the return.\n\nThis fixes CVE-2014-8481.\n\nReported-by: Andy Lutomirski <luto@amacapital.net>\nCc: stable@vger.kernel.org\nFixes: 41061cdb98a0bec464278b4db8e894a3121671f5\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/emulate.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/emulate.c b\/arch\/x86\/kvm\/emulate.c\nindex 02c8ea804aaf5..eb3b1c46f995d 100644\n--- a\/arch\/x86\/kvm\/emulate.c\n+++ b\/arch\/x86\/kvm\/emulate.c\n@@ -4580,10 +4580,10 @@ int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n \t\/* Decode and fetch the destination operand: register or memory. *\/\n \trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n \n-done:\n \tif (ctxt->rip_relative)\n \t\tctxt->memopp->addr.mem.ea += ctxt->_eip;\n \n+done:\n \treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n }\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-7283","CWE_ID":"399","category":"security","commit_id":"c88547a8119e3b581318ab65e9b72f27f23e641d","commit_message":"From c88547a8119e3b581318ab65e9b72f27f23e641d Mon Sep 17 00:00:00 2001\nFrom: Mark Tinguely <tinguely@sgi.com>\nDate: Fri, 4 Apr 2014 07:10:49 +1100\nSubject: xfs: fix directory hash ordering bug\n\nCommit f5ea1100 (\"xfs: add CRCs to dir2\/da node blocks\") introduced\nin 3.10 incorrectly converted the btree hash index array pointer in\nxfs_da3_fixhashpath(). It resulted in the the current hash always\nbeing compared against the first entry in the btree rather than the\ncurrent block index into the btree block's hash entry array. As a\nresult, it was comparing the wrong hashes, and so could misorder the\nentries in the btree.\n\nFor most cases, this doesn't cause any problems as it requires hash\ncollisions to expose the ordering problem. However, when there are\nhash collisions within a directory there is a very good probability\nthat the entries will be ordered incorrectly and that actually\nmatters when duplicate hashes are placed into or removed from the\nbtree block hash entry array.\n\nThis bug results in an on-disk directory corruption and that results\nin directory verifier functions throwing corruption warnings into\nthe logs. While no data or directory entries are lost, access to\nthem may be compromised, and attempts to remove entries from a\ndirectory that has suffered from this corruption may result in a\nfilesystem shutdown.  xfs_repair will fix the directory hash\nordering without data loss occuring.\n\n[dchinner: wrote useful a commit message]\n\ncc: <stable@vger.kernel.org>\nReported-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: Mark Tinguely <tinguely@sgi.com>\nReviewed-by: Ben Myers <bpm@sgi.com>\nSigned-off-by: Dave Chinner <david@fromorbit.com>\n---\n fs\/xfs\/xfs_da_btree.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/xfs\/xfs_da_btree.c b\/fs\/xfs\/xfs_da_btree.c\nindex 796272a2e129..e69d57be866b 100644\n--- a\/fs\/xfs\/xfs_da_btree.c\n+++ b\/fs\/xfs\/xfs_da_btree.c\n@@ -1295,7 +1295,7 @@ xfs_da3_fixhashpath(\n \t\tnode = blk->bp->b_addr;\n \t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n \t\tbtree = dp->d_ops->node_tree_p(node);\n-\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n+\t\tif (be32_to_cpu(btree[blk->index].hashval) == lasthash)\n \t\t\tbreak;\n \t\tblk->hashval = lasthash;\n \t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-3506","CWE_ID":"399","category":"security","commit_id":"1250f12613b61758675848f6600ebd914ccd7636","commit_message":"From 1250f12613b61758675848f6600ebd914ccd7636 Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Fri, 6 Jun 2014 14:25:52 -0700\nSubject: [PATCH] Fix DTLS handshake message size checks.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nIn |dtls1_reassemble_fragment|, the value of\n|msg_hdr->frag_off+frag_len| was being checked against the maximum\nhandshake message size, but then |msg_len| bytes were allocated for the\nfragment buffer. This means that so long as the fragment was within the\nallowed size, the pending handshake message could consume 16MB + 2MB\n(for the reassembly bitmap). Approx 10 outstanding handshake messages\nare allowed, meaning that an attacker could consume ~180MB per DTLS\nconnection.\n\nIn the non-fragmented path (in |dtls1_process_out_of_seq_message|), no\ncheck was applied.\n\nFixes CVE-2014-3506\n\nWholly based on patch by Adam Langley with one minor amendment.\n\nReviewed-by: Emilia K\u00c3\u00a4sper <emilia@openssl.org>\n---\n ssl\/d1_both.c | 29 ++++++++++++++++-------------\n 1 file changed, 16 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/ssl\/d1_both.c b\/ssl\/d1_both.c\nindex d98ae9392f..c5beea8824 100644\n--- a\/ssl\/d1_both.c\n+++ b\/ssl\/d1_both.c\n@@ -592,6 +592,16 @@ dtls1_retrieve_buffered_fragment(SSL *s, long max, int *ok)\n \t\treturn 0;\n \t}\n \n+\/* dtls1_max_handshake_message_len returns the maximum number of bytes\n+ * permitted in a DTLS handshake message for |s|. The minimum is 16KB, but may\n+ * be greater if the maximum certificate list size requires it. *\/\n+static unsigned long dtls1_max_handshake_message_len(const SSL *s)\n+\t{\n+\tunsigned long max_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n+\tif (max_len < (unsigned long)s->max_cert_list)\n+\t\treturn s->max_cert_list;\n+\treturn max_len;\n+\t}\n \n static int\n dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n@@ -600,20 +610,10 @@ dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n \tpitem *item = NULL;\n \tint i = -1, is_complete;\n \tunsigned char seq64be[8];\n-\tunsigned long frag_len = msg_hdr->frag_len, max_len;\n-\n-\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n-\t\tgoto err;\n-\n-\t\/* Determine maximum allowed message size. Depends on (user set)\n-\t * maximum certificate length, but 16k is minimum.\n-\t *\/\n-\tif (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH < s->max_cert_list)\n-\t\tmax_len = s->max_cert_list;\n-\telse\n-\t\tmax_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n+\tunsigned long frag_len = msg_hdr->frag_len;\n \n-\tif ((msg_hdr->frag_off+frag_len) > max_len)\n+\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len ||\n+\t    msg_hdr->msg_len > dtls1_max_handshake_message_len(s))\n \t\tgoto err;\n \n \t\/* Try to find item in queue *\/\n@@ -754,6 +754,9 @@ dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n \t\tif (frag_len && frag_len < msg_hdr->msg_len)\n \t\t\treturn dtls1_reassemble_fragment(s, msg_hdr, ok);\n \n+\t\tif (frag_len > dtls1_max_handshake_message_len(s))\n+\t\t\tgoto err;\n+\n \t\tfrag = dtls1_hm_fragment_new(frag_len, 0);\n \t\tif ( frag == NULL)\n \t\t\tgoto err;\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12990","CWE_ID":"399","category":"security","commit_id":"c2ef693866beae071a24b45c49f9674af1df4028","commit_message":"From c2ef693866beae071a24b45c49f9674af1df4028 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Mon, 6 Feb 2017 14:33:50 -0800\nSubject: [PATCH] CVE-2017-12990\/Fix printing of ISAKMPv1 Notification payload\n data.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe closest thing to a specification for the contents of the payload\ndata is draft-ietf-ipsec-notifymsg-04, and nothing in there says that it\nis ever a complete ISAKMP message, so don't dissect types we don't have\nspecific code for as a complete ISAKMP message.\n\nWhile we're at it, fix a comment, and clean up printing of V1 Nonce,\nV2 Authentication payloads, and v2 Notice payloads.\n\nThis fixes an infinite loop discovered by Forcepoint's security\nresearchers Otto Airamo & Antti Levom\u00e4ki.\n\nAdd a test using the capture file supplied by the reporter(s).\n---\n print-isakmp.c               | 112 +++++++++++++++++++----------------\n tests\/TESTLIST               |   1 +\n tests\/isakmp-no-none-np.out  |  78 ++++++++++++++++++++++++\n tests\/isakmp-no-none-np.pcap | Bin 0 -> 2344 bytes\n 4 files changed, 139 insertions(+), 52 deletions(-)\n create mode 100644 tests\/isakmp-no-none-np.out\n create mode 100644 tests\/isakmp-no-none-np.pcap\n\n","diff_code":"diff --git a\/print-isakmp.c b\/print-isakmp.c\nindex 2fa15b861..9de9b75d2 100644\n--- a\/print-isakmp.c\n+++ b\/print-isakmp.c\n@@ -428,7 +428,7 @@ struct notify_messages {\n \tchar     *msg;\n };\n \n-\/* 3.8 Notification Payload *\/\n+\/* 3.8 Authentication Payload *\/\n struct ikev2_auth {\n \tstruct isakmp_gen h;\n \tuint8_t  auth_method;  \/* Protocol-ID *\/\n@@ -1590,15 +1590,20 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n \n \tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n-\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n-\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\" \"));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n-\t\t\tgoto trunc;\n-\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\" \"));\n-\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n-\t\t\tgoto trunc;\n+\t\/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t *\/\n+\tND_PRINT((ndo,\" n len=%u\", ntohs(e.len) - 4));\n+\tif (ntohs(e.len) > 4) {\n+\t\tif (ndo->ndo_vflag > 2) {\n+\t\t\tND_PRINT((ndo, \" \"));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n+\t\t\t\tgoto trunc;\n+\t\t} else if (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \" \"));\n+\t\t\tif (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \treturn (const u_char *)ext + ntohs(e.len);\n trunc:\n@@ -1609,8 +1614,8 @@ ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n static const u_char *\n ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t      const struct isakmp_gen *ext, u_int item_len,\n-\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,\n-\t      uint32_t proto0 _U_, int depth)\n+\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n+\t      uint32_t proto0 _U_, int depth _U_)\n {\n \tconst struct ikev1_pl_n *p;\n \tstruct ikev1_pl_n n;\n@@ -1712,35 +1717,41 @@ ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tep2 = (const u_char *)p + item_len;\n \n \tif (cp < ep) {\n-\t\tND_PRINT((ndo,\" orig=(\"));\n \t\tswitch (ntohs(n.type)) {\n \t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n \t\t    {\n \t\t\tconst struct attrmap *map = oakley_t_map;\n \t\t\tsize_t nmap = sizeof(oakley_t_map)\/sizeof(oakley_t_map[0]);\n+\t\t\tND_PRINT((ndo,\" attrs=(\"));\n \t\t\twhile (cp < ep && cp < ep2) {\n \t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n \t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n \t\t\t}\n+\t\t\tND_PRINT((ndo,\")\"));\n \t\t\tbreak;\n \t\t    }\n \t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n+\t\t\tND_PRINT((ndo,\" status=(\"));\n \t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n \t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n-\t\t\tbreak;\n-\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:\n-\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,\n-\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,\n-\t\t\t\t\t    depth) == NULL)\n-\t\t\t\treturn NULL;\n+\t\t\tND_PRINT((ndo,\")\"));\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\t\/* NULL is dummy *\/\n-\t\t\tisakmp_print(ndo, cp,\n-\t\t\t\t     item_len - sizeof(*p) - n.spi_size,\n-\t\t\t\t     NULL);\n+\t\t\t\/*\n+\t\t\t * XXX - fill in more types here; see, for example,\n+\t\t\t * draft-ietf-ipsec-notifymsg-04.\n+\t\t\t *\/\n+\t\t\tif (ndo->ndo_vflag > 3) {\n+\t\t\t\tND_PRINT((ndo,\" data=(\"));\n+\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t\tND_PRINT((ndo,\")\"));\n+\t\t\t} else {\n+\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t}\n+\t\t\tbreak;\n \t\t}\n-\t\tND_PRINT((ndo,\")\"));\n \t}\n \treturn (const u_char *)ext + item_len;\n trunc:\n@@ -2264,16 +2275,21 @@ ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n \tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n \tlen = ntohs(a.h.len);\n \n-\tND_PRINT((ndo,\" len=%d method=%s\", len-4,\n+\t\/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t *\/\n+\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n \t\t  STR_OR_ID(a.auth_method, v2_auth)));\n-\n-\tif (1 < ndo->ndo_vflag && 4 < len) {\n-\t\tND_PRINT((ndo,\" authdata=(\"));\n-\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n-\t\t\tgoto trunc;\n-\t\tND_PRINT((ndo,\") \"));\n-\t} else if(ndo->ndo_vflag && 4 < len) {\n-\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n+\tif (len > 4) {\n+\t\tif (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \" authdata=(\"));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n+\t\t\t\tgoto trunc;\n+\t\t\tND_PRINT((ndo, \") \"));\n+\t\t} else if (ndo->ndo_vflag) {\n+\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + len;\n@@ -2322,7 +2338,7 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tconst struct ikev2_n *p;\n \tstruct ikev2_n n;\n \tconst u_char *cp;\n-\tu_char showspi, showdata, showsomedata;\n+\tu_char showspi, showsomedata;\n \tconst char *notify_name;\n \tuint32_t type;\n \n@@ -2332,7 +2348,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n \n \tshowspi = 1;\n-\tshowdata = 0;\n \tshowsomedata=0;\n \tnotify_name=NULL;\n \n@@ -2446,7 +2461,6 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t\tnotify_name = \"cookie\";\n \t\tshowspi = 1;\n \t\tshowsomedata= 1;\n-\t\tshowdata= 0;\n \t\tbreak;\n \n \tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n@@ -2499,19 +2513,17 @@ ikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n \n \tcp = (const u_char *)(p + 1) + n.spi_size;\n \n-\tif(3 < ndo->ndo_vflag) {\n-\t\tshowdata = 1;\n-\t}\n-\n-\tif ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {\n-\t\tND_PRINT((ndo,\" data=(\"));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n-\t\t\tgoto trunc;\n-\n-\t\tND_PRINT((ndo,\")\"));\n+\tif (cp < ep) {\n+\t\tif (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {\n+\t\t\tND_PRINT((ndo,\" data=(\"));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\tgoto trunc;\n \n-\t} else if(showsomedata && cp < ep) {\n-\t\tif(!ike_show_somedata(ndo, cp, ep)) goto trunc;\n+\t\t\tND_PRINT((ndo,\")\"));\n+\t\t} else if (showsomedata) {\n+\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + item_len;\n@@ -3091,7 +3103,3 @@ isakmp_rfc3948_print(netdissect_options *ndo,\n  * c-basic-offset: 8\n  * End:\n  *\/\n-\n-\n-\n-\ndiff --git a\/tests\/TESTLIST b\/tests\/TESTLIST\nindex 1e1624013..ed5b82aa3 100644\n--- a\/tests\/TESTLIST\n+++ b\/tests\/TESTLIST\n@@ -465,6 +465,7 @@ tok2str-oobr-2\t\ttok2str-oobr-2.pcap\t\ttok2str-oobr-2.out\t-vvv -e\n eigrp-tlv-oobr\t\teigrp-tlv-oobr.pcap\t\teigrp-tlv-oobr.out\t-vvv -e\n zephyr-oobr\t\tzephyr-oobr.pcap\t\tzephyr-oobr.out\t\t-vvv -e\n bgp-as-path-oobr\tbgp-as-path-oobr.pcap\t\tbgp-as-path-oobr.out\t-vvv -e\n+isakmp-no-none-np\tisakmp-no-none-np.pcap\t\tisakmp-no-none-np.out\t-vvv -e\n \n # RTP tests\n # fuzzed pcap\ndiff --git a\/tests\/isakmp-no-none-np.out b\/tests\/isakmp-no-none-np.out\nnew file mode 100644\nindex 000000000..eb91c804a\n--- \/dev\/null\n+++ b\/tests\/isakmp-no-none-np.out\n@@ -0,0 +1,78 @@\n+00:0c:29:86:c8:36 > 00:1a:4b:6a:ce:fe, ethertype IPv4 (0x0800), length 2228: (tos 0x0, ttl 128, id 28793, offset 0, flags [none], proto UDP (17), length 2214)\n+    192.168.1.25.500 > 192.168.1.10.500: [udp sum ok] isakmp 1.0 msgid 5f724dc6 cookie 0000000000000000->0000000000000000: phase 2\/others ? inf:\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=000000000b1005005f724dc600000054 data=(0b00001c000000010110...0100000700000000000000000000000000000000))\n+    (n: doi=ipsec proto=isakmp type=INVALID-MAJOR-VERSION spi=0000000000000000000000000010ba00 data=(00ff1d00020082001101...0100000700000000000000000000000000000000)) [|n] (len mismatch: isakmp 84\/ip 2186)\ndiff --git a\/tests\/isakmp-no-none-np.pcap b\/tests\/isakmp-no-none-np.pcap\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..fd388d617e4f2937fdb1214bdcce59c8c159a90c\nGIT binary patch\nliteral 2344\nzcmd<$<>fMAU|{gI(UxKa(*L1=g@KpBH6^noIk7;&NY6me2q*^vAhjTM3Q+q0e+C9l\nzpa>g~4+0863}Rp501`-G3y=@O3{u`%=l(J9Xttd&<6v-Q;8<2r$-vMcXcu*01*0So\nzb1{Bl{K7Gb{}YmCFq2z=l_9>!_ZW~9!p*=S1Ed)l1sGUClB05?;WC;gM)SjHSuk2g\nr0@J`~{V-ZL5^NWM$_g+L*ad9%$TBc7G%*M=0^2t1FbNn9YRdosru*ln\n\nliteral 0\nHcmV?d00001\n\n","owner":"the-tcpdump-group","repo":"tcpdump","source":"cve"},{"CVE_ID":"CVE-2010-3858","CWE_ID":"399","category":"security","commit_id":"1b528181b2ffa14721fb28ad1bd539fe1732c583","commit_message":"From 1b528181b2ffa14721fb28ad1bd539fe1732c583 Mon Sep 17 00:00:00 2001\nFrom: Roland McGrath <roland@redhat.com>\nDate: Tue, 7 Sep 2010 19:35:49 -0700\nSubject: setup_arg_pages: diagnose excessive argument size\n\nThe CONFIG_STACK_GROWSDOWN variant of setup_arg_pages() does not\ncheck the size of the argument\/environment area on the stack.\nWhen it is unworkably large, shift_arg_pages() hits its BUG_ON.\nThis is exploitable with a very large RLIMIT_STACK limit, to\ncreate a crash pretty easily.\n\nCheck that the initial stack is not too large to make it possible\nto map in any executable.  We're not checking that the actual\nexecutable (or intepreter, for binfmt_elf) will fit.  So those\nmappings might clobber part of the initial stack mapping.  But\nthat is just userland lossage that userland made happen, not a\nkernel problem.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nReviewed-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/exec.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/fs\/exec.c b\/fs\/exec.c\nindex 2d9455282744..1b63237fc6dc 100644\n--- a\/fs\/exec.c\n+++ b\/fs\/exec.c\n@@ -594,6 +594,11 @@ int setup_arg_pages(struct linux_binprm *bprm,\n #else\n \tstack_top = arch_align_stack(stack_top);\n \tstack_top = PAGE_ALIGN(stack_top);\n+\n+\tif (unlikely(stack_top < mmap_min_addr) ||\n+\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n+\t\treturn -ENOMEM;\n+\n \tstack_shift = vma->vm_end - stack_top;\n \n \tbprm->p -= stack_shift;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5547","CWE_ID":"399","category":"security","commit_id":"6d104af38b570d37aa32a5803b04c354f8ed513d","commit_message":"From 6d104af38b570d37aa32a5803b04c354f8ed513d Mon Sep 17 00:00:00 2001\nFrom: Johan Hovold <johan@kernel.org>\nDate: Thu, 12 Jan 2017 18:17:42 +0100\nSubject: HID: corsair: fix DMA buffers on stack\n\nNot all platforms support DMA to the stack, and specifically since v4.9\nthis is no longer supported on x86 with VMAP_STACK either.\n\nNote that the macro-mode buffer was larger than necessary.\n\nFixes: 6f78193ee9ea (\"HID: corsair: Add Corsair Vengeance K90 driver\")\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Johan Hovold <johan@kernel.org>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>\n---\n drivers\/hid\/hid-corsair.c | 54 ++++++++++++++++++++++++++++++++++++-----------\n 1 file changed, 42 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/hid\/hid-corsair.c b\/drivers\/hid\/hid-corsair.c\nindex 717704e9ae07..5971907a23b1 100644\n--- a\/drivers\/hid\/hid-corsair.c\n+++ b\/drivers\/hid\/hid-corsair.c\n@@ -148,7 +148,11 @@ static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n \tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n \tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n \tint brightness;\n-\tchar data[8];\n+\tchar *data;\n+\n+\tdata = kmalloc(8, GFP_KERNEL);\n+\tif (!data)\n+\t\treturn -ENOMEM;\n \n \tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n \t\t\t      K90_REQUEST_STATUS,\n@@ -158,16 +162,22 @@ static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n \tif (ret < 0) {\n \t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n \t\t\t ret);\n-\t\treturn -EIO;\n+\t\tret = -EIO;\n+\t\tgoto out;\n \t}\n \tbrightness = data[4];\n \tif (brightness < 0 || brightness > 3) {\n \t\tdev_warn(dev,\n \t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n \t\t\t data[4]);\n-\t\treturn -EIO;\n+\t\tret = -EIO;\n+\t\tgoto out;\n \t}\n-\treturn brightness;\n+\tret = brightness;\n+out:\n+\tkfree(data);\n+\n+\treturn ret;\n }\n \n static enum led_brightness k90_record_led_get(struct led_classdev *led_cdev)\n@@ -253,7 +263,11 @@ static ssize_t k90_show_macro_mode(struct device *dev,\n \tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n \tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n \tconst char *macro_mode;\n-\tchar data[8];\n+\tchar *data;\n+\n+\tdata = kmalloc(2, GFP_KERNEL);\n+\tif (!data)\n+\t\treturn -ENOMEM;\n \n \tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n \t\t\t      K90_REQUEST_GET_MODE,\n@@ -263,7 +277,8 @@ static ssize_t k90_show_macro_mode(struct device *dev,\n \tif (ret < 0) {\n \t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n \t\t\t ret);\n-\t\treturn -EIO;\n+\t\tret = -EIO;\n+\t\tgoto out;\n \t}\n \n \tswitch (data[0]) {\n@@ -277,10 +292,15 @@ static ssize_t k90_show_macro_mode(struct device *dev,\n \tdefault:\n \t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n \t\t\t data[0]);\n-\t\treturn -EIO;\n+\t\tret = -EIO;\n+\t\tgoto out;\n \t}\n \n-\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n+\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n+out:\n+\tkfree(data);\n+\n+\treturn ret;\n }\n \n static ssize_t k90_store_macro_mode(struct device *dev,\n@@ -320,7 +340,11 @@ static ssize_t k90_show_current_profile(struct device *dev,\n \tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n \tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n \tint current_profile;\n-\tchar data[8];\n+\tchar *data;\n+\n+\tdata = kmalloc(8, GFP_KERNEL);\n+\tif (!data)\n+\t\treturn -ENOMEM;\n \n \tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n \t\t\t      K90_REQUEST_STATUS,\n@@ -330,16 +354,22 @@ static ssize_t k90_show_current_profile(struct device *dev,\n \tif (ret < 0) {\n \t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n \t\t\t ret);\n-\t\treturn -EIO;\n+\t\tret = -EIO;\n+\t\tgoto out;\n \t}\n \tcurrent_profile = data[7];\n \tif (current_profile < 1 || current_profile > 3) {\n \t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n \t\t\t data[7]);\n-\t\treturn -EIO;\n+\t\tret = -EIO;\n+\t\tgoto out;\n \t}\n \n-\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n+\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n+out:\n+\tkfree(data);\n+\n+\treturn ret;\n }\n \n static ssize_t k90_store_current_profile(struct device *dev,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4169","CWE_ID":"399","category":"security","commit_id":"63bfd7384b119409685a17d5c58f0b56e5dc03da","commit_message":"From 63bfd7384b119409685a17d5c58f0b56e5dc03da Mon Sep 17 00:00:00 2001\nFrom: Pekka Enberg <penberg@kernel.org>\nDate: Mon, 8 Nov 2010 21:29:07 +0200\nSubject: perf_events: Fix perf_counter_mmap() hook in mprotect()\n\nAs pointed out by Linus, commit dab5855 (\"perf_counter: Add mmap event hooks to\nmprotect()\") is fundamentally wrong as mprotect_fixup() can free 'vma' due to\nmerging. Fix the problem by moving perf_event_mmap() hook to\nmprotect_fixup().\n\nNote: there's another successful return path from mprotect_fixup() if old\nflags equal to new flags. We don't, however, need to call\nperf_event_mmap() there because 'perf' already knows the VMA is\nexecutable.\n\nReported-by: Dave Jones <davej@redhat.com>\nAnalyzed-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nReviewed-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Pekka Enberg <penberg@kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/mprotect.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/mm\/mprotect.c b\/mm\/mprotect.c\nindex 2d1bf7cf8851..4c5133873097 100644\n--- a\/mm\/mprotect.c\n+++ b\/mm\/mprotect.c\n@@ -211,6 +211,7 @@ success:\n \tmmu_notifier_invalidate_range_end(mm, start, end);\n \tvm_stat_account(mm, oldflags, vma->vm_file, -nrpages);\n \tvm_stat_account(mm, newflags, vma->vm_file, nrpages);\n+\tperf_event_mmap(vma);\n \treturn 0;\n \n fail:\n@@ -299,7 +300,6 @@ SYSCALL_DEFINE3(mprotect, unsigned long, start, size_t, len,\n \t\terror = mprotect_fixup(vma, &prev, nstart, tmp, newflags);\n \t\tif (error)\n \t\t\tgoto out;\n-\t\tperf_event_mmap(vma);\n \t\tnstart = tmp;\n \n \t\tif (nstart < prev->vm_end)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-6301","CWE_ID":"399","category":"security","commit_id":"150dc7a2b483b8338a3e185c478b4b23ee884e71","commit_message":"From 150dc7a2b483b8338a3e185c478b4b23ee884e71 Mon Sep 17 00:00:00 2001\nFrom: Miroslav Lichvar <mlichvar@redhat.com>\nDate: Mon, 1 Aug 2016 20:24:24 +0200\nSubject: ntpd: respond only to client and symmetric active packets\n\nThe busybox NTP implementation doesn't check the NTP mode of packets\nreceived on the server port and responds to any packet with the right\nsize. This includes responses from another NTP server. An attacker can\nsend a packet with a spoofed source address in order to create an\ninfinite loop of responses between two busybox NTP servers. Adding\nmore packets to the loop increases the traffic between the servers\nuntil one of them has a fully loaded CPU and\/or network.\n\nSigned-off-by: Miroslav Lichvar <mlichvar@redhat.com>\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>\n---\n networking\/ntpd.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/networking\/ntpd.c b\/networking\/ntpd.c\nindex 130cef0af..8ca62cf1b 100644\n--- a\/networking\/ntpd.c\n+++ b\/networking\/ntpd.c\n@@ -2051,6 +2051,13 @@ recv_and_process_client_pkt(void \/*int fd*\/)\n \t\tgoto bail;\n \t}\n \n+\t\/* Respond only to client and symmetric active packets *\/\n+\tif ((msg.m_status & MODE_MASK) != MODE_CLIENT\n+\t && (msg.m_status & MODE_MASK) != MODE_SYM_ACT\n+\t) {\n+\t\tgoto bail;\n+\t}\n+\n \tquery_status = msg.m_status;\n \tquery_xmttime = msg.m_xmttime;\n \n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6214","CWE_ID":"399","category":"security","commit_id":"ccf7abb93af09ad0868ae9033d1ca8108bdaec82","commit_message":"From ccf7abb93af09ad0868ae9033d1ca8108bdaec82 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Fri, 3 Feb 2017 14:59:38 -0800\nSubject: [PATCH] tcp: avoid infinite loop in tcp_splice_read()\n\nSplicing from TCP socket is vulnerable when a packet with URG flag is\nreceived and stored into receive queue.\n\n__tcp_splice_read() returns 0, and sk_wait_data() immediately\nreturns since there is the problematic skb in queue.\n\nThis is a nice way to burn cpu (aka infinite loop) and trigger\nsoft lockups.\n\nAgain, this gem was found by syzkaller tool.\n\nFixes: 9c55e01c0cc8 (\"[TCP]: Splice receive support.\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Dmitry Vyukov  <dvyukov@google.com>\nCc: Willy Tarreau <w@1wt.eu>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/net\/ipv4\/tcp.c b\/net\/ipv4\/tcp.c\nindex 4a044964da667..0efb4c7f6704f 100644\n--- a\/net\/ipv4\/tcp.c\n+++ b\/net\/ipv4\/tcp.c\n@@ -770,6 +770,12 @@ ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n \t\t\t\tret = -EAGAIN;\n \t\t\t\tbreak;\n \t\t\t}\n+\t\t\t\/* if __tcp_splice_read() got nothing while we have\n+\t\t\t * an skb in receive queue, we do not want to loop.\n+\t\t\t * This might happen with URG data.\n+\t\t\t *\/\n+\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n+\t\t\t\tbreak;\n \t\t\tsk_wait_data(sk, &timeo, NULL);\n \t\t\tif (signal_pending(current)) {\n \t\t\t\tret = sock_intr_errno(timeo);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-13137","CWE_ID":"399","category":"security","commit_id":"7d11230060fa9c8f67e53c85224daf6648805c7b","commit_message":"From 7d11230060fa9c8f67e53c85224daf6648805c7b Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 18 Jun 2019 11:54:17 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1601\n\n---\n coders\/ps.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/coders\/ps.c b\/coders\/ps.c\nindex bcc20d9b2..4ffd7296e 100644\n--- a\/coders\/ps.c\n+++ b\/coders\/ps.c\n@@ -749,6 +749,7 @@ static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         {\n           (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"InvalidGeometry\",\"`%s'\",option);\n+          geometry=DestroyString(geometry);\n           image=DestroyImage(image);\n           return((Image *) NULL);\n         }\n","owner":"ImageMagick","repo":"ImageMagick6","source":"cve"},{"CVE_ID":"CVE-2011-4087","CWE_ID":"399","category":"security","commit_id":"f8e9881c2aef1e982e5abc25c046820cd0b7cf64","commit_message":"From f8e9881c2aef1e982e5abc25c046820cd0b7cf64 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <eric.dumazet@gmail.com>\nDate: Tue, 12 Apr 2011 13:39:14 -0700\nSubject: bridge: reset IPCB in br_parse_ip_options\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nCommit 462fb2af9788a82 (bridge : Sanitize skb before it enters the IP\nstack), missed one IPCB init before calling ip_options_compile()\n\nThanks to Scot Doyle for his tests and bug reports.\n\nReported-by: Scot Doyle <lkml@scotdoyle.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Hiroaki SHIMODA <shimoda.hiroaki@gmail.com>\nAcked-by: Bandan Das <bandan.das@stratus.com>\nAcked-by: Stephen Hemminger <shemminger@vyatta.com>\nCc: Jan L\u00fcbbe <jluebbe@debian.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/bridge\/br_netfilter.c | 6 ++----\n 1 file changed, 2 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/net\/bridge\/br_netfilter.c b\/net\/bridge\/br_netfilter.c\nindex 008ff6c4eecf..f3bc322c5891 100644\n--- a\/net\/bridge\/br_netfilter.c\n+++ b\/net\/bridge\/br_netfilter.c\n@@ -249,11 +249,9 @@ static int br_parse_ip_options(struct sk_buff *skb)\n \t\tgoto drop;\n \t}\n \n-\t\/* Zero out the CB buffer if no options present *\/\n-\tif (iph->ihl == 5) {\n-\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n+\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n+\tif (iph->ihl == 5)\n \t\treturn 0;\n-\t}\n \n \topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n \tif (ip_options_compile(dev_net(dev), opt, skb))\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-14057","CWE_ID":"399","category":"security","commit_id":"7f9ec5593e04827249e7aeb466da06a98a0d7329","commit_message":"From 7f9ec5593e04827249e7aeb466da06a98a0d7329 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?=E5=AD=99=E6=B5=A9=20and=20=E5=BC=A0=E6=B4=AA=E4=BA=AE=28?=\n =?UTF-8?q?=E6=9C=9B=E5=88=9D=29?= <tony.sh and wangchu.zhl@alibaba-inc.com>\nDate: Fri, 25 Aug 2017 12:37:25 +0200\nSubject: [PATCH] avformat\/asfdec: Fix DoS due to lack of eof check\n\nFixes: loop.asf\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/asfdec_f.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libavformat\/asfdec_f.c b\/libavformat\/asfdec_f.c\nindex be09a92bd1e..f3acbae2801 100644\n--- a\/libavformat\/asfdec_f.c\n+++ b\/libavformat\/asfdec_f.c\n@@ -749,13 +749,15 @@ static int asf_read_marker(AVFormatContext *s, int64_t size)\n     count = avio_rl32(pb);    \/\/ markers count\n     avio_rl16(pb);            \/\/ reserved 2 bytes\n     name_len = avio_rl16(pb); \/\/ name length\n-    for (i = 0; i < name_len; i++)\n-        avio_r8(pb); \/\/ skip the name\n+    avio_skip(pb, name_len);\n \n     for (i = 0; i < count; i++) {\n         int64_t pres_time;\n         int name_len;\n \n+        if (avio_feof(pb))\n+            return AVERROR_INVALIDDATA;\n+\n         avio_rl64(pb);             \/\/ offset, 8 bytes\n         pres_time = avio_rl64(pb); \/\/ presentation time\n         pres_time -= asf->hdr.preroll * 10000;\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-5667","CWE_ID":"399","category":"security","commit_id":"42922105beb14c2fc58185ea022b9f72fb5465e9","commit_message":"From 42922105beb14c2fc58185ea022b9f72fb5465e9 Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Tue, 7 Feb 2017 18:29:59 +0000\nSubject: [PATCH] sd: sdhci: check data length during dma_memory_read\n\nWhile doing multi block SDMA transfer in routine\n'sdhci_sdma_transfer_multi_blocks', the 's->fifo_buffer' starting\nindex 'begin' and data length 's->data_count' could end up to be same.\nThis could lead to an OOB access issue. Correct transfer data length\nto avoid it.\n\nCc: qemu-stable@nongnu.org\nReported-by: Jiang Xin <jiangxin1@huawei.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nReviewed-by: Peter Maydell <peter.maydell@linaro.org>\nMessage-id: 20170130064736.9236-1-ppandit@redhat.com\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>\n---\n hw\/sd\/sdhci.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/sd\/sdhci.c b\/hw\/sd\/sdhci.c\nindex 01fbf22..5bd5ab6 100644\n--- a\/hw\/sd\/sdhci.c\n+++ b\/hw\/sd\/sdhci.c\n@@ -536,7 +536,7 @@ static void sdhci_sdma_transfer_multi_blocks(SDHCIState *s)\n                 boundary_count -= block_size - begin;\n             }\n             dma_memory_read(&address_space_memory, s->sdmasysad,\n-                            &s->fifo_buffer[begin], s->data_count);\n+                            &s->fifo_buffer[begin], s->data_count - begin);\n             s->sdmasysad += s->data_count - begin;\n             if (s->data_count == block_size) {\n                 for (n = 0; n < block_size; n++) {\n-- \n1.8.3.1\n\n","owner":"qemu","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2012-0033","CWE_ID":"399","category":"security","commit_id":"11508aa72efab4fad0dbd8292b9614d9371b20a9","commit_message":"From 11508aa72efab4fad0dbd8292b9614d9371b20a9 Mon Sep 17 00:00:00 2001\nFrom: Alexey Sokolov <alexey@asokolov.org>\nDate: Sun, 1 Jan 2012 00:47:01 +0700\nSubject: [PATCH] Fix crash in bouncedcc module.\n\nIt happens when DCC RESUME is received.\nAffected ZNC versions: 0.200, 0.202.\n\nThanks to howeyc for reporting this and providing the patch.\n---\n modules\/bouncedcc.cpp | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/modules\/bouncedcc.cpp b\/modules\/bouncedcc.cpp\nindex c91ca37bd..d06ecf0e9 100644\n--- a\/modules\/bouncedcc.cpp\n+++ b\/modules\/bouncedcc.cpp\n@@ -238,7 +238,7 @@ class CBounceDCCMod : public CModule {\n \t\t\t\t\tCDCCBounce* pSock = (CDCCBounce*) *it;\n \n \t\t\t\t\tif (pSock->GetLocalPort() == uResumePort) {\n-\t\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pClient->GetNick() + \" :\\001DCC \" + sType + \" \" + sFile + \" \" + CString(pSock->GetUserPort()) + \" \" + sMessage.Token(4) + \"\\001\");\n+\t\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pUser->GetNick() + \" :\\001DCC \" + sType + \" \" + sFile + \" \" + CString(pSock->GetUserPort()) + \" \" + sMessage.Token(4) + \"\\001\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else if (sType.Equals(\"ACCEPT\")) {\n@@ -248,7 +248,7 @@ class CBounceDCCMod : public CModule {\n \t\t\t\t\tCDCCBounce* pSock = (CDCCBounce*) *it;\n \n \t\t\t\t\tif (pSock->GetUserPort() == sMessage.Token(3).ToUShort()) {\n-\t\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pClient->GetNick() + \" :\\001DCC \" + sType + \" \" + sFile + \" \" + CString(pSock->GetLocalPort()) + \" \" + sMessage.Token(4) + \"\\001\");\n+\t\t\t\t\t\tm_pUser->PutUser(\":\" + Nick.GetNickMask() + \" PRIVMSG \" + m_pUser->GetNick() + \" :\\001DCC \" + sType + \" \" + sFile + \" \" + CString(pSock->GetLocalPort()) + \" \" + sMessage.Token(4) + \"\\001\");\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n","owner":"znc","repo":"znc","source":"cve"},{"CVE_ID":"CVE-2016-9105","CWE_ID":"399","category":"security","commit_id":"4c1586787ff43c9acd18a56c12d720e3e6be9f7c","commit_message":"From 4c1586787ff43c9acd18a56c12d720e3e6be9f7c Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Mon, 17 Oct 2016 14:13:58 +0200\nSubject: [PATCH] 9pfs: fix memory leak in v9fs_link\n\nThe v9fs_link() function keeps a reference on the source fid object. This\ncauses a memory leak since the reference never goes down to 0. This patch\nfixes the issue.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nReviewed-by: Greg Kurz <groug@kaod.org>\n[groug, rephrased the changelog]\nSigned-off-by: Greg Kurz <groug@kaod.org>\n---\n hw\/9pfs\/9p.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/hw\/9pfs\/9p.c b\/hw\/9pfs\/9p.c\nindex 66135cf..d43a552 100644\n--- a\/hw\/9pfs\/9p.c\n+++ b\/hw\/9pfs\/9p.c\n@@ -2413,6 +2413,7 @@ static void coroutine_fn v9fs_link(void *opaque)\n     if (!err) {\n         err = offset;\n     }\n+    put_fid(pdu, oldfidp);\n out:\n     put_fid(pdu, dfidp);\n out_nofid:\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-3043","CWE_ID":"399","category":"security","commit_id":"5c58ceff103d8a654f24769bb1baaf84a841b0cc","commit_message":"From 5c58ceff103d8a654f24769bb1baaf84a841b0cc Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Tue, 25 Aug 2009 09:12:43 -0700\nSubject: tty: make sure to flush any pending work when halting the ldisc\n\nWhen I rewrote tty ldisc code to use proper reference counts (commits\n65b770468e98 and cbe9352fa08f) in order to avoid a race with hangup, the\ntest-program that Eric Biederman used to trigger the original problem\nseems to have exposed another long-standing bug: the hangup code did the\n'tty_ldisc_halt()' to stop any buffer flushing activity, but unlike the\nother call sites it never actually flushed any pending work.\n\nAs a result, if you get just the right timing, the pending work may be\njust about to execute (ie the timer has already triggered and thus\ncancel_delayed_work() was a no-op), when we then re-initialize the ldisc\nfrom under it.\n\nThat, in turn, results in various random problems, usually seen as a\nNULL pointer dereference in run_timer_softirq() or a BUG() in\nworker_thread (but it can be almost anything).\n\nFix it by adding the required 'flush_scheduled_work()' after doing the\ntty_ldisc_halt() (this also requires us to move the ldisc halt to before\ntaking the ldisc mutex in order to avoid a deadlock with the workqueue\nexecuting do_tty_hangup, which requires the mutex).\n\nThe locking should be cleaned up one day (the requirement to do this\noutside the ldisc_mutex is very annoying, and weakens the lock), but\nthat's a larger and separate undertaking.\n\nReported-by: Eric W. Biederman <ebiederm@xmission.com>\nTested-by: Xiaotian Feng <xtfeng@gmail.com>\nTested-by: Yanmin Zhang <yanmin_zhang@linux.intel.com>\nTested-by: Dave Young <hidave.darkstar@gmail.com>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Greg Kroah-Hartman <gregkh@suse.de>\nCc: Alan Cox <alan@lxorguk.ukuu.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/char\/tty_ldisc.c | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/char\/tty_ldisc.c b\/drivers\/char\/tty_ldisc.c\nindex 1733d3439ad2..e48af9f79219 100644\n--- a\/drivers\/char\/tty_ldisc.c\n+++ b\/drivers\/char\/tty_ldisc.c\n@@ -508,8 +508,9 @@ static void tty_ldisc_restore(struct tty_struct *tty, struct tty_ldisc *old)\n  *\tbe obtained while the delayed work queue halt ensures that no more\n  *\tdata is fed to the ldisc.\n  *\n- *\tIn order to wait for any existing references to complete see\n- *\ttty_ldisc_wait_idle.\n+ *\tYou need to do a 'flush_scheduled_work()' (outside the ldisc_mutex)\n+ *\tin order to make sure any currently executing ldisc work is also\n+ *\tflushed.\n  *\/\n \n static int tty_ldisc_halt(struct tty_struct *tty)\n@@ -753,11 +754,14 @@ void tty_ldisc_hangup(struct tty_struct *tty)\n \t * N_TTY.\n \t *\/\n \tif (tty->driver->flags & TTY_DRIVER_RESET_TERMIOS) {\n+\t\t\/* Make sure the old ldisc is quiescent *\/\n+\t\ttty_ldisc_halt(tty);\n+\t\tflush_scheduled_work();\n+\n \t\t\/* Avoid racing set_ldisc or tty_ldisc_release *\/\n \t\tmutex_lock(&tty->ldisc_mutex);\n \t\tif (tty->ldisc) {\t\/* Not yet closed *\/\n \t\t\t\/* Switch back to N_TTY *\/\n-\t\t\ttty_ldisc_halt(tty);\n \t\t\ttty_ldisc_reinit(tty);\n \t\t\t\/* At this point we have a closed ldisc and we want to\n \t\t\t   reopen it. We could defer this to the next open but\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-1446","CWE_ID":"399","category":"security","commit_id":"8e3fbf870481eb53b2d3a322d1fc395ad8b367ed","commit_message":"From 8e3fbf870481eb53b2d3a322d1fc395ad8b367ed Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Salva=20Peir=C3=B3?= <speiro@ai2.upv.es>\nDate: Tue, 17 Dec 2013 10:06:30 +0100\nSubject: [PATCH] hamradio\/yam: fix info leak in ioctl\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe yam_ioctl() code fails to initialise the cmd field\nof the struct yamdrv_ioctl_cfg. Add an explicit memset(0)\nbefore filling the structure to avoid the 4-byte info leak.\n\nSigned-off-by: Salva Peir\u00f3 <speiro@ai2.upv.es>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/hamradio\/yam.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/drivers\/net\/hamradio\/yam.c b\/drivers\/net\/hamradio\/yam.c\nindex 1971411574db1..61dd2447e1bb4 100644\n--- a\/drivers\/net\/hamradio\/yam.c\n+++ b\/drivers\/net\/hamradio\/yam.c\n@@ -1057,6 +1057,7 @@ static int yam_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n \t\tbreak;\n \n \tcase SIOCYAMGCFG:\n+\t\tmemset(&yi, 0, sizeof(yi));\n \t\tyi.cfg.mask = 0xffffffff;\n \t\tyi.cfg.iobase = yp->iobase;\n \t\tyi.cfg.irq = yp->irq;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-7145","CWE_ID":"399","category":"security","commit_id":"18f39e7be0121317550d03e267e3ebd4dbfbb3ce","commit_message":"From 18f39e7be0121317550d03e267e3ebd4dbfbb3ce Mon Sep 17 00:00:00 2001\nFrom: Steve French <smfrench@gmail.com>\nDate: Sun, 17 Aug 2014 00:22:24 -0500\nSubject: [CIFS] Possible null ptr deref in SMB2_tcon\n\nAs Raphael Geissert pointed out, tcon_error_exit can dereference tcon\nand there is one path in which tcon can be null.\n\nSigned-off-by: Steve French <smfrench@gmail.com>\nCC: Stable <stable@vger.kernel.org> # v3.7+\nReported-by: Raphael Geissert <geissert@debian.org>\n---\n fs\/cifs\/smb2pdu.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/cifs\/smb2pdu.c b\/fs\/cifs\/smb2pdu.c\nindex 74440af59f35..240c627bc0c6 100644\n--- a\/fs\/cifs\/smb2pdu.c\n+++ b\/fs\/cifs\/smb2pdu.c\n@@ -907,7 +907,8 @@ tcon_exit:\n tcon_error_exit:\n \tif (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {\n \t\tcifs_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n-\t\ttcon->bad_network_name = true;\n+\t\tif (tcon)\n+\t\t\ttcon->bad_network_name = true;\n \t}\n \tgoto tcon_exit;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2008-5033","CWE_ID":"399","category":"security","commit_id":"5ba2f67afb02c5302b2898949ed6fc3b3d37dcf1","commit_message":"From 5ba2f67afb02c5302b2898949ed6fc3b3d37dcf1 Mon Sep 17 00:00:00 2001\nFrom: Arjan van de Ven <arjan@linux.intel.com>\nDate: Fri, 10 Oct 2008 21:16:12 -0700\nSubject: security: avoid calling a NULL function pointer in\n drivers\/video\/tvaudio.c\n\nNULL function pointers are very bad security wise. This one got caught by\nkerneloops.org quite a few times, so it's happening in the field....\n\nFix is simple, check the function pointer for NULL, like 6 other places\nin the same function are already doing.\n\nSigned-off-by: Arjan van de Ven <arjan@linux.intel.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/media\/video\/tvaudio.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/media\/video\/tvaudio.c b\/drivers\/media\/video\/tvaudio.c\nindex 463680b13289..b59e47272abf 100644\n--- a\/drivers\/media\/video\/tvaudio.c\n+++ b\/drivers\/media\/video\/tvaudio.c\n@@ -1792,7 +1792,7 @@ static int chip_command(struct i2c_client *client,\n \t\tbreak;\n \tcase VIDIOC_S_FREQUENCY:\n \t\tchip->mode = 0; \/* automatic *\/\n-\t\tif (desc->checkmode) {\n+\t\tif (desc->checkmode && desc->setmode) {\n \t\t\tdesc->setmode(chip,V4L2_TUNER_MODE_MONO);\n \t\t\tif (chip->prevmode != V4L2_TUNER_MODE_MONO)\n \t\t\t\tchip->prevmode = -1; \/* reset previous mode *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6348","CWE_ID":"399","category":"security","commit_id":"4c03b862b12f980456f9de92db6d508a4999b788","commit_message":"From 4c03b862b12f980456f9de92db6d508a4999b788 Mon Sep 17 00:00:00 2001\nFrom: \"David S. Miller\" <davem@davemloft.net>\nDate: Fri, 17 Feb 2017 16:19:39 -0500\nSubject: irda: Fix lockdep annotations in hashbin_delete().\n\nA nested lock depth was added to the hasbin_delete() code but it\ndoesn't actually work some well and results in tons of lockdep splats.\n\nFix the code instead to properly drop the lock around the operation\nand just keep peeking the head of the hashbin queue.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/irda\/irqueue.c | 34 ++++++++++++++++------------------\n 1 file changed, 16 insertions(+), 18 deletions(-)\n\n","diff_code":"diff --git a\/net\/irda\/irqueue.c b\/net\/irda\/irqueue.c\nindex acbe61c7e683..160dc89335e2 100644\n--- a\/net\/irda\/irqueue.c\n+++ b\/net\/irda\/irqueue.c\n@@ -383,9 +383,6 @@ EXPORT_SYMBOL(hashbin_new);\n  *    for deallocating this structure if it's complex. If not the user can\n  *    just supply kfree, which should take care of the job.\n  *\/\n-#ifdef CONFIG_LOCKDEP\n-static int hashbin_lock_depth = 0;\n-#endif\n int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n {\n \tirda_queue_t* queue;\n@@ -396,22 +393,27 @@ int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n \tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n \n \t\/* Synchronize *\/\n-\tif ( hashbin->hb_type & HB_LOCK ) {\n-\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n-\t\t\t\t\t hashbin_lock_depth++);\n-\t}\n+\tif (hashbin->hb_type & HB_LOCK)\n+\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n \n \t\/*\n \t *  Free the entries in the hashbin, TODO: use hashbin_clear when\n \t *  it has been shown to work\n \t *\/\n \tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n-\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n-\t\twhile (queue ) {\n-\t\t\tif (free_func)\n-\t\t\t\t(*free_func)(queue);\n-\t\t\tqueue = dequeue_first(\n-\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n+\t\twhile (1) {\n+\t\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n+\n+\t\t\tif (!queue)\n+\t\t\t\tbreak;\n+\n+\t\t\tif (free_func) {\n+\t\t\t\tif (hashbin->hb_type & HB_LOCK)\n+\t\t\t\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n+\t\t\t\tfree_func(queue);\n+\t\t\t\tif (hashbin->hb_type & HB_LOCK)\n+\t\t\t\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -420,12 +422,8 @@ int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n \thashbin->magic = ~HB_MAGIC;\n \n \t\/* Release lock *\/\n-\tif ( hashbin->hb_type & HB_LOCK) {\n+\tif (hashbin->hb_type & HB_LOCK)\n \t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n-#ifdef CONFIG_LOCKDEP\n-\t\thashbin_lock_depth--;\n-#endif\n-\t}\n \n \t\/*\n \t *  Free the hashbin structure\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-8576","CWE_ID":"399","category":"security","commit_id":"05f43d44e4bc26611ce25fd7d726e483f73363ce","commit_message":"From 05f43d44e4bc26611ce25fd7d726e483f73363ce Mon Sep 17 00:00:00 2001\nFrom: Gerd Hoffmann <kraxel@redhat.com>\nDate: Mon, 10 Oct 2016 12:46:22 +0200\nSubject: [PATCH] xhci: limit the number of link trbs we are willing to process\n\nNeeded to avoid we run in circles forever in case the guest builds\nan endless loop with link trbs.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nTested-by: P J P <ppandit@redhat.com>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nMessage-id: 1476096382-7981-1-git-send-email-kraxel@redhat.com\n---\n hw\/usb\/hcd-xhci.c | 10 ++++++++++\n 1 file changed, 10 insertions(+)\n\n","diff_code":"diff --git a\/hw\/usb\/hcd-xhci.c b\/hw\/usb\/hcd-xhci.c\nindex 726435c..ee4fa48 100644\n--- a\/hw\/usb\/hcd-xhci.c\n+++ b\/hw\/usb\/hcd-xhci.c\n@@ -54,6 +54,8 @@\n  * to the specs when it gets them *\/\n #define ER_FULL_HACK\n \n+#define TRB_LINK_LIMIT  4\n+\n #define LEN_CAP         0x40\n #define LEN_OPER        (0x400 + 0x10 * MAXPORTS)\n #define LEN_RUNTIME     ((MAXINTRS + 1) * 0x20)\n@@ -1000,6 +1002,7 @@ static TRBType xhci_ring_fetch(XHCIState *xhci, XHCIRing *ring, XHCITRB *trb,\n                                dma_addr_t *addr)\n {\n     PCIDevice *pci_dev = PCI_DEVICE(xhci);\n+    uint32_t link_cnt = 0;\n \n     while (1) {\n         TRBType type;\n@@ -1026,6 +1029,9 @@ static TRBType xhci_ring_fetch(XHCIState *xhci, XHCIRing *ring, XHCITRB *trb,\n             ring->dequeue += TRB_SIZE;\n             return type;\n         } else {\n+            if (++link_cnt > TRB_LINK_LIMIT) {\n+                return 0;\n+            }\n             ring->dequeue = xhci_mask64(trb->parameter);\n             if (trb->control & TRB_LK_TC) {\n                 ring->ccs = !ring->ccs;\n@@ -1043,6 +1049,7 @@ static int xhci_ring_chain_length(XHCIState *xhci, const XHCIRing *ring)\n     bool ccs = ring->ccs;\n     \/* hack to bundle together the two\/three TDs that make a setup transfer *\/\n     bool control_td_set = 0;\n+    uint32_t link_cnt = 0;\n \n     while (1) {\n         TRBType type;\n@@ -1058,6 +1065,9 @@ static int xhci_ring_chain_length(XHCIState *xhci, const XHCIRing *ring)\n         type = TRB_TYPE(trb);\n \n         if (type == TR_LINK) {\n+            if (++link_cnt > TRB_LINK_LIMIT) {\n+                return -length;\n+            }\n             dequeue = xhci_mask64(trb.parameter);\n             if (trb.control & TRB_LK_TC) {\n                 ccs = !ccs;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-2635","CWE_ID":"399","category":"security","commit_id":"84d73cd3fb142bf1298a8c13fd4ca50fd2432372","commit_message":"From 84d73cd3fb142bf1298a8c13fd4ca50fd2432372 Mon Sep 17 00:00:00 2001\nFrom: Mathias Krause <minipli@googlemail.com>\nDate: Sat, 9 Mar 2013 05:52:20 +0000\nSubject: [PATCH] rtnl: fix info leak on RTM_GETLINK request for VF devices\n\nInitialize the mac address buffer with 0 as the driver specific function\nwill probably not fill the whole buffer. In fact, all in-kernel drivers\nfill only ETH_ALEN of the MAX_ADDR_LEN bytes, i.e. 6 of the 32 possible\nbytes. Therefore we currently leak 26 bytes of stack memory to userland\nvia the netlink interface.\n\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/rtnetlink.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/net\/core\/rtnetlink.c b\/net\/core\/rtnetlink.c\nindex b376410ff2590..a585d45cc9d9f 100644\n--- a\/net\/core\/rtnetlink.c\n+++ b\/net\/core\/rtnetlink.c\n@@ -979,6 +979,7 @@ static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,\n \t\t\t * report anything.\n \t\t\t *\/\n \t\t\tivi.spoofchk = -1;\n+\t\t\tmemset(ivi.mac, 0, sizeof(ivi.mac));\n \t\t\tif (dev->netdev_ops->ndo_get_vf_config(dev, i, &ivi))\n \t\t\t\tbreak;\n \t\t\tvf_mac.vf =\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7995","CWE_ID":"399","category":"security","commit_id":"b16c129daf0fed91febbb88de23dae8271c8898a","commit_message":"From b16c129daf0fed91febbb88de23dae8271c8898a Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Sun, 18 Sep 2016 19:48:35 -0700\nSubject: [PATCH] usb: ehci: fix memory leak in ehci_process_itd\n\nWhile processing isochronous transfer descriptors(iTD), if the page\nselect(PG) field value is out of bands it will return. In this\nsituation the ehci's sg list is not freed thus leading to a memory\nleak issue. This patch avoid this.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nReviewed-by: Thomas Huth <thuth@redhat.com>\nSigned-off-by: Michael Tokarev <mjt@tls.msk.ru>\n---\n hw\/usb\/hcd-ehci.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/hw\/usb\/hcd-ehci.c b\/hw\/usb\/hcd-ehci.c\nindex b093db7..f4ece9a 100644\n--- a\/hw\/usb\/hcd-ehci.c\n+++ b\/hw\/usb\/hcd-ehci.c\n@@ -1426,6 +1426,7 @@ static int ehci_process_itd(EHCIState *ehci,\n             if (off + len > 4096) {\n                 \/* transfer crosses page border *\/\n                 if (pg == 6) {\n+                    qemu_sglist_destroy(&ehci->isgl);\n                     return -1;  \/* avoid page pg + 1 *\/\n                 }\n                 ptr2 = (itd->bufptr[pg + 1] & ITD_BUFPTR_MASK);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-13134","CWE_ID":"399","category":"security","commit_id":"fe3066122ef72c82415811d25e9e3fad622c0a99","commit_message":"From fe3066122ef72c82415811d25e9e3fad622c0a99 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 18 Jun 2019 11:51:46 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1600\n\n---\n coders\/bmp.c  | 2 +-\n coders\/viff.c | 4 ++--\n 2 files changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/coders\/bmp.c b\/coders\/bmp.c\nindex fdabac9502..c964834fe8 100644\n--- a\/coders\/bmp.c\n+++ b\/coders\/bmp.c\n@@ -1506,7 +1506,7 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n             status=MagickFalse;\n-            return((Image *) NULL);\n+            break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\ndiff --git a\/coders\/viff.c b\/coders\/viff.c\nindex 5f89ad15e3..05aac7c556 100644\n--- a\/coders\/viff.c\n+++ b\/coders\/viff.c\n@@ -773,8 +773,8 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,\n         AcquireNextImage(image_info,image,exception);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n-            image=DestroyImageList(image);\n-            return((Image *) NULL);\n+            status=MagickFalse;\n+            break;\n           }\n         image=SyncNextImageInList(image);\n         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-1767","CWE_ID":"399","category":"security","commit_id":"5f00110f7273f9ff04ac69a5f85bb535a4fd0987","commit_message":"From 5f00110f7273f9ff04ac69a5f85bb535a4fd0987 Mon Sep 17 00:00:00 2001\nFrom: Greg Thelen <gthelen@google.com>\nDate: Fri, 22 Feb 2013 16:36:01 -0800\nSubject: tmpfs: fix use-after-free of mempolicy object\n\nThe tmpfs remount logic preserves filesystem mempolicy if the mpol=M\noption is not specified in the remount request.  A new policy can be\nspecified if mpol=M is given.\n\nBefore this patch remounting an mpol bound tmpfs without specifying\nmpol= mount option in the remount request would set the filesystem's\nmempolicy object to a freed mempolicy object.\n\nTo reproduce the problem boot a DEBUG_PAGEALLOC kernel and run:\n    # mkdir \/tmp\/x\n\n    # mount -t tmpfs -o size=100M,mpol=interleave nodev \/tmp\/x\n\n    # grep \/tmp\/x \/proc\/mounts\n    nodev \/tmp\/x tmpfs rw,relatime,size=102400k,mpol=interleave:0-3 0 0\n\n    # mount -o remount,size=200M nodev \/tmp\/x\n\n    # grep \/tmp\/x \/proc\/mounts\n    nodev \/tmp\/x tmpfs rw,relatime,size=204800k,mpol=??? 0 0\n        # note ? garbage in mpol=... output above\n\n    # dd if=\/dev\/zero of=\/tmp\/x\/f count=1\n        # panic here\n\nPanic:\n    BUG: unable to handle kernel NULL pointer dereference at           (null)\n    IP: [<          (null)>]           (null)\n    [...]\n    Oops: 0010 [#1] SMP DEBUG_PAGEALLOC\n    Call Trace:\n      mpol_shared_policy_init+0xa5\/0x160\n      shmem_get_inode+0x209\/0x270\n      shmem_mknod+0x3e\/0xf0\n      shmem_create+0x18\/0x20\n      vfs_create+0xb5\/0x130\n      do_last+0x9a1\/0xea0\n      path_openat+0xb3\/0x4d0\n      do_filp_open+0x42\/0xa0\n      do_sys_open+0xfe\/0x1e0\n      compat_sys_open+0x1b\/0x20\n      cstar_dispatch+0x7\/0x1f\n\nNon-debug kernels will not crash immediately because referencing the\ndangling mpol will not cause a fault.  Instead the filesystem will\nreference a freed mempolicy object, which will cause unpredictable\nbehavior.\n\nThe problem boils down to a dropped mpol reference below if\nshmem_parse_options() does not allocate a new mpol:\n\n    config = *sbinfo\n    shmem_parse_options(data, &config, true)\n    mpol_put(sbinfo->mpol)\n    sbinfo->mpol = config.mpol  \/* BUG: saves unreferenced mpol *\/\n\nThis patch avoids the crash by not releasing the mempolicy if\nshmem_parse_options() doesn't create a new mpol.\n\nHow far back does this issue go? I see it in both 2.6.36 and 3.3.  I did\nnot look back further.\n\nSigned-off-by: Greg Thelen <gthelen@google.com>\nAcked-by: Hugh Dickins <hughd@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/shmem.c | 10 ++++++++--\n 1 file changed, 8 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/mm\/shmem.c b\/mm\/shmem.c\nindex 7162c58355b1..5e2ff592e3b8 100644\n--- a\/mm\/shmem.c\n+++ b\/mm\/shmem.c\n@@ -2486,6 +2486,7 @@ static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n \tunsigned long inodes;\n \tint error = -EINVAL;\n \n+\tconfig.mpol = NULL;\n \tif (shmem_parse_options(data, &config, true))\n \t\treturn error;\n \n@@ -2510,8 +2511,13 @@ static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n \tsbinfo->max_inodes  = config.max_inodes;\n \tsbinfo->free_inodes = config.max_inodes - inodes;\n \n-\tmpol_put(sbinfo->mpol);\n-\tsbinfo->mpol        = config.mpol;\t\/* transfers initial ref *\/\n+\t\/*\n+\t * Preserve previous mempolicy unless mpol remount option was specified.\n+\t *\/\n+\tif (config.mpol) {\n+\t\tmpol_put(sbinfo->mpol);\n+\t\tsbinfo->mpol = config.mpol;\t\/* transfers initial ref *\/\n+\t}\n out:\n \tspin_unlock(&sbinfo->stat_lock);\n \treturn error;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-0992","CWE_ID":"399","category":"security","commit_id":"722f9890f09aadfc37ae479e7d946d5fc5ef7b91","commit_message":"From 722f9890f09aadfc37ae479e7d946d5fc5ef7b91 Mon Sep 17 00:00:00 2001\nFrom: Sebastien Pouliot <sebastien@ximian.com>\nDate: Wed, 6 Apr 2011 13:24:31 -0400\nSubject: [PATCH] Fix access to freed members of a dead thread\n\n* threads.c: Fix access to freed members of a dead thread. Found\nand fixed by Rodrigo Kumpera <rkumpera@novell.com>\nRef: CVE-2011-0992\n---\n mono\/metadata\/threads.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/mono\/metadata\/threads.c b\/mono\/metadata\/threads.c\nindex 3fe4e9302bb4..a7a721dca850 100644\n--- a\/mono\/metadata\/threads.c\n+++ b\/mono\/metadata\/threads.c\n@@ -1036,12 +1036,17 @@ void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInterna\n \t\tCloseHandle (thread);\n \n \tif (this->synch_cs) {\n-\t\tDeleteCriticalSection (this->synch_cs);\n-\t\tg_free (this->synch_cs);\n+\t\tCRITICAL_SECTION *synch_cs = this->synch_cs;\n \t\tthis->synch_cs = NULL;\n+\t\tDeleteCriticalSection (synch_cs);\n+\t\tg_free (synch_cs);\n \t}\n \n-\tg_free (this->name);\n+\tif (this->name) {\n+\t\tvoid *name = this->name;\n+\t\tthis->name = NULL;\n+\t\tg_free (name);\n+\t}\n }\n \n static void mono_thread_start (MonoThread *thread)\n","owner":"mono","repo":"mono","source":"cve"},{"CVE_ID":"CVE-2011-2918","CWE_ID":"399","category":"security","commit_id":"a8b0ca17b80e92faab46ee7179ba9e99ccb61233","commit_message":"From a8b0ca17b80e92faab46ee7179ba9e99ccb61233 Mon Sep 17 00:00:00 2001\nFrom: Peter Zijlstra <a.p.zijlstra@chello.nl>\nDate: Mon, 27 Jun 2011 14:41:57 +0200\nSubject: [PATCH] perf: Remove the nmi parameter from the swevent and overflow\n interface\n\nThe nmi parameter indicated if we could do wakeups from the current\ncontext, if not, we would set some state and self-IPI and let the\nresulting interrupt do the wakeup.\n\nFor the various event classes:\n\n  - hardware: nmi=0; PMI is in fact an NMI or we run irq_work_run from\n    the PMI-tail (ARM etc.)\n  - tracepoint: nmi=0; since tracepoint could be from NMI context.\n  - software: nmi=[0,1]; some, like the schedule thing cannot\n    perform wakeups, and hence need 0.\n\nAs one can see, there is very little nmi=1 usage, and the down-side of\nnot using it is that on some platforms some software events can have a\njiffy delay in wakeup (when arch_irq_work_raise isn't implemented).\n\nThe up-side however is that we can remove the nmi parameter and save a\nbunch of conditionals in fast paths.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nCc: Michael Cree <mcree@orcon.net.nz>\nCc: Will Deacon <will.deacon@arm.com>\nCc: Deng-Cheng Zhu <dengcheng.zhu@gmail.com>\nCc: Anton Blanchard <anton@samba.org>\nCc: Eric B Munson <emunson@mgebm.net>\nCc: Heiko Carstens <heiko.carstens@de.ibm.com>\nCc: Paul Mundt <lethal@linux-sh.org>\nCc: David S. Miller <davem@davemloft.net>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Jason Wessel <jason.wessel@windriver.com>\nCc: Don Zickus <dzickus@redhat.com>\nLink: http:\/\/lkml.kernel.org\/n\/tip-agjev8eu666tvknpb3iaj0fg@git.kernel.org\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\n---\n arch\/alpha\/kernel\/perf_event.c            |  2 +-\n arch\/arm\/kernel\/perf_event_v6.c           |  2 +-\n arch\/arm\/kernel\/perf_event_v7.c           |  2 +-\n arch\/arm\/kernel\/perf_event_xscale.c       |  4 +-\n arch\/arm\/kernel\/ptrace.c                  |  2 +-\n arch\/arm\/kernel\/swp_emulate.c             |  2 +-\n arch\/arm\/mm\/fault.c                       |  6 +--\n arch\/mips\/kernel\/perf_event.c             |  2 +-\n arch\/mips\/kernel\/traps.c                  |  8 +--\n arch\/mips\/kernel\/unaligned.c              |  5 +-\n arch\/mips\/math-emu\/cp1emu.c               |  3 +-\n arch\/mips\/mm\/fault.c                      |  8 ++-\n arch\/powerpc\/include\/asm\/emulated_ops.h   |  4 +-\n arch\/powerpc\/kernel\/perf_event.c          |  6 +--\n arch\/powerpc\/kernel\/perf_event_fsl_emb.c  |  6 +--\n arch\/powerpc\/kernel\/ptrace.c              |  2 +-\n arch\/powerpc\/mm\/fault.c                   |  6 +--\n arch\/s390\/mm\/fault.c                      |  6 +--\n arch\/sh\/kernel\/ptrace_32.c                |  2 +-\n arch\/sh\/kernel\/traps_32.c                 |  2 +-\n arch\/sh\/kernel\/traps_64.c                 |  8 +--\n arch\/sh\/math-emu\/math.c                   |  2 +-\n arch\/sh\/mm\/fault_32.c                     |  6 +--\n arch\/sh\/mm\/tlbflush_64.c                  |  6 +--\n arch\/sparc\/kernel\/perf_event.c            |  2 +-\n arch\/sparc\/kernel\/unaligned_32.c          |  4 +-\n arch\/sparc\/kernel\/unaligned_64.c          | 12 ++---\n arch\/sparc\/kernel\/visemul.c               |  2 +-\n arch\/sparc\/math-emu\/math_32.c             |  2 +-\n arch\/sparc\/math-emu\/math_64.c             |  2 +-\n arch\/sparc\/mm\/fault_32.c                  |  8 ++-\n arch\/sparc\/mm\/fault_64.c                  |  8 ++-\n arch\/x86\/kernel\/cpu\/perf_event.c          |  2 +-\n arch\/x86\/kernel\/cpu\/perf_event_intel.c    |  2 +-\n arch\/x86\/kernel\/cpu\/perf_event_intel_ds.c |  4 +-\n arch\/x86\/kernel\/cpu\/perf_event_p4.c       |  2 +-\n arch\/x86\/kernel\/kgdb.c                    |  2 +-\n arch\/x86\/kernel\/ptrace.c                  |  2 +-\n arch\/x86\/mm\/fault.c                       |  6 +--\n include\/linux\/perf_event.h                | 18 +++----\n kernel\/events\/core.c                      | 63 ++++++++++-------------\n kernel\/events\/internal.h                  |  1 -\n kernel\/events\/ring_buffer.c               | 10 ++--\n kernel\/sched.c                            |  2 +-\n kernel\/watchdog.c                         |  2 +-\n samples\/hw_breakpoint\/data_breakpoint.c   |  2 +-\n 46 files changed, 119 insertions(+), 141 deletions(-)\n\n","diff_code":"diff --git a\/arch\/alpha\/kernel\/perf_event.c b\/arch\/alpha\/kernel\/perf_event.c\nindex 90561c45e7d89..8e47709160f84 100644\n--- a\/arch\/alpha\/kernel\/perf_event.c\n+++ b\/arch\/alpha\/kernel\/perf_event.c\n@@ -847,7 +847,7 @@ static void alpha_perf_event_irq_handler(unsigned long la_ptr,\n \tdata.period = event->hw.last_period;\n \n \tif (alpha_perf_event_set_period(event, hwc, idx)) {\n-\t\tif (perf_event_overflow(event, 1, &data, regs)) {\n+\t\tif (perf_event_overflow(event, &data, regs)) {\n \t\t\t\/* Interrupts coming too quickly; \"throttle\" the\n \t\t\t * counter, i.e., disable it for a little while.\n \t\t\t *\/\ndiff --git a\/arch\/arm\/kernel\/perf_event_v6.c b\/arch\/arm\/kernel\/perf_event_v6.c\nindex f1e8dd94afe8f..38dc4da1d612d 100644\n--- a\/arch\/arm\/kernel\/perf_event_v6.c\n+++ b\/arch\/arm\/kernel\/perf_event_v6.c\n@@ -479,7 +479,7 @@ armv6pmu_handle_irq(int irq_num,\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 0, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n \ndiff --git a\/arch\/arm\/kernel\/perf_event_v7.c b\/arch\/arm\/kernel\/perf_event_v7.c\nindex 4960686afb581..6e5f8752303be 100644\n--- a\/arch\/arm\/kernel\/perf_event_v7.c\n+++ b\/arch\/arm\/kernel\/perf_event_v7.c\n@@ -787,7 +787,7 @@ static irqreturn_t armv7pmu_handle_irq(int irq_num, void *dev)\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 0, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n \ndiff --git a\/arch\/arm\/kernel\/perf_event_xscale.c b\/arch\/arm\/kernel\/perf_event_xscale.c\nindex 39affbe4fdb24..99b6b85c7e491 100644\n--- a\/arch\/arm\/kernel\/perf_event_xscale.c\n+++ b\/arch\/arm\/kernel\/perf_event_xscale.c\n@@ -251,7 +251,7 @@ xscale1pmu_handle_irq(int irq_num, void *dev)\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 0, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n \n@@ -583,7 +583,7 @@ xscale2pmu_handle_irq(int irq_num, void *dev)\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 0, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n \ndiff --git a\/arch\/arm\/kernel\/ptrace.c b\/arch\/arm\/kernel\/ptrace.c\nindex 97260060bf260..0c9b1054f7900 100644\n--- a\/arch\/arm\/kernel\/ptrace.c\n+++ b\/arch\/arm\/kernel\/ptrace.c\n@@ -396,7 +396,7 @@ static long ptrace_hbp_idx_to_num(int idx)\n \/*\n  * Handle hitting a HW-breakpoint.\n  *\/\n-static void ptrace_hbptriggered(struct perf_event *bp, int unused,\n+static void ptrace_hbptriggered(struct perf_event *bp,\n \t\t\t\t     struct perf_sample_data *data,\n \t\t\t\t     struct pt_regs *regs)\n {\ndiff --git a\/arch\/arm\/kernel\/swp_emulate.c b\/arch\/arm\/kernel\/swp_emulate.c\nindex 40ee7e5045e40..5f452f8fde056 100644\n--- a\/arch\/arm\/kernel\/swp_emulate.c\n+++ b\/arch\/arm\/kernel\/swp_emulate.c\n@@ -183,7 +183,7 @@ static int swp_handler(struct pt_regs *regs, unsigned int instr)\n \tunsigned int address, destreg, data, type;\n \tunsigned int res = 0;\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, regs->ARM_pc);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, regs->ARM_pc);\n \n \tif (current->pid != previous_pid) {\n \t\tpr_debug(\"\\\"%s\\\" (%ld) uses deprecated SWP{B} instruction\\n\",\ndiff --git a\/arch\/arm\/mm\/fault.c b\/arch\/arm\/mm\/fault.c\nindex bc0e1d88fd3ba..9ea4f7ddd665c 100644\n--- a\/arch\/arm\/mm\/fault.c\n+++ b\/arch\/arm\/mm\/fault.c\n@@ -318,11 +318,11 @@ do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\n \tfault = __do_page_fault(mm, addr, fsr, tsk);\n \tup_read(&mm->mmap_sem);\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, addr);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, addr);\n \tif (fault & VM_FAULT_MAJOR)\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0, regs, addr);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, addr);\n \telse if (fault & VM_FAULT_MINOR)\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0, regs, addr);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, addr);\n \n \t\/*\n \t * Handle the \"normal\" case first - VM_FAULT_MAJOR \/ VM_FAULT_MINOR\ndiff --git a\/arch\/mips\/kernel\/perf_event.c b\/arch\/mips\/kernel\/perf_event.c\nindex a8244854d3dc6..d0deaab9ace2e 100644\n--- a\/arch\/mips\/kernel\/perf_event.c\n+++ b\/arch\/mips\/kernel\/perf_event.c\n@@ -527,7 +527,7 @@ handle_associated_event(struct cpu_hw_events *cpuc,\n \tif (!mipspmu_event_set_period(event, hwc, idx))\n \t\treturn;\n \n-\tif (perf_event_overflow(event, 0, data, regs))\n+\tif (perf_event_overflow(event, data, regs))\n \t\tmipspmu->disable_event(idx);\n }\n \ndiff --git a\/arch\/mips\/kernel\/traps.c b\/arch\/mips\/kernel\/traps.c\nindex e9b3af27d844b..b7517e3abc852 100644\n--- a\/arch\/mips\/kernel\/traps.c\n+++ b\/arch\/mips\/kernel\/traps.c\n@@ -578,12 +578,12 @@ static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)\n {\n \tif ((opcode & OPCODE) == LL) {\n \t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t\t\t1, 0, regs, 0);\n+\t\t\t\t1, regs, 0);\n \t\treturn simulate_ll(regs, opcode);\n \t}\n \tif ((opcode & OPCODE) == SC) {\n \t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t\t\t1, 0, regs, 0);\n+\t\t\t\t1, regs, 0);\n \t\treturn simulate_sc(regs, opcode);\n \t}\n \n@@ -602,7 +602,7 @@ static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)\n \t\tint rd = (opcode & RD) >> 11;\n \t\tint rt = (opcode & RT) >> 16;\n \t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t\t\t1, 0, regs, 0);\n+\t\t\t\t1, regs, 0);\n \t\tswitch (rd) {\n \t\tcase 0:\t\t\/* CPU number *\/\n \t\t\tregs->regs[rt] = smp_processor_id();\n@@ -640,7 +640,7 @@ static int simulate_sync(struct pt_regs *regs, unsigned int opcode)\n {\n \tif ((opcode & OPCODE) == SPEC0 && (opcode & FUNC) == SYNC) {\n \t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t\t\t1, 0, regs, 0);\n+\t\t\t\t1, regs, 0);\n \t\treturn 0;\n \t}\n \ndiff --git a\/arch\/mips\/kernel\/unaligned.c b\/arch\/mips\/kernel\/unaligned.c\nindex cfea1adfa1536..eb319b5803537 100644\n--- a\/arch\/mips\/kernel\/unaligned.c\n+++ b\/arch\/mips\/kernel\/unaligned.c\n@@ -111,8 +111,7 @@ static void emulate_load_store_insn(struct pt_regs *regs,\n \tunsigned long value;\n \tunsigned int res;\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t      1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n \t\/*\n \t * This load never faults.\n@@ -517,7 +516,7 @@ asmlinkage void do_ade(struct pt_regs *regs)\n \tmm_segment_t seg;\n \n \tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\n-\t\t\t1, 0, regs, regs->cp0_badvaddr);\n+\t\t\t1, regs, regs->cp0_badvaddr);\n \t\/*\n \t * Did we catch a fault trying to load an instruction?\n \t * Or are we running in MIPS16 mode?\ndiff --git a\/arch\/mips\/math-emu\/cp1emu.c b\/arch\/mips\/math-emu\/cp1emu.c\nindex d32cb05031105..dbf2f93a50911 100644\n--- a\/arch\/mips\/math-emu\/cp1emu.c\n+++ b\/arch\/mips\/math-emu\/cp1emu.c\n@@ -272,8 +272,7 @@ static int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_struct *ctx,\n \t}\n \n       emul:\n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t\t1, 0, xcp, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, xcp, 0);\n \tMIPS_FPU_EMU_INC_STATS(emulated);\n \tswitch (MIPSInst_OPCODE(ir)) {\n \tcase ldc1_op:{\ndiff --git a\/arch\/mips\/mm\/fault.c b\/arch\/mips\/mm\/fault.c\nindex 137ee76a0045c..937cf3368164c 100644\n--- a\/arch\/mips\/mm\/fault.c\n+++ b\/arch\/mips\/mm\/fault.c\n@@ -145,7 +145,7 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs, unsigned long writ\n \t * the fault.\n \t *\/\n \tfault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);\n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \tif (unlikely(fault & VM_FAULT_ERROR)) {\n \t\tif (fault & VM_FAULT_OOM)\n \t\t\tgoto out_of_memory;\n@@ -154,12 +154,10 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs, unsigned long writ\n \t\tBUG();\n \t}\n \tif (fault & VM_FAULT_MAJOR) {\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ,\n-\t\t\t\t1, 0, regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);\n \t\ttsk->maj_flt++;\n \t} else {\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN,\n-\t\t\t\t1, 0, regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);\n \t\ttsk->min_flt++;\n \t}\n \ndiff --git a\/arch\/powerpc\/include\/asm\/emulated_ops.h b\/arch\/powerpc\/include\/asm\/emulated_ops.h\nindex 45921672b97af..2cc41c715d2ba 100644\n--- a\/arch\/powerpc\/include\/asm\/emulated_ops.h\n+++ b\/arch\/powerpc\/include\/asm\/emulated_ops.h\n@@ -78,14 +78,14 @@ extern void ppc_warn_emulated_print(const char *type);\n #define PPC_WARN_EMULATED(type, regs)\t\t\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\t\\\n \t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\t\t\\\n-\t\t\t1, 0, regs, 0);\t\t\t\t\t\\\n+\t\t\t1, regs, 0);\t\t\t\t\t\\\n \t\t__PPC_WARN_EMULATED(type);\t\t\t\t\\\n \t} while (0)\n \n #define PPC_WARN_ALIGNMENT(type, regs)\t\t\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\t\\\n \t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\t\t\\\n-\t\t\t1, 0, regs, regs->dar);\t\t\t\t\\\n+\t\t\t1, regs, regs->dar);\t\t\t\t\\\n \t\t__PPC_WARN_EMULATED(type);\t\t\t\t\\\n \t} while (0)\n \ndiff --git a\/arch\/powerpc\/kernel\/perf_event.c b\/arch\/powerpc\/kernel\/perf_event.c\nindex 822f63008ae11..14967de988760 100644\n--- a\/arch\/powerpc\/kernel\/perf_event.c\n+++ b\/arch\/powerpc\/kernel\/perf_event.c\n@@ -1207,7 +1207,7 @@ struct pmu power_pmu = {\n  * here so there is no possibility of being interrupted.\n  *\/\n static void record_and_restart(struct perf_event *event, unsigned long val,\n-\t\t\t       struct pt_regs *regs, int nmi)\n+\t\t\t       struct pt_regs *regs)\n {\n \tu64 period = event->hw.sample_period;\n \ts64 prev, delta, left;\n@@ -1258,7 +1258,7 @@ static void record_and_restart(struct perf_event *event, unsigned long val,\n \t\tif (event->attr.sample_type & PERF_SAMPLE_ADDR)\n \t\t\tperf_get_data_addr(regs, &data.addr);\n \n-\t\tif (perf_event_overflow(event, nmi, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tpower_pmu_stop(event, 0);\n \t}\n }\n@@ -1346,7 +1346,7 @@ static void perf_event_interrupt(struct pt_regs *regs)\n \t\tif ((int)val < 0) {\n \t\t\t\/* event has overflowed *\/\n \t\t\tfound = 1;\n-\t\t\trecord_and_restart(event, val, regs, nmi);\n+\t\t\trecord_and_restart(event, val, regs);\n \t\t}\n \t}\n \ndiff --git a\/arch\/powerpc\/kernel\/perf_event_fsl_emb.c b\/arch\/powerpc\/kernel\/perf_event_fsl_emb.c\nindex b0dc8f7069cd5..0a6d2a9d569cd 100644\n--- a\/arch\/powerpc\/kernel\/perf_event_fsl_emb.c\n+++ b\/arch\/powerpc\/kernel\/perf_event_fsl_emb.c\n@@ -568,7 +568,7 @@ static struct pmu fsl_emb_pmu = {\n  * here so there is no possibility of being interrupted.\n  *\/\n static void record_and_restart(struct perf_event *event, unsigned long val,\n-\t\t\t       struct pt_regs *regs, int nmi)\n+\t\t\t       struct pt_regs *regs)\n {\n \tu64 period = event->hw.sample_period;\n \ts64 prev, delta, left;\n@@ -616,7 +616,7 @@ static void record_and_restart(struct perf_event *event, unsigned long val,\n \t\tperf_sample_data_init(&data, 0);\n \t\tdata.period = event->hw.last_period;\n \n-\t\tif (perf_event_overflow(event, nmi, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tfsl_emb_pmu_stop(event, 0);\n \t}\n }\n@@ -644,7 +644,7 @@ static void perf_event_interrupt(struct pt_regs *regs)\n \t\t\tif (event) {\n \t\t\t\t\/* event has overflowed *\/\n \t\t\t\tfound = 1;\n-\t\t\t\trecord_and_restart(event, val, regs, nmi);\n+\t\t\t\trecord_and_restart(event, val, regs);\n \t\t\t} else {\n \t\t\t\t\/*\n \t\t\t\t * Disabled counter is negative,\ndiff --git a\/arch\/powerpc\/kernel\/ptrace.c b\/arch\/powerpc\/kernel\/ptrace.c\nindex cb22024f2b42a..3177617af2ef4 100644\n--- a\/arch\/powerpc\/kernel\/ptrace.c\n+++ b\/arch\/powerpc\/kernel\/ptrace.c\n@@ -882,7 +882,7 @@ void user_disable_single_step(struct task_struct *task)\n }\n \n #ifdef CONFIG_HAVE_HW_BREAKPOINT\n-void ptrace_triggered(struct perf_event *bp, int nmi,\n+void ptrace_triggered(struct perf_event *bp,\n \t\t      struct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct perf_event_attr attr;\ndiff --git a\/arch\/powerpc\/mm\/fault.c b\/arch\/powerpc\/mm\/fault.c\nindex 54f4fb994e99a..dbc48254c6cc9 100644\n--- a\/arch\/powerpc\/mm\/fault.c\n+++ b\/arch\/powerpc\/mm\/fault.c\n@@ -173,7 +173,7 @@ int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address,\n \t\tdie(\"Weird page fault\", regs, SIGSEGV);\n \t}\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \t\/* When running in the kernel we expect faults to occur only to\n \t * addresses in user space.  All other faults represent errors in the\n@@ -319,7 +319,7 @@ int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address,\n \t}\n \tif (ret & VM_FAULT_MAJOR) {\n \t\tcurrent->maj_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t     regs, address);\n #ifdef CONFIG_PPC_SMLPAR\n \t\tif (firmware_has_feature(FW_FEATURE_CMO)) {\n@@ -330,7 +330,7 @@ int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address,\n #endif\n \t} else {\n \t\tcurrent->min_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t     regs, address);\n \t}\n \tup_read(&mm->mmap_sem);\ndiff --git a\/arch\/s390\/mm\/fault.c b\/arch\/s390\/mm\/fault.c\nindex fe103e891e7a0..095f782a5512d 100644\n--- a\/arch\/s390\/mm\/fault.c\n+++ b\/arch\/s390\/mm\/fault.c\n@@ -299,7 +299,7 @@ static inline int do_exception(struct pt_regs *regs, int access,\n \t\tgoto out;\n \n \taddress = trans_exc_code & __FAIL_ADDR_MASK;\n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \tflags = FAULT_FLAG_ALLOW_RETRY;\n \tif (access == VM_WRITE || (trans_exc_code & store_indication) == 0x400)\n \t\tflags |= FAULT_FLAG_WRITE;\n@@ -345,11 +345,11 @@ static inline int do_exception(struct pt_regs *regs, int access,\n \tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n \t\tif (fault & VM_FAULT_MAJOR) {\n \t\t\ttsk->maj_flt++;\n-\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n+\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t      regs, address);\n \t\t} else {\n \t\t\ttsk->min_flt++;\n-\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n+\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t      regs, address);\n \t\t}\n \t\tif (fault & VM_FAULT_RETRY) {\ndiff --git a\/arch\/sh\/kernel\/ptrace_32.c b\/arch\/sh\/kernel\/ptrace_32.c\nindex 3d7b209b2178c..8051976100a61 100644\n--- a\/arch\/sh\/kernel\/ptrace_32.c\n+++ b\/arch\/sh\/kernel\/ptrace_32.c\n@@ -63,7 +63,7 @@ static inline int put_stack_long(struct task_struct *task, int offset,\n \treturn 0;\n }\n \n-void ptrace_triggered(struct perf_event *bp, int nmi,\n+void ptrace_triggered(struct perf_event *bp,\n \t\t      struct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct perf_event_attr attr;\ndiff --git a\/arch\/sh\/kernel\/traps_32.c b\/arch\/sh\/kernel\/traps_32.c\nindex b51a17104b5f8..d9006f8ffc142 100644\n--- a\/arch\/sh\/kernel\/traps_32.c\n+++ b\/arch\/sh\/kernel\/traps_32.c\n@@ -393,7 +393,7 @@ int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,\n \t *\/\n \tif (!expected) {\n \t\tunaligned_fixups_notify(current, instruction, regs);\n-\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,\n \t\t\t      regs, address);\n \t}\n \ndiff --git a\/arch\/sh\/kernel\/traps_64.c b\/arch\/sh\/kernel\/traps_64.c\nindex 6713ca97e553e..67110be83fd72 100644\n--- a\/arch\/sh\/kernel\/traps_64.c\n+++ b\/arch\/sh\/kernel\/traps_64.c\n@@ -434,7 +434,7 @@ static int misaligned_load(struct pt_regs *regs,\n \t\treturn error;\n \t}\n \n-\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, address);\n \n \tdestreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {\n@@ -512,7 +512,7 @@ static int misaligned_store(struct pt_regs *regs,\n \t\treturn error;\n \t}\n \n-\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, address);\n \n \tsrcreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {\n@@ -588,7 +588,7 @@ static int misaligned_fpu_load(struct pt_regs *regs,\n \t\treturn error;\n \t}\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, address);\n \n \tdestreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {\n@@ -665,7 +665,7 @@ static int misaligned_fpu_store(struct pt_regs *regs,\n \t\treturn error;\n \t}\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, address);\n \n \tsrcreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {\ndiff --git a\/arch\/sh\/math-emu\/math.c b\/arch\/sh\/math-emu\/math.c\nindex f76a5090d5d1b..977195210653e 100644\n--- a\/arch\/sh\/math-emu\/math.c\n+++ b\/arch\/sh\/math-emu\/math.c\n@@ -620,7 +620,7 @@ int do_fpu_inst(unsigned short inst, struct pt_regs *regs)\n \tstruct task_struct *tsk = current;\n \tstruct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu);\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n \tif (!(task_thread_info(tsk)->status & TS_USEDFPU)) {\n \t\t\/* initialize once. *\/\ndiff --git a\/arch\/sh\/mm\/fault_32.c b\/arch\/sh\/mm\/fault_32.c\nindex d4c34d757f0d5..7bebd044f2a1f 100644\n--- a\/arch\/sh\/mm\/fault_32.c\n+++ b\/arch\/sh\/mm\/fault_32.c\n@@ -160,7 +160,7 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,\n \tif ((regs->sr & SR_IMASK) != SR_IMASK)\n \t\tlocal_irq_enable();\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \t\/*\n \t * If we're in an interrupt, have no user context or are running\n@@ -210,11 +210,11 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,\n \t}\n \tif (fault & VM_FAULT_MAJOR) {\n \t\ttsk->maj_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t     regs, address);\n \t} else {\n \t\ttsk->min_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t     regs, address);\n \t}\n \ndiff --git a\/arch\/sh\/mm\/tlbflush_64.c b\/arch\/sh\/mm\/tlbflush_64.c\nindex 7f5810f5dfdc4..e3430e093d436 100644\n--- a\/arch\/sh\/mm\/tlbflush_64.c\n+++ b\/arch\/sh\/mm\/tlbflush_64.c\n@@ -116,7 +116,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long writeaccess,\n \t\/* Not an IO address, so reenable interrupts *\/\n \tlocal_irq_enable();\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \t\/*\n \t * If we're in an interrupt or have no user\n@@ -200,11 +200,11 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long writeaccess,\n \n \tif (fault & VM_FAULT_MAJOR) {\n \t\ttsk->maj_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t     regs, address);\n \t} else {\n \t\ttsk->min_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t     regs, address);\n \t}\n \ndiff --git a\/arch\/sparc\/kernel\/perf_event.c b\/arch\/sparc\/kernel\/perf_event.c\nindex 2cb0e1c001e25..0b32f2e9e08d9 100644\n--- a\/arch\/sparc\/kernel\/perf_event.c\n+++ b\/arch\/sparc\/kernel\/perf_event.c\n@@ -1277,7 +1277,7 @@ static int __kprobes perf_event_nmi_handler(struct notifier_block *self,\n \t\tif (!sparc_perf_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 1, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tsparc_pmu_stop(event, 0);\n \t}\n \ndiff --git a\/arch\/sparc\/kernel\/unaligned_32.c b\/arch\/sparc\/kernel\/unaligned_32.c\nindex 4491f4cb26953..7efbb2f9e77ff 100644\n--- a\/arch\/sparc\/kernel\/unaligned_32.c\n+++ b\/arch\/sparc\/kernel\/unaligned_32.c\n@@ -247,7 +247,7 @@ asmlinkage void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n \t\tunsigned long addr = compute_effective_address(regs, insn);\n \t\tint err;\n \n-\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n+\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n \t\tswitch (dir) {\n \t\tcase load:\n \t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n@@ -338,7 +338,7 @@ asmlinkage void user_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n \t\t}\n \n \t\taddr = compute_effective_address(regs, insn);\n-\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n+\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n \t\tswitch(dir) {\n \t\tcase load:\n \t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\ndiff --git a\/arch\/sparc\/kernel\/unaligned_64.c b\/arch\/sparc\/kernel\/unaligned_64.c\nindex b2b019ea8caab..35cff1673aa4e 100644\n--- a\/arch\/sparc\/kernel\/unaligned_64.c\n+++ b\/arch\/sparc\/kernel\/unaligned_64.c\n@@ -317,7 +317,7 @@ asmlinkage void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n \n \t\taddr = compute_effective_address(regs, insn,\n \t\t\t\t\t\t ((insn >> 25) & 0x1f));\n-\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n+\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n \t\tswitch (asi) {\n \t\tcase ASI_NL:\n \t\tcase ASI_AIUPL:\n@@ -384,7 +384,7 @@ int handle_popc(u32 insn, struct pt_regs *regs)\n \tint ret, i, rd = ((insn >> 25) & 0x1f);\n \tint from_kernel = (regs->tstate & TSTATE_PRIV) != 0;\n \t                        \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \tif (insn & 0x2000) {\n \t\tmaybe_flush_windows(0, 0, rd, from_kernel);\n \t\tvalue = sign_extend_imm13(insn);\n@@ -431,7 +431,7 @@ int handle_ldf_stq(u32 insn, struct pt_regs *regs)\n \tint asi = decode_asi(insn, regs);\n \tint flag = (freg < 32) ? FPRS_DL : FPRS_DU;\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n \tsave_and_clear_fpu();\n \tcurrent_thread_info()->xfsr[0] &= ~0x1c000;\n@@ -554,7 +554,7 @@ void handle_ld_nf(u32 insn, struct pt_regs *regs)\n \tint from_kernel = (regs->tstate & TSTATE_PRIV) != 0;\n \tunsigned long *reg;\n \t                        \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n \tmaybe_flush_windows(0, 0, rd, from_kernel);\n \treg = fetch_reg_addr(rd, regs);\n@@ -586,7 +586,7 @@ void handle_lddfmna(struct pt_regs *regs, unsigned long sfar, unsigned long sfsr\n \n \tif (tstate & TSTATE_PRIV)\n \t\tdie_if_kernel(\"lddfmna from kernel\", regs);\n-\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, sfar);\n+\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, sfar);\n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\n \tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\n@@ -647,7 +647,7 @@ void handle_stdfmna(struct pt_regs *regs, unsigned long sfar, unsigned long sfsr\n \n \tif (tstate & TSTATE_PRIV)\n \t\tdie_if_kernel(\"stdfmna from kernel\", regs);\n-\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, sfar);\n+\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, sfar);\n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\n \tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\ndiff --git a\/arch\/sparc\/kernel\/visemul.c b\/arch\/sparc\/kernel\/visemul.c\nindex 36357717d6910..32b626c9d8156 100644\n--- a\/arch\/sparc\/kernel\/visemul.c\n+++ b\/arch\/sparc\/kernel\/visemul.c\n@@ -802,7 +802,7 @@ int vis_emul(struct pt_regs *regs, unsigned int insn)\n \n \tBUG_ON(regs->tstate & TSTATE_PRIV);\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\ndiff --git a\/arch\/sparc\/math-emu\/math_32.c b\/arch\/sparc\/math-emu\/math_32.c\nindex a3fccde894ece..aa4d55b0bdf03 100644\n--- a\/arch\/sparc\/math-emu\/math_32.c\n+++ b\/arch\/sparc\/math-emu\/math_32.c\n@@ -164,7 +164,7 @@ int do_mathemu(struct pt_regs *regs, struct task_struct *fpt)\n \tint retcode = 0;                               \/* assume all succeed *\/\n \tunsigned long insn;\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n #ifdef DEBUG_MATHEMU\n \tprintk(\"In do_mathemu()... pc is %08lx\\n\", regs->pc);\ndiff --git a\/arch\/sparc\/math-emu\/math_64.c b\/arch\/sparc\/math-emu\/math_64.c\nindex 56d2c44747b8f..e575bd2fe3816 100644\n--- a\/arch\/sparc\/math-emu\/math_64.c\n+++ b\/arch\/sparc\/math-emu\/math_64.c\n@@ -184,7 +184,7 @@ int do_mathemu(struct pt_regs *regs, struct fpustate *f)\n \n \tif (tstate & TSTATE_PRIV)\n \t\tdie_if_kernel(\"unfinished\/unimplemented FPop from kernel\", regs);\n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\n \tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\ndiff --git a\/arch\/sparc\/mm\/fault_32.c b\/arch\/sparc\/mm\/fault_32.c\nindex 7543ddbdadb27..aa1c1b1ce5cc0 100644\n--- a\/arch\/sparc\/mm\/fault_32.c\n+++ b\/arch\/sparc\/mm\/fault_32.c\n@@ -251,7 +251,7 @@ asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,\n         if (in_atomic() || !mm)\n                 goto no_context;\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \tdown_read(&mm->mmap_sem);\n \n@@ -301,12 +301,10 @@ asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,\n \t}\n \tif (fault & VM_FAULT_MAJOR) {\n \t\tcurrent->maj_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n-\t\t\t      regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);\n \t} else {\n \t\tcurrent->min_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n-\t\t\t      regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);\n \t}\n \tup_read(&mm->mmap_sem);\n \treturn;\ndiff --git a\/arch\/sparc\/mm\/fault_64.c b\/arch\/sparc\/mm\/fault_64.c\nindex f92ce56a8b22c..504c0622f7296 100644\n--- a\/arch\/sparc\/mm\/fault_64.c\n+++ b\/arch\/sparc\/mm\/fault_64.c\n@@ -325,7 +325,7 @@ asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)\n \tif (in_atomic() || !mm)\n \t\tgoto intr_or_no_mm;\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \tif (!down_read_trylock(&mm->mmap_sem)) {\n \t\tif ((regs->tstate & TSTATE_PRIV) &&\n@@ -433,12 +433,10 @@ asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)\n \t}\n \tif (fault & VM_FAULT_MAJOR) {\n \t\tcurrent->maj_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n-\t\t\t      regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);\n \t} else {\n \t\tcurrent->min_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n-\t\t\t      regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);\n \t}\n \tup_read(&mm->mmap_sem);\n \ndiff --git a\/arch\/x86\/kernel\/cpu\/perf_event.c b\/arch\/x86\/kernel\/cpu\/perf_event.c\nindex 8a57f9aa8e36e..5b86ec51534cf 100644\n--- a\/arch\/x86\/kernel\/cpu\/perf_event.c\n+++ b\/arch\/x86\/kernel\/cpu\/perf_event.c\n@@ -1339,7 +1339,7 @@ static int x86_pmu_handle_irq(struct pt_regs *regs)\n \t\tif (!x86_perf_event_set_period(event))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 1, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tx86_pmu_stop(event, 0);\n \t}\n \ndiff --git a\/arch\/x86\/kernel\/cpu\/perf_event_intel.c b\/arch\/x86\/kernel\/cpu\/perf_event_intel.c\nindex 41178c826c485..d38b0020f7756 100644\n--- a\/arch\/x86\/kernel\/cpu\/perf_event_intel.c\n+++ b\/arch\/x86\/kernel\/cpu\/perf_event_intel.c\n@@ -1003,7 +1003,7 @@ static int intel_pmu_handle_irq(struct pt_regs *regs)\n \n \t\tdata.period = event->hw.last_period;\n \n-\t\tif (perf_event_overflow(event, 1, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tx86_pmu_stop(event, 0);\n \t}\n \ndiff --git a\/arch\/x86\/kernel\/cpu\/perf_event_intel_ds.c b\/arch\/x86\/kernel\/cpu\/perf_event_intel_ds.c\nindex bab491b8ee25e..0941f93f2940b 100644\n--- a\/arch\/x86\/kernel\/cpu\/perf_event_intel_ds.c\n+++ b\/arch\/x86\/kernel\/cpu\/perf_event_intel_ds.c\n@@ -340,7 +340,7 @@ static int intel_pmu_drain_bts_buffer(void)\n \t *\/\n \tperf_prepare_sample(&header, &data, event, &regs);\n \n-\tif (perf_output_begin(&handle, event, header.size * (top - at), 1, 1))\n+\tif (perf_output_begin(&handle, event, header.size * (top - at), 1))\n \t\treturn 1;\n \n \tfor (; at < top; at++) {\n@@ -616,7 +616,7 @@ static void __intel_pmu_pebs_event(struct perf_event *event,\n \telse\n \t\tregs.flags &= ~PERF_EFLAGS_EXACT;\n \n-\tif (perf_event_overflow(event, 1, &data, &regs))\n+\tif (perf_event_overflow(event, &data, &regs))\n \t\tx86_pmu_stop(event, 0);\n }\n \ndiff --git a\/arch\/x86\/kernel\/cpu\/perf_event_p4.c b\/arch\/x86\/kernel\/cpu\/perf_event_p4.c\nindex f76fddf633810..d6e6a67b9608e 100644\n--- a\/arch\/x86\/kernel\/cpu\/perf_event_p4.c\n+++ b\/arch\/x86\/kernel\/cpu\/perf_event_p4.c\n@@ -970,7 +970,7 @@ static int p4_pmu_handle_irq(struct pt_regs *regs)\n \n \t\tif (!x86_perf_event_set_period(event))\n \t\t\tcontinue;\n-\t\tif (perf_event_overflow(event, 1, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tx86_pmu_stop(event, 0);\n \t}\n \ndiff --git a\/arch\/x86\/kernel\/kgdb.c b\/arch\/x86\/kernel\/kgdb.c\nindex 5f9ecff328b5f..98da6a7b5e822 100644\n--- a\/arch\/x86\/kernel\/kgdb.c\n+++ b\/arch\/x86\/kernel\/kgdb.c\n@@ -608,7 +608,7 @@ int kgdb_arch_init(void)\n \treturn register_die_notifier(&kgdb_notifier);\n }\n \n-static void kgdb_hw_overflow_handler(struct perf_event *event, int nmi,\n+static void kgdb_hw_overflow_handler(struct perf_event *event,\n \t\tstruct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct task_struct *tsk = current;\ndiff --git a\/arch\/x86\/kernel\/ptrace.c b\/arch\/x86\/kernel\/ptrace.c\nindex 807c2a2b80f12..11db2e9b860a7 100644\n--- a\/arch\/x86\/kernel\/ptrace.c\n+++ b\/arch\/x86\/kernel\/ptrace.c\n@@ -528,7 +528,7 @@ static int genregs_set(struct task_struct *target,\n \treturn ret;\n }\n \n-static void ptrace_triggered(struct perf_event *bp, int nmi,\n+static void ptrace_triggered(struct perf_event *bp,\n \t\t\t     struct perf_sample_data *data,\n \t\t\t     struct pt_regs *regs)\n {\ndiff --git a\/arch\/x86\/mm\/fault.c b\/arch\/x86\/mm\/fault.c\nindex 2dbf6bf4c7e52..4d09df054e391 100644\n--- a\/arch\/x86\/mm\/fault.c\n+++ b\/arch\/x86\/mm\/fault.c\n@@ -1059,7 +1059,7 @@ do_page_fault(struct pt_regs *regs, unsigned long error_code)\n \tif (unlikely(error_code & PF_RSVD))\n \t\tpgtable_bad(regs, error_code, address);\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \t\/*\n \t * If we're in an interrupt, have no user context or are running\n@@ -1161,11 +1161,11 @@ do_page_fault(struct pt_regs *regs, unsigned long error_code)\n \tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n \t\tif (fault & VM_FAULT_MAJOR) {\n \t\t\ttsk->maj_flt++;\n-\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n+\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t      regs, address);\n \t\t} else {\n \t\t\ttsk->min_flt++;\n-\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n+\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t      regs, address);\n \t\t}\n \t\tif (fault & VM_FAULT_RETRY) {\ndiff --git a\/include\/linux\/perf_event.h b\/include\/linux\/perf_event.h\nindex 2f7b5d42ab416..0946a8bc098db 100644\n--- a\/include\/linux\/perf_event.h\n+++ b\/include\/linux\/perf_event.h\n@@ -682,7 +682,7 @@ enum perf_event_active_state {\n struct file;\n struct perf_sample_data;\n \n-typedef void (*perf_overflow_handler_t)(struct perf_event *, int,\n+typedef void (*perf_overflow_handler_t)(struct perf_event *,\n \t\t\t\t\tstruct perf_sample_data *,\n \t\t\t\t\tstruct pt_regs *regs);\n \n@@ -925,7 +925,6 @@ struct perf_output_handle {\n \tunsigned long\t\t\tsize;\n \tvoid\t\t\t\t*addr;\n \tint\t\t\t\tpage;\n-\tint\t\t\t\tnmi;\n \tint\t\t\t\tsample;\n };\n \n@@ -993,7 +992,7 @@ extern void perf_prepare_sample(struct perf_event_header *header,\n \t\t\t\tstruct perf_event *event,\n \t\t\t\tstruct pt_regs *regs);\n \n-extern int perf_event_overflow(struct perf_event *event, int nmi,\n+extern int perf_event_overflow(struct perf_event *event,\n \t\t\t\t struct perf_sample_data *data,\n \t\t\t\t struct pt_regs *regs);\n \n@@ -1012,7 +1011,7 @@ static inline int is_software_event(struct perf_event *event)\n \n extern struct jump_label_key perf_swevent_enabled[PERF_COUNT_SW_MAX];\n \n-extern void __perf_sw_event(u32, u64, int, struct pt_regs *, u64);\n+extern void __perf_sw_event(u32, u64, struct pt_regs *, u64);\n \n #ifndef perf_arch_fetch_caller_regs\n static inline void perf_arch_fetch_caller_regs(struct pt_regs *regs, unsigned long ip) { }\n@@ -1034,7 +1033,7 @@ static inline void perf_fetch_caller_regs(struct pt_regs *regs)\n }\n \n static __always_inline void\n-perf_sw_event(u32 event_id, u64 nr, int nmi, struct pt_regs *regs, u64 addr)\n+perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n {\n \tstruct pt_regs hot_regs;\n \n@@ -1043,7 +1042,7 @@ perf_sw_event(u32 event_id, u64 nr, int nmi, struct pt_regs *regs, u64 addr)\n \t\t\tperf_fetch_caller_regs(&hot_regs);\n \t\t\tregs = &hot_regs;\n \t\t}\n-\t\t__perf_sw_event(event_id, nr, nmi, regs, addr);\n+\t\t__perf_sw_event(event_id, nr, regs, addr);\n \t}\n }\n \n@@ -1057,7 +1056,7 @@ static inline void perf_event_task_sched_in(struct task_struct *task)\n \n static inline void perf_event_task_sched_out(struct task_struct *task, struct task_struct *next)\n {\n-\tperf_sw_event(PERF_COUNT_SW_CONTEXT_SWITCHES, 1, 1, NULL, 0);\n+\tperf_sw_event(PERF_COUNT_SW_CONTEXT_SWITCHES, 1, NULL, 0);\n \n \t__perf_event_task_sched_out(task, next);\n }\n@@ -1119,7 +1118,7 @@ extern void perf_bp_event(struct perf_event *event, void *data);\n \n extern int perf_output_begin(struct perf_output_handle *handle,\n \t\t\t     struct perf_event *event, unsigned int size,\n-\t\t\t     int nmi, int sample);\n+\t\t\t     int sample);\n extern void perf_output_end(struct perf_output_handle *handle);\n extern void perf_output_copy(struct perf_output_handle *handle,\n \t\t\t     const void *buf, unsigned int len);\n@@ -1143,8 +1142,7 @@ static inline int perf_event_task_disable(void)\t\t\t\t{ return -EINVAL; }\n static inline int perf_event_task_enable(void)\t\t\t\t{ return -EINVAL; }\n \n static inline void\n-perf_sw_event(u32 event_id, u64 nr, int nmi,\n-\t\t     struct pt_regs *regs, u64 addr)\t\t\t{ }\n+perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\t{ }\n static inline void\n perf_bp_event(struct perf_event *event, void *data)\t\t\t{ }\n \ndiff --git a\/kernel\/events\/core.c b\/kernel\/events\/core.c\nindex 270e32f9fc069..dbd1ca75bd3cb 100644\n--- a\/kernel\/events\/core.c\n+++ b\/kernel\/events\/core.c\n@@ -3972,7 +3972,7 @@ void perf_prepare_sample(struct perf_event_header *header,\n \t}\n }\n \n-static void perf_event_output(struct perf_event *event, int nmi,\n+static void perf_event_output(struct perf_event *event,\n \t\t\t\tstruct perf_sample_data *data,\n \t\t\t\tstruct pt_regs *regs)\n {\n@@ -3984,7 +3984,7 @@ static void perf_event_output(struct perf_event *event, int nmi,\n \n \tperf_prepare_sample(&header, data, event, regs);\n \n-\tif (perf_output_begin(&handle, event, header.size, nmi, 1))\n+\tif (perf_output_begin(&handle, event, header.size, 1))\n \t\tgoto exit;\n \n \tperf_output_sample(&handle, &header, data, event);\n@@ -4024,7 +4024,7 @@ perf_event_read_event(struct perf_event *event,\n \tint ret;\n \n \tperf_event_header__init_id(&read_event.header, &sample, event);\n-\tret = perf_output_begin(&handle, event, read_event.header.size, 0, 0);\n+\tret = perf_output_begin(&handle, event, read_event.header.size, 0);\n \tif (ret)\n \t\treturn;\n \n@@ -4067,7 +4067,7 @@ static void perf_event_task_output(struct perf_event *event,\n \tperf_event_header__init_id(&task_event->event_id.header, &sample, event);\n \n \tret = perf_output_begin(&handle, event,\n-\t\t\t\ttask_event->event_id.header.size, 0, 0);\n+\t\t\t\ttask_event->event_id.header.size, 0);\n \tif (ret)\n \t\tgoto out;\n \n@@ -4204,7 +4204,7 @@ static void perf_event_comm_output(struct perf_event *event,\n \n \tperf_event_header__init_id(&comm_event->event_id.header, &sample, event);\n \tret = perf_output_begin(&handle, event,\n-\t\t\t\tcomm_event->event_id.header.size, 0, 0);\n+\t\t\t\tcomm_event->event_id.header.size, 0);\n \n \tif (ret)\n \t\tgoto out;\n@@ -4351,7 +4351,7 @@ static void perf_event_mmap_output(struct perf_event *event,\n \n \tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n \tret = perf_output_begin(&handle, event,\n-\t\t\t\tmmap_event->event_id.header.size, 0, 0);\n+\t\t\t\tmmap_event->event_id.header.size, 0);\n \tif (ret)\n \t\tgoto out;\n \n@@ -4546,7 +4546,7 @@ static void perf_log_throttle(struct perf_event *event, int enable)\n \tperf_event_header__init_id(&throttle_event.header, &sample, event);\n \n \tret = perf_output_begin(&handle, event,\n-\t\t\t\tthrottle_event.header.size, 1, 0);\n+\t\t\t\tthrottle_event.header.size, 0);\n \tif (ret)\n \t\treturn;\n \n@@ -4559,7 +4559,7 @@ static void perf_log_throttle(struct perf_event *event, int enable)\n  * Generic event overflow handling, sampling.\n  *\/\n \n-static int __perf_event_overflow(struct perf_event *event, int nmi,\n+static int __perf_event_overflow(struct perf_event *event,\n \t\t\t\t   int throttle, struct perf_sample_data *data,\n \t\t\t\t   struct pt_regs *regs)\n {\n@@ -4602,34 +4602,28 @@ static int __perf_event_overflow(struct perf_event *event, int nmi,\n \tif (events && atomic_dec_and_test(&event->event_limit)) {\n \t\tret = 1;\n \t\tevent->pending_kill = POLL_HUP;\n-\t\tif (nmi) {\n-\t\t\tevent->pending_disable = 1;\n-\t\t\tirq_work_queue(&event->pending);\n-\t\t} else\n-\t\t\tperf_event_disable(event);\n+\t\tevent->pending_disable = 1;\n+\t\tirq_work_queue(&event->pending);\n \t}\n \n \tif (event->overflow_handler)\n-\t\tevent->overflow_handler(event, nmi, data, regs);\n+\t\tevent->overflow_handler(event, data, regs);\n \telse\n-\t\tperf_event_output(event, nmi, data, regs);\n+\t\tperf_event_output(event, data, regs);\n \n \tif (event->fasync && event->pending_kill) {\n-\t\tif (nmi) {\n-\t\t\tevent->pending_wakeup = 1;\n-\t\t\tirq_work_queue(&event->pending);\n-\t\t} else\n-\t\t\tperf_event_wakeup(event);\n+\t\tevent->pending_wakeup = 1;\n+\t\tirq_work_queue(&event->pending);\n \t}\n \n \treturn ret;\n }\n \n-int perf_event_overflow(struct perf_event *event, int nmi,\n+int perf_event_overflow(struct perf_event *event,\n \t\t\t  struct perf_sample_data *data,\n \t\t\t  struct pt_regs *regs)\n {\n-\treturn __perf_event_overflow(event, nmi, 1, data, regs);\n+\treturn __perf_event_overflow(event, 1, data, regs);\n }\n \n \/*\n@@ -4678,7 +4672,7 @@ static u64 perf_swevent_set_period(struct perf_event *event)\n }\n \n static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n-\t\t\t\t    int nmi, struct perf_sample_data *data,\n+\t\t\t\t    struct perf_sample_data *data,\n \t\t\t\t    struct pt_regs *regs)\n {\n \tstruct hw_perf_event *hwc = &event->hw;\n@@ -4692,7 +4686,7 @@ static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n \t\treturn;\n \n \tfor (; overflow; overflow--) {\n-\t\tif (__perf_event_overflow(event, nmi, throttle,\n+\t\tif (__perf_event_overflow(event, throttle,\n \t\t\t\t\t    data, regs)) {\n \t\t\t\/*\n \t\t\t * We inhibit the overflow from happening when\n@@ -4705,7 +4699,7 @@ static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n }\n \n static void perf_swevent_event(struct perf_event *event, u64 nr,\n-\t\t\t       int nmi, struct perf_sample_data *data,\n+\t\t\t       struct perf_sample_data *data,\n \t\t\t       struct pt_regs *regs)\n {\n \tstruct hw_perf_event *hwc = &event->hw;\n@@ -4719,12 +4713,12 @@ static void perf_swevent_event(struct perf_event *event, u64 nr,\n \t\treturn;\n \n \tif (nr == 1 && hwc->sample_period == 1 && !event->attr.freq)\n-\t\treturn perf_swevent_overflow(event, 1, nmi, data, regs);\n+\t\treturn perf_swevent_overflow(event, 1, data, regs);\n \n \tif (local64_add_negative(nr, &hwc->period_left))\n \t\treturn;\n \n-\tperf_swevent_overflow(event, 0, nmi, data, regs);\n+\tperf_swevent_overflow(event, 0, data, regs);\n }\n \n static int perf_exclude_event(struct perf_event *event,\n@@ -4812,7 +4806,7 @@ find_swevent_head(struct swevent_htable *swhash, struct perf_event *event)\n }\n \n static void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n-\t\t\t\t    u64 nr, int nmi,\n+\t\t\t\t    u64 nr,\n \t\t\t\t    struct perf_sample_data *data,\n \t\t\t\t    struct pt_regs *regs)\n {\n@@ -4828,7 +4822,7 @@ static void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n \n \thlist_for_each_entry_rcu(event, node, head, hlist_entry) {\n \t\tif (perf_swevent_match(event, type, event_id, data, regs))\n-\t\t\tperf_swevent_event(event, nr, nmi, data, regs);\n+\t\t\tperf_swevent_event(event, nr, data, regs);\n \t}\n end:\n \trcu_read_unlock();\n@@ -4849,8 +4843,7 @@ inline void perf_swevent_put_recursion_context(int rctx)\n \tput_recursion_context(swhash->recursion, rctx);\n }\n \n-void __perf_sw_event(u32 event_id, u64 nr, int nmi,\n-\t\t\t    struct pt_regs *regs, u64 addr)\n+void __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n {\n \tstruct perf_sample_data data;\n \tint rctx;\n@@ -4862,7 +4855,7 @@ void __perf_sw_event(u32 event_id, u64 nr, int nmi,\n \n \tperf_sample_data_init(&data, addr);\n \n-\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, nmi, &data, regs);\n+\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, &data, regs);\n \n \tperf_swevent_put_recursion_context(rctx);\n \tpreempt_enable_notrace();\n@@ -5110,7 +5103,7 @@ void perf_tp_event(u64 addr, u64 count, void *record, int entry_size,\n \n \thlist_for_each_entry_rcu(event, node, head, hlist_entry) {\n \t\tif (perf_tp_event_match(event, &data, regs))\n-\t\t\tperf_swevent_event(event, count, 1, &data, regs);\n+\t\t\tperf_swevent_event(event, count, &data, regs);\n \t}\n \n \tperf_swevent_put_recursion_context(rctx);\n@@ -5203,7 +5196,7 @@ void perf_bp_event(struct perf_event *bp, void *data)\n \tperf_sample_data_init(&sample, bp->attr.bp_addr);\n \n \tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n-\t\tperf_swevent_event(bp, 1, 1, &sample, regs);\n+\t\tperf_swevent_event(bp, 1, &sample, regs);\n }\n #endif\n \n@@ -5232,7 +5225,7 @@ static enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer)\n \n \tif (regs && !perf_exclude_event(event, regs)) {\n \t\tif (!(event->attr.exclude_idle && current->pid == 0))\n-\t\t\tif (perf_event_overflow(event, 0, &data, regs))\n+\t\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\t\tret = HRTIMER_NORESTART;\n \t}\n \ndiff --git a\/kernel\/events\/internal.h b\/kernel\/events\/internal.h\nindex 114f27f3a6249..09097dd8116c0 100644\n--- a\/kernel\/events\/internal.h\n+++ b\/kernel\/events\/internal.h\n@@ -27,7 +27,6 @@ struct ring_buffer {\n \tvoid\t\t\t\t*data_pages[0];\n };\n \n-\n extern void rb_free(struct ring_buffer *rb);\n extern struct ring_buffer *\n rb_alloc(int nr_pages, long watermark, int cpu, int flags);\ndiff --git a\/kernel\/events\/ring_buffer.c b\/kernel\/events\/ring_buffer.c\nindex fc2701c99207e..8b3b73630fa4c 100644\n--- a\/kernel\/events\/ring_buffer.c\n+++ b\/kernel\/events\/ring_buffer.c\n@@ -38,11 +38,8 @@ static void perf_output_wakeup(struct perf_output_handle *handle)\n {\n \tatomic_set(&handle->rb->poll, POLL_IN);\n \n-\tif (handle->nmi) {\n-\t\thandle->event->pending_wakeup = 1;\n-\t\tirq_work_queue(&handle->event->pending);\n-\t} else\n-\t\tperf_event_wakeup(handle->event);\n+\thandle->event->pending_wakeup = 1;\n+\tirq_work_queue(&handle->event->pending);\n }\n \n \/*\n@@ -102,7 +99,7 @@ static void perf_output_put_handle(struct perf_output_handle *handle)\n \n int perf_output_begin(struct perf_output_handle *handle,\n \t\t      struct perf_event *event, unsigned int size,\n-\t\t      int nmi, int sample)\n+\t\t      int sample)\n {\n \tstruct ring_buffer *rb;\n \tunsigned long tail, offset, head;\n@@ -127,7 +124,6 @@ int perf_output_begin(struct perf_output_handle *handle,\n \n \thandle->rb\t= rb;\n \thandle->event\t= event;\n-\thandle->nmi\t= nmi;\n \thandle->sample\t= sample;\n \n \tif (!rb->nr_pages)\ndiff --git a\/kernel\/sched.c b\/kernel\/sched.c\nindex 3f2e502d609bb..d08d110b89764 100644\n--- a\/kernel\/sched.c\n+++ b\/kernel\/sched.c\n@@ -2220,7 +2220,7 @@ void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n \n \tif (task_cpu(p) != new_cpu) {\n \t\tp->se.nr_migrations++;\n-\t\tperf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, 1, NULL, 0);\n+\t\tperf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);\n \t}\n \n \t__set_task_cpu(p, new_cpu);\ndiff --git a\/kernel\/watchdog.c b\/kernel\/watchdog.c\nindex 752b75ba662b2..a6708e677a0af 100644\n--- a\/kernel\/watchdog.c\n+++ b\/kernel\/watchdog.c\n@@ -211,7 +211,7 @@ static struct perf_event_attr wd_hw_attr = {\n };\n \n \/* Callback function for perf event subsystem *\/\n-static void watchdog_overflow_callback(struct perf_event *event, int nmi,\n+static void watchdog_overflow_callback(struct perf_event *event,\n \t\t struct perf_sample_data *data,\n \t\t struct pt_regs *regs)\n {\ndiff --git a\/samples\/hw_breakpoint\/data_breakpoint.c b\/samples\/hw_breakpoint\/data_breakpoint.c\nindex 063653955f9fd..7b164d3200ffe 100644\n--- a\/samples\/hw_breakpoint\/data_breakpoint.c\n+++ b\/samples\/hw_breakpoint\/data_breakpoint.c\n@@ -41,7 +41,7 @@ module_param_string(ksym, ksym_name, KSYM_NAME_LEN, S_IRUGO);\n MODULE_PARM_DESC(ksym, \"Kernel symbol to monitor; this module will report any\"\n \t\t\t\" write operations on the kernel symbol\");\n \n-static void sample_hbp_handler(struct perf_event *bp, int nmi,\n+static void sample_hbp_handler(struct perf_event *bp,\n \t\t\t       struct perf_sample_data *data,\n \t\t\t       struct pt_regs *regs)\n {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-3696","CWE_ID":"399","category":"security","commit_id":"4dc7800b866f889a1247685bbaa6dd4238a56279","commit_message":"From 4dc7800b866f889a1247685bbaa6dd4238a56279 Mon Sep 17 00:00:00 2001\nFrom: \"Alan T. DeKok\" <aland@freeradius.org>\nDate: Sat, 29 May 2010 11:26:56 +0200\nSubject: [PATCH] Fix endless loop when there are multiple DHCP options\n\n---\n src\/lib\/dhcp.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/lib\/dhcp.c b\/src\/lib\/dhcp.c\nindex d90ae2c728..2a8859453e 100644\n--- a\/src\/lib\/dhcp.c\n+++ b\/src\/lib\/dhcp.c\n@@ -714,7 +714,7 @@ int fr_dhcp_decode(RADIUS_PACKET *packet)\n \t\t\t}\n \n \t\t\t*tail = vp;\n-\t\t\twhile (*tail) tail = &vp->next;\n+\t\t\twhile (*tail) tail = &(*tail)->next;\n \t\t\tp += alen;\n \t\t} \/* loop over array entries *\/\n \t} \/* loop over the entire packet *\/\n","owner":"alandekok","repo":"freeradius-server","source":"cve"},{"CVE_ID":"CVE-2012-4467","CWE_ID":"399","category":"security","commit_id":"ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d","commit_message":"From ed6fe9d614fc1bca95eb8c0ccd0e92db00ef9d5d Mon Sep 17 00:00:00 2001\nFrom: Mikulas Patocka <mpatocka@redhat.com>\nDate: Sat, 1 Sep 2012 12:34:07 -0400\nSubject: [PATCH] Fix order of arguments to compat_put_time[spec|val]\n\nCommit 644595f89620 (\"compat: Handle COMPAT_USE_64BIT_TIME in\nnet\/socket.c\") introduced a bug where the helper functions to take\neither a 64-bit or compat time[spec|val] got the arguments in the wrong\norder, passing the kernel stack pointer off as a user pointer (and vice\nversa).\n\nBecause of the user address range check, that in turn then causes an\nEFAULT due to the user pointer range checking failing for the kernel\naddress.  Incorrectly resuling in a failed system call for 32-bit\nprocesses with a 64-bit kernel.\n\nOn odder architectures like HP-PA (with separate user\/kernel address\nspaces), it can be used read kernel memory.\n\nSigned-off-by: Mikulas Patocka <mpatocka@redhat.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n net\/socket.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/socket.c b\/net\/socket.c\nindex a5471f804d994..edc3c4af90853 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -2604,7 +2604,7 @@ static int do_siocgstamp(struct net *net, struct socket *sock,\n \terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n \tset_fs(old_fs);\n \tif (!err)\n-\t\terr = compat_put_timeval(up, &ktv);\n+\t\terr = compat_put_timeval(&ktv, up);\n \n \treturn err;\n }\n@@ -2620,7 +2620,7 @@ static int do_siocgstampns(struct net *net, struct socket *sock,\n \terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n \tset_fs(old_fs);\n \tif (!err)\n-\t\terr = compat_put_timespec(up, &kts);\n+\t\terr = compat_put_timespec(&kts, up);\n \n \treturn err;\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-0237","CWE_ID":"399","category":"security","commit_id":"b8acc83781d5a24cc5101e525d15efe0482c280d","commit_message":"From b8acc83781d5a24cc5101e525d15efe0482c280d Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Tue, 6 May 2014 18:20:39 +0000\nSubject: [PATCH] Remove loop that kept reading the same offset (Jan Kaluza)\n\n---\n src\/cdf.c | 20 ++++++--------------\n 1 file changed, 6 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/src\/cdf.c b\/src\/cdf.c\nindex f7c46aedb..c591a14a9 100644\n--- a\/src\/cdf.c\n+++ b\/src\/cdf.c\n@@ -35,7 +35,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: cdf.c,v 1.55 2014\/02\/27 23:26:17 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: cdf.c,v 1.56 2014\/05\/05 16:11:21 christos Exp $\")\n #endif\n \n #include <assert.h>\n@@ -932,7 +932,7 @@ int\n cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n     cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n {\n-\tsize_t i, maxcount;\n+\tsize_t maxcount;\n \tconst cdf_summary_info_header_t *si =\n \t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n \tconst cdf_section_declaration_t *sd =\n@@ -947,21 +947,13 @@ cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n \tssi->si_os = CDF_TOLE2(si->si_os);\n \tssi->si_class = si->si_class;\n \tcdf_swap_class(&ssi->si_class);\n-\tssi->si_count = CDF_TOLE2(si->si_count);\n+\tssi->si_count = CDF_TOLE4(si->si_count);\n \t*count = 0;\n \tmaxcount = 0;\n \t*info = NULL;\n-\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n-\t\tif (i >= CDF_LOOP_LIMIT) {\n-\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n-\t\t\terrno = EFTYPE;\n-\t\t\treturn -1;\n-\t\t}\n-\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n-\t\t    info, count, &maxcount) == -1) {\n-\t\t\treturn -1;\n-\t\t}\n-\t}\n+\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset), info,\n+\t    count, &maxcount) == -1)\n+\t\treturn -1;\n \treturn 0;\n }\n \n","owner":"glensc","repo":"file","source":"cve"},{"CVE_ID":"CVE-2011-2689","CWE_ID":"399","category":"security","commit_id":"6905d9e4dda6112f007e9090bca80507da158e63","commit_message":"From 6905d9e4dda6112f007e9090bca80507da158e63 Mon Sep 17 00:00:00 2001\nFrom: Benjamin Marzinski <bmarzins@redhat.com>\nDate: Tue, 26 Apr 2011 01:13:24 -0500\nSubject: GFS2: make sure fallocate bytes is a multiple of blksize\n\nThe GFS2 fallocate code chooses a target size to for allocating chunks of\nspace.  Whenever it can't find any resource groups with enough space free, it\nhalves its target. Since this target is in bytes, eventually it will no longer\nbe a multiple of blksize.  As long as there is more space available in the\nresource group than the target, this isn't a problem, since gfs2 will use the\nactual space available, which is always a multiple of blksize.  However,\nwhen gfs couldn't fallocate a bigger chunk than the target, it was using the\nnon-blksize aligned number. This caused a BUG in later code that required\nblksize aligned offsets.  GFS2 now ensures that bytes is always a multiple of\nblksize\n\nSigned-off-by: Benjamin Marzinski <bmarzins@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>\n---\n fs\/gfs2\/file.c | 10 ++++++++--\n 1 file changed, 8 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/gfs2\/file.c b\/fs\/gfs2\/file.c\nindex 23eab473f09d..a9f5cbe45cd9 100644\n--- a\/fs\/gfs2\/file.c\n+++ b\/fs\/gfs2\/file.c\n@@ -816,6 +816,7 @@ static long gfs2_fallocate(struct file *file, int mode, loff_t offset,\n \tloff_t bytes, max_bytes;\n \tstruct gfs2_alloc *al;\n \tint error;\n+\tloff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);\n \tloff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;\n \tnext = (next + 1) << sdp->sd_sb.sb_bsize_shift;\n \n@@ -823,13 +824,15 @@ static long gfs2_fallocate(struct file *file, int mode, loff_t offset,\n \tif (mode & ~FALLOC_FL_KEEP_SIZE)\n \t\treturn -EOPNOTSUPP;\n \n-\toffset = (offset >> sdp->sd_sb.sb_bsize_shift) <<\n-\t\t sdp->sd_sb.sb_bsize_shift;\n+\toffset &= bsize_mask;\n \n \tlen = next - offset;\n \tbytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize \/ 2;\n \tif (!bytes)\n \t\tbytes = UINT_MAX;\n+\tbytes &= bsize_mask;\n+\tif (bytes == 0)\n+\t\tbytes = sdp->sd_sb.sb_bsize;\n \n \tgfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);\n \terror = gfs2_glock_nq(&ip->i_gh);\n@@ -860,6 +863,9 @@ retry:\n \t\tif (error) {\n \t\t\tif (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {\n \t\t\t\tbytes >>= 1;\n+\t\t\t\tbytes &= bsize_mask;\n+\t\t\t\tif (bytes == 0)\n+\t\t\t\t\tbytes = sdp->sd_sb.sb_bsize;\n \t\t\t\tgoto retry;\n \t\t\t}\n \t\t\tgoto out_qunlock;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8959","CWE_ID":"399","category":"security","commit_id":"3ab016764c7f787829d9065440d86f5609765110","commit_message":"From 3ab016764c7f787829d9065440d86f5609765110 Mon Sep 17 00:00:00 2001\nFrom: cristy <urban-warrior@git.imagemagick.org>\nDate: Sun, 11 Jan 2015 19:18:02 +0000\nSubject: [PATCH] \n http:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=3&t=26861\n\n---\n coders\/dds.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/coders\/dds.c b\/coders\/dds.c\nindex 974fdaa65f..2483ef20ce 100644\n--- a\/coders\/dds.c\n+++ b\/coders\/dds.c\n@@ -2435,8 +2435,8 @@ static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n       {\n         offset = (MagickOffsetType) w * h * pixel_size;\n-        (void) SeekBlob(image, offset, SEEK_CUR);\n-\n+        if (SeekBlob(image,offset,SEEK_CUR) < 0)\n+          break;\n         w = DIV2(w);\n         h = DIV2(h);\n       }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-4008","CWE_ID":"399","category":"security","commit_id":"a6e0a0b58f5cdaf4e9beca5bce69c09808cbb625","commit_message":"From a6e0a0b58f5cdaf4e9beca5bce69c09808cbb625 Mon Sep 17 00:00:00 2001\nFrom: Nikos Mavrogiannopoulos <nmav@redhat.com>\nDate: Wed, 6 Apr 2016 13:02:19 +0200\nSubject: [PATCH] _asn1_extract_der_octet: properly account the bytes read\n through indefinite encodings\n\nThis prevents infinite recursions in the function loop.\nReported by Pascal Cuoq.\n---\n lib\/decoding.c | 12 ++++++++----\n 1 file changed, 8 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/lib\/decoding.c b\/lib\/decoding.c\nindex 6fd60d0..4fff03e 100644\n--- a\/lib\/decoding.c\n+++ b\/lib\/decoding.c\n@@ -753,7 +753,7 @@ _asn1_delete_not_used (asn1_node node)\n \n static int\n _asn1_extract_der_octet (asn1_node node, const unsigned char *der,\n-\t\t\t int der_len, unsigned flags)\n+\t\t\t int der_len, unsigned flags, int *bytes)\n {\n   int len2, len3;\n   int counter, counter_end;\n@@ -799,15 +799,19 @@ _asn1_extract_der_octet (asn1_node node, const unsigned char *der,\n \t  DECR_LEN(der_len, len3);\n \t  result =\n \t    _asn1_extract_der_octet (node, der + counter + len3,\n-\t\t\t\t     der_len, flags);\n+\t\t\t\t     der_len, flags, &len2);\n \t  if (result != ASN1_SUCCESS)\n \t    return result;\n-\t  len2 = 0;\n+\n+\t  DECR_LEN(der_len, len2);\n \t}\n \n       counter += len2 + len3 + 1;\n     }\n \n+  if (bytes)\n+    *bytes = counter;\n+\n   return ASN1_SUCCESS;\n \n cleanup:\n@@ -889,7 +893,7 @@ get_octet_string (asn1_node node, const unsigned char *der, int der_len,\n \t  asn1_length_der (tot_len, temp, &len2);\n \t  _asn1_set_value (node, temp, len2);\n \n-\t  ret = _asn1_extract_der_octet (node, der, orig_der_len, flags);\n+\t  ret = _asn1_extract_der_octet (node, der, orig_der_len, flags, NULL);\n \t  if (ret != ASN1_SUCCESS)\n \t    {\n \t      warn();\n-- \n1.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-14058","CWE_ID":"399","category":"security","commit_id":"7ec414892ddcad88313848494b6fc5f437c9ca4a","commit_message":"From 7ec414892ddcad88313848494b6fc5f437c9ca4a Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sat, 26 Aug 2017 01:26:58 +0200\nSubject: [PATCH] avformat\/hls: Fix DoS due to infinite loop\n\nFixes: loop.m3u\n\nThe default max iteration count of 1000 is arbitrary and ideas for a better solution are welcome\n\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\n\nPrevious version reviewed-by: Steven Liu <lingjiujianke@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n doc\/demuxers.texi | 18 ++++++++++++++++++\n libavformat\/hls.c |  7 +++++++\n 2 files changed, 25 insertions(+)\n\n","diff_code":"diff --git a\/doc\/demuxers.texi b\/doc\/demuxers.texi\nindex 29a23d48b25..73dc0feec19 100644\n--- a\/doc\/demuxers.texi\n+++ b\/doc\/demuxers.texi\n@@ -300,6 +300,24 @@ used to end the output video at the length of the shortest input file,\n which in this case is @file{input.mp4} as the GIF in this example loops\n infinitely.\n \n+@section hls\n+\n+HLS demuxer\n+\n+It accepts the following options:\n+\n+@table @option\n+@item live_start_index\n+segment index to start live streams at (negative values are from the end).\n+\n+@item allowed_extensions\n+',' separated list of file extensions that hls is allowed to access.\n+\n+@item max_reload\n+Maximum number of times a insufficient list is attempted to be reloaded.\n+Default value is 1000.\n+@end table\n+\n @section image2\n \n Image file demuxer.\ndiff --git a\/libavformat\/hls.c b\/libavformat\/hls.c\nindex 01731bd36b0..0995345bbf2 100644\n--- a\/libavformat\/hls.c\n+++ b\/libavformat\/hls.c\n@@ -205,6 +205,7 @@ typedef struct HLSContext {\n     AVDictionary *avio_opts;\n     int strict_std_compliance;\n     char *allowed_extensions;\n+    int max_reload;\n } HLSContext;\n \n static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)\n@@ -1263,6 +1264,7 @@ static int read_data(void *opaque, uint8_t *buf, int buf_size)\n     HLSContext *c = v->parent->priv_data;\n     int ret, i;\n     int just_opened = 0;\n+    int reload_count = 0;\n \n restart:\n     if (!v->needed)\n@@ -1294,6 +1296,9 @@ static int read_data(void *opaque, uint8_t *buf, int buf_size)\n         reload_interval = default_reload_interval(v);\n \n reload:\n+        reload_count++;\n+        if (reload_count > c->max_reload)\n+            return AVERROR_EOF;\n         if (!v->finished &&\n             av_gettime_relative() - v->last_load_time >= reload_interval) {\n             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n@@ -2150,6 +2155,8 @@ static const AVOption hls_options[] = {\n         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,\n         {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},\n         INT_MIN, INT_MAX, FLAGS},\n+    {\"max_reload\", \"Maximum number of times a insufficient list is attempted to be reloaded\",\n+        OFFSET(max_reload), AV_OPT_TYPE_INT, {.i64 = 1000}, 0, INT_MAX, FLAGS},\n     {NULL}\n };\n \n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-9461","CWE_ID":"399","category":"security","commit_id":"10c3e3923022485c720f322ca4f0aca5d7501310","commit_message":"From 10c3e3923022485c720f322ca4f0aca5d7501310 Mon Sep 17 00:00:00 2001\nFrom: Jeremy Allison <jra@samba.org>\nDate: Wed, 15 Feb 2017 15:42:52 -0800\nSubject: [PATCH] s3: smbd: Don't loop infinitely on bad-symlink resolution.\n\nIn the FILE_OPEN_IF case we have O_CREAT, but not\nO_EXCL. Previously we went into a loop trying first\n~(O_CREAT|O_EXCL), and if that returned ENOENT\ntry (O_CREAT|O_EXCL). We kept looping indefinately\nuntil we got an error, or the file was created or\nopened.\n\nThe big problem here is dangling symlinks. Opening\nwithout O_NOFOLLOW means both bad symlink\nand missing path return -1, ENOENT from open(). As POSIX\nis pathname based it's not possible to tell\nthe difference between these two cases in a\nnon-racy way, so change to try only two attempts before\ngiving up.\n\nWe don't have this problem for the O_NOFOLLOW\ncase as we just return NT_STATUS_OBJECT_PATH_NOT_FOUND\nmapped from the ELOOP POSIX error and immediately\nreturned.\n\nUnroll the loop logic to two tries instead.\n\nBUG: https:\/\/bugzilla.samba.org\/show_bug.cgi?id=12572\n\nPair-programmed-with: Ralph Boehme <slow@samba.org>\n\nSigned-off-by: Jeremy Allison <jra@samba.org>\nSigned-off-by: Ralph Boehme <slow@samba.org>\nReviewed-by: Ralph Boehme <slow@samba.org>\n---\n source3\/smbd\/open.c | 104 ++++++++++++++++++++++++--------------------\n 1 file changed, 56 insertions(+), 48 deletions(-)\n\n","diff_code":"diff --git a\/source3\/smbd\/open.c b\/source3\/smbd\/open.c\nindex 931d76df44f..37c630b7e5a 100644\n--- a\/source3\/smbd\/open.c\n+++ b\/source3\/smbd\/open.c\n@@ -640,7 +640,9 @@ static NTSTATUS fd_open_atomic(struct connection_struct *conn,\n \t\t\tbool *file_created)\n {\n \tNTSTATUS status = NT_STATUS_UNSUCCESSFUL;\n+\tNTSTATUS retry_status;\n \tbool file_existed = VALID_STAT(fsp->fsp_name->st);\n+\tint curr_flags;\n \n \t*file_created = false;\n \n@@ -672,59 +674,65 @@ static NTSTATUS fd_open_atomic(struct connection_struct *conn,\n \t * we can never call O_CREAT without O_EXCL. So if\n \t * we think the file existed, try without O_CREAT|O_EXCL.\n \t * If we think the file didn't exist, try with\n-\t * O_CREAT|O_EXCL. Keep bouncing between these two\n-\t * requests until either the file is created, or\n-\t * opened. Either way, we keep going until we get\n-\t * a returnable result (error, or open\/create).\n+\t * O_CREAT|O_EXCL.\n+\t *\n+\t * The big problem here is dangling symlinks. Opening\n+\t * without O_NOFOLLOW means both bad symlink\n+\t * and missing path return -1, ENOENT from open(). As POSIX\n+\t * is pathname based it's not possible to tell\n+\t * the difference between these two cases in a\n+\t * non-racy way, so change to try only two attempts before\n+\t * giving up.\n+\t *\n+\t * We don't have this problem for the O_NOFOLLOW\n+\t * case as it just returns NT_STATUS_OBJECT_PATH_NOT_FOUND\n+\t * mapped from the ELOOP POSIX error.\n \t *\/\n \n-\twhile(1) {\n-\t\tint curr_flags = flags;\n+\tcurr_flags = flags;\n \n-\t\tif (file_existed) {\n-\t\t\t\/* Just try open, do not create. *\/\n-\t\t\tcurr_flags &= ~(O_CREAT);\n-\t\t\tstatus = fd_open(conn, fsp, curr_flags, mode);\n-\t\t\tif (NT_STATUS_EQUAL(status,\n-\t\t\t\t\tNT_STATUS_OBJECT_NAME_NOT_FOUND)) {\n-\t\t\t\t\/*\n-\t\t\t\t * Someone deleted it in the meantime.\n-\t\t\t\t * Retry with O_EXCL.\n-\t\t\t\t *\/\n-\t\t\t\tfile_existed = false;\n-\t\t\t\tDEBUG(10,(\"fd_open_atomic: file %s existed. \"\n-\t\t\t\t\t\"Retry.\\n\",\n-\t\t\t\t\tsmb_fname_str_dbg(fsp->fsp_name)));\n-\t\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t} else {\n-\t\t\t\/* Try create exclusively, fail if it exists. *\/\n-\t\t\tcurr_flags |= O_EXCL;\n-\t\t\tstatus = fd_open(conn, fsp, curr_flags, mode);\n-\t\t\tif (NT_STATUS_EQUAL(status,\n-\t\t\t\t\tNT_STATUS_OBJECT_NAME_COLLISION)) {\n-\t\t\t\t\/*\n-\t\t\t\t * Someone created it in the meantime.\n-\t\t\t\t * Retry without O_CREAT.\n-\t\t\t\t *\/\n-\t\t\t\tfile_existed = true;\n-\t\t\t\tDEBUG(10,(\"fd_open_atomic: file %s \"\n-\t\t\t\t\t\"did not exist. Retry.\\n\",\n-\t\t\t\t\tsmb_fname_str_dbg(fsp->fsp_name)));\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tif (NT_STATUS_IS_OK(status)) {\n-\t\t\t\t\/*\n-\t\t\t\t * Here we've opened with O_CREAT|O_EXCL\n-\t\t\t\t * and got success. We *know* we created\n-\t\t\t\t * this file.\n-\t\t\t\t *\/\n-\t\t\t\t*file_created = true;\n-\t\t\t}\n+\tif (file_existed) {\n+\t\tcurr_flags &= ~(O_CREAT);\n+\t\tretry_status = NT_STATUS_OBJECT_NAME_NOT_FOUND;\n+\t} else {\n+\t\tcurr_flags |= O_EXCL;\n+\t\tretry_status = NT_STATUS_OBJECT_NAME_COLLISION;\n+\t}\n+\n+\tstatus = fd_open(conn, fsp, curr_flags, mode);\n+\tif (NT_STATUS_IS_OK(status)) {\n+\t\tif (!file_existed) {\n+\t\t\t*file_created = true;\n \t\t}\n-\t\t\/* Create is done, or failed. *\/\n-\t\tbreak;\n+\t\treturn NT_STATUS_OK;\n \t}\n+\tif (!NT_STATUS_EQUAL(status, retry_status)) {\n+\t\treturn status;\n+\t}\n+\n+\tcurr_flags = flags;\n+\n+\t\/*\n+\t * Keep file_existed up to date for clarity.\n+\t *\/\n+\tif (NT_STATUS_EQUAL(status, NT_STATUS_OBJECT_NAME_NOT_FOUND)) {\n+\t\tfile_existed = false;\n+\t\tcurr_flags |= O_EXCL;\n+\t\tDBG_DEBUG(\"file %s did not exist. Retry.\\n\",\n+\t\t\tsmb_fname_str_dbg(fsp->fsp_name));\n+\t} else {\n+\t\tfile_existed = true;\n+\t\tcurr_flags &= ~(O_CREAT);\n+\t\tDBG_DEBUG(\"file %s existed. Retry.\\n\",\n+\t\t\tsmb_fname_str_dbg(fsp->fsp_name));\n+\t}\n+\n+\tstatus = fd_open(conn, fsp, curr_flags, mode);\n+\n+\tif (NT_STATUS_IS_OK(status) && (!file_existed)) {\n+\t\t*file_created = true;\n+\t}\n+\n \treturn status;\n }\n \n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-13310","CWE_ID":"399","category":"security","commit_id":"5982632109cad48bc6dab867298fdea4dea57c51","commit_message":"From 5982632109cad48bc6dab867298fdea4dea57c51 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 23 Jun 2019 11:47:36 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1616\n\n---\n wand\/mogrify.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/wand\/mogrify.c b\/wand\/mogrify.c\nindex d641914f7..fca494d2c 100644\n--- a\/wand\/mogrify.c\n+++ b\/wand\/mogrify.c\n@@ -7923,6 +7923,8 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n               channel,metric,&distortion,exception);\n             if (difference_image == (Image *) NULL)\n               break;\n+            reconstruct_image=DestroyImage(reconstruct_image);\n+            image=DestroyImage(image);\n             if (*images != (Image *) NULL)\n               *images=DestroyImageList(*images);\n             *images=difference_image;\n@@ -8265,6 +8267,7 @@ WandExport MagickBooleanType MogrifyImageList(ImageInfo *image_info,\n                    q=GetImageFromList(*images,index-1);\n                    if (q == (Image *) NULL)\n                      {\n+                       p=DestroyImage(p);\n                        (void) ThrowMagickException(exception,GetMagickModule(),\n                          OptionError,\"NoSuchImage\",\"`%s'\",argv[i+1]);\n                        status=MagickFalse;\n","owner":"ImageMagick","repo":"ImageMagick6","source":"cve"},{"CVE_ID":"CVE-2019-11463","CWE_ID":"399","category":"security","commit_id":"ba641f73f3d758d9032b3f0e5597a9c6e593a505","commit_message":"From ba641f73f3d758d9032b3f0e5597a9c6e593a505 Mon Sep 17 00:00:00 2001\nFrom: Martin Matuska <martin@matuska.org>\nDate: Sun, 21 Apr 2019 00:53:02 +0200\nSubject: [PATCH] Fix typo in preprocessor macro in\n archive_read_format_zip_cleanup()\n\nFrees lzma_stream on cleanup()\n\nFixes #1165\n---\n libarchive\/archive_read_support_format_zip.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libarchive\/archive_read_support_format_zip.c b\/libarchive\/archive_read_support_format_zip.c\nindex 677c43709..6937969c1 100644\n--- a\/libarchive\/archive_read_support_format_zip.c\n+++ b\/libarchive\/archive_read_support_format_zip.c\n@@ -2751,7 +2751,7 @@ archive_read_format_zip_cleanup(struct archive_read *a)\n \t\tinflateEnd(&zip->stream);\n #endif\n \n-#if HAVA_LZMA_H && HAVE_LIBLZMA\n+#if HAVE_LZMA_H && HAVE_LIBLZMA\n     if (zip->zipx_lzma_valid) {\n \t\tlzma_end(&zip->zipx_lzma_stream);\n \t}\n","owner":"libarchive","repo":"libarchive","source":"cve"},{"CVE_ID":"CVE-2013-4592","CWE_ID":"399","category":"security","commit_id":"e40f193f5bb022e927a57a4f5d5194e4f12ddb74","commit_message":"From e40f193f5bb022e927a57a4f5d5194e4f12ddb74 Mon Sep 17 00:00:00 2001\nFrom: Alex Williamson <alex.williamson@redhat.com>\nDate: Mon, 10 Dec 2012 10:32:57 -0700\nSubject: KVM: Fix iommu map\/unmap to handle memory slot moves\n\nThe iommu integration into memory slots expects memory slots to be\nadded or removed and doesn't handle the move case.  We can unmap\nslots from the iommu after we mark them invalid and map them before\ninstalling the final memslot array.  Also re-order the kmemdup vs\nmap so we don't leave iommu mappings if we get ENOMEM.\n\nReviewed-by: Gleb Natapov <gleb@redhat.com>\nSigned-off-by: Alex Williamson <alex.williamson@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\n---\n virt\/kvm\/kvm_main.c | 19 +++++++++++--------\n 1 file changed, 11 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/virt\/kvm\/kvm_main.c b\/virt\/kvm\/kvm_main.c\nindex e4d358195e54..9a56ca2fa257 100644\n--- a\/virt\/kvm\/kvm_main.c\n+++ b\/virt\/kvm\/kvm_main.c\n@@ -822,6 +822,8 @@ int __kvm_set_memory_region(struct kvm *kvm,\n \t\told_memslots = kvm->memslots;\n \t\trcu_assign_pointer(kvm->memslots, slots);\n \t\tsynchronize_srcu_expedited(&kvm->srcu);\n+\t\t\/* slot was deleted or moved, clear iommu mapping *\/\n+\t\tkvm_iommu_unmap_pages(kvm, &old);\n \t\t\/* From this point no new shadow pages pointing to a deleted,\n \t\t * or moved, memslot will be created.\n \t\t *\n@@ -837,20 +839,19 @@ int __kvm_set_memory_region(struct kvm *kvm,\n \tif (r)\n \t\tgoto out_free;\n \n-\t\/* map\/unmap the pages in iommu page table *\/\n-\tif (npages) {\n-\t\tr = kvm_iommu_map_pages(kvm, &new);\n-\t\tif (r)\n-\t\t\tgoto out_free;\n-\t} else\n-\t\tkvm_iommu_unmap_pages(kvm, &old);\n-\n \tr = -ENOMEM;\n \tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n \t\t\tGFP_KERNEL);\n \tif (!slots)\n \t\tgoto out_free;\n \n+\t\/* map new memory slot into the iommu *\/\n+\tif (npages) {\n+\t\tr = kvm_iommu_map_pages(kvm, &new);\n+\t\tif (r)\n+\t\t\tgoto out_slots;\n+\t}\n+\n \t\/* actual memory is freed via old in kvm_free_physmem_slot below *\/\n \tif (!npages) {\n \t\tnew.dirty_bitmap = NULL;\n@@ -869,6 +870,8 @@ int __kvm_set_memory_region(struct kvm *kvm,\n \n \treturn 0;\n \n+out_slots:\n+\tkfree(slots);\n out_free:\n \tkvm_free_physmem_slot(&new, &old);\n out:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-0207","CWE_ID":"399","category":"security","commit_id":"a8c1f65c79cbbb2f7da782d4c9d15639a9b94b27","commit_message":"From a8c1f65c79cbbb2f7da782d4c9d15639a9b94b27 Mon Sep 17 00:00:00 2001\nFrom: Ben Hutchings <ben@decadent.org.uk>\nDate: Mon, 9 Jan 2012 14:06:46 -0800\nSubject: [PATCH] igmp: Avoid zero delay when receiving odd mixture of IGMP\n queries\n\nCommit 5b7c84066733c5dfb0e4016d939757b38de189e4 ('ipv4: correct IGMP\nbehavior on v3 query during v2-compatibility mode') added yet another\ncase for query parsing, which can result in max_delay = 0.  Substitute\na value of 1, as in the usual v3 case.\n\nReported-by: Simon McVittie <smcv@debian.org>\nReferences: http:\/\/bugs.debian.org\/654876\nSigned-off-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/igmp.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/net\/ipv4\/igmp.c b\/net\/ipv4\/igmp.c\nindex fa057d105befe..5104bc0bbdbe7 100644\n--- a\/net\/ipv4\/igmp.c\n+++ b\/net\/ipv4\/igmp.c\n@@ -880,6 +880,8 @@ static void igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb,\n \t\t * to be intended in a v3 query.\n \t\t *\/\n \t\tmax_delay = IGMPV3_MRC(ih3->code)*(HZ\/IGMP_TIMER_SCALE);\n+\t\tif (!max_delay)\n+\t\t\tmax_delay = 1;\t\/* can't mod w\/ 0 *\/\n \t} else { \/* v3 *\/\n \t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))\n \t\t\treturn;\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-2109","CWE_ID":"399","category":"security","commit_id":"c62981390d6cf9e3d612c489b8b77c2913b25807","commit_message":"From c62981390d6cf9e3d612c489b8b77c2913b25807 Mon Sep 17 00:00:00 2001\nFrom: \"Dr. Stephen Henson\" <steve@openssl.org>\nDate: Mon, 11 Apr 2016 13:57:20 +0100\nSubject: [PATCH] Harden ASN.1 BIO handling of large amounts of data.\n\nIf the ASN.1 BIO is presented with a large length field read it in\nchunks of increasing size checking for EOF on each read. This prevents\nsmall files allocating excessive amounts of data.\n\nCVE-2016-2109\n\nThanks to Brian Carpenter for reporting this issue.\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\n---\n crypto\/asn1\/a_d2i_fp.c | 36 ++++++++++++++++++++++++++----------\n 1 file changed, 26 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/asn1\/a_d2i_fp.c b\/crypto\/asn1\/a_d2i_fp.c\nindex 5ba6e1d1da..b030bf24dc 100644\n--- a\/crypto\/asn1\/a_d2i_fp.c\n+++ b\/crypto\/asn1\/a_d2i_fp.c\n@@ -138,6 +138,7 @@ void *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x)\n #endif\n \n #define HEADER_SIZE   8\n+#define ASN1_CHUNK_INITIAL_SIZE (16 * 1024)\n static int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)\n {\n     BUF_MEM *b;\n@@ -216,29 +217,44 @@ static int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)\n             \/* suck in slen bytes of data *\/\n             want = slen;\n             if (want > (len - off)) {\n+                size_t chunk_max = ASN1_CHUNK_INITIAL_SIZE;\n+\n                 want -= (len - off);\n                 if (want > INT_MAX \/* BIO_read takes an int length *\/  ||\n                     len + want < len) {\n                     ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_TOO_LONG);\n                     goto err;\n                 }\n-                if (!BUF_MEM_grow_clean(b, len + want)) {\n-                    ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);\n-                    goto err;\n-                }\n                 while (want > 0) {\n-                    i = BIO_read(in, &(b->data[len]), want);\n-                    if (i <= 0) {\n-                        ASN1err(ASN1_F_ASN1_D2I_READ_BIO,\n-                                ASN1_R_NOT_ENOUGH_DATA);\n+                    \/*\n+                     * Read content in chunks of increasing size\n+                     * so we can return an error for EOF without\n+                     * having to allocate the entire content length\n+                     * in one go.\n+                     *\/\n+                    size_t chunk = want > chunk_max ? chunk_max : want;\n+\n+                    if (!BUF_MEM_grow_clean(b, len + chunk)) {\n+                        ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);\n                         goto err;\n                     }\n+                    want -= chunk;\n+                    while (chunk > 0) {\n+                        i = BIO_read(in, &(b->data[len]), chunk);\n+                        if (i <= 0) {\n+                            ASN1err(ASN1_F_ASN1_D2I_READ_BIO,\n+                                    ASN1_R_NOT_ENOUGH_DATA);\n+                            goto err;\n+                        }\n                     \/*\n                      * This can't overflow because |len+want| didn't\n                      * overflow.\n                      *\/\n-                    len += i;\n-                    want -= i;\n+                        len += i;\n+                        chunk -= i;\n+                    }\n+                    if (chunk_max < INT_MAX\/2)\n+                        chunk_max *= 2;\n                 }\n             }\n             if (off + slen < off) {\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-13137","CWE_ID":"399","category":"security","commit_id":"35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34","commit_message":"From 35ccb468ee2dcbe8ce9cf1e2f1957acc27f54c34 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 18 Jun 2019 11:53:27 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1601\n\n---\n coders\/ps.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/coders\/ps.c b\/coders\/ps.c\nindex d599ab7047..cf5fc70580 100644\n--- a\/coders\/ps.c\n+++ b\/coders\/ps.c\n@@ -744,6 +744,7 @@ static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         {\n           (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n             \"InvalidGeometry\",\"`%s'\",option);\n+          page_geometry=DestroyString(page_geometry);\n           image=DestroyImage(image);\n           return((Image *) NULL);\n         }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2014-9637","CWE_ID":"399","category":"security","commit_id":"0c08d7a902c6fdd49b704623a12d8d672ef18944","commit_message":"From 0c08d7a902c6fdd49b704623a12d8d672ef18944 Mon Sep 17 00:00:00 2001\nFrom: Andreas Gruenbacher <agruen@gnu.org>\nDate: Tue, 20 Jan 2015 12:20:00 +0100\nSubject: Fail when out of memory in set_hunkmax()\n\nsrc\/pch.c (another_hunk): Call set_hunkmax() from here to make sure it is\ncalled even when falling back from plan A to plan B.\n(open_patch_file): No need to call set_hunkmax() anymore.\nsrc\/pch.c (set_hunkmax): Fail when out of memory. Make static.\nsrc\/pch.h: Remove set_hunkmax() prototype.\n---\n src\/pch.c | 11 ++++++-----\n src\/pch.h |  1 -\n 2 files changed, 6 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/src\/pch.c b\/src\/pch.c\nindex 145c4ef..33facd9 100644\n--- a\/src\/pch.c\n+++ b\/src\/pch.c\n@@ -158,20 +158,19 @@ open_patch_file (char const *filename)\n     if (p_filesize != (file_offset) p_filesize)\n       fatal (\"patch file is too long\");\n     next_intuit_at (file_pos, 1);\n-    set_hunkmax();\n }\n \n \/* Make sure our dynamically realloced tables are malloced to begin with. *\/\n \n-void\n+static void\n set_hunkmax (void)\n {\n     if (!p_line)\n-\tp_line = (char **) malloc (hunkmax * sizeof *p_line);\n+\tp_line = (char **) xmalloc (hunkmax * sizeof *p_line);\n     if (!p_len)\n-\tp_len = (size_t *) malloc (hunkmax * sizeof *p_len);\n+\tp_len = (size_t *) xmalloc (hunkmax * sizeof *p_len);\n     if (!p_Char)\n-\tp_Char = malloc (hunkmax * sizeof *p_Char);\n+\tp_Char = xmalloc (hunkmax * sizeof *p_Char);\n }\n \n \/* Enlarge the arrays containing the current hunk of patch. *\/\n@@ -1173,6 +1172,8 @@ another_hunk (enum diff difftype, bool rev)\n     char numbuf2[LINENUM_LENGTH_BOUND + 1];\n     char numbuf3[LINENUM_LENGTH_BOUND + 1];\n \n+    set_hunkmax();\n+\n     while (p_end >= 0) {\n \tif (p_end == p_efake)\n \t    p_end = p_bfake;\t\t\/* don't free twice *\/\ndiff --git a\/src\/pch.h b\/src\/pch.h\nindex 0c7ff62..9565ac4 100644\n--- a\/src\/pch.h\n+++ b\/src\/pch.h\n@@ -46,7 +46,6 @@ bool pch_rename (void) _GL_ATTRIBUTE_PURE;\n void do_ed_script (char const *, char const *, bool *, FILE *);\n void open_patch_file (char const *);\n void re_patch (void);\n-void set_hunkmax (void);\n void pch_normalize (enum diff);\n \n XTERN struct timespec p_timestamp[2];  \/* timestamps in patch headers *\/\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-2723","CWE_ID":"399","category":"security","commit_id":"17dd759c67f21e34f2156abcf415e1f60605a188","commit_message":"From 17dd759c67f21e34f2156abcf415e1f60605a188 Mon Sep 17 00:00:00 2001\nFrom: Herbert Xu <herbert@gondor.apana.org.au>\nDate: Wed, 27 Jul 2011 06:16:28 -0700\nSubject: gro: Only reset frag0 when skb can be pulled\n\nCurrently skb_gro_header_slow unconditionally resets frag0 and\nfrag0_len.  However, when we can't pull on the skb this leaves\nthe GRO fields in an inconsistent state.\n\nThis patch fixes this by only resetting those fields after the\npskb_may_pull test.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/linux\/netdevice.h | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/include\/linux\/netdevice.h b\/include\/linux\/netdevice.h\nindex 1d92acc0777b..661a07746e94 100644\n--- a\/include\/linux\/netdevice.h\n+++ b\/include\/linux\/netdevice.h\n@@ -1649,9 +1649,12 @@ static inline int skb_gro_header_hard(struct sk_buff *skb, unsigned int hlen)\n static inline void *skb_gro_header_slow(struct sk_buff *skb, unsigned int hlen,\n \t\t\t\t\tunsigned int offset)\n {\n+\tif (!pskb_may_pull(skb, hlen))\n+\t\treturn NULL;\n+\n \tNAPI_GRO_CB(skb)->frag0 = NULL;\n \tNAPI_GRO_CB(skb)->frag0_len = 0;\n-\treturn pskb_may_pull(skb, hlen) ? skb->data + offset : NULL;\n+\treturn skb->data + offset;\n }\n \n static inline void *skb_gro_mac_header(struct sk_buff *skb)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-20467","CWE_ID":"399","category":"security","commit_id":"db0add932fb850d762b02604ca3053b7d7ab6deb","commit_message":"From db0add932fb850d762b02604ca3053b7d7ab6deb Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 6 Dec 2018 20:37:59 -0500\nSubject: [PATCH] Prevent infinite loop\n\n---\n coders\/bmp.c | 13 ++++++-------\n 1 file changed, 6 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/coders\/bmp.c b\/coders\/bmp.c\nindex 49fddd6436..edc5cda546 100644\n--- a\/coders\/bmp.c\n+++ b\/coders\/bmp.c\n@@ -660,7 +660,7 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         bmp_info.x_pixels=ReadBlobLSBLong(image);\n         bmp_info.y_pixels=ReadBlobLSBLong(image);\n         bmp_info.number_colors=ReadBlobLSBLong(image);\n-        if (bmp_info.number_colors > GetBlobSize(image))\n+        if ((MagickSizeType) bmp_info.number_colors > GetBlobSize(image))\n           ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         bmp_info.colors_important=ReadBlobLSBLong(image);\n         if (image->debug != MagickFalse)\n@@ -1444,13 +1444,12 @@ static Image *ReadBMPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     if (image_info->number_scenes != 0)\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n+    offset=(MagickOffsetType) bmp_info.ba_offset;\n+    if (offset != 0)\n+      if ((offset < TellBlob(image)) ||\n+          (SeekBlob(image,offset,SEEK_SET) != offset))\n+        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     *magick='\\0';\n-    if (bmp_info.ba_offset != 0)\n-      {\n-        offset=SeekBlob(image,(MagickOffsetType) bmp_info.ba_offset,SEEK_SET);\n-        if (offset < 0)\n-          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n-      }\n     count=ReadBlob(image,2,magick);\n     if ((count == 2) && (IsBMP(magick,2) != MagickFalse))\n       {\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2014-7841","CWE_ID":"399","category":"security","commit_id":"e40607cbe270a9e8360907cb1e62ddf0736e4864","commit_message":"From e40607cbe270a9e8360907cb1e62ddf0736e4864 Mon Sep 17 00:00:00 2001\nFrom: Daniel Borkmann <dborkman@redhat.com>\nDate: Mon, 10 Nov 2014 17:54:26 +0100\nSubject: [PATCH] net: sctp: fix NULL pointer dereference in\n af->from_addr_param on malformed packet\n\nAn SCTP server doing ASCONF will panic on malformed INIT ping-of-death\nin the form of:\n\n  ------------ INIT[PARAM: SET_PRIMARY_IP] ------------>\n\nWhile the INIT chunk parameter verification dissects through many things\nin order to detect malformed input, it misses to actually check parameters\ninside of parameters. E.g. RFC5061, section 4.2.4 proposes a 'set primary\nIP address' parameter in ASCONF, which has as a subparameter an address\nparameter.\n\nSo an attacker may send a parameter type other than SCTP_PARAM_IPV4_ADDRESS\nor SCTP_PARAM_IPV6_ADDRESS, param_type2af() will subsequently return 0\nand thus sctp_get_af_specific() returns NULL, too, which we then happily\ndereference unconditionally through af->from_addr_param().\n\nThe trace for the log:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000078\nIP: [<ffffffffa01e9c62>] sctp_process_init+0x492\/0x990 [sctp]\nPGD 0\nOops: 0000 [#1] SMP\n[...]\nPid: 0, comm: swapper Not tainted 2.6.32-504.el6.x86_64 #1 Bochs Bochs\nRIP: 0010:[<ffffffffa01e9c62>]  [<ffffffffa01e9c62>] sctp_process_init+0x492\/0x990 [sctp]\n[...]\nCall Trace:\n <IRQ>\n [<ffffffffa01f2add>] ? sctp_bind_addr_copy+0x5d\/0xe0 [sctp]\n [<ffffffffa01e1fcb>] sctp_sf_do_5_1B_init+0x21b\/0x340 [sctp]\n [<ffffffffa01e3751>] sctp_do_sm+0x71\/0x1210 [sctp]\n [<ffffffffa01e5c09>] ? sctp_endpoint_lookup_assoc+0xc9\/0xf0 [sctp]\n [<ffffffffa01e61f6>] sctp_endpoint_bh_rcv+0x116\/0x230 [sctp]\n [<ffffffffa01ee986>] sctp_inq_push+0x56\/0x80 [sctp]\n [<ffffffffa01fcc42>] sctp_rcv+0x982\/0xa10 [sctp]\n [<ffffffffa01d5123>] ? ipt_local_in_hook+0x23\/0x28 [iptable_filter]\n [<ffffffff8148bdc9>] ? nf_iterate+0x69\/0xb0\n [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0\/0x2d0\n [<ffffffff8148bf86>] ? nf_hook_slow+0x76\/0x120\n [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0\/0x2d0\n[...]\n\nA minimal way to address this is to check for NULL as we do on all\nother such occasions where we know sctp_get_af_specific() could\npossibly return with NULL.\n\nFixes: d6de3097592b (\"[SCTP]: Add the handling of \"Set Primary IP Address\" parameter to INIT\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Vlad Yasevich <vyasevich@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/sctp\/sm_make_chunk.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/net\/sctp\/sm_make_chunk.c b\/net\/sctp\/sm_make_chunk.c\nindex ab734be8cb209..9f32741abb1c7 100644\n--- a\/net\/sctp\/sm_make_chunk.c\n+++ b\/net\/sctp\/sm_make_chunk.c\n@@ -2609,6 +2609,9 @@ static int sctp_process_param(struct sctp_association *asoc,\n \t\taddr_param = param.v + sizeof(sctp_addip_param_t);\n \n \t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n+\t\tif (af == NULL)\n+\t\t\tbreak;\n+\n \t\taf->from_addr_param(&addr, addr_param,\n \t\t\t\t    htons(asoc->peer.port), 0);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1575","CWE_ID":"399","category":"security","commit_id":"65c4d4ad331e94661de763e9b5304d28698999c4","commit_message":"From 65c4d4ad331e94661de763e9b5304d28698999c4 Mon Sep 17 00:00:00 2001\nFrom: Frank DENIS <github@pureftpd.org>\nDate: Mon, 7 Mar 2011 23:50:46 +0100\nSubject: [PATCH] Flush the command buffer after switching to TLS. Fixes a flaw\n similar to CVE-2011-0411.\n\n---\n src\/ftp_parser.c | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/ftp_parser.c b\/src\/ftp_parser.c\nindex 37553a6..69a42a3 100644\n--- a\/src\/ftp_parser.c\n+++ b\/src\/ftp_parser.c\n@@ -57,14 +57,20 @@ static void randomdelay(void)\n  * -Frank.\n  *\/\n \n+static size_t scanned;\n+static size_t readnbd;\n+\n+static void flush_cmd(void)\n+{\n+    scanned = readnbd = (size_t) 0U;\n+}\n+\n int sfgets(void)\n {\n     struct pollfd pfd;\n     int pollret;\n     ssize_t readnb;\n     signed char seen_r = 0;\n-    static size_t scanned;\n-    static size_t readnbd;\n     \n     if (scanned > (size_t) 0U) {       \/* support pipelining *\/\n         readnbd -= scanned;        \n@@ -362,6 +368,7 @@ void parser(void)\n             addreply_noformat(234, \"AUTH TLS OK.\");\n             doreply();\n             if (tls_cnx == NULL) {\n+                flush_cmd();\n                 (void) tls_init_new_session();\n             }\n             goto wayout;\n","owner":"jedisct1","repo":"pure-ftpd","source":"cve"},{"CVE_ID":"CVE-2015-5307","CWE_ID":"399","category":"security","commit_id":"54a20552e1eae07aa240fa370a0293e006b5faed","commit_message":"From 54a20552e1eae07aa240fa370a0293e006b5faed Mon Sep 17 00:00:00 2001\nFrom: Eric Northup <digitaleric@google.com>\nDate: Tue, 3 Nov 2015 18:03:53 +0100\nSubject: KVM: x86: work around infinite loop in microcode when #AC is\n delivered\n\nIt was found that a guest can DoS a host by triggering an infinite\nstream of \"alignment check\" (#AC) exceptions.  This causes the\nmicrocode to enter an infinite loop where the core never receives\nanother interrupt.  The host kernel panics pretty quickly due to the\neffects (CVE-2015-5307).\n\nSigned-off-by: Eric Northup <digitaleric@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/include\/uapi\/asm\/svm.h | 1 +\n arch\/x86\/kvm\/svm.c              | 8 ++++++++\n arch\/x86\/kvm\/vmx.c              | 5 ++++-\n 3 files changed, 13 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/uapi\/asm\/svm.h b\/arch\/x86\/include\/uapi\/asm\/svm.h\nindex b5d7640abc5d..8a4add8e4639 100644\n--- a\/arch\/x86\/include\/uapi\/asm\/svm.h\n+++ b\/arch\/x86\/include\/uapi\/asm\/svm.h\n@@ -100,6 +100,7 @@\n \t{ SVM_EXIT_EXCP_BASE + UD_VECTOR,       \"UD excp\" }, \\\n \t{ SVM_EXIT_EXCP_BASE + PF_VECTOR,       \"PF excp\" }, \\\n \t{ SVM_EXIT_EXCP_BASE + NM_VECTOR,       \"NM excp\" }, \\\n+\t{ SVM_EXIT_EXCP_BASE + AC_VECTOR,       \"AC excp\" }, \\\n \t{ SVM_EXIT_EXCP_BASE + MC_VECTOR,       \"MC excp\" }, \\\n \t{ SVM_EXIT_INTR,        \"interrupt\" }, \\\n \t{ SVM_EXIT_NMI,         \"nmi\" }, \\\ndiff --git a\/arch\/x86\/kvm\/svm.c b\/arch\/x86\/kvm\/svm.c\nindex f2ba91990b4e..183926483c3a 100644\n--- a\/arch\/x86\/kvm\/svm.c\n+++ b\/arch\/x86\/kvm\/svm.c\n@@ -1019,6 +1019,7 @@ static void init_vmcb(struct vcpu_svm *svm)\n \tset_exception_intercept(svm, PF_VECTOR);\n \tset_exception_intercept(svm, UD_VECTOR);\n \tset_exception_intercept(svm, MC_VECTOR);\n+\tset_exception_intercept(svm, AC_VECTOR);\n \n \tset_intercept(svm, INTERCEPT_INTR);\n \tset_intercept(svm, INTERCEPT_NMI);\n@@ -1707,6 +1708,12 @@ static int ud_interception(struct vcpu_svm *svm)\n \treturn 1;\n }\n \n+static int ac_interception(struct vcpu_svm *svm)\n+{\n+\tkvm_queue_exception_e(&svm->vcpu, AC_VECTOR, 0);\n+\treturn 1;\n+}\n+\n static void svm_fpu_activate(struct kvm_vcpu *vcpu)\n {\n \tstruct vcpu_svm *svm = to_svm(vcpu);\n@@ -3270,6 +3277,7 @@ static int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {\n \t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n \t[SVM_EXIT_EXCP_BASE + NM_VECTOR]\t= nm_interception,\n \t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n+\t[SVM_EXIT_EXCP_BASE + AC_VECTOR]\t= ac_interception,\n \t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n \t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n \t[SVM_EXIT_SMI]\t\t\t\t= nop_on_interception,\ndiff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex b765b036a048..89aaedd2a91d 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -1639,7 +1639,7 @@ static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n \tu32 eb;\n \n \teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n-\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n+\t     (1u << NM_VECTOR) | (1u << DB_VECTOR) | (1u << AC_VECTOR);\n \tif ((vcpu->guest_debug &\n \t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n \t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n@@ -5261,6 +5261,9 @@ static int handle_exception(struct kvm_vcpu *vcpu)\n \t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n \n \tswitch (ex_no) {\n+\tcase AC_VECTOR:\n+\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n+\t\treturn 1;\n \tcase DB_VECTOR:\n \t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n \t\tif (!(vcpu->guest_debug &\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-12643","CWE_ID":"399","category":"security","commit_id":"9eedb5660f1704cde8e8cd784c5c2a09dd2fd60f","commit_message":"From 9eedb5660f1704cde8e8cd784c5c2a09dd2fd60f Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sat, 8 Jul 2017 08:17:29 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/549\n\n---\n coders\/png.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/coders\/png.c b\/coders\/png.c\nindex 2ebb6e9d8f..3445ce7882 100644\n--- a\/coders\/png.c\n+++ b\/coders\/png.c\n@@ -4300,6 +4300,8 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,\n \n     if (length != 0)\n       {\n+        if (length > GetBlobSize(image))\n+          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n         chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n           sizeof(*chunk));\n \n@@ -5168,6 +5170,9 @@ static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n \n         if (length != 0)\n           {\n+            if (length > GetBlobSize(image))\n+              ThrowReaderException(CorruptImageError,\n+                \"InsufficientImageDataInFile\");\n             chunk=(unsigned char *) AcquireQuantumMemory(length+\n               MagickPathExtent,sizeof(*chunk));\n \n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-5759","CWE_ID":"399","category":"security","commit_id":"4d45a96e57fbabf00a7378b337d0ddcace6f38c1","commit_message":"From 4d45a96e57fbabf00a7378b337d0ddcace6f38c1 Mon Sep 17 00:00:00 2001\nFrom: Tor Andersson <tor.andersson@artifex.com>\nDate: Thu, 18 Jan 2018 14:16:28 +0100\nSubject: [PATCH] Guard binary expressions from too much recursion.\n\n---\n jsparse.c | 76 ++++++++++++++++++++++++++++++++++++++++++++++++---------------\n 1 file changed, 58 insertions(+), 18 deletions(-)\n\n","diff_code":"diff --git a\/jsparse.c b\/jsparse.c\nindex e0b950a..1f46024 100644\n--- a\/jsparse.c\n+++ b\/jsparse.c\n@@ -25,6 +25,8 @@ JS_NORETURN static void jsP_error(js_State *J, const char *fmt, ...) JS_PRINTFLI\n \n #define INCREC() if (++J->astdepth > JS_ASTLIMIT) jsP_error(J, \"too much recursion\")\n #define DECREC() --J->astdepth\n+#define SAVEREC() int SAVE=J->astdepth\n+#define POPREC() J->astdepth=SAVE\n \n static void jsP_error(js_State *J, const char *fmt, ...)\n {\n@@ -383,23 +385,26 @@ static js_Ast *newexp(js_State *J)\n \n static js_Ast *memberexp(js_State *J)\n {\n-\tjs_Ast *a;\n-\tINCREC();\n-\ta = newexp(J);\n+\tjs_Ast *a = newexp(J);\n+\tSAVEREC();\n loop:\n+\tINCREC();\n \tif (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }\n \tif (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }\n-\tDECREC();\n+\tPOPREC();\n \treturn a;\n }\n \n static js_Ast *callexp(js_State *J)\n {\n \tjs_Ast *a = newexp(J);\n+\tSAVEREC();\n loop:\n+\tINCREC();\n \tif (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }\n \tif (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }\n \tif (jsP_accept(J, '(')) { a = EXP2(CALL, a, arguments(J)); jsP_expect(J, ')'); goto loop; }\n+\tPOPREC();\n \treturn a;\n }\n \n@@ -432,104 +437,139 @@ static js_Ast *unary(js_State *J)\n static js_Ast *multiplicative(js_State *J)\n {\n \tjs_Ast *a = unary(J);\n+\tSAVEREC();\n loop:\n+\tINCREC();\n \tif (jsP_accept(J, '*')) { a = EXP2(MUL, a, unary(J)); goto loop; }\n \tif (jsP_accept(J, '\/')) { a = EXP2(DIV, a, unary(J)); goto loop; }\n \tif (jsP_accept(J, '%')) { a = EXP2(MOD, a, unary(J)); goto loop; }\n+\tPOPREC();\n \treturn a;\n }\n \n static js_Ast *additive(js_State *J)\n {\n \tjs_Ast *a = multiplicative(J);\n+\tSAVEREC();\n loop:\n+\tINCREC();\n \tif (jsP_accept(J, '+')) { a = EXP2(ADD, a, multiplicative(J)); goto loop; }\n \tif (jsP_accept(J, '-')) { a = EXP2(SUB, a, multiplicative(J)); goto loop; }\n+\tPOPREC();\n \treturn a;\n }\n \n static js_Ast *shift(js_State *J)\n {\n \tjs_Ast *a = additive(J);\n+\tSAVEREC();\n loop:\n+\tINCREC();\n \tif (jsP_accept(J, TK_SHL)) { a = EXP2(SHL, a, additive(J)); goto loop; }\n \tif (jsP_accept(J, TK_SHR)) { a = EXP2(SHR, a, additive(J)); goto loop; }\n \tif (jsP_accept(J, TK_USHR)) { a = EXP2(USHR, a, additive(J)); goto loop; }\n+\tPOPREC();\n \treturn a;\n }\n \n static js_Ast *relational(js_State *J, int notin)\n {\n \tjs_Ast *a = shift(J);\n+\tSAVEREC();\n loop:\n+\tINCREC();\n \tif (jsP_accept(J, '<')) { a = EXP2(LT, a, shift(J)); goto loop; }\n \tif (jsP_accept(J, '>')) { a = EXP2(GT, a, shift(J)); goto loop; }\n \tif (jsP_accept(J, TK_LE)) { a = EXP2(LE, a, shift(J)); goto loop; }\n \tif (jsP_accept(J, TK_GE)) { a = EXP2(GE, a, shift(J)); goto loop; }\n \tif (jsP_accept(J, TK_INSTANCEOF)) { a = EXP2(INSTANCEOF, a, shift(J)); goto loop; }\n \tif (!notin && jsP_accept(J, TK_IN)) { a = EXP2(IN, a, shift(J)); goto loop; }\n+\tPOPREC();\n \treturn a;\n }\n \n static js_Ast *equality(js_State *J, int notin)\n {\n \tjs_Ast *a = relational(J, notin);\n+\tSAVEREC();\n loop:\n+\tINCREC();\n \tif (jsP_accept(J, TK_EQ)) { a = EXP2(EQ, a, relational(J, notin)); goto loop; }\n \tif (jsP_accept(J, TK_NE)) { a = EXP2(NE, a, relational(J, notin)); goto loop; }\n \tif (jsP_accept(J, TK_STRICTEQ)) { a = EXP2(STRICTEQ, a, relational(J, notin)); goto loop; }\n \tif (jsP_accept(J, TK_STRICTNE)) { a = EXP2(STRICTNE, a, relational(J, notin)); goto loop; }\n+\tPOPREC();\n \treturn a;\n }\n \n static js_Ast *bitand(js_State *J, int notin)\n {\n \tjs_Ast *a = equality(J, notin);\n-\twhile (jsP_accept(J, '&'))\n+\tSAVEREC();\n+\twhile (jsP_accept(J, '&')) {\n+\t\tINCREC();\n \t\ta = EXP2(BITAND, a, equality(J, notin));\n+\t}\n+\tPOPREC();\n \treturn a;\n }\n \n static js_Ast *bitxor(js_State *J, int notin)\n {\n \tjs_Ast *a = bitand(J, notin);\n-\twhile (jsP_accept(J, '^'))\n+\tSAVEREC();\n+\twhile (jsP_accept(J, '^')) {\n+\t\tINCREC();\n \t\ta = EXP2(BITXOR, a, bitand(J, notin));\n+\t}\n+\tPOPREC();\n \treturn a;\n }\n \n static js_Ast *bitor(js_State *J, int notin)\n {\n \tjs_Ast *a = bitxor(J, notin);\n-\twhile (jsP_accept(J, '|'))\n+\tSAVEREC();\n+\twhile (jsP_accept(J, '|')) {\n+\t\tINCREC();\n \t\ta = EXP2(BITOR, a, bitxor(J, notin));\n+\t}\n+\tPOPREC();\n \treturn a;\n }\n \n static js_Ast *logand(js_State *J, int notin)\n {\n \tjs_Ast *a = bitor(J, notin);\n-\tif (jsP_accept(J, TK_AND))\n+\tif (jsP_accept(J, TK_AND)) {\n+\t\tINCREC();\n \t\ta = EXP2(LOGAND, a, logand(J, notin));\n+\t\tDECREC();\n+\t}\n \treturn a;\n }\n \n static js_Ast *logor(js_State *J, int notin)\n {\n \tjs_Ast *a = logand(J, notin);\n-\tif (jsP_accept(J, TK_OR))\n+\tif (jsP_accept(J, TK_OR)) {\n+\t\tINCREC();\n \t\ta = EXP2(LOGOR, a, logor(J, notin));\n+\t\tDECREC();\n+\t}\n \treturn a;\n }\n \n static js_Ast *conditional(js_State *J, int notin)\n {\n-\tjs_Ast *a, *b, *c;\n-\ta = logor(J, notin);\n+\tjs_Ast *a = logor(J, notin);\n \tif (jsP_accept(J, '?')) {\n+\t\tjs_Ast *b, *c;\n+\t\tINCREC();\n \t\tb = assignment(J, 0);\n \t\tjsP_expect(J, ':');\n \t\tc = assignment(J, notin);\n+\t\tDECREC();\n \t\treturn EXP3(COND, a, b, c);\n \t}\n \treturn a;\n@@ -537,9 +577,8 @@ static js_Ast *conditional(js_State *J, int notin)\n \n static js_Ast *assignment(js_State *J, int notin)\n {\n-\tjs_Ast *a;\n+\tjs_Ast *a = conditional(J, notin);\n \tINCREC();\n-\ta = conditional(J, notin);\n \tif (jsP_accept(J, '=')) a = EXP2(ASS, a, assignment(J, notin));\n \telse if (jsP_accept(J, TK_MUL_ASS)) a = EXP2(ASS_MUL, a, assignment(J, notin));\n \telse if (jsP_accept(J, TK_DIV_ASS)) a = EXP2(ASS_DIV, a, assignment(J, notin));\n@@ -558,12 +597,13 @@ static js_Ast *assignment(js_State *J, int notin)\n \n static js_Ast *expression(js_State *J, int notin)\n {\n-\tjs_Ast *a;\n-\tINCREC();\n-\ta = assignment(J, notin);\n-\twhile (jsP_accept(J, ','))\n+\tjs_Ast *a = assignment(J, notin);\n+\tSAVEREC();\n+\twhile (jsP_accept(J, ',')) {\n+\t\tINCREC();\n \t\ta = EXP2(COMMA, a, assignment(J, notin));\n-\tDECREC();\n+\t}\n+\tPOPREC();\n \treturn a;\n }\n \n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-1444","CWE_ID":"399","category":"security","commit_id":"96b340406724d87e4621284ebac5e059d67b2194","commit_message":"From 96b340406724d87e4621284ebac5e059d67b2194 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Salva=20Peir=C3=B3?= <speiro@ai2.upv.es>\nDate: Fri, 11 Oct 2013 12:50:03 +0300\nSubject: [PATCH] farsync: fix info leak in ioctl\n\nThe fst_get_iface() code fails to initialize the two padding bytes of\nstruct sync_serial_settings after the ->loopback member. Add an explicit\nmemset(0) before filling the structure to avoid the info leak.\n\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/wan\/farsync.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/drivers\/net\/wan\/farsync.c b\/drivers\/net\/wan\/farsync.c\nindex 3f0c4f2687510..bcfff0d62de4f 100644\n--- a\/drivers\/net\/wan\/farsync.c\n+++ b\/drivers\/net\/wan\/farsync.c\n@@ -1972,6 +1972,7 @@ fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n \t}\n \n \ti = port->index;\n+\tmemset(&sync, 0, sizeof(sync));\n \tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n \t\/* Lucky card and linux use same encoding here *\/\n \tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-0999","CWE_ID":"399","category":"security","commit_id":"a7d6e4ecdb7648478ddec76d30d87d03d6e22b31","commit_message":"From a7d6e4ecdb7648478ddec76d30d87d03d6e22b31 Mon Sep 17 00:00:00 2001\nFrom: Andrea Arcangeli <aarcange@redhat.com>\nDate: Tue, 15 Feb 2011 19:02:45 +0100\nSubject: thp: prevent hugepages during args\/env copying into the user stack\n\nTransparent hugepages can only be created if rmap is fully\nfunctional. So we must prevent hugepages to be created while\nis_vma_temporary_stack() is true.\n\nThis also optmizes away some harmless but unnecessary setting of\nkhugepaged_scan.address and it switches some BUG_ON to VM_BUG_ON.\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n include\/linux\/huge_mm.h |  3 ++-\n mm\/huge_memory.c        | 35 ++++++++++++++++-------------------\n 2 files changed, 18 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/huge_mm.h b\/include\/linux\/huge_mm.h\nindex 8e6c8c42bc3c..df29c8fde36b 100644\n--- a\/include\/linux\/huge_mm.h\n+++ b\/include\/linux\/huge_mm.h\n@@ -57,7 +57,8 @@ extern pmd_t *page_check_address_pmd(struct page *page,\n \t  (transparent_hugepage_flags &\t\t\t\t\t\\\n \t   (1<<TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG) &&\t\t\t\\\n \t   ((__vma)->vm_flags & VM_HUGEPAGE))) &&\t\t\t\\\n-\t !((__vma)->vm_flags & VM_NOHUGEPAGE))\n+\t !((__vma)->vm_flags & VM_NOHUGEPAGE) &&\t\t\t\\\n+\t !is_vma_temporary_stack(__vma))\n #define transparent_hugepage_defrag(__vma)\t\t\t\t\\\n \t((transparent_hugepage_flags &\t\t\t\t\t\\\n \t  (1<<TRANSPARENT_HUGEPAGE_DEFRAG_FLAG)) ||\t\t\t\\\ndiff --git a\/mm\/huge_memory.c b\/mm\/huge_memory.c\nindex e62ddb8f24b6..3e29781ee762 100644\n--- a\/mm\/huge_memory.c\n+++ b\/mm\/huge_memory.c\n@@ -1811,6 +1811,8 @@ static void collapse_huge_page(struct mm_struct *mm,\n \t\/* VM_PFNMAP vmas may have vm_ops null but vm_file set *\/\n \tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n \t\tgoto out;\n+\tif (is_vma_temporary_stack(vma))\n+\t\tgoto out;\n \tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n \n \tpgd = pgd_offset(mm, address);\n@@ -2032,32 +2034,27 @@ static unsigned int khugepaged_scan_mm_slot(unsigned int pages,\n \t\tif ((!(vma->vm_flags & VM_HUGEPAGE) &&\n \t\t     !khugepaged_always()) ||\n \t\t    (vma->vm_flags & VM_NOHUGEPAGE)) {\n+\t\tskip:\n \t\t\tprogress++;\n \t\t\tcontinue;\n \t\t}\n-\n \t\t\/* VM_PFNMAP vmas may have vm_ops null but vm_file set *\/\n-\t\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file) {\n-\t\t\tkhugepaged_scan.address = vma->vm_end;\n-\t\t\tprogress++;\n-\t\t\tcontinue;\n-\t\t}\n+\t\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n+\t\t\tgoto skip;\n+\t\tif (is_vma_temporary_stack(vma))\n+\t\t\tgoto skip;\n+\n \t\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n \n \t\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n \t\thend = vma->vm_end & HPAGE_PMD_MASK;\n-\t\tif (hstart >= hend) {\n-\t\t\tprogress++;\n-\t\t\tcontinue;\n-\t\t}\n+\t\tif (hstart >= hend)\n+\t\t\tgoto skip;\n+\t\tif (khugepaged_scan.address > hend)\n+\t\t\tgoto skip;\n \t\tif (khugepaged_scan.address < hstart)\n \t\t\tkhugepaged_scan.address = hstart;\n-\t\tif (khugepaged_scan.address > hend) {\n-\t\t\tkhugepaged_scan.address = hend + HPAGE_PMD_SIZE;\n-\t\t\tprogress++;\n-\t\t\tcontinue;\n-\t\t}\n-\t\tBUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n+\t\tVM_BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);\n \n \t\twhile (khugepaged_scan.address < hend) {\n \t\t\tint ret;\n@@ -2086,7 +2083,7 @@ breakouterloop:\n breakouterloop_mmap_sem:\n \n \tspin_lock(&khugepaged_mm_lock);\n-\tBUG_ON(khugepaged_scan.mm_slot != mm_slot);\n+\tVM_BUG_ON(khugepaged_scan.mm_slot != mm_slot);\n \t\/*\n \t * Release the current mm_slot if this mm is about to die, or\n \t * if we scanned all vmas of this mm.\n@@ -2241,9 +2238,9 @@ static int khugepaged(void *none)\n \n \tfor (;;) {\n \t\tmutex_unlock(&khugepaged_mutex);\n-\t\tBUG_ON(khugepaged_thread != current);\n+\t\tVM_BUG_ON(khugepaged_thread != current);\n \t\tkhugepaged_loop();\n-\t\tBUG_ON(khugepaged_thread != current);\n+\t\tVM_BUG_ON(khugepaged_thread != current);\n \n \t\tmutex_lock(&khugepaged_mutex);\n \t\tif (!khugepaged_enabled())\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2009-3726","CWE_ID":"399","category":"security","commit_id":"d953126a28f97ec965d23c69fd5795854c048f30","commit_message":"From d953126a28f97ec965d23c69fd5795854c048f30 Mon Sep 17 00:00:00 2001\nFrom: Trond Myklebust <Trond.Myklebust@netapp.com>\nDate: Tue, 21 Jul 2009 19:22:38 -0400\nSubject: NFSv4: Fix a problem whereby a buggy server can oops the kernel\n\nWe just had a case in which a buggy server occasionally returns the wrong\nattributes during an OPEN call. While the client does catch this sort of\ncondition in nfs4_open_done(), and causes the nfs4_atomic_open() to return\n-EISDIR, the logic in nfs_atomic_lookup() is broken, since it causes a\nfallback to an ordinary lookup instead of just returning the error.\n\nWhen the buggy server then returns a regular file for the fallback lookup,\nthe VFS allows the open, and bad things start to happen, since the open\nfile doesn't have any associated NFSv4 state.\n\nThe fix is firstly to return the EISDIR\/ENOTDIR errors immediately, and\nsecondly to ensure that we are always careful when dereferencing the\nnfs_open_context state pointer.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\n---\n fs\/nfs\/dir.c      |  2 +-\n fs\/nfs\/nfs4proc.c | 16 ++++++++++++----\n 2 files changed, 13 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/fs\/nfs\/dir.c b\/fs\/nfs\/dir.c\nindex 38d42c29fb92..32062c33c859 100644\n--- a\/fs\/nfs\/dir.c\n+++ b\/fs\/nfs\/dir.c\n@@ -1025,12 +1025,12 @@ static struct dentry *nfs_atomic_lookup(struct inode *dir, struct dentry *dentry\n \t\t\t\tres = NULL;\n \t\t\t\tgoto out;\n \t\t\t\/* This turned out not to be a regular file *\/\n-\t\t\tcase -EISDIR:\n \t\t\tcase -ENOTDIR:\n \t\t\t\tgoto no_open;\n \t\t\tcase -ELOOP:\n \t\t\t\tif (!(nd->intent.open.flags & O_NOFOLLOW))\n \t\t\t\t\tgoto no_open;\n+\t\t\t\/* case -EISDIR: *\/\n \t\t\t\/* case -EINVAL: *\/\n \t\t\tdefault:\n \t\t\t\tgoto out;\ndiff --git a\/fs\/nfs\/nfs4proc.c b\/fs\/nfs\/nfs4proc.c\nindex df24f67bca69..6917311f201c 100644\n--- a\/fs\/nfs\/nfs4proc.c\n+++ b\/fs\/nfs\/nfs4proc.c\n@@ -4093,15 +4093,23 @@ nfs4_proc_lock(struct file *filp, int cmd, struct file_lock *request)\n \tif (request->fl_start < 0 || request->fl_end < 0)\n \t\treturn -EINVAL;\n \n-\tif (IS_GETLK(cmd))\n-\t\treturn nfs4_proc_getlk(state, F_GETLK, request);\n+\tif (IS_GETLK(cmd)) {\n+\t\tif (state != NULL)\n+\t\t\treturn nfs4_proc_getlk(state, F_GETLK, request);\n+\t\treturn 0;\n+\t}\n \n \tif (!(IS_SETLK(cmd) || IS_SETLKW(cmd)))\n \t\treturn -EINVAL;\n \n-\tif (request->fl_type == F_UNLCK)\n-\t\treturn nfs4_proc_unlck(state, cmd, request);\n+\tif (request->fl_type == F_UNLCK) {\n+\t\tif (state != NULL)\n+\t\t\treturn nfs4_proc_unlck(state, cmd, request);\n+\t\treturn 0;\n+\t}\n \n+\tif (state == NULL)\n+\t\treturn -ENOLCK;\n \tdo {\n \t\tstatus = nfs4_proc_setlk(state, cmd, request);\n \t\tif ((status != -EAGAIN) || IS_SETLK(cmd))\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5857","CWE_ID":"399","category":"security","commit_id":"5e8e3c4c75c199aa1017db816fca02be2a9f8798","commit_message":"From 5e8e3c4c75c199aa1017db816fca02be2a9f8798 Mon Sep 17 00:00:00 2001\nFrom: Gerd Hoffmann <kraxel@redhat.com>\nDate: Mon, 23 Jan 2017 11:26:50 +0100\nSubject: [PATCH] virtio-gpu: fix resource leak in virgl_cmd_resource_unref\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nWhen the guest sends VIRTIO_GPU_CMD_RESOURCE_UNREF without detaching the\nbacking storage beforehand (VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING)\nwe'll leak memory.\n\nThis patch fixes it for 3d mode, simliar to the 2d mode fix in commit\n\"b8e2392 virtio-gpu: call cleanup mapping function in resource destroy\".\n\nReported-by: \u00e6\u009d\u008e\u00e5\u00bc\u00ba <liqiang6-s@360.cn>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nMessage-id: 1485167210-4757-1-git-send-email-kraxel@redhat.com\n---\n hw\/display\/virtio-gpu-3d.c | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\n","diff_code":"diff --git a\/hw\/display\/virtio-gpu-3d.c b\/hw\/display\/virtio-gpu-3d.c\nindex f96a0c2..ecb09d1 100644\n--- a\/hw\/display\/virtio-gpu-3d.c\n+++ b\/hw\/display\/virtio-gpu-3d.c\n@@ -77,10 +77,18 @@ static void virgl_cmd_resource_unref(VirtIOGPU *g,\n                                      struct virtio_gpu_ctrl_command *cmd)\n {\n     struct virtio_gpu_resource_unref unref;\n+    struct iovec *res_iovs = NULL;\n+    int num_iovs = 0;\n \n     VIRTIO_GPU_FILL_CMD(unref);\n     trace_virtio_gpu_cmd_res_unref(unref.resource_id);\n \n+    virgl_renderer_resource_detach_iov(unref.resource_id,\n+                                       &res_iovs,\n+                                       &num_iovs);\n+    if (res_iovs != NULL && num_iovs != 0) {\n+        virtio_gpu_cleanup_mapping_iov(res_iovs, num_iovs);\n+    }\n     virgl_renderer_resource_unref(unref.resource_id);\n }\n \n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-2844","CWE_ID":"399","category":"security","commit_id":"cd3468bad96c00b5a512f551674f36776129520e","commit_message":"From cd3468bad96c00b5a512f551674f36776129520e Mon Sep 17 00:00:00 2001\nFrom: Johannes Berg <johannes@sipsolutions.net>\nDate: Wed, 29 Jul 2009 22:07:44 +0200\nSubject: cfg80211: add two missing NULL pointer checks\n\nThese pointers can be NULL, the is_mesh() case isn't\never hit in the current kernel, but cmp_ies() can be\nhit under certain conditions.\n\nSigned-off-by: Johannes Berg <johannes@sipsolutions.net>\nCc: stable@kernel.org [2.6.29, 2.6.30]\nSigned-off-by: John W. Linville <linville@tuxdriver.com>\n---\n net\/wireless\/scan.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/wireless\/scan.c b\/net\/wireless\/scan.c\nindex 9271118e1fc4..7e595ce24eeb 100644\n--- a\/net\/wireless\/scan.c\n+++ b\/net\/wireless\/scan.c\n@@ -118,7 +118,7 @@ static int cmp_ies(u8 num, u8 *ies1, size_t len1, u8 *ies2, size_t len2)\n \n \tif (!ie1 && !ie2)\n \t\treturn 0;\n-\tif (!ie1)\n+\tif (!ie1 || !ie2)\n \t\treturn -1;\n \n \tr = memcmp(ie1 + 2, ie2 + 2, min(ie1[1], ie2[1]));\n@@ -171,6 +171,8 @@ static bool is_mesh(struct cfg80211_bss *a,\n \tie = find_ie(WLAN_EID_MESH_CONFIG,\n \t\t     a->information_elements,\n \t\t     a->len_information_elements);\n+\tif (!ie)\n+\t\treturn false;\n \tif (ie[1] != IEEE80211_MESH_CONFIG_LEN)\n \t\treturn false;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-14175","CWE_ID":"399","category":"security","commit_id":"b8c63b156bf26b52e710b1a0643c846a6cd01e56","commit_message":"From b8c63b156bf26b52e710b1a0643c846a6cd01e56 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 31 Aug 2017 09:10:37 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/712\n\n---\n coders\/xbm.c | 31 +++++++++++++++++++++----------\n 1 file changed, 21 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/coders\/xbm.c b\/coders\/xbm.c\nindex 8a3cf34439..66b2faca98 100644\n--- a\/coders\/xbm.c\n+++ b\/coders\/xbm.c\n@@ -131,7 +131,7 @@ static MagickBooleanType IsXBM(const unsigned char *magick,const size_t length)\n %\n *\/\n \n-static unsigned int XBMInteger(Image *image,short int *hex_digits)\n+static int XBMInteger(Image *image,short int *hex_digits)\n { \n   int\n     c;\n@@ -146,7 +146,7 @@ static unsigned int XBMInteger(Image *image,short int *hex_digits)\n   { \n     c=ReadBlobByte(image);\n     if (c == EOF)\n-      return(0);\n+      return(-1);\n   } while ((c == ' ') || (c == '\\t') || (c == '\\n') || (c == '\\r'));\n   \/*\n     Evaluate number.\n@@ -162,9 +162,9 @@ static unsigned int XBMInteger(Image *image,short int *hex_digits)\n     value+=hex_digits[c];\n     c=ReadBlobByte(image);\n     if (c == EOF)\n-      return(0);\n+      return(-1);\n   }\n-  return(value);\n+  return((int) value);\n }\n \n static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n@@ -176,6 +176,9 @@ static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   Image\n     *image;\n \n+  int\n+    c;\n+\n   MagickBooleanType\n     status;\n \n@@ -208,7 +211,6 @@ static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     height,\n     length,\n     padding,\n-    value,\n     version,\n     width;\n \n@@ -349,16 +351,25 @@ static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   if (version == 10)\n     for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2))\n     {\n-      value=XBMInteger(image,hex_digits);\n-      *p++=(unsigned char) value;\n+      c=XBMInteger(image,hex_digits);\n+      if (c < 0)\n+        break;\n+      *p++=(unsigned char) c;\n       if ((padding == 0) || (((i+2) % bytes_per_line) != 0))\n-        *p++=(unsigned char) (value >> 8);\n+        *p++=(unsigned char) (c >> 8);\n     }\n   else\n     for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++)\n     {\n       value=XBMInteger(image,hex_digits);\n-      *p++=(unsigned char) value;\n+      if (c < 0)\n+        break;\n+      *p++=(unsigned char) c;\n+    }\n+  if (EOFBlob(image) != MagickFalse)\n+    {\n+      data=(unsigned char *) RelinquishMagickMemory(data);\n+      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n   \/*\n     Convert X bitmap image to pixel packets.\n@@ -375,7 +386,7 @@ static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     for (x=0; x < (ssize_t) image->columns; x++)\n     {\n       if (bit == 0)\n-        byte=(size_t) (*p++);\n+        byte=(unsigned int) (*p++);\n       SetPixelIndex(indexes+x,(byte & 0x01) != 0 ? 0x01 : 0x00);\n       bit++;\n       byte>>=1;\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2010-4707","CWE_ID":"399","category":"security","commit_id":"ffe7058c70253d574b1963c7c93002bd410fddc9","commit_message":"From ffe7058c70253d574b1963c7c93002bd410fddc9 Mon Sep 17 00:00:00 2001\nFrom: Dmitry V. Levin <ldv@users.sourceforge.net>\nDate: Tue, 28 Sep 2010 17:11:36 +0000\nSubject: [PATCH] Relevant BUGIDs:\n\nPurpose of commit: bugfix\n\nCommit summary:\n---------------\n2010-09-27  Dmitry V. Levin  <ldv@altlinux.org>\n\n\t* modules\/pam_xauth\/pam_xauth.c (check_acl): Check that the given\n\taccess control file is a regular file.\n---\n Linux-PAM\/ChangeLog                     |    5 +++++\n Linux-PAM\/modules\/pam_xauth\/pam_xauth.c |   29 +++++++++++++++++++++++++----\n 2 files changed, 30 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/Linux-PAM\/ChangeLog b\/Linux-PAM\/ChangeLog\nindex dd749de..abad321 100644\n--- a\/Linux-PAM\/ChangeLog\n+++ b\/Linux-PAM\/ChangeLog\n@@ -1,3 +1,8 @@\n+2010-09-27  Dmitry V. Levin  <ldv@altlinux.org>\n+\n+\t* modules\/pam_xauth\/pam_xauth.c (check_acl): Ensure that the given\n+\taccess control file is a regular file.\n+\n 2010-09-16  Dmitry V. Levin  <ldv@altlinux.org>\n \n \t* modules\/pam_env\/pam_env.c (handle_env): Use setfsuid() return code.\ndiff --git a\/Linux-PAM\/modules\/pam_xauth\/pam_xauth.c b\/Linux-PAM\/modules\/pam_xauth\/pam_xauth.c\nindex 05ed6ee..591dc85 100644\n--- a\/Linux-PAM\/modules\/pam_xauth\/pam_xauth.c\n+++ b\/Linux-PAM\/modules\/pam_xauth\/pam_xauth.c\n@@ -37,6 +37,9 @@\n #include <sys\/types.h>\n #include <sys\/fsuid.h>\n #include <sys\/wait.h>\n+#include <sys\/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n #include <errno.h>\n #include <fnmatch.h>\n #include <grp.h>\n@@ -232,9 +235,10 @@ check_acl(pam_handle_t *pamh,\n {\n \tchar path[PATH_MAX];\n \tstruct passwd *pwd;\n-\tFILE *fp;\n-\tint i, save_errno;\n+\tFILE *fp = NULL;\n+\tint i, fd = -1, save_errno;\n \tuid_t fsuid;\n+\tstruct stat st;\n \t\/* Check this user's <sense> file. *\/\n \tpwd = pam_modutil_getpwnam(pamh, this_user);\n \tif (pwd == NULL) {\n@@ -251,10 +255,27 @@ check_acl(pam_handle_t *pamh,\n \t\treturn PAM_SESSION_ERR;\n \t}\n \tfsuid = setfsuid(pwd->pw_uid);\n-\tfp = fopen(path, \"r\");\n+\tif (!stat(path, &st)) {\n+\t\tif (!S_ISREG(st.st_mode))\n+\t\t\terrno = EINVAL;\n+\t\telse\n+\t\t\tfd = open(path, O_RDONLY | O_NOCTTY);\n+\t}\n \tsave_errno = errno;\n \tsetfsuid(fsuid);\n-\tif (fp != NULL) {\n+\tif (fd >= 0) {\n+\t\tif (!fstat(fd, &st)) {\n+\t\t\tif (!S_ISREG(st.st_mode))\n+\t\t\t\terrno = EINVAL;\n+\t\t\telse\n+\t\t\t\tfp = fdopen(fd, \"r\");\n+\t\t}\n+\t\tif (!fp) {\n+\t\t\tsave_errno = errno;\n+\t\t\tclose(fd);\n+\t\t}\n+\t}\n+\tif (fp) {\n \t\tchar buf[LINE_MAX], *tmp;\n \t\t\/* Scan the file for a list of specs of users to \"trust\". *\/\n \t\twhile (fgets(buf, sizeof(buf), fp) != NULL) {\n-- \n1.7.3.3\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1090","CWE_ID":"399","category":"security","commit_id":"e9e3d724e2145f5039b423c290ce2b2c3d8f94bc","commit_message":"From e9e3d724e2145f5039b423c290ce2b2c3d8f94bc Mon Sep 17 00:00:00 2001\nFrom: Neil Horman <nhorman@tuxdriver.com>\nDate: Fri, 4 Mar 2011 19:26:03 -0500\nSubject: nfs4: Ensure that ACL pages sent over NFS were not allocated from the\n slab (v3)\n\nThe \"bad_page()\" page allocator sanity check was reported recently (call\nchain as follows):\n\n  bad_page+0x69\/0x91\n  free_hot_cold_page+0x81\/0x144\n  skb_release_data+0x5f\/0x98\n  __kfree_skb+0x11\/0x1a\n  tcp_ack+0x6a3\/0x1868\n  tcp_rcv_established+0x7a6\/0x8b9\n  tcp_v4_do_rcv+0x2a\/0x2fa\n  tcp_v4_rcv+0x9a2\/0x9f6\n  do_timer+0x2df\/0x52c\n  ip_local_deliver+0x19d\/0x263\n  ip_rcv+0x539\/0x57c\n  netif_receive_skb+0x470\/0x49f\n  :virtio_net:virtnet_poll+0x46b\/0x5c5\n  net_rx_action+0xac\/0x1b3\n  __do_softirq+0x89\/0x133\n  call_softirq+0x1c\/0x28\n  do_softirq+0x2c\/0x7d\n  do_IRQ+0xec\/0xf5\n  default_idle+0x0\/0x50\n  ret_from_intr+0x0\/0xa\n  default_idle+0x29\/0x50\n  cpu_idle+0x95\/0xb8\n  start_kernel+0x220\/0x225\n  _sinittext+0x22f\/0x236\n\nIt occurs because an skb with a fraglist was freed from the tcp\nretransmit queue when it was acked, but a page on that fraglist had\nPG_Slab set (indicating it was allocated from the Slab allocator (which\nmeans the free path above can't safely free it via put_page.\n\nWe tracked this back to an nfsv4 setacl operation, in which the nfs code\nattempted to fill convert the passed in buffer to an array of pages in\n__nfs4_proc_set_acl, which gets used by the skb->frags list in\nxs_sendpages.  __nfs4_proc_set_acl just converts each page in the buffer\nto a page struct via virt_to_page, but the vfs allocates the buffer via\nkmalloc, meaning the PG_slab bit is set.  We can't create a buffer with\nkmalloc and free it later in the tcp ack path with put_page, so we need\nto either:\n\n1) ensure that when we create the list of pages, no page struct has\n   PG_Slab set\n\n or\n\n2) not use a page list to send this data\n\nGiven that these buffers can be multiple pages and arbitrarily sized, I\nthink (1) is the right way to go.  I've written the below patch to\nallocate a page from the buddy allocator directly and copy the data over\nto it.  This ensures that we have a put_page free-able page for every\nentry that winds up on an skb frag list, so it can be safely freed when\nthe frame is acked.  We do a put page on each entry after the\nrpc_call_sync call so as to drop our own reference count to the page,\nleaving only the ref count taken by tcp_sendpages.  This way the data\nwill be properly freed when the ack comes in\n\nSuccessfully tested by myself to solve the above oops.\n\nNote, as this is the result of a setacl operation that exceeded a page\nof data, I think this amounts to a local DOS triggerable by an\nuprivlidged user, so I'm CCing security on this as well.\n\nSigned-off-by: Neil Horman <nhorman@tuxdriver.com>\nCC: Trond Myklebust <Trond.Myklebust@netapp.com>\nCC: security@kernel.org\nCC: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/nfs\/nfs4proc.c | 44 ++++++++++++++++++++++++++++++++++++++++++--\n 1 file changed, 42 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/nfs\/nfs4proc.c b\/fs\/nfs\/nfs4proc.c\nindex 78936a8f40ab..1ff76acc7e98 100644\n--- a\/fs\/nfs\/nfs4proc.c\n+++ b\/fs\/nfs\/nfs4proc.c\n@@ -51,6 +51,7 @@\n #include <linux\/sunrpc\/bc_xprt.h>\n #include <linux\/xattr.h>\n #include <linux\/utsname.h>\n+#include <linux\/mm.h>\n \n #include \"nfs4_fs.h\"\n #include \"delegation.h\"\n@@ -3252,6 +3253,35 @@ static void buf_to_pages(const void *buf, size_t buflen,\n \t}\n }\n \n+static int buf_to_pages_noslab(const void *buf, size_t buflen,\n+\t\tstruct page **pages, unsigned int *pgbase)\n+{\n+\tstruct page *newpage, **spages;\n+\tint rc = 0;\n+\tsize_t len;\n+\tspages = pages;\n+\n+\tdo {\n+\t\tlen = min(PAGE_CACHE_SIZE, buflen);\n+\t\tnewpage = alloc_page(GFP_KERNEL);\n+\n+\t\tif (newpage == NULL)\n+\t\t\tgoto unwind;\n+\t\tmemcpy(page_address(newpage), buf, len);\n+                buf += len;\n+                buflen -= len;\n+\t\t*pages++ = newpage;\n+\t\trc++;\n+\t} while (buflen != 0);\n+\n+\treturn rc;\n+\n+unwind:\n+\tfor(; rc > 0; rc--)\n+\t\t__free_page(spages[rc-1]);\n+\treturn -ENOMEM;\n+}\n+\n struct nfs4_cached_acl {\n \tint cached;\n \tsize_t len;\n@@ -3420,13 +3450,23 @@ static int __nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t bufl\n \t\t.rpc_argp\t= &arg,\n \t\t.rpc_resp\t= &res,\n \t};\n-\tint ret;\n+\tint ret, i;\n \n \tif (!nfs4_server_supports_acls(server))\n \t\treturn -EOPNOTSUPP;\n+\ti = buf_to_pages_noslab(buf, buflen, arg.acl_pages, &arg.acl_pgbase);\n+\tif (i < 0)\n+\t\treturn i;\n \tnfs_inode_return_delegation(inode);\n-\tbuf_to_pages(buf, buflen, arg.acl_pages, &arg.acl_pgbase);\n \tret = nfs4_call_sync(server, &msg, &arg, &res, 1);\n+\n+\t\/*\n+\t * Free each page after tx, so the only ref left is\n+\t * held by the network stack\n+\t *\/\n+\tfor (; i > 0; i--)\n+\t\tput_page(pages[i-1]);\n+\n \t\/*\n \t * Acl update can result in inode attribute update.\n \t * so mark the attribute cache invalid.\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-0221","CWE_ID":"399","category":"security","commit_id":"d3152655d5319ce883c8e3ac4b99f8de4c59d846","commit_message":"From d3152655d5319ce883c8e3ac4b99f8de4c59d846 Mon Sep 17 00:00:00 2001\nFrom: \"Dr. Stephen Henson\" <steve@openssl.org>\nDate: Fri, 16 May 2014 13:00:45 +0100\nSubject: [PATCH] Fix CVE-2014-0221\n\nUnnecessary recursion when receiving a DTLS hello request can be used to\ncrash a DTLS client. Fixed by handling DTLS hello request without recursion.\n\nThanks to Imre Rad (Search-Lab Ltd.) for discovering this issue.\n---\n ssl\/d1_both.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/ssl\/d1_both.c b\/ssl\/d1_both.c\nindex 7de9ae4b5f..04aa23107e 100644\n--- a\/ssl\/d1_both.c\n+++ b\/ssl\/d1_both.c\n@@ -793,6 +793,7 @@ dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok)\n \tint i,al;\n \tstruct hm_header_st msg_hdr;\n \n+\tredo:\n \t\/* see if we have the required fragment already *\/\n \tif ((frag_len = dtls1_retrieve_buffered_fragment(s,max,ok)) || *ok)\n \t\t{\n@@ -851,8 +852,7 @@ dtls1_get_message_fragment(SSL *s, int st1, int stn, long max, int *ok)\n \t\t\t\t\ts->msg_callback_arg);\n \t\t\t\n \t\t\ts->init_num = 0;\n-\t\t\treturn dtls1_get_message_fragment(s, st1, stn,\n-\t\t\t\tmax, ok);\n+\t\t\tgoto redo;\n \t\t\t}\n \t\telse \/* Incorrectly formated Hello request *\/\n \t\t\t{\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3690","CWE_ID":"399","category":"security","commit_id":"d974baa398f34393db76be45f7d4d04fbdbb4a0a","commit_message":"From d974baa398f34393db76be45f7d4d04fbdbb4a0a Mon Sep 17 00:00:00 2001\nFrom: Andy Lutomirski <luto@amacapital.net>\nDate: Wed, 8 Oct 2014 09:02:13 -0700\nSubject: x86,kvm,vmx: Preserve CR4 across VM entry\n\nCR4 isn't constant; at least the TSD and PCE bits can vary.\n\nTBH, treating CR0 and CR3 as constant scares me a bit, too, but it looks\nlike it's correct.\n\nThis adds a branch and a read from cr4 to each vm entry.  Because it is\nextremely likely that consecutive entries into the same vcpu will have\nthe same host cr4 value, this fixes up the vmcs instead of restoring cr4\nafter the fact.  A subsequent patch will add a kernel-wide cr4 shadow,\nreducing the overhead in the common case to just two memory reads and a\nbranch.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nAcked-by: Paolo Bonzini <pbonzini@redhat.com>\nCc: stable@vger.kernel.org\nCc: Petr Matousek <pmatouse@redhat.com>\nCc: Gleb Natapov <gleb@kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/x86\/kvm\/vmx.c | 16 ++++++++++++++--\n 1 file changed, 14 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex d9dcfa27aa84..0acac81f198b 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -472,6 +472,7 @@ struct vcpu_vmx {\n \t\tint           gs_ldt_reload_needed;\n \t\tint           fs_reload_needed;\n \t\tu64           msr_host_bndcfgs;\n+\t\tunsigned long vmcs_host_cr4;\t\/* May not match real cr4 *\/\n \t} host_state;\n \tstruct {\n \t\tint vm86_active;\n@@ -4267,11 +4268,16 @@ static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n \tu32 low32, high32;\n \tunsigned long tmpl;\n \tstruct desc_ptr dt;\n+\tunsigned long cr4;\n \n \tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  \/* 22.2.3 *\/\n-\tvmcs_writel(HOST_CR4, read_cr4());  \/* 22.2.3, 22.2.5 *\/\n \tvmcs_writel(HOST_CR3, read_cr3());  \/* 22.2.3  FIXME: shadow tables *\/\n \n+\t\/* Save the most likely value for this task's CR4 in the VMCS. *\/\n+\tcr4 = read_cr4();\n+\tvmcs_writel(HOST_CR4, cr4);\t\t\t\/* 22.2.3, 22.2.5 *\/\n+\tvmx->host_state.vmcs_host_cr4 = cr4;\n+\n \tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \/* 22.2.4 *\/\n #ifdef CONFIG_X86_64\n \t\/*\n@@ -7514,7 +7520,7 @@ static void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n {\n \tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n-\tunsigned long debugctlmsr;\n+\tunsigned long debugctlmsr, cr4;\n \n \t\/* Record the guest's net vcpu time for enforced NMI injections. *\/\n \tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n@@ -7540,6 +7546,12 @@ static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n \tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n \t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n \n+\tcr4 = read_cr4();\n+\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {\n+\t\tvmcs_writel(HOST_CR4, cr4);\n+\t\tvmx->host_state.vmcs_host_cr4 = cr4;\n+\t}\n+\n \t\/* When single-stepping over STI and MOV SS, we must clear the\n \t * corresponding interruptibility bits in the guest state. Otherwise\n \t * vmentry fails as it then expects bit 14 (BS) in pending debug\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-5364","CWE_ID":"399","category":"security","commit_id":"beb39db59d14990e401e235faf66a6b9b31240b0","commit_message":"From beb39db59d14990e401e235faf66a6b9b31240b0 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Sat, 30 May 2015 09:16:53 -0700\nSubject: [PATCH] udp: fix behavior of wrong checksums\n\nWe have two problems in UDP stack related to bogus checksums :\n\n1) We return -EAGAIN to application even if receive queue is not empty.\n   This breaks applications using edge trigger epoll()\n\n2) Under UDP flood, we can loop forever without yielding to other\n   processes, potentially hanging the host, especially on non SMP.\n\nThis patch is an attempt to make things better.\n\nWe might in the future add extra support for rt applications\nwanting to better control time spent doing a recv() in a hostile\nenvironment. For example we could validate checksums before queuing\npackets in socket receive queue.\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Willem de Bruijn <willemb@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/udp.c | 6 ++----\n net\/ipv6\/udp.c | 6 ++----\n 2 files changed, 4 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/udp.c b\/net\/ipv4\/udp.c\nindex d10b7e0112ebd..1c92ea67baefe 100644\n--- a\/net\/ipv4\/udp.c\n+++ b\/net\/ipv4\/udp.c\n@@ -1345,10 +1345,8 @@ int udp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int noblock,\n \t}\n \tunlock_sock_fast(sk, slow);\n \n-\tif (noblock)\n-\t\treturn -EAGAIN;\n-\n-\t\/* starting over for a new packet *\/\n+\t\/* starting over for a new packet, but check if we need to yield *\/\n+\tcond_resched();\n \tmsg->msg_flags &= ~MSG_TRUNC;\n \tgoto try_again;\n }\ndiff --git a\/net\/ipv6\/udp.c b\/net\/ipv6\/udp.c\nindex c2ec41617a354..e51fc3eee6dbd 100644\n--- a\/net\/ipv6\/udp.c\n+++ b\/net\/ipv6\/udp.c\n@@ -525,10 +525,8 @@ int udpv6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\n \t}\n \tunlock_sock_fast(sk, slow);\n \n-\tif (noblock)\n-\t\treturn -EAGAIN;\n-\n-\t\/* starting over for a new packet *\/\n+\t\/* starting over for a new packet, but check if we need to yield *\/\n+\tcond_resched();\n \tmsg->msg_flags &= ~MSG_TRUNC;\n \tgoto try_again;\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-0217","CWE_ID":"399","category":"security","commit_id":"7d5145d8eb2b9791533ffe4dc003b129b9696c48","commit_message":"From 7d5145d8eb2b9791533ffe4dc003b129b9696c48 Mon Sep 17 00:00:00 2001\nFrom: Matthew Daley <mattjd@gmail.com>\nDate: Wed, 6 Feb 2013 23:41:36 +0000\nSubject: [PATCH] xen\/netback: don't leak pages on failure in\n xen_netbk_tx_check_gop.\n\nSigned-off-by: Matthew Daley <mattjd@gmail.com>\nReviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nAcked-by: Ian Campbell <ian.campbell@citrix.com>\nAcked-by: Jan Beulich <JBeulich@suse.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/xen-netback\/netback.c | 38 +++++++++++--------------------\n 1 file changed, 13 insertions(+), 25 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/xen-netback\/netback.c b\/drivers\/net\/xen-netback\/netback.c\nindex c2e3336b4f98a..bf692df966a9d 100644\n--- a\/drivers\/net\/xen-netback\/netback.c\n+++ b\/drivers\/net\/xen-netback\/netback.c\n@@ -147,7 +147,8 @@ void xen_netbk_remove_xenvif(struct xenvif *vif)\n \tatomic_dec(&netbk->netfront_count);\n }\n \n-static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx);\n+static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx,\n+\t\t\t\t  u8 status);\n static void make_tx_response(struct xenvif *vif,\n \t\t\t     struct xen_netif_tx_request *txp,\n \t\t\t     s8       st);\n@@ -1007,30 +1008,20 @@ static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n {\n \tstruct gnttab_copy *gop = *gopp;\n \tu16 pending_idx = *((u16 *)skb->data);\n-\tstruct pending_tx_info *pending_tx_info = netbk->pending_tx_info;\n-\tstruct xenvif *vif = pending_tx_info[pending_idx].vif;\n-\tstruct xen_netif_tx_request *txp;\n \tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n \tint nr_frags = shinfo->nr_frags;\n \tint i, err, start;\n \n \t\/* Check status of header. *\/\n \terr = gop->status;\n-\tif (unlikely(err)) {\n-\t\tpending_ring_idx_t index;\n-\t\tindex = pending_index(netbk->pending_prod++);\n-\t\ttxp = &pending_tx_info[pending_idx].req;\n-\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n-\t\tnetbk->pending_ring[index] = pending_idx;\n-\t\txenvif_put(vif);\n-\t}\n+\tif (unlikely(err))\n+\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);\n \n \t\/* Skip first skb fragment if it is on same page as header fragment. *\/\n \tstart = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);\n \n \tfor (i = start; i < nr_frags; i++) {\n \t\tint j, newerr;\n-\t\tpending_ring_idx_t index;\n \n \t\tpending_idx = frag_get_pending_idx(&shinfo->frags[i]);\n \n@@ -1039,16 +1030,12 @@ static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n \t\tif (likely(!newerr)) {\n \t\t\t\/* Had a previous error? Invalidate this fragment. *\/\n \t\t\tif (unlikely(err))\n-\t\t\t\txen_netbk_idx_release(netbk, pending_idx);\n+\t\t\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n \t\t\tcontinue;\n \t\t}\n \n \t\t\/* Error on this fragment: respond to client with an error. *\/\n-\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n-\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n-\t\tindex = pending_index(netbk->pending_prod++);\n-\t\tnetbk->pending_ring[index] = pending_idx;\n-\t\txenvif_put(vif);\n+\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);\n \n \t\t\/* Not the first error? Preceding frags already invalidated. *\/\n \t\tif (err)\n@@ -1056,10 +1043,10 @@ static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n \n \t\t\/* First error: invalidate header and preceding fragments. *\/\n \t\tpending_idx = *((u16 *)skb->data);\n-\t\txen_netbk_idx_release(netbk, pending_idx);\n+\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n \t\tfor (j = start; j < i; j++) {\n \t\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[j]);\n-\t\t\txen_netbk_idx_release(netbk, pending_idx);\n+\t\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n \t\t}\n \n \t\t\/* Remember the error: invalidate all subsequent fragments. *\/\n@@ -1093,7 +1080,7 @@ static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n \n \t\t\/* Take an extra reference to offset xen_netbk_idx_release *\/\n \t\tget_page(netbk->mmap_pages[pending_idx]);\n-\t\txen_netbk_idx_release(netbk, pending_idx);\n+\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n \t}\n }\n \n@@ -1476,7 +1463,7 @@ static void xen_netbk_tx_submit(struct xen_netbk *netbk)\n \t\t\ttxp->size -= data_len;\n \t\t} else {\n \t\t\t\/* Schedule a response immediately. *\/\n-\t\t\txen_netbk_idx_release(netbk, pending_idx);\n+\t\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n \t\t}\n \n \t\tif (txp->flags & XEN_NETTXF_csum_blank)\n@@ -1528,7 +1515,8 @@ static void xen_netbk_tx_action(struct xen_netbk *netbk)\n \txen_netbk_tx_submit(netbk);\n }\n \n-static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n+static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx,\n+\t\t\t\t  u8 status)\n {\n \tstruct xenvif *vif;\n \tstruct pending_tx_info *pending_tx_info;\n@@ -1542,7 +1530,7 @@ static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n \n \tvif = pending_tx_info->vif;\n \n-\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n+\tmake_tx_response(vif, &pending_tx_info->req, status);\n \n \tindex = pending_index(netbk->pending_prod++);\n \tnetbk->pending_ring[index] = pending_idx;\n","owner":"torvalds","repo":"linux","source":"cve"}]