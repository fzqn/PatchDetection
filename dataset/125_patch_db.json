[{"CVE_ID":"CVE-2017-7277","CWE_ID":"125","category":"security","commit_id":"8605330aac5a5785630aec8f64378a54891937cc","commit_message":"From 8605330aac5a5785630aec8f64378a54891937cc Mon Sep 17 00:00:00 2001\nFrom: Soheil Hassas Yeganeh <soheil@google.com>\nDate: Sat, 18 Mar 2017 17:02:59 -0400\nSubject: [PATCH] tcp: fix SCM_TIMESTAMPING_OPT_STATS for normal skbs\n\n__sock_recv_timestamp can be called for both normal skbs (for\nreceive timestamps) and for skbs on the error queue (for transmit\ntimestamps).\n\nCommit 1c885808e456\n(tcp: SOF_TIMESTAMPING_OPT_STATS option for SO_TIMESTAMPING)\nassumes any skb passed to __sock_recv_timestamp are from\nthe error queue, containing OPT_STATS in the content of the skb.\nThis results in accessing invalid memory or generating junk\ndata.\n\nTo fix this, set skb->pkt_type to PACKET_OUTGOING for packets\non the error queue. This is safe because on the receive path\non local sockets skb->pkt_type is never set to PACKET_OUTGOING.\nWith that, copy OPT_STATS from a packet, only if its pkt_type\nis PACKET_OUTGOING.\n\nFixes: 1c885808e456 (\"tcp: SOF_TIMESTAMPING_OPT_STATS option for SO_TIMESTAMPING\")\nReported-by: JongHwan Kim <zzoru007@gmail.com>\nSigned-off-by: Soheil Hassas Yeganeh <soheil@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Willem de Bruijn <willemb@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/skbuff.c | 10 ++++++++++\n net\/socket.c      | 13 ++++++++++++-\n 2 files changed, 22 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/core\/skbuff.c b\/net\/core\/skbuff.c\nindex cd4ba8c6b6091..b1fbd1958eb63 100644\n--- a\/net\/core\/skbuff.c\n+++ b\/net\/core\/skbuff.c\n@@ -3694,6 +3694,15 @@ static void sock_rmem_free(struct sk_buff *skb)\n \tatomic_sub(skb->truesize, &sk->sk_rmem_alloc);\n }\n \n+static void skb_set_err_queue(struct sk_buff *skb)\n+{\n+\t\/* pkt_type of skbs received on local sockets is never PACKET_OUTGOING.\n+\t * So, it is safe to (mis)use it to mark skbs on the error queue.\n+\t *\/\n+\tskb->pkt_type = PACKET_OUTGOING;\n+\tBUILD_BUG_ON(PACKET_OUTGOING == 0);\n+}\n+\n \/*\n  * Note: We dont mem charge error packets (no sk_forward_alloc changes)\n  *\/\n@@ -3707,6 +3716,7 @@ int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb)\n \tskb->sk = sk;\n \tskb->destructor = sock_rmem_free;\n \tatomic_add(skb->truesize, &sk->sk_rmem_alloc);\n+\tskb_set_err_queue(skb);\n \n \t\/* before exiting rcu section, make sure dst is refcounted *\/\n \tskb_dst_force(skb);\ndiff --git a\/net\/socket.c b\/net\/socket.c\nindex e034fe4164bee..692d6989d2c2b 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -652,6 +652,16 @@ int kernel_sendmsg(struct socket *sock, struct msghdr *msg,\n }\n EXPORT_SYMBOL(kernel_sendmsg);\n \n+static bool skb_is_err_queue(const struct sk_buff *skb)\n+{\n+\t\/* pkt_type of skbs enqueued on the error queue are set to\n+\t * PACKET_OUTGOING in skb_set_err_queue(). This is only safe to do\n+\t * in recvmsg, since skbs received on a local socket will never\n+\t * have a pkt_type of PACKET_OUTGOING.\n+\t *\/\n+\treturn skb->pkt_type == PACKET_OUTGOING;\n+}\n+\n \/*\n  * called from sock_recv_timestamp() if sock_flag(sk, SOCK_RCVTSTAMP)\n  *\/\n@@ -695,7 +705,8 @@ void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n \t\tput_cmsg(msg, SOL_SOCKET,\n \t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n \n-\t\tif (skb->len && (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS))\n+\t\tif (skb_is_err_queue(skb) && skb->len &&\n+\t\t    (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS))\n \t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n \t\t\t\t skb->len, skb->data);\n \t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-3561","CWE_ID":"125","category":"security","commit_id":"46003b4ab564b2abcd8470035fc324fe36aa8c75","commit_message":"From 46003b4ab564b2abcd8470035fc324fe36aa8c75 Mon Sep 17 00:00:00 2001\nFrom: Mat Hostetter <mjh@fb.com>\nDate: Sat, 6 Apr 2019 08:53:56 -0700\nSubject: [PATCH] Prevent strrpos and strripos from visiting out-of-bounds\n memory.\n\nReviewed By: alexeyt\n\nDifferential Revision: D14669668\n\nfbshipit-source-id: 16bb4674bccf83ffd737e60d1fd9fd4a0093f77c\n---\n hphp\/runtime\/base\/zend-string.cpp                | 5 +++--\n hphp\/test\/slow\/ext_string\/ext_string.php         | 9 +++++++++\n hphp\/test\/slow\/ext_string\/ext_string.php.expectf | 8 ++++++++\n 3 files changed, 20 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/hphp\/runtime\/base\/zend-string.cpp b\/hphp\/runtime\/base\/zend-string.cpp\nindex 40267cffd6f..e128af3ecd4 100644\n--- a\/hphp\/runtime\/base\/zend-string.cpp\n+++ b\/hphp\/runtime\/base\/zend-string.cpp\n@@ -21,6 +21,7 @@\n \n #include \"hphp\/util\/lock.h\"\n #include \"hphp\/util\/overflow.h\"\n+#include <algorithm>\n #include <cmath>\n \n #ifndef _MSC_VER\n@@ -385,13 +386,13 @@ int string_rfind(const char *input, int len, const char *s, int s_len,\n     if (pos >= 0) {\n       ptr = bstrrstr(input + pos, len - pos, s, s_len);\n     } else {\n-      ptr = bstrrstr(input, len + pos + s_len, s, s_len);\n+      ptr = bstrrstr(input, len + std::min(pos + s_len, 0), s, s_len);\n     }\n   } else {\n     if (pos >= 0) {\n       ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n     } else {\n-      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);\n+      ptr = bstrrcasestr(input, len + std::min(pos + s_len, 0), s, s_len);\n     }\n   }\n   if (ptr != nullptr) {\ndiff --git a\/hphp\/test\/slow\/ext_string\/ext_string.php b\/hphp\/test\/slow\/ext_string\/ext_string.php\nindex 836d8b0c684..ce3f3651280 100644\n--- a\/hphp\/test\/slow\/ext_string\/ext_string.php\n+++ b\/hphp\/test\/slow\/ext_string\/ext_string.php\n@@ -391,6 +391,15 @@ function main_ext_string() {\n \n var_dump(strripos(\"abcdef abcdef\", \"A\"));\n \n+var_dump(strrpos(\"abc\", \"c\\0\", -1));\n+var_dump(strripos(\"abc\", \"c\\0\", -1));\n+var_dump(strrpos(\"abc\", \"abc\", -3));\n+var_dump(strripos(\"abc\", \"abc\", -3));\n+var_dump(strrpos(\"aaaa\", \"aa\", -1));\n+var_dump(strripos(\"aaaa\", \"aa\", -1));\n+var_dump(strrpos(\"aaaa\", \"aa\", -2));\n+var_dump(strripos(\"aaaa\", \"aa\", -2));\n+\n $text = \"This is a test\";\n var_dump(substr_count($text, \"is\"));\n var_dump(substr_count($text, \"is\", 3));\ndiff --git a\/hphp\/test\/slow\/ext_string\/ext_string.php.expectf b\/hphp\/test\/slow\/ext_string\/ext_string.php.expectf\nindex 6ba58f635e9..f9bb69954ad 100644\n--- a\/hphp\/test\/slow\/ext_string\/ext_string.php.expectf\n+++ b\/hphp\/test\/slow\/ext_string\/ext_string.php.expectf\n@@ -220,6 +220,14 @@ int(17)\n int(27)\n bool(false)\n int(7)\n+bool(false)\n+bool(false)\n+int(0)\n+int(0)\n+int(2)\n+int(2)\n+int(2)\n+int(2)\n int(2)\n int(1)\n int(0)\n","owner":"facebook","repo":"hhvm","source":"cve"},{"CVE_ID":"CVE-2016-7521","CWE_ID":"125","category":"security","commit_id":"30eec879c8b446b0ea9a3bb0da1a441cc8482bc4","commit_message":"From 30eec879c8b446b0ea9a3bb0da1a441cc8482bc4 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Tue, 2 Feb 2016 21:03:24 +0100\nSubject: [PATCH] Moved check for\n https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/92.\n\n---\n coders\/psd.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex 11d26ea852..9f69d8a712 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -487,6 +487,7 @@ static ssize_t DecodePSDPixels(const size_t number_compact_pixels,\n     length++;\n     for (j=0; j < (ssize_t) length; j++)\n     {\n+      CheckNumberCompactPixels;\n       switch (depth)\n       {\n         case 1:\n@@ -525,7 +526,6 @@ static ssize_t DecodePSDPixels(const size_t number_compact_pixels,\n           break;\n         }\n       }\n-      CheckNumberCompactPixels;\n       compact_pixels++;\n     }\n   }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-20455","CWE_ID":"125","category":"security","commit_id":"9b46d38dd3c4de6048a488b655c7319f845af185","commit_message":"From 9b46d38dd3c4de6048a488b655c7319f845af185 Mon Sep 17 00:00:00 2001\nFrom: radare <pancake@nopcode.org>\nDate: Mon, 3 Dec 2018 01:46:58 +0100\nSubject: [PATCH] Fix #12372 and #12373 - Crash in x86 assembler (#12380)\n\n0 ,0,[bP-bL-bP-bL-bL-r-bL-bP-bL-bL-\nmov ,0,[ax+Bx-ax+Bx-ax+ax+Bx-ax+Bx--\nleA ,0,[bP-bL-bL-bP-bL-bP-bL-60@bL-\nleA ,0,[bP-bL-r-bP-bL-bP-bL-60@bL-\nmov ,0,[ax+Bx-ax+Bx-ax+ax+Bx-ax+Bx--\n---\n libr\/asm\/p\/asm_x86_nz.c | 11 +++++++----\n 1 file changed, 7 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libr\/asm\/p\/asm_x86_nz.c b\/libr\/asm\/p\/asm_x86_nz.c\nindex 623892b6d7..79abc9d60d 100644\n--- a\/libr\/asm\/p\/asm_x86_nz.c\n+++ b\/libr\/asm\/p\/asm_x86_nz.c\n@@ -4575,14 +4575,17 @@ static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {\n \t\t\tif (last_type == TT_SPECIAL) {\n \t\t\t\tif (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {\n \t\t\t\t\tif (reg != X86R_UNDEFINED) {\n-\t\t\t\t\t\top->regs[reg_index] = reg;\n-\t\t\t\t\t\top->scale[reg_index] = temp;\n+\t\t\t\t\t\tif (reg_index < 2) {\n+\t\t\t\t\t\t\top->regs[reg_index] = reg;\n+\t\t\t\t\t\t\top->scale[reg_index] = temp;\n+\t\t\t\t\t\t}\n \t\t\t\t\t\t++reg_index;\n \t\t\t\t\t} else {\n \t\t\t\t\t\top->offset += temp;\n-\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;\n+\t\t\t\t\t\tif (reg_index < 2) {\n+\t\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\n \t\t\t\t\ttemp = 1;\n \t\t\t\t\treg = X86R_UNDEFINED;\n \t\t\t\t} else if (str[pos] == '*') {\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2017-16535","CWE_ID":"125","category":"security","commit_id":"1c0edc3633b56000e18d82fc241e3995ca18a69e","commit_message":"From 1c0edc3633b56000e18d82fc241e3995ca18a69e Mon Sep 17 00:00:00 2001\nFrom: Alan Stern <stern@rowland.harvard.edu>\nDate: Wed, 18 Oct 2017 12:49:38 -0400\nSubject: [PATCH] USB: core: fix out-of-bounds access bug in\n usb_get_bos_descriptor()\n\nAndrey used the syzkaller fuzzer to find an out-of-bounds memory\naccess in usb_get_bos_descriptor().  The code wasn't checking that the\nnext usb_dev_cap_header structure could fit into the remaining buffer\nspace.\n\nThis patch fixes the error and also reduces the bNumDeviceCaps field\nin the header to match the actual number of capabilities found, in\ncases where there are fewer than expected.\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nCC: <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/usb\/core\/config.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/usb\/core\/config.c b\/drivers\/usb\/core\/config.c\nindex 68b54bd88d1eb..883549ee946cb 100644\n--- a\/drivers\/usb\/core\/config.c\n+++ b\/drivers\/usb\/core\/config.c\n@@ -960,10 +960,12 @@ int usb_get_bos_descriptor(struct usb_device *dev)\n \tfor (i = 0; i < num; i++) {\n \t\tbuffer += length;\n \t\tcap = (struct usb_dev_cap_header *)buffer;\n-\t\tlength = cap->bLength;\n \n-\t\tif (total_len < length)\n+\t\tif (total_len < sizeof(*cap) || total_len < cap->bLength) {\n+\t\t\tdev->bos->desc->bNumDeviceCaps = i;\n \t\t\tbreak;\n+\t\t}\n+\t\tlength = cap->bLength;\n \t\ttotal_len -= length;\n \n \t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-6310","CWE_ID":"125","category":"security","commit_id":"8dccf79857ceeb7a6d3e42c1e762e7b865d5344d","commit_message":"From 8dccf79857ceeb7a6d3e42c1e762e7b865d5344d Mon Sep 17 00:00:00 2001\nFrom: Eric Sesterhenn <eric.sesterhenn@x41-dsec.de>\nDate: Sun, 19 Feb 2017 19:36:35 +0100\nSubject: [PATCH] Check types to avoid invalid reads\/writes.\n\n---\n src\/file.c |  4 ++++\n src\/tnef.c | 16 +++++++++-------\n 2 files changed, 13 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/src\/file.c b\/src\/file.c\nindex 4dacda4..4b3d81d 100644\n--- a\/src\/file.c\n+++ b\/src\/file.c\n@@ -173,11 +173,13 @@ file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n \t    switch (a->name)\n \t    {\n \t    case MAPI_ATTACH_LONG_FILENAME:\n+\t\tassert(a->type == szMAPI_STRING);\n \t\tif (file->name) XFREE(file->name);\n \t\tfile->name = strdup( (char*)a->values[0].data.buf );\n \t\tbreak;\n \n \t    case MAPI_ATTACH_DATA_OBJ:\n+\t\tassert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));\n \t\tfile->len = a->values[0].len;\n \t\tif (file->data) XFREE (file->data);\n \t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n@@ -185,12 +187,14 @@ file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n \t\tbreak;\n \n              case MAPI_ATTACH_MIME_TAG:\n+\t\tassert(a->type == szMAPI_STRING);\n \t\tif (file->mime_type) XFREE (file->mime_type);\n \t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n \t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n \t\tbreak;\n \n                 case MAPI_ATTACH_CONTENT_ID:\n+                    assert(a->type == szMAPI_STRING);\n                     if (file->content_id) XFREE(file->content_id);\n                     file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                     memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\ndiff --git a\/src\/tnef.c b\/src\/tnef.c\nindex 0f1d9e4..7f74e88 100644\n--- a\/src\/tnef.c\n+++ b\/src\/tnef.c\n@@ -165,10 +165,12 @@ get_html_data (MAPI_Attr *a)\n     int j;\n     for (j = 0; j < a->num_values; j++)\n     {\n-\tbody[j] = XMALLOC(VarLenData, 1);\n-\tbody[j]->len = a->values[j].len;\n-\tbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n-\tmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n+        if (a->type == szMAPI_BINARY) {\n+ \t    body[j] = XMALLOC(VarLenData, 1);\n+\t    body[j]->len = a->values[j].len;\n+\t    body[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n+\t    memmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n+        }\n     }\n     return body;\n }\n@@ -306,13 +308,13 @@ parse_file (FILE* input_file, char* directory,\n \t\t    for (i = 0; mapi_attrs[i]; i++)\n \t\t    {\n \t\t\tMAPI_Attr *a = mapi_attrs[i];\n-\t\t\t    \n-\t\t\tif (a->name == MAPI_BODY_HTML)\n+\t\t\n+\t\t\tif (a->type == szMAPI_BINARY && a->name == MAPI_BODY_HTML)\n \t\t\t{\n \t\t\t    body.html_bodies = get_html_data (a);\n                                 html_size = a->num_values;\n \t\t\t}\n-\t\t\telse if (a->name == MAPI_RTF_COMPRESSED)\n+\t\t\telse if (a->type == szMAPI_BINARY && a->name == MAPI_RTF_COMPRESSED)\n \t\t\t{\n \t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                 rtf_size = a->num_values;\n","owner":"verdammelt","repo":"tnef","source":"cve"},{"CVE_ID":"CVE-2016-7529","CWE_ID":"125","category":"security","commit_id":"a2e1064f288a353bc5fef7f79ccb7683759e775c","commit_message":"From a2e1064f288a353bc5fef7f79ccb7683759e775c Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sat, 30 Jan 2016 09:51:24 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/104\n\n---\n coders\/xcf.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/xcf.c b\/coders\/xcf.c\nindex 0fdc546561..b8075bb682 100644\n--- a\/coders\/xcf.c\n+++ b\/coders\/xcf.c\n@@ -347,7 +347,8 @@ static MagickBooleanType load_tile(Image *image,Image *tile_image,\n     *xcfdata,\n     *xcfodata;\n \n-  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n+  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(MagickMax(data_length,\n+    tile_image->columns*tile_image->rows),sizeof(*xcfdata));\n   if (xcfdata == (XCFPixelInfo *) NULL)\n     ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n       image->filename);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-7163","CWE_ID":"125","category":"security","commit_id":"c16bc057ba3f125051c9966cf1f5b68a05681de4","commit_message":"From c16bc057ba3f125051c9966cf1f5b68a05681de4 Mon Sep 17 00:00:00 2001\nFrom: trylab <trylab@users.noreply.github.com>\nDate: Tue, 6 Sep 2016 13:55:49 +0800\nSubject: [PATCH] Fix an integer overflow issue (#809)\n\nPrevent an integer overflow issue in function opj_pi_create_decode of\npi.c.\n---\n src\/lib\/openjp2\/pi.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/lib\/openjp2\/pi.c b\/src\/lib\/openjp2\/pi.c\nindex cffad6684..36e2ff0cf 100644\n--- a\/src\/lib\/openjp2\/pi.c\n+++ b\/src\/lib\/openjp2\/pi.c\n@@ -1237,7 +1237,13 @@ opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n \tl_current_pi = l_pi;\n \n \t\/* memory allocation for include *\/\n-\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n+\t\/* prevent an integer overflow issue *\/\n+\tl_current_pi->include = 00;\n+\tif (l_step_l <= (SIZE_MAX \/ (l_tcp->numlayers + 1U)))\n+\t{\n+\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n+\t}\n+\n \tif\n \t\t(!l_current_pi->include)\n \t{\n","owner":"uclouvain","repo":"openjpeg","source":"cve"},{"CVE_ID":"CVE-2016-7951","CWE_ID":"125","category":"security","commit_id":"9556ad67af3129ec4a7a4f4b54a0d59701beeae3","commit_message":"From 9556ad67af3129ec4a7a4f4b54a0d59701beeae3 Mon Sep 17 00:00:00 2001\nFrom: Tobias Stoeckmann <tobias@stoeckmann.org>\nDate: Sun, 25 Sep 2016 21:37:01 +0200\nSubject: Out of boundary access and endless loop in libXtst\n\nA lack of range checks in libXtst allows out of boundary accesses.\nThe checks have to be done in-place here, because it cannot be done\nwithout in-depth knowledge of the read data.\n\nIf XRecordStartOfData, XRecordEndOfData, or XRecordClientDied\nwithout a client sequence have attached data, an endless loop would\noccur. The do-while-loop continues until the current index reaches\nthe end. But in these cases, the current index would not be\nincremented, leading to an endless processing.\n\nSigned-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>\nReviewed-by: Matthieu Herrb <matthieu@herrb.eu>\n---\n src\/XRecord.c | 43 +++++++++++++++++++++++++++++++++++++++----\n 1 file changed, 39 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/src\/XRecord.c b\/src\/XRecord.c\nindex 50420c0..fefd842 100644\n--- a\/src\/XRecord.c\n+++ b\/src\/XRecord.c\n@@ -749,15 +749,23 @@ parse_reply_call_callback(\n \tswitch (rep->category) {\n \tcase XRecordFromServer:\n \t    if (rep->elementHeader&XRecordFromServerTime) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->server_time);\n \t\tcurrent_index += 4;\n \t    }\n+\t    if (current_index + 1 > rep->length << 2)\n+\t\treturn Error;\n \t    switch (reply->buf[current_index]) {\n \t    case X_Reply: \/* reply *\/\n+\t\tif (current_index + 8 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index+4, datum_bytes);\n+\t\tif (datum_bytes < 0 || datum_bytes > ((INT_MAX >> 2) - 8))\n+\t\t    return Error;\n \t\tdatum_bytes = (datum_bytes+8) << 2;\n \t\tbreak;\n \t    default: \/* error or event *\/\n@@ -766,52 +774,73 @@ parse_reply_call_callback(\n \t    break;\n \tcase XRecordFromClient:\n \t    if (rep->elementHeader&XRecordFromClientTime) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->server_time);\n \t\tcurrent_index += 4;\n \t    }\n \t    if (rep->elementHeader&XRecordFromClientSequence) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->client_seq);\n \t\tcurrent_index += 4;\n \t    }\n+\t    if (current_index + 4 > rep->length<<2)\n+\t\treturn Error;\n \t    if (reply->buf[current_index+2] == 0\n \t\t&& reply->buf[current_index+3] == 0) \/* needn't swap 0 *\/\n \t    {\t\/* BIG-REQUESTS *\/\n+\t\tif (current_index + 8 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index+4, datum_bytes);\n \t    } else {\n \t\tEXTRACT_CARD16(rep->clientSwapped,\n \t\t\t       reply->buf+current_index+2, datum_bytes);\n \t    }\n+\t    if (datum_bytes < 0 || datum_bytes > INT_MAX >> 2)\n+\t\treturn Error;\n \t    datum_bytes <<= 2;\n \t    break;\n \tcase XRecordClientStarted:\n+\t    if (current_index + 8 > rep->length << 2)\n+\t\treturn Error;\n \t    EXTRACT_CARD16(rep->clientSwapped,\n \t\t\t   reply->buf+current_index+6, datum_bytes);\n \t    datum_bytes = (datum_bytes+2) << 2;\n \t    break;\n \tcase XRecordClientDied:\n \t    if (rep->elementHeader&XRecordFromClientSequence) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->client_seq);\n \t\tcurrent_index += 4;\n-\t    }\n-\t    \/* fall through *\/\n+\t    } else if (current_index < rep->length << 2)\n+\t\treturn Error;\n+\t    datum_bytes = 0;\n+\t    break;\n \tcase XRecordStartOfData:\n \tcase XRecordEndOfData:\n+\t    if (current_index < rep->length << 2)\n+\t\treturn Error;\n \t    datum_bytes = 0;\n+\t    break;\n \t}\n \n \tif (datum_bytes > 0) {\n-\t    if (current_index + datum_bytes > rep->length << 2)\n+\t    if (INT_MAX - datum_bytes < (rep->length << 2) - current_index) {\n \t\tfprintf(stderr,\n \t\t\t\"XRecord: %lu-byte reply claims %d-byte element (seq %lu)\\n\",\n-\t\t\t(long)rep->length << 2, current_index + datum_bytes,\n+\t\t\t(unsigned long)rep->length << 2, current_index + datum_bytes,\n \t\t\tdpy->last_request_read);\n+\t\treturn Error;\n+\t    }\n \t    \/*\n \t     * This assignment (and indeed the whole buffer sharing\n \t     * scheme) assumes arbitrary 4-byte boundaries are\n@@ -863,6 +892,12 @@ XRecordEnableContext(Display *dpy, XRecordContext context,\n \t    return 0;\n \t}\n \n+\tif (rep.length > INT_MAX >> 2) {\n+\t    UnlockDisplay(dpy);\n+\t    SyncHandle();\n+\t    return 0;\n+\t}\n+\n \tif (rep.length > 0) {\n \t    reply = alloc_reply_buffer(info, rep.length<<2);\n \t    if (!reply) {\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7914","CWE_ID":"125","category":"security","commit_id":"8d4a2ec1e0b41b0cf9a0c5cd4511da7f8e4f3de2","commit_message":"From 8d4a2ec1e0b41b0cf9a0c5cd4511da7f8e4f3de2 Mon Sep 17 00:00:00 2001\nFrom: Jerome Marchand <jmarchan@redhat.com>\nDate: Wed, 6 Apr 2016 14:06:48 +0100\nSubject: [PATCH] assoc_array: don't call compare_object() on a node\n\nChanges since V1: fixed the description and added KASan warning.\n\nIn assoc_array_insert_into_terminal_node(), we call the\ncompare_object() method on all non-empty slots, even when they're\nnot leaves, passing a pointer to an unexpected structure to\ncompare_object(). Currently it causes an out-of-bound read access\nin keyring_compare_object detected by KASan (see below). The issue\nis easily reproduced with keyutils testsuite.\nOnly call compare_object() when the slot is a leave.\n\nKASan warning:\n==================================================================\nBUG: KASAN: slab-out-of-bounds in keyring_compare_object+0x213\/0x240 at addr ffff880060a6f838\nRead of size 8 by task keyctl\/1655\n=============================================================================\nBUG kmalloc-192 (Not tainted): kasan: bad access detected\n-----------------------------------------------------------------------------\n\nDisabling lock debugging due to kernel taint\nINFO: Allocated in assoc_array_insert+0xfd0\/0x3a60 age=69 cpu=1 pid=1647\n\t___slab_alloc+0x563\/0x5c0\n\t__slab_alloc+0x51\/0x90\n\tkmem_cache_alloc_trace+0x263\/0x300\n\tassoc_array_insert+0xfd0\/0x3a60\n\t__key_link_begin+0xfc\/0x270\n\tkey_create_or_update+0x459\/0xaf0\n\tSyS_add_key+0x1ba\/0x350\n\tentry_SYSCALL_64_fastpath+0x12\/0x76\nINFO: Slab 0xffffea0001829b80 objects=16 used=8 fp=0xffff880060a6f550 flags=0x3fff8000004080\nINFO: Object 0xffff880060a6f740 @offset=5952 fp=0xffff880060a6e5d1\n\nBytes b4 ffff880060a6f730: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject ffff880060a6f740: d1 e5 a6 60 00 88 ff ff 0e 00 00 00 00 00 00 00  ...`............\nObject ffff880060a6f750: 02 cf 8e 60 00 88 ff ff 02 c0 8e 60 00 88 ff ff  ...`.......`....\nObject ffff880060a6f760: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject ffff880060a6f770: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject ffff880060a6f780: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject ffff880060a6f790: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject ffff880060a6f7a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject ffff880060a6f7b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject ffff880060a6f7c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject ffff880060a6f7d0: 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject ffff880060a6f7e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nObject ffff880060a6f7f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\nCPU: 0 PID: 1655 Comm: keyctl Tainted: G    B           4.5.0-rc4-kasan+ #291\nHardware name: Bochs Bochs, BIOS Bochs 01\/01\/2011\n 0000000000000000 000000001b2800b4 ffff880060a179e0 ffffffff81b60491\n ffff88006c802900 ffff880060a6f740 ffff880060a17a10 ffffffff815e2969\n ffff88006c802900 ffffea0001829b80 ffff880060a6f740 ffff880060a6e650\nCall Trace:\n [<ffffffff81b60491>] dump_stack+0x85\/0xc4\n [<ffffffff815e2969>] print_trailer+0xf9\/0x150\n [<ffffffff815e9454>] object_err+0x34\/0x40\n [<ffffffff815ebe50>] kasan_report_error+0x230\/0x550\n [<ffffffff819949be>] ? keyring_get_key_chunk+0x13e\/0x210\n [<ffffffff815ec62d>] __asan_report_load_n_noabort+0x5d\/0x70\n [<ffffffff81994cc3>] ? keyring_compare_object+0x213\/0x240\n [<ffffffff81994cc3>] keyring_compare_object+0x213\/0x240\n [<ffffffff81bc238c>] assoc_array_insert+0x86c\/0x3a60\n [<ffffffff81bc1b20>] ? assoc_array_cancel_edit+0x70\/0x70\n [<ffffffff8199797d>] ? __key_link_begin+0x20d\/0x270\n [<ffffffff8199786c>] __key_link_begin+0xfc\/0x270\n [<ffffffff81993389>] key_create_or_update+0x459\/0xaf0\n [<ffffffff8128ce0d>] ? trace_hardirqs_on+0xd\/0x10\n [<ffffffff81992f30>] ? key_type_lookup+0xc0\/0xc0\n [<ffffffff8199e19d>] ? lookup_user_key+0x13d\/0xcd0\n [<ffffffff81534763>] ? memdup_user+0x53\/0x80\n [<ffffffff819983ea>] SyS_add_key+0x1ba\/0x350\n [<ffffffff81998230>] ? key_get_type_from_user.constprop.6+0xa0\/0xa0\n [<ffffffff828bcf4e>] ? retint_user+0x18\/0x23\n [<ffffffff8128cc7e>] ? trace_hardirqs_on_caller+0x3fe\/0x580\n [<ffffffff81004017>] ? trace_hardirqs_on_thunk+0x17\/0x19\n [<ffffffff828bc432>] entry_SYSCALL_64_fastpath+0x12\/0x76\nMemory state around the buggy address:\n ffff880060a6f700: fc fc fc fc fc fc fc fc 00 00 00 00 00 00 00 00\n ffff880060a6f780: 00 00 00 00 00 00 00 00 00 00 00 fc fc fc fc fc\n>ffff880060a6f800: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n                                        ^\n ffff880060a6f880: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff880060a6f900: fc fc fc fc fc fc 00 00 00 00 00 00 00 00 00 00\n==================================================================\n\nSigned-off-by: Jerome Marchand <jmarchan@redhat.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\ncc: stable@vger.kernel.org\n---\n lib\/assoc_array.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/lib\/assoc_array.c b\/lib\/assoc_array.c\nindex 03dd576e67730..59fd7c0b119cb 100644\n--- a\/lib\/assoc_array.c\n+++ b\/lib\/assoc_array.c\n@@ -524,7 +524,9 @@ static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n \t\t\tfree_slot = i;\n \t\t\tcontinue;\n \t\t}\n-\t\tif (ops->compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) {\n+\t\tif (assoc_array_ptr_is_leaf(ptr) &&\n+\t\t    ops->compare_object(assoc_array_ptr_to_leaf(ptr),\n+\t\t\t\t\tindex_key)) {\n \t\t\tpr_devel(\"replace in slot %d\\n\", i);\n \t\t\tedit->leaf_p = &node->slots[i];\n \t\t\tedit->dead_leaf = node->slots[i];\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-16643","CWE_ID":"125","category":"security","commit_id":"a50829479f58416a013a4ccca791336af3c584c7","commit_message":"From a50829479f58416a013a4ccca791336af3c584c7 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Torokhov <dmitry.torokhov@gmail.com>\nDate: Mon, 23 Oct 2017 16:46:00 -0700\nSubject: [PATCH] Input: gtco - fix potential out-of-bound access\n\nparse_hid_report_descriptor() has a while (i < length) loop, which\nonly guarantees that there's at least 1 byte in the buffer, but the\nloop body can read multiple bytes which causes out-of-bounds access.\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nReviewed-by: Andrey Konovalov <andreyknvl@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>\n---\n drivers\/input\/tablet\/gtco.c | 17 ++++++++++-------\n 1 file changed, 10 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/input\/tablet\/gtco.c b\/drivers\/input\/tablet\/gtco.c\nindex b796e891e2eed..4b8b9d7aa75e2 100644\n--- a\/drivers\/input\/tablet\/gtco.c\n+++ b\/drivers\/input\/tablet\/gtco.c\n@@ -230,13 +230,17 @@ static void parse_hid_report_descriptor(struct gtco *device, char * report,\n \n \t\/* Walk  this report and pull out the info we need *\/\n \twhile (i < length) {\n-\t\tprefix = report[i];\n-\n-\t\t\/* Skip over prefix *\/\n-\t\ti++;\n+\t\tprefix = report[i++];\n \n \t\t\/* Determine data size and save the data in the proper variable *\/\n-\t\tsize = PREF_SIZE(prefix);\n+\t\tsize = (1U << PREF_SIZE(prefix)) >> 1;\n+\t\tif (i + size > length) {\n+\t\t\tdev_err(ddev,\n+\t\t\t\t\"Not enough data (need %d, have %d)\\n\",\n+\t\t\t\ti + size, length);\n+\t\t\tbreak;\n+\t\t}\n+\n \t\tswitch (size) {\n \t\tcase 1:\n \t\t\tdata = report[i];\n@@ -244,8 +248,7 @@ static void parse_hid_report_descriptor(struct gtco *device, char * report,\n \t\tcase 2:\n \t\t\tdata16 = get_unaligned_le16(&report[i]);\n \t\t\tbreak;\n-\t\tcase 3:\n-\t\t\tsize = 4;\n+\t\tcase 4:\n \t\t\tdata32 = get_unaligned_le32(&report[i]);\n \t\t\tbreak;\n \t\t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-16840","CWE_ID":"125","category":"security","commit_id":"a94cb36ab2ad99d3a1331c9f91831ef593d94f74","commit_message":"From a94cb36ab2ad99d3a1331c9f91831ef593d94f74 Mon Sep 17 00:00:00 2001\nFrom: Rostislav Pehlivanov <atomnuker@gmail.com>\nDate: Wed, 8 Nov 2017 23:50:04 +0000\nSubject: [PATCH] vc2enc_dwt: pad the temporary buffer by the slice size\n\nSince non-Haar wavelets need to look into pixels outside the frame, we\nneed to pad the buffer. The old factor of two seemed to be a workaround\nthat fact and only padded to the left and bottom. This correctly pads\nby the slice size and as such reduces memory usage and potential\nexploits.\nReported by Liu Bingchang.\n\nIdeally, there should be no temporary buffer but the encoder is designed\nto deinterleave the coefficients into the classical wavelet structure\nwith the lower frequency values in the top left corner.\n\nSigned-off-by: Rostislav Pehlivanov <atomnuker@gmail.com>\n(cherry picked from commit 3228ac730c11eca49d5680d5550128e397061c85)\n---\n libavcodec\/vc2enc.c     |  3 ++-\n libavcodec\/vc2enc_dwt.c | 12 +++++++++---\n libavcodec\/vc2enc_dwt.h |  4 +++-\n 3 files changed, 14 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/vc2enc.c b\/libavcodec\/vc2enc.c\nindex 96e27d93ed..1059f41b56 100644\n--- a\/libavcodec\/vc2enc.c\n+++ b\/libavcodec\/vc2enc.c\n@@ -1190,7 +1190,8 @@ static av_cold int vc2_encode_init(AVCodecContext *avctx)\n         \/* DWT init *\/\n         if (ff_vc2enc_init_transforms(&s->transform_args[i].t,\n                                       s->plane[i].coef_stride,\n-                                      s->plane[i].dwt_height))\n+                                      s->plane[i].dwt_height,\n+                                      s->slice_width, s->slice_height))\n             goto alloc_fail;\n     }\n \ndiff --git a\/libavcodec\/vc2enc_dwt.c b\/libavcodec\/vc2enc_dwt.c\nindex c60b003a31..d22af8a313 100644\n--- a\/libavcodec\/vc2enc_dwt.c\n+++ b\/libavcodec\/vc2enc_dwt.c\n@@ -255,21 +255,27 @@ static void vc2_subband_dwt_haar_shift(VC2TransformContext *t, dwtcoef *data,\n     dwt_haar(t, data, stride, width, height, 1);\n }\n \n-av_cold int ff_vc2enc_init_transforms(VC2TransformContext *s, int p_width, int p_height)\n+av_cold int ff_vc2enc_init_transforms(VC2TransformContext *s, int p_stride,\n+                                      int p_height, int slice_w, int slice_h)\n {\n     s->vc2_subband_dwt[VC2_TRANSFORM_9_7]    = vc2_subband_dwt_97;\n     s->vc2_subband_dwt[VC2_TRANSFORM_5_3]    = vc2_subband_dwt_53;\n     s->vc2_subband_dwt[VC2_TRANSFORM_HAAR]   = vc2_subband_dwt_haar;\n     s->vc2_subband_dwt[VC2_TRANSFORM_HAAR_S] = vc2_subband_dwt_haar_shift;\n \n-    s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));\n+    \/* Pad by the slice size, only matters for non-Haar wavelets *\/\n+    s->buffer = av_calloc((p_stride + slice_w)*(p_height + slice_h), sizeof(dwtcoef));\n     if (!s->buffer)\n         return 1;\n \n+    s->padding = (slice_h >> 1)*p_stride + (slice_w >> 1);\n+    s->buffer += s->padding;\n+\n     return 0;\n }\n \n av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n {\n-    av_freep(&s->buffer);\n+    av_free(s->buffer - s->padding);\n+    s->buffer = NULL;\n }\ndiff --git a\/libavcodec\/vc2enc_dwt.h b\/libavcodec\/vc2enc_dwt.h\nindex 7fbbfbe0ed..a6932bcdaf 100644\n--- a\/libavcodec\/vc2enc_dwt.h\n+++ b\/libavcodec\/vc2enc_dwt.h\n@@ -41,12 +41,14 @@ enum VC2TransformType {\n \n typedef struct VC2TransformContext {\n     dwtcoef *buffer;\n+    int padding;\n     void (*vc2_subband_dwt[VC2_TRANSFORMS_NB])(struct VC2TransformContext *t,\n                                                dwtcoef *data, ptrdiff_t stride,\n                                                int width, int height);\n } VC2TransformContext;\n \n-int  ff_vc2enc_init_transforms(VC2TransformContext *t, int p_width, int p_height);\n+int  ff_vc2enc_init_transforms(VC2TransformContext *t, int p_stride, int p_height,\n+                               int slice_w, int slice_h);\n void ff_vc2enc_free_transforms(VC2TransformContext *t);\n \n #endif \/* AVCODEC_VC2ENC_DWT_H *\/\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-16530","CWE_ID":"125","category":"security","commit_id":"786de92b3cb26012d3d0f00ee37adf14527f35c4","commit_message":"From 786de92b3cb26012d3d0f00ee37adf14527f35c4 Mon Sep 17 00:00:00 2001\nFrom: Alan Stern <stern@rowland.harvard.edu>\nDate: Fri, 22 Sep 2017 11:56:49 -0400\nSubject: [PATCH] USB: uas: fix bug in handling of alternate settings\n\nThe uas driver has a subtle bug in the way it handles alternate\nsettings.  The uas_find_uas_alt_setting() routine returns an\naltsetting value (the bAlternateSetting number in the descriptor), but\nuas_use_uas_driver() then treats that value as an index to the\nintf->altsetting array, which it isn't.\n\nNormally this doesn't cause any problems because the various\nalternate settings have bAlternateSetting values 0, 1, 2, ..., so the\nvalue is equal to the index in the array.  But this is not guaranteed,\nand Andrey Konovalov used the syzkaller fuzzer with KASAN to get a\nslab-out-of-bounds error by violating this assumption.\n\nThis patch fixes the bug by making uas_find_uas_alt_setting() return a\npointer to the altsetting entry rather than either the value or the\nindex.  Pointers are less subject to misinterpretation.\n\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nCC: Oliver Neukum <oneukum@suse.com>\nCC: <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/usb\/storage\/uas-detect.h | 15 ++++++++-------\n drivers\/usb\/storage\/uas.c        | 10 +++++-----\n 2 files changed, 13 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/usb\/storage\/uas-detect.h b\/drivers\/usb\/storage\/uas-detect.h\nindex f58caa9e6a27e..a155cd02bce24 100644\n--- a\/drivers\/usb\/storage\/uas-detect.h\n+++ b\/drivers\/usb\/storage\/uas-detect.h\n@@ -9,7 +9,8 @@ static int uas_is_interface(struct usb_host_interface *intf)\n \t\tintf->desc.bInterfaceProtocol == USB_PR_UAS);\n }\n \n-static int uas_find_uas_alt_setting(struct usb_interface *intf)\n+static struct usb_host_interface *uas_find_uas_alt_setting(\n+\t\tstruct usb_interface *intf)\n {\n \tint i;\n \n@@ -17,10 +18,10 @@ static int uas_find_uas_alt_setting(struct usb_interface *intf)\n \t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n \n \t\tif (uas_is_interface(alt))\n-\t\t\treturn alt->desc.bAlternateSetting;\n+\t\t\treturn alt;\n \t}\n \n-\treturn -ENODEV;\n+\treturn NULL;\n }\n \n static int uas_find_endpoints(struct usb_host_interface *alt,\n@@ -58,14 +59,14 @@ static int uas_use_uas_driver(struct usb_interface *intf,\n \tstruct usb_device *udev = interface_to_usbdev(intf);\n \tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n \tunsigned long flags = id->driver_info;\n-\tint r, alt;\n-\n+\tstruct usb_host_interface *alt;\n+\tint r;\n \n \talt = uas_find_uas_alt_setting(intf);\n-\tif (alt < 0)\n+\tif (!alt)\n \t\treturn 0;\n \n-\tr = uas_find_endpoints(&intf->altsetting[alt], eps);\n+\tr = uas_find_endpoints(alt, eps);\n \tif (r < 0)\n \t\treturn 0;\n \ndiff --git a\/drivers\/usb\/storage\/uas.c b\/drivers\/usb\/storage\/uas.c\nindex cfb1e3bbd4347..63cf981ed81cf 100644\n--- a\/drivers\/usb\/storage\/uas.c\n+++ b\/drivers\/usb\/storage\/uas.c\n@@ -873,14 +873,14 @@ MODULE_DEVICE_TABLE(usb, uas_usb_ids);\n static int uas_switch_interface(struct usb_device *udev,\n \t\t\t\tstruct usb_interface *intf)\n {\n-\tint alt;\n+\tstruct usb_host_interface *alt;\n \n \talt = uas_find_uas_alt_setting(intf);\n-\tif (alt < 0)\n-\t\treturn alt;\n+\tif (!alt)\n+\t\treturn -ENODEV;\n \n-\treturn usb_set_interface(udev,\n-\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n+\treturn usb_set_interface(udev, alt->desc.bInterfaceNumber,\n+\t\t\talt->desc.bAlternateSetting);\n }\n \n static int uas_configure_endpoints(struct uas_dev_info *devinfo)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-7728","CWE_ID":"125","category":"security","commit_id":"e163667a06a9b656a047b0ec660b871f29a83c9f","commit_message":"From e163667a06a9b656a047b0ec660b871f29a83c9f Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Hubert=20Figui=C3=A8re?= <hub@figuiere.net>\nDate: Sun, 25 Feb 2018 14:01:52 -0500\nSubject: Bug 105205 - fix a buffer overflow in the TIFF parser\n\n---\n XMPFiles\/source\/FileHandlers\/TIFF_Handler.cpp | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/XMPFiles\/source\/FileHandlers\/TIFF_Handler.cpp b\/XMPFiles\/source\/FileHandlers\/TIFF_Handler.cpp\nindex a09b879..37e4ab1 100644\n--- a\/XMPFiles\/source\/FileHandlers\/TIFF_Handler.cpp\n+++ b\/XMPFiles\/source\/FileHandlers\/TIFF_Handler.cpp\n@@ -235,8 +235,9 @@ void TIFF_MetaHandler::ProcessXMP()\n \t\t\t\/\/ zero padding for the IPTC digest. If the full digest differs, recheck without the padding.\n \n \t\t\tiptcDigestState = PhotoDataUtils::CheckIPTCDigest ( iptcInfo.dataPtr, iptcInfo.dataLen, digestInfo.dataPtr );\n-\n-\t\t\tif ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) ) {\n+\t\t\t\/\/ See bug https:\/\/bugs.freedesktop.org\/show_bug.cgi?id=105205\n+\t\t\t\/\/ if iptcInfo.dataLen is 0, then there is no digest.\n+\t\t\tif ( (iptcDigestState == kDigestDiffers) && (kTIFF_TypeSizes[iptcInfo.type] > 1) && iptcInfo.dataLen > 0 ) {\n \t\t\t\tXMP_Uns8 * endPtr = (XMP_Uns8*)iptcInfo.dataPtr + iptcInfo.dataLen - 1;\n \t\t\t\tXMP_Uns8 * minPtr = endPtr - kTIFF_TypeSizes[iptcInfo.type] + 1;\n \t\t\t\twhile ( (endPtr >= minPtr) && (*endPtr == 0) ) --endPtr;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-11375","CWE_ID":"125","category":"security","commit_id":"041e53cab7ca33481ae45ecd65ad596976d78e68","commit_message":"From 041e53cab7ca33481ae45ecd65ad596976d78e68 Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Fri, 20 Apr 2018 19:44:43 +0200\nSubject: [PATCH] Fix crash in anal.avr\n\n---\n libr\/anal\/p\/anal_avr.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/libr\/anal\/p\/anal_avr.c b\/libr\/anal\/p\/anal_avr.c\nindex e7717beb7c..1da1ab0551 100644\n--- a\/libr\/anal\/p\/anal_avr.c\n+++ b\/libr\/anal\/p\/anal_avr.c\n@@ -912,6 +912,9 @@ INST_HANDLER (ldi) {\t\/\/ LDI Rd, K\n }\n \n INST_HANDLER (lds) {\t\/\/ LDS Rd, k\n+\tif (len < 4) {\n+\t\treturn;\n+\t}\n \tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n \tint k = (buf[3] << 8) | buf[2];\n \top->ptr = k;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2016-10029","CWE_ID":"125","category":"security","commit_id":"2fe760554eb3769d70f608a158474f728ba45ba6","commit_message":"From 2fe760554eb3769d70f608a158474f728ba45ba6 Mon Sep 17 00:00:00 2001\nFrom: =?utf8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>\nDate: Thu, 19 May 2016 12:25:58 +0200\nSubject: [PATCH] virtio-gpu: check max_outputs only\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nThe scanout id should not be above the configured num_scanouts.\n\nSigned-off-by: Marc-Andr\u00c3\u00a9 Lureau <marcandre.lureau@redhat.com>\nMessage-id: 1463653560-26958-5-git-send-email-marcandre.lureau@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/display\/virtio-gpu-3d.c | 4 ++--\n hw\/display\/virtio-gpu.c    | 5 ++---\n 2 files changed, 4 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/hw\/display\/virtio-gpu-3d.c b\/hw\/display\/virtio-gpu-3d.c\nindex 20e8865..433bf93 100644\n--- a\/hw\/display\/virtio-gpu-3d.c\n+++ b\/hw\/display\/virtio-gpu-3d.c\n@@ -128,7 +128,7 @@ static void virgl_cmd_resource_flush(VirtIOGPU *g,\n     trace_virtio_gpu_cmd_res_flush(rf.resource_id,\n                                    rf.r.width, rf.r.height, rf.r.x, rf.r.y);\n \n-    for (i = 0; i < VIRTIO_GPU_MAX_SCANOUT; i++) {\n+    for (i = 0; i < g->conf.max_outputs; i++) {\n         if (g->scanout[i].resource_id != rf.resource_id) {\n             continue;\n         }\n@@ -147,7 +147,7 @@ static void virgl_cmd_set_scanout(VirtIOGPU *g,\n     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,\n                                      ss.r.width, ss.r.height, ss.r.x, ss.r.y);\n \n-    if (ss.scanout_id >= VIRTIO_GPU_MAX_SCANOUT) {\n+    if (ss.scanout_id >= g->conf.max_outputs) {\n         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",\n                       __func__, ss.scanout_id);\n         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;\ndiff --git a\/hw\/display\/virtio-gpu.c b\/hw\/display\/virtio-gpu.c\nindex 7114021..643dd92 100644\n--- a\/hw\/display\/virtio-gpu.c\n+++ b\/hw\/display\/virtio-gpu.c\n@@ -466,7 +466,7 @@ static void virtio_gpu_resource_flush(VirtIOGPU *g,\n \n     pixman_region_init_rect(&flush_region,\n                             rf.r.x, rf.r.y, rf.r.width, rf.r.height);\n-    for (i = 0; i < VIRTIO_GPU_MAX_SCANOUT; i++) {\n+    for (i = 0; i < g->conf.max_outputs; i++) {\n         struct virtio_gpu_scanout *scanout;\n         pixman_region16_t region, finalregion;\n         pixman_box16_t *extents;\n@@ -509,8 +509,7 @@ static void virtio_gpu_set_scanout(VirtIOGPU *g,\n     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,\n                                      ss.r.width, ss.r.height, ss.r.x, ss.r.y);\n \n-    if (ss.scanout_id >= VIRTIO_GPU_MAX_SCANOUT ||\n-        ss.scanout_id >= g->conf.max_outputs) {\n+    if (ss.scanout_id >= g->conf.max_outputs) {\n         qemu_log_mask(LOG_GUEST_ERROR, \"%s: illegal scanout id specified %d\",\n                       __func__, ss.scanout_id);\n         cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-7557","CWE_ID":"125","category":"security","commit_id":"7414d0bda7763f9bd69c26c068e482ab297c1c96","commit_message":"From 7414d0bda7763f9bd69c26c068e482ab297c1c96 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Mon, 26 Feb 2018 03:02:48 +0100\nSubject: [PATCH] avcodec\/utvideodec: Check subsample factors\n\nFixes: Out of array read\nFixes: heap_poc\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/utvideodec.c | 9 +++++++++\n 1 file changed, 9 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/utvideodec.c b\/libavcodec\/utvideodec.c\nindex c5f5534..086129d 100644\n--- a\/libavcodec\/utvideodec.c\n+++ b\/libavcodec\/utvideodec.c\n@@ -30,6 +30,7 @@\n #define UNCHECKED_BITSTREAM_READER 1\n \n #include \"libavutil\/intreadwrite.h\"\n+#include \"libavutil\/pixdesc.h\"\n #include \"avcodec.h\"\n #include \"bswapdsp.h\"\n #include \"bytestream.h\"\n@@ -912,6 +913,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n static av_cold int decode_init(AVCodecContext *avctx)\n {\n     UtvideoContext * const c = avctx->priv_data;\n+    int h_shift, v_shift;\n \n     c->avctx = avctx;\n \n@@ -1012,6 +1014,13 @@ static av_cold int decode_init(AVCodecContext *avctx)\n         return AVERROR_INVALIDDATA;\n     }\n \n+    av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &h_shift, &v_shift);\n+    if ((avctx->width  & ((1<<h_shift)-1)) ||\n+        (avctx->height & ((1<<v_shift)-1))) {\n+        avpriv_request_sample(avctx, \"Odd dimensions\");\n+        return AVERROR_PATCHWELCOME;\n+    }\n+\n     if (c->pack && avctx->extradata_size >= 16) {\n         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",\n                avctx->extradata[3], avctx->extradata[2],\n-- \n2.7.4\n\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-14502","CWE_ID":"125","category":"security","commit_id":"5562545b5562f6d12a4ef991fae158bf4ccf92b6","commit_message":"From 5562545b5562f6d12a4ef991fae158bf4ccf92b6 Mon Sep 17 00:00:00 2001\nFrom: Joerg Sonnenberger <joerg@bec.de>\nDate: Sat, 9 Sep 2017 17:47:32 +0200\nSubject: [PATCH] Avoid a read off-by-one error for UTF16 names in RAR\n archives.\n\nReported-By: OSS-Fuzz issue 573\n---\n libarchive\/archive_read_support_format_rar.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libarchive\/archive_read_support_format_rar.c b\/libarchive\/archive_read_support_format_rar.c\nindex cbb14c32d..751de6979 100644\n--- a\/libarchive\/archive_read_support_format_rar.c\n+++ b\/libarchive\/archive_read_support_format_rar.c\n@@ -1496,7 +1496,11 @@ read_header(struct archive_read *a, struct archive_entry *entry,\n         return (ARCHIVE_FATAL);\n       }\n       filename[filename_size++] = '\\0';\n-      filename[filename_size++] = '\\0';\n+      \/*\n+       * Do not increment filename_size here as the computations below\n+       * add the space for the terminating NUL explicitly.\n+       *\/\n+      filename[filename_size] = '\\0';\n \n       \/* Decoded unicode form is UTF-16BE, so we have to update a string\n        * conversion object for it. *\/\n","owner":"libarchive","repo":"libarchive","source":"cve"},{"CVE_ID":"CVE-2018-20459","CWE_ID":"125","category":"security","commit_id":"88a8adf080a9f8ed5a4250a2507752e133ba54dd","commit_message":"From 88a8adf080a9f8ed5a4250a2507752e133ba54dd Mon Sep 17 00:00:00 2001\nFrom: David Carlier <devnexen@gmail.com>\nDate: Mon, 10 Dec 2018 14:22:51 +0000\nSubject: [PATCH] Fix #12417\/#12418 attempts.\n\n---\n libr\/asm\/arch\/arm\/armass.c   | 2 +-\n libr\/asm\/arch\/arm\/armass64.c | 2 +-\n 2 files changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libr\/asm\/arch\/arm\/armass.c b\/libr\/asm\/arch\/arm\/armass.c\nindex 6b752c0463..dc1b05e9c3 100644\n--- a\/libr\/asm\/arch\/arm\/armass.c\n+++ b\/libr\/asm\/arch\/arm\/armass.c\n@@ -6545,7 +6545,7 @@ ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n \tint i, j;\n \tchar buf[128];\n \tArmOpcode aop = {.off = off};\n-\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n+\tfor (i = j = 0; i < sizeof (buf) - 1 && str[j]; i++, j++) {\n \t\tif (str[j] == '#') {\n \t\t\ti--; continue;\n \t\t}\ndiff --git a\/libr\/asm\/arch\/arm\/armass64.c b\/libr\/asm\/arch\/arm\/armass64.c\nindex 91bd4282a7..3c8ea1b72d 100644\n--- a\/libr\/asm\/arch\/arm\/armass64.c\n+++ b\/libr\/asm\/arch\/arm\/armass64.c\n@@ -756,7 +756,7 @@ static bool parseOperands(char* str, ArmOp *op) {\n \t\t} else if (!strncmp (token, \"asr\", 3)) {\n \t\t\top->operands[operand].shift = ARM_ASR;\n \t\t}\n-\t\tif (op->operands[operand].shift != ARM_NO_SHIFT) {\n+\t\tif (strlen(token) > 4 && op->operands[operand].shift != ARM_NO_SHIFT) {\n \t\t\top->operands_count ++;\n \t\t\top->operands[operand].shift_amount = r_num_math (NULL, token + 4);\n \t\t\tif (op->operands[operand].shift_amount > 63) {\n","owner":"devnexen","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2017-18344","CWE_ID":"125","category":"security","commit_id":"cef31d9af908243421258f1df35a4a644604efbe","commit_message":"From cef31d9af908243421258f1df35a4a644604efbe Mon Sep 17 00:00:00 2001\nFrom: Thomas Gleixner <tglx@linutronix.de>\nDate: Fri, 15 Dec 2017 10:32:03 +0100\nSubject: [PATCH] posix-timer: Properly check sigevent->sigev_notify\n\ntimer_create() specifies via sigevent->sigev_notify the signal delivery for\nthe new timer. The valid modes are SIGEV_NONE, SIGEV_SIGNAL, SIGEV_THREAD\nand (SIGEV_SIGNAL | SIGEV_THREAD_ID).\n\nThe sanity check in good_sigevent() is only checking the valid combination\nfor the SIGEV_THREAD_ID bit, i.e. SIGEV_SIGNAL, but if SIGEV_THREAD_ID is\nnot set it accepts any random value.\n\nThis has no real effects on the posix timer and signal delivery code, but\nit affects show_timer() which handles the output of \/proc\/$PID\/timers. That\nfunction uses a string array to pretty print sigev_notify. The access to\nthat array has no bound checks, so random sigev_notify cause access beyond\nthe array bounds.\n\nAdd proper checks for the valid notify modes and remove the SIGEV_THREAD_ID\nmasking from various code pathes as SIGEV_NONE can never be set in\ncombination with SIGEV_THREAD_ID.\n\nReported-by: Eric Biggers <ebiggers3@gmail.com>\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nReported-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: John Stultz <john.stultz@linaro.org>\nCc: stable@vger.kernel.org\n---\n kernel\/time\/posix-timers.c | 29 +++++++++++++++++------------\n 1 file changed, 17 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/time\/posix-timers.c b\/kernel\/time\/posix-timers.c\nindex 13d6881f908b7..ec999f32c8405 100644\n--- a\/kernel\/time\/posix-timers.c\n+++ b\/kernel\/time\/posix-timers.c\n@@ -434,17 +434,22 @@ static struct pid *good_sigevent(sigevent_t * event)\n {\n \tstruct task_struct *rtn = current->group_leader;\n \n-\tif ((event->sigev_notify & SIGEV_THREAD_ID ) &&\n-\t\t(!(rtn = find_task_by_vpid(event->sigev_notify_thread_id)) ||\n-\t\t !same_thread_group(rtn, current) ||\n-\t\t (event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_SIGNAL))\n+\tswitch (event->sigev_notify) {\n+\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n+\t\trtn = find_task_by_vpid(event->sigev_notify_thread_id);\n+\t\tif (!rtn || !same_thread_group(rtn, current))\n+\t\t\treturn NULL;\n+\t\t\/* FALLTHRU *\/\n+\tcase SIGEV_SIGNAL:\n+\tcase SIGEV_THREAD:\n+\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n+\t\t\treturn NULL;\n+\t\t\/* FALLTHRU *\/\n+\tcase SIGEV_NONE:\n+\t\treturn task_pid(rtn);\n+\tdefault:\n \t\treturn NULL;\n-\n-\tif (((event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) &&\n-\t    ((event->sigev_signo <= 0) || (event->sigev_signo > SIGRTMAX)))\n-\t\treturn NULL;\n-\n-\treturn task_pid(rtn);\n+\t}\n }\n \n static struct k_itimer * alloc_posix_timer(void)\n@@ -669,7 +674,7 @@ void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n \tstruct timespec64 ts64;\n \tbool sig_none;\n \n-\tsig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n+\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n \tiv = timr->it_interval;\n \n \t\/* interval timer ? *\/\n@@ -856,7 +861,7 @@ int common_timer_set(struct k_itimer *timr, int flags,\n \n \ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n \texpires = timespec64_to_ktime(new_setting->it_value);\n-\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n+\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n \n \tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n \ttimr->it_active = !sigev_none;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-1838","CWE_ID":"125","category":"security","commit_id":"db07dd613e461df93dde7902c6505629bf0734e9","commit_message":"From db07dd613e461df93dde7902c6505629bf0734e9 Mon Sep 17 00:00:00 2001\nFrom: David Kilzer <ddkilzer@apple.com>\nDate: Fri, 12 Feb 2016 09:58:29 -0800\nSubject: [PATCH] Bug 758588: Heap-based buffer overread in\n xmlParserPrintFileContextInternal\n <https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=758588>\n\n* parser.c:\n(xmlParseEndTag2): Add bounds checks before dereferencing\nctxt->input->cur past the end of the buffer, or incrementing the\npointer past the end of the buffer.\n\n* result\/errors\/758588.xml: Add test result.\n* result\/errors\/758588.xml.err: Ditto.\n* result\/errors\/758588.xml.str: Ditto.\n* test\/errors\/758588.xml: Add regression test.\n---\n parser.c                     |  8 ++++++--\n result\/errors\/758588.xml     |  0\n result\/errors\/758588.xml.err |  9 +++++++++\n result\/errors\/758588.xml.str | 10 ++++++++++\n test\/errors\/758588.xml       |  1 +\n 5 files changed, 26 insertions(+), 2 deletions(-)\n create mode 100644 result\/errors\/758588.xml\n create mode 100644 result\/errors\/758588.xml.err\n create mode 100644 result\/errors\/758588.xml.str\n create mode 100644 test\/errors\/758588.xml\n\n","diff_code":"diff --git a\/parser.c b\/parser.c\nindex 68e1c90f..4464e2e8 100644\n--- a\/parser.c\n+++ b\/parser.c\n@@ -9825,6 +9825,7 @@ static void\n xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,\n                 const xmlChar *URI, int line, int nsNr, int tlen) {\n     const xmlChar *name;\n+    size_t curLength;\n \n     GROW;\n     if ((RAW != '<') || (NXT(1) != '\/')) {\n@@ -9833,8 +9834,11 @@ xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix,\n     }\n     SKIP(2);\n \n-    if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {\n-        if (ctxt->input->cur[tlen] == '>') {\n+    curLength = ctxt->input->end - ctxt->input->cur;\n+    if ((tlen > 0) && (curLength >= (size_t)tlen) &&\n+        (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {\n+        if ((curLength >= (size_t)(tlen + 1)) &&\n+\t    (ctxt->input->cur[tlen] == '>')) {\n \t    ctxt->input->cur += tlen + 1;\n \t    ctxt->input->col += tlen + 1;\n \t    goto done;\ndiff --git a\/result\/errors\/758588.xml b\/result\/errors\/758588.xml\nnew file mode 100644\nindex 00000000..e69de29b\ndiff --git a\/result\/errors\/758588.xml.err b\/result\/errors\/758588.xml.err\nnew file mode 100644\nindex 00000000..dfa59bcf\n--- \/dev\/null\n+++ b\/result\/errors\/758588.xml.err\n@@ -0,0 +1,9 @@\n+.\/test\/errors\/758588.xml:1: namespace error : Namespace prefix a-340282366920938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867261d on a is not defined\n+63472597946867209384634725979468672093846347259794686720938463472597946867261d:a\n+                                                                               ^\n+.\/test\/errors\/758588.xml:1: parser error : expected '>'\n+2597946867209384634725979468672093846347259794686720938463472597946867261d:a><\/a\n+                                                                               ^\n+.\/test\/errors\/758588.xml:1: parser error : Opening and ending tag mismatch: a line 1 and a\n+2597946867209384634725979468672093846347259794686720938463472597946867261d:a><\/a\n+                                                                               ^\ndiff --git a\/result\/errors\/758588.xml.str b\/result\/errors\/758588.xml.str\nnew file mode 100644\nindex 00000000..303ee0ce\n--- \/dev\/null\n+++ b\/result\/errors\/758588.xml.str\n@@ -0,0 +1,10 @@\n+.\/test\/errors\/758588.xml:1: namespace error : Namespace prefix a-340282366920938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867261d on a is not defined\n+63472597946867209384634725979468672093846347259794686720938463472597946867261d:a\n+                                                                               ^\n+.\/test\/errors\/758588.xml:1: parser error : expected '>'\n+2597946867209384634725979468672093846347259794686720938463472597946867261d:a><\/a\n+                                                                               ^\n+.\/test\/errors\/758588.xml:1: parser error : Opening and ending tag mismatch: a line 1 and a\n+2597946867209384634725979468672093846347259794686720938463472597946867261d:a><\/a\n+                                                                               ^\n+.\/test\/errors\/758588.xml : failed to parse\ndiff --git a\/test\/errors\/758588.xml b\/test\/errors\/758588.xml\nnew file mode 100644\nindex 00000000..bec7e932\n--- \/dev\/null\n+++ b\/test\/errors\/758588.xml\n@@ -0,0 +1 @@\n+<a-340282366920938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867209384634725979468672093846347259794686720938463472597946867261d:a><\/a\n\\ No newline at end of file\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-20482","CWE_ID":"125","category":"security","commit_id":"c15c42ccd1e2377945fd0414eca1a49294bff454","commit_message":"From c15c42ccd1e2377945fd0414eca1a49294bff454 Mon Sep 17 00:00:00 2001\nFrom: Sergey Poznyakoff <gray@gnu.org>\nDate: Thu, 27 Dec 2018 17:48:57 +0200\nSubject: Fix CVE-2018-20482\n\n* NEWS: Update.\n* src\/sparse.c (sparse_dump_region): Handle short read condition.\n(sparse_extract_region,check_data_region): Fix dumped_size calculation.\nHandle short read condition.\n(pax_decode_header): Fix dumped_size calculation.\n* tests\/Makefile.am: Add new testcases.\n* tests\/testsuite.at: Likewise.\n\n* tests\/sptrcreat.at: New file.\n* tests\/sptrdiff00.at: New file.\n* tests\/sptrdiff01.at: New file.\n---\n NEWS                |  8 ++++++-\n src\/sparse.c        | 50 ++++++++++++++++++++++++++++++++++++------\n tests\/Makefile.am   |  5 ++++-\n tests\/sptrcreat.at  | 62 +++++++++++++++++++++++++++++++++++++++++++++++++++++\n tests\/sptrdiff00.at | 55 +++++++++++++++++++++++++++++++++++++++++++++++\n tests\/sptrdiff01.at | 55 +++++++++++++++++++++++++++++++++++++++++++++++\n tests\/testsuite.at  |  5 ++++-\n 7 files changed, 231 insertions(+), 9 deletions(-)\n create mode 100644 tests\/sptrcreat.at\n create mode 100644 tests\/sptrdiff00.at\n create mode 100644 tests\/sptrdiff01.at\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 93f3197..9debbeb 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -1,4 +1,4 @@\n-GNU tar NEWS - User visible changes. 2018-12-21\n+GNU tar NEWS - User visible changes. 2018-12-27\n Please send GNU tar bug reports to <bug-tar@gnu.org>\n \n \f\n@@ -25,6 +25,12 @@ semantics of the option.\n Previous versions of tar extracted NAME, those of named members that\n appeared before it, and everything after it.\n \n+* Fix CVE-2018-20482\n+\n+When creating archives with the --sparse option, previous versions of\n+tar would loop endlessly if a sparse file had been truncated while\n+being archived.\n+\n \f\n version 1.30 - Sergey Poznyakoff, 2017-12-17\n \ndiff --git a\/src\/sparse.c b\/src\/sparse.c\nindex d41c0ea..f611200 100644\n--- a\/src\/sparse.c\n+++ b\/src\/sparse.c\n@@ -1,6 +1,6 @@\n \/* Functions for dealing with sparse files\n \n-   Copyright 2003-2007, 2010, 2013-2017 Free Software Foundation, Inc.\n+   Copyright 2003-2007, 2010, 2013-2018 Free Software Foundation, Inc.\n \n    This program is free software; you can redistribute it and\/or modify it\n    under the terms of the GNU General Public License as published by the\n@@ -427,6 +427,30 @@ sparse_dump_region (struct tar_sparse_file *file, size_t i)\n \t\t\t     bufsize);\n \t  return false;\n \t}\n+      else if (bytes_read == 0)\n+\t{\n+\t  char buf[UINTMAX_STRSIZE_BOUND];\n+\t  struct stat st;\n+\t  size_t n;\n+\t  if (fstat (file->fd, &st) == 0)\n+\t    n = file->stat_info->stat.st_size - st.st_size;\n+\t  else\n+\t    n = file->stat_info->stat.st_size\n+\t      - (file->stat_info->sparse_map[i].offset\n+\t\t + file->stat_info->sparse_map[i].numbytes\n+\t\t - bytes_left);\n+\t  \n+\t  WARNOPT (WARN_FILE_SHRANK,\n+\t\t   (0, 0,\n+\t\t    ngettext (\"%s: File shrank by %s byte; padding with zeros\",\n+\t\t\t      \"%s: File shrank by %s bytes; padding with zeros\",\n+\t\t\t      n),\n+\t\t    quotearg_colon (file->stat_info->orig_file_name),\n+\t\t    STRINGIFY_BIGINT (n, buf)));\n+\t  if (! ignore_failed_read_option)\n+\t    set_exit_status (TAREXIT_DIFFERS);\n+\t  return false;\n+\t}\n \n       memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);\n       bytes_left -= bytes_read;\n@@ -464,9 +488,9 @@ sparse_extract_region (struct tar_sparse_file *file, size_t i)\n \t  return false;\n \t}\n       set_next_block_after (blk);\n+      file->dumped_size += BLOCKSIZE;\n       count = blocking_write (file->fd, blk->buffer, wrbytes);\n       write_size -= count;\n-      file->dumped_size += count;\n       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n       file->offset += count;\n       if (count != wrbytes)\n@@ -598,6 +622,12 @@ check_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)\n \t\t\t     rdsize);\n \t  return false;\n \t}\n+      else if (bytes_read == 0)\n+\t{\n+\t  report_difference (file->stat_info, _(\"Size differs\"));\n+\t  return false;\n+\t}\n+      \n       if (!zero_block_p (diff_buffer, bytes_read))\n \t{\n \t  char begbuf[INT_BUFSIZE_BOUND (off_t)];\n@@ -609,6 +639,7 @@ check_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)\n \n       beg += bytes_read;\n     }\n+\n   return true;\n }\n \n@@ -635,6 +666,7 @@ check_data_region (struct tar_sparse_file *file, size_t i)\n \t  return false;\n \t}\n       set_next_block_after (blk);\n+      file->dumped_size += BLOCKSIZE;      \n       bytes_read = safe_read (file->fd, diff_buffer, rdsize);\n       if (bytes_read == SAFE_READ_ERROR)\n \t{\n@@ -645,7 +677,11 @@ check_data_region (struct tar_sparse_file *file, size_t i)\n \t\t\t     rdsize);\n \t  return false;\n \t}\n-      file->dumped_size += bytes_read;\n+      else if (bytes_read == 0)\n+\t{\n+\t  report_difference (&current_stat_info, _(\"Size differs\"));\n+\t  return false;\n+\t}\n       size_left -= bytes_read;\n       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n       if (memcmp (blk->buffer, diff_buffer, rdsize))\n@@ -1213,7 +1249,8 @@ pax_decode_header (struct tar_sparse_file *file)\n       union block *blk;\n       char *p;\n       size_t i;\n-\n+      off_t start;\n+      \n #define COPY_BUF(b,buf,src) do                                     \\\n  {                                                                 \\\n    char *endp = b->buffer + BLOCKSIZE;                             \\\n@@ -1229,7 +1266,6 @@ pax_decode_header (struct tar_sparse_file *file)\n        if (src == endp)                                            \\\n \t {                                                         \\\n \t   set_next_block_after (b);                               \\\n-           file->dumped_size += BLOCKSIZE;                         \\\n            b = find_next_block ();                                 \\\n            src = b->buffer;                                        \\\n \t   endp = b->buffer + BLOCKSIZE;                           \\\n@@ -1240,8 +1276,8 @@ pax_decode_header (struct tar_sparse_file *file)\n    dst[-1] = 0;                                                    \\\n  } while (0)\n \n+      start = current_block_ordinal ();\n       set_next_block_after (current_header);\n-      file->dumped_size += BLOCKSIZE;\n       blk = find_next_block ();\n       p = blk->buffer;\n       COPY_BUF (blk,nbuf,p);\n@@ -1278,6 +1314,8 @@ pax_decode_header (struct tar_sparse_file *file)\n \t  sparse_add_map (file->stat_info, &sp);\n \t}\n       set_next_block_after (blk);\n+\n+      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n     }\n \n   return true;\ndiff --git a\/tests\/Makefile.am b\/tests\/Makefile.am\nindex fb46325..7f9294f 100644\n--- a\/tests\/Makefile.am\n+++ b\/tests\/Makefile.am\n@@ -1,6 +1,6 @@\n # Makefile for GNU tar regression tests.\n \n-# Copyright 1996-1997, 1999-2001, 2003-2007, 2009, 2012-2015 Free Software\n+# Copyright 1996-1997, 1999-2001, 2003-2007, 2009, 2012-2018 Free Software\n \n # This file is part of GNU tar.\n \n@@ -238,6 +238,9 @@ TESTSUITE_AT = \\\n  spmvp00.at\\\n  spmvp01.at\\\n  spmvp10.at\\\n+ sptrcreat.at\\\n+ sptrdiff00.at\\\n+ sptrdiff01.at\\\n  time01.at\\\n  time02.at\\\n  truncate.at\\\ndiff --git a\/tests\/sptrcreat.at b\/tests\/sptrcreat.at\nnew file mode 100644\nindex 0000000..8e28f0e\n--- \/dev\/null\n+++ b\/tests\/sptrcreat.at\n@@ -0,0 +1,62 @@\n+# Process this file with autom4te to create testsuite. -*- Autotest -*-\n+\n+# Test suite for GNU tar.\n+# Copyright 2018 Free Software Foundation, Inc.\n+\n+# This file is part of GNU tar.\n+\n+# GNU tar is free software; you can redistribute it and\/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+\n+# GNU tar is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n+\n+# Tar up to 1.30 would loop endlessly if a sparse file had been truncated\n+# while being archived (with --sparse flag).\n+#\n+# The bug has been assigned id CVE-2018-20482 (on the grounds that it is a\n+# denial of service possibility).\n+# \n+# Reported by: Chris Siebenmann <cks.gnutar-01@cs.toronto.edu>\n+# References: <20181226223948.781EB32008E@apps1.cs.toronto.edu>,\n+#   <http:\/\/lists.gnu.org\/archive\/html\/bug-tar\/2018-12\/msg00023.html>\n+#   <https:\/\/utcc.utoronto.ca\/~cks\/space\/blog\/sysadmin\/TarFindingTruncateBug>\n+#   <https:\/\/nvd.nist.gov\/vuln\/detail\/CVE-2018-20482>\n+\n+AT_SETUP([sparse file truncated while archiving])\n+AT_KEYWORDS([truncate filechange sparse sptr sptrcreat])\n+\n+AT_TAR_CHECK([\n+genfile --sparse --block-size=1024 --file foo \\\n+  0 ABCDEFGHIJ 1M ABCDEFGHIJ 10M ABCDEFGHIJ 200M ABCDEFGHIJ\n+genfile --file baz\n+genfile --run --checkpoint 3 --length 200m --truncate foo -- \\\n+ tar --checkpoint=1 \\\n+     --checkpoint-action=echo \\\n+     --checkpoint-action=sleep=1 \\\n+     --sparse -vcf bar foo baz\n+echo Exit status: $?\n+echo separator\n+genfile --file foo --seek 200m --length 11575296 --pattern=zeros\n+tar dvf bar],\n+[1],\n+[foo\n+baz\n+Exit status: 1\n+separator\n+foo\n+foo: Mod time differs\n+baz\n+],\n+[tar: foo: File shrank by 11575296 bytes; padding with zeros\n+],\n+[],[],[posix, gnu, oldgnu])\n+\n+AT_CLEANUP\ndiff --git a\/tests\/sptrdiff00.at b\/tests\/sptrdiff00.at\nnew file mode 100644\nindex 0000000..c410561\n--- \/dev\/null\n+++ b\/tests\/sptrdiff00.at\n@@ -0,0 +1,55 @@\n+# Process this file with autom4te to create testsuite. -*- Autotest -*-\n+#\n+# Test suite for GNU tar.\n+# Copyright 2018 Free Software Foundation, Inc.\n+#\n+# This file is part of GNU tar.\n+#\n+# GNU tar is free software; you can redistribute it and\/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# GNU tar is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n+\n+# While fixing CVE-2018-20482 (see sptrcreat.at) it has been discovered\n+# that similar bug exists in file checking code (tar d). \n+# This test case checks if tar correctly handles a short read condition\n+# appearing in check_sparse_region.\n+\n+AT_SETUP([file truncated in sparse region while comparing])\n+AT_KEYWORDS([truncate filechange sparse sptr sptrdiff diff])\n+\n+# This triggers short read in check_sparse_region.\n+AT_TAR_CHECK([\n+genfile --sparse --block-size=1024 --file foo \\\n+  0 ABCDEFGHIJ 1M ABCDEFGHIJ 10M ABCDEFGHIJ 200M ABCDEFGHIJ\n+genfile --file baz\n+echo creating\n+tar --sparse -vcf bar foo baz\n+echo comparing\n+genfile --run --checkpoint 3 --length 200m --truncate foo -- \\\n+ tar --checkpoint=1 \\\n+     --checkpoint-action=echo='Write checkpoint %u' \\\n+     --checkpoint-action=sleep=1 \\\n+     --sparse -vdf bar \n+],\n+[1],\n+[creating\n+foo\n+baz\n+comparing\n+foo\n+foo: Size differs\n+baz\n+],\n+[],\n+[],[],[posix, gnu, oldgnu])\n+\n+AT_CLEANUP\ndiff --git a\/tests\/sptrdiff01.at b\/tests\/sptrdiff01.at\nnew file mode 100644\nindex 0000000..2da2267\n--- \/dev\/null\n+++ b\/tests\/sptrdiff01.at\n@@ -0,0 +1,55 @@\n+# Process this file with autom4te to create testsuite. -*- Autotest -*-\n+#\n+# Test suite for GNU tar.\n+# Copyright 2018 Free Software Foundation, Inc.\n+#\n+# This file is part of GNU tar.\n+#\n+# GNU tar is free software; you can redistribute it and\/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# GNU tar is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n+\n+# While fixing CVE-2018-20482 (see sptrcreat.at) it has been discovered\n+# that similar bug exists in file checking code (tar d). \n+# This test case checks if tar correctly handles a short read condition\n+# appearing in check_data_region.\n+\n+AT_SETUP([file truncated in data region while comparing])\n+AT_KEYWORDS([truncate filechange sparse sptr sptrdiff diff])\n+\n+# This triggers short read in check_data_region.\n+AT_TAR_CHECK([\n+genfile --sparse --block-size=1024 --file foo \\\n+  0 ABCDEFGHIJ 1M ABCDEFGHIJ 10M ABCDEFGHIJ 200M ABCDEFGHIJ\n+genfile --file baz\n+echo creating\n+tar --sparse -vcf bar foo baz\n+echo comparing\n+genfile --run --checkpoint 5 --length 221278210 --truncate foo -- \\\n+ tar --checkpoint=1 \\\n+     --checkpoint-action=echo='Write checkpoint %u' \\\n+     --checkpoint-action=sleep=1 \\\n+     --sparse -vdf bar \n+],\n+[1],\n+[creating\n+foo\n+baz\n+comparing\n+foo\n+foo: Size differs\n+baz\n+],\n+[],\n+[],[],[posix, gnu, oldgnu])\n+\n+AT_CLEANUP\ndiff --git a\/tests\/testsuite.at b\/tests\/testsuite.at\nindex dcccc7b..0f5cca3 100644\n--- a\/tests\/testsuite.at\n+++ b\/tests\/testsuite.at\n@@ -1,7 +1,7 @@\n # Process this file with autom4te to create testsuite. -*- Autotest -*-\n \n # Test suite for GNU tar.\n-# Copyright 2004-2008, 2010-2017 Free Software Foundation, Inc.\n+# Copyright 2004-2008, 2010-2018 Free Software Foundation, Inc.\n \n # This file is part of GNU tar.\n \n@@ -416,6 +416,9 @@ m4_include([sparsemv.at])\n m4_include([spmvp00.at])\n m4_include([spmvp01.at])\n m4_include([spmvp10.at])\n+m4_include([sptrcreat.at])\n+m4_include([sptrdiff00.at])\n+m4_include([sptrdiff01.at])\n \n AT_BANNER([Updates])\n m4_include([update.at])\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7515","CWE_ID":"125","category":"security","commit_id":"2ad6d33493750a28a5a655d319a8e0b16c392de1","commit_message":"From 2ad6d33493750a28a5a655d319a8e0b16c392de1 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Mon, 5 Oct 2015 22:11:31 +0200\nSubject: [PATCH] Fixed check for the number of pixels that will be allocated.\n\n---\n coders\/rle.c | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/coders\/rle.c b\/coders\/rle.c\nindex a5c27ffaf7..9809fa7f29 100644\n--- a\/coders\/rle.c\n+++ b\/coders\/rle.c\n@@ -173,6 +173,7 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     map_length,\n     number_colormaps,\n     number_planes,\n+    number_planes_filled,\n     one,\n     offset,\n     pixel_info_length;\n@@ -308,9 +309,12 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     if (image->alpha_trait != UndefinedPixelTrait)\n       number_planes++;\n     number_pixels=(MagickSizeType) image->columns*image->rows;\n-    if ((number_pixels*number_planes) != (size_t) (number_pixels*number_planes))\n+    number_planes_filled=(number_planes % 2 == 0) ? number_planes :\n+      number_planes+1;\n+    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*\n+         number_planes_filled))\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n-    pixel_info_length=image->columns*image->rows*MagickMax(number_planes,4);\n+    pixel_info_length=image->columns*image->rows*number_planes_filled;\n     pixel_info=AcquireVirtualMemory(pixel_info_length,sizeof(*pixels));\n     if (pixel_info == (MemoryInfo *) NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-7101","CWE_ID":"125","category":"security","commit_id":"7afcf9f71043df15508e46f079387bd4689a738d","commit_message":"From 7afcf9f71043df15508e46f079387bd4689a738d Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 18 Aug 2016 18:23:44 -0400\nSubject: [PATCH] Prevent buffer overflow in BMP & SGI coders (bug report from\n pwchen&rayzhong of tencent)\n\n---\n ChangeLog    | 2 +-\n coders\/sgi.c | 6 ++++--\n 2 files changed, 5 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 3a9c38e2b2..ff89b2021c 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,5 @@\n 2016-08-15  7.0.2-10 Cristy  <quetzlzacatenango@image...>\n-  * Prevent buffer overflow in BMP coder (bug report from\n+  * Prevent buffer overflow in BMP & SGI coders (bug report from\n     pwchen&rayzhong of tencent).\n \n 2016-08-14  7.0.2-9 Cristy  <quetzlzacatenango@image...>\ndiff --git a\/coders\/sgi.c b\/coders\/sgi.c\nindex cd8c2b69e1..1fe65e604f 100644\n--- a\/coders\/sgi.c\n+++ b\/coders\/sgi.c\n@@ -354,13 +354,15 @@ static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     image->rows=iris_info.rows;\n     image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n     if (iris_info.pixel_format == 0)\n-      image->depth=(size_t) MagickMin((size_t) 8*\n-        iris_info.bytes_per_pixel,MAGICKCORE_QUANTUM_DEPTH);\n+      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,\n+        MAGICKCORE_QUANTUM_DEPTH);\n     if (iris_info.depth < 3)\n       {\n         image->storage_class=PseudoClass;\n         image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;\n       }\n+    if (EOFBlob(image) != MagickFalse)\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     if ((image_info->ping != MagickFalse)  && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-10528","CWE_ID":"125","category":"security","commit_id":"895529fc2f2eb8bc633edd6b04b5b237eb4db564","commit_message":"From 895529fc2f2eb8bc633edd6b04b5b237eb4db564 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Fri, 27 Apr 2018 12:35:55 +0300\nSubject: [PATCH] X3F parser possible buffer overrun\n\n---\n src\/libraw_cxx.cpp | 11 ++++++-----\n 1 file changed, 6 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/libraw_cxx.cpp b\/src\/libraw_cxx.cpp\nindex a8a24de6..a111b9fe 100644\n--- a\/src\/libraw_cxx.cpp\n+++ b\/src\/libraw_cxx.cpp\n@@ -6080,18 +6080,19 @@ const char *LibRaw::strprogress(enum LibRaw_progress p)\n \n void x3f_clear(void *p) { x3f_delete((x3f_t *)p); }\n \n-static char *utf2char(utf16_t *str, char *buffer)\n+void utf2char(utf16_t *str, char *buffer, unsigned bufsz)\n {\n+ if(bufsz<1) return;\n+ buffer[bufsz-1] = 0;\n   char *b = buffer;\n \n-  while (*str != 0x00)\n+  while (*str != 0x00 && --bufsz>0)\n   {\n     char *chr = (char *)str;\n     *b++ = *chr;\n     str++;\n   }\n   *b = 0;\n-  return buffer;\n }\n \n static void *lr_memmem(const void *l, size_t l_len, const void *s, size_t s_len)\n@@ -6155,8 +6156,8 @@ void LibRaw::parse_x3f()\n       for (i = 0; i < PL->num_properties; i++)\n       {\n         char name[100], value[100];\n-        utf2char(P[i].name, name);\n-        utf2char(P[i].value, value);\n+        utf2char(P[i].name, name,sizeof(name));\n+        utf2char(P[i].value, value,sizeof(value));\n         if (!strcmp(name, \"ISO\"))\n           imgdata.other.iso_speed = atoi(value);\n         if (!strcmp(name, \"CAMMANUF\"))\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2018-19842","CWE_ID":"125","category":"security","commit_id":"66191f780863ea8c66ace4040d0d04a8842e8432","commit_message":"From 66191f780863ea8c66ace4040d0d04a8842e8432 Mon Sep 17 00:00:00 2001\nFrom: radare <pancake@nopcode.org>\nDate: Wed, 21 Nov 2018 17:50:58 +0100\nSubject: [PATCH] Fix #12239 - crash in the x86.nz assembler ##asm (#12252)\n\n---\n libr\/asm\/p\/asm_x86_nz.c | 13 +++++++++----\n 1 file changed, 9 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libr\/asm\/p\/asm_x86_nz.c b\/libr\/asm\/p\/asm_x86_nz.c\nindex 4a23062ee6..42e079932c 100644\n--- a\/libr\/asm\/p\/asm_x86_nz.c\n+++ b\/libr\/asm\/p\/asm_x86_nz.c\n@@ -4295,21 +4295,26 @@ LookupTable oplookup[] = {\n };\n \n static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n+\tif (*begin > strlen (str)) {\n+\t\treturn TT_EOF;\n+\t}\n \t\/\/ Skip whitespace\n-\twhile (begin && isspace ((ut8)str[*begin])) {\n+\twhile (begin && str[*begin] && isspace ((ut8)str[*begin])) {\n \t\t++(*begin);\n \t}\n \n \tif (!str[*begin]) {                \/\/ null byte\n \t\t*end = *begin;\n \t\treturn TT_EOF;\n-\t} else if (isalpha ((ut8)str[*begin])) {   \/\/ word token\n+\t}\n+\tif (isalpha ((ut8)str[*begin])) {   \/\/ word token\n \t\t*end = *begin;\n-\t\twhile (end && isalnum ((ut8)str[*end])) {\n+\t\twhile (end && str[*end] && isalnum ((ut8)str[*end])) {\n \t\t\t++(*end);\n \t\t}\n \t\treturn TT_WORD;\n-\t} else if (isdigit ((ut8)str[*begin])) {   \/\/ number token\n+\t}\n+\tif (isdigit ((ut8)str[*begin])) {   \/\/ number token\n \t\t*end = *begin;\n \t\twhile (end && isalnum ((ut8)str[*end])) {     \/\/ accept alphanumeric characters, because hex.\n \t\t\t++(*end);\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2017-16358","CWE_ID":"125","category":"security","commit_id":"d31c4d3cbdbe01ea3ded16a584de94149ecd31d9","commit_message":"From d31c4d3cbdbe01ea3ded16a584de94149ecd31d9 Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Tue, 31 Oct 2017 13:08:52 +0100\nSubject: [PATCH] Fix #8748 - Fix oobread on string search\n\n---\n libr\/bin\/bin.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libr\/bin\/bin.c b\/libr\/bin\/bin.c\nindex fbb8a8025b..b5fffe88bc 100644\n--- a\/libr\/bin\/bin.c\n+++ b\/libr\/bin\/bin.c\n@@ -352,16 +352,16 @@ static int string_scan_range(RList *list, const ut8 *buf, int min,\n \t\t\t\t\/\/ TODO: move into adjust_offset\n \t\t\t\tswitch (str_type) {\n \t\t\t\tcase R_STRING_TYPE_WIDE:\n-\t\t\t\t\t{\n-\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 2;\n+\t\t\t\t\tif (str_start > 1) {\n+\t\t\t\t\t\tconst ut8 *p = buf + str_start - 2;\n \t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n \t\t\t\t\t\t\tstr_start -= 2; \/\/ \\xff\\xfe\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tbreak;\n \t\t\t\tcase R_STRING_TYPE_WIDE32:\n-\t\t\t\t\t{\n-\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 4;\n+\t\t\t\t\tif (str_start > 3) {\n+\t\t\t\t\t\tconst ut8 *p = buf + str_start - 4;\n \t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n \t\t\t\t\t\t\tstr_start -= 4; \/\/ \\xff\\xfe\\x00\\x00\n \t\t\t\t\t\t}\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2019-13295","CWE_ID":"125","category":"security","commit_id":"a7759f410b773a1dd57b0e1fb28112e1cd8b97bc","commit_message":"From a7759f410b773a1dd57b0e1fb28112e1cd8b97bc Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 21 Jun 2019 16:51:38 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1608\n\n---\n MagickCore\/threshold.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/MagickCore\/threshold.c b\/MagickCore\/threshold.c\nindex a3bb96a214..f9412bb52e 100644\n--- a\/MagickCore\/threshold.c\n+++ b\/MagickCore\/threshold.c\n@@ -212,6 +212,8 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,\n   threshold_image=CloneImage(image,0,0,MagickTrue,exception);\n   if (threshold_image == (Image *) NULL)\n     return((Image *) NULL);\n+  if (width == 0)\n+    return(threshold_image);\n   status=SetImageStorageClass(threshold_image,DirectClass,exception);\n   if (status == MagickFalse)\n     {\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-6347","CWE_ID":"125","category":"security","commit_id":"ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32","commit_message":"From ca4ef4574f1ee5252e2cd365f8f5d5bafd048f32 Mon Sep 17 00:00:00 2001\nFrom: Paolo Abeni <pabeni@redhat.com>\nDate: Tue, 21 Feb 2017 09:33:18 +0100\nSubject: [PATCH] ip: fix IP_CHECKSUM handling\n\nThe skbs processed by ip_cmsg_recv() are not guaranteed to\nbe linear e.g. when sending UDP packets over loopback with\nMSGMORE.\nUsing csum_partial() on [potentially] the whole skb len\nis dangerous; instead be on the safe side and use skb_checksum().\n\nThanks to syzkaller team to detect the issue and provide the\nreproducer.\n\nv1 -> v2:\n - move the variable declaration in a tighter scope\n\nFixes: ad6f939ab193 (\"ip: Add offset parameter to ip_cmsg_recv\")\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/ip_sockglue.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/ip_sockglue.c b\/net\/ipv4\/ip_sockglue.c\nindex ce1386a67e243..ebd953bc5607f 100644\n--- a\/net\/ipv4\/ip_sockglue.c\n+++ b\/net\/ipv4\/ip_sockglue.c\n@@ -116,10 +116,10 @@ static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n \tif (skb->ip_summed != CHECKSUM_COMPLETE)\n \t\treturn;\n \n-\tif (offset != 0)\n-\t\tcsum = csum_sub(csum,\n-\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n-\t\t\t\t\t     offset, 0));\n+\tif (offset != 0) {\n+\t\tint tend_off = skb_transport_offset(skb) + tlen;\n+\t\tcsum = csum_sub(csum, skb_checksum(skb, tend_off, offset, 0));\n+\t}\n \n \tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7520","CWE_ID":"125","category":"security","commit_id":"14e606db148d6ebcaae20f1e1d6d71903ca4a556","commit_message":"From 14e606db148d6ebcaae20f1e1d6d71903ca4a556 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 22 Jan 2016 19:39:55 -0500\nSubject: [PATCH] \n https:\/\/bugs.launchpad.net\/ubuntu\/+source\/imagemagick\/+bug\/1537213\n\n---\n coders\/hdr.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/coders\/hdr.c b\/coders\/hdr.c\nindex b15c415be3..bdb343b119 100644\n--- a\/coders\/hdr.c\n+++ b\/coders\/hdr.c\n@@ -723,7 +723,8 @@ static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,\n     }\n   if (image->gamma != 0.0)\n     {\n-      count=FormatLocaleString(header,MagickPathExtent,\"GAMMA=%g\\n\",image->gamma);\n+      count=FormatLocaleString(header,MagickPathExtent,\"GAMMA=%g\\n\",\n+        image->gamma);\n       (void) WriteBlob(image,(size_t) count,(unsigned char *) header);\n     }\n   count=FormatLocaleString(header,MagickPathExtent,\n@@ -741,10 +742,11 @@ static MagickBooleanType WriteHDRImage(const ImageInfo *image_info,Image *image,\n   \/*\n     Write HDR pixels.\n   *\/\n-  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n+  pixels=(unsigned char *) AcquireQuantumMemory(image->columns+128,4*\n     sizeof(*pixels));\n   if (pixels == (unsigned char *) NULL)\n     ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+  (void) ResetMagickMemory(pixels,0,4*(image->columns+128)*sizeof(*pixels));\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n     p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-16912","CWE_ID":"125","category":"security","commit_id":"635f545a7e8be7596b9b2b6a43cab6bbd5a88e43","commit_message":"From 635f545a7e8be7596b9b2b6a43cab6bbd5a88e43 Mon Sep 17 00:00:00 2001\nFrom: Shuah Khan <shuahkh@osg.samsung.com>\nDate: Thu, 7 Dec 2017 14:16:47 -0700\nSubject: usbip: fix stub_rx: get_pipe() to validate endpoint number\n\nget_pipe() routine doesn't validate the input endpoint number\nand uses to reference ep_in and ep_out arrays. Invalid endpoint\nnumber can trigger BUG(). Range check the epnum and returning\nerror instead of calling BUG().\n\nChange caller stub_recv_cmd_submit() to handle the get_pipe()\nerror return.\n\nReported-by: Secunia Research <vuln@secunia.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Shuah Khan <shuahkh@osg.samsung.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/usb\/usbip\/stub_rx.c | 18 +++++++++++-------\n 1 file changed, 11 insertions(+), 7 deletions(-)\n\n(limited to 'drivers\/usb\/usbip')\n\n","diff_code":"diff --git a\/drivers\/usb\/usbip\/stub_rx.c b\/drivers\/usb\/usbip\/stub_rx.c\nindex 536e037f541f..4d61063c259d 100644\n--- a\/drivers\/usb\/usbip\/stub_rx.c\n+++ b\/drivers\/usb\/usbip\/stub_rx.c\n@@ -328,15 +328,15 @@ static int get_pipe(struct stub_device *sdev, int epnum, int dir)\n \tstruct usb_host_endpoint *ep;\n \tstruct usb_endpoint_descriptor *epd = NULL;\n \n+\tif (epnum < 0 || epnum > 15)\n+\t\tgoto err_ret;\n+\n \tif (dir == USBIP_DIR_IN)\n \t\tep = udev->ep_in[epnum & 0x7f];\n \telse\n \t\tep = udev->ep_out[epnum & 0x7f];\n-\tif (!ep) {\n-\t\tdev_err(&sdev->udev->dev, \"no such endpoint?, %d\\n\",\n-\t\t\tepnum);\n-\t\tBUG();\n-\t}\n+\tif (!ep)\n+\t\tgoto err_ret;\n \n \tepd = &ep->desc;\n \tif (usb_endpoint_xfer_control(epd)) {\n@@ -367,9 +367,10 @@ static int get_pipe(struct stub_device *sdev, int epnum, int dir)\n \t\t\treturn usb_rcvisocpipe(udev, epnum);\n \t}\n \n+err_ret:\n \t\/* NOT REACHED *\/\n-\tdev_err(&sdev->udev->dev, \"get pipe, epnum %d\\n\", epnum);\n-\treturn 0;\n+\tdev_err(&sdev->udev->dev, \"get pipe() invalid epnum %d\\n\", epnum);\n+\treturn -1;\n }\n \n static void masking_bogus_flags(struct urb *urb)\n@@ -435,6 +436,9 @@ static void stub_recv_cmd_submit(struct stub_device *sdev,\n \tstruct usb_device *udev = sdev->udev;\n \tint pipe = get_pipe(sdev, pdu->base.ep, pdu->base.direction);\n \n+\tif (pipe == -1)\n+\t\treturn;\n+\n \tpriv = stub_priv_alloc(sdev, pdu);\n \tif (!priv)\n \t\treturn;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8948","CWE_ID":"125","category":"security","commit_id":"570e68886c41c2e765e6218cb317d9a9a447a041","commit_message":"From 570e68886c41c2e765e6218cb317d9a9a447a041 Mon Sep 17 00:00:00 2001\nFrom: Simon Josefsson <simon@josefsson.org>\nDate: Mon, 10 Aug 2015 10:23:30 +0200\nSubject: idn: Use getline instead of fgets with fixed-size buffer.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nFixes out-of-bounds read, reported by Hanno B\u00f6ck.\n---\n .gitignore              |   1 +\n gl\/Makefile.am          | 196 +++++++++-\n gl\/getdelim.c           | 135 +++++++\n gl\/getline.c            |  27 ++\n gl\/m4\/getdelim.m4       |  88 +++++\n gl\/m4\/getline.m4        |  96 +++++\n gl\/m4\/gnulib-cache.m4   |   3 +-\n gl\/m4\/gnulib-comp.m4    |  40 +-\n gl\/m4\/realloc.m4        |  76 ++++\n gl\/realloc.c            |  79 ++++\n gl\/stdint.in.h          | 635 +++++++++++++++++++++++++++++++\n gl\/stdlib.in.h          | 977 ++++++++++++++++++++++++++++++++++++++++++++++++\n gltests\/Makefile.am     | 173 +--------\n gltests\/stdint.in.h     | 635 -------------------------------\n gltests\/stdlib.in.h     | 977 ------------------------------------------------\n gltests\/test-getdelim.c |  94 +++++\n gltests\/test-getline.c  |  94 +++++\n src\/idn.c               |  35 +-\n 18 files changed, 2570 insertions(+), 1791 deletions(-)\n create mode 100644 gl\/getdelim.c\n create mode 100644 gl\/getline.c\n create mode 100644 gl\/m4\/getdelim.m4\n create mode 100644 gl\/m4\/getline.m4\n create mode 100644 gl\/m4\/realloc.m4\n create mode 100644 gl\/realloc.c\n create mode 100644 gl\/stdint.in.h\n create mode 100644 gl\/stdlib.in.h\n delete mode 100644 gltests\/stdint.in.h\n delete mode 100644 gltests\/stdlib.in.h\n create mode 100644 gltests\/test-getdelim.c\n create mode 100644 gltests\/test-getline.c\n\n","diff_code":"diff --git a\/.gitignore b\/.gitignore\nindex a9bc58b..e206a3c 100644\n--- a\/.gitignore\n+++ b\/.gitignore\n@@ -173,6 +173,7 @@ gl\/progname.lo\n gl\/progname.o\n gl\/stddef.h\n gl\/stdio.h\n+gl\/stdlib.h\n gl\/string.h\n gl\/sys\/\n gl\/unistd.h\ndiff --git a\/gl\/Makefile.am b\/gl\/Makefile.am\nindex 2b4c4ed..03397b4 100644\n--- a\/gl\/Makefile.am\n+++ b\/gl\/Makefile.am\n@@ -21,7 +21,7 @@\n # the same distribution terms as the rest of that program.\n #\n # Generated by gnulib-tool.\n-# Reproduce by: gnulib-tool --import --dir=. --local-dir=gl\/override --lib=libgnu --source-base=gl --m4-base=gl\/m4 --doc-base=doc --tests-base=gltests --aux-dir=build-aux --with-tests --avoid=fcntl-h-tests --avoid=stdlib-tests --avoid=string-tests --avoid=sys_stat-tests --avoid=time-tests --avoid=unistd-tests --avoid=update-copyright-tests --avoid=wchar-tests --no-conditional-dependencies --libtool --macro-prefix=gl --no-vc-files autobuild csharpcomp-script csharpexec-script error fdl-1.3 gendocs getopt-gnu gnupload maintainer-makefile manywarnings pmccabe2html progname update-copyright useless-if-before-free valgrind-tests vc-list-files version-etc warnings\n+# Reproduce by: gnulib-tool --import --dir=. --local-dir=gl\/override --lib=libgnu --source-base=gl --m4-base=gl\/m4 --doc-base=doc --tests-base=gltests --aux-dir=build-aux --with-tests --avoid=fcntl-h-tests --avoid=stdlib-tests --avoid=string-tests --avoid=sys_stat-tests --avoid=time-tests --avoid=unistd-tests --avoid=update-copyright-tests --avoid=wchar-tests --no-conditional-dependencies --libtool --macro-prefix=gl --no-vc-files autobuild csharpcomp-script csharpexec-script error fdl-1.3 gendocs getline getopt-gnu gnupload maintainer-makefile manywarnings pmccabe2html progname update-copyright useless-if-before-free valgrind-tests vc-list-files version-etc warnings\n \n AUTOMAKE_OPTIONS = 1.9.6 gnits\n \n@@ -125,6 +125,24 @@ EXTRA_DIST += $(top_srcdir)\/build-aux\/gendocs.sh\n \n ## end   gnulib module gendocs\n \n+## begin gnulib module getdelim\n+\n+\n+EXTRA_DIST += getdelim.c\n+\n+EXTRA_libgnu_la_SOURCES += getdelim.c\n+\n+## end   gnulib module getdelim\n+\n+## begin gnulib module getline\n+\n+\n+EXTRA_DIST += getline.c\n+\n+EXTRA_libgnu_la_SOURCES += getline.c\n+\n+## end   gnulib module getline\n+\n ## begin gnulib module getopt-posix\n \n BUILT_SOURCES += $(GETOPT_H)\n@@ -219,6 +237,27 @@ libgnu_la_SOURCES += progname.h progname.c\n \n ## end   gnulib module progname\n \n+## begin gnulib module realloc-posix\n+\n+\n+EXTRA_DIST += realloc.c\n+\n+EXTRA_libgnu_la_SOURCES += realloc.c\n+\n+## end   gnulib module realloc-posix\n+\n+## begin gnulib module snippet\/_Noreturn\n+\n+# Because this Makefile snippet defines a variable used by other\n+# gnulib Makefile snippets, it must be present in all Makefile.am that\n+# need it. This is ensured by the applicability 'all' defined above.\n+\n+_NORETURN_H=$(top_srcdir)\/build-aux\/snippet\/_Noreturn.h\n+\n+EXTRA_DIST += $(top_srcdir)\/build-aux\/snippet\/_Noreturn.h\n+\n+## end   gnulib module snippet\/_Noreturn\n+\n ## begin gnulib module snippet\/arg-nonnull\n \n # The BUILT_SOURCES created by this Makefile snippet are not used via #include\n@@ -347,6 +386,56 @@ EXTRA_DIST += stddef.in.h\n \n ## end   gnulib module stddef\n \n+## begin gnulib module stdint\n+\n+BUILT_SOURCES += $(STDINT_H)\n+\n+# We need the following in order to create <stdint.h> when the system\n+# doesn't have one that works with the given compiler.\n+if GL_GENERATE_STDINT_H\n+stdint.h: stdint.in.h $(top_builddir)\/config.status\n+\t$(AM_V_GEN)rm -f $@-t $@ && \\\n+\t{ echo '\/* DO NOT EDIT! GENERATED AUTOMATICALLY! *\/'; \\\n+\t  sed -e 's|@''GUARD_PREFIX''@|GL|g' \\\n+\t      -e 's\/@''HAVE_STDINT_H''@\/$(HAVE_STDINT_H)\/g' \\\n+\t      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \\\n+\t      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \\\n+\t      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \\\n+\t      -e 's|@''NEXT_STDINT_H''@|$(NEXT_STDINT_H)|g' \\\n+\t      -e 's\/@''HAVE_SYS_TYPES_H''@\/$(HAVE_SYS_TYPES_H)\/g' \\\n+\t      -e 's\/@''HAVE_INTTYPES_H''@\/$(HAVE_INTTYPES_H)\/g' \\\n+\t      -e 's\/@''HAVE_SYS_INTTYPES_H''@\/$(HAVE_SYS_INTTYPES_H)\/g' \\\n+\t      -e 's\/@''HAVE_SYS_BITYPES_H''@\/$(HAVE_SYS_BITYPES_H)\/g' \\\n+\t      -e 's\/@''HAVE_WCHAR_H''@\/$(HAVE_WCHAR_H)\/g' \\\n+\t      -e 's\/@''HAVE_LONG_LONG_INT''@\/$(HAVE_LONG_LONG_INT)\/g' \\\n+\t      -e 's\/@''HAVE_UNSIGNED_LONG_LONG_INT''@\/$(HAVE_UNSIGNED_LONG_LONG_INT)\/g' \\\n+\t      -e 's\/@''APPLE_UNIVERSAL_BUILD''@\/$(APPLE_UNIVERSAL_BUILD)\/g' \\\n+\t      -e 's\/@''BITSIZEOF_PTRDIFF_T''@\/$(BITSIZEOF_PTRDIFF_T)\/g' \\\n+\t      -e 's\/@''PTRDIFF_T_SUFFIX''@\/$(PTRDIFF_T_SUFFIX)\/g' \\\n+\t      -e 's\/@''BITSIZEOF_SIG_ATOMIC_T''@\/$(BITSIZEOF_SIG_ATOMIC_T)\/g' \\\n+\t      -e 's\/@''HAVE_SIGNED_SIG_ATOMIC_T''@\/$(HAVE_SIGNED_SIG_ATOMIC_T)\/g' \\\n+\t      -e 's\/@''SIG_ATOMIC_T_SUFFIX''@\/$(SIG_ATOMIC_T_SUFFIX)\/g' \\\n+\t      -e 's\/@''BITSIZEOF_SIZE_T''@\/$(BITSIZEOF_SIZE_T)\/g' \\\n+\t      -e 's\/@''SIZE_T_SUFFIX''@\/$(SIZE_T_SUFFIX)\/g' \\\n+\t      -e 's\/@''BITSIZEOF_WCHAR_T''@\/$(BITSIZEOF_WCHAR_T)\/g' \\\n+\t      -e 's\/@''HAVE_SIGNED_WCHAR_T''@\/$(HAVE_SIGNED_WCHAR_T)\/g' \\\n+\t      -e 's\/@''WCHAR_T_SUFFIX''@\/$(WCHAR_T_SUFFIX)\/g' \\\n+\t      -e 's\/@''BITSIZEOF_WINT_T''@\/$(BITSIZEOF_WINT_T)\/g' \\\n+\t      -e 's\/@''HAVE_SIGNED_WINT_T''@\/$(HAVE_SIGNED_WINT_T)\/g' \\\n+\t      -e 's\/@''WINT_T_SUFFIX''@\/$(WINT_T_SUFFIX)\/g' \\\n+\t      < $(srcdir)\/stdint.in.h; \\\n+\t} > $@-t && \\\n+\tmv $@-t $@\n+else\n+stdint.h: $(top_builddir)\/config.status\n+\trm -f $@\n+endif\n+MOSTLYCLEANFILES += stdint.h stdint.h-t\n+\n+EXTRA_DIST += stdint.in.h\n+\n+## end   gnulib module stdint\n+\n ## begin gnulib module stdio\n \n BUILT_SOURCES += stdio.h\n@@ -475,6 +564,111 @@ EXTRA_DIST += stdio.in.h\n \n ## end   gnulib module stdio\n \n+## begin gnulib module stdlib\n+\n+BUILT_SOURCES += stdlib.h\n+\n+# We need the following in order to create <stdlib.h> when the system\n+# doesn't have one that works with the given compiler.\n+stdlib.h: stdlib.in.h $(top_builddir)\/config.status $(CXXDEFS_H) \\\n+  $(_NORETURN_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)\n+\t$(AM_V_GEN)rm -f $@-t $@ && \\\n+\t{ echo '\/* DO NOT EDIT! GENERATED AUTOMATICALLY! *\/' && \\\n+\t  sed -e 's|@''GUARD_PREFIX''@|GL|g' \\\n+\t      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \\\n+\t      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \\\n+\t      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \\\n+\t      -e 's|@''NEXT_STDLIB_H''@|$(NEXT_STDLIB_H)|g' \\\n+\t      -e 's\/@''GNULIB__EXIT''@\/$(GNULIB__EXIT)\/g' \\\n+\t      -e 's\/@''GNULIB_ATOLL''@\/$(GNULIB_ATOLL)\/g' \\\n+\t      -e 's\/@''GNULIB_CALLOC_POSIX''@\/$(GNULIB_CALLOC_POSIX)\/g' \\\n+\t      -e 's\/@''GNULIB_CANONICALIZE_FILE_NAME''@\/$(GNULIB_CANONICALIZE_FILE_NAME)\/g' \\\n+\t      -e 's\/@''GNULIB_GETLOADAVG''@\/$(GNULIB_GETLOADAVG)\/g' \\\n+\t      -e 's\/@''GNULIB_GETSUBOPT''@\/$(GNULIB_GETSUBOPT)\/g' \\\n+\t      -e 's\/@''GNULIB_GRANTPT''@\/$(GNULIB_GRANTPT)\/g' \\\n+\t      -e 's\/@''GNULIB_MALLOC_POSIX''@\/$(GNULIB_MALLOC_POSIX)\/g' \\\n+\t      -e 's\/@''GNULIB_MBTOWC''@\/$(GNULIB_MBTOWC)\/g' \\\n+\t      -e 's\/@''GNULIB_MKDTEMP''@\/$(GNULIB_MKDTEMP)\/g' \\\n+\t      -e 's\/@''GNULIB_MKOSTEMP''@\/$(GNULIB_MKOSTEMP)\/g' \\\n+\t      -e 's\/@''GNULIB_MKOSTEMPS''@\/$(GNULIB_MKOSTEMPS)\/g' \\\n+\t      -e 's\/@''GNULIB_MKSTEMP''@\/$(GNULIB_MKSTEMP)\/g' \\\n+\t      -e 's\/@''GNULIB_MKSTEMPS''@\/$(GNULIB_MKSTEMPS)\/g' \\\n+\t      -e 's\/@''GNULIB_POSIX_OPENPT''@\/$(GNULIB_POSIX_OPENPT)\/g' \\\n+\t      -e 's\/@''GNULIB_PTSNAME''@\/$(GNULIB_PTSNAME)\/g' \\\n+\t      -e 's\/@''GNULIB_PTSNAME_R''@\/$(GNULIB_PTSNAME_R)\/g' \\\n+\t      -e 's\/@''GNULIB_PUTENV''@\/$(GNULIB_PUTENV)\/g' \\\n+\t      -e 's\/@''GNULIB_QSORT_R''@\/$(GNULIB_QSORT_R)\/g' \\\n+\t      -e 's\/@''GNULIB_RANDOM''@\/$(GNULIB_RANDOM)\/g' \\\n+\t      -e 's\/@''GNULIB_RANDOM_R''@\/$(GNULIB_RANDOM_R)\/g' \\\n+\t      -e 's\/@''GNULIB_REALLOC_POSIX''@\/$(GNULIB_REALLOC_POSIX)\/g' \\\n+\t      -e 's\/@''GNULIB_REALPATH''@\/$(GNULIB_REALPATH)\/g' \\\n+\t      -e 's\/@''GNULIB_RPMATCH''@\/$(GNULIB_RPMATCH)\/g' \\\n+\t      -e 's\/@''GNULIB_SECURE_GETENV''@\/$(GNULIB_SECURE_GETENV)\/g' \\\n+\t      -e 's\/@''GNULIB_SETENV''@\/$(GNULIB_SETENV)\/g' \\\n+\t      -e 's\/@''GNULIB_STRTOD''@\/$(GNULIB_STRTOD)\/g' \\\n+\t      -e 's\/@''GNULIB_STRTOLL''@\/$(GNULIB_STRTOLL)\/g' \\\n+\t      -e 's\/@''GNULIB_STRTOULL''@\/$(GNULIB_STRTOULL)\/g' \\\n+\t      -e 's\/@''GNULIB_SYSTEM_POSIX''@\/$(GNULIB_SYSTEM_POSIX)\/g' \\\n+\t      -e 's\/@''GNULIB_UNLOCKPT''@\/$(GNULIB_UNLOCKPT)\/g' \\\n+\t      -e 's\/@''GNULIB_UNSETENV''@\/$(GNULIB_UNSETENV)\/g' \\\n+\t      -e 's\/@''GNULIB_WCTOMB''@\/$(GNULIB_WCTOMB)\/g' \\\n+\t      < $(srcdir)\/stdlib.in.h | \\\n+\t  sed -e 's|@''HAVE__EXIT''@|$(HAVE__EXIT)|g' \\\n+\t      -e 's|@''HAVE_ATOLL''@|$(HAVE_ATOLL)|g' \\\n+\t      -e 's|@''HAVE_CANONICALIZE_FILE_NAME''@|$(HAVE_CANONICALIZE_FILE_NAME)|g' \\\n+\t      -e 's|@''HAVE_DECL_GETLOADAVG''@|$(HAVE_DECL_GETLOADAVG)|g' \\\n+\t      -e 's|@''HAVE_GETSUBOPT''@|$(HAVE_GETSUBOPT)|g' \\\n+\t      -e 's|@''HAVE_GRANTPT''@|$(HAVE_GRANTPT)|g' \\\n+\t      -e 's|@''HAVE_MKDTEMP''@|$(HAVE_MKDTEMP)|g' \\\n+\t      -e 's|@''HAVE_MKOSTEMP''@|$(HAVE_MKOSTEMP)|g' \\\n+\t      -e 's|@''HAVE_MKOSTEMPS''@|$(HAVE_MKOSTEMPS)|g' \\\n+\t      -e 's|@''HAVE_MKSTEMP''@|$(HAVE_MKSTEMP)|g' \\\n+\t      -e 's|@''HAVE_MKSTEMPS''@|$(HAVE_MKSTEMPS)|g' \\\n+\t      -e 's|@''HAVE_POSIX_OPENPT''@|$(HAVE_POSIX_OPENPT)|g' \\\n+\t      -e 's|@''HAVE_PTSNAME''@|$(HAVE_PTSNAME)|g' \\\n+\t      -e 's|@''HAVE_PTSNAME_R''@|$(HAVE_PTSNAME_R)|g' \\\n+\t      -e 's|@''HAVE_RANDOM''@|$(HAVE_RANDOM)|g' \\\n+\t      -e 's|@''HAVE_RANDOM_H''@|$(HAVE_RANDOM_H)|g' \\\n+\t      -e 's|@''HAVE_RANDOM_R''@|$(HAVE_RANDOM_R)|g' \\\n+\t      -e 's|@''HAVE_REALPATH''@|$(HAVE_REALPATH)|g' \\\n+\t      -e 's|@''HAVE_RPMATCH''@|$(HAVE_RPMATCH)|g' \\\n+\t      -e 's|@''HAVE_SECURE_GETENV''@|$(HAVE_SECURE_GETENV)|g' \\\n+\t      -e 's|@''HAVE_DECL_SETENV''@|$(HAVE_DECL_SETENV)|g' \\\n+\t      -e 's|@''HAVE_STRTOD''@|$(HAVE_STRTOD)|g' \\\n+\t      -e 's|@''HAVE_STRTOLL''@|$(HAVE_STRTOLL)|g' \\\n+\t      -e 's|@''HAVE_STRTOULL''@|$(HAVE_STRTOULL)|g' \\\n+\t      -e 's|@''HAVE_STRUCT_RANDOM_DATA''@|$(HAVE_STRUCT_RANDOM_DATA)|g' \\\n+\t      -e 's|@''HAVE_SYS_LOADAVG_H''@|$(HAVE_SYS_LOADAVG_H)|g' \\\n+\t      -e 's|@''HAVE_UNLOCKPT''@|$(HAVE_UNLOCKPT)|g' \\\n+\t      -e 's|@''HAVE_DECL_UNSETENV''@|$(HAVE_DECL_UNSETENV)|g' \\\n+\t      -e 's|@''REPLACE_CALLOC''@|$(REPLACE_CALLOC)|g' \\\n+\t      -e 's|@''REPLACE_CANONICALIZE_FILE_NAME''@|$(REPLACE_CANONICALIZE_FILE_NAME)|g' \\\n+\t      -e 's|@''REPLACE_MALLOC''@|$(REPLACE_MALLOC)|g' \\\n+\t      -e 's|@''REPLACE_MBTOWC''@|$(REPLACE_MBTOWC)|g' \\\n+\t      -e 's|@''REPLACE_MKSTEMP''@|$(REPLACE_MKSTEMP)|g' \\\n+\t      -e 's|@''REPLACE_PTSNAME''@|$(REPLACE_PTSNAME)|g' \\\n+\t      -e 's|@''REPLACE_PTSNAME_R''@|$(REPLACE_PTSNAME_R)|g' \\\n+\t      -e 's|@''REPLACE_PUTENV''@|$(REPLACE_PUTENV)|g' \\\n+\t      -e 's|@''REPLACE_QSORT_R''@|$(REPLACE_QSORT_R)|g' \\\n+\t      -e 's|@''REPLACE_RANDOM_R''@|$(REPLACE_RANDOM_R)|g' \\\n+\t      -e 's|@''REPLACE_REALLOC''@|$(REPLACE_REALLOC)|g' \\\n+\t      -e 's|@''REPLACE_REALPATH''@|$(REPLACE_REALPATH)|g' \\\n+\t      -e 's|@''REPLACE_SETENV''@|$(REPLACE_SETENV)|g' \\\n+\t      -e 's|@''REPLACE_STRTOD''@|$(REPLACE_STRTOD)|g' \\\n+\t      -e 's|@''REPLACE_UNSETENV''@|$(REPLACE_UNSETENV)|g' \\\n+\t      -e 's|@''REPLACE_WCTOMB''@|$(REPLACE_WCTOMB)|g' \\\n+\t      -e '\/definitions of _GL_FUNCDECL_RPL\/r $(CXXDEFS_H)' \\\n+\t      -e '\/definition of _Noreturn\/r $(_NORETURN_H)' \\\n+\t      -e '\/definition of _GL_ARG_NONNULL\/r $(ARG_NONNULL_H)' \\\n+\t      -e '\/definition of _GL_WARN_ON_USE\/r $(WARN_ON_USE_H)'; \\\n+\t} > $@-t && \\\n+\tmv $@-t $@\n+MOSTLYCLEANFILES += stdlib.h stdlib.h-t\n+\n+EXTRA_DIST += stdlib.in.h\n+\n+## end   gnulib module stdlib\n+\n ## begin gnulib module strerror\n \n \ndiff --git a\/gl\/getdelim.c b\/gl\/getdelim.c\nnew file mode 100644\nindex 0000000..88258e5\n--- \/dev\/null\n+++ b\/gl\/getdelim.c\n@@ -0,0 +1,135 @@\n+\/* getdelim.c --- Implementation of replacement getdelim function.\n+   Copyright (C) 1994, 1996-1998, 2001, 2003, 2005-2015 Free Software\n+   Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and\/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 3, or (at\n+   your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, see <http:\/\/www.gnu.org\/licenses\/>.  *\/\n+\n+\/* Ported from glibc by Simon Josefsson. *\/\n+\n+\/* Don't use __attribute__ __nonnull__ in this compilation unit.  Otherwise gcc\n+   optimizes away the lineptr == NULL || n == NULL || fp == NULL tests below.  *\/\n+#define _GL_ARG_NONNULL(params)\n+\n+#include <config.h>\n+\n+#include <stdio.h>\n+\n+#include <limits.h>\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+\n+#ifndef SSIZE_MAX\n+# define SSIZE_MAX ((ssize_t) (SIZE_MAX \/ 2))\n+#endif\n+\n+#if USE_UNLOCKED_IO\n+# include \"unlocked-io.h\"\n+# define getc_maybe_unlocked(fp)        getc(fp)\n+#elif !HAVE_FLOCKFILE || !HAVE_FUNLOCKFILE || !HAVE_DECL_GETC_UNLOCKED\n+# undef flockfile\n+# undef funlockfile\n+# define flockfile(x) ((void) 0)\n+# define funlockfile(x) ((void) 0)\n+# define getc_maybe_unlocked(fp)        getc(fp)\n+#else\n+# define getc_maybe_unlocked(fp)        getc_unlocked(fp)\n+#endif\n+\n+\/* Read up to (and including) a DELIMITER from FP into *LINEPTR (and\n+   NUL-terminate it).  *LINEPTR is a pointer returned from malloc (or\n+   NULL), pointing to *N characters of space.  It is realloc'ed as\n+   necessary.  Returns the number of characters read (not including\n+   the null terminator), or -1 on error or EOF.  *\/\n+\n+ssize_t\n+getdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n+{\n+  ssize_t result;\n+  size_t cur_len = 0;\n+\n+  if (lineptr == NULL || n == NULL || fp == NULL)\n+    {\n+      errno = EINVAL;\n+      return -1;\n+    }\n+\n+  flockfile (fp);\n+\n+  if (*lineptr == NULL || *n == 0)\n+    {\n+      char *new_lineptr;\n+      *n = 120;\n+      new_lineptr = (char *) realloc (*lineptr, *n);\n+      if (new_lineptr == NULL)\n+        {\n+          result = -1;\n+          goto unlock_return;\n+        }\n+      *lineptr = new_lineptr;\n+    }\n+\n+  for (;;)\n+    {\n+      int i;\n+\n+      i = getc_maybe_unlocked (fp);\n+      if (i == EOF)\n+        {\n+          result = -1;\n+          break;\n+        }\n+\n+      \/* Make enough space for len+1 (for final NUL) bytes.  *\/\n+      if (cur_len + 1 >= *n)\n+        {\n+          size_t needed_max =\n+            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n+          size_t needed = 2 * *n + 1;   \/* Be generous. *\/\n+          char *new_lineptr;\n+\n+          if (needed_max < needed)\n+            needed = needed_max;\n+          if (cur_len + 1 >= needed)\n+            {\n+              result = -1;\n+              errno = EOVERFLOW;\n+              goto unlock_return;\n+            }\n+\n+          new_lineptr = (char *) realloc (*lineptr, needed);\n+          if (new_lineptr == NULL)\n+            {\n+              result = -1;\n+              goto unlock_return;\n+            }\n+\n+          *lineptr = new_lineptr;\n+          *n = needed;\n+        }\n+\n+      (*lineptr)[cur_len] = i;\n+      cur_len++;\n+\n+      if (i == delimiter)\n+        break;\n+    }\n+  (*lineptr)[cur_len] = '\\0';\n+  result = cur_len ? cur_len : result;\n+\n+ unlock_return:\n+  funlockfile (fp); \/* doesn't set errno *\/\n+\n+  return result;\n+}\ndiff --git a\/gl\/getline.c b\/gl\/getline.c\nnew file mode 100644\nindex 0000000..811c773\n--- \/dev\/null\n+++ b\/gl\/getline.c\n@@ -0,0 +1,27 @@\n+\/* getline.c --- Implementation of replacement getline function.\n+   Copyright (C) 2005-2007, 2009-2015 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and\/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 3, or (at\n+   your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, see <http:\/\/www.gnu.org\/licenses\/>.  *\/\n+\n+\/* Written by Simon Josefsson. *\/\n+\n+#include <config.h>\n+\n+#include <stdio.h>\n+\n+ssize_t\n+getline (char **lineptr, size_t *n, FILE *stream)\n+{\n+  return getdelim (lineptr, n, '\\n', stream);\n+}\ndiff --git a\/gl\/m4\/getdelim.m4 b\/gl\/m4\/getdelim.m4\nnew file mode 100644\nindex 0000000..af9b1fa\n--- \/dev\/null\n+++ b\/gl\/m4\/getdelim.m4\n@@ -0,0 +1,88 @@\n+# getdelim.m4 serial 10\n+\n+dnl Copyright (C) 2005-2007, 2009-2015 Free Software Foundation, Inc.\n+dnl\n+dnl This file is free software; the Free Software Foundation\n+dnl gives unlimited permission to copy and\/or distribute it,\n+dnl with or without modifications, as long as this notice is preserved.\n+\n+AC_PREREQ([2.59])\n+\n+AC_DEFUN([gl_FUNC_GETDELIM],\n+[\n+  AC_REQUIRE([gl_STDIO_H_DEFAULTS])\n+\n+  dnl Persuade glibc <stdio.h> to declare getdelim().\n+  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])\n+\n+  AC_CHECK_DECLS_ONCE([getdelim])\n+\n+  AC_CHECK_FUNCS_ONCE([getdelim])\n+  if test $ac_cv_func_getdelim = yes; then\n+    HAVE_GETDELIM=1\n+    dnl Found it in some library.  Verify that it works.\n+    AC_CACHE_CHECK([for working getdelim function], [gl_cv_func_working_getdelim],\n+    [echo fooNbarN | tr -d '\\012' | tr N '\\012' > conftest.data\n+    AC_RUN_IFELSE([AC_LANG_SOURCE([[\n+#    include <stdio.h>\n+#    include <stdlib.h>\n+#    include <string.h>\n+    int main ()\n+    {\n+      FILE *in = fopen (\".\/conftest.data\", \"r\");\n+      if (!in)\n+        return 1;\n+      {\n+        \/* Test result for a NULL buffer and a zero size.\n+           Based on a test program from Karl Heuer.  *\/\n+        char *line = NULL;\n+        size_t siz = 0;\n+        int len = getdelim (&line, &siz, '\\n', in);\n+        if (!(len == 4 && line && strcmp (line, \"foo\\n\") == 0))\n+          return 2;\n+      }\n+      {\n+        \/* Test result for a NULL buffer and a non-zero size.\n+           This crashes on FreeBSD 8.0.  *\/\n+        char *line = NULL;\n+        size_t siz = (size_t)(~0) \/ 4;\n+        if (getdelim (&line, &siz, '\\n', in) == -1)\n+          return 3;\n+      }\n+      return 0;\n+    }\n+    ]])], [gl_cv_func_working_getdelim=yes] dnl The library version works.\n+    , [gl_cv_func_working_getdelim=no] dnl The library version does NOT work.\n+    , dnl We're cross compiling. Assume it works on glibc2 systems.\n+      [AC_EGREP_CPP([Lucky GNU user],\n+         [\n+#include <features.h>\n+#ifdef __GNU_LIBRARY__\n+ #if (__GLIBC__ >= 2) && !defined __UCLIBC__\n+  Lucky GNU user\n+ #endif\n+#endif\n+         ],\n+         [gl_cv_func_working_getdelim=\"guessing yes\"],\n+         [gl_cv_func_working_getdelim=\"guessing no\"])]\n+    )])\n+    case \"$gl_cv_func_working_getdelim\" in\n+      *no)\n+        REPLACE_GETDELIM=1\n+        ;;\n+    esac\n+  else\n+    HAVE_GETDELIM=0\n+  fi\n+\n+  if test $ac_cv_have_decl_getdelim = no; then\n+    HAVE_DECL_GETDELIM=0\n+  fi\n+])\n+\n+# Prerequisites of lib\/getdelim.c.\n+AC_DEFUN([gl_PREREQ_GETDELIM],\n+[\n+  AC_CHECK_FUNCS([flockfile funlockfile])\n+  AC_CHECK_DECLS([getc_unlocked])\n+])\ndiff --git a\/gl\/m4\/getline.m4 b\/gl\/m4\/getline.m4\nnew file mode 100644\nindex 0000000..a35f3a2\n--- \/dev\/null\n+++ b\/gl\/m4\/getline.m4\n@@ -0,0 +1,96 @@\n+# getline.m4 serial 26\n+\n+dnl Copyright (C) 1998-2003, 2005-2007, 2009-2015 Free Software Foundation,\n+dnl Inc.\n+dnl\n+dnl This file is free software; the Free Software Foundation\n+dnl gives unlimited permission to copy and\/or distribute it,\n+dnl with or without modifications, as long as this notice is preserved.\n+\n+AC_PREREQ([2.59])\n+\n+dnl See if there's a working, system-supplied version of the getline function.\n+dnl We can't just do AC_REPLACE_FUNCS([getline]) because some systems\n+dnl have a function by that name in -linet that doesn't have anything\n+dnl to do with the function we need.\n+AC_DEFUN([gl_FUNC_GETLINE],\n+[\n+  AC_REQUIRE([gl_STDIO_H_DEFAULTS])\n+\n+  dnl Persuade glibc <stdio.h> to declare getline().\n+  AC_REQUIRE([AC_USE_SYSTEM_EXTENSIONS])\n+\n+  AC_CHECK_DECLS_ONCE([getline])\n+\n+  gl_getline_needs_run_time_check=no\n+  AC_CHECK_FUNC([getline],\n+                [dnl Found it in some library.  Verify that it works.\n+                 gl_getline_needs_run_time_check=yes],\n+                [am_cv_func_working_getline=no])\n+  if test $gl_getline_needs_run_time_check = yes; then\n+    AC_CACHE_CHECK([for working getline function], [am_cv_func_working_getline],\n+    [echo fooNbarN | tr -d '\\012' | tr N '\\012' > conftest.data\n+    AC_RUN_IFELSE([AC_LANG_SOURCE([[\n+#    include <stdio.h>\n+#    include <stdlib.h>\n+#    include <string.h>\n+    int main ()\n+    {\n+      FILE *in = fopen (\".\/conftest.data\", \"r\");\n+      if (!in)\n+        return 1;\n+      {\n+        \/* Test result for a NULL buffer and a zero size.\n+           Based on a test program from Karl Heuer.  *\/\n+        char *line = NULL;\n+        size_t siz = 0;\n+        int len = getline (&line, &siz, in);\n+        if (!(len == 4 && line && strcmp (line, \"foo\\n\") == 0))\n+          return 2;\n+      }\n+      {\n+        \/* Test result for a NULL buffer and a non-zero size.\n+           This crashes on FreeBSD 8.0.  *\/\n+        char *line = NULL;\n+        size_t siz = (size_t)(~0) \/ 4;\n+        if (getline (&line, &siz, in) == -1)\n+          return 3;\n+      }\n+      return 0;\n+    }\n+    ]])], [am_cv_func_working_getline=yes] dnl The library version works.\n+    , [am_cv_func_working_getline=no] dnl The library version does NOT work.\n+    , dnl We're cross compiling. Assume it works on glibc2 systems.\n+      [AC_EGREP_CPP([Lucky GNU user],\n+         [\n+#include <features.h>\n+#ifdef __GNU_LIBRARY__\n+ #if (__GLIBC__ >= 2) && !defined __UCLIBC__\n+  Lucky GNU user\n+ #endif\n+#endif\n+         ],\n+         [am_cv_func_working_getline=\"guessing yes\"],\n+         [am_cv_func_working_getline=\"guessing no\"])]\n+    )])\n+  fi\n+\n+  if test $ac_cv_have_decl_getline = no; then\n+    HAVE_DECL_GETLINE=0\n+  fi\n+\n+  case \"$am_cv_func_working_getline\" in\n+    *no)\n+      dnl Set REPLACE_GETLINE always: Even if we have not found the broken\n+      dnl getline function among $LIBS, it may exist in libinet and the\n+      dnl executable may be linked with -linet.\n+      REPLACE_GETLINE=1\n+      ;;\n+  esac\n+])\n+\n+# Prerequisites of lib\/getline.c.\n+AC_DEFUN([gl_PREREQ_GETLINE],\n+[\n+  :\n+])\ndiff --git a\/gl\/m4\/gnulib-cache.m4 b\/gl\/m4\/gnulib-cache.m4\nindex 61e1f01..6995fe5 100644\n--- a\/gl\/m4\/gnulib-cache.m4\n+++ b\/gl\/m4\/gnulib-cache.m4\n@@ -27,7 +27,7 @@\n \n \n # Specification in the form of a command-line invocation:\n-#   gnulib-tool --import --dir=. --local-dir=gl\/override --lib=libgnu --source-base=gl --m4-base=gl\/m4 --doc-base=doc --tests-base=gltests --aux-dir=build-aux --with-tests --avoid=fcntl-h-tests --avoid=stdlib-tests --avoid=string-tests --avoid=sys_stat-tests --avoid=time-tests --avoid=unistd-tests --avoid=update-copyright-tests --avoid=wchar-tests --no-conditional-dependencies --libtool --macro-prefix=gl --no-vc-files autobuild csharpcomp-script csharpexec-script error fdl-1.3 gendocs getopt-gnu gnupload maintainer-makefile manywarnings pmccabe2html progname update-copyright useless-if-before-free valgrind-tests vc-list-files version-etc warnings\n+#   gnulib-tool --import --dir=. --local-dir=gl\/override --lib=libgnu --source-base=gl --m4-base=gl\/m4 --doc-base=doc --tests-base=gltests --aux-dir=build-aux --with-tests --avoid=fcntl-h-tests --avoid=stdlib-tests --avoid=string-tests --avoid=sys_stat-tests --avoid=time-tests --avoid=unistd-tests --avoid=update-copyright-tests --avoid=wchar-tests --no-conditional-dependencies --libtool --macro-prefix=gl --no-vc-files autobuild csharpcomp-script csharpexec-script error fdl-1.3 gendocs getline getopt-gnu gnupload maintainer-makefile manywarnings pmccabe2html progname update-copyright useless-if-before-free valgrind-tests vc-list-files version-etc warnings\n \n # Specification in the form of a few gnulib-tool.m4 macro invocations:\n gl_LOCAL_DIR([gl\/override])\n@@ -38,6 +38,7 @@ gl_MODULES([\n   error\n   fdl-1.3\n   gendocs\n+  getline\n   getopt-gnu\n   gnupload\n   maintainer-makefile\ndiff --git a\/gl\/m4\/gnulib-comp.m4 b\/gl\/m4\/gnulib-comp.m4\nindex 076d36d..66430dd 100644\n--- a\/gl\/m4\/gnulib-comp.m4\n+++ b\/gl\/m4\/gnulib-comp.m4\n@@ -74,8 +74,12 @@ AC_DEFUN([gl_EARLY],\n   # Code from module gendocs:\n   # Code from module getcwd-lgpl:\n   # Code from module getcwd-lgpl-tests:\n+  # Code from module getdelim:\n+  # Code from module getdelim-tests:\n   # Code from module getdtablesize:\n   # Code from module getdtablesize-tests:\n+  # Code from module getline:\n+  # Code from module getline-tests:\n   # Code from module getopt-gnu:\n   # Code from module getopt-posix:\n   # Code from module getopt-posix-tests:\n@@ -112,6 +116,7 @@ AC_DEFUN([gl_EARLY],\n   # Code from module pmccabe2html:\n   # Code from module progname:\n   # Code from module putenv:\n+  # Code from module realloc-posix:\n   # Code from module same-inode:\n   # Code from module setenv:\n   # Code from module setenv-tests:\n@@ -198,6 +203,18 @@ AC_DEFUN([gl_INIT],\n     [AM_][XGETTEXT_OPTION([--flag=error:3:c-format])\n      AM_][XGETTEXT_OPTION([--flag=error_at_line:5:c-format])])\n   AC_REQUIRE([gl_EXTERN_INLINE])\n+  gl_FUNC_GETDELIM\n+  if test $HAVE_GETDELIM = 0 || test $REPLACE_GETDELIM = 1; then\n+    AC_LIBOBJ([getdelim])\n+    gl_PREREQ_GETDELIM\n+  fi\n+  gl_STDIO_MODULE_INDICATOR([getdelim])\n+  gl_FUNC_GETLINE\n+  if test $REPLACE_GETLINE = 1; then\n+    AC_LIBOBJ([getline])\n+    gl_PREREQ_GETLINE\n+  fi\n+  gl_STDIO_MODULE_INDICATOR([getline])\n   gl_FUNC_GETOPT_GNU\n   if test $REPLACE_GETOPT = 1; then\n     AC_LIBOBJ([getopt])\n@@ -240,13 +257,21 @@ AC_DEFUN([gl_INIT],\n   if test $HAVE_MSVC_INVALID_PARAMETER_HANDLER = 1; then\n     AC_LIBOBJ([msvc-nothrow])\n   fi\n+  gl_MULTIARCH\n   AC_PATH_PROG([PMCCABE], [pmccabe], [false])\n   AC_CHECK_DECLS([program_invocation_name], [], [], [#include <errno.h>])\n   AC_CHECK_DECLS([program_invocation_short_name], [], [], [#include <errno.h>])\n+  gl_FUNC_REALLOC_POSIX\n+  if test $REPLACE_REALLOC = 1; then\n+    AC_LIBOBJ([realloc])\n+  fi\n+  gl_STDLIB_MODULE_INDICATOR([realloc-posix])\n   gt_TYPE_SSIZE_T\n   gl_STDARG_H\n   gl_STDDEF_H\n+  gl_STDINT_H\n   gl_STDIO_H\n+  gl_STDLIB_H\n   gl_FUNC_STRERROR\n   if test $REPLACE_STRERROR = 1; then\n     AC_LIBOBJ([strerror])\n@@ -370,7 +395,6 @@ changequote([, ])dnl\n   fi\n   gl_STDLIB_MODULE_INDICATOR([malloc-posix])\n   gl_MALLOCA\n-  gl_MULTIARCH\n   gl_FUNC_OPEN\n   if test $REPLACE_OPEN = 1; then\n     AC_LIBOBJ([open])\n@@ -397,10 +421,8 @@ changequote([, ])dnl\n   gl_SYS_STAT_MODULE_INDICATOR([stat])\n   gl_STDALIGN_H\n   AM_STDBOOL_H\n-  gl_STDINT_H\n   AC_REQUIRE([gt_TYPE_WCHAR_T])\n   AC_REQUIRE([gt_TYPE_WINT_T])\n-  gl_STDLIB_H\n   gl_FUNC_SYMLINK\n   if test $HAVE_SYMLINK = 0 || test $REPLACE_SYMLINK = 1; then\n     AC_LIBOBJ([symlink])\n@@ -532,6 +554,8 @@ AC_DEFUN([gl_FILE_LIST], [\n   lib\/errno.in.h\n   lib\/error.c\n   lib\/error.h\n+  lib\/getdelim.c\n+  lib\/getline.c\n   lib\/getopt.c\n   lib\/getopt.in.h\n   lib\/getopt1.c\n@@ -544,9 +568,12 @@ AC_DEFUN([gl_FILE_LIST], [\n   lib\/msvc-nothrow.h\n   lib\/progname.c\n   lib\/progname.h\n+  lib\/realloc.c\n   lib\/stdarg.in.h\n   lib\/stddef.in.h\n+  lib\/stdint.in.h\n   lib\/stdio.in.h\n+  lib\/stdlib.in.h\n   lib\/strerror-override.c\n   lib\/strerror-override.h\n   lib\/strerror.c\n@@ -577,7 +604,9 @@ AC_DEFUN([gl_FILE_LIST], [\n   m4\/fdopen.m4\n   m4\/fstat.m4\n   m4\/getcwd.m4\n+  m4\/getdelim.m4\n   m4\/getdtablesize.m4\n+  m4\/getline.m4\n   m4\/getopt.m4\n   m4\/gettimeofday.m4\n   m4\/gnulib-common.m4\n@@ -599,6 +628,7 @@ AC_DEFUN([gl_FILE_LIST], [\n   m4\/open.m4\n   m4\/pathmax.m4\n   m4\/putenv.m4\n+  m4\/realloc.m4\n   m4\/setenv.m4\n   m4\/ssize_t.m4\n   m4\/stat.m4\n@@ -642,7 +672,9 @@ AC_DEFUN([gl_FILE_LIST], [\n   tests\/test-fstat.c\n   tests\/test-fwrite.c\n   tests\/test-getcwd-lgpl.c\n+  tests\/test-getdelim.c\n   tests\/test-getdtablesize.c\n+  tests\/test-getline.c\n   tests\/test-getopt.c\n   tests\/test-getopt.h\n   tests\/test-getopt_long.h\n@@ -706,8 +738,6 @@ AC_DEFUN([gl_FILE_LIST], [\n   tests=lib\/stat.c\n   tests=lib\/stdalign.in.h\n   tests=lib\/stdbool.in.h\n-  tests=lib\/stdint.in.h\n-  tests=lib\/stdlib.in.h\n   tests=lib\/symlink.c\n   tests=lib\/sys_stat.in.h\n   tests=lib\/sys_time.in.h\ndiff --git a\/gl\/m4\/realloc.m4 b\/gl\/m4\/realloc.m4\nnew file mode 100644\nindex 0000000..0e1d338\n--- \/dev\/null\n+++ b\/gl\/m4\/realloc.m4\n@@ -0,0 +1,76 @@\n+# realloc.m4 serial 13\n+dnl Copyright (C) 2007, 2009-2015 Free Software Foundation, Inc.\n+dnl This file is free software; the Free Software Foundation\n+dnl gives unlimited permission to copy and\/or distribute it,\n+dnl with or without modifications, as long as this notice is preserved.\n+\n+m4_version_prereq([2.70], [] ,[\n+\n+# This is taken from the following Autoconf patch:\n+# http:\/\/git.savannah.gnu.org\/gitweb\/?p=autoconf.git;a=commitdiff;h=7fbb553727ed7e0e689a17594b58559ecf3ea6e9\n+AC_DEFUN([_AC_FUNC_REALLOC_IF],\n+[\n+  AC_REQUIRE([AC_HEADER_STDC])dnl\n+  AC_REQUIRE([AC_CANONICAL_HOST])dnl for cross-compiles\n+  AC_CHECK_HEADERS([stdlib.h])\n+  AC_CACHE_CHECK([for GNU libc compatible realloc],\n+    [ac_cv_func_realloc_0_nonnull],\n+    [AC_RUN_IFELSE(\n+       [AC_LANG_PROGRAM(\n+          [[#if defined STDC_HEADERS || defined HAVE_STDLIB_H\n+            # include <stdlib.h>\n+            #else\n+            char *realloc ();\n+            #endif\n+          ]],\n+          [[return ! realloc (0, 0);]])\n+       ],\n+       [ac_cv_func_realloc_0_nonnull=yes],\n+       [ac_cv_func_realloc_0_nonnull=no],\n+       [case \"$host_os\" in\n+          # Guess yes on platforms where we know the result.\n+          *-gnu* | freebsd* | netbsd* | openbsd* \\\n+          | hpux* | solaris* | cygwin* | mingw*)\n+            ac_cv_func_realloc_0_nonnull=yes ;;\n+          # If we don't know, assume the worst.\n+          *) ac_cv_func_realloc_0_nonnull=no ;;\n+        esac\n+       ])\n+    ])\n+  AS_IF([test $ac_cv_func_realloc_0_nonnull = yes], [$1], [$2])\n+])# AC_FUNC_REALLOC\n+\n+])\n+\n+# gl_FUNC_REALLOC_GNU\n+# -------------------\n+# Test whether 'realloc (0, 0)' is handled like in GNU libc, and replace\n+# realloc if it is not.\n+AC_DEFUN([gl_FUNC_REALLOC_GNU],\n+[\n+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])\n+  dnl _AC_FUNC_REALLOC_IF is defined in Autoconf.\n+  _AC_FUNC_REALLOC_IF(\n+    [AC_DEFINE([HAVE_REALLOC_GNU], [1],\n+               [Define to 1 if your system has a GNU libc compatible 'realloc'\n+                function, and to 0 otherwise.])],\n+    [AC_DEFINE([HAVE_REALLOC_GNU], [0])\n+     REPLACE_REALLOC=1\n+    ])\n+])# gl_FUNC_REALLOC_GNU\n+\n+# gl_FUNC_REALLOC_POSIX\n+# ---------------------\n+# Test whether 'realloc' is POSIX compliant (sets errno to ENOMEM when it\n+# fails), and replace realloc if it is not.\n+AC_DEFUN([gl_FUNC_REALLOC_POSIX],\n+[\n+  AC_REQUIRE([gl_STDLIB_H_DEFAULTS])\n+  AC_REQUIRE([gl_CHECK_MALLOC_POSIX])\n+  if test $gl_cv_func_malloc_posix = yes; then\n+    AC_DEFINE([HAVE_REALLOC_POSIX], [1],\n+      [Define if the 'realloc' function is POSIX compliant.])\n+  else\n+    REPLACE_REALLOC=1\n+  fi\n+])\ndiff --git a\/gl\/realloc.c b\/gl\/realloc.c\nnew file mode 100644\nindex 0000000..068b081\n--- \/dev\/null\n+++ b\/gl\/realloc.c\n@@ -0,0 +1,79 @@\n+\/* realloc() function that is glibc compatible.\n+\n+   Copyright (C) 1997, 2003-2004, 2006-2007, 2009-2015 Free Software\n+   Foundation, Inc.\n+\n+   This program is free software: you can redistribute it and\/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.  *\/\n+\n+\/* written by Jim Meyering and Bruno Haible *\/\n+\n+#define _GL_USE_STDLIB_ALLOC 1\n+#include <config.h>\n+\n+\/* Only the AC_FUNC_REALLOC macro defines 'realloc' already in config.h.  *\/\n+#ifdef realloc\n+# define NEED_REALLOC_GNU 1\n+\/* Whereas the gnulib module 'realloc-gnu' defines HAVE_REALLOC_GNU.  *\/\n+#elif GNULIB_REALLOC_GNU && !HAVE_REALLOC_GNU\n+# define NEED_REALLOC_GNU 1\n+#endif\n+\n+\/* Infer the properties of the system's malloc function.\n+   The gnulib module 'malloc-gnu' defines HAVE_MALLOC_GNU.  *\/\n+#if GNULIB_MALLOC_GNU && HAVE_MALLOC_GNU\n+# define SYSTEM_MALLOC_GLIBC_COMPATIBLE 1\n+#endif\n+\n+#include <stdlib.h>\n+\n+#include <errno.h>\n+\n+\/* Change the size of an allocated block of memory P to N bytes,\n+   with error checking.  If N is zero, change it to 1.  If P is NULL,\n+   use malloc.  *\/\n+\n+void *\n+rpl_realloc (void *p, size_t n)\n+{\n+  void *result;\n+\n+#if NEED_REALLOC_GNU\n+  if (n == 0)\n+    {\n+      n = 1;\n+\n+      \/* In theory realloc might fail, so don't rely on it to free.  *\/\n+      free (p);\n+      p = NULL;\n+    }\n+#endif\n+\n+  if (p == NULL)\n+    {\n+#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n+      if (n == 0)\n+        n = 1;\n+#endif\n+      result = malloc (n);\n+    }\n+  else\n+    result = realloc (p, n);\n+\n+#if !HAVE_REALLOC_POSIX\n+  if (result == NULL)\n+    errno = ENOMEM;\n+#endif\n+\n+  return result;\n+}\ndiff --git a\/gl\/stdint.in.h b\/gl\/stdint.in.h\nnew file mode 100644\nindex 0000000..378de2e\n--- \/dev\/null\n+++ b\/gl\/stdint.in.h\n@@ -0,0 +1,635 @@\n+\/* Copyright (C) 2001-2002, 2004-2015 Free Software Foundation, Inc.\n+   Written by Paul Eggert, Bruno Haible, Sam Steingold, Peter Burwood.\n+   This file is part of gnulib.\n+\n+   This program is free software; you can redistribute it and\/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, see <http:\/\/www.gnu.org\/licenses\/>.  *\/\n+\n+\/*\n+ * ISO C 99 <stdint.h> for platforms that lack it.\n+ * <http:\/\/www.opengroup.org\/susv3xbd\/stdint.h.html>\n+ *\/\n+\n+#ifndef _@GUARD_PREFIX@_STDINT_H\n+\n+#if __GNUC__ >= 3\n+@PRAGMA_SYSTEM_HEADER@\n+#endif\n+@PRAGMA_COLUMNS@\n+\n+\/* When including a system file that in turn includes <inttypes.h>,\n+   use the system <inttypes.h>, not our substitute.  This avoids\n+   problems with (for example) VMS, whose <sys\/bitypes.h> includes\n+   <inttypes.h>.  *\/\n+#define _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H\n+\n+\/* On Android (Bionic libc), <sys\/types.h> includes this file before\n+   having defined 'time_t'.  Therefore in this case avoid including\n+   other system header files; just include the system's <stdint.h>.\n+   Ideally we should test __BIONIC__ here, but it is only defined after\n+   <sys\/cdefs.h> has been included; hence test __ANDROID__ instead.  *\/\n+#if defined __ANDROID__ && defined _GL_INCLUDING_SYS_TYPES_H\n+# @INCLUDE_NEXT@ @NEXT_STDINT_H@\n+#else\n+\n+\/* Get those types that are already defined in other system include\n+   files, so that we can \"#define int8_t signed char\" below without\n+   worrying about a later system include file containing a \"typedef\n+   signed char int8_t;\" that will get messed up by our macro.  Our\n+   macros should all be consistent with the system versions, except\n+   for the \"fast\" types and macros, which we recommend against using\n+   in public interfaces due to compiler differences.  *\/\n+\n+#if @HAVE_STDINT_H@\n+# if defined __sgi && ! defined __c99\n+   \/* Bypass IRIX's <stdint.h> if in C89 mode, since it merely annoys users\n+      with \"This header file is to be used only for c99 mode compilations\"\n+      diagnostics.  *\/\n+#  define __STDINT_H__\n+# endif\n+\n+  \/* Some pre-C++11 <stdint.h> implementations need this.  *\/\n+# ifdef __cplusplus\n+#  ifndef __STDC_CONSTANT_MACROS\n+#   define __STDC_CONSTANT_MACROS 1\n+#  endif\n+#  ifndef __STDC_LIMIT_MACROS\n+#   define __STDC_LIMIT_MACROS 1\n+#  endif\n+# endif\n+\n+  \/* Other systems may have an incomplete or buggy <stdint.h>.\n+     Include it before <inttypes.h>, since any \"#include <stdint.h>\"\n+     in <inttypes.h> would reinclude us, skipping our contents because\n+     _@GUARD_PREFIX@_STDINT_H is defined.\n+     The include_next requires a split double-inclusion guard.  *\/\n+# @INCLUDE_NEXT@ @NEXT_STDINT_H@\n+#endif\n+\n+#if ! defined _@GUARD_PREFIX@_STDINT_H && ! defined _GL_JUST_INCLUDE_SYSTEM_STDINT_H\n+#define _@GUARD_PREFIX@_STDINT_H\n+\n+\/* <sys\/types.h> defines some of the stdint.h types as well, on glibc,\n+   IRIX 6.5, and OpenBSD 3.8 (via <machine\/types.h>).\n+   AIX 5.2 <sys\/types.h> isn't needed and causes troubles.\n+   Mac OS X 10.4.6 <sys\/types.h> includes <stdint.h> (which is us), but\n+   relies on the system <stdint.h> definitions, so include\n+   <sys\/types.h> after @NEXT_STDINT_H@.  *\/\n+#if @HAVE_SYS_TYPES_H@ && ! defined _AIX\n+# include <sys\/types.h>\n+#endif\n+\n+\/* Get SCHAR_MIN, SCHAR_MAX, UCHAR_MAX, INT_MIN, INT_MAX,\n+   LONG_MIN, LONG_MAX, ULONG_MAX.  *\/\n+#include <limits.h>\n+\n+#if @HAVE_INTTYPES_H@\n+  \/* In OpenBSD 3.8, <inttypes.h> includes <machine\/types.h>, which defines\n+     int{8,16,32,64}_t, uint{8,16,32,64}_t and __BIT_TYPES_DEFINED__.\n+     <inttypes.h> also defines intptr_t and uintptr_t.  *\/\n+# include <inttypes.h>\n+#elif @HAVE_SYS_INTTYPES_H@\n+  \/* Solaris 7 <sys\/inttypes.h> has the types except the *_fast*_t types, and\n+     the macros except for *_FAST*_*, INTPTR_MIN, PTRDIFF_MIN, PTRDIFF_MAX.  *\/\n+# include <sys\/inttypes.h>\n+#endif\n+\n+#if @HAVE_SYS_BITYPES_H@ && ! defined __BIT_TYPES_DEFINED__\n+  \/* Linux libc4 >= 4.6.7 and libc5 have a <sys\/bitypes.h> that defines\n+     int{8,16,32,64}_t and __BIT_TYPES_DEFINED__.  In libc5 >= 5.2.2 it is\n+     included by <sys\/types.h>.  *\/\n+# include <sys\/bitypes.h>\n+#endif\n+\n+#undef _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H\n+\n+\/* Minimum and maximum values for an integer type under the usual assumption.\n+   Return an unspecified value if BITS == 0, adding a check to pacify\n+   picky compilers.  *\/\n+\n+#define _STDINT_MIN(signed, bits, zero) \\\n+  ((signed) ? (- ((zero) + 1) << ((bits) ? (bits) - 1 : 0)) : (zero))\n+\n+#define _STDINT_MAX(signed, bits, zero) \\\n+  ((signed) \\\n+   ? ~ _STDINT_MIN (signed, bits, zero) \\\n+   : \/* The expression for the unsigned case.  The subtraction of (signed) \\\n+        is a nop in the unsigned case and avoids \"signed integer overflow\" \\\n+        warnings in the signed case.  *\/ \\\n+     ((((zero) + 1) << ((bits) ? (bits) - 1 - (signed) : 0)) - 1) * 2 + 1)\n+\n+#if !GNULIB_defined_stdint_types\n+\n+\/* 7.18.1.1. Exact-width integer types *\/\n+\n+\/* Here we assume a standard architecture where the hardware integer\n+   types have 8, 16, 32, optionally 64 bits.  *\/\n+\n+#undef int8_t\n+#undef uint8_t\n+typedef signed char gl_int8_t;\n+typedef unsigned char gl_uint8_t;\n+#define int8_t gl_int8_t\n+#define uint8_t gl_uint8_t\n+\n+#undef int16_t\n+#undef uint16_t\n+typedef short int gl_int16_t;\n+typedef unsigned short int gl_uint16_t;\n+#define int16_t gl_int16_t\n+#define uint16_t gl_uint16_t\n+\n+#undef int32_t\n+#undef uint32_t\n+typedef int gl_int32_t;\n+typedef unsigned int gl_uint32_t;\n+#define int32_t gl_int32_t\n+#define uint32_t gl_uint32_t\n+\n+\/* If the system defines INT64_MAX, assume int64_t works.  That way,\n+   if the underlying platform defines int64_t to be a 64-bit long long\n+   int, the code below won't mistakenly define it to be a 64-bit long\n+   int, which would mess up C++ name mangling.  We must use #ifdef\n+   rather than #if, to avoid an error with HP-UX 10.20 cc.  *\/\n+\n+#ifdef INT64_MAX\n+# define GL_INT64_T\n+#else\n+\/* Do not undefine int64_t if gnulib is not being used with 64-bit\n+   types, since otherwise it breaks platforms like Tandem\/NSK.  *\/\n+# if LONG_MAX >> 31 >> 31 == 1\n+#  undef int64_t\n+typedef long int gl_int64_t;\n+#  define int64_t gl_int64_t\n+#  define GL_INT64_T\n+# elif defined _MSC_VER\n+#  undef int64_t\n+typedef __int64 gl_int64_t;\n+#  define int64_t gl_int64_t\n+#  define GL_INT64_T\n+# elif @HAVE_LONG_LONG_INT@\n+#  undef int64_t\n+typedef long long int gl_int64_t;\n+#  define int64_t gl_int64_t\n+#  define GL_INT64_T\n+# endif\n+#endif\n+\n+#ifdef UINT64_MAX\n+# define GL_UINT64_T\n+#else\n+# if ULONG_MAX >> 31 >> 31 >> 1 == 1\n+#  undef uint64_t\n+typedef unsigned long int gl_uint64_t;\n+#  define uint64_t gl_uint64_t\n+#  define GL_UINT64_T\n+# elif defined _MSC_VER\n+#  undef uint64_t\n+typedef unsigned __int64 gl_uint64_t;\n+#  define uint64_t gl_uint64_t\n+#  define GL_UINT64_T\n+# elif @HAVE_UNSIGNED_LONG_LONG_INT@\n+#  undef uint64_t\n+typedef unsigned long long int gl_uint64_t;\n+#  define uint64_t gl_uint64_t\n+#  define GL_UINT64_T\n+# endif\n+#endif\n+\n+\/* Avoid collision with Solaris 2.5.1 <pthread.h> etc.  *\/\n+#define _UINT8_T\n+#define _UINT32_T\n+#define _UINT64_T\n+\n+\n+\/* 7.18.1.2. Minimum-width integer types *\/\n+\n+\/* Here we assume a standard architecture where the hardware integer\n+   types have 8, 16, 32, optionally 64 bits. Therefore the leastN_t types\n+   are the same as the corresponding N_t types.  *\/\n+\n+#undef int_least8_t\n+#undef uint_least8_t\n+#undef int_least16_t\n+#undef uint_least16_t\n+#undef int_least32_t\n+#undef uint_least32_t\n+#undef int_least64_t\n+#undef uint_least64_t\n+#define int_least8_t int8_t\n+#define uint_least8_t uint8_t\n+#define int_least16_t int16_t\n+#define uint_least16_t uint16_t\n+#define int_least32_t int32_t\n+#define uint_least32_t uint32_t\n+#ifdef GL_INT64_T\n+# define int_least64_t int64_t\n+#endif\n+#ifdef GL_UINT64_T\n+# define uint_least64_t uint64_t\n+#endif\n+\n+\/* 7.18.1.3. Fastest minimum-width integer types *\/\n+\n+\/* Note: Other <stdint.h> substitutes may define these types differently.\n+   It is not recommended to use these types in public header files. *\/\n+\n+\/* Here we assume a standard architecture where the hardware integer\n+   types have 8, 16, 32, optionally 64 bits. Therefore the fastN_t types\n+   are taken from the same list of types.  The following code normally\n+   uses types consistent with glibc, as that lessens the chance of\n+   incompatibility with older GNU hosts.  *\/\n+\n+#undef int_fast8_t\n+#undef uint_fast8_t\n+#undef int_fast16_t\n+#undef uint_fast16_t\n+#undef int_fast32_t\n+#undef uint_fast32_t\n+#undef int_fast64_t\n+#undef uint_fast64_t\n+typedef signed char gl_int_fast8_t;\n+typedef unsigned char gl_uint_fast8_t;\n+\n+#ifdef __sun\n+\/* Define types compatible with SunOS 5.10, so that code compiled under\n+   earlier SunOS versions works with code compiled under SunOS 5.10.  *\/\n+typedef int gl_int_fast32_t;\n+typedef unsigned int gl_uint_fast32_t;\n+#else\n+typedef long int gl_int_fast32_t;\n+typedef unsigned long int gl_uint_fast32_t;\n+#endif\n+typedef gl_int_fast32_t gl_int_fast16_t;\n+typedef gl_uint_fast32_t gl_uint_fast16_t;\n+\n+#define int_fast8_t gl_int_fast8_t\n+#define uint_fast8_t gl_uint_fast8_t\n+#define int_fast16_t gl_int_fast16_t\n+#define uint_fast16_t gl_uint_fast16_t\n+#define int_fast32_t gl_int_fast32_t\n+#define uint_fast32_t gl_uint_fast32_t\n+#ifdef GL_INT64_T\n+# define int_fast64_t int64_t\n+#endif\n+#ifdef GL_UINT64_T\n+# define uint_fast64_t uint64_t\n+#endif\n+\n+\/* 7.18.1.4. Integer types capable of holding object pointers *\/\n+\n+#undef intptr_t\n+#undef uintptr_t\n+typedef long int gl_intptr_t;\n+typedef unsigned long int gl_uintptr_t;\n+#define intptr_t gl_intptr_t\n+#define uintptr_t gl_uintptr_t\n+\n+\/* 7.18.1.5. Greatest-width integer types *\/\n+\n+\/* Note: These types are compiler dependent. It may be unwise to use them in\n+   public header files. *\/\n+\n+\/* If the system defines INTMAX_MAX, assume that intmax_t works, and\n+   similarly for UINTMAX_MAX and uintmax_t.  This avoids problems with\n+   assuming one type where another is used by the system.  *\/\n+\n+#ifndef INTMAX_MAX\n+# undef INTMAX_C\n+# undef intmax_t\n+# if @HAVE_LONG_LONG_INT@ && LONG_MAX >> 30 == 1\n+typedef long long int gl_intmax_t;\n+#  define intmax_t gl_intmax_t\n+# elif defined GL_INT64_T\n+#  define intmax_t int64_t\n+# else\n+typedef long int gl_intmax_t;\n+#  define intmax_t gl_intmax_t\n+# endif\n+#endif\n+\n+#ifndef UINTMAX_MAX\n+# undef UINTMAX_C\n+# undef uintmax_t\n+# if @HAVE_UNSIGNED_LONG_LONG_INT@ && ULONG_MAX >> 31 == 1\n+typedef unsigned long long int gl_uintmax_t;\n+#  define uintmax_t gl_uintmax_t\n+# elif defined GL_UINT64_T\n+#  define uintmax_t uint64_t\n+# else\n+typedef unsigned long int gl_uintmax_t;\n+#  define uintmax_t gl_uintmax_t\n+# endif\n+#endif\n+\n+\/* Verify that intmax_t and uintmax_t have the same size.  Too much code\n+   breaks if this is not the case.  If this check fails, the reason is likely\n+   to be found in the autoconf macros.  *\/\n+typedef int _verify_intmax_size[sizeof (intmax_t) == sizeof (uintmax_t)\n+                                ? 1 : -1];\n+\n+#define GNULIB_defined_stdint_types 1\n+#endif \/* !GNULIB_defined_stdint_types *\/\n+\n+\/* 7.18.2. Limits of specified-width integer types *\/\n+\n+\/* 7.18.2.1. Limits of exact-width integer types *\/\n+\n+\/* Here we assume a standard architecture where the hardware integer\n+   types have 8, 16, 32, optionally 64 bits.  *\/\n+\n+#undef INT8_MIN\n+#undef INT8_MAX\n+#undef UINT8_MAX\n+#define INT8_MIN  (~ INT8_MAX)\n+#define INT8_MAX  127\n+#define UINT8_MAX  255\n+\n+#undef INT16_MIN\n+#undef INT16_MAX\n+#undef UINT16_MAX\n+#define INT16_MIN  (~ INT16_MAX)\n+#define INT16_MAX  32767\n+#define UINT16_MAX  65535\n+\n+#undef INT32_MIN\n+#undef INT32_MAX\n+#undef UINT32_MAX\n+#define INT32_MIN  (~ INT32_MAX)\n+#define INT32_MAX  2147483647\n+#define UINT32_MAX  4294967295U\n+\n+#if defined GL_INT64_T && ! defined INT64_MAX\n+\/* Prefer (- INTMAX_C (1) << 63) over (~ INT64_MAX) because SunPRO C 5.0\n+   evaluates the latter incorrectly in preprocessor expressions.  *\/\n+# define INT64_MIN  (- INTMAX_C (1) << 63)\n+# define INT64_MAX  INTMAX_C (9223372036854775807)\n+#endif\n+\n+#if defined GL_UINT64_T && ! defined UINT64_MAX\n+# define UINT64_MAX  UINTMAX_C (18446744073709551615)\n+#endif\n+\n+\/* 7.18.2.2. Limits of minimum-width integer types *\/\n+\n+\/* Here we assume a standard architecture where the hardware integer\n+   types have 8, 16, 32, optionally 64 bits. Therefore the leastN_t types\n+   are the same as the corresponding N_t types.  *\/\n+\n+#undef INT_LEAST8_MIN\n+#undef INT_LEAST8_MAX\n+#undef UINT_LEAST8_MAX\n+#define INT_LEAST8_MIN  INT8_MIN\n+#define INT_LEAST8_MAX  INT8_MAX\n+#define UINT_LEAST8_MAX  UINT8_MAX\n+\n+#undef INT_LEAST16_MIN\n+#undef INT_LEAST16_MAX\n+#undef UINT_LEAST16_MAX\n+#define INT_LEAST16_MIN  INT16_MIN\n+#define INT_LEAST16_MAX  INT16_MAX\n+#define UINT_LEAST16_MAX  UINT16_MAX\n+\n+#undef INT_LEAST32_MIN\n+#undef INT_LEAST32_MAX\n+#undef UINT_LEAST32_MAX\n+#define INT_LEAST32_MIN  INT32_MIN\n+#define INT_LEAST32_MAX  INT32_MAX\n+#define UINT_LEAST32_MAX  UINT32_MAX\n+\n+#undef INT_LEAST64_MIN\n+#undef INT_LEAST64_MAX\n+#ifdef GL_INT64_T\n+# define INT_LEAST64_MIN  INT64_MIN\n+# define INT_LEAST64_MAX  INT64_MAX\n+#endif\n+\n+#undef UINT_LEAST64_MAX\n+#ifdef GL_UINT64_T\n+# define UINT_LEAST64_MAX  UINT64_MAX\n+#endif\n+\n+\/* 7.18.2.3. Limits of fastest minimum-width integer types *\/\n+\n+\/* Here we assume a standard architecture where the hardware integer\n+   types have 8, 16, 32, optionally 64 bits. Therefore the fastN_t types\n+   are taken from the same list of types.  *\/\n+\n+#undef INT_FAST8_MIN\n+#undef INT_FAST8_MAX\n+#undef UINT_FAST8_MAX\n+#define INT_FAST8_MIN  SCHAR_MIN\n+#define INT_FAST8_MAX  SCHAR_MAX\n+#define UINT_FAST8_MAX  UCHAR_MAX\n+\n+#undef INT_FAST16_MIN\n+#undef INT_FAST16_MAX\n+#undef UINT_FAST16_MAX\n+#define INT_FAST16_MIN  INT_FAST32_MIN\n+#define INT_FAST16_MAX  INT_FAST32_MAX\n+#define UINT_FAST16_MAX  UINT_FAST32_MAX\n+\n+#undef INT_FAST32_MIN\n+#undef INT_FAST32_MAX\n+#undef UINT_FAST32_MAX\n+#ifdef __sun\n+# define INT_FAST32_MIN  INT_MIN\n+# define INT_FAST32_MAX  INT_MAX\n+# define UINT_FAST32_MAX  UINT_MAX\n+#else\n+# define INT_FAST32_MIN  LONG_MIN\n+# define INT_FAST32_MAX  LONG_MAX\n+# define UINT_FAST32_MAX  ULONG_MAX\n+#endif\n+\n+#undef INT_FAST64_MIN\n+#undef INT_FAST64_MAX\n+#ifdef GL_INT64_T\n+# define INT_FAST64_MIN  INT64_MIN\n+# define INT_FAST64_MAX  INT64_MAX\n+#endif\n+\n+#undef UINT_FAST64_MAX\n+#ifdef GL_UINT64_T\n+# define UINT_FAST64_MAX  UINT64_MAX\n+#endif\n+\n+\/* 7.18.2.4. Limits of integer types capable of holding object pointers *\/\n+\n+#undef INTPTR_MIN\n+#undef INTPTR_MAX\n+#undef UINTPTR_MAX\n+#define INTPTR_MIN  LONG_MIN\n+#define INTPTR_MAX  LONG_MAX\n+#define UINTPTR_MAX  ULONG_MAX\n+\n+\/* 7.18.2.5. Limits of greatest-width integer types *\/\n+\n+#ifndef INTMAX_MAX\n+# undef INTMAX_MIN\n+# ifdef INT64_MAX\n+#  define INTMAX_MIN  INT64_MIN\n+#  define INTMAX_MAX  INT64_MAX\n+# else\n+#  define INTMAX_MIN  INT32_MIN\n+#  define INTMAX_MAX  INT32_MAX\n+# endif\n+#endif\n+\n+#ifndef UINTMAX_MAX\n+# ifdef UINT64_MAX\n+#  define UINTMAX_MAX  UINT64_MAX\n+# else\n+#  define UINTMAX_MAX  UINT32_MAX\n+# endif\n+#endif\n+\n+\/* 7.18.3. Limits of other integer types *\/\n+\n+\/* ptrdiff_t limits *\/\n+#undef PTRDIFF_MIN\n+#undef PTRDIFF_MAX\n+#if @APPLE_UNIVERSAL_BUILD@\n+# ifdef _LP64\n+#  define PTRDIFF_MIN  _STDINT_MIN (1, 64, 0l)\n+#  define PTRDIFF_MAX  _STDINT_MAX (1, 64, 0l)\n+# else\n+#  define PTRDIFF_MIN  _STDINT_MIN (1, 32, 0)\n+#  define PTRDIFF_MAX  _STDINT_MAX (1, 32, 0)\n+# endif\n+#else\n+# define PTRDIFF_MIN  \\\n+    _STDINT_MIN (1, @BITSIZEOF_PTRDIFF_T@, 0@PTRDIFF_T_SUFFIX@)\n+# define PTRDIFF_MAX  \\\n+    _STDINT_MAX (1, @BITSIZEOF_PTRDIFF_T@, 0@PTRDIFF_T_SUFFIX@)\n+#endif\n+\n+\/* sig_atomic_t limits *\/\n+#undef SIG_ATOMIC_MIN\n+#undef SIG_ATOMIC_MAX\n+#define SIG_ATOMIC_MIN  \\\n+   _STDINT_MIN (@HAVE_SIGNED_SIG_ATOMIC_T@, @BITSIZEOF_SIG_ATOMIC_T@, \\\n+                0@SIG_ATOMIC_T_SUFFIX@)\n+#define SIG_ATOMIC_MAX  \\\n+   _STDINT_MAX (@HAVE_SIGNED_SIG_ATOMIC_T@, @BITSIZEOF_SIG_ATOMIC_T@, \\\n+                0@SIG_ATOMIC_T_SUFFIX@)\n+\n+\n+\/* size_t limit *\/\n+#undef SIZE_MAX\n+#if @APPLE_UNIVERSAL_BUILD@\n+# ifdef _LP64\n+#  define SIZE_MAX  _STDINT_MAX (0, 64, 0ul)\n+# else\n+#  define SIZE_MAX  _STDINT_MAX (0, 32, 0ul)\n+# endif\n+#else\n+# define SIZE_MAX  _STDINT_MAX (0, @BITSIZEOF_SIZE_T@, 0@SIZE_T_SUFFIX@)\n+#endif\n+\n+\/* wchar_t limits *\/\n+\/* Get WCHAR_MIN, WCHAR_MAX.\n+   This include is not on the top, above, because on OSF\/1 4.0 we have a\n+   sequence of nested includes\n+   <wchar.h> -> <stdio.h> -> <getopt.h> -> <stdlib.h>, and the latter includes\n+   <stdint.h> and assumes its types are already defined.  *\/\n+#if @HAVE_WCHAR_H@ && ! (defined WCHAR_MIN && defined WCHAR_MAX)\n+  \/* BSD\/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be\n+     included before <wchar.h>.  *\/\n+# include <stddef.h>\n+# include <stdio.h>\n+# include <time.h>\n+# define _GL_JUST_INCLUDE_SYSTEM_WCHAR_H\n+# include <wchar.h>\n+# undef _GL_JUST_INCLUDE_SYSTEM_WCHAR_H\n+#endif\n+#undef WCHAR_MIN\n+#undef WCHAR_MAX\n+#define WCHAR_MIN  \\\n+   _STDINT_MIN (@HAVE_SIGNED_WCHAR_T@, @BITSIZEOF_WCHAR_T@, 0@WCHAR_T_SUFFIX@)\n+#define WCHAR_MAX  \\\n+   _STDINT_MAX (@HAVE_SIGNED_WCHAR_T@, @BITSIZEOF_WCHAR_T@, 0@WCHAR_T_SUFFIX@)\n+\n+\/* wint_t limits *\/\n+#undef WINT_MIN\n+#undef WINT_MAX\n+#define WINT_MIN  \\\n+   _STDINT_MIN (@HAVE_SIGNED_WINT_T@, @BITSIZEOF_WINT_T@, 0@WINT_T_SUFFIX@)\n+#define WINT_MAX  \\\n+   _STDINT_MAX (@HAVE_SIGNED_WINT_T@, @BITSIZEOF_WINT_T@, 0@WINT_T_SUFFIX@)\n+\n+\/* 7.18.4. Macros for integer constants *\/\n+\n+\/* 7.18.4.1. Macros for minimum-width integer constants *\/\n+\/* According to ISO C 99 Technical Corrigendum 1 *\/\n+\n+\/* Here we assume a standard architecture where the hardware integer\n+   types have 8, 16, 32, optionally 64 bits, and int is 32 bits.  *\/\n+\n+#undef INT8_C\n+#undef UINT8_C\n+#define INT8_C(x) x\n+#define UINT8_C(x) x\n+\n+#undef INT16_C\n+#undef UINT16_C\n+#define INT16_C(x) x\n+#define UINT16_C(x) x\n+\n+#undef INT32_C\n+#undef UINT32_C\n+#define INT32_C(x) x\n+#define UINT32_C(x) x ## U\n+\n+#undef INT64_C\n+#undef UINT64_C\n+#if LONG_MAX >> 31 >> 31 == 1\n+# define INT64_C(x) x##L\n+#elif defined _MSC_VER\n+# define INT64_C(x) x##i64\n+#elif @HAVE_LONG_LONG_INT@\n+# define INT64_C(x) x##LL\n+#endif\n+#if ULONG_MAX >> 31 >> 31 >> 1 == 1\n+# define UINT64_C(x) x##UL\n+#elif defined _MSC_VER\n+# define UINT64_C(x) x##ui64\n+#elif @HAVE_UNSIGNED_LONG_LONG_INT@\n+# define UINT64_C(x) x##ULL\n+#endif\n+\n+\/* 7.18.4.2. Macros for greatest-width integer constants *\/\n+\n+#ifndef INTMAX_C\n+# if @HAVE_LONG_LONG_INT@ && LONG_MAX >> 30 == 1\n+#  define INTMAX_C(x)   x##LL\n+# elif defined GL_INT64_T\n+#  define INTMAX_C(x)   INT64_C(x)\n+# else\n+#  define INTMAX_C(x)   x##L\n+# endif\n+#endif\n+\n+#ifndef UINTMAX_C\n+# if @HAVE_UNSIGNED_LONG_LONG_INT@ && ULONG_MAX >> 31 == 1\n+#  define UINTMAX_C(x)  x##ULL\n+# elif defined GL_UINT64_T\n+#  define UINTMAX_C(x)  UINT64_C(x)\n+# else\n+#  define UINTMAX_C(x)  x##UL\n+# endif\n+#endif\n+\n+#endif \/* _@GUARD_PREFIX@_STDINT_H *\/\n+#endif \/* !(defined __ANDROID__ && ...) *\/\n+#endif \/* !defined _@GUARD_PREFIX@_STDINT_H && !defined _GL_JUST_INCLUDE_SYSTEM_STDINT_H *\/\ndiff --git a\/gl\/stdlib.in.h b\/gl\/stdlib.in.h\nnew file mode 100644\nindex 0000000..428a119\n--- \/dev\/null\n+++ b\/gl\/stdlib.in.h\n@@ -0,0 +1,977 @@\n+\/* A GNU-like <stdlib.h>.\n+\n+   Copyright (C) 1995, 2001-2004, 2006-2015 Free Software Foundation, Inc.\n+\n+   This program is free software: you can redistribute it and\/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.  *\/\n+\n+#if __GNUC__ >= 3\n+@PRAGMA_SYSTEM_HEADER@\n+#endif\n+@PRAGMA_COLUMNS@\n+\n+#if defined __need_system_stdlib_h || defined __need_malloc_and_calloc\n+\/* Special invocation conventions inside some gnulib header files,\n+   and inside some glibc header files, respectively.  *\/\n+\n+#@INCLUDE_NEXT@ @NEXT_STDLIB_H@\n+\n+#else\n+\/* Normal invocation convention.  *\/\n+\n+#ifndef _@GUARD_PREFIX@_STDLIB_H\n+\n+\/* The include_next requires a split double-inclusion guard.  *\/\n+#@INCLUDE_NEXT@ @NEXT_STDLIB_H@\n+\n+#ifndef _@GUARD_PREFIX@_STDLIB_H\n+#define _@GUARD_PREFIX@_STDLIB_H\n+\n+\/* NetBSD 5.0 mis-defines NULL.  *\/\n+#include <stddef.h>\n+\n+\/* MirBSD 10 defines WEXITSTATUS in <sys\/wait.h>, not in <stdlib.h>.  *\/\n+#if @GNULIB_SYSTEM_POSIX@ && !defined WEXITSTATUS\n+# include <sys\/wait.h>\n+#endif\n+\n+\/* Solaris declares getloadavg() in <sys\/loadavg.h>.  *\/\n+#if (@GNULIB_GETLOADAVG@ || defined GNULIB_POSIXCHECK) && @HAVE_SYS_LOADAVG_H@\n+# include <sys\/loadavg.h>\n+#endif\n+\n+\/* Native Windows platforms declare mktemp() in <io.h>.  *\/\n+#if 0 && ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)\n+# include <io.h>\n+#endif\n+\n+#if @GNULIB_RANDOM_R@\n+\n+\/* OSF\/1 5.1 declares 'struct random_data' in <random.h>, which is included\n+   from <stdlib.h> if _REENTRANT is defined.  Include it whenever we need\n+   'struct random_data'.  *\/\n+# if @HAVE_RANDOM_H@\n+#  include <random.h>\n+# endif\n+\n+# if !@HAVE_STRUCT_RANDOM_DATA@ || @REPLACE_RANDOM_R@ || !@HAVE_RANDOM_R@\n+#  include <stdint.h>\n+# endif\n+\n+# if !@HAVE_STRUCT_RANDOM_DATA@\n+\/* Define 'struct random_data'.\n+   But allow multiple gnulib generated <stdlib.h> replacements to coexist.  *\/\n+#  if !GNULIB_defined_struct_random_data\n+struct random_data\n+{\n+  int32_t *fptr;                \/* Front pointer.  *\/\n+  int32_t *rptr;                \/* Rear pointer.  *\/\n+  int32_t *state;               \/* Array of state values.  *\/\n+  int rand_type;                \/* Type of random number generator.  *\/\n+  int rand_deg;                 \/* Degree of random number generator.  *\/\n+  int rand_sep;                 \/* Distance between front and rear.  *\/\n+  int32_t *end_ptr;             \/* Pointer behind state table.  *\/\n+};\n+#   define GNULIB_defined_struct_random_data 1\n+#  endif\n+# endif\n+#endif\n+\n+#if (@GNULIB_MKSTEMP@ || @GNULIB_MKSTEMPS@ || @GNULIB_GETSUBOPT@ || defined GNULIB_POSIXCHECK) && ! defined __GLIBC__ && !((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)\n+\/* On Mac OS X 10.3, only <unistd.h> declares mkstemp.  *\/\n+\/* On Mac OS X 10.5, only <unistd.h> declares mkstemps.  *\/\n+\/* On Cygwin 1.7.1, only <unistd.h> declares getsubopt.  *\/\n+\/* But avoid namespace pollution on glibc systems and native Windows.  *\/\n+# include <unistd.h>\n+#endif\n+\n+\/* The __attribute__ feature is available in gcc versions 2.5 and later.\n+   The attribute __pure__ was added in gcc 2.96.  *\/\n+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)\n+# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))\n+#else\n+# define _GL_ATTRIBUTE_PURE \/* empty *\/\n+#endif\n+\n+\/* The definition of _Noreturn is copied here.  *\/\n+\n+\/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  *\/\n+\n+\/* The definition of _GL_ARG_NONNULL is copied here.  *\/\n+\n+\/* The definition of _GL_WARN_ON_USE is copied here.  *\/\n+\n+\n+\/* Some systems do not define EXIT_*, despite otherwise supporting C89.  *\/\n+#ifndef EXIT_SUCCESS\n+# define EXIT_SUCCESS 0\n+#endif\n+\/* Tandem\/NSK and other platforms that define EXIT_FAILURE as -1 interfere\n+   with proper operation of xargs.  *\/\n+#ifndef EXIT_FAILURE\n+# define EXIT_FAILURE 1\n+#elif EXIT_FAILURE != 1\n+# undef EXIT_FAILURE\n+# define EXIT_FAILURE 1\n+#endif\n+\n+\n+#if @GNULIB__EXIT@\n+\/* Terminate the current process with the given return code, without running\n+   the 'atexit' handlers.  *\/\n+# if !@HAVE__EXIT@\n+_GL_FUNCDECL_SYS (_Exit, _Noreturn void, (int status));\n+# endif\n+_GL_CXXALIAS_SYS (_Exit, void, (int status));\n+_GL_CXXALIASWARN (_Exit);\n+#elif defined GNULIB_POSIXCHECK\n+# undef _Exit\n+# if HAVE_RAW_DECL__EXIT\n+_GL_WARN_ON_USE (_Exit, \"_Exit is unportable - \"\n+                 \"use gnulib module _Exit for portability\");\n+# endif\n+#endif\n+\n+\n+#if @GNULIB_ATOLL@\n+\/* Parse a signed decimal integer.\n+   Returns the value of the integer.  Errors are not detected.  *\/\n+# if !@HAVE_ATOLL@\n+_GL_FUNCDECL_SYS (atoll, long long, (const char *string)\n+                                    _GL_ATTRIBUTE_PURE\n+                                    _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (atoll, long long, (const char *string));\n+_GL_CXXALIASWARN (atoll);\n+#elif defined GNULIB_POSIXCHECK\n+# undef atoll\n+# if HAVE_RAW_DECL_ATOLL\n+_GL_WARN_ON_USE (atoll, \"atoll is unportable - \"\n+                 \"use gnulib module atoll for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_CALLOC_POSIX@\n+# if @REPLACE_CALLOC@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef calloc\n+#   define calloc rpl_calloc\n+#  endif\n+_GL_FUNCDECL_RPL (calloc, void *, (size_t nmemb, size_t size));\n+_GL_CXXALIAS_RPL (calloc, void *, (size_t nmemb, size_t size));\n+# else\n+_GL_CXXALIAS_SYS (calloc, void *, (size_t nmemb, size_t size));\n+# endif\n+_GL_CXXALIASWARN (calloc);\n+#elif defined GNULIB_POSIXCHECK\n+# undef calloc\n+\/* Assume calloc is always declared.  *\/\n+_GL_WARN_ON_USE (calloc, \"calloc is not POSIX compliant everywhere - \"\n+                 \"use gnulib module calloc-posix for portability\");\n+#endif\n+\n+#if @GNULIB_CANONICALIZE_FILE_NAME@\n+# if @REPLACE_CANONICALIZE_FILE_NAME@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   define canonicalize_file_name rpl_canonicalize_file_name\n+#  endif\n+_GL_FUNCDECL_RPL (canonicalize_file_name, char *, (const char *name)\n+                                                  _GL_ARG_NONNULL ((1)));\n+_GL_CXXALIAS_RPL (canonicalize_file_name, char *, (const char *name));\n+# else\n+#  if !@HAVE_CANONICALIZE_FILE_NAME@\n+_GL_FUNCDECL_SYS (canonicalize_file_name, char *, (const char *name)\n+                                                  _GL_ARG_NONNULL ((1)));\n+#  endif\n+_GL_CXXALIAS_SYS (canonicalize_file_name, char *, (const char *name));\n+# endif\n+_GL_CXXALIASWARN (canonicalize_file_name);\n+#elif defined GNULIB_POSIXCHECK\n+# undef canonicalize_file_name\n+# if HAVE_RAW_DECL_CANONICALIZE_FILE_NAME\n+_GL_WARN_ON_USE (canonicalize_file_name,\n+                 \"canonicalize_file_name is unportable - \"\n+                 \"use gnulib module canonicalize-lgpl for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_GETLOADAVG@\n+\/* Store max(NELEM,3) load average numbers in LOADAVG[].\n+   The three numbers are the load average of the last 1 minute, the last 5\n+   minutes, and the last 15 minutes, respectively.\n+   LOADAVG is an array of NELEM numbers.  *\/\n+# if !@HAVE_DECL_GETLOADAVG@\n+_GL_FUNCDECL_SYS (getloadavg, int, (double loadavg[], int nelem)\n+                                   _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (getloadavg, int, (double loadavg[], int nelem));\n+_GL_CXXALIASWARN (getloadavg);\n+#elif defined GNULIB_POSIXCHECK\n+# undef getloadavg\n+# if HAVE_RAW_DECL_GETLOADAVG\n+_GL_WARN_ON_USE (getloadavg, \"getloadavg is not portable - \"\n+                 \"use gnulib module getloadavg for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_GETSUBOPT@\n+\/* Assuming *OPTIONP is a comma separated list of elements of the form\n+   \"token\" or \"token=value\", getsubopt parses the first of these elements.\n+   If the first element refers to a \"token\" that is member of the given\n+   NULL-terminated array of tokens:\n+     - It replaces the comma with a NUL byte, updates *OPTIONP to point past\n+       the first option and the comma, sets *VALUEP to the value of the\n+       element (or NULL if it doesn't contain an \"=\" sign),\n+     - It returns the index of the \"token\" in the given array of tokens.\n+   Otherwise it returns -1, and *OPTIONP and *VALUEP are undefined.\n+   For more details see the POSIX:2001 specification.\n+   http:\/\/www.opengroup.org\/susv3xsh\/getsubopt.html *\/\n+# if !@HAVE_GETSUBOPT@\n+_GL_FUNCDECL_SYS (getsubopt, int,\n+                  (char **optionp, char *const *tokens, char **valuep)\n+                  _GL_ARG_NONNULL ((1, 2, 3)));\n+# endif\n+_GL_CXXALIAS_SYS (getsubopt, int,\n+                  (char **optionp, char *const *tokens, char **valuep));\n+_GL_CXXALIASWARN (getsubopt);\n+#elif defined GNULIB_POSIXCHECK\n+# undef getsubopt\n+# if HAVE_RAW_DECL_GETSUBOPT\n+_GL_WARN_ON_USE (getsubopt, \"getsubopt is unportable - \"\n+                 \"use gnulib module getsubopt for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_GRANTPT@\n+\/* Change the ownership and access permission of the slave side of the\n+   pseudo-terminal whose master side is specified by FD.  *\/\n+# if !@HAVE_GRANTPT@\n+_GL_FUNCDECL_SYS (grantpt, int, (int fd));\n+# endif\n+_GL_CXXALIAS_SYS (grantpt, int, (int fd));\n+_GL_CXXALIASWARN (grantpt);\n+#elif defined GNULIB_POSIXCHECK\n+# undef grantpt\n+# if HAVE_RAW_DECL_GRANTPT\n+_GL_WARN_ON_USE (grantpt, \"grantpt is not portable - \"\n+                 \"use gnulib module grantpt for portability\");\n+# endif\n+#endif\n+\n+\/* If _GL_USE_STDLIB_ALLOC is nonzero, the including module does not\n+   rely on GNU or POSIX semantics for malloc and realloc (for example,\n+   by never specifying a zero size), so it does not need malloc or\n+   realloc to be redefined.  *\/\n+#if @GNULIB_MALLOC_POSIX@\n+# if @REPLACE_MALLOC@\n+#  if !((defined __cplusplus && defined GNULIB_NAMESPACE) \\\n+        || _GL_USE_STDLIB_ALLOC)\n+#   undef malloc\n+#   define malloc rpl_malloc\n+#  endif\n+_GL_FUNCDECL_RPL (malloc, void *, (size_t size));\n+_GL_CXXALIAS_RPL (malloc, void *, (size_t size));\n+# else\n+_GL_CXXALIAS_SYS (malloc, void *, (size_t size));\n+# endif\n+_GL_CXXALIASWARN (malloc);\n+#elif defined GNULIB_POSIXCHECK && !_GL_USE_STDLIB_ALLOC\n+# undef malloc\n+\/* Assume malloc is always declared.  *\/\n+_GL_WARN_ON_USE (malloc, \"malloc is not POSIX compliant everywhere - \"\n+                 \"use gnulib module malloc-posix for portability\");\n+#endif\n+\n+\/* Convert a multibyte character to a wide character.  *\/\n+#if @GNULIB_MBTOWC@\n+# if @REPLACE_MBTOWC@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef mbtowc\n+#   define mbtowc rpl_mbtowc\n+#  endif\n+_GL_FUNCDECL_RPL (mbtowc, int, (wchar_t *pwc, const char *s, size_t n));\n+_GL_CXXALIAS_RPL (mbtowc, int, (wchar_t *pwc, const char *s, size_t n));\n+# else\n+_GL_CXXALIAS_SYS (mbtowc, int, (wchar_t *pwc, const char *s, size_t n));\n+# endif\n+_GL_CXXALIASWARN (mbtowc);\n+#endif\n+\n+#if @GNULIB_MKDTEMP@\n+\/* Create a unique temporary directory from TEMPLATE.\n+   The last six characters of TEMPLATE must be \"XXXXXX\";\n+   they are replaced with a string that makes the directory name unique.\n+   Returns TEMPLATE, or a null pointer if it cannot get a unique name.\n+   The directory is created mode 700.  *\/\n+# if !@HAVE_MKDTEMP@\n+_GL_FUNCDECL_SYS (mkdtemp, char *, (char * \/*template*\/) _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (mkdtemp, char *, (char * \/*template*\/));\n+_GL_CXXALIASWARN (mkdtemp);\n+#elif defined GNULIB_POSIXCHECK\n+# undef mkdtemp\n+# if HAVE_RAW_DECL_MKDTEMP\n+_GL_WARN_ON_USE (mkdtemp, \"mkdtemp is unportable - \"\n+                 \"use gnulib module mkdtemp for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_MKOSTEMP@\n+\/* Create a unique temporary file from TEMPLATE.\n+   The last six characters of TEMPLATE must be \"XXXXXX\";\n+   they are replaced with a string that makes the file name unique.\n+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)\n+   and O_TEXT, O_BINARY (defined in \"binary-io.h\").\n+   The file is then created, with the specified flags, ensuring it didn't exist\n+   before.\n+   The file is created read-write (mask at least 0600 & ~umask), but it may be\n+   world-readable and world-writable (mask 0666 & ~umask), depending on the\n+   implementation.\n+   Returns the open file descriptor if successful, otherwise -1 and errno\n+   set.  *\/\n+# if !@HAVE_MKOSTEMP@\n+_GL_FUNCDECL_SYS (mkostemp, int, (char * \/*template*\/, int \/*flags*\/)\n+                                 _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (mkostemp, int, (char * \/*template*\/, int \/*flags*\/));\n+_GL_CXXALIASWARN (mkostemp);\n+#elif defined GNULIB_POSIXCHECK\n+# undef mkostemp\n+# if HAVE_RAW_DECL_MKOSTEMP\n+_GL_WARN_ON_USE (mkostemp, \"mkostemp is unportable - \"\n+                 \"use gnulib module mkostemp for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_MKOSTEMPS@\n+\/* Create a unique temporary file from TEMPLATE.\n+   The last six characters of TEMPLATE before a suffix of length\n+   SUFFIXLEN must be \"XXXXXX\";\n+   they are replaced with a string that makes the file name unique.\n+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)\n+   and O_TEXT, O_BINARY (defined in \"binary-io.h\").\n+   The file is then created, with the specified flags, ensuring it didn't exist\n+   before.\n+   The file is created read-write (mask at least 0600 & ~umask), but it may be\n+   world-readable and world-writable (mask 0666 & ~umask), depending on the\n+   implementation.\n+   Returns the open file descriptor if successful, otherwise -1 and errno\n+   set.  *\/\n+# if !@HAVE_MKOSTEMPS@\n+_GL_FUNCDECL_SYS (mkostemps, int,\n+                  (char * \/*template*\/, int \/*suffixlen*\/, int \/*flags*\/)\n+                  _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (mkostemps, int,\n+                  (char * \/*template*\/, int \/*suffixlen*\/, int \/*flags*\/));\n+_GL_CXXALIASWARN (mkostemps);\n+#elif defined GNULIB_POSIXCHECK\n+# undef mkostemps\n+# if HAVE_RAW_DECL_MKOSTEMPS\n+_GL_WARN_ON_USE (mkostemps, \"mkostemps is unportable - \"\n+                 \"use gnulib module mkostemps for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_MKSTEMP@\n+\/* Create a unique temporary file from TEMPLATE.\n+   The last six characters of TEMPLATE must be \"XXXXXX\";\n+   they are replaced with a string that makes the file name unique.\n+   The file is then created, ensuring it didn't exist before.\n+   The file is created read-write (mask at least 0600 & ~umask), but it may be\n+   world-readable and world-writable (mask 0666 & ~umask), depending on the\n+   implementation.\n+   Returns the open file descriptor if successful, otherwise -1 and errno\n+   set.  *\/\n+# if @REPLACE_MKSTEMP@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   define mkstemp rpl_mkstemp\n+#  endif\n+_GL_FUNCDECL_RPL (mkstemp, int, (char * \/*template*\/) _GL_ARG_NONNULL ((1)));\n+_GL_CXXALIAS_RPL (mkstemp, int, (char * \/*template*\/));\n+# else\n+#  if ! @HAVE_MKSTEMP@\n+_GL_FUNCDECL_SYS (mkstemp, int, (char * \/*template*\/) _GL_ARG_NONNULL ((1)));\n+#  endif\n+_GL_CXXALIAS_SYS (mkstemp, int, (char * \/*template*\/));\n+# endif\n+_GL_CXXALIASWARN (mkstemp);\n+#elif defined GNULIB_POSIXCHECK\n+# undef mkstemp\n+# if HAVE_RAW_DECL_MKSTEMP\n+_GL_WARN_ON_USE (mkstemp, \"mkstemp is unportable - \"\n+                 \"use gnulib module mkstemp for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_MKSTEMPS@\n+\/* Create a unique temporary file from TEMPLATE.\n+   The last six characters of TEMPLATE prior to a suffix of length\n+   SUFFIXLEN must be \"XXXXXX\";\n+   they are replaced with a string that makes the file name unique.\n+   The file is then created, ensuring it didn't exist before.\n+   The file is created read-write (mask at least 0600 & ~umask), but it may be\n+   world-readable and world-writable (mask 0666 & ~umask), depending on the\n+   implementation.\n+   Returns the open file descriptor if successful, otherwise -1 and errno\n+   set.  *\/\n+# if !@HAVE_MKSTEMPS@\n+_GL_FUNCDECL_SYS (mkstemps, int, (char * \/*template*\/, int \/*suffixlen*\/)\n+                                 _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (mkstemps, int, (char * \/*template*\/, int \/*suffixlen*\/));\n+_GL_CXXALIASWARN (mkstemps);\n+#elif defined GNULIB_POSIXCHECK\n+# undef mkstemps\n+# if HAVE_RAW_DECL_MKSTEMPS\n+_GL_WARN_ON_USE (mkstemps, \"mkstemps is unportable - \"\n+                 \"use gnulib module mkstemps for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_POSIX_OPENPT@\n+\/* Return an FD open to the master side of a pseudo-terminal.  Flags should\n+   include O_RDWR, and may also include O_NOCTTY.  *\/\n+# if !@HAVE_POSIX_OPENPT@\n+_GL_FUNCDECL_SYS (posix_openpt, int, (int flags));\n+# endif\n+_GL_CXXALIAS_SYS (posix_openpt, int, (int flags));\n+_GL_CXXALIASWARN (posix_openpt);\n+#elif defined GNULIB_POSIXCHECK\n+# undef posix_openpt\n+# if HAVE_RAW_DECL_POSIX_OPENPT\n+_GL_WARN_ON_USE (posix_openpt, \"posix_openpt is not portable - \"\n+                 \"use gnulib module posix_openpt for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_PTSNAME@\n+\/* Return the pathname of the pseudo-terminal slave associated with\n+   the master FD is open on, or NULL on errors.  *\/\n+# if @REPLACE_PTSNAME@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef ptsname\n+#   define ptsname rpl_ptsname\n+#  endif\n+_GL_FUNCDECL_RPL (ptsname, char *, (int fd));\n+_GL_CXXALIAS_RPL (ptsname, char *, (int fd));\n+# else\n+#  if !@HAVE_PTSNAME@\n+_GL_FUNCDECL_SYS (ptsname, char *, (int fd));\n+#  endif\n+_GL_CXXALIAS_SYS (ptsname, char *, (int fd));\n+# endif\n+_GL_CXXALIASWARN (ptsname);\n+#elif defined GNULIB_POSIXCHECK\n+# undef ptsname\n+# if HAVE_RAW_DECL_PTSNAME\n+_GL_WARN_ON_USE (ptsname, \"ptsname is not portable - \"\n+                 \"use gnulib module ptsname for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_PTSNAME_R@\n+\/* Set the pathname of the pseudo-terminal slave associated with\n+   the master FD is open on and return 0, or set errno and return\n+   non-zero on errors.  *\/\n+# if @REPLACE_PTSNAME_R@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef ptsname_r\n+#   define ptsname_r rpl_ptsname_r\n+#  endif\n+_GL_FUNCDECL_RPL (ptsname_r, int, (int fd, char *buf, size_t len));\n+_GL_CXXALIAS_RPL (ptsname_r, int, (int fd, char *buf, size_t len));\n+# else\n+#  if !@HAVE_PTSNAME_R@\n+_GL_FUNCDECL_SYS (ptsname_r, int, (int fd, char *buf, size_t len));\n+#  endif\n+_GL_CXXALIAS_SYS (ptsname_r, int, (int fd, char *buf, size_t len));\n+# endif\n+_GL_CXXALIASWARN (ptsname_r);\n+#elif defined GNULIB_POSIXCHECK\n+# undef ptsname_r\n+# if HAVE_RAW_DECL_PTSNAME_R\n+_GL_WARN_ON_USE (ptsname_r, \"ptsname_r is not portable - \"\n+                 \"use gnulib module ptsname_r for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_PUTENV@\n+# if @REPLACE_PUTENV@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef putenv\n+#   define putenv rpl_putenv\n+#  endif\n+_GL_FUNCDECL_RPL (putenv, int, (char *string) _GL_ARG_NONNULL ((1)));\n+_GL_CXXALIAS_RPL (putenv, int, (char *string));\n+# else\n+_GL_CXXALIAS_SYS (putenv, int, (char *string));\n+# endif\n+_GL_CXXALIASWARN (putenv);\n+#endif\n+\n+#if @GNULIB_QSORT_R@\n+# if @REPLACE_QSORT_R@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef qsort_r\n+#   define qsort_r rpl_qsort_r\n+#  endif\n+_GL_FUNCDECL_RPL (qsort_r, void, (void *base, size_t nmemb, size_t size,\n+                                  int (*compare) (void const *, void const *,\n+                                                  void *),\n+                                  void *arg) _GL_ARG_NONNULL ((1, 4)));\n+_GL_CXXALIAS_RPL (qsort_r, void, (void *base, size_t nmemb, size_t size,\n+                                  int (*compare) (void const *, void const *,\n+                                                  void *),\n+                                  void *arg));\n+# else\n+_GL_CXXALIAS_SYS (qsort_r, void, (void *base, size_t nmemb, size_t size,\n+                                  int (*compare) (void const *, void const *,\n+                                                  void *),\n+                                  void *arg));\n+# endif\n+_GL_CXXALIASWARN (qsort_r);\n+#endif\n+\n+\n+#if @GNULIB_RANDOM_R@\n+# if !@HAVE_RANDOM_R@\n+#  ifndef RAND_MAX\n+#   define RAND_MAX 2147483647\n+#  endif\n+# endif\n+#endif\n+\n+\n+#if @GNULIB_RANDOM@\n+# if !@HAVE_RANDOM@\n+_GL_FUNCDECL_SYS (random, long, (void));\n+# endif\n+_GL_CXXALIAS_SYS (random, long, (void));\n+_GL_CXXALIASWARN (random);\n+#elif defined GNULIB_POSIXCHECK\n+# undef random\n+# if HAVE_RAW_DECL_RANDOM\n+_GL_WARN_ON_USE (random, \"random is unportable - \"\n+                 \"use gnulib module random for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_RANDOM@\n+# if !@HAVE_RANDOM@\n+_GL_FUNCDECL_SYS (srandom, void, (unsigned int seed));\n+# endif\n+_GL_CXXALIAS_SYS (srandom, void, (unsigned int seed));\n+_GL_CXXALIASWARN (srandom);\n+#elif defined GNULIB_POSIXCHECK\n+# undef srandom\n+# if HAVE_RAW_DECL_SRANDOM\n+_GL_WARN_ON_USE (srandom, \"srandom is unportable - \"\n+                 \"use gnulib module random for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_RANDOM@\n+# if !@HAVE_RANDOM@\n+_GL_FUNCDECL_SYS (initstate, char *,\n+                  (unsigned int seed, char *buf, size_t buf_size)\n+                  _GL_ARG_NONNULL ((2)));\n+# endif\n+_GL_CXXALIAS_SYS (initstate, char *,\n+                  (unsigned int seed, char *buf, size_t buf_size));\n+_GL_CXXALIASWARN (initstate);\n+#elif defined GNULIB_POSIXCHECK\n+# undef initstate\n+# if HAVE_RAW_DECL_INITSTATE_R\n+_GL_WARN_ON_USE (initstate, \"initstate is unportable - \"\n+                 \"use gnulib module random for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_RANDOM@\n+# if !@HAVE_RANDOM@\n+_GL_FUNCDECL_SYS (setstate, char *, (char *arg_state) _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (setstate, char *, (char *arg_state));\n+_GL_CXXALIASWARN (setstate);\n+#elif defined GNULIB_POSIXCHECK\n+# undef setstate\n+# if HAVE_RAW_DECL_SETSTATE_R\n+_GL_WARN_ON_USE (setstate, \"setstate is unportable - \"\n+                 \"use gnulib module random for portability\");\n+# endif\n+#endif\n+\n+\n+#if @GNULIB_RANDOM_R@\n+# if @REPLACE_RANDOM_R@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef random_r\n+#   define random_r rpl_random_r\n+#  endif\n+_GL_FUNCDECL_RPL (random_r, int, (struct random_data *buf, int32_t *result)\n+                                 _GL_ARG_NONNULL ((1, 2)));\n+_GL_CXXALIAS_RPL (random_r, int, (struct random_data *buf, int32_t *result));\n+# else\n+#  if !@HAVE_RANDOM_R@\n+_GL_FUNCDECL_SYS (random_r, int, (struct random_data *buf, int32_t *result)\n+                                 _GL_ARG_NONNULL ((1, 2)));\n+#  endif\n+_GL_CXXALIAS_SYS (random_r, int, (struct random_data *buf, int32_t *result));\n+# endif\n+_GL_CXXALIASWARN (random_r);\n+#elif defined GNULIB_POSIXCHECK\n+# undef random_r\n+# if HAVE_RAW_DECL_RANDOM_R\n+_GL_WARN_ON_USE (random_r, \"random_r is unportable - \"\n+                 \"use gnulib module random_r for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_RANDOM_R@\n+# if @REPLACE_RANDOM_R@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef srandom_r\n+#   define srandom_r rpl_srandom_r\n+#  endif\n+_GL_FUNCDECL_RPL (srandom_r, int,\n+                  (unsigned int seed, struct random_data *rand_state)\n+                  _GL_ARG_NONNULL ((2)));\n+_GL_CXXALIAS_RPL (srandom_r, int,\n+                  (unsigned int seed, struct random_data *rand_state));\n+# else\n+#  if !@HAVE_RANDOM_R@\n+_GL_FUNCDECL_SYS (srandom_r, int,\n+                  (unsigned int seed, struct random_data *rand_state)\n+                  _GL_ARG_NONNULL ((2)));\n+#  endif\n+_GL_CXXALIAS_SYS (srandom_r, int,\n+                  (unsigned int seed, struct random_data *rand_state));\n+# endif\n+_GL_CXXALIASWARN (srandom_r);\n+#elif defined GNULIB_POSIXCHECK\n+# undef srandom_r\n+# if HAVE_RAW_DECL_SRANDOM_R\n+_GL_WARN_ON_USE (srandom_r, \"srandom_r is unportable - \"\n+                 \"use gnulib module random_r for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_RANDOM_R@\n+# if @REPLACE_RANDOM_R@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef initstate_r\n+#   define initstate_r rpl_initstate_r\n+#  endif\n+_GL_FUNCDECL_RPL (initstate_r, int,\n+                  (unsigned int seed, char *buf, size_t buf_size,\n+                   struct random_data *rand_state)\n+                  _GL_ARG_NONNULL ((2, 4)));\n+_GL_CXXALIAS_RPL (initstate_r, int,\n+                  (unsigned int seed, char *buf, size_t buf_size,\n+                   struct random_data *rand_state));\n+# else\n+#  if !@HAVE_RANDOM_R@\n+_GL_FUNCDECL_SYS (initstate_r, int,\n+                  (unsigned int seed, char *buf, size_t buf_size,\n+                   struct random_data *rand_state)\n+                  _GL_ARG_NONNULL ((2, 4)));\n+#  endif\n+_GL_CXXALIAS_SYS (initstate_r, int,\n+                  (unsigned int seed, char *buf, size_t buf_size,\n+                   struct random_data *rand_state));\n+# endif\n+_GL_CXXALIASWARN (initstate_r);\n+#elif defined GNULIB_POSIXCHECK\n+# undef initstate_r\n+# if HAVE_RAW_DECL_INITSTATE_R\n+_GL_WARN_ON_USE (initstate_r, \"initstate_r is unportable - \"\n+                 \"use gnulib module random_r for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_RANDOM_R@\n+# if @REPLACE_RANDOM_R@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef setstate_r\n+#   define setstate_r rpl_setstate_r\n+#  endif\n+_GL_FUNCDECL_RPL (setstate_r, int,\n+                  (char *arg_state, struct random_data *rand_state)\n+                  _GL_ARG_NONNULL ((1, 2)));\n+_GL_CXXALIAS_RPL (setstate_r, int,\n+                  (char *arg_state, struct random_data *rand_state));\n+# else\n+#  if !@HAVE_RANDOM_R@\n+_GL_FUNCDECL_SYS (setstate_r, int,\n+                  (char *arg_state, struct random_data *rand_state)\n+                  _GL_ARG_NONNULL ((1, 2)));\n+#  endif\n+_GL_CXXALIAS_SYS (setstate_r, int,\n+                  (char *arg_state, struct random_data *rand_state));\n+# endif\n+_GL_CXXALIASWARN (setstate_r);\n+#elif defined GNULIB_POSIXCHECK\n+# undef setstate_r\n+# if HAVE_RAW_DECL_SETSTATE_R\n+_GL_WARN_ON_USE (setstate_r, \"setstate_r is unportable - \"\n+                 \"use gnulib module random_r for portability\");\n+# endif\n+#endif\n+\n+\n+#if @GNULIB_REALLOC_POSIX@\n+# if @REPLACE_REALLOC@\n+#  if !((defined __cplusplus && defined GNULIB_NAMESPACE) \\\n+        || _GL_USE_STDLIB_ALLOC)\n+#   undef realloc\n+#   define realloc rpl_realloc\n+#  endif\n+_GL_FUNCDECL_RPL (realloc, void *, (void *ptr, size_t size));\n+_GL_CXXALIAS_RPL (realloc, void *, (void *ptr, size_t size));\n+# else\n+_GL_CXXALIAS_SYS (realloc, void *, (void *ptr, size_t size));\n+# endif\n+_GL_CXXALIASWARN (realloc);\n+#elif defined GNULIB_POSIXCHECK && !_GL_USE_STDLIB_ALLOC\n+# undef realloc\n+\/* Assume realloc is always declared.  *\/\n+_GL_WARN_ON_USE (realloc, \"realloc is not POSIX compliant everywhere - \"\n+                 \"use gnulib module realloc-posix for portability\");\n+#endif\n+\n+#if @GNULIB_REALPATH@\n+# if @REPLACE_REALPATH@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   define realpath rpl_realpath\n+#  endif\n+_GL_FUNCDECL_RPL (realpath, char *, (const char *name, char *resolved)\n+                                    _GL_ARG_NONNULL ((1)));\n+_GL_CXXALIAS_RPL (realpath, char *, (const char *name, char *resolved));\n+# else\n+#  if !@HAVE_REALPATH@\n+_GL_FUNCDECL_SYS (realpath, char *, (const char *name, char *resolved)\n+                                    _GL_ARG_NONNULL ((1)));\n+#  endif\n+_GL_CXXALIAS_SYS (realpath, char *, (const char *name, char *resolved));\n+# endif\n+_GL_CXXALIASWARN (realpath);\n+#elif defined GNULIB_POSIXCHECK\n+# undef realpath\n+# if HAVE_RAW_DECL_REALPATH\n+_GL_WARN_ON_USE (realpath, \"realpath is unportable - use gnulib module \"\n+                 \"canonicalize or canonicalize-lgpl for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_RPMATCH@\n+\/* Test a user response to a question.\n+   Return 1 if it is affirmative, 0 if it is negative, or -1 if not clear.  *\/\n+# if !@HAVE_RPMATCH@\n+_GL_FUNCDECL_SYS (rpmatch, int, (const char *response) _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (rpmatch, int, (const char *response));\n+_GL_CXXALIASWARN (rpmatch);\n+#elif defined GNULIB_POSIXCHECK\n+# undef rpmatch\n+# if HAVE_RAW_DECL_RPMATCH\n+_GL_WARN_ON_USE (rpmatch, \"rpmatch is unportable - \"\n+                 \"use gnulib module rpmatch for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_SECURE_GETENV@\n+\/* Look up NAME in the environment, returning 0 in insecure situations.  *\/\n+# if !@HAVE_SECURE_GETENV@\n+_GL_FUNCDECL_SYS (secure_getenv, char *,\n+                  (char const *name) _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (secure_getenv, char *, (char const *name));\n+_GL_CXXALIASWARN (secure_getenv);\n+#elif defined GNULIB_POSIXCHECK\n+# undef secure_getenv\n+# if HAVE_RAW_DECL_SECURE_GETENV\n+_GL_WARN_ON_USE (secure_getenv, \"secure_getenv is unportable - \"\n+                 \"use gnulib module secure_getenv for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_SETENV@\n+\/* Set NAME to VALUE in the environment.\n+   If REPLACE is nonzero, overwrite an existing value.  *\/\n+# if @REPLACE_SETENV@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef setenv\n+#   define setenv rpl_setenv\n+#  endif\n+_GL_FUNCDECL_RPL (setenv, int,\n+                  (const char *name, const char *value, int replace)\n+                  _GL_ARG_NONNULL ((1)));\n+_GL_CXXALIAS_RPL (setenv, int,\n+                  (const char *name, const char *value, int replace));\n+# else\n+#  if !@HAVE_DECL_SETENV@\n+_GL_FUNCDECL_SYS (setenv, int,\n+                  (const char *name, const char *value, int replace)\n+                  _GL_ARG_NONNULL ((1)));\n+#  endif\n+_GL_CXXALIAS_SYS (setenv, int,\n+                  (const char *name, const char *value, int replace));\n+# endif\n+# if !(@REPLACE_SETENV@ && !@HAVE_DECL_SETENV@)\n+_GL_CXXALIASWARN (setenv);\n+# endif\n+#elif defined GNULIB_POSIXCHECK\n+# undef setenv\n+# if HAVE_RAW_DECL_SETENV\n+_GL_WARN_ON_USE (setenv, \"setenv is unportable - \"\n+                 \"use gnulib module setenv for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_STRTOD@\n+ \/* Parse a double from STRING, updating ENDP if appropriate.  *\/\n+# if @REPLACE_STRTOD@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   define strtod rpl_strtod\n+#  endif\n+_GL_FUNCDECL_RPL (strtod, double, (const char *str, char **endp)\n+                                  _GL_ARG_NONNULL ((1)));\n+_GL_CXXALIAS_RPL (strtod, double, (const char *str, char **endp));\n+# else\n+#  if !@HAVE_STRTOD@\n+_GL_FUNCDECL_SYS (strtod, double, (const char *str, char **endp)\n+                                  _GL_ARG_NONNULL ((1)));\n+#  endif\n+_GL_CXXALIAS_SYS (strtod, double, (const char *str, char **endp));\n+# endif\n+_GL_CXXALIASWARN (strtod);\n+#elif defined GNULIB_POSIXCHECK\n+# undef strtod\n+# if HAVE_RAW_DECL_STRTOD\n+_GL_WARN_ON_USE (strtod, \"strtod is unportable - \"\n+                 \"use gnulib module strtod for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_STRTOLL@\n+\/* Parse a signed integer whose textual representation starts at STRING.\n+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,\n+   it may be decimal or octal (with prefix \"0\") or hexadecimal (with prefix\n+   \"0x\").\n+   If ENDPTR is not NULL, the address of the first byte after the integer is\n+   stored in *ENDPTR.\n+   Upon overflow, the return value is LLONG_MAX or LLONG_MIN, and errno is set\n+   to ERANGE.  *\/\n+# if !@HAVE_STRTOLL@\n+_GL_FUNCDECL_SYS (strtoll, long long,\n+                  (const char *string, char **endptr, int base)\n+                  _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (strtoll, long long,\n+                  (const char *string, char **endptr, int base));\n+_GL_CXXALIASWARN (strtoll);\n+#elif defined GNULIB_POSIXCHECK\n+# undef strtoll\n+# if HAVE_RAW_DECL_STRTOLL\n+_GL_WARN_ON_USE (strtoll, \"strtoll is unportable - \"\n+                 \"use gnulib module strtoll for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_STRTOULL@\n+\/* Parse an unsigned integer whose textual representation starts at STRING.\n+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,\n+   it may be decimal or octal (with prefix \"0\") or hexadecimal (with prefix\n+   \"0x\").\n+   If ENDPTR is not NULL, the address of the first byte after the integer is\n+   stored in *ENDPTR.\n+   Upon overflow, the return value is ULLONG_MAX, and errno is set to\n+   ERANGE.  *\/\n+# if !@HAVE_STRTOULL@\n+_GL_FUNCDECL_SYS (strtoull, unsigned long long,\n+                  (const char *string, char **endptr, int base)\n+                  _GL_ARG_NONNULL ((1)));\n+# endif\n+_GL_CXXALIAS_SYS (strtoull, unsigned long long,\n+                  (const char *string, char **endptr, int base));\n+_GL_CXXALIASWARN (strtoull);\n+#elif defined GNULIB_POSIXCHECK\n+# undef strtoull\n+# if HAVE_RAW_DECL_STRTOULL\n+_GL_WARN_ON_USE (strtoull, \"strtoull is unportable - \"\n+                 \"use gnulib module strtoull for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_UNLOCKPT@\n+\/* Unlock the slave side of the pseudo-terminal whose master side is specified\n+   by FD, so that it can be opened.  *\/\n+# if !@HAVE_UNLOCKPT@\n+_GL_FUNCDECL_SYS (unlockpt, int, (int fd));\n+# endif\n+_GL_CXXALIAS_SYS (unlockpt, int, (int fd));\n+_GL_CXXALIASWARN (unlockpt);\n+#elif defined GNULIB_POSIXCHECK\n+# undef unlockpt\n+# if HAVE_RAW_DECL_UNLOCKPT\n+_GL_WARN_ON_USE (unlockpt, \"unlockpt is not portable - \"\n+                 \"use gnulib module unlockpt for portability\");\n+# endif\n+#endif\n+\n+#if @GNULIB_UNSETENV@\n+\/* Remove the variable NAME from the environment.  *\/\n+# if @REPLACE_UNSETENV@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef unsetenv\n+#   define unsetenv rpl_unsetenv\n+#  endif\n+_GL_FUNCDECL_RPL (unsetenv, int, (const char *name) _GL_ARG_NONNULL ((1)));\n+_GL_CXXALIAS_RPL (unsetenv, int, (const char *name));\n+# else\n+#  if !@HAVE_DECL_UNSETENV@\n+_GL_FUNCDECL_SYS (unsetenv, int, (const char *name) _GL_ARG_NONNULL ((1)));\n+#  endif\n+_GL_CXXALIAS_SYS (unsetenv, int, (const char *name));\n+# endif\n+# if !(@REPLACE_UNSETENV@ && !@HAVE_DECL_UNSETENV@)\n+_GL_CXXALIASWARN (unsetenv);\n+# endif\n+#elif defined GNULIB_POSIXCHECK\n+# undef unsetenv\n+# if HAVE_RAW_DECL_UNSETENV\n+_GL_WARN_ON_USE (unsetenv, \"unsetenv is unportable - \"\n+                 \"use gnulib module unsetenv for portability\");\n+# endif\n+#endif\n+\n+\/* Convert a wide character to a multibyte character.  *\/\n+#if @GNULIB_WCTOMB@\n+# if @REPLACE_WCTOMB@\n+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n+#   undef wctomb\n+#   define wctomb rpl_wctomb\n+#  endif\n+_GL_FUNCDECL_RPL (wctomb, int, (char *s, wchar_t wc));\n+_GL_CXXALIAS_RPL (wctomb, int, (char *s, wchar_t wc));\n+# else\n+_GL_CXXALIAS_SYS (wctomb, int, (char *s, wchar_t wc));\n+# endif\n+_GL_CXXALIASWARN (wctomb);\n+#endif\n+\n+\n+#endif \/* _@GUARD_PREFIX@_STDLIB_H *\/\n+#endif \/* _@GUARD_PREFIX@_STDLIB_H *\/\n+#endif\ndiff --git a\/gltests\/Makefile.am b\/gltests\/Makefile.am\nindex cea90f8..e254376 100644\n--- a\/gltests\/Makefile.am\n+++ b\/gltests\/Makefile.am\n@@ -291,6 +291,15 @@ EXTRA_DIST += test-getcwd-lgpl.c signature.h macros.h\n \n ## end   gnulib module getcwd-lgpl-tests\n \n+## begin gnulib module getdelim-tests\n+\n+TESTS += test-getdelim\n+check_PROGRAMS += test-getdelim\n+MOSTLYCLEANFILES += test-getdelim.txt\n+EXTRA_DIST += test-getdelim.c signature.h macros.h\n+\n+## end   gnulib module getdelim-tests\n+\n ## begin gnulib module getdtablesize\n \n \n@@ -308,6 +317,15 @@ EXTRA_DIST += test-getdtablesize.c signature.h macros.h\n \n ## end   gnulib module getdtablesize-tests\n \n+## begin gnulib module getline-tests\n+\n+TESTS += test-getline\n+check_PROGRAMS += test-getline\n+MOSTLYCLEANFILES += test-getline.txt\n+EXTRA_DIST += test-getline.c signature.h macros.h\n+\n+## end   gnulib module getline-tests\n+\n ## begin gnulib module getopt-posix-tests\n \n TESTS += test-getopt\n@@ -688,56 +706,6 @@ EXTRA_DIST += test-stddef.c\n \n ## end   gnulib module stddef-tests\n \n-## begin gnulib module stdint\n-\n-BUILT_SOURCES += $(STDINT_H)\n-\n-# We need the following in order to create <stdint.h> when the system\n-# doesn't have one that works with the given compiler.\n-if GL_GENERATE_STDINT_H\n-stdint.h: stdint.in.h $(top_builddir)\/config.status\n-\t$(AM_V_GEN)rm -f $@-t $@ && \\\n-\t{ echo '\/* DO NOT EDIT! GENERATED AUTOMATICALLY! *\/'; \\\n-\t  sed -e 's|@''GUARD_PREFIX''@|GL|g' \\\n-\t      -e 's\/@''HAVE_STDINT_H''@\/$(HAVE_STDINT_H)\/g' \\\n-\t      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \\\n-\t      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \\\n-\t      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \\\n-\t      -e 's|@''NEXT_STDINT_H''@|$(NEXT_STDINT_H)|g' \\\n-\t      -e 's\/@''HAVE_SYS_TYPES_H''@\/$(HAVE_SYS_TYPES_H)\/g' \\\n-\t      -e 's\/@''HAVE_INTTYPES_H''@\/$(HAVE_INTTYPES_H)\/g' \\\n-\t      -e 's\/@''HAVE_SYS_INTTYPES_H''@\/$(HAVE_SYS_INTTYPES_H)\/g' \\\n-\t      -e 's\/@''HAVE_SYS_BITYPES_H''@\/$(HAVE_SYS_BITYPES_H)\/g' \\\n-\t      -e 's\/@''HAVE_WCHAR_H''@\/$(HAVE_WCHAR_H)\/g' \\\n-\t      -e 's\/@''HAVE_LONG_LONG_INT''@\/$(HAVE_LONG_LONG_INT)\/g' \\\n-\t      -e 's\/@''HAVE_UNSIGNED_LONG_LONG_INT''@\/$(HAVE_UNSIGNED_LONG_LONG_INT)\/g' \\\n-\t      -e 's\/@''APPLE_UNIVERSAL_BUILD''@\/$(APPLE_UNIVERSAL_BUILD)\/g' \\\n-\t      -e 's\/@''BITSIZEOF_PTRDIFF_T''@\/$(BITSIZEOF_PTRDIFF_T)\/g' \\\n-\t      -e 's\/@''PTRDIFF_T_SUFFIX''@\/$(PTRDIFF_T_SUFFIX)\/g' \\\n-\t      -e 's\/@''BITSIZEOF_SIG_ATOMIC_T''@\/$(BITSIZEOF_SIG_ATOMIC_T)\/g' \\\n-\t      -e 's\/@''HAVE_SIGNED_SIG_ATOMIC_T''@\/$(HAVE_SIGNED_SIG_ATOMIC_T)\/g' \\\n-\t      -e 's\/@''SIG_ATOMIC_T_SUFFIX''@\/$(SIG_ATOMIC_T_SUFFIX)\/g' \\\n-\t      -e 's\/@''BITSIZEOF_SIZE_T''@\/$(BITSIZEOF_SIZE_T)\/g' \\\n-\t      -e 's\/@''SIZE_T_SUFFIX''@\/$(SIZE_T_SUFFIX)\/g' \\\n-\t      -e 's\/@''BITSIZEOF_WCHAR_T''@\/$(BITSIZEOF_WCHAR_T)\/g' \\\n-\t      -e 's\/@''HAVE_SIGNED_WCHAR_T''@\/$(HAVE_SIGNED_WCHAR_T)\/g' \\\n-\t      -e 's\/@''WCHAR_T_SUFFIX''@\/$(WCHAR_T_SUFFIX)\/g' \\\n-\t      -e 's\/@''BITSIZEOF_WINT_T''@\/$(BITSIZEOF_WINT_T)\/g' \\\n-\t      -e 's\/@''HAVE_SIGNED_WINT_T''@\/$(HAVE_SIGNED_WINT_T)\/g' \\\n-\t      -e 's\/@''WINT_T_SUFFIX''@\/$(WINT_T_SUFFIX)\/g' \\\n-\t      < $(srcdir)\/stdint.in.h; \\\n-\t} > $@-t && \\\n-\tmv $@-t $@\n-else\n-stdint.h: $(top_builddir)\/config.status\n-\trm -f $@\n-endif\n-MOSTLYCLEANFILES += stdint.h stdint.h-t\n-\n-EXTRA_DIST += stdint.in.h\n-\n-## end   gnulib module stdint\n-\n ## begin gnulib module stdint-tests\n \n TESTS += test-stdint\n@@ -754,111 +722,6 @@ EXTRA_DIST += test-stdio.c\n \n ## end   gnulib module stdio-tests\n \n-## begin gnulib module stdlib\n-\n-BUILT_SOURCES += stdlib.h\n-\n-# We need the following in order to create <stdlib.h> when the system\n-# doesn't have one that works with the given compiler.\n-stdlib.h: stdlib.in.h $(top_builddir)\/config.status $(CXXDEFS_H) \\\n-  $(_NORETURN_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)\n-\t$(AM_V_GEN)rm -f $@-t $@ && \\\n-\t{ echo '\/* DO NOT EDIT! GENERATED AUTOMATICALLY! *\/' && \\\n-\t  sed -e 's|@''GUARD_PREFIX''@|GL|g' \\\n-\t      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \\\n-\t      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \\\n-\t      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \\\n-\t      -e 's|@''NEXT_STDLIB_H''@|$(NEXT_STDLIB_H)|g' \\\n-\t      -e 's\/@''GNULIB__EXIT''@\/$(GNULIB__EXIT)\/g' \\\n-\t      -e 's\/@''GNULIB_ATOLL''@\/$(GNULIB_ATOLL)\/g' \\\n-\t      -e 's\/@''GNULIB_CALLOC_POSIX''@\/$(GNULIB_CALLOC_POSIX)\/g' \\\n-\t      -e 's\/@''GNULIB_CANONICALIZE_FILE_NAME''@\/$(GNULIB_CANONICALIZE_FILE_NAME)\/g' \\\n-\t      -e 's\/@''GNULIB_GETLOADAVG''@\/$(GNULIB_GETLOADAVG)\/g' \\\n-\t      -e 's\/@''GNULIB_GETSUBOPT''@\/$(GNULIB_GETSUBOPT)\/g' \\\n-\t      -e 's\/@''GNULIB_GRANTPT''@\/$(GNULIB_GRANTPT)\/g' \\\n-\t      -e 's\/@''GNULIB_MALLOC_POSIX''@\/$(GNULIB_MALLOC_POSIX)\/g' \\\n-\t      -e 's\/@''GNULIB_MBTOWC''@\/$(GNULIB_MBTOWC)\/g' \\\n-\t      -e 's\/@''GNULIB_MKDTEMP''@\/$(GNULIB_MKDTEMP)\/g' \\\n-\t      -e 's\/@''GNULIB_MKOSTEMP''@\/$(GNULIB_MKOSTEMP)\/g' \\\n-\t      -e 's\/@''GNULIB_MKOSTEMPS''@\/$(GNULIB_MKOSTEMPS)\/g' \\\n-\t      -e 's\/@''GNULIB_MKSTEMP''@\/$(GNULIB_MKSTEMP)\/g' \\\n-\t      -e 's\/@''GNULIB_MKSTEMPS''@\/$(GNULIB_MKSTEMPS)\/g' \\\n-\t      -e 's\/@''GNULIB_POSIX_OPENPT''@\/$(GNULIB_POSIX_OPENPT)\/g' \\\n-\t      -e 's\/@''GNULIB_PTSNAME''@\/$(GNULIB_PTSNAME)\/g' \\\n-\t      -e 's\/@''GNULIB_PTSNAME_R''@\/$(GNULIB_PTSNAME_R)\/g' \\\n-\t      -e 's\/@''GNULIB_PUTENV''@\/$(GNULIB_PUTENV)\/g' \\\n-\t      -e 's\/@''GNULIB_QSORT_R''@\/$(GNULIB_QSORT_R)\/g' \\\n-\t      -e 's\/@''GNULIB_RANDOM''@\/$(GNULIB_RANDOM)\/g' \\\n-\t      -e 's\/@''GNULIB_RANDOM_R''@\/$(GNULIB_RANDOM_R)\/g' \\\n-\t      -e 's\/@''GNULIB_REALLOC_POSIX''@\/$(GNULIB_REALLOC_POSIX)\/g' \\\n-\t      -e 's\/@''GNULIB_REALPATH''@\/$(GNULIB_REALPATH)\/g' \\\n-\t      -e 's\/@''GNULIB_RPMATCH''@\/$(GNULIB_RPMATCH)\/g' \\\n-\t      -e 's\/@''GNULIB_SECURE_GETENV''@\/$(GNULIB_SECURE_GETENV)\/g' \\\n-\t      -e 's\/@''GNULIB_SETENV''@\/$(GNULIB_SETENV)\/g' \\\n-\t      -e 's\/@''GNULIB_STRTOD''@\/$(GNULIB_STRTOD)\/g' \\\n-\t      -e 's\/@''GNULIB_STRTOLL''@\/$(GNULIB_STRTOLL)\/g' \\\n-\t      -e 's\/@''GNULIB_STRTOULL''@\/$(GNULIB_STRTOULL)\/g' \\\n-\t      -e 's\/@''GNULIB_SYSTEM_POSIX''@\/$(GNULIB_SYSTEM_POSIX)\/g' \\\n-\t      -e 's\/@''GNULIB_UNLOCKPT''@\/$(GNULIB_UNLOCKPT)\/g' \\\n-\t      -e 's\/@''GNULIB_UNSETENV''@\/$(GNULIB_UNSETENV)\/g' \\\n-\t      -e 's\/@''GNULIB_WCTOMB''@\/$(GNULIB_WCTOMB)\/g' \\\n-\t      < $(srcdir)\/stdlib.in.h | \\\n-\t  sed -e 's|@''HAVE__EXIT''@|$(HAVE__EXIT)|g' \\\n-\t      -e 's|@''HAVE_ATOLL''@|$(HAVE_ATOLL)|g' \\\n-\t      -e 's|@''HAVE_CANONICALIZE_FILE_NAME''@|$(HAVE_CANONICALIZE_FILE_NAME)|g' \\\n-\t      -e 's|@''HAVE_DECL_GETLOADAVG''@|$(HAVE_DECL_GETLOADAVG)|g' \\\n-\t      -e 's|@''HAVE_GETSUBOPT''@|$(HAVE_GETSUBOPT)|g' \\\n-\t      -e 's|@''HAVE_GRANTPT''@|$(HAVE_GRANTPT)|g' \\\n-\t      -e 's|@''HAVE_MKDTEMP''@|$(HAVE_MKDTEMP)|g' \\\n-\t      -e 's|@''HAVE_MKOSTEMP''@|$(HAVE_MKOSTEMP)|g' \\\n-\t      -e 's|@''HAVE_MKOSTEMPS''@|$(HAVE_MKOSTEMPS)|g' \\\n-\t      -e 's|@''HAVE_MKSTEMP''@|$(HAVE_MKSTEMP)|g' \\\n-\t      -e 's|@''HAVE_MKSTEMPS''@|$(HAVE_MKSTEMPS)|g' \\\n-\t      -e 's|@''HAVE_POSIX_OPENPT''@|$(HAVE_POSIX_OPENPT)|g' \\\n-\t      -e 's|@''HAVE_PTSNAME''@|$(HAVE_PTSNAME)|g' \\\n-\t      -e 's|@''HAVE_PTSNAME_R''@|$(HAVE_PTSNAME_R)|g' \\\n-\t      -e 's|@''HAVE_RANDOM''@|$(HAVE_RANDOM)|g' \\\n-\t      -e 's|@''HAVE_RANDOM_H''@|$(HAVE_RANDOM_H)|g' \\\n-\t      -e 's|@''HAVE_RANDOM_R''@|$(HAVE_RANDOM_R)|g' \\\n-\t      -e 's|@''HAVE_REALPATH''@|$(HAVE_REALPATH)|g' \\\n-\t      -e 's|@''HAVE_RPMATCH''@|$(HAVE_RPMATCH)|g' \\\n-\t      -e 's|@''HAVE_SECURE_GETENV''@|$(HAVE_SECURE_GETENV)|g' \\\n-\t      -e 's|@''HAVE_DECL_SETENV''@|$(HAVE_DECL_SETENV)|g' \\\n-\t      -e 's|@''HAVE_STRTOD''@|$(HAVE_STRTOD)|g' \\\n-\t      -e 's|@''HAVE_STRTOLL''@|$(HAVE_STRTOLL)|g' \\\n-\t      -e 's|@''HAVE_STRTOULL''@|$(HAVE_STRTOULL)|g' \\\n-\t      -e 's|@''HAVE_STRUCT_RANDOM_DATA''@|$(HAVE_STRUCT_RANDOM_DATA)|g' \\\n-\t      -e 's|@''HAVE_SYS_LOADAVG_H''@|$(HAVE_SYS_LOADAVG_H)|g' \\\n-\t      -e 's|@''HAVE_UNLOCKPT''@|$(HAVE_UNLOCKPT)|g' \\\n-\t      -e 's|@''HAVE_DECL_UNSETENV''@|$(HAVE_DECL_UNSETENV)|g' \\\n-\t      -e 's|@''REPLACE_CALLOC''@|$(REPLACE_CALLOC)|g' \\\n-\t      -e 's|@''REPLACE_CANONICALIZE_FILE_NAME''@|$(REPLACE_CANONICALIZE_FILE_NAME)|g' \\\n-\t      -e 's|@''REPLACE_MALLOC''@|$(REPLACE_MALLOC)|g' \\\n-\t      -e 's|@''REPLACE_MBTOWC''@|$(REPLACE_MBTOWC)|g' \\\n-\t      -e 's|@''REPLACE_MKSTEMP''@|$(REPLACE_MKSTEMP)|g' \\\n-\t      -e 's|@''REPLACE_PTSNAME''@|$(REPLACE_PTSNAME)|g' \\\n-\t      -e 's|@''REPLACE_PTSNAME_R''@|$(REPLACE_PTSNAME_R)|g' \\\n-\t      -e 's|@''REPLACE_PUTENV''@|$(REPLACE_PUTENV)|g' \\\n-\t      -e 's|@''REPLACE_QSORT_R''@|$(REPLACE_QSORT_R)|g' \\\n-\t      -e 's|@''REPLACE_RANDOM_R''@|$(REPLACE_RANDOM_R)|g' \\\n-\t      -e 's|@''REPLACE_REALLOC''@|$(REPLACE_REALLOC)|g' \\\n-\t      -e 's|@''REPLACE_REALPATH''@|$(REPLACE_REALPATH)|g' \\\n-\t      -e 's|@''REPLACE_SETENV''@|$(REPLACE_SETENV)|g' \\\n-\t      -e 's|@''REPLACE_STRTOD''@|$(REPLACE_STRTOD)|g' \\\n-\t      -e 's|@''REPLACE_UNSETENV''@|$(REPLACE_UNSETENV)|g' \\\n-\t      -e 's|@''REPLACE_WCTOMB''@|$(REPLACE_WCTOMB)|g' \\\n-\t      -e '\/definitions of _GL_FUNCDECL_RPL\/r $(CXXDEFS_H)' \\\n-\t      -e '\/definition of _Noreturn\/r $(_NORETURN_H)' \\\n-\t      -e '\/definition of _GL_ARG_NONNULL\/r $(ARG_NONNULL_H)' \\\n-\t      -e '\/definition of _GL_WARN_ON_USE\/r $(WARN_ON_USE_H)'; \\\n-\t} > $@-t && \\\n-\tmv $@-t $@\n-MOSTLYCLEANFILES += stdlib.h stdlib.h-t\n-\n-EXTRA_DIST += stdlib.in.h\n-\n-## end   gnulib module stdlib\n-\n ## begin gnulib module strerror-tests\n \n TESTS += test-strerror\ndiff --git a\/gltests\/stdint.in.h b\/gltests\/stdint.in.h\ndeleted file mode 100644\nindex 378de2e..0000000\n--- a\/gltests\/stdint.in.h\n+++ \/dev\/null\n@@ -1,635 +0,0 @@\n-\/* Copyright (C) 2001-2002, 2004-2015 Free Software Foundation, Inc.\n-   Written by Paul Eggert, Bruno Haible, Sam Steingold, Peter Burwood.\n-   This file is part of gnulib.\n-\n-   This program is free software; you can redistribute it and\/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, see <http:\/\/www.gnu.org\/licenses\/>.  *\/\n-\n-\/*\n- * ISO C 99 <stdint.h> for platforms that lack it.\n- * <http:\/\/www.opengroup.org\/susv3xbd\/stdint.h.html>\n- *\/\n-\n-#ifndef _@GUARD_PREFIX@_STDINT_H\n-\n-#if __GNUC__ >= 3\n-@PRAGMA_SYSTEM_HEADER@\n-#endif\n-@PRAGMA_COLUMNS@\n-\n-\/* When including a system file that in turn includes <inttypes.h>,\n-   use the system <inttypes.h>, not our substitute.  This avoids\n-   problems with (for example) VMS, whose <sys\/bitypes.h> includes\n-   <inttypes.h>.  *\/\n-#define _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H\n-\n-\/* On Android (Bionic libc), <sys\/types.h> includes this file before\n-   having defined 'time_t'.  Therefore in this case avoid including\n-   other system header files; just include the system's <stdint.h>.\n-   Ideally we should test __BIONIC__ here, but it is only defined after\n-   <sys\/cdefs.h> has been included; hence test __ANDROID__ instead.  *\/\n-#if defined __ANDROID__ && defined _GL_INCLUDING_SYS_TYPES_H\n-# @INCLUDE_NEXT@ @NEXT_STDINT_H@\n-#else\n-\n-\/* Get those types that are already defined in other system include\n-   files, so that we can \"#define int8_t signed char\" below without\n-   worrying about a later system include file containing a \"typedef\n-   signed char int8_t;\" that will get messed up by our macro.  Our\n-   macros should all be consistent with the system versions, except\n-   for the \"fast\" types and macros, which we recommend against using\n-   in public interfaces due to compiler differences.  *\/\n-\n-#if @HAVE_STDINT_H@\n-# if defined __sgi && ! defined __c99\n-   \/* Bypass IRIX's <stdint.h> if in C89 mode, since it merely annoys users\n-      with \"This header file is to be used only for c99 mode compilations\"\n-      diagnostics.  *\/\n-#  define __STDINT_H__\n-# endif\n-\n-  \/* Some pre-C++11 <stdint.h> implementations need this.  *\/\n-# ifdef __cplusplus\n-#  ifndef __STDC_CONSTANT_MACROS\n-#   define __STDC_CONSTANT_MACROS 1\n-#  endif\n-#  ifndef __STDC_LIMIT_MACROS\n-#   define __STDC_LIMIT_MACROS 1\n-#  endif\n-# endif\n-\n-  \/* Other systems may have an incomplete or buggy <stdint.h>.\n-     Include it before <inttypes.h>, since any \"#include <stdint.h>\"\n-     in <inttypes.h> would reinclude us, skipping our contents because\n-     _@GUARD_PREFIX@_STDINT_H is defined.\n-     The include_next requires a split double-inclusion guard.  *\/\n-# @INCLUDE_NEXT@ @NEXT_STDINT_H@\n-#endif\n-\n-#if ! defined _@GUARD_PREFIX@_STDINT_H && ! defined _GL_JUST_INCLUDE_SYSTEM_STDINT_H\n-#define _@GUARD_PREFIX@_STDINT_H\n-\n-\/* <sys\/types.h> defines some of the stdint.h types as well, on glibc,\n-   IRIX 6.5, and OpenBSD 3.8 (via <machine\/types.h>).\n-   AIX 5.2 <sys\/types.h> isn't needed and causes troubles.\n-   Mac OS X 10.4.6 <sys\/types.h> includes <stdint.h> (which is us), but\n-   relies on the system <stdint.h> definitions, so include\n-   <sys\/types.h> after @NEXT_STDINT_H@.  *\/\n-#if @HAVE_SYS_TYPES_H@ && ! defined _AIX\n-# include <sys\/types.h>\n-#endif\n-\n-\/* Get SCHAR_MIN, SCHAR_MAX, UCHAR_MAX, INT_MIN, INT_MAX,\n-   LONG_MIN, LONG_MAX, ULONG_MAX.  *\/\n-#include <limits.h>\n-\n-#if @HAVE_INTTYPES_H@\n-  \/* In OpenBSD 3.8, <inttypes.h> includes <machine\/types.h>, which defines\n-     int{8,16,32,64}_t, uint{8,16,32,64}_t and __BIT_TYPES_DEFINED__.\n-     <inttypes.h> also defines intptr_t and uintptr_t.  *\/\n-# include <inttypes.h>\n-#elif @HAVE_SYS_INTTYPES_H@\n-  \/* Solaris 7 <sys\/inttypes.h> has the types except the *_fast*_t types, and\n-     the macros except for *_FAST*_*, INTPTR_MIN, PTRDIFF_MIN, PTRDIFF_MAX.  *\/\n-# include <sys\/inttypes.h>\n-#endif\n-\n-#if @HAVE_SYS_BITYPES_H@ && ! defined __BIT_TYPES_DEFINED__\n-  \/* Linux libc4 >= 4.6.7 and libc5 have a <sys\/bitypes.h> that defines\n-     int{8,16,32,64}_t and __BIT_TYPES_DEFINED__.  In libc5 >= 5.2.2 it is\n-     included by <sys\/types.h>.  *\/\n-# include <sys\/bitypes.h>\n-#endif\n-\n-#undef _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H\n-\n-\/* Minimum and maximum values for an integer type under the usual assumption.\n-   Return an unspecified value if BITS == 0, adding a check to pacify\n-   picky compilers.  *\/\n-\n-#define _STDINT_MIN(signed, bits, zero) \\\n-  ((signed) ? (- ((zero) + 1) << ((bits) ? (bits) - 1 : 0)) : (zero))\n-\n-#define _STDINT_MAX(signed, bits, zero) \\\n-  ((signed) \\\n-   ? ~ _STDINT_MIN (signed, bits, zero) \\\n-   : \/* The expression for the unsigned case.  The subtraction of (signed) \\\n-        is a nop in the unsigned case and avoids \"signed integer overflow\" \\\n-        warnings in the signed case.  *\/ \\\n-     ((((zero) + 1) << ((bits) ? (bits) - 1 - (signed) : 0)) - 1) * 2 + 1)\n-\n-#if !GNULIB_defined_stdint_types\n-\n-\/* 7.18.1.1. Exact-width integer types *\/\n-\n-\/* Here we assume a standard architecture where the hardware integer\n-   types have 8, 16, 32, optionally 64 bits.  *\/\n-\n-#undef int8_t\n-#undef uint8_t\n-typedef signed char gl_int8_t;\n-typedef unsigned char gl_uint8_t;\n-#define int8_t gl_int8_t\n-#define uint8_t gl_uint8_t\n-\n-#undef int16_t\n-#undef uint16_t\n-typedef short int gl_int16_t;\n-typedef unsigned short int gl_uint16_t;\n-#define int16_t gl_int16_t\n-#define uint16_t gl_uint16_t\n-\n-#undef int32_t\n-#undef uint32_t\n-typedef int gl_int32_t;\n-typedef unsigned int gl_uint32_t;\n-#define int32_t gl_int32_t\n-#define uint32_t gl_uint32_t\n-\n-\/* If the system defines INT64_MAX, assume int64_t works.  That way,\n-   if the underlying platform defines int64_t to be a 64-bit long long\n-   int, the code below won't mistakenly define it to be a 64-bit long\n-   int, which would mess up C++ name mangling.  We must use #ifdef\n-   rather than #if, to avoid an error with HP-UX 10.20 cc.  *\/\n-\n-#ifdef INT64_MAX\n-# define GL_INT64_T\n-#else\n-\/* Do not undefine int64_t if gnulib is not being used with 64-bit\n-   types, since otherwise it breaks platforms like Tandem\/NSK.  *\/\n-# if LONG_MAX >> 31 >> 31 == 1\n-#  undef int64_t\n-typedef long int gl_int64_t;\n-#  define int64_t gl_int64_t\n-#  define GL_INT64_T\n-# elif defined _MSC_VER\n-#  undef int64_t\n-typedef __int64 gl_int64_t;\n-#  define int64_t gl_int64_t\n-#  define GL_INT64_T\n-# elif @HAVE_LONG_LONG_INT@\n-#  undef int64_t\n-typedef long long int gl_int64_t;\n-#  define int64_t gl_int64_t\n-#  define GL_INT64_T\n-# endif\n-#endif\n-\n-#ifdef UINT64_MAX\n-# define GL_UINT64_T\n-#else\n-# if ULONG_MAX >> 31 >> 31 >> 1 == 1\n-#  undef uint64_t\n-typedef unsigned long int gl_uint64_t;\n-#  define uint64_t gl_uint64_t\n-#  define GL_UINT64_T\n-# elif defined _MSC_VER\n-#  undef uint64_t\n-typedef unsigned __int64 gl_uint64_t;\n-#  define uint64_t gl_uint64_t\n-#  define GL_UINT64_T\n-# elif @HAVE_UNSIGNED_LONG_LONG_INT@\n-#  undef uint64_t\n-typedef unsigned long long int gl_uint64_t;\n-#  define uint64_t gl_uint64_t\n-#  define GL_UINT64_T\n-# endif\n-#endif\n-\n-\/* Avoid collision with Solaris 2.5.1 <pthread.h> etc.  *\/\n-#define _UINT8_T\n-#define _UINT32_T\n-#define _UINT64_T\n-\n-\n-\/* 7.18.1.2. Minimum-width integer types *\/\n-\n-\/* Here we assume a standard architecture where the hardware integer\n-   types have 8, 16, 32, optionally 64 bits. Therefore the leastN_t types\n-   are the same as the corresponding N_t types.  *\/\n-\n-#undef int_least8_t\n-#undef uint_least8_t\n-#undef int_least16_t\n-#undef uint_least16_t\n-#undef int_least32_t\n-#undef uint_least32_t\n-#undef int_least64_t\n-#undef uint_least64_t\n-#define int_least8_t int8_t\n-#define uint_least8_t uint8_t\n-#define int_least16_t int16_t\n-#define uint_least16_t uint16_t\n-#define int_least32_t int32_t\n-#define uint_least32_t uint32_t\n-#ifdef GL_INT64_T\n-# define int_least64_t int64_t\n-#endif\n-#ifdef GL_UINT64_T\n-# define uint_least64_t uint64_t\n-#endif\n-\n-\/* 7.18.1.3. Fastest minimum-width integer types *\/\n-\n-\/* Note: Other <stdint.h> substitutes may define these types differently.\n-   It is not recommended to use these types in public header files. *\/\n-\n-\/* Here we assume a standard architecture where the hardware integer\n-   types have 8, 16, 32, optionally 64 bits. Therefore the fastN_t types\n-   are taken from the same list of types.  The following code normally\n-   uses types consistent with glibc, as that lessens the chance of\n-   incompatibility with older GNU hosts.  *\/\n-\n-#undef int_fast8_t\n-#undef uint_fast8_t\n-#undef int_fast16_t\n-#undef uint_fast16_t\n-#undef int_fast32_t\n-#undef uint_fast32_t\n-#undef int_fast64_t\n-#undef uint_fast64_t\n-typedef signed char gl_int_fast8_t;\n-typedef unsigned char gl_uint_fast8_t;\n-\n-#ifdef __sun\n-\/* Define types compatible with SunOS 5.10, so that code compiled under\n-   earlier SunOS versions works with code compiled under SunOS 5.10.  *\/\n-typedef int gl_int_fast32_t;\n-typedef unsigned int gl_uint_fast32_t;\n-#else\n-typedef long int gl_int_fast32_t;\n-typedef unsigned long int gl_uint_fast32_t;\n-#endif\n-typedef gl_int_fast32_t gl_int_fast16_t;\n-typedef gl_uint_fast32_t gl_uint_fast16_t;\n-\n-#define int_fast8_t gl_int_fast8_t\n-#define uint_fast8_t gl_uint_fast8_t\n-#define int_fast16_t gl_int_fast16_t\n-#define uint_fast16_t gl_uint_fast16_t\n-#define int_fast32_t gl_int_fast32_t\n-#define uint_fast32_t gl_uint_fast32_t\n-#ifdef GL_INT64_T\n-# define int_fast64_t int64_t\n-#endif\n-#ifdef GL_UINT64_T\n-# define uint_fast64_t uint64_t\n-#endif\n-\n-\/* 7.18.1.4. Integer types capable of holding object pointers *\/\n-\n-#undef intptr_t\n-#undef uintptr_t\n-typedef long int gl_intptr_t;\n-typedef unsigned long int gl_uintptr_t;\n-#define intptr_t gl_intptr_t\n-#define uintptr_t gl_uintptr_t\n-\n-\/* 7.18.1.5. Greatest-width integer types *\/\n-\n-\/* Note: These types are compiler dependent. It may be unwise to use them in\n-   public header files. *\/\n-\n-\/* If the system defines INTMAX_MAX, assume that intmax_t works, and\n-   similarly for UINTMAX_MAX and uintmax_t.  This avoids problems with\n-   assuming one type where another is used by the system.  *\/\n-\n-#ifndef INTMAX_MAX\n-# undef INTMAX_C\n-# undef intmax_t\n-# if @HAVE_LONG_LONG_INT@ && LONG_MAX >> 30 == 1\n-typedef long long int gl_intmax_t;\n-#  define intmax_t gl_intmax_t\n-# elif defined GL_INT64_T\n-#  define intmax_t int64_t\n-# else\n-typedef long int gl_intmax_t;\n-#  define intmax_t gl_intmax_t\n-# endif\n-#endif\n-\n-#ifndef UINTMAX_MAX\n-# undef UINTMAX_C\n-# undef uintmax_t\n-# if @HAVE_UNSIGNED_LONG_LONG_INT@ && ULONG_MAX >> 31 == 1\n-typedef unsigned long long int gl_uintmax_t;\n-#  define uintmax_t gl_uintmax_t\n-# elif defined GL_UINT64_T\n-#  define uintmax_t uint64_t\n-# else\n-typedef unsigned long int gl_uintmax_t;\n-#  define uintmax_t gl_uintmax_t\n-# endif\n-#endif\n-\n-\/* Verify that intmax_t and uintmax_t have the same size.  Too much code\n-   breaks if this is not the case.  If this check fails, the reason is likely\n-   to be found in the autoconf macros.  *\/\n-typedef int _verify_intmax_size[sizeof (intmax_t) == sizeof (uintmax_t)\n-                                ? 1 : -1];\n-\n-#define GNULIB_defined_stdint_types 1\n-#endif \/* !GNULIB_defined_stdint_types *\/\n-\n-\/* 7.18.2. Limits of specified-width integer types *\/\n-\n-\/* 7.18.2.1. Limits of exact-width integer types *\/\n-\n-\/* Here we assume a standard architecture where the hardware integer\n-   types have 8, 16, 32, optionally 64 bits.  *\/\n-\n-#undef INT8_MIN\n-#undef INT8_MAX\n-#undef UINT8_MAX\n-#define INT8_MIN  (~ INT8_MAX)\n-#define INT8_MAX  127\n-#define UINT8_MAX  255\n-\n-#undef INT16_MIN\n-#undef INT16_MAX\n-#undef UINT16_MAX\n-#define INT16_MIN  (~ INT16_MAX)\n-#define INT16_MAX  32767\n-#define UINT16_MAX  65535\n-\n-#undef INT32_MIN\n-#undef INT32_MAX\n-#undef UINT32_MAX\n-#define INT32_MIN  (~ INT32_MAX)\n-#define INT32_MAX  2147483647\n-#define UINT32_MAX  4294967295U\n-\n-#if defined GL_INT64_T && ! defined INT64_MAX\n-\/* Prefer (- INTMAX_C (1) << 63) over (~ INT64_MAX) because SunPRO C 5.0\n-   evaluates the latter incorrectly in preprocessor expressions.  *\/\n-# define INT64_MIN  (- INTMAX_C (1) << 63)\n-# define INT64_MAX  INTMAX_C (9223372036854775807)\n-#endif\n-\n-#if defined GL_UINT64_T && ! defined UINT64_MAX\n-# define UINT64_MAX  UINTMAX_C (18446744073709551615)\n-#endif\n-\n-\/* 7.18.2.2. Limits of minimum-width integer types *\/\n-\n-\/* Here we assume a standard architecture where the hardware integer\n-   types have 8, 16, 32, optionally 64 bits. Therefore the leastN_t types\n-   are the same as the corresponding N_t types.  *\/\n-\n-#undef INT_LEAST8_MIN\n-#undef INT_LEAST8_MAX\n-#undef UINT_LEAST8_MAX\n-#define INT_LEAST8_MIN  INT8_MIN\n-#define INT_LEAST8_MAX  INT8_MAX\n-#define UINT_LEAST8_MAX  UINT8_MAX\n-\n-#undef INT_LEAST16_MIN\n-#undef INT_LEAST16_MAX\n-#undef UINT_LEAST16_MAX\n-#define INT_LEAST16_MIN  INT16_MIN\n-#define INT_LEAST16_MAX  INT16_MAX\n-#define UINT_LEAST16_MAX  UINT16_MAX\n-\n-#undef INT_LEAST32_MIN\n-#undef INT_LEAST32_MAX\n-#undef UINT_LEAST32_MAX\n-#define INT_LEAST32_MIN  INT32_MIN\n-#define INT_LEAST32_MAX  INT32_MAX\n-#define UINT_LEAST32_MAX  UINT32_MAX\n-\n-#undef INT_LEAST64_MIN\n-#undef INT_LEAST64_MAX\n-#ifdef GL_INT64_T\n-# define INT_LEAST64_MIN  INT64_MIN\n-# define INT_LEAST64_MAX  INT64_MAX\n-#endif\n-\n-#undef UINT_LEAST64_MAX\n-#ifdef GL_UINT64_T\n-# define UINT_LEAST64_MAX  UINT64_MAX\n-#endif\n-\n-\/* 7.18.2.3. Limits of fastest minimum-width integer types *\/\n-\n-\/* Here we assume a standard architecture where the hardware integer\n-   types have 8, 16, 32, optionally 64 bits. Therefore the fastN_t types\n-   are taken from the same list of types.  *\/\n-\n-#undef INT_FAST8_MIN\n-#undef INT_FAST8_MAX\n-#undef UINT_FAST8_MAX\n-#define INT_FAST8_MIN  SCHAR_MIN\n-#define INT_FAST8_MAX  SCHAR_MAX\n-#define UINT_FAST8_MAX  UCHAR_MAX\n-\n-#undef INT_FAST16_MIN\n-#undef INT_FAST16_MAX\n-#undef UINT_FAST16_MAX\n-#define INT_FAST16_MIN  INT_FAST32_MIN\n-#define INT_FAST16_MAX  INT_FAST32_MAX\n-#define UINT_FAST16_MAX  UINT_FAST32_MAX\n-\n-#undef INT_FAST32_MIN\n-#undef INT_FAST32_MAX\n-#undef UINT_FAST32_MAX\n-#ifdef __sun\n-# define INT_FAST32_MIN  INT_MIN\n-# define INT_FAST32_MAX  INT_MAX\n-# define UINT_FAST32_MAX  UINT_MAX\n-#else\n-# define INT_FAST32_MIN  LONG_MIN\n-# define INT_FAST32_MAX  LONG_MAX\n-# define UINT_FAST32_MAX  ULONG_MAX\n-#endif\n-\n-#undef INT_FAST64_MIN\n-#undef INT_FAST64_MAX\n-#ifdef GL_INT64_T\n-# define INT_FAST64_MIN  INT64_MIN\n-# define INT_FAST64_MAX  INT64_MAX\n-#endif\n-\n-#undef UINT_FAST64_MAX\n-#ifdef GL_UINT64_T\n-# define UINT_FAST64_MAX  UINT64_MAX\n-#endif\n-\n-\/* 7.18.2.4. Limits of integer types capable of holding object pointers *\/\n-\n-#undef INTPTR_MIN\n-#undef INTPTR_MAX\n-#undef UINTPTR_MAX\n-#define INTPTR_MIN  LONG_MIN\n-#define INTPTR_MAX  LONG_MAX\n-#define UINTPTR_MAX  ULONG_MAX\n-\n-\/* 7.18.2.5. Limits of greatest-width integer types *\/\n-\n-#ifndef INTMAX_MAX\n-# undef INTMAX_MIN\n-# ifdef INT64_MAX\n-#  define INTMAX_MIN  INT64_MIN\n-#  define INTMAX_MAX  INT64_MAX\n-# else\n-#  define INTMAX_MIN  INT32_MIN\n-#  define INTMAX_MAX  INT32_MAX\n-# endif\n-#endif\n-\n-#ifndef UINTMAX_MAX\n-# ifdef UINT64_MAX\n-#  define UINTMAX_MAX  UINT64_MAX\n-# else\n-#  define UINTMAX_MAX  UINT32_MAX\n-# endif\n-#endif\n-\n-\/* 7.18.3. Limits of other integer types *\/\n-\n-\/* ptrdiff_t limits *\/\n-#undef PTRDIFF_MIN\n-#undef PTRDIFF_MAX\n-#if @APPLE_UNIVERSAL_BUILD@\n-# ifdef _LP64\n-#  define PTRDIFF_MIN  _STDINT_MIN (1, 64, 0l)\n-#  define PTRDIFF_MAX  _STDINT_MAX (1, 64, 0l)\n-# else\n-#  define PTRDIFF_MIN  _STDINT_MIN (1, 32, 0)\n-#  define PTRDIFF_MAX  _STDINT_MAX (1, 32, 0)\n-# endif\n-#else\n-# define PTRDIFF_MIN  \\\n-    _STDINT_MIN (1, @BITSIZEOF_PTRDIFF_T@, 0@PTRDIFF_T_SUFFIX@)\n-# define PTRDIFF_MAX  \\\n-    _STDINT_MAX (1, @BITSIZEOF_PTRDIFF_T@, 0@PTRDIFF_T_SUFFIX@)\n-#endif\n-\n-\/* sig_atomic_t limits *\/\n-#undef SIG_ATOMIC_MIN\n-#undef SIG_ATOMIC_MAX\n-#define SIG_ATOMIC_MIN  \\\n-   _STDINT_MIN (@HAVE_SIGNED_SIG_ATOMIC_T@, @BITSIZEOF_SIG_ATOMIC_T@, \\\n-                0@SIG_ATOMIC_T_SUFFIX@)\n-#define SIG_ATOMIC_MAX  \\\n-   _STDINT_MAX (@HAVE_SIGNED_SIG_ATOMIC_T@, @BITSIZEOF_SIG_ATOMIC_T@, \\\n-                0@SIG_ATOMIC_T_SUFFIX@)\n-\n-\n-\/* size_t limit *\/\n-#undef SIZE_MAX\n-#if @APPLE_UNIVERSAL_BUILD@\n-# ifdef _LP64\n-#  define SIZE_MAX  _STDINT_MAX (0, 64, 0ul)\n-# else\n-#  define SIZE_MAX  _STDINT_MAX (0, 32, 0ul)\n-# endif\n-#else\n-# define SIZE_MAX  _STDINT_MAX (0, @BITSIZEOF_SIZE_T@, 0@SIZE_T_SUFFIX@)\n-#endif\n-\n-\/* wchar_t limits *\/\n-\/* Get WCHAR_MIN, WCHAR_MAX.\n-   This include is not on the top, above, because on OSF\/1 4.0 we have a\n-   sequence of nested includes\n-   <wchar.h> -> <stdio.h> -> <getopt.h> -> <stdlib.h>, and the latter includes\n-   <stdint.h> and assumes its types are already defined.  *\/\n-#if @HAVE_WCHAR_H@ && ! (defined WCHAR_MIN && defined WCHAR_MAX)\n-  \/* BSD\/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be\n-     included before <wchar.h>.  *\/\n-# include <stddef.h>\n-# include <stdio.h>\n-# include <time.h>\n-# define _GL_JUST_INCLUDE_SYSTEM_WCHAR_H\n-# include <wchar.h>\n-# undef _GL_JUST_INCLUDE_SYSTEM_WCHAR_H\n-#endif\n-#undef WCHAR_MIN\n-#undef WCHAR_MAX\n-#define WCHAR_MIN  \\\n-   _STDINT_MIN (@HAVE_SIGNED_WCHAR_T@, @BITSIZEOF_WCHAR_T@, 0@WCHAR_T_SUFFIX@)\n-#define WCHAR_MAX  \\\n-   _STDINT_MAX (@HAVE_SIGNED_WCHAR_T@, @BITSIZEOF_WCHAR_T@, 0@WCHAR_T_SUFFIX@)\n-\n-\/* wint_t limits *\/\n-#undef WINT_MIN\n-#undef WINT_MAX\n-#define WINT_MIN  \\\n-   _STDINT_MIN (@HAVE_SIGNED_WINT_T@, @BITSIZEOF_WINT_T@, 0@WINT_T_SUFFIX@)\n-#define WINT_MAX  \\\n-   _STDINT_MAX (@HAVE_SIGNED_WINT_T@, @BITSIZEOF_WINT_T@, 0@WINT_T_SUFFIX@)\n-\n-\/* 7.18.4. Macros for integer constants *\/\n-\n-\/* 7.18.4.1. Macros for minimum-width integer constants *\/\n-\/* According to ISO C 99 Technical Corrigendum 1 *\/\n-\n-\/* Here we assume a standard architecture where the hardware integer\n-   types have 8, 16, 32, optionally 64 bits, and int is 32 bits.  *\/\n-\n-#undef INT8_C\n-#undef UINT8_C\n-#define INT8_C(x) x\n-#define UINT8_C(x) x\n-\n-#undef INT16_C\n-#undef UINT16_C\n-#define INT16_C(x) x\n-#define UINT16_C(x) x\n-\n-#undef INT32_C\n-#undef UINT32_C\n-#define INT32_C(x) x\n-#define UINT32_C(x) x ## U\n-\n-#undef INT64_C\n-#undef UINT64_C\n-#if LONG_MAX >> 31 >> 31 == 1\n-# define INT64_C(x) x##L\n-#elif defined _MSC_VER\n-# define INT64_C(x) x##i64\n-#elif @HAVE_LONG_LONG_INT@\n-# define INT64_C(x) x##LL\n-#endif\n-#if ULONG_MAX >> 31 >> 31 >> 1 == 1\n-# define UINT64_C(x) x##UL\n-#elif defined _MSC_VER\n-# define UINT64_C(x) x##ui64\n-#elif @HAVE_UNSIGNED_LONG_LONG_INT@\n-# define UINT64_C(x) x##ULL\n-#endif\n-\n-\/* 7.18.4.2. Macros for greatest-width integer constants *\/\n-\n-#ifndef INTMAX_C\n-# if @HAVE_LONG_LONG_INT@ && LONG_MAX >> 30 == 1\n-#  define INTMAX_C(x)   x##LL\n-# elif defined GL_INT64_T\n-#  define INTMAX_C(x)   INT64_C(x)\n-# else\n-#  define INTMAX_C(x)   x##L\n-# endif\n-#endif\n-\n-#ifndef UINTMAX_C\n-# if @HAVE_UNSIGNED_LONG_LONG_INT@ && ULONG_MAX >> 31 == 1\n-#  define UINTMAX_C(x)  x##ULL\n-# elif defined GL_UINT64_T\n-#  define UINTMAX_C(x)  UINT64_C(x)\n-# else\n-#  define UINTMAX_C(x)  x##UL\n-# endif\n-#endif\n-\n-#endif \/* _@GUARD_PREFIX@_STDINT_H *\/\n-#endif \/* !(defined __ANDROID__ && ...) *\/\n-#endif \/* !defined _@GUARD_PREFIX@_STDINT_H && !defined _GL_JUST_INCLUDE_SYSTEM_STDINT_H *\/\ndiff --git a\/gltests\/stdlib.in.h b\/gltests\/stdlib.in.h\ndeleted file mode 100644\nindex 428a119..0000000\n--- a\/gltests\/stdlib.in.h\n+++ \/dev\/null\n@@ -1,977 +0,0 @@\n-\/* A GNU-like <stdlib.h>.\n-\n-   Copyright (C) 1995, 2001-2004, 2006-2015 Free Software Foundation, Inc.\n-\n-   This program is free software: you can redistribute it and\/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.  *\/\n-\n-#if __GNUC__ >= 3\n-@PRAGMA_SYSTEM_HEADER@\n-#endif\n-@PRAGMA_COLUMNS@\n-\n-#if defined __need_system_stdlib_h || defined __need_malloc_and_calloc\n-\/* Special invocation conventions inside some gnulib header files,\n-   and inside some glibc header files, respectively.  *\/\n-\n-#@INCLUDE_NEXT@ @NEXT_STDLIB_H@\n-\n-#else\n-\/* Normal invocation convention.  *\/\n-\n-#ifndef _@GUARD_PREFIX@_STDLIB_H\n-\n-\/* The include_next requires a split double-inclusion guard.  *\/\n-#@INCLUDE_NEXT@ @NEXT_STDLIB_H@\n-\n-#ifndef _@GUARD_PREFIX@_STDLIB_H\n-#define _@GUARD_PREFIX@_STDLIB_H\n-\n-\/* NetBSD 5.0 mis-defines NULL.  *\/\n-#include <stddef.h>\n-\n-\/* MirBSD 10 defines WEXITSTATUS in <sys\/wait.h>, not in <stdlib.h>.  *\/\n-#if @GNULIB_SYSTEM_POSIX@ && !defined WEXITSTATUS\n-# include <sys\/wait.h>\n-#endif\n-\n-\/* Solaris declares getloadavg() in <sys\/loadavg.h>.  *\/\n-#if (@GNULIB_GETLOADAVG@ || defined GNULIB_POSIXCHECK) && @HAVE_SYS_LOADAVG_H@\n-# include <sys\/loadavg.h>\n-#endif\n-\n-\/* Native Windows platforms declare mktemp() in <io.h>.  *\/\n-#if 0 && ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)\n-# include <io.h>\n-#endif\n-\n-#if @GNULIB_RANDOM_R@\n-\n-\/* OSF\/1 5.1 declares 'struct random_data' in <random.h>, which is included\n-   from <stdlib.h> if _REENTRANT is defined.  Include it whenever we need\n-   'struct random_data'.  *\/\n-# if @HAVE_RANDOM_H@\n-#  include <random.h>\n-# endif\n-\n-# if !@HAVE_STRUCT_RANDOM_DATA@ || @REPLACE_RANDOM_R@ || !@HAVE_RANDOM_R@\n-#  include <stdint.h>\n-# endif\n-\n-# if !@HAVE_STRUCT_RANDOM_DATA@\n-\/* Define 'struct random_data'.\n-   But allow multiple gnulib generated <stdlib.h> replacements to coexist.  *\/\n-#  if !GNULIB_defined_struct_random_data\n-struct random_data\n-{\n-  int32_t *fptr;                \/* Front pointer.  *\/\n-  int32_t *rptr;                \/* Rear pointer.  *\/\n-  int32_t *state;               \/* Array of state values.  *\/\n-  int rand_type;                \/* Type of random number generator.  *\/\n-  int rand_deg;                 \/* Degree of random number generator.  *\/\n-  int rand_sep;                 \/* Distance between front and rear.  *\/\n-  int32_t *end_ptr;             \/* Pointer behind state table.  *\/\n-};\n-#   define GNULIB_defined_struct_random_data 1\n-#  endif\n-# endif\n-#endif\n-\n-#if (@GNULIB_MKSTEMP@ || @GNULIB_MKSTEMPS@ || @GNULIB_GETSUBOPT@ || defined GNULIB_POSIXCHECK) && ! defined __GLIBC__ && !((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)\n-\/* On Mac OS X 10.3, only <unistd.h> declares mkstemp.  *\/\n-\/* On Mac OS X 10.5, only <unistd.h> declares mkstemps.  *\/\n-\/* On Cygwin 1.7.1, only <unistd.h> declares getsubopt.  *\/\n-\/* But avoid namespace pollution on glibc systems and native Windows.  *\/\n-# include <unistd.h>\n-#endif\n-\n-\/* The __attribute__ feature is available in gcc versions 2.5 and later.\n-   The attribute __pure__ was added in gcc 2.96.  *\/\n-#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)\n-# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))\n-#else\n-# define _GL_ATTRIBUTE_PURE \/* empty *\/\n-#endif\n-\n-\/* The definition of _Noreturn is copied here.  *\/\n-\n-\/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  *\/\n-\n-\/* The definition of _GL_ARG_NONNULL is copied here.  *\/\n-\n-\/* The definition of _GL_WARN_ON_USE is copied here.  *\/\n-\n-\n-\/* Some systems do not define EXIT_*, despite otherwise supporting C89.  *\/\n-#ifndef EXIT_SUCCESS\n-# define EXIT_SUCCESS 0\n-#endif\n-\/* Tandem\/NSK and other platforms that define EXIT_FAILURE as -1 interfere\n-   with proper operation of xargs.  *\/\n-#ifndef EXIT_FAILURE\n-# define EXIT_FAILURE 1\n-#elif EXIT_FAILURE != 1\n-# undef EXIT_FAILURE\n-# define EXIT_FAILURE 1\n-#endif\n-\n-\n-#if @GNULIB__EXIT@\n-\/* Terminate the current process with the given return code, without running\n-   the 'atexit' handlers.  *\/\n-# if !@HAVE__EXIT@\n-_GL_FUNCDECL_SYS (_Exit, _Noreturn void, (int status));\n-# endif\n-_GL_CXXALIAS_SYS (_Exit, void, (int status));\n-_GL_CXXALIASWARN (_Exit);\n-#elif defined GNULIB_POSIXCHECK\n-# undef _Exit\n-# if HAVE_RAW_DECL__EXIT\n-_GL_WARN_ON_USE (_Exit, \"_Exit is unportable - \"\n-                 \"use gnulib module _Exit for portability\");\n-# endif\n-#endif\n-\n-\n-#if @GNULIB_ATOLL@\n-\/* Parse a signed decimal integer.\n-   Returns the value of the integer.  Errors are not detected.  *\/\n-# if !@HAVE_ATOLL@\n-_GL_FUNCDECL_SYS (atoll, long long, (const char *string)\n-                                    _GL_ATTRIBUTE_PURE\n-                                    _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (atoll, long long, (const char *string));\n-_GL_CXXALIASWARN (atoll);\n-#elif defined GNULIB_POSIXCHECK\n-# undef atoll\n-# if HAVE_RAW_DECL_ATOLL\n-_GL_WARN_ON_USE (atoll, \"atoll is unportable - \"\n-                 \"use gnulib module atoll for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_CALLOC_POSIX@\n-# if @REPLACE_CALLOC@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef calloc\n-#   define calloc rpl_calloc\n-#  endif\n-_GL_FUNCDECL_RPL (calloc, void *, (size_t nmemb, size_t size));\n-_GL_CXXALIAS_RPL (calloc, void *, (size_t nmemb, size_t size));\n-# else\n-_GL_CXXALIAS_SYS (calloc, void *, (size_t nmemb, size_t size));\n-# endif\n-_GL_CXXALIASWARN (calloc);\n-#elif defined GNULIB_POSIXCHECK\n-# undef calloc\n-\/* Assume calloc is always declared.  *\/\n-_GL_WARN_ON_USE (calloc, \"calloc is not POSIX compliant everywhere - \"\n-                 \"use gnulib module calloc-posix for portability\");\n-#endif\n-\n-#if @GNULIB_CANONICALIZE_FILE_NAME@\n-# if @REPLACE_CANONICALIZE_FILE_NAME@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   define canonicalize_file_name rpl_canonicalize_file_name\n-#  endif\n-_GL_FUNCDECL_RPL (canonicalize_file_name, char *, (const char *name)\n-                                                  _GL_ARG_NONNULL ((1)));\n-_GL_CXXALIAS_RPL (canonicalize_file_name, char *, (const char *name));\n-# else\n-#  if !@HAVE_CANONICALIZE_FILE_NAME@\n-_GL_FUNCDECL_SYS (canonicalize_file_name, char *, (const char *name)\n-                                                  _GL_ARG_NONNULL ((1)));\n-#  endif\n-_GL_CXXALIAS_SYS (canonicalize_file_name, char *, (const char *name));\n-# endif\n-_GL_CXXALIASWARN (canonicalize_file_name);\n-#elif defined GNULIB_POSIXCHECK\n-# undef canonicalize_file_name\n-# if HAVE_RAW_DECL_CANONICALIZE_FILE_NAME\n-_GL_WARN_ON_USE (canonicalize_file_name,\n-                 \"canonicalize_file_name is unportable - \"\n-                 \"use gnulib module canonicalize-lgpl for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_GETLOADAVG@\n-\/* Store max(NELEM,3) load average numbers in LOADAVG[].\n-   The three numbers are the load average of the last 1 minute, the last 5\n-   minutes, and the last 15 minutes, respectively.\n-   LOADAVG is an array of NELEM numbers.  *\/\n-# if !@HAVE_DECL_GETLOADAVG@\n-_GL_FUNCDECL_SYS (getloadavg, int, (double loadavg[], int nelem)\n-                                   _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (getloadavg, int, (double loadavg[], int nelem));\n-_GL_CXXALIASWARN (getloadavg);\n-#elif defined GNULIB_POSIXCHECK\n-# undef getloadavg\n-# if HAVE_RAW_DECL_GETLOADAVG\n-_GL_WARN_ON_USE (getloadavg, \"getloadavg is not portable - \"\n-                 \"use gnulib module getloadavg for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_GETSUBOPT@\n-\/* Assuming *OPTIONP is a comma separated list of elements of the form\n-   \"token\" or \"token=value\", getsubopt parses the first of these elements.\n-   If the first element refers to a \"token\" that is member of the given\n-   NULL-terminated array of tokens:\n-     - It replaces the comma with a NUL byte, updates *OPTIONP to point past\n-       the first option and the comma, sets *VALUEP to the value of the\n-       element (or NULL if it doesn't contain an \"=\" sign),\n-     - It returns the index of the \"token\" in the given array of tokens.\n-   Otherwise it returns -1, and *OPTIONP and *VALUEP are undefined.\n-   For more details see the POSIX:2001 specification.\n-   http:\/\/www.opengroup.org\/susv3xsh\/getsubopt.html *\/\n-# if !@HAVE_GETSUBOPT@\n-_GL_FUNCDECL_SYS (getsubopt, int,\n-                  (char **optionp, char *const *tokens, char **valuep)\n-                  _GL_ARG_NONNULL ((1, 2, 3)));\n-# endif\n-_GL_CXXALIAS_SYS (getsubopt, int,\n-                  (char **optionp, char *const *tokens, char **valuep));\n-_GL_CXXALIASWARN (getsubopt);\n-#elif defined GNULIB_POSIXCHECK\n-# undef getsubopt\n-# if HAVE_RAW_DECL_GETSUBOPT\n-_GL_WARN_ON_USE (getsubopt, \"getsubopt is unportable - \"\n-                 \"use gnulib module getsubopt for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_GRANTPT@\n-\/* Change the ownership and access permission of the slave side of the\n-   pseudo-terminal whose master side is specified by FD.  *\/\n-# if !@HAVE_GRANTPT@\n-_GL_FUNCDECL_SYS (grantpt, int, (int fd));\n-# endif\n-_GL_CXXALIAS_SYS (grantpt, int, (int fd));\n-_GL_CXXALIASWARN (grantpt);\n-#elif defined GNULIB_POSIXCHECK\n-# undef grantpt\n-# if HAVE_RAW_DECL_GRANTPT\n-_GL_WARN_ON_USE (grantpt, \"grantpt is not portable - \"\n-                 \"use gnulib module grantpt for portability\");\n-# endif\n-#endif\n-\n-\/* If _GL_USE_STDLIB_ALLOC is nonzero, the including module does not\n-   rely on GNU or POSIX semantics for malloc and realloc (for example,\n-   by never specifying a zero size), so it does not need malloc or\n-   realloc to be redefined.  *\/\n-#if @GNULIB_MALLOC_POSIX@\n-# if @REPLACE_MALLOC@\n-#  if !((defined __cplusplus && defined GNULIB_NAMESPACE) \\\n-        || _GL_USE_STDLIB_ALLOC)\n-#   undef malloc\n-#   define malloc rpl_malloc\n-#  endif\n-_GL_FUNCDECL_RPL (malloc, void *, (size_t size));\n-_GL_CXXALIAS_RPL (malloc, void *, (size_t size));\n-# else\n-_GL_CXXALIAS_SYS (malloc, void *, (size_t size));\n-# endif\n-_GL_CXXALIASWARN (malloc);\n-#elif defined GNULIB_POSIXCHECK && !_GL_USE_STDLIB_ALLOC\n-# undef malloc\n-\/* Assume malloc is always declared.  *\/\n-_GL_WARN_ON_USE (malloc, \"malloc is not POSIX compliant everywhere - \"\n-                 \"use gnulib module malloc-posix for portability\");\n-#endif\n-\n-\/* Convert a multibyte character to a wide character.  *\/\n-#if @GNULIB_MBTOWC@\n-# if @REPLACE_MBTOWC@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef mbtowc\n-#   define mbtowc rpl_mbtowc\n-#  endif\n-_GL_FUNCDECL_RPL (mbtowc, int, (wchar_t *pwc, const char *s, size_t n));\n-_GL_CXXALIAS_RPL (mbtowc, int, (wchar_t *pwc, const char *s, size_t n));\n-# else\n-_GL_CXXALIAS_SYS (mbtowc, int, (wchar_t *pwc, const char *s, size_t n));\n-# endif\n-_GL_CXXALIASWARN (mbtowc);\n-#endif\n-\n-#if @GNULIB_MKDTEMP@\n-\/* Create a unique temporary directory from TEMPLATE.\n-   The last six characters of TEMPLATE must be \"XXXXXX\";\n-   they are replaced with a string that makes the directory name unique.\n-   Returns TEMPLATE, or a null pointer if it cannot get a unique name.\n-   The directory is created mode 700.  *\/\n-# if !@HAVE_MKDTEMP@\n-_GL_FUNCDECL_SYS (mkdtemp, char *, (char * \/*template*\/) _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (mkdtemp, char *, (char * \/*template*\/));\n-_GL_CXXALIASWARN (mkdtemp);\n-#elif defined GNULIB_POSIXCHECK\n-# undef mkdtemp\n-# if HAVE_RAW_DECL_MKDTEMP\n-_GL_WARN_ON_USE (mkdtemp, \"mkdtemp is unportable - \"\n-                 \"use gnulib module mkdtemp for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_MKOSTEMP@\n-\/* Create a unique temporary file from TEMPLATE.\n-   The last six characters of TEMPLATE must be \"XXXXXX\";\n-   they are replaced with a string that makes the file name unique.\n-   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)\n-   and O_TEXT, O_BINARY (defined in \"binary-io.h\").\n-   The file is then created, with the specified flags, ensuring it didn't exist\n-   before.\n-   The file is created read-write (mask at least 0600 & ~umask), but it may be\n-   world-readable and world-writable (mask 0666 & ~umask), depending on the\n-   implementation.\n-   Returns the open file descriptor if successful, otherwise -1 and errno\n-   set.  *\/\n-# if !@HAVE_MKOSTEMP@\n-_GL_FUNCDECL_SYS (mkostemp, int, (char * \/*template*\/, int \/*flags*\/)\n-                                 _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (mkostemp, int, (char * \/*template*\/, int \/*flags*\/));\n-_GL_CXXALIASWARN (mkostemp);\n-#elif defined GNULIB_POSIXCHECK\n-# undef mkostemp\n-# if HAVE_RAW_DECL_MKOSTEMP\n-_GL_WARN_ON_USE (mkostemp, \"mkostemp is unportable - \"\n-                 \"use gnulib module mkostemp for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_MKOSTEMPS@\n-\/* Create a unique temporary file from TEMPLATE.\n-   The last six characters of TEMPLATE before a suffix of length\n-   SUFFIXLEN must be \"XXXXXX\";\n-   they are replaced with a string that makes the file name unique.\n-   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)\n-   and O_TEXT, O_BINARY (defined in \"binary-io.h\").\n-   The file is then created, with the specified flags, ensuring it didn't exist\n-   before.\n-   The file is created read-write (mask at least 0600 & ~umask), but it may be\n-   world-readable and world-writable (mask 0666 & ~umask), depending on the\n-   implementation.\n-   Returns the open file descriptor if successful, otherwise -1 and errno\n-   set.  *\/\n-# if !@HAVE_MKOSTEMPS@\n-_GL_FUNCDECL_SYS (mkostemps, int,\n-                  (char * \/*template*\/, int \/*suffixlen*\/, int \/*flags*\/)\n-                  _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (mkostemps, int,\n-                  (char * \/*template*\/, int \/*suffixlen*\/, int \/*flags*\/));\n-_GL_CXXALIASWARN (mkostemps);\n-#elif defined GNULIB_POSIXCHECK\n-# undef mkostemps\n-# if HAVE_RAW_DECL_MKOSTEMPS\n-_GL_WARN_ON_USE (mkostemps, \"mkostemps is unportable - \"\n-                 \"use gnulib module mkostemps for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_MKSTEMP@\n-\/* Create a unique temporary file from TEMPLATE.\n-   The last six characters of TEMPLATE must be \"XXXXXX\";\n-   they are replaced with a string that makes the file name unique.\n-   The file is then created, ensuring it didn't exist before.\n-   The file is created read-write (mask at least 0600 & ~umask), but it may be\n-   world-readable and world-writable (mask 0666 & ~umask), depending on the\n-   implementation.\n-   Returns the open file descriptor if successful, otherwise -1 and errno\n-   set.  *\/\n-# if @REPLACE_MKSTEMP@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   define mkstemp rpl_mkstemp\n-#  endif\n-_GL_FUNCDECL_RPL (mkstemp, int, (char * \/*template*\/) _GL_ARG_NONNULL ((1)));\n-_GL_CXXALIAS_RPL (mkstemp, int, (char * \/*template*\/));\n-# else\n-#  if ! @HAVE_MKSTEMP@\n-_GL_FUNCDECL_SYS (mkstemp, int, (char * \/*template*\/) _GL_ARG_NONNULL ((1)));\n-#  endif\n-_GL_CXXALIAS_SYS (mkstemp, int, (char * \/*template*\/));\n-# endif\n-_GL_CXXALIASWARN (mkstemp);\n-#elif defined GNULIB_POSIXCHECK\n-# undef mkstemp\n-# if HAVE_RAW_DECL_MKSTEMP\n-_GL_WARN_ON_USE (mkstemp, \"mkstemp is unportable - \"\n-                 \"use gnulib module mkstemp for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_MKSTEMPS@\n-\/* Create a unique temporary file from TEMPLATE.\n-   The last six characters of TEMPLATE prior to a suffix of length\n-   SUFFIXLEN must be \"XXXXXX\";\n-   they are replaced with a string that makes the file name unique.\n-   The file is then created, ensuring it didn't exist before.\n-   The file is created read-write (mask at least 0600 & ~umask), but it may be\n-   world-readable and world-writable (mask 0666 & ~umask), depending on the\n-   implementation.\n-   Returns the open file descriptor if successful, otherwise -1 and errno\n-   set.  *\/\n-# if !@HAVE_MKSTEMPS@\n-_GL_FUNCDECL_SYS (mkstemps, int, (char * \/*template*\/, int \/*suffixlen*\/)\n-                                 _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (mkstemps, int, (char * \/*template*\/, int \/*suffixlen*\/));\n-_GL_CXXALIASWARN (mkstemps);\n-#elif defined GNULIB_POSIXCHECK\n-# undef mkstemps\n-# if HAVE_RAW_DECL_MKSTEMPS\n-_GL_WARN_ON_USE (mkstemps, \"mkstemps is unportable - \"\n-                 \"use gnulib module mkstemps for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_POSIX_OPENPT@\n-\/* Return an FD open to the master side of a pseudo-terminal.  Flags should\n-   include O_RDWR, and may also include O_NOCTTY.  *\/\n-# if !@HAVE_POSIX_OPENPT@\n-_GL_FUNCDECL_SYS (posix_openpt, int, (int flags));\n-# endif\n-_GL_CXXALIAS_SYS (posix_openpt, int, (int flags));\n-_GL_CXXALIASWARN (posix_openpt);\n-#elif defined GNULIB_POSIXCHECK\n-# undef posix_openpt\n-# if HAVE_RAW_DECL_POSIX_OPENPT\n-_GL_WARN_ON_USE (posix_openpt, \"posix_openpt is not portable - \"\n-                 \"use gnulib module posix_openpt for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_PTSNAME@\n-\/* Return the pathname of the pseudo-terminal slave associated with\n-   the master FD is open on, or NULL on errors.  *\/\n-# if @REPLACE_PTSNAME@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef ptsname\n-#   define ptsname rpl_ptsname\n-#  endif\n-_GL_FUNCDECL_RPL (ptsname, char *, (int fd));\n-_GL_CXXALIAS_RPL (ptsname, char *, (int fd));\n-# else\n-#  if !@HAVE_PTSNAME@\n-_GL_FUNCDECL_SYS (ptsname, char *, (int fd));\n-#  endif\n-_GL_CXXALIAS_SYS (ptsname, char *, (int fd));\n-# endif\n-_GL_CXXALIASWARN (ptsname);\n-#elif defined GNULIB_POSIXCHECK\n-# undef ptsname\n-# if HAVE_RAW_DECL_PTSNAME\n-_GL_WARN_ON_USE (ptsname, \"ptsname is not portable - \"\n-                 \"use gnulib module ptsname for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_PTSNAME_R@\n-\/* Set the pathname of the pseudo-terminal slave associated with\n-   the master FD is open on and return 0, or set errno and return\n-   non-zero on errors.  *\/\n-# if @REPLACE_PTSNAME_R@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef ptsname_r\n-#   define ptsname_r rpl_ptsname_r\n-#  endif\n-_GL_FUNCDECL_RPL (ptsname_r, int, (int fd, char *buf, size_t len));\n-_GL_CXXALIAS_RPL (ptsname_r, int, (int fd, char *buf, size_t len));\n-# else\n-#  if !@HAVE_PTSNAME_R@\n-_GL_FUNCDECL_SYS (ptsname_r, int, (int fd, char *buf, size_t len));\n-#  endif\n-_GL_CXXALIAS_SYS (ptsname_r, int, (int fd, char *buf, size_t len));\n-# endif\n-_GL_CXXALIASWARN (ptsname_r);\n-#elif defined GNULIB_POSIXCHECK\n-# undef ptsname_r\n-# if HAVE_RAW_DECL_PTSNAME_R\n-_GL_WARN_ON_USE (ptsname_r, \"ptsname_r is not portable - \"\n-                 \"use gnulib module ptsname_r for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_PUTENV@\n-# if @REPLACE_PUTENV@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef putenv\n-#   define putenv rpl_putenv\n-#  endif\n-_GL_FUNCDECL_RPL (putenv, int, (char *string) _GL_ARG_NONNULL ((1)));\n-_GL_CXXALIAS_RPL (putenv, int, (char *string));\n-# else\n-_GL_CXXALIAS_SYS (putenv, int, (char *string));\n-# endif\n-_GL_CXXALIASWARN (putenv);\n-#endif\n-\n-#if @GNULIB_QSORT_R@\n-# if @REPLACE_QSORT_R@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef qsort_r\n-#   define qsort_r rpl_qsort_r\n-#  endif\n-_GL_FUNCDECL_RPL (qsort_r, void, (void *base, size_t nmemb, size_t size,\n-                                  int (*compare) (void const *, void const *,\n-                                                  void *),\n-                                  void *arg) _GL_ARG_NONNULL ((1, 4)));\n-_GL_CXXALIAS_RPL (qsort_r, void, (void *base, size_t nmemb, size_t size,\n-                                  int (*compare) (void const *, void const *,\n-                                                  void *),\n-                                  void *arg));\n-# else\n-_GL_CXXALIAS_SYS (qsort_r, void, (void *base, size_t nmemb, size_t size,\n-                                  int (*compare) (void const *, void const *,\n-                                                  void *),\n-                                  void *arg));\n-# endif\n-_GL_CXXALIASWARN (qsort_r);\n-#endif\n-\n-\n-#if @GNULIB_RANDOM_R@\n-# if !@HAVE_RANDOM_R@\n-#  ifndef RAND_MAX\n-#   define RAND_MAX 2147483647\n-#  endif\n-# endif\n-#endif\n-\n-\n-#if @GNULIB_RANDOM@\n-# if !@HAVE_RANDOM@\n-_GL_FUNCDECL_SYS (random, long, (void));\n-# endif\n-_GL_CXXALIAS_SYS (random, long, (void));\n-_GL_CXXALIASWARN (random);\n-#elif defined GNULIB_POSIXCHECK\n-# undef random\n-# if HAVE_RAW_DECL_RANDOM\n-_GL_WARN_ON_USE (random, \"random is unportable - \"\n-                 \"use gnulib module random for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_RANDOM@\n-# if !@HAVE_RANDOM@\n-_GL_FUNCDECL_SYS (srandom, void, (unsigned int seed));\n-# endif\n-_GL_CXXALIAS_SYS (srandom, void, (unsigned int seed));\n-_GL_CXXALIASWARN (srandom);\n-#elif defined GNULIB_POSIXCHECK\n-# undef srandom\n-# if HAVE_RAW_DECL_SRANDOM\n-_GL_WARN_ON_USE (srandom, \"srandom is unportable - \"\n-                 \"use gnulib module random for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_RANDOM@\n-# if !@HAVE_RANDOM@\n-_GL_FUNCDECL_SYS (initstate, char *,\n-                  (unsigned int seed, char *buf, size_t buf_size)\n-                  _GL_ARG_NONNULL ((2)));\n-# endif\n-_GL_CXXALIAS_SYS (initstate, char *,\n-                  (unsigned int seed, char *buf, size_t buf_size));\n-_GL_CXXALIASWARN (initstate);\n-#elif defined GNULIB_POSIXCHECK\n-# undef initstate\n-# if HAVE_RAW_DECL_INITSTATE_R\n-_GL_WARN_ON_USE (initstate, \"initstate is unportable - \"\n-                 \"use gnulib module random for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_RANDOM@\n-# if !@HAVE_RANDOM@\n-_GL_FUNCDECL_SYS (setstate, char *, (char *arg_state) _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (setstate, char *, (char *arg_state));\n-_GL_CXXALIASWARN (setstate);\n-#elif defined GNULIB_POSIXCHECK\n-# undef setstate\n-# if HAVE_RAW_DECL_SETSTATE_R\n-_GL_WARN_ON_USE (setstate, \"setstate is unportable - \"\n-                 \"use gnulib module random for portability\");\n-# endif\n-#endif\n-\n-\n-#if @GNULIB_RANDOM_R@\n-# if @REPLACE_RANDOM_R@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef random_r\n-#   define random_r rpl_random_r\n-#  endif\n-_GL_FUNCDECL_RPL (random_r, int, (struct random_data *buf, int32_t *result)\n-                                 _GL_ARG_NONNULL ((1, 2)));\n-_GL_CXXALIAS_RPL (random_r, int, (struct random_data *buf, int32_t *result));\n-# else\n-#  if !@HAVE_RANDOM_R@\n-_GL_FUNCDECL_SYS (random_r, int, (struct random_data *buf, int32_t *result)\n-                                 _GL_ARG_NONNULL ((1, 2)));\n-#  endif\n-_GL_CXXALIAS_SYS (random_r, int, (struct random_data *buf, int32_t *result));\n-# endif\n-_GL_CXXALIASWARN (random_r);\n-#elif defined GNULIB_POSIXCHECK\n-# undef random_r\n-# if HAVE_RAW_DECL_RANDOM_R\n-_GL_WARN_ON_USE (random_r, \"random_r is unportable - \"\n-                 \"use gnulib module random_r for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_RANDOM_R@\n-# if @REPLACE_RANDOM_R@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef srandom_r\n-#   define srandom_r rpl_srandom_r\n-#  endif\n-_GL_FUNCDECL_RPL (srandom_r, int,\n-                  (unsigned int seed, struct random_data *rand_state)\n-                  _GL_ARG_NONNULL ((2)));\n-_GL_CXXALIAS_RPL (srandom_r, int,\n-                  (unsigned int seed, struct random_data *rand_state));\n-# else\n-#  if !@HAVE_RANDOM_R@\n-_GL_FUNCDECL_SYS (srandom_r, int,\n-                  (unsigned int seed, struct random_data *rand_state)\n-                  _GL_ARG_NONNULL ((2)));\n-#  endif\n-_GL_CXXALIAS_SYS (srandom_r, int,\n-                  (unsigned int seed, struct random_data *rand_state));\n-# endif\n-_GL_CXXALIASWARN (srandom_r);\n-#elif defined GNULIB_POSIXCHECK\n-# undef srandom_r\n-# if HAVE_RAW_DECL_SRANDOM_R\n-_GL_WARN_ON_USE (srandom_r, \"srandom_r is unportable - \"\n-                 \"use gnulib module random_r for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_RANDOM_R@\n-# if @REPLACE_RANDOM_R@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef initstate_r\n-#   define initstate_r rpl_initstate_r\n-#  endif\n-_GL_FUNCDECL_RPL (initstate_r, int,\n-                  (unsigned int seed, char *buf, size_t buf_size,\n-                   struct random_data *rand_state)\n-                  _GL_ARG_NONNULL ((2, 4)));\n-_GL_CXXALIAS_RPL (initstate_r, int,\n-                  (unsigned int seed, char *buf, size_t buf_size,\n-                   struct random_data *rand_state));\n-# else\n-#  if !@HAVE_RANDOM_R@\n-_GL_FUNCDECL_SYS (initstate_r, int,\n-                  (unsigned int seed, char *buf, size_t buf_size,\n-                   struct random_data *rand_state)\n-                  _GL_ARG_NONNULL ((2, 4)));\n-#  endif\n-_GL_CXXALIAS_SYS (initstate_r, int,\n-                  (unsigned int seed, char *buf, size_t buf_size,\n-                   struct random_data *rand_state));\n-# endif\n-_GL_CXXALIASWARN (initstate_r);\n-#elif defined GNULIB_POSIXCHECK\n-# undef initstate_r\n-# if HAVE_RAW_DECL_INITSTATE_R\n-_GL_WARN_ON_USE (initstate_r, \"initstate_r is unportable - \"\n-                 \"use gnulib module random_r for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_RANDOM_R@\n-# if @REPLACE_RANDOM_R@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef setstate_r\n-#   define setstate_r rpl_setstate_r\n-#  endif\n-_GL_FUNCDECL_RPL (setstate_r, int,\n-                  (char *arg_state, struct random_data *rand_state)\n-                  _GL_ARG_NONNULL ((1, 2)));\n-_GL_CXXALIAS_RPL (setstate_r, int,\n-                  (char *arg_state, struct random_data *rand_state));\n-# else\n-#  if !@HAVE_RANDOM_R@\n-_GL_FUNCDECL_SYS (setstate_r, int,\n-                  (char *arg_state, struct random_data *rand_state)\n-                  _GL_ARG_NONNULL ((1, 2)));\n-#  endif\n-_GL_CXXALIAS_SYS (setstate_r, int,\n-                  (char *arg_state, struct random_data *rand_state));\n-# endif\n-_GL_CXXALIASWARN (setstate_r);\n-#elif defined GNULIB_POSIXCHECK\n-# undef setstate_r\n-# if HAVE_RAW_DECL_SETSTATE_R\n-_GL_WARN_ON_USE (setstate_r, \"setstate_r is unportable - \"\n-                 \"use gnulib module random_r for portability\");\n-# endif\n-#endif\n-\n-\n-#if @GNULIB_REALLOC_POSIX@\n-# if @REPLACE_REALLOC@\n-#  if !((defined __cplusplus && defined GNULIB_NAMESPACE) \\\n-        || _GL_USE_STDLIB_ALLOC)\n-#   undef realloc\n-#   define realloc rpl_realloc\n-#  endif\n-_GL_FUNCDECL_RPL (realloc, void *, (void *ptr, size_t size));\n-_GL_CXXALIAS_RPL (realloc, void *, (void *ptr, size_t size));\n-# else\n-_GL_CXXALIAS_SYS (realloc, void *, (void *ptr, size_t size));\n-# endif\n-_GL_CXXALIASWARN (realloc);\n-#elif defined GNULIB_POSIXCHECK && !_GL_USE_STDLIB_ALLOC\n-# undef realloc\n-\/* Assume realloc is always declared.  *\/\n-_GL_WARN_ON_USE (realloc, \"realloc is not POSIX compliant everywhere - \"\n-                 \"use gnulib module realloc-posix for portability\");\n-#endif\n-\n-#if @GNULIB_REALPATH@\n-# if @REPLACE_REALPATH@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   define realpath rpl_realpath\n-#  endif\n-_GL_FUNCDECL_RPL (realpath, char *, (const char *name, char *resolved)\n-                                    _GL_ARG_NONNULL ((1)));\n-_GL_CXXALIAS_RPL (realpath, char *, (const char *name, char *resolved));\n-# else\n-#  if !@HAVE_REALPATH@\n-_GL_FUNCDECL_SYS (realpath, char *, (const char *name, char *resolved)\n-                                    _GL_ARG_NONNULL ((1)));\n-#  endif\n-_GL_CXXALIAS_SYS (realpath, char *, (const char *name, char *resolved));\n-# endif\n-_GL_CXXALIASWARN (realpath);\n-#elif defined GNULIB_POSIXCHECK\n-# undef realpath\n-# if HAVE_RAW_DECL_REALPATH\n-_GL_WARN_ON_USE (realpath, \"realpath is unportable - use gnulib module \"\n-                 \"canonicalize or canonicalize-lgpl for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_RPMATCH@\n-\/* Test a user response to a question.\n-   Return 1 if it is affirmative, 0 if it is negative, or -1 if not clear.  *\/\n-# if !@HAVE_RPMATCH@\n-_GL_FUNCDECL_SYS (rpmatch, int, (const char *response) _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (rpmatch, int, (const char *response));\n-_GL_CXXALIASWARN (rpmatch);\n-#elif defined GNULIB_POSIXCHECK\n-# undef rpmatch\n-# if HAVE_RAW_DECL_RPMATCH\n-_GL_WARN_ON_USE (rpmatch, \"rpmatch is unportable - \"\n-                 \"use gnulib module rpmatch for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_SECURE_GETENV@\n-\/* Look up NAME in the environment, returning 0 in insecure situations.  *\/\n-# if !@HAVE_SECURE_GETENV@\n-_GL_FUNCDECL_SYS (secure_getenv, char *,\n-                  (char const *name) _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (secure_getenv, char *, (char const *name));\n-_GL_CXXALIASWARN (secure_getenv);\n-#elif defined GNULIB_POSIXCHECK\n-# undef secure_getenv\n-# if HAVE_RAW_DECL_SECURE_GETENV\n-_GL_WARN_ON_USE (secure_getenv, \"secure_getenv is unportable - \"\n-                 \"use gnulib module secure_getenv for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_SETENV@\n-\/* Set NAME to VALUE in the environment.\n-   If REPLACE is nonzero, overwrite an existing value.  *\/\n-# if @REPLACE_SETENV@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef setenv\n-#   define setenv rpl_setenv\n-#  endif\n-_GL_FUNCDECL_RPL (setenv, int,\n-                  (const char *name, const char *value, int replace)\n-                  _GL_ARG_NONNULL ((1)));\n-_GL_CXXALIAS_RPL (setenv, int,\n-                  (const char *name, const char *value, int replace));\n-# else\n-#  if !@HAVE_DECL_SETENV@\n-_GL_FUNCDECL_SYS (setenv, int,\n-                  (const char *name, const char *value, int replace)\n-                  _GL_ARG_NONNULL ((1)));\n-#  endif\n-_GL_CXXALIAS_SYS (setenv, int,\n-                  (const char *name, const char *value, int replace));\n-# endif\n-# if !(@REPLACE_SETENV@ && !@HAVE_DECL_SETENV@)\n-_GL_CXXALIASWARN (setenv);\n-# endif\n-#elif defined GNULIB_POSIXCHECK\n-# undef setenv\n-# if HAVE_RAW_DECL_SETENV\n-_GL_WARN_ON_USE (setenv, \"setenv is unportable - \"\n-                 \"use gnulib module setenv for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_STRTOD@\n- \/* Parse a double from STRING, updating ENDP if appropriate.  *\/\n-# if @REPLACE_STRTOD@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   define strtod rpl_strtod\n-#  endif\n-_GL_FUNCDECL_RPL (strtod, double, (const char *str, char **endp)\n-                                  _GL_ARG_NONNULL ((1)));\n-_GL_CXXALIAS_RPL (strtod, double, (const char *str, char **endp));\n-# else\n-#  if !@HAVE_STRTOD@\n-_GL_FUNCDECL_SYS (strtod, double, (const char *str, char **endp)\n-                                  _GL_ARG_NONNULL ((1)));\n-#  endif\n-_GL_CXXALIAS_SYS (strtod, double, (const char *str, char **endp));\n-# endif\n-_GL_CXXALIASWARN (strtod);\n-#elif defined GNULIB_POSIXCHECK\n-# undef strtod\n-# if HAVE_RAW_DECL_STRTOD\n-_GL_WARN_ON_USE (strtod, \"strtod is unportable - \"\n-                 \"use gnulib module strtod for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_STRTOLL@\n-\/* Parse a signed integer whose textual representation starts at STRING.\n-   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,\n-   it may be decimal or octal (with prefix \"0\") or hexadecimal (with prefix\n-   \"0x\").\n-   If ENDPTR is not NULL, the address of the first byte after the integer is\n-   stored in *ENDPTR.\n-   Upon overflow, the return value is LLONG_MAX or LLONG_MIN, and errno is set\n-   to ERANGE.  *\/\n-# if !@HAVE_STRTOLL@\n-_GL_FUNCDECL_SYS (strtoll, long long,\n-                  (const char *string, char **endptr, int base)\n-                  _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (strtoll, long long,\n-                  (const char *string, char **endptr, int base));\n-_GL_CXXALIASWARN (strtoll);\n-#elif defined GNULIB_POSIXCHECK\n-# undef strtoll\n-# if HAVE_RAW_DECL_STRTOLL\n-_GL_WARN_ON_USE (strtoll, \"strtoll is unportable - \"\n-                 \"use gnulib module strtoll for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_STRTOULL@\n-\/* Parse an unsigned integer whose textual representation starts at STRING.\n-   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,\n-   it may be decimal or octal (with prefix \"0\") or hexadecimal (with prefix\n-   \"0x\").\n-   If ENDPTR is not NULL, the address of the first byte after the integer is\n-   stored in *ENDPTR.\n-   Upon overflow, the return value is ULLONG_MAX, and errno is set to\n-   ERANGE.  *\/\n-# if !@HAVE_STRTOULL@\n-_GL_FUNCDECL_SYS (strtoull, unsigned long long,\n-                  (const char *string, char **endptr, int base)\n-                  _GL_ARG_NONNULL ((1)));\n-# endif\n-_GL_CXXALIAS_SYS (strtoull, unsigned long long,\n-                  (const char *string, char **endptr, int base));\n-_GL_CXXALIASWARN (strtoull);\n-#elif defined GNULIB_POSIXCHECK\n-# undef strtoull\n-# if HAVE_RAW_DECL_STRTOULL\n-_GL_WARN_ON_USE (strtoull, \"strtoull is unportable - \"\n-                 \"use gnulib module strtoull for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_UNLOCKPT@\n-\/* Unlock the slave side of the pseudo-terminal whose master side is specified\n-   by FD, so that it can be opened.  *\/\n-# if !@HAVE_UNLOCKPT@\n-_GL_FUNCDECL_SYS (unlockpt, int, (int fd));\n-# endif\n-_GL_CXXALIAS_SYS (unlockpt, int, (int fd));\n-_GL_CXXALIASWARN (unlockpt);\n-#elif defined GNULIB_POSIXCHECK\n-# undef unlockpt\n-# if HAVE_RAW_DECL_UNLOCKPT\n-_GL_WARN_ON_USE (unlockpt, \"unlockpt is not portable - \"\n-                 \"use gnulib module unlockpt for portability\");\n-# endif\n-#endif\n-\n-#if @GNULIB_UNSETENV@\n-\/* Remove the variable NAME from the environment.  *\/\n-# if @REPLACE_UNSETENV@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef unsetenv\n-#   define unsetenv rpl_unsetenv\n-#  endif\n-_GL_FUNCDECL_RPL (unsetenv, int, (const char *name) _GL_ARG_NONNULL ((1)));\n-_GL_CXXALIAS_RPL (unsetenv, int, (const char *name));\n-# else\n-#  if !@HAVE_DECL_UNSETENV@\n-_GL_FUNCDECL_SYS (unsetenv, int, (const char *name) _GL_ARG_NONNULL ((1)));\n-#  endif\n-_GL_CXXALIAS_SYS (unsetenv, int, (const char *name));\n-# endif\n-# if !(@REPLACE_UNSETENV@ && !@HAVE_DECL_UNSETENV@)\n-_GL_CXXALIASWARN (unsetenv);\n-# endif\n-#elif defined GNULIB_POSIXCHECK\n-# undef unsetenv\n-# if HAVE_RAW_DECL_UNSETENV\n-_GL_WARN_ON_USE (unsetenv, \"unsetenv is unportable - \"\n-                 \"use gnulib module unsetenv for portability\");\n-# endif\n-#endif\n-\n-\/* Convert a wide character to a multibyte character.  *\/\n-#if @GNULIB_WCTOMB@\n-# if @REPLACE_WCTOMB@\n-#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)\n-#   undef wctomb\n-#   define wctomb rpl_wctomb\n-#  endif\n-_GL_FUNCDECL_RPL (wctomb, int, (char *s, wchar_t wc));\n-_GL_CXXALIAS_RPL (wctomb, int, (char *s, wchar_t wc));\n-# else\n-_GL_CXXALIAS_SYS (wctomb, int, (char *s, wchar_t wc));\n-# endif\n-_GL_CXXALIASWARN (wctomb);\n-#endif\n-\n-\n-#endif \/* _@GUARD_PREFIX@_STDLIB_H *\/\n-#endif \/* _@GUARD_PREFIX@_STDLIB_H *\/\n-#endif\ndiff --git a\/gltests\/test-getdelim.c b\/gltests\/test-getdelim.c\nnew file mode 100644\nindex 0000000..bbcc3cd\n--- \/dev\/null\n+++ b\/gltests\/test-getdelim.c\n@@ -0,0 +1,94 @@\n+\/* Test of getdelim() function.\n+   Copyright (C) 2007-2015 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and\/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, see <http:\/\/www.gnu.org\/licenses\/>.  *\/\n+\n+\/* Written by Eric Blake <ebb9@byu.net>, 2007.  *\/\n+\n+#include <config.h>\n+\n+#include <stdio.h>\n+\n+#include \"signature.h\"\n+SIGNATURE_CHECK (getdelim, ssize_t, (char **, size_t *, int, FILE *));\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"macros.h\"\n+\n+int\n+main (void)\n+{\n+  FILE *f;\n+  char *line;\n+  size_t len;\n+  ssize_t result;\n+\n+  \/* Create test file.  *\/\n+  f = fopen (\"test-getdelim.txt\", \"wb\");\n+  if (!f || fwrite (\"anAnbcnd\\0f\", 1, 10, f) != 10 || fclose (f) != 0)\n+    {\n+      fputs (\"Failed to create sample file.\\n\", stderr);\n+      remove (\"test-getdelim.txt\");\n+      return 1;\n+    }\n+  f = fopen (\"test-getdelim.txt\", \"rb\");\n+  if (!f)\n+    {\n+      fputs (\"Failed to reopen sample file.\\n\", stderr);\n+      remove (\"test-getdelim.txt\");\n+      return 1;\n+    }\n+\n+  \/* Test initial allocation, which must include trailing NUL.  *\/\n+  line = NULL;\n+  len = 0;\n+  result = getdelim (&line, &len, 'n', f);\n+  ASSERT (result == 2);\n+  ASSERT (strcmp (line, \"an\") == 0);\n+  ASSERT (2 < len);\n+  free (line);\n+\n+  \/* Test initial allocation again, with line = NULL and len != 0.  *\/\n+  line = NULL;\n+  len = (size_t)(~0) \/ 4;\n+  result = getdelim (&line, &len, 'n', f);\n+  ASSERT (result == 2);\n+  ASSERT (strcmp (line, \"An\") == 0);\n+  ASSERT (2 < len);\n+  free (line);\n+\n+  \/* Test growth of buffer.  *\/\n+  line = malloc (1);\n+  len = 1;\n+  result = getdelim (&line, &len, 'n', f);\n+  ASSERT (result == 3);\n+  ASSERT (strcmp (line, \"bcn\") == 0);\n+  ASSERT (3 < len);\n+\n+  \/* Test embedded NULs and EOF behavior.  *\/\n+  result = getdelim (&line, &len, 'n', f);\n+  ASSERT (result == 3);\n+  ASSERT (memcmp (line, \"d\\0f\", 4) == 0);\n+  ASSERT (3 < len);\n+\n+  result = getdelim (&line, &len, 'n', f);\n+  ASSERT (result == -1);\n+\n+  free (line);\n+  fclose (f);\n+  remove (\"test-getdelim.txt\");\n+  return 0;\n+}\ndiff --git a\/gltests\/test-getline.c b\/gltests\/test-getline.c\nnew file mode 100644\nindex 0000000..238742c\n--- \/dev\/null\n+++ b\/gltests\/test-getline.c\n@@ -0,0 +1,94 @@\n+\/* Test of getline() function.\n+   Copyright (C) 2007-2015 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and\/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, see <http:\/\/www.gnu.org\/licenses\/>.  *\/\n+\n+\/* Written by Eric Blake <ebb9@byu.net>, 2007.  *\/\n+\n+#include <config.h>\n+\n+#include <stdio.h>\n+\n+#include \"signature.h\"\n+SIGNATURE_CHECK (getline, ssize_t, (char **, size_t *, FILE *));\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"macros.h\"\n+\n+int\n+main (void)\n+{\n+  FILE *f;\n+  char *line;\n+  size_t len;\n+  ssize_t result;\n+\n+  \/* Create test file.  *\/\n+  f = fopen (\"test-getline.txt\", \"wb\");\n+  if (!f || fwrite (\"a\\nA\\nbc\\nd\\0f\", 1, 10, f) != 10 || fclose (f) != 0)\n+    {\n+      fputs (\"Failed to create sample file.\\n\", stderr);\n+      remove (\"test-getline.txt\");\n+      return 1;\n+    }\n+  f = fopen (\"test-getline.txt\", \"rb\");\n+  if (!f)\n+    {\n+      fputs (\"Failed to reopen sample file.\\n\", stderr);\n+      remove (\"test-getline.txt\");\n+      return 1;\n+    }\n+\n+  \/* Test initial allocation, which must include trailing NUL.  *\/\n+  line = NULL;\n+  len = 0;\n+  result = getline (&line, &len, f);\n+  ASSERT (result == 2);\n+  ASSERT (strcmp (line, \"a\\n\") == 0);\n+  ASSERT (2 < len);\n+  free (line);\n+\n+  \/* Test initial allocation again, with line = NULL and len != 0.  *\/\n+  line = NULL;\n+  len = (size_t)(~0) \/ 4;\n+  result = getline (&line, &len, f);\n+  ASSERT (result == 2);\n+  ASSERT (strcmp (line, \"A\\n\") == 0);\n+  ASSERT (2 < len);\n+  free (line);\n+\n+  \/* Test growth of buffer, must not leak.  *\/\n+  line = malloc (1);\n+  len = 0;\n+  result = getline (&line, &len, f);\n+  ASSERT (result == 3);\n+  ASSERT (strcmp (line, \"bc\\n\") == 0);\n+  ASSERT (3 < len);\n+\n+  \/* Test embedded NULs and EOF behavior.  *\/\n+  result = getline (&line, &len, f);\n+  ASSERT (result == 3);\n+  ASSERT (memcmp (line, \"d\\0f\", 4) == 0);\n+  ASSERT (3 < len);\n+\n+  result = getline (&line, &len, f);\n+  ASSERT (result == -1);\n+\n+  free (line);\n+  fclose (f);\n+  remove (\"test-getline.txt\");\n+  return 0;\n+}\ndiff --git a\/src\/idn.c b\/src\/idn.c\nindex 0d32bbf..23fa843 100644\n--- a\/src\/idn.c\n+++ b\/src\/idn.c\n@@ -126,7 +126,8 @@ int\n main (int argc, char *argv[])\n {\n   struct gengetopt_args_info args_info;\n-  char readbuf[BUFSIZ];\n+  char *line = NULL;\n+  size_t linelen = 0;\n   char *p, *r;\n   uint32_t *q;\n   unsigned cmdn = 0;\n@@ -190,11 +191,8 @@ main (int argc, char *argv[])\n   do\n     {\n       if (cmdn < args_info.inputs_num)\n-\t{\n-\t  strncpy (readbuf, args_info.inputs[cmdn++], BUFSIZ - 1);\n-\t  readbuf[BUFSIZ - 1] = '\\0';\n-\t}\n-      else if (fgets (readbuf, BUFSIZ, stdin) == NULL)\n+\tline = strdup (args_info.inputs[cmdn++]);\n+      else if (getline (&line, &linelen, stdin) == -1)\n \t{\n \t  if (feof (stdin))\n \t    break;\n@@ -202,12 +200,12 @@ main (int argc, char *argv[])\n \t  error (EXIT_FAILURE, errno, _(\"input error\"));\n \t}\n \n-      if (readbuf[strlen (readbuf) - 1] == '\\n')\n-\treadbuf[strlen (readbuf) - 1] = '\\0';\n+      if (line[strlen (line) - 1] == '\\n')\n+\tline[strlen (line) - 1] = '\\0';\n \n       if (args_info.stringprep_given)\n \t{\n-\t  p = stringprep_locale_to_utf8 (readbuf);\n+\t  p = stringprep_locale_to_utf8 (line);\n \t  if (!p)\n \t    error (EXIT_FAILURE, 0, _(\"could not convert from %s to UTF-8\"),\n \t\t   stringprep_locale_charset ());\n@@ -267,9 +265,10 @@ main (int argc, char *argv[])\n \n       if (args_info.punycode_encode_given)\n \t{\n+\t  char encbuf[BUFSIZ];\n \t  size_t len, len2;\n \n-\t  p = stringprep_locale_to_utf8 (readbuf);\n+\t  p = stringprep_locale_to_utf8 (line);\n \t  if (!p)\n \t    error (EXIT_FAILURE, 0, _(\"could not convert from %s to UTF-8\"),\n \t\t   stringprep_locale_charset ());\n@@ -289,15 +288,15 @@ main (int argc, char *argv[])\n \t    }\n \n \t  len2 = BUFSIZ - 1;\n-\t  rc = punycode_encode (len, q, NULL, &len2, readbuf);\n+\t  rc = punycode_encode (len, q, NULL, &len2, encbuf);\n \t  free (q);\n \t  if (rc != PUNYCODE_SUCCESS)\n \t    error (EXIT_FAILURE, 0, _(\"punycode_encode: %s\"),\n \t\t   punycode_strerror (rc));\n \n-\t  readbuf[len2] = '\\0';\n+\t  encbuf[len2] = '\\0';\n \n-\t  p = stringprep_utf8_to_locale (readbuf);\n+\t  p = stringprep_utf8_to_locale (encbuf);\n \t  if (!p)\n \t    error (EXIT_FAILURE, 0, _(\"could not convert from UTF-8 to %s\"),\n \t\t   stringprep_locale_charset ());\n@@ -316,7 +315,7 @@ main (int argc, char *argv[])\n \t  if (!q)\n \t    error (EXIT_FAILURE, ENOMEM, N_(\"malloc\"));\n \n-\t  rc = punycode_decode (strlen (readbuf), readbuf, &len, q, NULL);\n+\t  rc = punycode_decode (strlen (line), line, &len, q, NULL);\n \t  if (rc != PUNYCODE_SUCCESS)\n \t    {\n \t      free (q);\n@@ -352,7 +351,7 @@ main (int argc, char *argv[])\n \n       if (args_info.idna_to_ascii_given)\n \t{\n-\t  p = stringprep_locale_to_utf8 (readbuf);\n+\t  p = stringprep_locale_to_utf8 (line);\n \t  if (!p)\n \t    error (EXIT_FAILURE, 0, _(\"could not convert from %s to UTF-8\"),\n \t\t   stringprep_locale_charset ());\n@@ -429,7 +428,7 @@ main (int argc, char *argv[])\n \n       if (args_info.idna_to_unicode_given)\n \t{\n-\t  p = stringprep_locale_to_utf8 (readbuf);\n+\t  p = stringprep_locale_to_utf8 (line);\n \t  if (!p)\n \t    error (EXIT_FAILURE, 0, _(\"could not convert from %s to UTF-8\"),\n \t\t   stringprep_locale_charset ());\n@@ -510,7 +509,7 @@ main (int argc, char *argv[])\n \n       if (args_info.nfkc_given)\n \t{\n-\t  p = stringprep_locale_to_utf8 (readbuf);\n+\t  p = stringprep_locale_to_utf8 (line);\n \t  if (!p)\n \t    error (EXIT_FAILURE, 0, _(\"could not convert from %s to UTF-8\"),\n \t\t   stringprep_locale_charset ());\n@@ -574,5 +573,7 @@ main (int argc, char *argv[])\n   while (!feof (stdin) && !ferror (stdin) && (args_info.inputs_num == 0 ||\n \t\t\t\t\t      cmdn < args_info.inputs_num));\n \n+  free (line);\n+\n   return EXIT_SUCCESS;\n }\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9434","CWE_ID":"125","category":"security","commit_id":"07dbcc3d9644b18e05c1776db2a57fe04d780965","commit_message":"From 07dbcc3d9644b18e05c1776db2a57fe04d780965 Mon Sep 17 00:00:00 2001\nFrom: Jeffrey Walton <noloader@gmail.com>\nDate: Wed, 10 May 2017 18:17:12 -0400\nSubject: [PATCH] Add Inflator::BadDistanceErr exception (Issue 414) The\n improved validation and excpetion clears the Address Sanitizer and Undefined\n Behavior Sanitizer findings\n\n---\n validat1.cpp | 6 +++---\n zinflate.cpp | 8 +++++++-\n zinflate.h   | 4 ++++\n 3 files changed, 14 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/validat1.cpp b\/validat1.cpp\nindex cd8655b4..e81a46c6 100644\n--- a\/validat1.cpp\n+++ b\/validat1.cpp\n@@ -623,7 +623,7 @@ bool TestRandomPool()\n \t\t\tstd::cout << \"FAILED:\";\n \t\telse\n \t\t\tstd::cout << \"passed:\";\n-\t\tstd::cout << \"  GenerateWord32 and Crop\\n\";\t\n+\t\tstd::cout << \"  GenerateWord32 and Crop\\n\";\n \t}\n \n #if !defined(NO_OS_DEPENDENCE)\n@@ -711,7 +711,7 @@ bool TestRandomPool()\n \t\t\tstd::cout << \"FAILED:\";\n \t\telse\n \t\t\tstd::cout << \"passed:\";\n-\t\tstd::cout << \"  GenerateWord32 and Crop\\n\";\t\n+\t\tstd::cout << \"  GenerateWord32 and Crop\\n\";\n \t}\n #endif\n \n@@ -808,7 +808,7 @@ bool TestAutoSeededX917()\n \t\tstd::cout << \"FAILED:\";\n \telse\n \t\tstd::cout << \"passed:\";\n-\tstd::cout << \"  GenerateWord32 and Crop\\n\";\t\n+\tstd::cout << \"  GenerateWord32 and Crop\\n\";\n \n \tstd::cout.flush();\n \treturn pass;\ndiff --git a\/zinflate.cpp b\/zinflate.cpp\nindex 62431771..ee15c945 100644\n--- a\/zinflate.cpp\n+++ b\/zinflate.cpp\n@@ -552,12 +552,18 @@ bool Inflator::DecodeBody()\n \t\tcase DISTANCE_BITS:\n \t\t\t\t\t\/\/ TODO: this surfaced during fuzzing. What do we do???\n \t\t\t\t\tCRYPTOPP_ASSERT(m_distance < COUNTOF(distanceExtraBits));\n-\t\t\t\t\tbits = (m_distance >= COUNTOF(distanceExtraBits)) ? distanceExtraBits[29] : distanceExtraBits[m_distance];\n+\t\t\t\t\tif (m_distance >= COUNTOF(distanceExtraBits))\n+\t\t\t\t\t\tthrow BadDistanceErr();\n+\t\t\t\t\tbits = distanceExtraBits[m_distance];\n \t\t\t\t\tif (!m_reader.FillBuffer(bits))\n \t\t\t\t\t{\n \t\t\t\t\t\tm_nextDecode = DISTANCE_BITS;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n+\t\t\t\t\t\/\/ TODO: this surfaced during fuzzing. What do we do???\n+\t\t\t\t\tCRYPTOPP_ASSERT(m_distance < COUNTOF(distanceStarts));\n+\t\t\t\t\tif (m_distance >= COUNTOF(distanceStarts))\n+\t\t\t\t\t\tthrow BadDistanceErr();\n \t\t\t\t\tm_distance = m_reader.GetBits(bits) + distanceStarts[m_distance];\n \t\t\t\t\tOutputPast(m_literal, m_distance);\n \t\t\t\t}\ndiff --git a\/zinflate.h b\/zinflate.h\nindex b0879cef..0767d4f9 100644\n--- a\/zinflate.h\n+++ b\/zinflate.h\n@@ -98,8 +98,12 @@ class Inflator : public AutoSignaling<Filter>\n \t\tErr(ErrorType e, const std::string &s)\n \t\t\t: Exception(e, s) {}\n \t};\n+\t\/\/! \\brief Exception thrown when a truncated stream is encountered\n \tclass UnexpectedEndErr : public Err {public: UnexpectedEndErr() : Err(INVALID_DATA_FORMAT, \"Inflator: unexpected end of compressed block\") {}};\n+\t\/\/! \\brief Exception thrown when a bad block is encountered\n \tclass BadBlockErr : public Err {public: BadBlockErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in compressed block\") {}};\n+\t\/\/! \\brief Exception thrown when an invalid distance is encountered\n+\tclass BadDistanceErr : public Err {public: BadDistanceErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in bit distance\") {}};\n \n \t\/\/! \\brief RFC 1951 Decompressor\n \t\/\/! \\param attachment the filter's attached transformation\n","owner":"weidai11","repo":"cryptopp","source":"cve"},{"CVE_ID":"CVE-2018-9841","CWE_ID":"125","category":"security","commit_id":"35eeff30caf34df835206f1c12bcf4b7c2bd6758","commit_message":"From 35eeff30caf34df835206f1c12bcf4b7c2bd6758 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Fri, 30 Mar 2018 02:16:31 +0200\nSubject: [PATCH] avfilter\/vf_signature: use av_strlcpy()\n\nFixes: out of array access\n\nFound-by: Kira <kira_cxy@foxmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavfilter\/vf_signature.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavfilter\/vf_signature.c b\/libavfilter\/vf_signature.c\nindex f0078ba1a6..d07b213f31 100644\n--- a\/libavfilter\/vf_signature.c\n+++ b\/libavfilter\/vf_signature.c\n@@ -576,7 +576,8 @@ static int export(AVFilterContext *ctx, StreamContext *sc, int input)\n         \/* error already handled *\/\n         av_assert0(av_get_frame_filename(filename, sizeof(filename), sic->filename, input) == 0);\n     } else {\n-        strcpy(filename, sic->filename);\n+        if (av_strlcpy(filename, sic->filename, sizeof(filename)) >= sizeof(filename))\n+            return AVERROR(EINVAL);\n     }\n     if (sic->format == FORMAT_XML) {\n         return xml_export(ctx, sc, filename);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6800","CWE_ID":"125","category":"security","commit_id":"f98f5d4adc1c4bd4033638f6167c1bb95d642f89","commit_message":"From f98f5d4adc1c4bd4033638f6167c1bb95d642f89 Mon Sep 17 00:00:00 2001\nFrom: Randall Hand <randall.hand@gmail.com>\nDate: Thu, 23 Feb 2017 14:26:49 -0500\nSubject: [PATCH] BugFix - data length\n\nEven tho this is a \"LONG\" type, it's actually only 4 bytes. Typecasting\nit to a long* caused a dereference beyond the end of the allocated\nregion.\n\nissues#28\n---\n lib\/ytnef.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/lib\/ytnef.c b\/lib\/ytnef.c\nindex c11c77c..afb2efb 100644\n--- a\/lib\/ytnef.c\n+++ b\/lib\/ytnef.c\n@@ -1390,7 +1390,7 @@ void MAPIPrint(MAPIProps *p) {\n           printf(\"] (%llu)\\n\", ddword_tmp);\n           break;\n         case PT_LONG:\n-          printf(\"    Value: %li\\n\", *((long*)mapidata->data));\n+          printf(\"    Value: %i\\n\", *((int*)mapidata->data));\n           break;\n         case PT_I2:\n           printf(\"    Value: %hi\\n\", *((short int*)mapidata->data));\n","owner":"Yeraze","repo":"ytnef","source":"cve"},{"CVE_ID":"CVE-2016-9777","CWE_ID":"125","category":"security","commit_id":"81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755","commit_message":"From 81cdb259fb6d8c1c4ecfeea389ff5a73c07f5755 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Radim=20Kr=C4=8Dm=C3=A1=C5=99?= <rkrcmar@redhat.com>\nDate: Wed, 23 Nov 2016 21:15:27 +0100\nSubject: [PATCH] KVM: x86: fix out-of-bounds accesses of rtc_eoi map\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nKVM was using arrays of size KVM_MAX_VCPUS with vcpu_id, but ID can be\nbigger that the maximal number of VCPUs, resulting in out-of-bounds\naccess.\n\nFound by syzkaller:\n\n  BUG: KASAN: slab-out-of-bounds in __apic_accept_irq+0xb33\/0xb50 at addr [...]\n  Write of size 1 by task a.out\/27101\n  CPU: 1 PID: 27101 Comm: a.out Not tainted 4.9.0-rc5+ #49\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01\/01\/2011\n   [...]\n  Call Trace:\n   [...] __apic_accept_irq+0xb33\/0xb50 arch\/x86\/kvm\/lapic.c:905\n   [...] kvm_apic_set_irq+0x10e\/0x180 arch\/x86\/kvm\/lapic.c:495\n   [...] kvm_irq_delivery_to_apic+0x732\/0xc10 arch\/x86\/kvm\/irq_comm.c:86\n   [...] ioapic_service+0x41d\/0x760 arch\/x86\/kvm\/ioapic.c:360\n   [...] ioapic_set_irq+0x275\/0x6c0 arch\/x86\/kvm\/ioapic.c:222\n   [...] kvm_ioapic_inject_all arch\/x86\/kvm\/ioapic.c:235\n   [...] kvm_set_ioapic+0x223\/0x310 arch\/x86\/kvm\/ioapic.c:670\n   [...] kvm_vm_ioctl_set_irqchip arch\/x86\/kvm\/x86.c:3668\n   [...] kvm_arch_vm_ioctl+0x1a08\/0x23c0 arch\/x86\/kvm\/x86.c:3999\n   [...] kvm_vm_ioctl+0x1fa\/0x1a70 arch\/x86\/kvm\/..\/..\/..\/virt\/kvm\/kvm_main.c:3099\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nCc: stable@vger.kernel.org\nFixes: af1bae5497b9 (\"KVM: x86: bump KVM_MAX_VCPU_ID to 1023\")\nReviewed-by: Paolo Bonzini <pbonzini@redhat.com>\nReviewed-by: David Hildenbrand <david@redhat.com>\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>\n---\n arch\/x86\/kvm\/ioapic.c | 2 +-\n arch\/x86\/kvm\/ioapic.h | 4 ++--\n 2 files changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/ioapic.c b\/arch\/x86\/kvm\/ioapic.c\nindex 1a22de70f7f7d..6e219e5c07d27 100644\n--- a\/arch\/x86\/kvm\/ioapic.c\n+++ b\/arch\/x86\/kvm\/ioapic.c\n@@ -94,7 +94,7 @@ static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n {\n \tioapic->rtc_status.pending_eoi = 0;\n-\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n+\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n }\n \n static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\ndiff --git a\/arch\/x86\/kvm\/ioapic.h b\/arch\/x86\/kvm\/ioapic.h\nindex 7d2692a496575..1cc6e54436dba 100644\n--- a\/arch\/x86\/kvm\/ioapic.h\n+++ b\/arch\/x86\/kvm\/ioapic.h\n@@ -42,13 +42,13 @@ struct kvm_vcpu;\n \n struct dest_map {\n \t\/* vcpu bitmap where IRQ has been sent *\/\n-\tDECLARE_BITMAP(map, KVM_MAX_VCPUS);\n+\tDECLARE_BITMAP(map, KVM_MAX_VCPU_ID);\n \n \t\/*\n \t * Vector sent to a given vcpu, only valid when\n \t * the vcpu's bit in map is set\n \t *\/\n-\tu8 vectors[KVM_MAX_VCPUS];\n+\tu8 vectors[KVM_MAX_VCPU_ID];\n };\n \n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5897","CWE_ID":"125","category":"security","commit_id":"7892032cfe67f4bde6fc2ee967e45a8fbaf33756","commit_message":"From 7892032cfe67f4bde6fc2ee967e45a8fbaf33756 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Sat, 4 Feb 2017 23:18:55 -0800\nSubject: ip6_gre: fix ip6gre_err() invalid reads\n\nAndrey Konovalov reported out of bound accesses in ip6gre_err()\n\nIf GRE flags contains GRE_KEY, the following expression\n*(((__be32 *)p) + (grehlen \/ 4) - 1)\n\naccesses data ~40 bytes after the expected point, since\ngrehlen includes the size of IPv6 headers.\n\nLet's use a \"struct gre_base_hdr *greh\" pointer to make this\ncode more readable.\n\np[1] becomes greh->protocol.\ngrhlen is the GRE header length.\n\nFixes: c12b395a4664 (\"gre: Support GRE over IPv6\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/ip6_gre.c | 40 +++++++++++++++++++++-------------------\n 1 file changed, 21 insertions(+), 19 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/ip6_gre.c b\/net\/ipv6\/ip6_gre.c\nindex 558631860d91..630b73be5999 100644\n--- a\/net\/ipv6\/ip6_gre.c\n+++ b\/net\/ipv6\/ip6_gre.c\n@@ -367,35 +367,37 @@ static void ip6gre_tunnel_uninit(struct net_device *dev)\n \n \n static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt,\n-\t\tu8 type, u8 code, int offset, __be32 info)\n+\t\t       u8 type, u8 code, int offset, __be32 info)\n {\n-\tconst struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data;\n-\t__be16 *p = (__be16 *)(skb->data + offset);\n-\tint grehlen = offset + 4;\n+\tconst struct gre_base_hdr *greh;\n+\tconst struct ipv6hdr *ipv6h;\n+\tint grehlen = sizeof(*greh);\n \tstruct ip6_tnl *t;\n+\tint key_off = 0;\n \t__be16 flags;\n+\t__be32 key;\n \n-\tflags = p[0];\n-\tif (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) {\n-\t\tif (flags&(GRE_VERSION|GRE_ROUTING))\n-\t\t\treturn;\n-\t\tif (flags&GRE_KEY) {\n-\t\t\tgrehlen += 4;\n-\t\t\tif (flags&GRE_CSUM)\n-\t\t\t\tgrehlen += 4;\n-\t\t}\n+\tif (!pskb_may_pull(skb, offset + grehlen))\n+\t\treturn;\n+\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n+\tflags = greh->flags;\n+\tif (flags & (GRE_VERSION | GRE_ROUTING))\n+\t\treturn;\n+\tif (flags & GRE_CSUM)\n+\t\tgrehlen += 4;\n+\tif (flags & GRE_KEY) {\n+\t\tkey_off = grehlen + offset;\n+\t\tgrehlen += 4;\n \t}\n \n-\t\/* If only 8 bytes returned, keyed message will be dropped here *\/\n-\tif (!pskb_may_pull(skb, grehlen))\n+\tif (!pskb_may_pull(skb, offset + grehlen))\n \t\treturn;\n \tipv6h = (const struct ipv6hdr *)skb->data;\n-\tp = (__be16 *)(skb->data + offset);\n+\tgreh = (const struct gre_base_hdr *)(skb->data + offset);\n+\tkey = key_off ? *(__be32 *)(skb->data + key_off) : 0;\n \n \tt = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr,\n-\t\t\t\tflags & GRE_KEY ?\n-\t\t\t\t*(((__be32 *)p) + (grehlen \/ 4) - 1) : 0,\n-\t\t\t\tp[1]);\n+\t\t\t\t key, greh->protocol);\n \tif (!t)\n \t\treturn;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-19841","CWE_ID":"125","category":"security","commit_id":"bba5389dc598a92bdf2b297c3ea34620b6679b5b","commit_message":"From bba5389dc598a92bdf2b297c3ea34620b6679b5b Mon Sep 17 00:00:00 2001\nFrom: David Bryant <david@wavpack.com>\nDate: Thu, 29 Nov 2018 21:53:51 -0800\nSubject: [PATCH] issue #54: fix potential out-of-bounds heap read\n\n---\n src\/open_utils.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/open_utils.c b\/src\/open_utils.c\nindex 80051fc..4fe0d67 100644\n--- a\/src\/open_utils.c\n+++ b\/src\/open_utils.c\n@@ -1258,13 +1258,13 @@ int WavpackVerifySingleBlock (unsigned char *buffer, int verify_checksum)\n #endif\n \n             if (meta_bc == 4) {\n-                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))\n+                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff))\n                     return FALSE;\n             }\n             else {\n                 csum ^= csum >> 16;\n \n-                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))\n+                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff))\n                     return FALSE;\n             }\n \n","owner":"dbry","repo":"WavPack","source":"cve"},{"CVE_ID":"CVE-2019-13299","CWE_ID":"125","category":"security","commit_id":"8187d2d8fd010d2d6b1a3a8edd935beec404dddc","commit_message":"From 8187d2d8fd010d2d6b1a3a8edd935beec404dddc Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 21 Jun 2019 18:49:58 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1610\n\n---\n MagickCore\/pixel-accessor.h | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/MagickCore\/pixel-accessor.h b\/MagickCore\/pixel-accessor.h\nindex 8af0e369cf..56fba6c978 100644\n--- a\/MagickCore\/pixel-accessor.h\n+++ b\/MagickCore\/pixel-accessor.h\n@@ -111,7 +111,7 @@ static inline PixelTrait GetPixelCbTraits(const Image *magick_restrict image)\n static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n   const PixelChannel channel,const Quantum *magick_restrict pixel)\n {\n-  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n+  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)\n     return((Quantum) 0);\n   return(pixel[image->channel_map[channel].offset]);\n }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-12684","CWE_ID":"125","category":"security","commit_id":"8fd069f6dedb064339f1091069ac96f3f8bdb552","commit_message":"From 8fd069f6dedb064339f1091069ac96f3f8bdb552 Mon Sep 17 00:00:00 2001\nFrom: bel2125 <bel2125@gmail.com>\nDate: Sat, 16 Jun 2018 00:48:25 +0200\nSubject: [PATCH] Check length of memcmp\n\n---\n src\/civetweb.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/civetweb.c b\/src\/civetweb.c\nindex 4c885513..f3fcb8c0 100644\n--- a\/src\/civetweb.c\n+++ b\/src\/civetweb.c\n@@ -11611,10 +11611,10 @@ send_ssi_file(struct mg_connection *conn,\n \t\t\t\t\t\/* Handle SSI tag *\/\n \t\t\t\t\tbuf[len] = 0;\n \n-\t\t\t\t\tif (!memcmp(buf + 5, \"include\", 7)) {\n+\t\t\t\t\tif ((len > 12) && !memcmp(buf + 5, \"include\", 7)) {\n \t\t\t\t\t\tdo_ssi_include(conn, path, buf + 12, include_level + 1);\n #if !defined(NO_POPEN)\n-\t\t\t\t\t} else if (!memcmp(buf + 5, \"exec\", 4)) {\n+\t\t\t\t\t} else if ((len > 9) && !memcmp(buf + 5, \"exec\", 4)) {\n \t\t\t\t\t\tdo_ssi_exec(conn, buf + 9);\n #endif \/* !NO_POPEN *\/\n \t\t\t\t\t} else {\n","owner":"civetweb","repo":"civetweb","source":"cve"},{"CVE_ID":"CVE-2017-13139","CWE_ID":"125","category":"security","commit_id":"22e0310345499ffe906c604428f2a3a668942b05","commit_message":"From 22e0310345499ffe906c604428f2a3a668942b05 Mon Sep 17 00:00:00 2001\nFrom: Glenn Randers-Pehrson <glennrp@gmail.com>\nDate: Mon, 10 Jul 2017 08:23:01 -0400\nSubject: [PATCH] Fix potential out-of-bounds read with the MNG CLIP chunk.\n\n---\n coders\/png.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/coders\/png.c b\/coders\/png.c\nindex 71d3cfada9..d262e7057b 100644\n--- a\/coders\/png.c\n+++ b\/coders\/png.c\n@@ -5804,6 +5804,8 @@ static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n \n                 for (i=(int) first_object; i <= (int) last_object; i++)\n                 {\n+                  if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n+                    continue;\n                   if (mng_info->exists[i] && !mng_info->frozen[i])\n                     {\n                       MngBox\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2019-5747","CWE_ID":"125","category":"security","commit_id":"74d9f1ba37010face4bd1449df4d60dd84450b06","commit_message":"From 74d9f1ba37010face4bd1449df4d60dd84450b06 Mon Sep 17 00:00:00 2001\nFrom: Denys Vlasenko <vda.linux@googlemail.com>\nDate: Mon, 7 Jan 2019 15:33:42 +0100\nSubject: udhcpc: when decoding DHCP_SUBNET, ensure it is 4 bytes long\n\nfunction                                             old     new   delta\nudhcp_run_script                                     795     801      +6\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>\n---\n networking\/udhcp\/common.c | 2 +-\n networking\/udhcp\/common.h | 2 +-\n networking\/udhcp\/dhcpc.c  | 2 +-\n 3 files changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/networking\/udhcp\/common.c b\/networking\/udhcp\/common.c\nindex 4c2221b77..fc4de5716 100644\n--- a\/networking\/udhcp\/common.c\n+++ b\/networking\/udhcp\/common.c\n@@ -302,7 +302,7 @@ uint8_t* FAST_FUNC udhcp_get_option32(struct dhcp_packet *packet, int code)\n {\n \tuint8_t *r = udhcp_get_option(packet, code);\n \tif (r) {\n-\t\tif (r[-1] != 4)\n+\t\tif (r[-OPT_DATA + OPT_LEN] != 4)\n \t\t\tr = NULL;\n \t}\n \treturn r;\ndiff --git a\/networking\/udhcp\/common.h b\/networking\/udhcp\/common.h\nindex 9511152ff..62f9a2a4a 100644\n--- a\/networking\/udhcp\/common.h\n+++ b\/networking\/udhcp\/common.h\n@@ -119,7 +119,7 @@ enum {\n \/\/#define DHCP_TIME_SERVER      0x04 \/* RFC 868 time server (32-bit, 0 = 1.1.1900) *\/\n \/\/#define DHCP_NAME_SERVER      0x05 \/* IEN 116 _really_ ancient kind of NS *\/\n \/\/#define DHCP_DNS_SERVER       0x06\n-\/\/#define DHCP_LOG_SERVER       0x07 \/* port 704 UDP log (not syslog)\n+\/\/#define DHCP_LOG_SERVER       0x07 \/* port 704 UDP log (not syslog) *\/\n \/\/#define DHCP_COOKIE_SERVER    0x08 \/* \"quote of the day\" server *\/\n \/\/#define DHCP_LPR_SERVER       0x09\n #define DHCP_HOST_NAME          0x0c \/* 12: either client informs server or server gives name to client *\/\ndiff --git a\/networking\/udhcp\/dhcpc.c b\/networking\/udhcp\/dhcpc.c\nindex 5b3fd531c..dcec8cdfd 100644\n--- a\/networking\/udhcp\/dhcpc.c\n+++ b\/networking\/udhcp\/dhcpc.c\n@@ -531,7 +531,7 @@ static char **fill_envp(struct dhcp_packet *packet)\n \t\ttemp = udhcp_get_option(packet, code);\n \t\t*curr = xmalloc_optname_optval(temp, &dhcp_optflags[i], opt_name);\n \t\tputenv(*curr++);\n-\t\tif (code == DHCP_SUBNET) {\n+\t\tif (code == DHCP_SUBNET && temp[-OPT_DATA + OPT_LEN] == 4) {\n \t\t\t\/* Subnet option: make things like \"$ip\/$mask\" possible *\/\n \t\t\tuint32_t subnet;\n \t\t\tmove_from_unaligned32(subnet, temp);\n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-10888","CWE_ID":"125","category":"security","commit_id":"9844d38bed10e9ff17174434b3421b227ae710f3","commit_message":"From 9844d38bed10e9ff17174434b3421b227ae710f3 Mon Sep 17 00:00:00 2001\nFrom: Patrick Steinhardt <ps@pks.im>\nDate: Fri, 29 Jun 2018 09:11:02 +0200\nSubject: [PATCH] delta: fix out-of-bounds read of delta\n\nWhen computing the offset and length of the delta base, we repeatedly\nincrement the `delta` pointer without checking whether we have advanced\npast its end already, which can thus result in an out-of-bounds read.\nFix this by repeatedly checking whether we have reached the end. Add a\ntest which would cause Valgrind to produce an error.\n\nReported-by: Riccardo Schirone <rschiron@redhat.com>\nTest-provided-by: Riccardo Schirone <rschiron@redhat.com>\n---\n src\/delta.c         | 18 ++++++++++--------\n tests\/delta\/apply.c |  9 +++++++++\n 2 files changed, 19 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/src\/delta.c b\/src\/delta.c\nindex 8d9e6146e7..8676e7a8f2 100644\n--- a\/src\/delta.c\n+++ b\/src\/delta.c\n@@ -568,15 +568,17 @@ int git_delta_apply(\n \t\t\t\/* cmd is a copy instruction; copy from the base. *\/\n \t\t\tsize_t off = 0, len = 0;\n \n-\t\t\tif (cmd & 0x01) off = *delta++;\n-\t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;\n-\t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;\n-\t\t\tif (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);\n-\n-\t\t\tif (cmd & 0x10) len = *delta++;\n-\t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;\n-\t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;\n+#define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }\n+\t\t\tif (cmd & 0x01) ADD_DELTA(off, 0UL);\n+\t\t\tif (cmd & 0x02) ADD_DELTA(off, 8UL);\n+\t\t\tif (cmd & 0x04) ADD_DELTA(off, 16UL);\n+\t\t\tif (cmd & 0x08) ADD_DELTA(off, 24UL);\n+\n+\t\t\tif (cmd & 0x10) ADD_DELTA(len, 0UL);\n+\t\t\tif (cmd & 0x20) ADD_DELTA(len, 8UL);\n+\t\t\tif (cmd & 0x40) ADD_DELTA(len, 16UL);\n \t\t\tif (!len)       len = 0x10000;\n+#undef ADD_DELTA\n \n \t\t\tif (base_len < off + len || res_sz < len)\n \t\t\t\tgoto fail;\ndiff --git a\/tests\/delta\/apply.c b\/tests\/delta\/apply.c\nindex 24513e040d..5bb95a2834 100644\n--- a\/tests\/delta\/apply.c\n+++ b\/tests\/delta\/apply.c\n@@ -10,3 +10,12 @@ void test_delta_apply__read_at_off(void)\n \n \tcl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));\n }\n+\n+void test_delta_apply__read_after_limit(void)\n+{\n+\tunsigned char base[16] = { 0 }, delta[] = { 0x10, 0x70, 0xff };\n+\tvoid *out;\n+\tsize_t outlen;\n+\n+\tcl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));\n+}\n","owner":"libgit2","repo":"libgit2","source":"cve"},{"CVE_ID":"CVE-2017-16805","CWE_ID":"125","category":"security","commit_id":"2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d","commit_message":"From 2ca9ab45891b6ae8e32b6c28c81eebca059cbe5d Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Tue, 14 Nov 2017 04:15:54 +0900\nSubject: [PATCH] Fix #8813 - segfault in dwarf parser\n\n---\n libr\/bin\/dwarf.c           | 29 ++++++++++++++++++-----------\n libr\/include\/r_bin_dwarf.h |  2 +-\n 2 files changed, 19 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/libr\/bin\/dwarf.c b\/libr\/bin\/dwarf.c\nindex 808d350520..ebbf5720bf 100644\n--- a\/libr\/bin\/dwarf.c\n+++ b\/libr\/bin\/dwarf.c\n@@ -1,4 +1,4 @@\n-\/* radare - LGPL - Copyright 2012-2016 - pancake, Fedor Sakharov *\/\n+\/* radare - LGPL - Copyright 2012-2017 - pancake, Fedor Sakharov *\/\n \n #define D0 if(1)\n #define D1 if(1)\n@@ -1144,8 +1144,9 @@ static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf)\n \t\t\tvalues = dies[j].attr_values;\n \n \t\t\tfor (k = 0; k < dies[j].length; k++) {\n-\t\t\t\tif (!values[k].name)\n+\t\t\t\tif (!values[k].name) {\n \t\t\t\t\tcontinue;\n+\t\t\t\t}\n \n \t\t\t\tif (values[k].name < DW_AT_vtable_elem_location &&\n \t\t\t\t\t\tdwarf_attr_encodings[values[k].name]) {\n@@ -1168,7 +1169,7 @@ static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,\n \tconst ut8 *buf_end = obuf + obuf_len;\n \tsize_t j;\n \n-\tif (!spec || !value || !hdr || !obuf || obuf_len < 0) {\n+\tif (!spec || !value || !hdr || !obuf || obuf_len < 1) {\n \t\treturn NULL;\n \t}\n \n@@ -1194,7 +1195,7 @@ static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,\n \t\t\tvalue->encoding.address = READ (buf, ut64);\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\teprintf(\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->pointer_size);\n+\t\t\teprintf (\"DWARF: Unexpected pointer size: %u\\n\", (unsigned)hdr->pointer_size);\n \t\t\treturn NULL;\n \t\t}\n \t\tbreak;\n@@ -1219,6 +1220,8 @@ static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,\n \t\t\tvalue->encoding.block.data = data;\n \t\t}\n \t\tbreak;\n+#if 0\n+\/\/ This causes segfaults to happen\n \tcase DW_FORM_data2:\n \t\tvalue->encoding.data = READ (buf, ut16);\n \t\tbreak;\n@@ -1228,6 +1231,7 @@ static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,\n \tcase DW_FORM_data8:\n \t\tvalue->encoding.data = READ (buf, ut64);\n \t\tbreak;\n+#endif\n \tcase DW_FORM_string:\n \t\tvalue->encoding.str_struct.string = *buf? strdup ((const char*)buf) : NULL;\n \t\tbuf += (strlen ((const char*)buf) + 1);\n@@ -1237,16 +1241,20 @@ static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len,\n \t\tif (!buf) {\n \t\t\treturn NULL;\n \t\t}\n-\t\tvalue->encoding.block.data = calloc (sizeof(ut8), value->encoding.block.length);\n-\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n-\t\t\tvalue->encoding.block.data[j] = READ (buf, ut8);\n+\t\tvalue->encoding.block.data = calloc (sizeof (ut8), value->encoding.block.length);\n+\t\tif (value->encoding.block.data) {\n+\t\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n+\t\t\t\tvalue->encoding.block.data[j] = READ (buf, ut8);\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase DW_FORM_block1:\n \t\tvalue->encoding.block.length = READ (buf, ut8);\n \t\tvalue->encoding.block.data = calloc (sizeof (ut8), value->encoding.block.length + 1);\n-\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n-\t\t\tvalue->encoding.block.data[j] = READ (buf, ut8);\n+\t\tif (value->encoding.block.data) {\n+\t\t\tfor (j = 0; j < value->encoding.block.length; j++) {\n+\t\t\t\tvalue->encoding.block.data[j] = READ (buf, ut8);\n+\t\t\t}\n \t\t}\n \t\tbreak;\n \tcase DW_FORM_flag:\n@@ -1344,8 +1352,7 @@ static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf,\n \t\t\t\teprintf (\"Warning: malformed dwarf attribute capacity doesn't match length\\n\");\n \t\t\t\tbreak;\n \t\t\t}\n-\t\t\tmemset (&cu->dies[cu->length].attr_values[i], 0, sizeof\n-\t\t\t\t\t(cu->dies[cu->length].attr_values[i]));\n+\t\t\tmemset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i]));\n \t\t\tbuf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf,\n \t\t\t\t\t&da->decls[abbr_code - 1].specs[i],\n \t\t\t\t\t&cu->dies[cu->length].attr_values[i],\ndiff --git a\/libr\/include\/r_bin_dwarf.h b\/libr\/include\/r_bin_dwarf.h\nindex 866bcbb445..857d9cca34 100644\n--- a\/libr\/include\/r_bin_dwarf.h\n+++ b\/libr\/include\/r_bin_dwarf.h\n@@ -622,7 +622,7 @@ typedef union {\n \tut64\tdata;\n \tst64\tsdata;\n \tut64\treference;\n-\tstruct str_structt {\n+\tstruct {\n \t\tchar\t*string;\n \t\tut64\toffset;\n \t} str_struct;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2018-15501","CWE_ID":"125","category":"security","commit_id":"1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649","commit_message":"From 1f9a8510e1d2f20ed7334eeeddb92c4dd8e7c649 Mon Sep 17 00:00:00 2001\nFrom: Patrick Steinhardt <ps@pks.im>\nDate: Thu, 19 Jul 2018 13:00:42 +0200\nSubject: [PATCH] smart_pkt: fix potential OOB-read when processing ng packet\n\nOSS-fuzz has reported a potential out-of-bounds read when processing a\n\"ng\" smart packet:\n\n==1==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6310000249c0 at pc 0x000000493a92 bp 0x7ffddc882cd0 sp 0x7ffddc882480\n\tREAD of size 65529 at 0x6310000249c0 thread T0\n\tSCARINESS: 26 (multi-byte-read-heap-buffer-overflow)\n\t#0 0x493a91 in __interceptor_strchr.part.35 \/src\/llvm\/projects\/compiler-rt\/lib\/sanitizer_common\/sanitizer_common_interceptors.inc:673\n\t#1 0x813960 in ng_pkt libgit2\/src\/transports\/smart_pkt.c:320:14\n\t#2 0x810f79 in git_pkt_parse_line libgit2\/src\/transports\/smart_pkt.c:478:9\n\t#3 0x82c3c9 in git_smart__store_refs libgit2\/src\/transports\/smart_protocol.c:47:12\n\t#4 0x6373a2 in git_smart__connect libgit2\/src\/transports\/smart.c:251:15\n\t#5 0x57688f in git_remote_connect libgit2\/src\/remote.c:708:15\n\t#6 0x52e59b in LLVMFuzzerTestOneInput \/src\/download_refs_fuzzer.cc:145:9\n\t#7 0x52ef3f in ExecuteFilesOnyByOne(int, char**) \/src\/libfuzzer\/afl\/afl_driver.cpp:301:5\n\t#8 0x52f4ee in main \/src\/libfuzzer\/afl\/afl_driver.cpp:339:12\n\t#9 0x7f6c910db82f in __libc_start_main \/build\/glibc-Cl5G7W\/glibc-2.23\/csu\/libc-start.c:291\n\t#10 0x41d518 in _start\n\nWhen parsing an \"ng\" packet, we keep track of both the current position\nas well as the remaining length of the packet itself. But instead of\ntaking care not to exceed the length, we pass the current pointer's\nposition to `strchr`, which will search for a certain character until\nhitting NUL. It is thus possible to create a crafted packet which\ndoesn't contain a NUL byte to trigger an out-of-bounds read.\n\nFix the issue by instead using `memchr`, passing the remaining length as\nrestriction. Furthermore, verify that we actually have enough bytes left\nto produce a match at all.\n\nOSS-Fuzz-Issue: 9406\n---\n src\/transports\/smart_pkt.c | 10 ++++++++--\n 1 file changed, 8 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/transports\/smart_pkt.c b\/src\/transports\/smart_pkt.c\nindex a661dfe136..d10d6c68fa 100644\n--- a\/src\/transports\/smart_pkt.c\n+++ b\/src\/transports\/smart_pkt.c\n@@ -299,8 +299,11 @@ static int ng_pkt(git_pkt **out, const char *line, size_t len)\n \tpkt->ref = NULL;\n \tpkt->type = GIT_PKT_NG;\n \n+\tif (len < 3)\n+\t\tgoto out_err;\n \tline += 3; \/* skip \"ng \" *\/\n-\tif (!(ptr = strchr(line, ' ')))\n+\tlen -= 3;\n+\tif (!(ptr = memchr(line, ' ', len)))\n \t\tgoto out_err;\n \tlen = ptr - line;\n \n@@ -311,8 +314,11 @@ static int ng_pkt(git_pkt **out, const char *line, size_t len)\n \tmemcpy(pkt->ref, line, len);\n \tpkt->ref[len] = '\\0';\n \n+\tif (len < 1)\n+\t\tgoto out_err;\n \tline = ptr + 1;\n-\tif (!(ptr = strchr(line, '\\n')))\n+\tlen -= 1;\n+\tif (!(ptr = memchr(line, '\\n', len)))\n \t\tgoto out_err;\n \tlen = ptr - line;\n \n","owner":"libgit2","repo":"libgit2","source":"cve"},{"CVE_ID":"CVE-2016-10029","CWE_ID":"125","category":"security","commit_id":"acfc4846508a02cc4c83aa27799fd74ac280bdb2","commit_message":"From acfc4846508a02cc4c83aa27799fd74ac280bdb2 Mon Sep 17 00:00:00 2001\nFrom: =?utf8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>\nDate: Thu, 19 May 2016 12:25:59 +0200\nSubject: [PATCH] virtio-gpu: use VIRTIO_GPU_MAX_SCANOUTS\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nThe value is defined in virtio_gpu.h already (changing from 4 to 16).\n\nSigned-off-by: Marc-Andr\u00c3\u00a9 Lureau <marcandre.lureau@redhat.com>\nMessage-id: 1463653560-26958-6-git-send-email-marcandre.lureau@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/display\/virtio-gpu.c        | 4 ++--\n include\/hw\/virtio\/virtio-gpu.h | 6 ++----\n 2 files changed, 4 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/hw\/display\/virtio-gpu.c b\/hw\/display\/virtio-gpu.c\nindex 643dd92..bc10d5d 100644\n--- a\/hw\/display\/virtio-gpu.c\n+++ b\/hw\/display\/virtio-gpu.c\n@@ -929,8 +929,8 @@ static void virtio_gpu_device_realize(DeviceState *qdev, Error **errp)\n     bool have_virgl;\n     int i;\n \n-    if (g->conf.max_outputs > VIRTIO_GPU_MAX_SCANOUT) {\n-        error_setg(errp, \"invalid max_outputs > %d\", VIRTIO_GPU_MAX_SCANOUT);\n+    if (g->conf.max_outputs > VIRTIO_GPU_MAX_SCANOUTS) {\n+        error_setg(errp, \"invalid max_outputs > %d\", VIRTIO_GPU_MAX_SCANOUTS);\n         return;\n     }\n \ndiff --git a\/include\/hw\/virtio\/virtio-gpu.h b\/include\/hw\/virtio\/virtio-gpu.h\nindex 13b0ab0..1602a13 100644\n--- a\/include\/hw\/virtio\/virtio-gpu.h\n+++ b\/include\/hw\/virtio\/virtio-gpu.h\n@@ -27,8 +27,6 @@\n \n #define VIRTIO_ID_GPU 16\n \n-#define VIRTIO_GPU_MAX_SCANOUT 4\n-\n struct virtio_gpu_simple_resource {\n     uint32_t resource_id;\n     uint32_t width;\n@@ -98,8 +96,8 @@ typedef struct VirtIOGPU {\n     QTAILQ_HEAD(, virtio_gpu_ctrl_command) cmdq;\n     QTAILQ_HEAD(, virtio_gpu_ctrl_command) fenceq;\n \n-    struct virtio_gpu_scanout scanout[VIRTIO_GPU_MAX_SCANOUT];\n-    struct virtio_gpu_requested_state req_state[VIRTIO_GPU_MAX_SCANOUT];\n+    struct virtio_gpu_scanout scanout[VIRTIO_GPU_MAX_SCANOUTS];\n+    struct virtio_gpu_requested_state req_state[VIRTIO_GPU_MAX_SCANOUTS];\n \n     struct virtio_gpu_conf conf;\n     int enabled_output_bitmask;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-10001","CWE_ID":"125","category":"security","commit_id":"47b7c68ae54560e2308bdb6be4fb076c73b93081","commit_message":"From 47b7c68ae54560e2308bdb6be4fb076c73b93081 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sat, 31 Mar 2018 03:10:43 +0200\nSubject: [PATCH] avcodec\/utvideodec: Set pro flag based on fourcc\n\nThis avoids mixing 8bit variants with pro and 10bit with non pro mode.\nFixes: out of array read\nFixes: poc_03_30.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nReviewed-by: Paul B Mahol <onemda@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/utvideodec.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/utvideodec.c b\/libavcodec\/utvideodec.c\nindex 086129d094..82cb038ccd 100644\n--- a\/libavcodec\/utvideodec.c\n+++ b\/libavcodec\/utvideodec.c\n@@ -949,14 +949,17 @@ static av_cold int decode_init(AVCodecContext *avctx)\n         break;\n     case MKTAG('U', 'Q', 'Y', '2'):\n         c->planes      = 3;\n+        c->pro         = 1;\n         avctx->pix_fmt = AV_PIX_FMT_YUV422P10;\n         break;\n     case MKTAG('U', 'Q', 'R', 'G'):\n         c->planes      = 3;\n+        c->pro         = 1;\n         avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n         break;\n     case MKTAG('U', 'Q', 'R', 'A'):\n         c->planes      = 4;\n+        c->pro         = 1;\n         avctx->pix_fmt = AV_PIX_FMT_GBRAP10;\n         break;\n     case MKTAG('U', 'L', 'H', '0'):\n@@ -1031,7 +1034,7 @@ static av_cold int decode_init(AVCodecContext *avctx)\n         if (c->compression != 2)\n             avpriv_request_sample(avctx, \"Unknown compression type\");\n         c->slices      = avctx->extradata[9] + 1;\n-    } else if (avctx->extradata_size >= 16) {\n+    } else if (!c->pro && avctx->extradata_size >= 16) {\n         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",\n                avctx->extradata[3], avctx->extradata[2],\n                avctx->extradata[1], avctx->extradata[0]);\n@@ -1046,14 +1049,13 @@ static av_cold int decode_init(AVCodecContext *avctx)\n         c->slices      = (c->flags >> 24) + 1;\n         c->compression = c->flags & 1;\n         c->interlaced  = c->flags & 0x800;\n-    } else if (avctx->extradata_size == 8) {\n+    } else if (c->pro && avctx->extradata_size == 8) {\n         av_log(avctx, AV_LOG_DEBUG, \"Encoder version %d.%d.%d.%d\\n\",\n                avctx->extradata[3], avctx->extradata[2],\n                avctx->extradata[1], avctx->extradata[0]);\n         av_log(avctx, AV_LOG_DEBUG, \"Original format %\"PRIX32\"\\n\",\n                AV_RB32(avctx->extradata + 4));\n         c->interlaced  = 0;\n-        c->pro         = 1;\n         c->frame_info_size = 4;\n     } else {\n         av_log(avctx, AV_LOG_ERROR,\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8958","CWE_ID":"125","category":"security","commit_id":"b8f17d08b7418204bf8a05a5c24e87b2fc395b75","commit_message":"From b8f17d08b7418204bf8a05a5c24e87b2fc395b75 Mon Sep 17 00:00:00 2001\nFrom: cristy <urban-warrior@git.imagemagick.org>\nDate: Sat, 10 Jan 2015 14:10:16 +0000\nSubject: [PATCH] \n http:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=3&t=26857\n\n---\n coders\/sun.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/coders\/sun.c b\/coders\/sun.c\nindex af1a7289bf..728bffa4d3 100644\n--- a\/coders\/sun.c\n+++ b\/coders\/sun.c\n@@ -409,8 +409,8 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         sun_info.length || !sun_info.length)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     number_pixels=(MagickSizeType) image->columns*image->rows;\n-    if ((sun_info.type != RT_ENCODED) && (sun_info.depth >= 8) &&\n-        ((number_pixels*((sun_info.depth+7)\/8)) > sun_info.length))\n+    if ((sun_info.type != RT_ENCODED) && \n+        ((number_pixels*sun_info.depth) > (8*sun_info.length)))\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     bytes_per_line=sun_info.width*sun_info.depth;\n     sun_data=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(\n@@ -532,7 +532,7 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n             bytes_per_pixel++;\n           if (bytes_per_line == 0)\n             bytes_per_line=bytes_per_pixel*image->columns;\n-          length=image->rows*(bytes_per_line+image->columns % 2);\n+          length=image->rows*(bytes_per_line+bytes_per_line % 2);\n           if (((sun_info.type == RT_ENCODED) &&\n                (length > (bytes_per_line*image->rows))) ||\n               ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-7456","CWE_ID":"125","category":"security","commit_id":"4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a","commit_message":"From 4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a Mon Sep 17 00:00:00 2001\nFrom: Chris Reuter <chris@blit.ca>\nDate: Mon, 23 Sep 2013 18:03:08 -0400\nSubject: [PATCH] Fixed memory overrun bug in gdImageScaleTwoPass\n\n_gdContributionsCalc would compute a window size and then adjust\nthe left and right positions of the window to make a window within\nthat size.  However, it was storing the values in the struct *before*\nit made the adjustment.  This change fixes that.\n---\n src\/gd_interpolation.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/src\/gd_interpolation.c b\/src\/gd_interpolation.c\nindex 43891e6d..71cc1504 100644\n--- a\/src\/gd_interpolation.c\n+++ b\/src\/gd_interpolation.c\n@@ -953,9 +953,6 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n \t\tdouble dTotalWeight = 0.0;\n \t\tint iSrc;\n \n-\t\tres->ContribRow[u].Left = iLeft;\n-\t\tres->ContribRow[u].Right = iRight;\n-\n \t\t\/* Cut edge points to fit in filter window in case of spill-off *\/\n \t\tif (iRight - iLeft + 1 > windows_size)  {\n \t\t\tif (iLeft < ((int)src_size - 1 \/ 2))  {\n@@ -965,6 +962,9 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n \t\t\t}\n \t\t}\n \n+\t\tres->ContribRow[u].Left = iLeft;\n+\t\tres->ContribRow[u].Right = iRight;\n+\n \t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n \t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n \t\t}\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2018-20461","CWE_ID":"125","category":"security","commit_id":"a1bc65c3db593530775823d6d7506a457ed95267","commit_message":"From a1bc65c3db593530775823d6d7506a457ed95267 Mon Sep 17 00:00:00 2001\nFrom: radare <pancake@nopcode.org>\nDate: Mon, 3 Dec 2018 02:54:37 +0100\nSubject: [PATCH] Fix #12375 - Crash in bd+ao (#12382)\n\n---\n libr\/core\/cmd_anal.c | 16 +++++++++++-----\n 1 file changed, 11 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/libr\/core\/cmd_anal.c b\/libr\/core\/cmd_anal.c\nindex 4b6613ecc6..af060f2767 100644\n--- a\/libr\/core\/cmd_anal.c\n+++ b\/libr\/core\/cmd_anal.c\n@@ -1568,16 +1568,22 @@ static void core_anal_bytes(RCore *core, const ut8 *buf, int len, int nops, int\n \t\t\t}\n #endif\n \t\t\tprintline (\"bytes\", NULL, 0);\n-\t\t\tfor (j = 0; j < size; j++) {\n-\t\t\t\tr_cons_printf (\"%02x\", buf[j + idx]);\n+\t\t\tint minsz = R_MIN (len, size);\n+\t\t\tminsz = R_MAX (minsz, 0);\n+\t\t\tfor (j = 0; j < minsz; j++) {\n+\t\t\t\tut8 ch = ((j + idx - 1) > minsz)? 0xff: buf[j + idx];\n+\t\t\t\tr_cons_printf (\"%02x\", ch);\n \t\t\t}\n \t\t\tr_cons_newline ();\n-\t\t\tif (op.val != UT64_MAX)\n+\t\t\tif (op.val != UT64_MAX) {\n \t\t\t\tprintline (\"val\", \"0x%08\" PFMT64x \"\\n\", op.val);\n-\t\t\tif (op.ptr != UT64_MAX)\n+\t\t\t}\n+\t\t\tif (op.ptr != UT64_MAX) {\n \t\t\t\tprintline (\"ptr\", \"0x%08\" PFMT64x \"\\n\", op.ptr);\n-\t\t\tif (op.refptr != -1)\n+\t\t\t}\n+\t\t\tif (op.refptr != -1) {\n \t\t\t\tprintline (\"refptr\", \"%d\\n\", op.refptr);\n+\t\t\t}\n \t\t\tprintline (\"size\", \"%d\\n\", size);\n \t\t\tprintline (\"sign\", \"%s\\n\", r_str_bool (op.sign));\n \t\t\tprintline (\"type\", \"%s\\n\", r_anal_optype_to_string (op.type));\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2018-10529","CWE_ID":"125","category":"security","commit_id":"f0c505a3e5d47989a5f69be2d0d4f250af6b1a6c","commit_message":"From f0c505a3e5d47989a5f69be2d0d4f250af6b1a6c Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Sat, 28 Apr 2018 12:09:12 +0300\nSubject: [PATCH] X3F property table list fix\n\n---\n internal\/dcraw_common.cpp |  1 +\n internal\/libraw_x3f.cpp   | 14 +++-----------\n src\/libraw_cxx.cpp        | 13 +++++++++++--\n 3 files changed, 15 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex 29c69950..97c67545 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -17602,6 +17602,7 @@ void CLASS identify()\n       tiff_ifd[i].dng_levels.analogbalance[c] = 1.0f;\n   }\n #endif\n+\n   memset(gpsdata, 0, sizeof gpsdata);\n   memset(cblack, 0, sizeof cblack);\n   memset(white, 0, sizeof white);\ndiff --git a\/internal\/libraw_x3f.cpp b\/internal\/libraw_x3f.cpp\nindex c7b9840f..b18e8be4 100644\n--- a\/internal\/libraw_x3f.cpp\n+++ b\/internal\/libraw_x3f.cpp\n@@ -121,8 +121,6 @@ typedef struct x3f_property_s {\n   \/* Computed *\/\n   utf16_t *name;\t\t\/* 0x0000 terminated UTF 16 *\/\n   utf16_t *value;               \/* 0x0000 terminated UTF 16 *\/\n-  char *name_utf8;\t\t\/* converted to UTF 8 *\/\n-  char *value_utf8;          \/* converted to UTF 8 *\/\n } x3f_property_t;\n \n typedef struct x3f_property_table_s {\n@@ -516,7 +514,6 @@ unsigned x3f_get4(LibRaw_abstract_datastream *f)\n \t\tint _cur = _file->_func(_buffer,1,_left);\t\\\n \t\tif (_cur == 0) {\t\t\t\t\t\t\t\\\n \t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\t\t\\\n-\t\t\texit(1);\t\t\t\t\t\t\t\t\\\n \t\t}\t\t\t\t\t\t\t\t\t\t\t\\\n \t\t_left -= _cur;\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n@@ -912,11 +909,6 @@ static void free_camf_entry(camf_entry_t *entry)\n \t\t\tif (PL)\n \t\t\t{\n \t\t\t\tint i;\n-\n-\t\t\t\tfor (i = 0; i < PL->property_table.size; i++) {\n-\t\t\t\t\tFREE(PL->property_table.element[i].name_utf8);\n-\t\t\t\t\tFREE(PL->property_table.element[i].value_utf8);\n-\t\t\t\t}\n \t\t\t}\n \t\t\tFREE(PL->property_table.element);\n \t\t\tFREE(PL->data);\n@@ -1624,14 +1616,14 @@ static void x3f_load_property_list(x3f_info_t *I, x3f_directory_entry_t *DE)\n \n \tif (!PL->data_size)\n \t\tPL->data_size = read_data_block(&PL->data, I, DE, 0);\n+\tuint32_t maxoffset = PL->data_size\/sizeof(utf16_t)-2; \/\/ at least 2 chars, value + terminating 0x0000\n \n \tfor (i=0; i<PL->num_properties; i++) {\n \t\tx3f_property_t *P = &PL->property_table.element[i];\n-\n+\t\tif(P->name_offset > maxoffset || P->value_offset > maxoffset)\n+\t\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n \t\tP->name = ((utf16_t *)PL->data + P->name_offset);\n \t\tP->value = ((utf16_t *)PL->data + P->value_offset);\n-\t\tP->name_utf8 = 0;\/\/ utf16le_to_utf8(P->name);\n-\t\tP->value_utf8 = 0;\/\/utf16le_to_utf8(P->value);\n \t}\n }\n \ndiff --git a\/src\/libraw_cxx.cpp b\/src\/libraw_cxx.cpp\nindex a111b9fe..294ba423 100644\n--- a\/src\/libraw_cxx.cpp\n+++ b\/src\/libraw_cxx.cpp\n@@ -6143,12 +6143,15 @@ void LibRaw::parse_x3f()\n   imgdata.sizes.raw_width = ID->columns;\n   imgdata.sizes.raw_height = ID->rows;\n   \/\/ Parse other params from property section\n+\n   DE = x3f_get_prop(x3f);\n   if ((x3f_load_data(x3f, DE) == X3F_OK))\n   {\n     \/\/ Parse property list\n     DEH = &DE->header;\n     x3f_property_list_t *PL = &DEH->data_subsection.property_list;\n+    utf16_t *datap = (utf16_t*) PL->data;\n+    uint32_t maxitems = PL->data_size\/sizeof(utf16_t);\n     if (PL->property_table.size != 0)\n     {\n       int i;\n@@ -6156,8 +6159,14 @@ void LibRaw::parse_x3f()\n       for (i = 0; i < PL->num_properties; i++)\n       {\n         char name[100], value[100];\n-        utf2char(P[i].name, name,sizeof(name));\n-        utf2char(P[i].value, value,sizeof(value));\n+        int noffset = (P[i].name - datap);\n+        int voffset = (P[i].value - datap);\n+        if(noffset < 0 || noffset>maxitems || voffset<0 || voffset>maxitems)\n+           throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+        int maxnsize = maxitems - (P[i].name - datap);\n+        int maxvsize = maxitems - (P[i].value - datap);\n+        utf2char(P[i].name, name,MIN(maxnsize,sizeof(name)));\n+        utf2char(P[i].value, value,MIN(maxvsize,sizeof(value)));\n         if (!strcmp(name, \"ISO\"))\n           imgdata.other.iso_speed = atoi(value);\n         if (!strcmp(name, \"CAMMANUF\"))\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2016-7799","CWE_ID":"125","category":"security","commit_id":"a7bb158b7bedd1449a34432feb3a67c8f1873bfa","commit_message":"From a7bb158b7bedd1449a34432feb3a67c8f1873bfa Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 30 Sep 2016 15:19:06 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/280\n\n---\n MagickCore\/profile.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/MagickCore\/profile.c b\/MagickCore\/profile.c\nindex ea76057700..4239d558c6 100644\n--- a\/MagickCore\/profile.c\n+++ b\/MagickCore\/profile.c\n@@ -2032,7 +2032,7 @@ MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n         break;  \/* corrupt EXIF *\/\n       tag_value=(ssize_t) ReadProfileShort(endian,q);\n       format=(ssize_t) ReadProfileShort(endian,q+2);\n-      if ((format-1) >= EXIF_NUM_FORMATS)\n+      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n         break;\n       components=(ssize_t) ReadProfileLong(endian,q+4);\n       if (components < 0)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2019-10714","CWE_ID":"125","category":"security","commit_id":"07eebcd72f45c8fd7563d3f9ec5d2bed48f65f36","commit_message":"From 07eebcd72f45c8fd7563d3f9ec5d2bed48f65f36 Mon Sep 17 00:00:00 2001\nFrom: Cristy <mikayla-grace@urban-warrior.org>\nDate: Mon, 4 Mar 2019 19:25:01 -0500\nSubject: [PATCH] ...\n\n---\n MagickCore\/locale.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/MagickCore\/locale.c b\/MagickCore\/locale.c\nindex d30960e9db..158b7ef92d 100644\n--- a\/MagickCore\/locale.c\n+++ b\/MagickCore\/locale.c\n@@ -1523,9 +1523,9 @@ MagickExport int LocaleLowercase(const int c)\n {\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n-    return(tolower_l(c,c_locale));\n+    return(tolower_l((int) ((unsigned char) c),c_locale));\n #endif\n-  return(tolower(c));\n+  return(tolower((int) ((unsigned char) c)));\n }\n \f\n \/*\n@@ -1661,9 +1661,9 @@ MagickExport int LocaleUppercase(const int c)\n {\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n-    return(toupper_l(c,c_locale));\n+    return(toupper_l((int) ((unsigned char) c),c_locale));\n #endif\n-  return(toupper(c));\n+  return(toupper((int) ((unsigned char) c)));\n }\n \f\n \/*\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-6912","CWE_ID":"125","category":"security","commit_id":"76cc0f0f673353cd4746cd3b83838ae335e5d9ed","commit_message":"From 76cc0f0f673353cd4746cd3b83838ae335e5d9ed Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Fri, 9 Feb 2018 15:27:41 +0100\nSubject: [PATCH] avcodec\/utvideodec: Add several out of array read related\n checks\n\nFixes: OV_decode_plane.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/utvideodec.c | 14 ++++++++++----\n 1 file changed, 10 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/utvideodec.c b\/libavcodec\/utvideodec.c\nindex 1bcd14e..c5f5534 100644\n--- a\/libavcodec\/utvideodec.c\n+++ b\/libavcodec\/utvideodec.c\n@@ -268,6 +268,9 @@ static int decode_plane(UtvideoContext *c, int plane_no,\n             send   = (height * (slice + 1) \/ c->slices) & cmask;\n             dest   = dst + sstart * stride;\n \n+            if (3 * ((dst + send * stride - dest + 7)\/8) > get_bits_left(&cbit))\n+                return AVERROR_INVALIDDATA;\n+\n             for (p = dest; p < dst + send * stride; p += 8) {\n                 int bits = get_bits_le(&cbit, 3);\n \n@@ -277,6 +280,9 @@ static int decode_plane(UtvideoContext *c, int plane_no,\n                     uint32_t sub = 0x80 >> (8 - (bits + 1)), add;\n                     int k;\n \n+                    if ((bits + 1) * 8 > get_bits_left(&pbit))\n+                        return AVERROR_INVALIDDATA;\n+\n                     for (k = 0; k < 8; k++) {\n \n                         p[k] = get_bits_le(&pbit, bits + 1);\n@@ -639,9 +645,9 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n             for (j = 0; j < c->slices; j++) {\n                 c->packed_stream[i][j] = packed_stream;\n                 c->packed_stream_size[i][j] = bytestream2_get_le32(&pb);\n-                left -= c->packed_stream_size[i][j];\n-                if (left < 0)\n+                if (c->packed_stream_size[i][j] > left)\n                     return AVERROR_INVALIDDATA;\n+                left -= c->packed_stream_size[i][j];\n                 packed_stream += c->packed_stream_size[i][j];\n             }\n         }\n@@ -652,9 +658,9 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n             for (j = 0; j < c->slices; j++) {\n                 c->control_stream[i][j] = control_stream;\n                 c->control_stream_size[i][j] = bytestream2_get_le32(&pb);\n-                left -= c->control_stream_size[i][j];\n-                if (left < 0)\n+                if (c->control_stream_size[i][j] > left)\n                     return AVERROR_INVALIDDATA;\n+                left -= c->control_stream_size[i][j];\n                 control_stream += c->control_stream_size[i][j];\n             }\n         }\n-- \n2.7.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-1000115","CWE_ID":"125","category":"security","commit_id":"dbb7a8af90054bf4ef51f5814ef7ceb17d83d974","commit_message":"From dbb7a8af90054bf4ef51f5814ef7ceb17d83d974 Mon Sep 17 00:00:00 2001\nFrom: dormando <dormando@rydia.net>\nDate: Tue, 27 Feb 2018 10:50:45 -0800\nSubject: [PATCH] disable UDP port by default\n\nAs reported, UDP amplification attacks have started to use insecure\ninternet-exposed memcached instances. UDP used to be a lot more popular as a\ntransport for memcached many years ago, but I'm not aware of many recent\nusers.\n\nTen years ago, the TCP connection overhead from many clients was relatively\nhigh (dozens or hundreds per client server), but these days many clients are\nbatched, or user fewer processes, or simply anre't worried about it.\n\nWhile changing the default to listen on localhost only would also help, the\ntrue culprit is UDP. There are many more use cases for using memcached over\nthe network than there are for using the UDP protocol.\n---\n memcached.c  | 6 ++----\n t\/issue_67.t | 4 ++--\n 2 files changed, 4 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/memcached.c b\/memcached.c\nindex 88a5f2ebe..7178666e2 100644\n--- a\/memcached.c\n+++ b\/memcached.c\n@@ -222,7 +222,7 @@ static void settings_init(void) {\n     settings.use_cas = true;\n     settings.access = 0700;\n     settings.port = 11211;\n-    settings.udpport = 11211;\n+    settings.udpport = 0;\n     \/* By default this string should be NULL for getaddrinfo() *\/\n     settings.inter = NULL;\n     settings.maxbytes = 64 * 1024 * 1024; \/* default is 64MB *\/\n@@ -7479,9 +7479,7 @@ int main (int argc, char **argv) {\n         }\n     }\n \n-    if (tcp_specified && settings.port != 0 && !udp_specified) {\n-        settings.udpport = settings.port;\n-    } else if (udp_specified && settings.udpport != 0 && !tcp_specified) {\n+    if (udp_specified && settings.udpport != 0 && !tcp_specified) {\n         settings.port = settings.udpport;\n     }\n \ndiff --git a\/t\/issue_67.t b\/t\/issue_67.t\nindex 69c869f4c..b2d374fa5 100644\n--- a\/t\/issue_67.t\n+++ b\/t\/issue_67.t\n@@ -77,11 +77,11 @@ sub when {\n \n # Disabling the defaults since it conflicts with a running instance.\n # when('no arguments', '', 11211, 11211);\n-when('specifying tcp port', '-p 11212', 11212, 11212);\n+when('specifying tcp port', '-p 11212', 11212, -1);\n when('specifying udp port', '-U 11222', 11222, 11222);\n when('specifying tcp ephemeral port', '-p -1', 0, 0);\n when('specifying udp ephemeral port', '-U -1', 0, 0);\n-when('tcp port disabled', '-p 0', -1, 11211);\n+when('tcp port disabled', '-p 0', -1, -1);\n when('udp port disabled', '-U 0', 11211, -1);\n when('specifying tcp and udp ports', '-p 11232 -U 11233', 11232, 11233);\n when('specifying tcp and disabling udp', '-p 11242 -U 0', 11242, -1);\n","owner":"memcached","repo":"memcached","source":"cve"},{"CVE_ID":"CVE-2015-8958","CWE_ID":"125","category":"security","commit_id":"6b4aff0f117b978502ee5bcd6e753c17aec5a961","commit_message":"From 6b4aff0f117b978502ee5bcd6e753c17aec5a961 Mon Sep 17 00:00:00 2001\nFrom: cristy <urban-warrior@git.imagemagick.org>\nDate: Tue, 13 Jan 2015 12:16:28 +0000\nSubject: [PATCH]\n\n---\n coders\/sun.c | 12 +++++++++---\n 1 file changed, 9 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/coders\/sun.c b\/coders\/sun.c\nindex 04915bc3d0..7edf41b3a0 100644\n--- a\/coders\/sun.c\n+++ b\/coders\/sun.c\n@@ -408,7 +408,7 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n       return(DestroyImageList(image));\n     if ((sun_info.length*sizeof(*sun_data))\/sizeof(*sun_data) !=\n         sun_info.length || !sun_info.length)\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n     number_pixels=(MagickSizeType) image->columns*image->rows;\n     if ((sun_info.type != RT_ENCODED) && \n         ((number_pixels*sun_info.depth) > (8*sun_info.length)))\n@@ -424,11 +424,11 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     height=sun_info.height;\n     if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n         ((bytes_per_line\/sun_info.depth) != sun_info.width))\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n     bytes_per_line+=15;\n     bytes_per_line<<=1;\n     if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n     bytes_per_line>>=4;\n     sun_pixels=(unsigned char *) AcquireQuantumMemory(height,\n       bytes_per_line*sizeof(*sun_pixels));\n@@ -437,6 +437,12 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     if (sun_info.type == RT_ENCODED)\n       (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\n         height);\n+    else\n+      {\n+        if (sun_info.length > (height*bytes_per_line))\n+          ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n+        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);\n+      }\n     sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n     \/*\n       Convert SUN raster image to pixel packets.\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-13720","CWE_ID":"125","category":"security","commit_id":"d1e670a4a8704b8708e493ab6155589bcd570608","commit_message":"From d1e670a4a8704b8708e493ab6155589bcd570608 Mon Sep 17 00:00:00 2001\nFrom: Michal Srb <msrb@suse.com>\nDate: Thu, 20 Jul 2017 13:38:53 +0200\nSubject: Check for end of string in PatternMatch (CVE-2017-13720)\n\nIf a pattern contains '?' character, any character in the string is skipped,\neven if it is '\\0'. The rest of the matching then reads invalid memory.\n\nReviewed-by: Peter Hutterer <peter.hutterer@who-t.net>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n src\/fontfile\/fontdir.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/fontfile\/fontdir.c b\/src\/fontfile\/fontdir.c\nindex 4ce2473..996b7d1 100644\n--- a\/src\/fontfile\/fontdir.c\n+++ b\/src\/fontfile\/fontdir.c\n@@ -400,8 +400,10 @@ PatternMatch(char *pat, int patdashes, char *string, int stringdashes)\n \t\t}\n \t    }\n \tcase '?':\n-\t    if (*string++ == XK_minus)\n+\t    if ((t = *string++) == XK_minus)\n \t\tstringdashes--;\n+\t    if (!t)\n+\t\treturn 0;\n \t    break;\n \tcase '\\0':\n \t    return (*string == '\\0');\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-11377","CWE_ID":"125","category":"security","commit_id":"25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4","commit_message":"From 25a3703ef2e015bbe1d1f16f6b2f63bb10dd34f4 Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Wed, 18 Apr 2018 13:16:04 +0200\nSubject: [PATCH] Fix invalid free in RAnal.avr\n\n---\n libr\/anal\/p\/anal_avr.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libr\/anal\/p\/anal_avr.c b\/libr\/anal\/p\/anal_avr.c\nindex 4e62158513..e7717beb7c 100644\n--- a\/libr\/anal\/p\/anal_avr.c\n+++ b\/libr\/anal\/p\/anal_avr.c\n@@ -1287,7 +1287,7 @@ INST_HANDLER (sbrx) {\t\/\/ SBRC Rr, b\n \t\t\t\/\/ SBRS Rr, b\n \tint b = buf[0] & 0x7;\n \tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n-\tRAnalOp next_op;\n+\tRAnalOp next_op = {0};\n \n \t\/\/ calculate next instruction size (call recursively avr_op_analyze)\n \t\/\/ and free next_op's esil string (we dont need it now)\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2016-6491","CWE_ID":"125","category":"security","commit_id":"dd84447b63a71fa8c3f47071b09454efc667767b","commit_message":"From dd84447b63a71fa8c3f47071b09454efc667767b Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 24 Jul 2016 20:07:03 -0400\nSubject: [PATCH] Prevent buffer overflow (bug report from Ibrahim el-sayed)\n\n---\n MagickCore\/property.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/MagickCore\/property.c b\/MagickCore\/property.c\nindex 772f3d59fe..0b4b75c494 100644\n--- a\/MagickCore\/property.c\n+++ b\/MagickCore\/property.c\n@@ -665,6 +665,11 @@ static MagickBooleanType Get8BIMProperty(const Image *image,const char *key,\n     if ((count & 0x01) == 0)\n       (void) ReadPropertyByte(&info,&length);\n     count=(ssize_t) ReadPropertyMSBLong(&info,&length);\n+    if ((count < 0) || ((size_t) count > length))\n+      {\n+        length=0; \n+        continue;\n+      }\n     if ((*name != '\\0') && (*name != '#'))\n       if ((resource == (char *) NULL) || (LocaleCompare(name,resource) != 0))\n         {\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-18445","CWE_ID":"125","category":"security","commit_id":"b799207e1e1816b09e7a5920fbb2d5fcf6edd681","commit_message":"From b799207e1e1816b09e7a5920fbb2d5fcf6edd681 Mon Sep 17 00:00:00 2001\nFrom: Jann Horn <jannh@google.com>\nDate: Fri, 5 Oct 2018 18:17:59 +0200\nSubject: bpf: 32-bit RSH verification must truncate input before the ALU op\n\nWhen I wrote commit 468f6eafa6c4 (\"bpf: fix 32-bit ALU op verification\"), I\nassumed that, in order to emulate 64-bit arithmetic with 32-bit logic, it\nis sufficient to just truncate the output to 32 bits; and so I just moved\nthe register size coercion that used to be at the start of the function to\nthe end of the function.\n\nThat assumption is true for almost every op, but not for 32-bit right\nshifts, because those can propagate information towards the least\nsignificant bit. Fix it by always truncating inputs for 32-bit ops to 32\nbits.\n\nAlso get rid of the coerce_reg_to_size() after the ALU op, since that has\nno effect.\n\nFixes: 468f6eafa6c4 (\"bpf: fix 32-bit ALU op verification\")\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\n---\n kernel\/bpf\/verifier.c | 10 +++++++++-\n 1 file changed, 9 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/kernel\/bpf\/verifier.c b\/kernel\/bpf\/verifier.c\nindex bb07e74b34a2..465952a8e465 100644\n--- a\/kernel\/bpf\/verifier.c\n+++ b\/kernel\/bpf\/verifier.c\n@@ -2896,6 +2896,15 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n \tu64 umin_val, umax_val;\n \tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n \n+\tif (insn_bitness == 32) {\n+\t\t\/* Relevant for 32-bit RSH: Information can propagate towards\n+\t\t * LSB, so it isn't sufficient to only truncate the output to\n+\t\t * 32 bits.\n+\t\t *\/\n+\t\tcoerce_reg_to_size(dst_reg, 4);\n+\t\tcoerce_reg_to_size(&src_reg, 4);\n+\t}\n+\n \tsmin_val = src_reg.smin_value;\n \tsmax_val = src_reg.smax_value;\n \tumin_val = src_reg.umin_value;\n@@ -3131,7 +3140,6 @@ static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n \tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n \t\t\/* 32-bit ALU ops are (32,32)->32 *\/\n \t\tcoerce_reg_to_size(dst_reg, 4);\n-\t\tcoerce_reg_to_size(&src_reg, 4);\n \t}\n \n \t__reg_deduce_bounds(dst_reg);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7533","CWE_ID":"125","category":"security","commit_id":"bef1e4f637d8f665bc133a9c6d30df08d983bc3a","commit_message":"From bef1e4f637d8f665bc133a9c6d30df08d983bc3a Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 5 Feb 2016 21:20:42 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/120\n\n---\n coders\/wpg.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/wpg.c b\/coders\/wpg.c\nindex 964530533e..b01dcf9cc6 100644\n--- a\/coders\/wpg.c\n+++ b\/coders\/wpg.c\n@@ -1331,7 +1331,7 @@ static Image *ReadWPGImage(const ImageInfo *image_info,\n                   {\n                     ldblk=(ssize_t) ((bpp*image->columns+7)\/8);\n                     BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t)\n-                      ldblk,sizeof(*BImgBuff));\n+                      ldblk+1,sizeof(*BImgBuff));\n                     if (BImgBuff == (unsigned char *) NULL)\n                       goto NoMemory;\n \n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-11714","CWE_ID":"125","category":"security","commit_id":"671fd59eb657743aa86fbc1895cb15872a317caa","commit_message":"From 671fd59eb657743aa86fbc1895cb15872a317caa Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Thu, 6 Jul 2017 14:54:02 +0100\nSubject: [PATCH] Bug 698158: prevent trying to reloc a freed object\n\nIn the token reader, we pass the scanner state structure around as a\nt_struct ref on the Postscript operand stack.\n\nBut we explicitly free the scanner state when we're done, which leaves a\ndangling reference on the operand stack and, unless that reference gets\noverwritten before the next garbager run, we can end up with the garbager\ntrying to deal with an already freed object - that can cause a crash, or\nmemory corruption.\n---\n psi\/ztoken.c | 14 +++++++++++++-\n 1 file changed, 13 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/psi\/ztoken.c b\/psi\/ztoken.c\nindex 4dba7c5..af1ceeb 100644\n--- a\/psi\/ztoken.c\n+++ b\/psi\/ztoken.c\n@@ -107,6 +107,12 @@ token_continue(i_ctx_t *i_ctx_p, scanner_state * pstate, bool save)\n     int code;\n     ref token;\n \n+    \/* Since we might free pstate below, and we're dealing with\n+     * gc memory referenced by the stack, we need to explicitly\n+     * remove the reference to pstate from the stack, otherwise\n+     * the garbager will fall over\n+     *\/\n+    make_null(osp);\n     \/* Note that gs_scan_token may change osp! *\/\n     pop(1);                     \/* remove the file or scanner state *\/\n again:\n@@ -183,8 +189,14 @@ ztokenexec_continue(i_ctx_t *i_ctx_p)\n static int\n tokenexec_continue(i_ctx_t *i_ctx_p, scanner_state * pstate, bool save)\n {\n-    os_ptr op;\n+    os_ptr op = osp;\n     int code;\n+    \/* Since we might free pstate below, and we're dealing with\n+     * gc memory referenced by the stack, we need to explicitly\n+     * remove the reference to pstate from the stack, otherwise\n+     * the garbager will fall over\n+     *\/\n+    make_null(osp);\n     \/* Note that gs_scan_token may change osp! *\/\n     pop(1);\n again:\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-10714","CWE_ID":"125","category":"security","commit_id":"edc7d3035883ddca8413e4fe7689aa2e579ef04a","commit_message":"From edc7d3035883ddca8413e4fe7689aa2e579ef04a Mon Sep 17 00:00:00 2001\nFrom: Cristy <mikayla-grace@urban-warrior.org>\nDate: Mon, 4 Mar 2019 19:58:00 -0500\nSubject: [PATCH] ...\n\n---\n ChangeLog           | 7 +++++++\n MagickCore\/locale.c | 4 ++++\n 2 files changed, 11 insertions(+)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex eb3d33de8b..f3ac83be4e 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,10 @@\n+2019-03-05  7.0.8-32 Cristy  <quetzlzacatenango@image...>\n+  * Release ImageMagick version 7.0.8-32, GIT revision ...\n+\n+2019-03-05  7.0.8-32 Cristy  <quetzlzacatenango@image...>\n+  * Fix out-of-boundary LocaleLowerCase() @\n+    https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1495\n+\n 2019-03-04  7.0.8-31 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 7.0.8-31, GIT revision 15381:3122a669d:20190304\n \ndiff --git a\/MagickCore\/locale.c b\/MagickCore\/locale.c\nindex 158b7ef92d..4bcab6df3e 100644\n--- a\/MagickCore\/locale.c\n+++ b\/MagickCore\/locale.c\n@@ -1521,6 +1521,8 @@ MagickExport void LocaleLower(char *string)\n *\/\n MagickExport int LocaleLowercase(const int c)\n {\n+  if (c < 0)\n+    return(c);\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n     return(tolower_l((int) ((unsigned char) c),c_locale));\n@@ -1659,6 +1661,8 @@ MagickExport void LocaleUpper(char *string)\n *\/\n MagickExport int LocaleUppercase(const int c)\n {\n+  if (c < 0)\n+    return(c);\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n     return(toupper_l((int) ((unsigned char) c),c_locale));\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-20458","CWE_ID":"125","category":"security","commit_id":"4e98402f09a0ef0bb8559a33a4c1988c54938eaf","commit_message":"From 4e98402f09a0ef0bb8559a33a4c1988c54938eaf Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Mon, 3 Dec 2018 01:16:30 +0100\nSubject: [PATCH] Fix #12374 - oobread crash in truncated dyldcache ##bin\n\n---\n libr\/bin\/format\/mach0\/dyldcache.c | 47 +++++++++++++++++++++++--------\n 1 file changed, 35 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/libr\/bin\/format\/mach0\/dyldcache.c b\/libr\/bin\/format\/mach0\/dyldcache.c\nindex b19dbc656a..1fc7cc2b82 100644\n--- a\/libr\/bin\/format\/mach0\/dyldcache.c\n+++ b\/libr\/bin\/format\/mach0\/dyldcache.c\n@@ -1,4 +1,4 @@\n-\/* radare - LGPL - Copyright 2010-2016 - nibble, pancake  *\/\n+\/* radare - LGPL - Copyright 2010-2018 - nibble, pancake  *\/\n \n #include <stdio.h>\n #include <r_types.h>\n@@ -21,6 +21,23 @@ static int r_bin_dyldcache_apply_patch (struct r_buf_t* buf, ut32 data, ut64 off\n \n #define NZ_OFFSET(x) if((x) > 0) r_bin_dyldcache_apply_patch (dbuf, (x) - linkedit_offset, (ut64)((size_t)&(x) - (size_t)data))\n \n+\/\/ make it public in util\/buf.c ?\n+static ut64 r_buf_read64le (RBuffer *buf, ut64 off) {\n+\tut8 data[8] = {0};\n+\tr_buf_read_at (buf, off, data, 8);\n+\treturn r_read_le64 (data);\n+}\n+\n+static char *r_buf_read_string (RBuffer *buf, ut64 addr, int len) {\n+\tut8 *data = malloc (len);\n+\tif (data) {\n+\t\tr_buf_read_at (buf, addr, data, len);\n+\t\tdata[len-1] = 0;\n+\t\treturn data;\n+\t}\n+\treturn NULL;\n+}\n+\n \/* TODO: Needs more testing and ERROR HANDLING *\/\n struct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj_t* bin, int idx, int *nlib) {\n \tut64 liboff, linkedit_offset;\n@@ -47,7 +64,6 @@ struct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj\n \t*nlib = bin->nlibs;\n \tret = R_NEW0 (struct r_bin_dyldcache_lib_t);\n \tif (!ret) {\n-\t\tperror (\"malloc (ret)\");\n \t\treturn NULL;\n \t}\n \tif (bin->hdr.startaddr > bin->size) {\n@@ -55,13 +71,20 @@ struct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj\n \t\tfree (ret);\n \t\treturn NULL;\n \t}\n+\n \tif (bin->hdr.startaddr > bin->size || bin->hdr.baseaddroff > bin->size) {\n \t\teprintf (\"corrupted dyldcache\");\n \t\tfree (ret);\n \t\treturn NULL;\n \t}\n-\timage_infos = (struct dyld_cache_image_info*) (bin->b->buf + bin->hdr.startaddr);\n-\tdyld_vmbase = *(ut64 *)(bin->b->buf + bin->hdr.baseaddroff);\n+\tint sz = bin->nlibs * sizeof (struct dyld_cache_image_info);\n+\timage_infos = malloc (sz); \/\/(struct dyld_cache_image_info*) (bin->b->buf + bin->hdr.startaddr);\n+\tif (!image_infos) {\n+\t\tfree (ret);\n+\t\treturn NULL;\n+\t}\n+\tr_buf_read_at (bin->b, bin->hdr.startaddr, (ut8*)image_infos, sz);\n+\tdyld_vmbase = r_buf_read64le (bin->b, bin->hdr.baseaddroff);\n \tliboff = image_infos[idx].address - dyld_vmbase;\n \tif (liboff > bin->size) {\n \t\teprintf (\"Corrupted file\\n\");\n@@ -69,12 +92,13 @@ struct r_bin_dyldcache_lib_t *r_bin_dyldcache_extract(struct r_bin_dyldcache_obj\n \t\treturn NULL;\n \t}\n \tret->offset = liboff;\n-\tif (image_infos[idx].pathFileOffset > bin->size) {\n-\t    eprintf (\"corrupted file\\n\");\n+\tint pfo = image_infos[idx].pathFileOffset;\n+\tif (pfo < 0 || pfo > bin->size) {\n+\t\teprintf (\"corrupted file: pathFileOffset > bin->size (%d)\\n\", pfo);\n \t\tfree (ret);\n \t\treturn NULL;\n \t}\n-\tlibname = (char *)(bin->b->buf + image_infos[idx].pathFileOffset);\n+\tlibname = r_buf_read_string (bin->b, pfo, 64);\n \t\/* Locate lib hdr in cache *\/\n \tdata = bin->b->buf + liboff;\n \tmh = (struct mach_header *)data;\n@@ -224,16 +248,15 @@ struct r_bin_dyldcache_obj_t* r_bin_dyldcache_new(const char* file) {\n }\n \n struct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {\n-\tstruct r_bin_dyldcache_obj_t *bin;\n-\tif (!(bin = malloc (sizeof (struct r_bin_dyldcache_obj_t)))) {\n+\tstruct r_bin_dyldcache_obj_t *bin = R_NEW0 (struct r_bin_dyldcache_obj_t);\n+\tif (!bin) {\n \t\treturn NULL;\n \t}\n-\tmemset (bin, 0, sizeof (struct r_bin_dyldcache_obj_t));\n \tif (!buf) {\n \t\treturn r_bin_dyldcache_free (bin);\n \t}\n-\tbin->b = r_buf_new();\n-\tif (!r_buf_set_bytes (bin->b, buf, size)) {\n+\tbin->b = r_buf_new ();\n+\tif (!bin->b || !r_buf_set_bytes (bin->b, buf, size)) {\n \t\treturn r_bin_dyldcache_free (bin);\n \t}\n \tif (!r_bin_dyldcache_init (bin)) {\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2019-13297","CWE_ID":"125","category":"security","commit_id":"35c7032723d85eee7318ff6c82f031fa2666b773","commit_message":"From 35c7032723d85eee7318ff6c82f031fa2666b773 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 21 Jun 2019 17:30:44 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1609\n\n---\n magick\/threshold.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/magick\/threshold.c b\/magick\/threshold.c\nindex a53e839e6..4a8c6b2e7 100644\n--- a\/magick\/threshold.c\n+++ b\/magick\/threshold.c\n@@ -202,7 +202,7 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,\n   threshold_image=CloneImage(image,0,0,MagickTrue,exception);\n   if (threshold_image == (Image *) NULL)\n     return((Image *) NULL);\n-  if (width == 0)\n+  if ((width == 0) || (height == 0))\n     return(threshold_image);\n   if (SetImageStorageClass(threshold_image,DirectClass) == MagickFalse)\n     {\n","owner":"ImageMagick","repo":"ImageMagick6","source":"cve"},{"CVE_ID":"CVE-2018-6392","CWE_ID":"125","category":"security","commit_id":"3f621455d62e46745453568d915badd5b1e5bcd5","commit_message":"From 3f621455d62e46745453568d915badd5b1e5bcd5 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sun, 28 Jan 2018 02:46:56 +0100\nSubject: [PATCH] avfilter\/vf_transpose: Fix regression with packed pixel\n formats\n\nRegression since: c6939f65a116b1ffed345d29d8621ee4ffb32235\nFound-by: Paul B Mahol <onemda@gmail.com>\nReviewed-by: Paul B Mahol <onemda@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavfilter\/vf_transpose.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavfilter\/vf_transpose.c b\/libavfilter\/vf_transpose.c\nindex 1e1a5c4..3ff4cb4 100644\n--- a\/libavfilter\/vf_transpose.c\n+++ b\/libavfilter\/vf_transpose.c\n@@ -217,7 +217,7 @@ static int config_props_output(AVFilterLink *outlink)\n \n     s->hsub = desc_in->log2_chroma_w;\n     s->vsub = desc_in->log2_chroma_h;\n-    s->planes = desc_in->nb_components;\n+    s->planes = av_pix_fmt_count_planes(outlink->format);\n \n     av_assert0(desc_in->nb_components == desc_out->nb_components);\n \n-- \n2.7.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-5809","CWE_ID":"125","category":"security","commit_id":"fd6330292501983ac75fe4162275794b18445bd9","commit_message":"From fd6330292501983ac75fe4162275794b18445bd9 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Tue, 24 Apr 2018 15:17:31 +0300\nSubject: [PATCH] Secunia 81800#1: samsumg_load_raw\n\nSecunia 81800#2: find_green\n\nSecunia 81800#3: rollei_load_raw\n\nremove_trailing_spaces: isspace() does not works right with signed non-latin chars\n\nSecunia 81800#5\/6: nikon_coolscan_load_raw\n\nSecunia 81800#4: rollei_load_raw\n---\n dcraw\/dcraw.c             | 157 ++++++++++++++++++++++++++------------\n internal\/dcraw_common.cpp | 156 +++++++++++++++++++++++++------------\n internal\/defines.h        |   1 +\n 3 files changed, 216 insertions(+), 98 deletions(-)\n\n","diff_code":"diff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 1c6bf662..e2b9c7d4 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -251,6 +251,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n \/\/@end DEFINES\n@@ -1511,9 +1512,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1794,7 +1800,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1810,8 +1821,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3857,6 +3871,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3875,11 +3894,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -11081,37 +11106,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -15077,7 +15133,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -15100,14 +15157,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex cfb82a27..b430d3e5 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -1228,9 +1228,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1506,7 +1511,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1522,8 +1532,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3569,6 +3582,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3587,11 +3605,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -9890,37 +9914,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -13739,7 +13794,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -13762,14 +13818,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/defines.h b\/internal\/defines.h\nindex b84e1d28..06e171ec 100644\n--- a\/internal\/defines.h\n+++ b\/internal\/defines.h\n@@ -153,6 +153,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n #define BAYER(row,col) \\\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2019-13302","CWE_ID":"125","category":"security","commit_id":"d5089971bd792311aaab5cb73460326d7ef7f32d","commit_message":"From d5089971bd792311aaab5cb73460326d7ef7f32d Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 17 Jun 2019 09:13:34 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1597\n\n---\n MagickCore\/fourier.c | 9 ++++++++-\n 1 file changed, 8 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/MagickCore\/fourier.c b\/MagickCore\/fourier.c\nindex 24b3824201..47c3ccd2ea 100644\n--- a\/MagickCore\/fourier.c\n+++ b\/MagickCore\/fourier.c\n@@ -164,6 +164,9 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n   MagickOffsetType\n     progress;\n \n+  size_t\n+    number_channels;\n+\n   ssize_t\n     y;\n \n@@ -216,6 +219,10 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n     }\n   Cr_image=complex_images;\n   Ci_image=complex_images->next;\n+  number_channels=MagickMin(MagickMin(MagickMin(\n+    Ar_image->number_channels,Ai_image->number_channels),MagickMin(\n+    Br_image->number_channels,Bi_image->number_channels)),MagickMin(\n+    Cr_image->number_channels,Ci_image->number_channels));\n   Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n   Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n   Br_view=AcquireVirtualCacheView(Br_image,exception);\n@@ -263,7 +270,7 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n       register ssize_t\n         i;\n \n-      for (i=0; i < (ssize_t) GetPixelChannels(Cr_image); i++)\n+      for (i=0; i < (ssize_t) number_channels; i++)\n       {\n         switch (op)\n         {\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-10270","CWE_ID":"125","category":"security","commit_id":"9a72a69e035ee70ff5c41541c8c61cd97990d018","commit_message":"From 9a72a69e035ee70ff5c41541c8c61cd97990d018 Mon Sep 17 00:00:00 2001\nFrom: erouault <erouault>\nDate: Sat, 3 Dec 2016 11:02:15 +0000\nSubject: [PATCH] * libtiff\/tif_dirread.c: modify\n ChopUpSingleUncompressedStrip() to instanciate compute ntrips as\n TIFFhowmany_32(td->td_imagelength, rowsperstrip), instead of a logic based on\n the total size of data. Which is faulty is the total size of data is not\n sufficient to fill the whole image, and thus results in reading outside of\n the StripByCounts\/StripOffsets arrays when using TIFFReadScanline(). Reported\n by Agostino Sarubbo. Fixes http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2608.\n\n* libtiff\/tif_strip.c: revert the change in TIFFNumberOfStrips() done\nfor http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2587 \/ CVE-2016-9273 since\nthe above change is a better fix that makes it unnecessary.\n---\n ChangeLog             | 15 +++++++++++++++\n libtiff\/tif_dirread.c | 22 ++++++++++------------\n libtiff\/tif_strip.c   |  9 ---------\n 3 files changed, 25 insertions(+), 21 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 93c01f80..9dbc7a0c 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,18 @@\n+2016-12-03 Even Rouault <even.rouault at spatialys.com>\n+\n+\t* libtiff\/tif_dirread.c: modify ChopUpSingleUncompressedStrip() to\n+\tinstanciate compute ntrips as TIFFhowmany_32(td->td_imagelength, rowsperstrip),\n+\tinstead of a logic based on the total size of data. Which is faulty is\n+\tthe total size of data is not sufficient to fill the whole image, and thus\n+\tresults in reading outside of the StripByCounts\/StripOffsets arrays when\n+\tusing TIFFReadScanline().\n+\tReported by Agostino Sarubbo.\n+\tFixes http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2608.\n+\n+\t* libtiff\/tif_strip.c: revert the change in TIFFNumberOfStrips() done\n+\tfor http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2587 \/ CVE-2016-9273 since\n+\tthe above change is a better fix that makes it unnecessary.\n+\n 2016-12-03 Even Rouault <even.rouault at spatialys.com>\n \n \t* libtiff\/tif_pixarlog.c, libtiff\/tif_luv.c: fix heap-based buffer\ndiff --git a\/libtiff\/tif_dirread.c b\/libtiff\/tif_dirread.c\nindex 3eec79c9..570d0c32 100644\n--- a\/libtiff\/tif_dirread.c\n+++ b\/libtiff\/tif_dirread.c\n@@ -5502,8 +5502,7 @@ ChopUpSingleUncompressedStrip(TIFF* tif)\n \tuint64 rowblockbytes;\n \tuint64 stripbytes;\n \tuint32 strip;\n-\tuint64 nstrips64;\n-\tuint32 nstrips32;\n+\tuint32 nstrips;\n \tuint32 rowsperstrip;\n \tuint64* newcounts;\n \tuint64* newoffsets;\n@@ -5534,18 +5533,17 @@ ChopUpSingleUncompressedStrip(TIFF* tif)\n \t    return;\n \n \t\/*\n-\t * never increase the number of strips in an image\n+\t * never increase the number of rows per strip\n \t *\/\n \tif (rowsperstrip >= td->td_rowsperstrip)\n \t\treturn;\n-\tnstrips64 = TIFFhowmany_64(bytecount, stripbytes);\n-\tif ((nstrips64==0)||(nstrips64>0xFFFFFFFF)) \/* something is wonky, do nothing. *\/\n-\t    return;\n-\tnstrips32 = (uint32)nstrips64;\n+        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);\n+        if( nstrips == 0 )\n+            return;\n \n-\tnewcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips32, sizeof (uint64),\n+\tnewcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\n \t\t\t\t\"for chopped \\\"StripByteCounts\\\" array\");\n-\tnewoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips32, sizeof (uint64),\n+\tnewoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),\n \t\t\t\t\"for chopped \\\"StripOffsets\\\" array\");\n \tif (newcounts == NULL || newoffsets == NULL) {\n \t\t\/*\n@@ -5562,18 +5560,18 @@ ChopUpSingleUncompressedStrip(TIFF* tif)\n \t * Fill the strip information arrays with new bytecounts and offsets\n \t * that reflect the broken-up format.\n \t *\/\n-\tfor (strip = 0; strip < nstrips32; strip++) {\n+\tfor (strip = 0; strip < nstrips; strip++) {\n \t\tif (stripbytes > bytecount)\n \t\t\tstripbytes = bytecount;\n \t\tnewcounts[strip] = stripbytes;\n-\t\tnewoffsets[strip] = offset;\n+\t\tnewoffsets[strip] = stripbytes ? offset : 0;\n \t\toffset += stripbytes;\n \t\tbytecount -= stripbytes;\n \t}\n \t\/*\n \t * Replace old single strip info with multi-strip info.\n \t *\/\n-\ttd->td_stripsperimage = td->td_nstrips = nstrips32;\n+\ttd->td_stripsperimage = td->td_nstrips = nstrips;\n \tTIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n \n \t_TIFFfree(td->td_stripbytecount);\ndiff --git a\/libtiff\/tif_strip.c b\/libtiff\/tif_strip.c\nindex 4c46ecf5..1676e47d 100644\n--- a\/libtiff\/tif_strip.c\n+++ b\/libtiff\/tif_strip.c\n@@ -63,15 +63,6 @@ TIFFNumberOfStrips(TIFF* tif)\n \tTIFFDirectory *td = &tif->tif_dir;\n \tuint32 nstrips;\n \n-    \/* If the value was already computed and store in td_nstrips, then return it,\n-       since ChopUpSingleUncompressedStrip might have altered and resized the\n-       since the td_stripbytecount and td_stripoffset arrays to the new value\n-       after the initial affectation of td_nstrips = TIFFNumberOfStrips() in\n-       tif_dirread.c ~line 3612.\n-       See http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2587 *\/\n-    if( td->td_nstrips )\n-        return td->td_nstrips;\n-\n \tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n \t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n \tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n","owner":"vadz","repo":"libtiff","source":"cve"},{"CVE_ID":"CVE-2017-6801","CWE_ID":"125","category":"security","commit_id":"3cb0f914d6427073f262e1b2b5fd973e3043cdf7","commit_message":"From 3cb0f914d6427073f262e1b2b5fd973e3043cdf7 Mon Sep 17 00:00:00 2001\nFrom: Randall Hand <randall.hand@gmail.com>\nDate: Fri, 24 Feb 2017 16:08:02 -0500\nSubject: [PATCH] BugFix - Potential OOB with Fields of Size 0\n\nThanks to @hannob for contributing a malformed TNEF stream with\na Version field of size 0.  Now such files will return an error\nindicating invalid data.\n---\n lib\/ytnef.c                              |   4 ++++\n test-data\/test.sh                        |   2 ++\n test-data\/ytnef-oob-TNEFVersion-SwapWord | Bin 0 -> 17 bytes\n 3 files changed, 6 insertions(+)\n create mode 100644 test-data\/ytnef-oob-TNEFVersion-SwapWord\n\n","diff_code":"diff --git a\/lib\/ytnef.c b\/lib\/ytnef.c\nindex afb2efb..eea43b7 100644\n--- a\/lib\/ytnef.c\n+++ b\/lib\/ytnef.c\n@@ -1147,6 +1147,10 @@ int TNEFParse(TNEFStruct *TNEF) {\n   while (TNEFGetHeader(TNEF, &type, &size) == 0) {\n     DEBUG2(TNEF->Debug, 2, \"Header says type=0x%X, size=%u\", type, size);\n     DEBUG2(TNEF->Debug, 2, \"Header says type=%u, size=%u\", type, size);\n+    if(size == 0) {\n+      printf(\"ERROR: Field with size of 0\\n\");\n+      return YTNEF_ERROR_READING_DATA;\n+    }\n     data = calloc(size, sizeof(BYTE));\n     ALLOCCHECK(data);\n     if (TNEFRawRead(TNEF, data, size, &header_checksum) < 0) {\ndiff --git a\/test-data\/test.sh b\/test-data\/test.sh\nindex 7e2e541..81037e4 100755\n--- a\/test-data\/test.sh\n+++ b\/test-data\/test.sh\n@@ -21,3 +21,5 @@ diff results data\n ..\/ytnefprint\/ytnefprint .\/winmail.dat  | grep -A 1 PR_RTF_SYNC_BODY_CRC     | grep 872404792\n ..\/ytnefprint\/ytnefprint .\/winmail.dat  | grep -A 1 PR_RTF_SYNC_BODY_COUNT   | grep 90\n ..\/ytnefprint\/ytnefprint .\/winmail.dat  | grep -A 18 PR_RTF_COMPRESSED       | grep '\\pard Casdasdfasdfasd\\\\par'\n+\n+..\/ytnefprint\/ytnefprint .\/ytnef-oob-TNEFVersion-SwapWord | grep 'ERROR: Field with size of 0'\ndiff --git a\/test-data\/ytnef-oob-TNEFVersion-SwapWord b\/test-data\/ytnef-oob-TNEFVersion-SwapWord\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..4ee03bc0aa8370537d57608b1819d099d9f9d566\nGIT binary patch\nliteral 17\nTcmb=JZ>MBnV8Awkg8>2nBf|ow\n\nliteral 0\nHcmV?d00001\n\n","owner":"Yeraze","repo":"ytnef","source":"cve"},{"CVE_ID":"CVE-2016-6905","CWE_ID":"125","category":"security","commit_id":"01c61f8ab110a77ae64b5ca67c244c728c506f03","commit_message":"From 01c61f8ab110a77ae64b5ca67c244c728c506f03 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Ond=C5=99ej=20Sur=C3=BD?= <ondrej@sury.org>\nDate: Fri, 15 Jul 2016 09:40:31 +0200\nSubject: [PATCH] Proper fix for #248\n\n---\n src\/gd_tga.c | 48 +++++++++++++++++++-----------------------------\n 1 file changed, 19 insertions(+), 29 deletions(-)\n\n","diff_code":"diff --git a\/src\/gd_tga.c b\/src\/gd_tga.c\nindex 6420cae6..34879caa 100644\n--- a\/src\/gd_tga.c\n+++ b\/src\/gd_tga.c\n@@ -196,7 +196,6 @@ int read_image_tga( gdIOCtx *ctx, oTga *tga )\n \tint buffer_caret = 0;\n \tint bitmap_caret = 0;\n \tint i = 0;\n-\tint j = 0;\n \tuint8_t encoded_pixels;\n \n \tif(overflow2(tga->width, tga->height)) {\n@@ -280,43 +279,34 @@ int read_image_tga( gdIOCtx *ctx, oTga *tga )\n \t\twhile( bitmap_caret < image_block_size ) {\n \t\t\t\n \t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n-\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );\n+\t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & !TGA_RLE_FLAG ) + 1 );\n \t\t\t\tbuffer_caret++;\n \n-\t\t\t\tif (encoded_pixels != 0) {\n-\t\t\t\t\n-\t\t\t\t\tif (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {\n-\t\t\t\t\t\tgdFree( decompression_buffer );\n-\t\t\t\t\t\tgdFree( conversion_buffer );\n-\t\t\t\t\t\treturn -1;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n-\t\t\t\t\t\tfor (j = 0; j < pixel_block_size; j++, bitmap_caret++) {\n-\t\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {\n+\t\t\t\t\tgdFree( decompression_buffer );\n+\t\t\t\t\tgdFree( conversion_buffer );\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\n+\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n+\t\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size);\n+\t\t\t\t\tbitmap_caret += pixel_block_size;\n \t\t\t\t}\n \t\t\t\tbuffer_caret += pixel_block_size;\n+\n \t\t\t} else {\n \t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n \t\t\t\tbuffer_caret++;\n \n-\t\t\t\tif (encoded_pixels != 0) {\n-\t\t\t\t\n-\t\t\t\t\tif (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {\n-\t\t\t\t\t\tgdFree( decompression_buffer );\n-\t\t\t\t\t\tgdFree( conversion_buffer );\n-\t\t\t\t\t\treturn -1;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n-\t\t\t\t\t\tfor( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {\n-\t\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tbuffer_caret += pixel_block_size;\n-\t\t\t\t\t}\n+\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {\n+\t\t\t\t\tgdFree( decompression_buffer );\n+\t\t\t\t\tgdFree( conversion_buffer );\n+\t\t\t\t\treturn -1;\n \t\t\t\t}\n+\n+\t\t\t\tmemcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size);\n+\t\t\t\tbitmap_caret += (encoded_pixels * pixel_block_size);\n+\t\t\t\tbuffer_caret += (encoded_pixels * pixel_block_size);\n \t\t\t}\n \t\t}\n \t\tgdFree( decompression_buffer );\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2016-7537","CWE_ID":"125","category":"security","commit_id":"424d40ebfcde48bb872eba75179d3d73704fdf1f","commit_message":"From 424d40ebfcde48bb872eba75179d3d73704fdf1f Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 7 Mar 2016 07:12:05 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/143\n\n---\n coders\/pdb.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/coders\/pdb.c b\/coders\/pdb.c\nindex dcd7400c3e..6d36bcf544 100644\n--- a\/coders\/pdb.c\n+++ b\/coders\/pdb.c\n@@ -420,7 +420,7 @@ static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n       return(DestroyImageList(image));\n     }\n   packets=(bits_per_pixel*image->columns+7)\/8;\n-  pixels=(unsigned char *) AcquireQuantumMemory(packets+256UL,image->rows*\n+  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n     sizeof(*pixels));\n   if (pixels == (unsigned char *) NULL)\n     ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n@@ -822,7 +822,7 @@ static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n     image->rows*sizeof(*runlength));\n   if (runlength == (unsigned char *) NULL)\n     ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n-  buffer=(unsigned char *) AcquireQuantumMemory(256,sizeof(*buffer));\n+  buffer=(unsigned char *) AcquireQuantumMemory(257,sizeof(*buffer));\n   if (buffer == (unsigned char *) NULL)\n     ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n   packet_size=(size_t) (image->depth > 8 ? 2: 1);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-11379","CWE_ID":"125","category":"security","commit_id":"4e1cf0d3e6f6fe2552a269def0af1cd2403e266c","commit_message":"From 4e1cf0d3e6f6fe2552a269def0af1cd2403e266c Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Fri, 20 Apr 2018 20:06:36 +0200\nSubject: [PATCH] Fix crash in pe\n\n---\n libr\/bin\/format\/pe\/pe.c | 17 ++++++++++++-----\n 1 file changed, 12 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/libr\/bin\/format\/pe\/pe.c b\/libr\/bin\/format\/pe\/pe.c\nindex 16314ca4a9..761ac0a7e1 100644\n--- a\/libr\/bin\/format\/pe\/pe.c\n+++ b\/libr\/bin\/format\/pe\/pe.c\n@@ -2732,8 +2732,8 @@ static bool get_rsds(ut8* dbg_data, int dbg_data_len, SCV_RSDS_HEADER* res) {\n \n static void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n \tconst int nb10sz = 16;\n-\tmemcpy (res, dbg_data, nb10sz);\n-\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n+\t\/\/ memcpy (res, dbg_data, nb10sz);\n+\t\/\/ res->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n }\n \n static int get_debug_info(struct PE_(r_bin_pe_obj_t)* bin, PE_(image_debug_directory_entry)* dbg_dir_entry, ut8* dbg_data, int dbg_data_len, SDebugInfo* res) {\n@@ -2772,13 +2772,20 @@ static int get_debug_info(struct PE_(r_bin_pe_obj_t)* bin, PE_(image_debug_direc\n \t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n \t\t\trsds_hdr.free ((struct SCV_RSDS_HEADER*) &rsds_hdr);\n \t\t} else if (strncmp ((const char*) dbg_data, \"NB10\", 4) == 0) {\n-\t\t\tSCV_NB10_HEADER nb10_hdr;\n+\t\t\tif (dbg_data_len < 20) {\n+\t\t\t\teprintf (\"Truncated NB10 entry, not enough data to parse\\n\");\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t\tSCV_NB10_HEADER nb10_hdr = {{0}};\n \t\t\tinit_cv_nb10_header (&nb10_hdr);\n \t\t\tget_nb10 (dbg_data, &nb10_hdr);\n \t\t\tsnprintf (res->guidstr, sizeof (res->guidstr),\n \t\t\t\t\"%x%x\", nb10_hdr.timestamp, nb10_hdr.age);\n-\t\t\tstrncpy (res->file_name, (const char*)\n-\t\t\t\tnb10_hdr.file_name, sizeof(res->file_name) - 1);\n+\t\t\tres->file_name[0] = 0;\n+\t\t\tif (nb10_hdr.file_name) {\n+\t\t\t\tstrncpy (res->file_name, (const char*)\n+\t\t\t\t\t\tnb10_hdr.file_name, sizeof (res->file_name) - 1);\n+\t\t\t}\n \t\t\tres->file_name[sizeof (res->file_name) - 1] = 0;\n \t\t\tnb10_hdr.free ((struct SCV_NB10_HEADER*) &nb10_hdr);\n \t\t} else {\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2016-9935","CWE_ID":"125","category":"security","commit_id":"66fd44209d5ffcb9b3d1bc1b9fd8e35b485040c0","commit_message":"From 66fd44209d5ffcb9b3d1bc1b9fd8e35b485040c0 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Mon, 5 Dec 2016 21:40:55 -0800\nSubject: [PATCH] Fix bug #73631 - Invalid read when wddx decodes empty boolean\n element\n\n---\n ext\/wddx\/tests\/bug73631.phpt | 19 +++++++++++++++++++\n ext\/wddx\/wddx.c              |  5 +++++\n 2 files changed, 24 insertions(+)\n create mode 100644 ext\/wddx\/tests\/bug73631.phpt\n\n","diff_code":"diff --git a\/ext\/wddx\/tests\/bug73631.phpt b\/ext\/wddx\/tests\/bug73631.phpt\nnew file mode 100644\nindex 000000000000..5e37ae826921\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug73631.phpt\n@@ -0,0 +1,19 @@\n+--TEST--\n+Bug #73631 (Memory leak due to invalid wddx stack processing)\n+--SKIPIF--\n+<?php if (!extension_loaded(\"wddx\")) print \"skip\"; ?>\n+--FILE--\n+<?php\n+$xml = <<<EOF\n+<?xml version=\"1.0\" ?>\n+<wddxPacket version=\"1.0\">\n+<number>1234<\/number>\n+<binary><boolean\/><\/binary>\n+<\/wddxPacket>\n+EOF;\n+$wddx = wddx_deserialize($xml);\n+var_dump($wddx);\n+?>\n+--EXPECTF--\n+int(1234)\n+\ndiff --git a\/ext\/wddx\/wddx.c b\/ext\/wddx\/wddx.c\nindex 069ea122ce3b..0cee16b9ad07 100644\n--- a\/ext\/wddx\/wddx.c\n+++ b\/ext\/wddx\/wddx.c\n@@ -811,6 +811,11 @@ static void php_wddx_push_element(void *user_data, const XML_Char *name, const X\n \t\t\t\tphp_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));\n \t\t\t\tbreak;\n \t\t\t}\n+\t\t} else {\n+\t\t\tent.type = ST_BOOLEAN;\n+\t\t\tSET_STACK_VARNAME;\n+\t\t\tZVAL_FALSE(&ent.data);\n+\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n \t\t}\n \t} else if (!strcmp(name, EL_NULL)) {\n \t\tent.type = ST_NULL;\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2018-6621","CWE_ID":"125","category":"security","commit_id":"118e1b0b3370dd1c0da442901b486689efd1654b","commit_message":"From 118e1b0b3370dd1c0da442901b486689efd1654b Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Fri, 2 Feb 2018 21:44:57 +0100\nSubject: [PATCH] avcodec\/utvideodec: Fix bytes left check in decode_frame()\n\nFixes: out of array read\nFixes: poc-2017.avi\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/utvideodec.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/utvideodec.c b\/libavcodec\/utvideodec.c\nindex 608c8c4..1bcd14e 100644\n--- a\/libavcodec\/utvideodec.c\n+++ b\/libavcodec\/utvideodec.c\n@@ -676,7 +676,7 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n             for (j = 0; j < c->slices; j++) {\n                 slice_end   = bytestream2_get_le32u(&gb);\n                 if (slice_end < 0 || slice_end < slice_start ||\n-                    bytestream2_get_bytes_left(&gb) < slice_end) {\n+                    bytestream2_get_bytes_left(&gb) < slice_end + 1024LL) {\n                     av_log(avctx, AV_LOG_ERROR, \"Incorrect slice size\\n\");\n                     return AVERROR_INVALIDDATA;\n                 }\n-- \n2.7.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-16529","CWE_ID":"125","category":"security","commit_id":"bfc81a8bc18e3c4ba0cbaa7666ff76be2f998991","commit_message":"From bfc81a8bc18e3c4ba0cbaa7666ff76be2f998991 Mon Sep 17 00:00:00 2001\nFrom: Takashi Iwai <tiwai@suse.de>\nDate: Fri, 22 Sep 2017 16:18:53 +0200\nSubject: [PATCH] ALSA: usb-audio: Check out-of-bounds access by corrupted\n buffer descriptor\n\nWhen a USB-audio device receives a maliciously adjusted or corrupted\nbuffer descriptor, the USB-audio driver may access an out-of-bounce\nvalue at its parser.  This was detected by syzkaller, something like:\n\n  BUG: KASAN: slab-out-of-bounds in usb_audio_probe+0x27b2\/0x2ab0\n  Read of size 1 at addr ffff88006b83a9e8 by task kworker\/0:1\/24\n  CPU: 0 PID: 24 Comm: kworker\/0:1 Not tainted 4.14.0-rc1-42251-gebb2c2437d80 #224\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01\/01\/2011\n  Workqueue: usb_hub_wq hub_event\n  Call Trace:\n   __dump_stack lib\/dump_stack.c:16\n   dump_stack+0x292\/0x395 lib\/dump_stack.c:52\n   print_address_description+0x78\/0x280 mm\/kasan\/report.c:252\n   kasan_report_error mm\/kasan\/report.c:351\n   kasan_report+0x22f\/0x340 mm\/kasan\/report.c:409\n   __asan_report_load1_noabort+0x19\/0x20 mm\/kasan\/report.c:427\n   snd_usb_create_streams sound\/usb\/card.c:248\n   usb_audio_probe+0x27b2\/0x2ab0 sound\/usb\/card.c:605\n   usb_probe_interface+0x35d\/0x8e0 drivers\/usb\/core\/driver.c:361\n   really_probe drivers\/base\/dd.c:413\n   driver_probe_device+0x610\/0xa00 drivers\/base\/dd.c:557\n   __device_attach_driver+0x230\/0x290 drivers\/base\/dd.c:653\n   bus_for_each_drv+0x161\/0x210 drivers\/base\/bus.c:463\n   __device_attach+0x26e\/0x3d0 drivers\/base\/dd.c:710\n   device_initial_probe+0x1f\/0x30 drivers\/base\/dd.c:757\n   bus_probe_device+0x1eb\/0x290 drivers\/base\/bus.c:523\n   device_add+0xd0b\/0x1660 drivers\/base\/core.c:1835\n   usb_set_configuration+0x104e\/0x1870 drivers\/usb\/core\/message.c:1932\n   generic_probe+0x73\/0xe0 drivers\/usb\/core\/generic.c:174\n   usb_probe_device+0xaf\/0xe0 drivers\/usb\/core\/driver.c:266\n   really_probe drivers\/base\/dd.c:413\n   driver_probe_device+0x610\/0xa00 drivers\/base\/dd.c:557\n   __device_attach_driver+0x230\/0x290 drivers\/base\/dd.c:653\n   bus_for_each_drv+0x161\/0x210 drivers\/base\/bus.c:463\n   __device_attach+0x26e\/0x3d0 drivers\/base\/dd.c:710\n   device_initial_probe+0x1f\/0x30 drivers\/base\/dd.c:757\n   bus_probe_device+0x1eb\/0x290 drivers\/base\/bus.c:523\n   device_add+0xd0b\/0x1660 drivers\/base\/core.c:1835\n   usb_new_device+0x7b8\/0x1020 drivers\/usb\/core\/hub.c:2457\n   hub_port_connect drivers\/usb\/core\/hub.c:4903\n   hub_port_connect_change drivers\/usb\/core\/hub.c:5009\n   port_event drivers\/usb\/core\/hub.c:5115\n   hub_event+0x194d\/0x3740 drivers\/usb\/core\/hub.c:5195\n   process_one_work+0xc7f\/0x1db0 kernel\/workqueue.c:2119\n   worker_thread+0x221\/0x1850 kernel\/workqueue.c:2253\n   kthread+0x3a1\/0x470 kernel\/kthread.c:231\n   ret_from_fork+0x2a\/0x40 arch\/x86\/entry\/entry_64.S:431\n\nThis patch adds the checks of out-of-bounce accesses at appropriate\nplaces and bails out when it goes out of the given buffer.\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/usb\/card.c | 20 ++++++++++++++++++++\n 1 file changed, 20 insertions(+)\n\n","diff_code":"diff --git a\/sound\/usb\/card.c b\/sound\/usb\/card.c\nindex 3dc36d9135502..23d1d23aefec3 100644\n--- a\/sound\/usb\/card.c\n+++ b\/sound\/usb\/card.c\n@@ -221,6 +221,7 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n \tstruct usb_interface_descriptor *altsd;\n \tvoid *control_header;\n \tint i, protocol;\n+\tint rest_bytes;\n \n \t\/* find audiocontrol interface *\/\n \thost_iface = &usb_ifnum_to_if(dev, ctrlif)->altsetting[0];\n@@ -235,6 +236,15 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n \t\treturn -EINVAL;\n \t}\n \n+\trest_bytes = (void *)(host_iface->extra + host_iface->extralen) -\n+\t\tcontrol_header;\n+\n+\t\/* just to be sure -- this shouldn't hit at all *\/\n+\tif (rest_bytes <= 0) {\n+\t\tdev_err(&dev->dev, \"invalid control header\\n\");\n+\t\treturn -EINVAL;\n+\t}\n+\n \tswitch (protocol) {\n \tdefault:\n \t\tdev_warn(&dev->dev,\n@@ -245,11 +255,21 @@ static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)\n \tcase UAC_VERSION_1: {\n \t\tstruct uac1_ac_header_descriptor *h1 = control_header;\n \n+\t\tif (rest_bytes < sizeof(*h1)) {\n+\t\t\tdev_err(&dev->dev, \"too short v1 buffer descriptor\\n\");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\n \t\tif (!h1->bInCollection) {\n \t\t\tdev_info(&dev->dev, \"skipping empty audio interface (v1)\\n\");\n \t\t\treturn -EINVAL;\n \t\t}\n \n+\t\tif (rest_bytes < h1->bLength) {\n+\t\t\tdev_err(&dev->dev, \"invalid buffer length (v1)\\n\");\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\n \t\tif (h1->bLength < sizeof(*h1) + h1->bInCollection) {\n \t\t\tdev_err(&dev->dev, \"invalid UAC_HEADER (v1)\\n\");\n \t\t\treturn -EINVAL;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-8294","CWE_ID":"125","category":"security","commit_id":"83d799804648c2a0895d40a19835d9b757c6fa4e","commit_message":"From 83d799804648c2a0895d40a19835d9b757c6fa4e Mon Sep 17 00:00:00 2001\nFrom: \"Victor M. Alvarez\" <plusvic@gmail.com>\nDate: Thu, 27 Apr 2017 11:39:04 +0200\nSubject: [PATCH] Fix issue #646 (#648)\n\n* Fix issue #646 and some edge cases with wide regexps using \\b and \\B\n\n* Rename function IS_WORD_CHAR to _yr_re_is_word_char\n---\n libyara\/exec.c            |   1 +\n libyara\/include\/yara\/re.h |  15 ++----\n libyara\/re.c              | 110 +++++++++++++++++++++++++++-----------\n libyara\/scan.c            |  10 ++--\n tests\/test-rules.c        |  44 +++++++++++++++\n 5 files changed, 135 insertions(+), 45 deletions(-)\n\n","diff_code":"diff --git a\/libyara\/exec.c b\/libyara\/exec.c\nindex 14128cf0..0b58999e 100644\n--- a\/libyara\/exec.c\n+++ b\/libyara\/exec.c\n@@ -850,6 +850,7 @@ int yr_execute_code(\n           (uint8_t*) r2.re->code,\n           (uint8_t*) r1.ss->c_string,\n           r1.ss->length,\n+          0,\n           r2.re->flags | RE_FLAGS_SCAN,\n           NULL,\n           NULL) >= 0;\ndiff --git a\/libyara\/include\/yara\/re.h b\/libyara\/include\/yara\/re.h\nindex a9645bb6..f2393064 100644\n--- a\/libyara\/include\/yara\/re.h\n+++ b\/libyara\/include\/yara\/re.h\n@@ -94,7 +94,6 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n #define RE_FLAGS_NO_CASE                0x20\n #define RE_FLAGS_SCAN                   0x40\n #define RE_FLAGS_DOT_ALL                0x80\n-#define RE_FLAGS_NOT_AT_START          0x100\n #define RE_FLAGS_GREEDY                0x400\n #define RE_FLAGS_UNGREEDY              0x800\n \n@@ -107,14 +106,6 @@ typedef struct RE_ERROR RE_ERROR;\n typedef uint8_t RE_SPLIT_ID_TYPE;\n \n \n-#define CHAR_IN_CLASS(chr, cls)  \\\n-    ((cls)[(chr) \/ 8] & 1 << ((chr) % 8))\n-\n-\n-#define IS_WORD_CHAR(chr) \\\n-    (isalnum(chr) || (chr) == '_')\n-\n-\n struct RE_NODE\n {\n   int type;\n@@ -213,7 +204,8 @@ void yr_re_node_destroy(\n int yr_re_exec(\n     uint8_t* re_code,\n     uint8_t* input,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args);\n@@ -222,7 +214,8 @@ int yr_re_exec(\n int yr_re_fast_exec(\n     uint8_t* re_code,\n     uint8_t* input,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args);\ndiff --git a\/libyara\/re.c b\/libyara\/re.c\nindex dcb063c7..6257a816 100644\n--- a\/libyara\/re.c\n+++ b\/libyara\/re.c\n@@ -140,6 +140,24 @@ typedef struct _RE_THREAD_STORAGE\n YR_THREAD_STORAGE_KEY thread_storage_key = 0;\n \n \n+#define CHAR_IN_CLASS(chr, cls)  \\\n+    ((cls)[(chr) \/ 8] & 1 << ((chr) % 8))\n+\n+\n+int _yr_re_is_word_char(\n+    uint8_t* input,\n+    int character_size)\n+{\n+  int result = ((isalnum(*input) || (*input) == '_'));\n+\n+  if (character_size == 2)\n+    result = result && (*(input + 1) == 0);\n+\n+  return result;\n+}\n+\n+\n+\n \/\/\n \/\/ yr_re_initialize\n \/\/\n@@ -360,6 +378,7 @@ int yr_re_match(\n       re->code,\n       (uint8_t*) target,\n       strlen(target),\n+      0,\n       re->flags | RE_FLAGS_SCAN,\n       NULL,\n       NULL);\n@@ -1799,18 +1818,30 @@ int _yr_re_fiber_sync(\n \/\/\n \/\/ yr_re_exec\n \/\/\n-\/\/ Executes a regular expression\n+\/\/ Executes a regular expression. The specified regular expression will try to\n+\/\/ match the data starting at the address specified by \"input\". The \"input\"\n+\/\/ pointer can point to any address inside a memory buffer. Arguments\n+\/\/ \"input_forwards_size\" and \"input_backwards_size\" indicate how many bytes\n+\/\/ can be accesible starting at \"input\" and going forwards and backwards\n+\/\/ respectively.\n+\/\/\n+\/\/   <--- input_backwards_size -->|<----------- input_forwards_size -------->\n+\/\/  |--------  memory buffer  -----------------------------------------------|\n+\/\/                                ^\n+\/\/                              input\n \/\/\n \/\/ Args:\n \/\/   uint8_t* re_code                 - Regexp code be executed\n \/\/   uint8_t* input                   - Pointer to input data\n-\/\/   size_t input_size                - Input data size\n+\/\/   size_t input_forwards_size       - Number of accessible bytes starting at\n+\/\/                                      \"input\" and going forwards.\n+\/\/   size_t input_backwards_size      - Number of accessible bytes starting at\n+\/\/                                      \"input\" and going backwards\n \/\/   int flags                        - Flags:\n \/\/      RE_FLAGS_SCAN\n \/\/      RE_FLAGS_BACKWARDS\n \/\/      RE_FLAGS_EXHAUSTIVE\n \/\/      RE_FLAGS_WIDE\n-\/\/      RE_FLAGS_NOT_AT_START\n \/\/      RE_FLAGS_NO_CASE\n \/\/      RE_FLAGS_DOT_ALL\n \/\/   RE_MATCH_CALLBACK_FUNC callback  - Callback function\n@@ -1825,10 +1856,12 @@ int _yr_re_fiber_sync(\n \/\/      -4  Too many fibers\n \/\/      -5  Unknown fatal error\n \n+\n int yr_re_exec(\n     uint8_t* re_code,\n     uint8_t* input_data,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args)\n@@ -1858,18 +1891,23 @@ int yr_re_exec(\n   #define ACTION_KILL       2\n   #define ACTION_KILL_TAIL  3\n \n-  #define prolog if (bytes_matched >= max_bytes_matched) \\\n+  #define prolog { \\\n+      if ((bytes_matched >= max_bytes_matched) || \\\n+          (character_size == 2 && *(input + 1) != 0)) \\\n       { \\\n         action = ACTION_KILL; \\\n         break; \\\n-      }\n+      } \\\n+    }\n \n-  #define fail_if_error(e) switch (e) { \\\n+  #define fail_if_error(e) { \\\n+      switch (e) { \\\n         case ERROR_INSUFFICIENT_MEMORY: \\\n           return -2; \\\n         case ERROR_TOO_MANY_RE_FIBERS: \\\n           return -4; \\\n-      }\n+      } \\\n+    }\n \n   if (_yr_re_alloc_storage(&storage) != ERROR_SUCCESS)\n     return -2;\n@@ -1884,14 +1922,17 @@ int yr_re_exec(\n \n   if (flags & RE_FLAGS_BACKWARDS)\n   {\n+    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);\n     input -= character_size;\n     input_incr = -input_incr;\n   }\n-\n-  max_bytes_matched = (int) yr_min(input_size, RE_SCAN_LIMIT);\n+  else\n+  {\n+    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);\n+  }\n \n   \/\/ Round down max_bytes_matched to a multiple of character_size, this way if\n-  \/\/ character_size is 2 and input_size is odd we are ignoring the\n+  \/\/ character_size is 2 and max_bytes_matched is odd we are ignoring the\n   \/\/ extra byte which can't match anyways.\n \n   max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;\n@@ -1973,14 +2014,14 @@ int yr_re_exec(\n \n         case RE_OPCODE_WORD_CHAR:\n           prolog;\n-          match = IS_WORD_CHAR(*input);\n+          match = _yr_re_is_word_char(input, character_size);\n           action = match ? ACTION_NONE : ACTION_KILL;\n           fiber->ip += 1;\n           break;\n \n         case RE_OPCODE_NON_WORD_CHAR:\n           prolog;\n-          match = !IS_WORD_CHAR(*input);\n+          match = !_yr_re_is_word_char(input, character_size);\n           action = match ? ACTION_NONE : ACTION_KILL;\n           fiber->ip += 1;\n           break;\n@@ -2028,16 +2069,25 @@ int yr_re_exec(\n         case RE_OPCODE_WORD_BOUNDARY:\n         case RE_OPCODE_NON_WORD_BOUNDARY:\n \n-          if (bytes_matched == 0 &&\n-              !(flags & RE_FLAGS_NOT_AT_START) &&\n-              !(flags & RE_FLAGS_BACKWARDS))\n+          if (bytes_matched == 0 && input_backwards_size < character_size)\n+          {\n             match = TRUE;\n+          }\n           else if (bytes_matched >= max_bytes_matched)\n+          {\n             match = TRUE;\n-          else if (IS_WORD_CHAR(*(input - input_incr)) != IS_WORD_CHAR(*input))\n-            match = TRUE;\n+          }\n           else\n-            match = FALSE;\n+          {\n+            assert(input <  input_data + input_forwards_size);\n+            assert(input >= input_data - input_backwards_size);\n+\n+            assert(input - input_incr <  input_data + input_forwards_size);\n+            assert(input - input_incr >= input_data - input_backwards_size);\n+\n+            match = _yr_re_is_word_char(input, character_size) != \\\n+                    _yr_re_is_word_char(input - input_incr, character_size);\n+          }\n \n           if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)\n             match = !match;\n@@ -2048,16 +2098,16 @@ int yr_re_exec(\n \n         case RE_OPCODE_MATCH_AT_START:\n           if (flags & RE_FLAGS_BACKWARDS)\n-            kill = input_size > (size_t) bytes_matched;\n+            kill = input_backwards_size > (size_t) bytes_matched;\n           else\n-            kill = (flags & RE_FLAGS_NOT_AT_START) || (bytes_matched != 0);\n+            kill = input_backwards_size > 0 || (bytes_matched != 0);\n           action = kill ? ACTION_KILL : ACTION_CONTINUE;\n           fiber->ip += 1;\n           break;\n \n         case RE_OPCODE_MATCH_AT_END:\n           kill = flags & RE_FLAGS_BACKWARDS ||\n-                 input_size > (size_t) bytes_matched;\n+                 input_forwards_size > (size_t) bytes_matched;\n           action = kill ? ACTION_KILL : ACTION_CONTINUE;\n           fiber->ip += 1;\n           break;\n@@ -2134,13 +2184,6 @@ int yr_re_exec(\n       }\n     }\n \n-    if (flags & RE_FLAGS_WIDE &&\n-        bytes_matched < max_bytes_matched &&\n-        *(input + 1) != 0)\n-    {\n-      _yr_re_fiber_kill_all(&fibers, &storage->fiber_pool);\n-    }\n-\n     input += input_incr;\n     bytes_matched += character_size;\n \n@@ -2164,7 +2207,8 @@ int yr_re_exec(\n int yr_re_fast_exec(\n     uint8_t* code,\n     uint8_t* input_data,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args)\n@@ -2187,7 +2231,11 @@ int yr_re_fast_exec(\n   int input_incr;\n   int sp = 0;\n   int bytes_matched;\n-  int max_bytes_matched = input_size;\n+  int max_bytes_matched;\n+\n+  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?\n+      input_backwards_size :\n+      input_forwards_size;\n \n   input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;\n \ndiff --git a\/libyara\/scan.c b\/libyara\/scan.c\nindex 93fcf8d1..88a7d84a 100644\n--- a\/libyara\/scan.c\n+++ b\/libyara\/scan.c\n@@ -528,7 +528,8 @@ int _yr_scan_match_callback(\n typedef int (*RE_EXEC_FUNC)(\n     uint8_t* code,\n     uint8_t* input,\n-    size_t input_size,\n+    size_t input_forwards_size,\n+    size_t input_backwards_size,\n     int flags,\n     RE_MATCH_CALLBACK_FUNC callback,\n     void* callback_args);\n@@ -569,7 +570,8 @@ int _yr_scan_verify_re_match(\n         ac_match->forward_code,\n         data + offset,\n         data_size - offset,\n-        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\n+        offset,\n+        flags,\n         NULL,\n         NULL);\n   }\n@@ -581,7 +583,8 @@ int _yr_scan_verify_re_match(\n         ac_match->forward_code,\n         data + offset,\n         data_size - offset,\n-        offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags,\n+        offset,\n+        flags,\n         NULL,\n         NULL);\n   }\n@@ -616,6 +619,7 @@ int _yr_scan_verify_re_match(\n     backward_matches = exec(\n         ac_match->backward_code,\n         data + offset,\n+        data_size - offset,\n         offset,\n         flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE,\n         _yr_scan_match_callback,\ndiff --git a\/tests\/test-rules.c b\/tests\/test-rules.c\nindex c26a25f4..63433e08 100644\n--- a\/tests\/test-rules.c\n+++ b\/tests\/test-rules.c\n@@ -901,6 +901,50 @@ void test_re()\n       \"rule test { strings: $a = \/a.{1,2}b\/ wide condition: !a == 8 }\",\n       \"a\\0x\\0x\\0b\\0\");\n \n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = \/\\\\babc\/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = \/\\\\babc\/ wide condition: $a }\",\n+      \"\\0a\\0b\\0c\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = \/\\\\babc\/ wide condition: $a }\",\n+      \"\\ta\\0b\\0c\\0\");\n+\n+  assert_false_rule_blob(\n+      \"rule test { strings: $a = \/\\\\babc\/ wide condition: $a }\",\n+      \"x\\0a\\0b\\0c\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = \/\\\\babc\/ wide condition: $a }\",\n+      \"x\\ta\\0b\\0c\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = \/abc\\\\b\/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = \/abc\\\\b\/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = \/abc\\\\b\/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0\\t\");\n+\n+  assert_false_rule_blob(\n+      \"rule test { strings: $a = \/abc\\\\b\/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0x\\0\");\n+\n+  assert_true_rule_blob(\n+      \"rule test { strings: $a = \/abc\\\\b\/ wide condition: $a }\",\n+      \"a\\0b\\0c\\0b\\t\");\n+\n+  assert_false_rule_blob(\n+      \"rule test { strings: $a = \/\\\\b\/ wide condition: $a }\",\n+      \"abc\");\n+\n   assert_regexp_syntax_error(\")\");\n   assert_true_regexp(\"abc\", \"abc\", \"abc\");\n   assert_false_regexp(\"abc\", \"xbc\");\n","owner":"VirusTotal","repo":"yara","source":"cve"},{"CVE_ID":"CVE-2016-5352","CWE_ID":"125","category":"security","commit_id":"b6d838eebf4456192360654092e5587c5207f185","commit_message":"From b6d838eebf4456192360654092e5587c5207f185 Mon Sep 17 00:00:00 2001\nFrom: Michael Mann <mmann78@netscape.net>\nDate: Mon, 9 May 2016 20:41:45 -0400\nSubject: [PATCH] Sanity check eapol_len in AirPDcapDecryptWPABroadcastKey\n\nBug: 12175\nChange-Id: Iaf977ba48f8668bf8095800a115ff9a3472dd893\nReviewed-on: https:\/\/code.wireshark.org\/review\/15326\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>\nReviewed-by: Peter Wu <peter@lekensteyn.nl>\nTested-by: Peter Wu <peter@lekensteyn.nl>\n---\n epan\/crypt\/airpdcap.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/epan\/crypt\/airpdcap.c b\/epan\/crypt\/airpdcap.c\nindex bb4d7bc43d..dd948a0d1d 100644\n--- a\/epan\/crypt\/airpdcap.c\n+++ b\/epan\/crypt\/airpdcap.c\n@@ -351,7 +351,9 @@ AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_\n         }\n     }\n \n-    if (key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {\n+    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n+        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n+        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n         return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n     }\n \n","owner":"wireshark","repo":"wireshark","source":"cve"},{"CVE_ID":"CVE-2016-10208","CWE_ID":"125","category":"security","commit_id":"3a4b77cd47bb837b8557595ec7425f281f2ca1fe","commit_message":"From 3a4b77cd47bb837b8557595ec7425f281f2ca1fe Mon Sep 17 00:00:00 2001\nFrom: Eryu Guan <guaneryu@gmail.com>\nDate: Thu, 1 Dec 2016 15:08:37 -0500\nSubject: [PATCH] ext4: validate s_first_meta_bg at mount time\n\nRalf Spenneberg reported that he hit a kernel crash when mounting a\nmodified ext4 image. And it turns out that kernel crashed when\ncalculating fs overhead (ext4_calculate_overhead()), this is because\nthe image has very large s_first_meta_bg (debug code shows it's\n842150400), and ext4 overruns the memory in count_overhead() when\nsetting bitmap buffer, which is PAGE_SIZE.\n\next4_calculate_overhead():\n  buf = get_zeroed_page(GFP_NOFS);  <=== PAGE_SIZE buffer\n  blks = count_overhead(sb, i, buf);\n\ncount_overhead():\n  for (j = ext4_bg_num_gdb(sb, grp); j > 0; j--) { <=== j = 842150400\n          ext4_set_bit(EXT4_B2C(sbi, s++), buf);   <=== buffer overrun\n          count++;\n  }\n\nThis can be reproduced easily for me by this script:\n\n  #!\/bin\/bash\n  rm -f fs.img\n  mkdir -p \/mnt\/ext4\n  fallocate -l 16M fs.img\n  mke2fs -t ext4 -O bigalloc,meta_bg,^resize_inode -F fs.img\n  debugfs -w -R \"ssv first_meta_bg 842150400\" fs.img\n  mount -o loop fs.img \/mnt\/ext4\n\nFix it by validating s_first_meta_bg first at mount time, and\nrefusing to mount if its value exceeds the largest possible meta_bg\nnumber.\n\nReported-by: Ralf Spenneberg <ralf@os-t.de>\nSigned-off-by: Eryu Guan <guaneryu@gmail.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nReviewed-by: Andreas Dilger <adilger@dilger.ca>\n---\n fs\/ext4\/super.c | 9 +++++++++\n 1 file changed, 9 insertions(+)\n\n","diff_code":"diff --git a\/fs\/ext4\/super.c b\/fs\/ext4\/super.c\nindex a526956e49e78..32c0debbaa923 100644\n--- a\/fs\/ext4\/super.c\n+++ b\/fs\/ext4\/super.c\n@@ -3842,6 +3842,15 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n \t\t\t(EXT4_MAX_BLOCK_FILE_PHYS \/ EXT4_BLOCKS_PER_GROUP(sb)));\n \tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) \/\n \t\t   EXT4_DESC_PER_BLOCK(sb);\n+\tif (ext4_has_feature_meta_bg(sb)) {\n+\t\tif (le32_to_cpu(es->s_first_meta_bg) >= db_count) {\n+\t\t\text4_msg(sb, KERN_WARNING,\n+\t\t\t\t \"first meta block group too large: %u \"\n+\t\t\t\t \"(group descriptor block count %u)\",\n+\t\t\t\t le32_to_cpu(es->s_first_meta_bg), db_count);\n+\t\t\tgoto failed_mount;\n+\t\t}\n+\t}\n \tsbi->s_group_desc = ext4_kvmalloc(db_count *\n \t\t\t\t\t  sizeof(struct buffer_head *),\n \t\t\t\t\t  GFP_KERNEL);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-1833","CWE_ID":"125","category":"security","commit_id":"0bcd05c5cd83dec3406c8f68b769b1d610c72f76","commit_message":"From 0bcd05c5cd83dec3406c8f68b769b1d610c72f76 Mon Sep 17 00:00:00 2001\nFrom: Pranjal Jumde <pjumde@apple.com>\nDate: Tue, 1 Mar 2016 15:18:04 -0800\nSubject: [PATCH] Heap-based buffer overread in htmlCurrentChar\n\nFor https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=758606\n\n* parserInternals.c:\n(xmlNextChar): Add an test to catch other issues on ctxt->input\ncorruption proactively.\nFor non-UTF-8 charsets, xmlNextChar() failed to check for the end\nof the input buffer and would continuing reading.  Fix this by\npulling out the check for the end of the input buffer into common\ncode, and return if we reach the end of the input buffer\nprematurely.\n* result\/HTML\/758606.html: Added.\n* result\/HTML\/758606.html.err: Added.\n* result\/HTML\/758606.html.sax: Added.\n* result\/HTML\/758606_2.html: Added.\n* result\/HTML\/758606_2.html.err: Added.\n* result\/HTML\/758606_2.html.sax: Added.\n* test\/HTML\/758606.html: Added test case.\n* test\/HTML\/758606_2.html: Added test case.\n---\n parserInternals.c             | 172 ++++++++++++++++++----------------\n result\/HTML\/758606.html       |   2 +\n result\/HTML\/758606.html.err   |  16 ++++\n result\/HTML\/758606.html.sax   |  10 ++\n result\/HTML\/758606_2.html     |   2 +\n result\/HTML\/758606_2.html.err |  16 ++++\n result\/HTML\/758606_2.html.sax |  17 ++++\n test\/HTML\/758606.html         |   1 +\n test\/HTML\/758606_2.html       |   1 +\n 9 files changed, 154 insertions(+), 83 deletions(-)\n create mode 100644 result\/HTML\/758606.html\n create mode 100644 result\/HTML\/758606.html.err\n create mode 100644 result\/HTML\/758606.html.sax\n create mode 100644 result\/HTML\/758606_2.html\n create mode 100644 result\/HTML\/758606_2.html.err\n create mode 100644 result\/HTML\/758606_2.html.sax\n create mode 100644 test\/HTML\/758606.html\n create mode 100644 test\/HTML\/758606_2.html\n\n","diff_code":"diff --git a\/parserInternals.c b\/parserInternals.c\nindex 8c796788..bfc778ac 100644\n--- a\/parserInternals.c\n+++ b\/parserInternals.c\n@@ -55,6 +55,10 @@\n #include <libxml\/globals.h>\n #include <libxml\/chvalid.h>\n \n+#define CUR(ctxt) ctxt->input->cur\n+#define END(ctxt) ctxt->input->end\n+#define VALID_CTXT(ctxt) (CUR(ctxt) <= END(ctxt))\n+\n #include \"buf.h\"\n #include \"enc.h\"\n \n@@ -422,103 +426,105 @@ xmlNextChar(xmlParserCtxtPtr ctxt)\n         (ctxt->input == NULL))\n         return;\n \n-    if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n-        if ((*ctxt->input->cur == 0) &&\n-            (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0) &&\n-            (ctxt->instate != XML_PARSER_COMMENT)) {\n-            \/*\n-             * If we are at the end of the current entity and\n-             * the context allows it, we pop consumed entities\n-             * automatically.\n-             * the auto closing should be blocked in other cases\n-             *\/\n+    if (!(VALID_CTXT(ctxt))) {\n+        xmlErrInternal(ctxt, \"Parser input data memory error\\n\", NULL);\n+\tctxt->errNo = XML_ERR_INTERNAL_ERROR;\n+        xmlStopParser(ctxt);\n+\treturn;\n+    }\n+\n+    if ((*ctxt->input->cur == 0) &&\n+        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {\n+        if ((ctxt->instate != XML_PARSER_COMMENT))\n             xmlPopInput(ctxt);\n-        } else {\n-            const unsigned char *cur;\n-            unsigned char c;\n+        return;\n+    }\n \n-            \/*\n-             *   2.11 End-of-Line Handling\n-             *   the literal two-character sequence \"#xD#xA\" or a standalone\n-             *   literal #xD, an XML processor must pass to the application\n-             *   the single character #xA.\n-             *\/\n-            if (*(ctxt->input->cur) == '\\n') {\n-                ctxt->input->line++; ctxt->input->col = 1;\n-            } else\n-                ctxt->input->col++;\n+    if (ctxt->charset == XML_CHAR_ENCODING_UTF8) {\n+        const unsigned char *cur;\n+        unsigned char c;\n \n-            \/*\n-             * We are supposed to handle UTF8, check it's valid\n-             * From rfc2044: encoding of the Unicode values on UTF-8:\n-             *\n-             * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-             * 0000 0000-0000 007F   0xxxxxxx\n-             * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-             * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-             *\n-             * Check for the 0x110000 limit too\n-             *\/\n-            cur = ctxt->input->cur;\n+        \/*\n+         *   2.11 End-of-Line Handling\n+         *   the literal two-character sequence \"#xD#xA\" or a standalone\n+         *   literal #xD, an XML processor must pass to the application\n+         *   the single character #xA.\n+         *\/\n+        if (*(ctxt->input->cur) == '\\n') {\n+            ctxt->input->line++; ctxt->input->col = 1;\n+        } else\n+            ctxt->input->col++;\n \n-            c = *cur;\n-            if (c & 0x80) {\n-\t        if (c == 0xC0)\n-\t\t    goto encoding_error;\n-                if (cur[1] == 0) {\n+        \/*\n+         * We are supposed to handle UTF8, check it's valid\n+         * From rfc2044: encoding of the Unicode values on UTF-8:\n+         *\n+         * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n+         * 0000 0000-0000 007F   0xxxxxxx\n+         * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n+         * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n+         *\n+         * Check for the 0x110000 limit too\n+         *\/\n+        cur = ctxt->input->cur;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+        if (c == 0xC0)\n+\t    goto encoding_error;\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                cur = ctxt->input->cur;\n+            }\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                unsigned int val;\n+\n+                if (cur[2] == 0) {\n                     xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                     cur = ctxt->input->cur;\n                 }\n-                if ((cur[1] & 0xc0) != 0x80)\n+                if ((cur[2] & 0xc0) != 0x80)\n                     goto encoding_error;\n-                if ((c & 0xe0) == 0xe0) {\n-                    unsigned int val;\n-\n-                    if (cur[2] == 0) {\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n                         xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n                         cur = ctxt->input->cur;\n                     }\n-                    if ((cur[2] & 0xc0) != 0x80)\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n                         goto encoding_error;\n-                    if ((c & 0xf0) == 0xf0) {\n-                        if (cur[3] == 0) {\n-                            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-                            cur = ctxt->input->cur;\n-                        }\n-                        if (((c & 0xf8) != 0xf0) ||\n-                            ((cur[3] & 0xc0) != 0x80))\n-                            goto encoding_error;\n-                        \/* 4-byte code *\/\n-                        ctxt->input->cur += 4;\n-                        val = (cur[0] & 0x7) << 18;\n-                        val |= (cur[1] & 0x3f) << 12;\n-                        val |= (cur[2] & 0x3f) << 6;\n-                        val |= cur[3] & 0x3f;\n-                    } else {\n-                        \/* 3-byte code *\/\n-                        ctxt->input->cur += 3;\n-                        val = (cur[0] & 0xf) << 12;\n-                        val |= (cur[1] & 0x3f) << 6;\n-                        val |= cur[2] & 0x3f;\n-                    }\n-                    if (((val > 0xd7ff) && (val < 0xe000)) ||\n-                        ((val > 0xfffd) && (val < 0x10000)) ||\n-                        (val >= 0x110000)) {\n-\t\t\txmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n-\t\t\t\t\t  \"Char 0x%X out of allowed range\\n\",\n-\t\t\t\t\t  val);\n-                    }\n-                } else\n-                    \/* 2-byte code *\/\n-                    ctxt->input->cur += 2;\n+                    \/* 4-byte code *\/\n+                    ctxt->input->cur += 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                } else {\n+                    \/* 3-byte code *\/\n+                    ctxt->input->cur += 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                }\n+                if (((val > 0xd7ff) && (val < 0xe000)) ||\n+                    ((val > 0xfffd) && (val < 0x10000)) ||\n+                    (val >= 0x110000)) {\n+\t\txmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n+\t\t\t\t  \"Char 0x%X out of allowed range\\n\",\n+\t\t\t\t  val);\n+                }\n             } else\n-                \/* 1-byte code *\/\n-                ctxt->input->cur++;\n+                \/* 2-byte code *\/\n+                ctxt->input->cur += 2;\n+        } else\n+            \/* 1-byte code *\/\n+            ctxt->input->cur++;\n \n-            ctxt->nbChars++;\n-            if (*ctxt->input->cur == 0)\n-                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-        }\n+        ctxt->nbChars++;\n+        if (*ctxt->input->cur == 0)\n+            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n     } else {\n         \/*\n          * Assume it's a fixed length encoding (1) with\ndiff --git a\/result\/HTML\/758606.html b\/result\/HTML\/758606.html\nnew file mode 100644\nindex 00000000..4f21f628\n--- \/dev\/null\n+++ b\/result\/HTML\/758606.html\n@@ -0,0 +1,2 @@\n+<!DOCTYPE >\n+\ndiff --git a\/result\/HTML\/758606.html.err b\/result\/HTML\/758606.html.err\nnew file mode 100644\nindex 00000000..060433a8\n--- \/dev\/null\n+++ b\/result\/HTML\/758606.html.err\n@@ -0,0 +1,16 @@\n+.\/test\/HTML\/758606.html:1: HTML parser error : Comment not terminated \n+<!--\n+<!--\f<!doctype\n+    ^\n+.\/test\/HTML\/758606.html:1: HTML parser error : Invalid char in CDATA 0xC\n+<!--\f<!doctype\n+    ^\n+.\/test\/HTML\/758606.html:1: HTML parser error : Misplaced DOCTYPE declaration\n+<!--\f<!doctype\n+     ^\n+.\/test\/HTML\/758606.html:2: HTML parser error : htmlParseDocTypeDecl : no DOCTYPE name !\n+\n+^\n+.\/test\/HTML\/758606.html:2: HTML parser error : DOCTYPE improperly terminated\n+\n+^\ndiff --git a\/result\/HTML\/758606.html.sax b\/result\/HTML\/758606.html.sax\nnew file mode 100644\nindex 00000000..d44a5cf4\n--- \/dev\/null\n+++ b\/result\/HTML\/758606.html.sax\n@@ -0,0 +1,10 @@\n+SAX.setDocumentLocator()\n+SAX.startDocument()\n+SAX.error: Comment not terminated \n+<!--\n+SAX.error: Invalid char in CDATA 0xC\n+SAX.error: Misplaced DOCTYPE declaration\n+SAX.error: htmlParseDocTypeDecl : no DOCTYPE name !\n+SAX.error: DOCTYPE improperly terminated\n+SAX.internalSubset((null), , )\n+SAX.endDocument()\ndiff --git a\/result\/HTML\/758606_2.html b\/result\/HTML\/758606_2.html\nnew file mode 100644\nindex 00000000..273816a0\n--- \/dev\/null\n+++ b\/result\/HTML\/758606_2.html\n@@ -0,0 +1,2 @@\n+<!DOCTYPE >\n+<html><body><p>&#145;<\/p><\/body><\/html>\ndiff --git a\/result\/HTML\/758606_2.html.err b\/result\/HTML\/758606_2.html.err\nnew file mode 100644\nindex 00000000..4be039f4\n--- \/dev\/null\n+++ b\/result\/HTML\/758606_2.html.err\n@@ -0,0 +1,16 @@\n+.\/test\/HTML\/758606_2.html:1: HTML parser error : Comment not terminated \n+<!--\n+<!--\f<!dOctYPE\n+    ^\n+.\/test\/HTML\/758606_2.html:1: HTML parser error : Invalid char in CDATA 0xC\n+<!--\f<!dOctYPE\n+    ^\n+.\/test\/HTML\/758606_2.html:1: HTML parser error : Misplaced DOCTYPE declaration\n+\u0091<!dOctYPE\n+  ^\n+.\/test\/HTML\/758606_2.html:2: HTML parser error : htmlParseDocTypeDecl : no DOCTYPE name !\n+\n+^\n+.\/test\/HTML\/758606_2.html:2: HTML parser error : DOCTYPE improperly terminated\n+\n+^\ndiff --git a\/result\/HTML\/758606_2.html.sax b\/result\/HTML\/758606_2.html.sax\nnew file mode 100644\nindex 00000000..80ff3d77\n--- \/dev\/null\n+++ b\/result\/HTML\/758606_2.html.sax\n@@ -0,0 +1,17 @@\n+SAX.setDocumentLocator()\n+SAX.startDocument()\n+SAX.error: Comment not terminated \n+<!--\n+SAX.error: Invalid char in CDATA 0xC\n+SAX.startElement(html)\n+SAX.startElement(body)\n+SAX.startElement(p)\n+SAX.characters(&#145;, 2)\n+SAX.error: Misplaced DOCTYPE declaration\n+SAX.error: htmlParseDocTypeDecl : no DOCTYPE name !\n+SAX.error: DOCTYPE improperly terminated\n+SAX.internalSubset((null), , )\n+SAX.endElement(p)\n+SAX.endElement(body)\n+SAX.endElement(html)\n+SAX.endDocument()\ndiff --git a\/test\/HTML\/758606.html b\/test\/HTML\/758606.html\nnew file mode 100644\nindex 00000000..01a013c5\n--- \/dev\/null\n+++ b\/test\/HTML\/758606.html\n@@ -0,0 +1 @@\n+<!--\f<!doctype\ndiff --git a\/test\/HTML\/758606_2.html b\/test\/HTML\/758606_2.html\nnew file mode 100644\nindex 00000000..daa185b8\n--- \/dev\/null\n+++ b\/test\/HTML\/758606_2.html\n@@ -0,0 +1 @@\n+<!--\f<!dOctYPE\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5923","CWE_ID":"125","category":"security","commit_id":"ab906da53ff2a68c6fd6d1fa73f2b7c7bf0bc636","commit_message":"From ab906da53ff2a68c6fd6d1fa73f2b7c7bf0bc636 Mon Sep 17 00:00:00 2001\nFrom: plusvic <plusvic@gmail.com>\nDate: Mon, 23 Jan 2017 18:08:51 +0100\nSubject: [PATCH] Fix issue #597\n\n---\n libyara\/grammar.c | 296 +++++++++++++++++++++++-----------------------\n libyara\/grammar.y |   6 +\n 2 files changed, 157 insertions(+), 145 deletions(-)\n\n","diff_code":"diff --git a\/libyara\/grammar.c b\/libyara\/grammar.c\nindex 32427e6e..34fe1f23 100644\n--- a\/libyara\/grammar.c\n+++ b\/libyara\/grammar.c\n@@ -611,14 +611,14 @@ static const yytype_uint16 yyrline[] =\n      347,   353,   356,   374,   387,   424,   425,   430,   446,   459,\n      472,   485,   502,   503,   509,   508,   524,   523,   539,   553,\n      554,   559,   560,   561,   562,   567,   652,   698,   756,   801,\n-     802,   806,   831,   867,   913,   935,   944,   953,   968,   980,\n-     994,  1007,  1018,  1027,  1057,  1026,  1171,  1170,  1249,  1255,\n-    1262,  1261,  1324,  1323,  1384,  1393,  1402,  1411,  1420,  1429,\n-    1438,  1442,  1450,  1451,  1456,  1478,  1490,  1506,  1505,  1511,\n-    1522,  1523,  1528,  1535,  1546,  1547,  1551,  1559,  1563,  1573,\n-    1587,  1603,  1613,  1622,  1647,  1659,  1671,  1687,  1699,  1715,\n-    1760,  1779,  1797,  1815,  1833,  1859,  1877,  1887,  1897,  1907,\n-    1917,  1927,  1937\n+     802,   806,   833,   871,   917,   939,   948,   957,   972,   984,\n+     998,  1011,  1022,  1033,  1063,  1032,  1177,  1176,  1255,  1261,\n+    1268,  1267,  1330,  1329,  1390,  1399,  1408,  1417,  1426,  1435,\n+    1444,  1448,  1456,  1457,  1462,  1484,  1496,  1512,  1511,  1517,\n+    1528,  1529,  1534,  1541,  1552,  1553,  1557,  1565,  1569,  1579,\n+    1593,  1609,  1619,  1628,  1653,  1665,  1677,  1693,  1705,  1721,\n+    1766,  1785,  1803,  1821,  1839,  1865,  1883,  1893,  1903,  1913,\n+    1923,  1933,  1943\n };\n #endif\n \n@@ -2361,15 +2361,17 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           case EXPRESSION_TYPE_REGEXP:\n             strlcpy((yyval.c_string), \"r\", MAX_FUNCTION_ARGS);\n             break;\n+          default:\n+            assert(FALSE);\n         }\n \n         ERROR_IF((yyval.c_string) == NULL);\n       }\n-#line 2369 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2371 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 52:\n-#line 832 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 834 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         if (strlen((yyvsp[-2].c_string)) == MAX_FUNCTION_ARGS)\n         {\n@@ -2394,6 +2396,8 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n             case EXPRESSION_TYPE_REGEXP:\n               strlcat((yyvsp[-2].c_string), \"r\", MAX_FUNCTION_ARGS);\n               break;\n+            default:\n+              assert(FALSE);\n           }\n         }\n \n@@ -2401,11 +2405,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.c_string) = (yyvsp[-2].c_string);\n       }\n-#line 2405 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2409 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 53:\n-#line 868 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 872 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         SIZED_STRING* sized_string = (yyvsp[0].sized_string);\n         RE* re;\n@@ -2447,11 +2451,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_REGEXP;\n       }\n-#line 2451 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2455 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 54:\n-#line 914 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 918 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)\n         {\n@@ -2470,11 +2474,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2474 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2478 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 55:\n-#line 936 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 940 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n@@ -2483,11 +2487,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2487 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2491 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 56:\n-#line 945 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 949 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 0, NULL, NULL);\n@@ -2496,11 +2500,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2500 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2504 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 57:\n-#line 954 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 958 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"matches\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, \"matches\");\n@@ -2515,11 +2519,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2519 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2523 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 58:\n-#line 969 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 973 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, \"contains\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_STRING, \"contains\");\n@@ -2531,11 +2535,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2535 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2539 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 59:\n-#line 981 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 985 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         int result = yr_parser_reduce_string_identifier(\n             yyscanner,\n@@ -2549,11 +2553,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2553 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2557 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 60:\n-#line 995 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 999 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"at\");\n \n@@ -2566,11 +2570,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2570 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2574 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 61:\n-#line 1008 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1012 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);\n@@ -2581,23 +2585,25 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2585 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2589 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 62:\n-#line 1019 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1023 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         if (compiler->loop_depth > 0)\n         {\n           compiler->loop_depth--;\n           compiler->loop_identifier[compiler->loop_depth] = NULL;\n         }\n+\n+        YYERROR;\n       }\n-#line 2597 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2603 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 63:\n-#line 1027 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1033 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         int var_index;\n \n@@ -2627,11 +2633,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 2631 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2637 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 64:\n-#line 1057 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1063 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n@@ -2666,11 +2672,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);\n         compiler->loop_depth++;\n       }\n-#line 2670 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2676 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 65:\n-#line 1092 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1098 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         int mem_offset;\n \n@@ -2749,11 +2755,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2753 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2759 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 66:\n-#line 1171 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1177 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;\n         uint8_t* addr;\n@@ -2783,11 +2789,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         compiler->loop_identifier[compiler->loop_depth] = NULL;\n         compiler->loop_depth++;\n       }\n-#line 2787 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2793 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 67:\n-#line 1201 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1207 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         int mem_offset;\n \n@@ -2836,31 +2842,31 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n \n       }\n-#line 2840 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2846 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 68:\n-#line 1250 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1256 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         yr_parser_emit(yyscanner, OP_OF, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2850 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2856 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 69:\n-#line 1256 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1262 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         yr_parser_emit(yyscanner, OP_NOT, NULL);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2860 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2866 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 70:\n-#line 1262 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1268 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n@@ -2886,11 +2892,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n-#line 2890 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2896 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 71:\n-#line 1288 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1294 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         YR_FIXUP* fixup;\n         uint8_t* and_addr;\n@@ -2926,11 +2932,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2930 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2936 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 72:\n-#line 1324 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1330 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         YR_FIXUP* fixup;\n         void* jmp_destination_addr;\n@@ -2955,11 +2961,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         fixup->next = compiler->fixup_stack_head;\n         compiler->fixup_stack_head = fixup;\n       }\n-#line 2959 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 2965 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 73:\n-#line 1349 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1355 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         YR_FIXUP* fixup;\n         uint8_t* or_addr;\n@@ -2995,11 +3001,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 2999 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3005 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 74:\n-#line 1385 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1391 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<\", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3008,11 +3014,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3012 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3018 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 75:\n-#line 1394 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1400 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">\", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3021,11 +3027,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3025 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3031 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 76:\n-#line 1403 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1409 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"<=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3034,11 +3040,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3038 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3044 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 77:\n-#line 1412 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1418 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \">=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3047,11 +3053,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3051 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3057 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 78:\n-#line 1421 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1427 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"==\", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3060,11 +3066,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3064 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3070 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 79:\n-#line 1430 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1436 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"!=\", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3073,39 +3079,39 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;\n       }\n-#line 3077 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3083 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 80:\n-#line 1439 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1445 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n-#line 3085 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3091 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 81:\n-#line 1443 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1449 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n-#line 3093 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3099 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 82:\n-#line 1450 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1456 \"grammar.y\" \/* yacc.c:1646  *\/\n     { (yyval.integer) = INTEGER_SET_ENUMERATION; }\n-#line 3099 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3105 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 83:\n-#line 1451 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1457 \"grammar.y\" \/* yacc.c:1646  *\/\n     { (yyval.integer) = INTEGER_SET_RANGE; }\n-#line 3105 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3111 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 84:\n-#line 1457 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1463 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n@@ -3123,11 +3129,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3127 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3133 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 85:\n-#line 1479 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1485 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n@@ -3139,11 +3145,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3143 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3149 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 86:\n-#line 1491 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1497 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)\n         {\n@@ -3154,77 +3160,77 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3158 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3164 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 87:\n-#line 1506 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1512 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         \/\/ Push end-of-list marker\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n-#line 3167 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3173 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 89:\n-#line 1512 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1518 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n         yr_parser_emit_pushes_for_strings(yyscanner, \"$*\");\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3178 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3184 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 92:\n-#line 1529 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1535 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3189 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3195 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 93:\n-#line 1536 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1542 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));\n         yr_free((yyvsp[0].c_string));\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3200 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3206 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 95:\n-#line 1548 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1554 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);\n       }\n-#line 3208 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3214 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 96:\n-#line 1552 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1558 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);\n       }\n-#line 3216 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3222 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 97:\n-#line 1560 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1566 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.expression) = (yyvsp[-1].expression);\n       }\n-#line 3224 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3230 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 98:\n-#line 1564 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1570 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_emit(\n             yyscanner, OP_FILESIZE, NULL);\n@@ -3234,11 +3240,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3238 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3244 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 99:\n-#line 1574 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1580 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         yywarning(yyscanner,\n             \"Using deprecated \\\"entrypoint\\\" keyword. Use the \\\"entry_point\\\" \"\n@@ -3252,11 +3258,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3256 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3262 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 100:\n-#line 1588 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1594 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, \"intXXXX or uintXXXX\");\n \n@@ -3272,11 +3278,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3276 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3282 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 101:\n-#line 1604 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1610 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL);\n@@ -3286,11 +3292,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = (yyvsp[0].integer);\n       }\n-#line 3290 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3296 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 102:\n-#line 1614 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1620 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_emit_with_arg_double(\n             yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL);\n@@ -3299,11 +3305,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n       }\n-#line 3303 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3309 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 103:\n-#line 1623 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1629 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         SIZED_STRING* sized_string;\n \n@@ -3328,11 +3334,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_STRING;\n         (yyval.expression).value.sized_string = sized_string;\n       }\n-#line 3332 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3338 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 104:\n-#line 1648 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1654 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);\n@@ -3344,11 +3350,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3348 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3354 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 105:\n-#line 1660 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1666 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);\n@@ -3360,11 +3366,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3364 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3370 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 106:\n-#line 1672 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1678 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n@@ -3380,11 +3386,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3384 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3390 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 107:\n-#line 1688 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1694 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_string_identifier(\n             yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);\n@@ -3396,11 +3402,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3400 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3406 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 108:\n-#line 1700 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1706 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_emit_with_arg(\n             yyscanner, OP_PUSH, 1, NULL, NULL);\n@@ -3416,11 +3422,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = UNDEFINED;\n       }\n-#line 3420 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3426 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 109:\n-#line 1716 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1722 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  \/\/ loop identifier\n         {\n@@ -3465,11 +3471,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3469 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3475 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 110:\n-#line 1761 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1767 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, \"-\");\n \n@@ -3488,11 +3494,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n \n         ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n       }\n-#line 3492 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3498 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 111:\n-#line 1780 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1786 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"+\", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3510,11 +3516,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3514 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3520 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 112:\n-#line 1798 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1804 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"-\", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3532,11 +3538,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3536 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3542 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 113:\n-#line 1816 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1822 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"*\", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3554,11 +3560,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3558 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3564 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 114:\n-#line 1834 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1840 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         compiler->last_result = yr_parser_reduce_operation(\n             yyscanner, \"\\\\\", (yyvsp[-2].expression), (yyvsp[0].expression));\n@@ -3584,11 +3590,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           (yyval.expression).type = EXPRESSION_TYPE_FLOAT;\n         }\n       }\n-#line 3588 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3594 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 115:\n-#line 1860 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1866 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"%\");\n@@ -3606,11 +3612,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n           ERROR_IF(compiler->last_result != ERROR_SUCCESS);\n         }\n       }\n-#line 3610 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3616 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 116:\n-#line 1878 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1884 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n@@ -3620,11 +3626,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3624 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3630 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 117:\n-#line 1888 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1894 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"^\");\n@@ -3634,11 +3640,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3638 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3644 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 118:\n-#line 1898 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1904 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"|\");\n@@ -3648,11 +3654,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3652 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3658 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 119:\n-#line 1908 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1914 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"~\");\n \n@@ -3662,11 +3668,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?\n             UNDEFINED : ~((yyvsp[0].expression).value.integer);\n       }\n-#line 3666 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3672 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 120:\n-#line 1918 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1924 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \"<<\");\n@@ -3676,11 +3682,11 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3680 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3686 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 121:\n-#line 1928 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1934 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         CHECK_TYPE((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n         CHECK_TYPE((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, \">>\");\n@@ -3690,19 +3696,19 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n         (yyval.expression).type = EXPRESSION_TYPE_INTEGER;\n         (yyval.expression).value.integer = OPERATION(>>, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);\n       }\n-#line 3694 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3700 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n   case 122:\n-#line 1938 \"grammar.y\" \/* yacc.c:1646  *\/\n+#line 1944 \"grammar.y\" \/* yacc.c:1646  *\/\n     {\n         (yyval.expression) = (yyvsp[0].expression);\n       }\n-#line 3702 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3708 \"grammar.c\" \/* yacc.c:1646  *\/\n     break;\n \n \n-#line 3706 \"grammar.c\" \/* yacc.c:1646  *\/\n+#line 3712 \"grammar.c\" \/* yacc.c:1646  *\/\n       default: break;\n     }\n   \/* User semantic actions sometimes alter yychar, and that requires\n@@ -3930,5 +3936,5 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);\n #endif\n   return yyresult;\n }\n-#line 1943 \"grammar.y\" \/* yacc.c:1906  *\/\n+#line 1949 \"grammar.y\" \/* yacc.c:1906  *\/\n \ndiff --git a\/libyara\/grammar.y b\/libyara\/grammar.y\nindex bf3c88b4..4a0a7cbb 100644\n--- a\/libyara\/grammar.y\n+++ b\/libyara\/grammar.y\n@@ -824,6 +824,8 @@ arguments_list\n           case EXPRESSION_TYPE_REGEXP:\n             strlcpy($$, \"r\", MAX_FUNCTION_ARGS);\n             break;\n+          default:\n+            assert(FALSE);\n         }\n \n         ERROR_IF($$ == NULL);\n@@ -853,6 +855,8 @@ arguments_list\n             case EXPRESSION_TYPE_REGEXP:\n               strlcat($1, \"r\", MAX_FUNCTION_ARGS);\n               break;\n+            default:\n+              assert(FALSE);\n           }\n         }\n \n@@ -1022,6 +1026,8 @@ expression\n           compiler->loop_depth--;\n           compiler->loop_identifier[compiler->loop_depth] = NULL;\n         }\n+\n+        YYERROR;\n       }\n     | _FOR_ for_expression _IDENTIFIER_ _IN_\n       {\n","owner":"VirusTotal","repo":"yara","source":"cve"},{"CVE_ID":"CVE-2018-11377","CWE_ID":"125","category":"security","commit_id":"b35530fa0681b27eba084de5527037ebfb397422","commit_message":"From b35530fa0681b27eba084de5527037ebfb397422 Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Wed, 18 Apr 2018 13:15:11 +0200\nSubject: [PATCH] Fix oobread in avr\n\n---\n libr\/anal\/p\/anal_avr.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/libr\/anal\/p\/anal_avr.c b\/libr\/anal\/p\/anal_avr.c\nindex 9361b404a7..4e62158513 100644\n--- a\/libr\/anal\/p\/anal_avr.c\n+++ b\/libr\/anal\/p\/anal_avr.c\n@@ -1526,6 +1526,9 @@ OPCODE_DESC opcodes[] = {\n \n static OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n \tOPCODE_DESC *opcode_desc;\n+\tif (len < 2) {\n+\t\treturn NULL;\n+\t}\n \tut16 ins = (buf[1] << 8) | buf[0];\n \tint fail;\n \tchar *t;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2018-5802","CWE_ID":"125","category":"security","commit_id":"0df5490b985c419de008d32168650bff17128914","commit_message":"From 0df5490b985c419de008d32168650bff17128914 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Wed, 6 Dec 2017 21:41:19 +0300\nSubject: [PATCH] SA79000 advisory fix\n\n---\n Changelog.txt             |  9 ++++++-\n dcraw\/dcraw.c             | 54 +++++++++++++++++++++++++++++++++++++--\n internal\/dcraw_common.cpp | 46 +++++++++++++++++++++++++++++++--\n src\/libraw_cxx.cpp        |  2 +-\n 4 files changed, 105 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/Changelog.txt b\/Changelog.txt\nindex dff568a0..90b2971f 100755\n--- a\/Changelog.txt\n+++ b\/Changelog.txt\n@@ -1,4 +1,11 @@\n-Alex Tutubalin <lexa@lexa.ru>\n+2018-01-19  Alex Tutubalin <lexa@lexa.ru>\n+Secunia #79000: \n+Credit: Laurent Delosieres, Secunia Research at Flexera\n+ * All legacy (RGB raw) image loaders checks for imgdata.image is not NULL\n+ * kodak_radc_load_raw: check image size before processing\n+ * legacy memory allocator: allocate max(widh,raw_width)*max(height,raw_height)\n+\n+2017-12-06 Alex Tutubalin <lexa@lexa.ru>\n Secunia #76000:\n  * Fixed fuji_width handling if file is neither fuji nor DNG\n  * Fixed xtrans interpolate for broken xtrans pattern\ndiff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 033b26fa..d287089c 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -1886,6 +1886,10 @@ void CLASS nikon_load_raw()\n \n void CLASS nikon_yuv_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col, yuv[4], rgb[3], b, c;\n   UINT64 bitbuf = 0;\n   float cmul[4];\n@@ -2815,6 +2819,10 @@ void CLASS sinar_4shot_load_raw()\n     unpacked_load_raw();\n     return;\n   }\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  else if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n   merror(pixel, \"sinar_4shot_load_raw()\");\n #ifdef LIBRAW_LIBRARY_BUILD\n@@ -2857,8 +2865,10 @@ void CLASS imacon_full_load_raw()\n {\n   int row, col;\n \n-  if (!image)\n-    return;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n \n #ifdef LIBRAW_LIBRARY_BUILD\n   unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n@@ -3404,6 +3414,12 @@ void CLASS quicktake_100_load_raw()\n \n void CLASS kodak_radc_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  \/\/ All kodak radc images are 768x512\n+  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   static const signed char src[] = {\n       1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n       8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n@@ -3652,6 +3668,10 @@ void CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n \n void CLASS lossy_dng_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   struct jpeg_decompress_struct cinfo;\n   struct jpeg_error_mgr jerr;\n   JSAMPARRAY buf;\n@@ -3806,6 +3826,11 @@ void CLASS eight_bit_load_raw()\n \n void CLASS kodak_c330_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -3849,6 +3874,11 @@ void CLASS kodak_c330_load_raw()\n \n void CLASS kodak_c603_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -4028,6 +4058,10 @@ void CLASS kodak_65000_load_raw()\n \n void CLASS kodak_ycbcr_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[384], *bp;\n   int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n   ushort *ip;\n@@ -4067,6 +4101,10 @@ void CLASS kodak_ycbcr_load_raw()\n \n void CLASS kodak_rgb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[768], *bp;\n   int row, col, len, c, i, rgb[3], ret;\n   ushort *ip = image[0];\n@@ -4096,6 +4134,10 @@ void CLASS kodak_rgb_load_raw()\n \n void CLASS kodak_thumb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col;\n   colors = thumb_misc >> 5;\n   for (row = 0; row < height; row++)\n@@ -4809,6 +4851,10 @@ void CLASS foveon_thumb()\n \n void CLASS foveon_sd_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   struct decode *dindex;\n   short diff[1024];\n   unsigned bitbuf = 0;\n@@ -4869,6 +4915,10 @@ void CLASS foveon_huff(ushort *huff)\n \n void CLASS foveon_dp_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   unsigned c, roff[4], row, col, diff;\n   ushort huff[512], vpred[2][2], hpred[2];\n \ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex 207898de..877bce0f 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -1595,6 +1595,10 @@ void CLASS nikon_load_raw()\n \n void CLASS nikon_yuv_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col, yuv[4], rgb[3], b, c;\n   UINT64 bitbuf = 0;\n   float cmul[4];\n@@ -2519,6 +2523,10 @@ void CLASS sinar_4shot_load_raw()\n     unpacked_load_raw();\n     return;\n   }\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  else if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n   merror(pixel, \"sinar_4shot_load_raw()\");\n #ifdef LIBRAW_LIBRARY_BUILD\n@@ -2561,8 +2569,10 @@ void CLASS imacon_full_load_raw()\n {\n   int row, col;\n \n-  if (!image)\n-    return;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n \n #ifdef LIBRAW_LIBRARY_BUILD\n   unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n@@ -3108,6 +3118,12 @@ void CLASS quicktake_100_load_raw()\n \n void CLASS kodak_radc_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  \/\/ All kodak radc images are 768x512\n+  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   static const signed char src[] = {\n       1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n       8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n@@ -3356,6 +3372,10 @@ void CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n \n void CLASS lossy_dng_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   struct jpeg_decompress_struct cinfo;\n   struct jpeg_error_mgr jerr;\n   JSAMPARRAY buf;\n@@ -3510,6 +3530,11 @@ void CLASS eight_bit_load_raw()\n \n void CLASS kodak_c330_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -3553,6 +3578,11 @@ void CLASS kodak_c330_load_raw()\n \n void CLASS kodak_c603_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -3732,6 +3762,10 @@ void CLASS kodak_65000_load_raw()\n \n void CLASS kodak_ycbcr_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[384], *bp;\n   int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n   ushort *ip;\n@@ -3771,6 +3805,10 @@ void CLASS kodak_ycbcr_load_raw()\n \n void CLASS kodak_rgb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[768], *bp;\n   int row, col, len, c, i, rgb[3], ret;\n   ushort *ip = image[0];\n@@ -3800,6 +3838,10 @@ void CLASS kodak_rgb_load_raw()\n \n void CLASS kodak_thumb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col;\n   colors = thumb_misc >> 5;\n   for (row = 0; row < height; row++)\ndiff --git a\/src\/libraw_cxx.cpp b\/src\/libraw_cxx.cpp\nindex 69206380..69f6c3ae 100644\n--- a\/src\/libraw_cxx.cpp\n+++ b\/src\/libraw_cxx.cpp\n@@ -2792,7 +2792,7 @@ int LibRaw::unpack(void)\n         \/\/ sRAW and old Foveon decoders only, so extra buffer size is just 1\/4\n         \/\/ allocate image as temporary buffer, size\n         imgdata.rawdata.raw_alloc = 0;\n-        imgdata.image = (ushort(*)[4])calloc(unsigned(S.raw_width) * unsigned(S.raw_height), sizeof(*imgdata.image));\n+        imgdata.image = (ushort(*)[4])calloc(unsigned(MAX(S.width,S.raw_width)) * unsigned(MAX(S.height,S.raw_height)), sizeof(*imgdata.image));\n         if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n         {\n           imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2018-5800","CWE_ID":"125","category":"security","commit_id":"0df5490b985c419de008d32168650bff17128914","commit_message":"From 0df5490b985c419de008d32168650bff17128914 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Wed, 6 Dec 2017 21:41:19 +0300\nSubject: [PATCH] SA79000 advisory fix\n\n---\n Changelog.txt             |  9 ++++++-\n dcraw\/dcraw.c             | 54 +++++++++++++++++++++++++++++++++++++--\n internal\/dcraw_common.cpp | 46 +++++++++++++++++++++++++++++++--\n src\/libraw_cxx.cpp        |  2 +-\n 4 files changed, 105 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/Changelog.txt b\/Changelog.txt\nindex dff568a0..90b2971f 100755\n--- a\/Changelog.txt\n+++ b\/Changelog.txt\n@@ -1,4 +1,11 @@\n-Alex Tutubalin <lexa@lexa.ru>\n+2018-01-19  Alex Tutubalin <lexa@lexa.ru>\n+Secunia #79000: \n+Credit: Laurent Delosieres, Secunia Research at Flexera\n+ * All legacy (RGB raw) image loaders checks for imgdata.image is not NULL\n+ * kodak_radc_load_raw: check image size before processing\n+ * legacy memory allocator: allocate max(widh,raw_width)*max(height,raw_height)\n+\n+2017-12-06 Alex Tutubalin <lexa@lexa.ru>\n Secunia #76000:\n  * Fixed fuji_width handling if file is neither fuji nor DNG\n  * Fixed xtrans interpolate for broken xtrans pattern\ndiff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 033b26fa..d287089c 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -1886,6 +1886,10 @@ void CLASS nikon_load_raw()\n \n void CLASS nikon_yuv_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col, yuv[4], rgb[3], b, c;\n   UINT64 bitbuf = 0;\n   float cmul[4];\n@@ -2815,6 +2819,10 @@ void CLASS sinar_4shot_load_raw()\n     unpacked_load_raw();\n     return;\n   }\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  else if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n   merror(pixel, \"sinar_4shot_load_raw()\");\n #ifdef LIBRAW_LIBRARY_BUILD\n@@ -2857,8 +2865,10 @@ void CLASS imacon_full_load_raw()\n {\n   int row, col;\n \n-  if (!image)\n-    return;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n \n #ifdef LIBRAW_LIBRARY_BUILD\n   unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n@@ -3404,6 +3414,12 @@ void CLASS quicktake_100_load_raw()\n \n void CLASS kodak_radc_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  \/\/ All kodak radc images are 768x512\n+  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   static const signed char src[] = {\n       1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n       8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n@@ -3652,6 +3668,10 @@ void CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n \n void CLASS lossy_dng_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   struct jpeg_decompress_struct cinfo;\n   struct jpeg_error_mgr jerr;\n   JSAMPARRAY buf;\n@@ -3806,6 +3826,11 @@ void CLASS eight_bit_load_raw()\n \n void CLASS kodak_c330_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -3849,6 +3874,11 @@ void CLASS kodak_c330_load_raw()\n \n void CLASS kodak_c603_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -4028,6 +4058,10 @@ void CLASS kodak_65000_load_raw()\n \n void CLASS kodak_ycbcr_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[384], *bp;\n   int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n   ushort *ip;\n@@ -4067,6 +4101,10 @@ void CLASS kodak_ycbcr_load_raw()\n \n void CLASS kodak_rgb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[768], *bp;\n   int row, col, len, c, i, rgb[3], ret;\n   ushort *ip = image[0];\n@@ -4096,6 +4134,10 @@ void CLASS kodak_rgb_load_raw()\n \n void CLASS kodak_thumb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col;\n   colors = thumb_misc >> 5;\n   for (row = 0; row < height; row++)\n@@ -4809,6 +4851,10 @@ void CLASS foveon_thumb()\n \n void CLASS foveon_sd_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   struct decode *dindex;\n   short diff[1024];\n   unsigned bitbuf = 0;\n@@ -4869,6 +4915,10 @@ void CLASS foveon_huff(ushort *huff)\n \n void CLASS foveon_dp_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   unsigned c, roff[4], row, col, diff;\n   ushort huff[512], vpred[2][2], hpred[2];\n \ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex 207898de..877bce0f 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -1595,6 +1595,10 @@ void CLASS nikon_load_raw()\n \n void CLASS nikon_yuv_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col, yuv[4], rgb[3], b, c;\n   UINT64 bitbuf = 0;\n   float cmul[4];\n@@ -2519,6 +2523,10 @@ void CLASS sinar_4shot_load_raw()\n     unpacked_load_raw();\n     return;\n   }\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  else if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n   merror(pixel, \"sinar_4shot_load_raw()\");\n #ifdef LIBRAW_LIBRARY_BUILD\n@@ -2561,8 +2569,10 @@ void CLASS imacon_full_load_raw()\n {\n   int row, col;\n \n-  if (!image)\n-    return;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n \n #ifdef LIBRAW_LIBRARY_BUILD\n   unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n@@ -3108,6 +3118,12 @@ void CLASS quicktake_100_load_raw()\n \n void CLASS kodak_radc_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  \/\/ All kodak radc images are 768x512\n+  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   static const signed char src[] = {\n       1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n       8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n@@ -3356,6 +3372,10 @@ void CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n \n void CLASS lossy_dng_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   struct jpeg_decompress_struct cinfo;\n   struct jpeg_error_mgr jerr;\n   JSAMPARRAY buf;\n@@ -3510,6 +3530,11 @@ void CLASS eight_bit_load_raw()\n \n void CLASS kodak_c330_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -3553,6 +3578,11 @@ void CLASS kodak_c330_load_raw()\n \n void CLASS kodak_c603_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -3732,6 +3762,10 @@ void CLASS kodak_65000_load_raw()\n \n void CLASS kodak_ycbcr_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[384], *bp;\n   int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n   ushort *ip;\n@@ -3771,6 +3805,10 @@ void CLASS kodak_ycbcr_load_raw()\n \n void CLASS kodak_rgb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[768], *bp;\n   int row, col, len, c, i, rgb[3], ret;\n   ushort *ip = image[0];\n@@ -3800,6 +3838,10 @@ void CLASS kodak_rgb_load_raw()\n \n void CLASS kodak_thumb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col;\n   colors = thumb_misc >> 5;\n   for (row = 0; row < height; row++)\ndiff --git a\/src\/libraw_cxx.cpp b\/src\/libraw_cxx.cpp\nindex 69206380..69f6c3ae 100644\n--- a\/src\/libraw_cxx.cpp\n+++ b\/src\/libraw_cxx.cpp\n@@ -2792,7 +2792,7 @@ int LibRaw::unpack(void)\n         \/\/ sRAW and old Foveon decoders only, so extra buffer size is just 1\/4\n         \/\/ allocate image as temporary buffer, size\n         imgdata.rawdata.raw_alloc = 0;\n-        imgdata.image = (ushort(*)[4])calloc(unsigned(S.raw_width) * unsigned(S.raw_height), sizeof(*imgdata.image));\n+        imgdata.image = (ushort(*)[4])calloc(unsigned(MAX(S.width,S.raw_width)) * unsigned(MAX(S.height,S.raw_height)), sizeof(*imgdata.image));\n         if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n         {\n           imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2016-7101","CWE_ID":"125","category":"security","commit_id":"8f8959033e4e59418d6506b345829af1f7a71127","commit_message":"From 8f8959033e4e59418d6506b345829af1f7a71127 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 18 Aug 2016 19:40:03 -0400\nSubject: [PATCH] ...\n\n---\n coders\/sgi.c | 11 ++++++-----\n 1 file changed, 6 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/coders\/sgi.c b\/coders\/sgi.c\nindex 1fe65e604f..0ccd9c0313 100644\n--- a\/coders\/sgi.c\n+++ b\/coders\/sgi.c\n@@ -340,8 +340,10 @@ static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     iris_info.minimum_value=ReadBlobMSBLong(image);\n     iris_info.maximum_value=ReadBlobMSBLong(image);\n     iris_info.sans=ReadBlobMSBLong(image);\n-    (void) ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n+    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n       iris_info.name);\n+    if (count != sizeof(iris_info.name))\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     iris_info.name[sizeof(iris_info.name)-1]='\\0';\n     if (*iris_info.name != '\\0')\n       (void) SetImageProperty(image,\"label\",iris_info.name,exception);\n@@ -349,7 +351,8 @@ static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     if (iris_info.pixel_format != 0)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n-    (void) count;\n+    if (count != sizeof(iris_info.filler))\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     image->columns=iris_info.columns;\n     image->rows=iris_info.rows;\n     image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n@@ -361,9 +364,7 @@ static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         image->storage_class=PseudoClass;\n         image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;\n       }\n-    if (EOFBlob(image) != MagickFalse)\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n-    if ((image_info->ping != MagickFalse)  && (image_info->number_scenes != 0))\n+    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n     status=SetImageExtent(image,image->columns,image->rows,exception);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-8688","CWE_ID":"125","category":"security","commit_id":"eec077f52bfa2d3f7103b4b74d52572ba8a15aca","commit_message":"From eec077f52bfa2d3f7103b4b74d52572ba8a15aca Mon Sep 17 00:00:00 2001\nFrom: Tim Kientzle <kientzle@acm.org>\nDate: Sun, 18 Sep 2016 17:27:47 -0700\nSubject: [PATCH] Issue 747 (and others?):  Avoid OOB read when parsing\n multiple long lines\n\nThe mtree bidder needs to look several lines ahead\nin the input.  It does this by extending the read-ahead\nand parsing subsequent lines from the same growing buffer.\nA bookkeeping error when extending the read-ahead would\nsometimes lead it to significantly over-count the\nsize of the line being read.\n---\n Makefile.am                                   |  1 +\n ...\/archive_read_support_format_mtree.c       | 11 ++++-\n libarchive\/test\/CMakeLists.txt                |  1 +\n ...\/test\/test_read_format_mtree_crash747.c    | 44 +++++++++++++++++++\n ...st_read_format_mtree_crash747.mtree.bz2.uu |  6 +++\n 5 files changed, 62 insertions(+), 1 deletion(-)\n create mode 100644 libarchive\/test\/test_read_format_mtree_crash747.c\n create mode 100644 libarchive\/test\/test_read_format_mtree_crash747.mtree.bz2.uu\n\n","diff_code":"diff --git a\/Makefile.am b\/Makefile.am\nindex e161c5d3b..90c9ae105 100644\n--- a\/Makefile.am\n+++ b\/Makefile.am\n@@ -449,6 +449,7 @@ libarchive_test_SOURCES= \\\n \tlibarchive\/test\/test_read_format_lha_bugfix_0.c \\\n \tlibarchive\/test\/test_read_format_lha_filename.c \\\n \tlibarchive\/test\/test_read_format_mtree.c \\\n+\tlibarchive\/test\/test_read_format_mtree_crash747.c \\\n \tlibarchive\/test\/test_read_format_pax_bz2.c \\\n \tlibarchive\/test\/test_read_format_rar.c \\\n \tlibarchive\/test\/test_read_format_rar_encryption_data.c \\\ndiff --git a\/libarchive\/archive_read_support_format_mtree.c b\/libarchive\/archive_read_support_format_mtree.c\nindex 8c3be9a29..ae58e8750 100644\n--- a\/libarchive\/archive_read_support_format_mtree.c\n+++ b\/libarchive\/archive_read_support_format_mtree.c\n@@ -301,6 +301,15 @@ get_line_size(const char *b, ssize_t avail, ssize_t *nlsize)\n \treturn (avail);\n }\n \n+\/*\n+ *  <---------------- ravail --------------------->\n+ *  <-- diff ------> <---  avail ----------------->\n+ *                   <---- len ----------->\n+ * | Previous lines | line being parsed  nl extra |\n+ *                  ^\n+ *                  b\n+ *\n+ *\/\n static ssize_t\n next_line(struct archive_read *a,\n     const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n@@ -339,7 +348,7 @@ next_line(struct archive_read *a,\n \t\t*b += diff;\n \t\t*avail -= diff;\n \t\ttested = len;\/* Skip some bytes we already determinated. *\/\n-\t\tlen = get_line_size(*b, *avail, nl);\n+\t\tlen = get_line_size(*b + len, *avail - len, nl);\n \t\tif (len >= 0)\n \t\t\tlen += tested;\n \t}\ndiff --git a\/libarchive\/test\/CMakeLists.txt b\/libarchive\/test\/CMakeLists.txt\nindex 345e42af2..0cb5966df 100644\n--- a\/libarchive\/test\/CMakeLists.txt\n+++ b\/libarchive\/test\/CMakeLists.txt\n@@ -138,6 +138,7 @@ IF(ENABLE_TEST)\n     test_read_format_lha_bugfix_0.c\n     test_read_format_lha_filename.c\n     test_read_format_mtree.c\n+    test_read_format_mtree_crash747.c\n     test_read_format_pax_bz2.c\n     test_read_format_rar.c\n     test_read_format_rar_encryption_data.c\ndiff --git a\/libarchive\/test\/test_read_format_mtree_crash747.c b\/libarchive\/test\/test_read_format_mtree_crash747.c\nnew file mode 100644\nindex 000000000..c08284552\n--- \/dev\/null\n+++ b\/libarchive\/test\/test_read_format_mtree_crash747.c\n@@ -0,0 +1,44 @@\n+\/*-\n+ * Copyright (c) 2003-2016 Tim Kientzle\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and\/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+#include \"test.h\"\n+\n+\n+\/*\n+ * Reproduce the crash reported in Github Issue #747.\n+ *\/\n+DEFINE_TEST(test_read_format_mtree_crash747)\n+{\n+\tconst char *reffile = \"test_read_format_mtree_crash747.mtree.bz2\";\n+\tstruct archive *a;\n+\n+\textract_reference_file(reffile);\n+\n+\tassert((a = archive_read_new()) != NULL);\n+\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_bzip2(a));\n+\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_mtree(a));\n+\tassertEqualIntA(a, ARCHIVE_FATAL, archive_read_open_filename(a, reffile, 10240));\n+\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n+}\n+\ndiff --git a\/libarchive\/test\/test_read_format_mtree_crash747.mtree.bz2.uu b\/libarchive\/test\/test_read_format_mtree_crash747.mtree.bz2.uu\nnew file mode 100644\nindex 000000000..84f38955b\n--- \/dev\/null\n+++ b\/libarchive\/test\/test_read_format_mtree_crash747.mtree.bz2.uu\n@@ -0,0 +1,6 @@\n+begin 600 test_read_format_mtree_crash747.mtree.bz2\n+M0EIH.3%!62936:OH@(@``'\/[@,`0`@!``'^```)A@9\\`$`@@`'4)049!IIH!\n+MM021-0,F@&@6````9%>$(K!GIC*XFR0`$```J0+:$XP```!D-F)H[#SE9+2'\n+4+E\"L=ASXUI%R(I\"HD'ZA(5?1`Q``\n+`\n+end\n","owner":"libarchive","repo":"libarchive","source":"cve"},{"CVE_ID":"CVE-2018-6340","CWE_ID":"125","category":"security","commit_id":"4bff3bfbe90d10451e4638c2118d1ad1117bb3e3","commit_message":"From 4bff3bfbe90d10451e4638c2118d1ad1117bb3e3 Mon Sep 17 00:00:00 2001\nFrom: Jan Oravec <jan@fb.com>\nDate: Tue, 18 Dec 2018 14:05:37 -0800\nSubject: [PATCH] CVE-2018-6340 Fix buffer overread\n\nSummary:\nsnprintf() returns the number of would be written bytes if the buffer had\nenough size, letting the original code to construct output string from\narbitrary data on the stack.\n\nFix this by properly assembling the String without trying to arbitrarily\nlimiting the length to 30 bytes.\n\nReviewed By: ottoni\n\nDifferential Revision: D13509547\n\nfbshipit-source-id: aa401b83d356f5b261433c4b16d777948ba7f9b4\n---\n hphp\/runtime\/ext\/memcache\/ext_memcache.cpp | 13 +++++++------\n 1 file changed, 7 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/hphp\/runtime\/ext\/memcache\/ext_memcache.cpp b\/hphp\/runtime\/ext\/memcache\/ext_memcache.cpp\nindex 221908993f6..776f5f30a44 100644\n--- a\/hphp\/runtime\/ext\/memcache\/ext_memcache.cpp\n+++ b\/hphp\/runtime\/ext\/memcache\/ext_memcache.cpp\n@@ -700,9 +700,6 @@ static Array HHVM_METHOD(Memcache, getextendedstats,\n \n   for (int server_id = 0; server_id < server_count; server_id++) {\n     memcached_stat_st *stat;\n-    char stats_key[30] = {0};\n-    size_t key_len;\n-\n     LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n       memcached_server_instance_by_position(&data->m_memcache, server_id);\n     const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n@@ -715,9 +712,13 @@ static Array HHVM_METHOD(Memcache, getextendedstats,\n       continue;\n     }\n \n-    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n-\n-    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n+    auto const port_str = folly::to<std::string>(port);\n+    auto const key_len = strlen(hostname) + 1 + port_str.length();\n+    auto key = String(key_len, ReserveString);\n+    key += hostname;\n+    key += \":\";\n+    key += port_str;\n+    return_val.set(key, server_stats);\n   }\n \n   free(stats);\n","owner":"facebook","repo":"hhvm","source":"cve"},{"CVE_ID":"CVE-2019-3557","CWE_ID":"125","category":"security","commit_id":"6e4dd9ec3f14b48170fc45dc9d13a3261765f994","commit_message":"From 6e4dd9ec3f14b48170fc45dc9d13a3261765f994 Mon Sep 17 00:00:00 2001\nFrom: Joseph Griego <jgriego@fb.com>\nDate: Mon, 14 Jan 2019 12:18:21 -0800\nSubject: [PATCH] CVE-2019-3557: Fix OOB read in readRecord on\n BZ2Files\/OutputFiles\n\nSummary:\nThese File subclasses return -1 on read errors which is not what is\nexpected for readImpl--this made File::readRecord behave unusually if the read\nfails, causing it to read (size_t)(-1) bytes from its stream buffer; which,\nunsurprisingly produces a out-of-bounds heap read.\n\nReviewed By: leikahing, jjgriego\n\nDifferential Revision: D13659395\n\nfbshipit-source-id: 359ed6e3ff9f9cf49b752b666f51c4e0b3ce4b8a\n---\n hphp\/runtime\/base\/output-file.cpp        |  2 +-\n hphp\/runtime\/ext\/bz2\/bz2-file.cpp        |  2 +-\n hphp\/test\/slow\/oob_read_file.php         | 12 ++++++++++++\n hphp\/test\/slow\/oob_read_file.php.expectf |  4 ++++\n 4 files changed, 18 insertions(+), 2 deletions(-)\n create mode 100644 hphp\/test\/slow\/oob_read_file.php\n create mode 100644 hphp\/test\/slow\/oob_read_file.php.expectf\n\n","diff_code":"diff --git a\/hphp\/runtime\/base\/output-file.cpp b\/hphp\/runtime\/base\/output-file.cpp\nindex f512b7896d8..1b2711b51f2 100644\n--- a\/hphp\/runtime\/base\/output-file.cpp\n+++ b\/hphp\/runtime\/base\/output-file.cpp\n@@ -66,7 +66,7 @@ bool OutputFile::closeImpl() {\n \n int64_t OutputFile::readImpl(char* \/*buffer*\/, int64_t \/*length*\/) {\n   raise_warning(\"cannot read from a php:\/\/output stream\");\n-  return -1;\n+  return 0;\n }\n \n int OutputFile::getc() {\ndiff --git a\/hphp\/runtime\/ext\/bz2\/bz2-file.cpp b\/hphp\/runtime\/ext\/bz2\/bz2-file.cpp\nindex 3b180f73038..687d0145590 100644\n--- a\/hphp\/runtime\/ext\/bz2\/bz2-file.cpp\n+++ b\/hphp\/runtime\/ext\/bz2\/bz2-file.cpp\n@@ -95,7 +95,7 @@ int64_t BZ2File::readImpl(char * buf, int64_t length) {\n   if (len <= 0) {\n     setEof(true);\n     if (len < 0) {\n-      return -1;\n+      return 0;\n     }\n   }\n   return len;\ndiff --git a\/hphp\/test\/slow\/oob_read_file.php b\/hphp\/test\/slow\/oob_read_file.php\nnew file mode 100644\nindex 00000000000..49a9904bdb7\n--- \/dev\/null\n+++ b\/hphp\/test\/slow\/oob_read_file.php\n@@ -0,0 +1,12 @@\n+<?hh\n+\n+<<__EntryPoint>>\n+function main() {\n+    $a = bzopen(\"\/dev\/null\", \"w\");\n+    $tmp = stream_get_line($a, 1, \"1\");\n+    var_dump($tmp);\n+\n+    $a = fopen(\"php:\/\/output\", \"w\");\n+    $tmp = stream_get_line($a, 1, \"1\");\n+    var_dump($tmp);\n+}\ndiff --git a\/hphp\/test\/slow\/oob_read_file.php.expectf b\/hphp\/test\/slow\/oob_read_file.php.expectf\nnew file mode 100644\nindex 00000000000..d2d24bc1eb4\n--- \/dev\/null\n+++ b\/hphp\/test\/slow\/oob_read_file.php.expectf\n@@ -0,0 +1,4 @@\n+string(0) \"\"\n+\n+Warning: cannot read from a php:\/\/output stream in %s on line %d\n+string(0) \"\"\n","owner":"facebook","repo":"hhvm","source":"cve"},{"CVE_ID":"CVE-2018-16842","CWE_ID":"125","category":"security","commit_id":"d530e92f59ae9bb2d47066c3c460b25d2ffeb211","commit_message":"From d530e92f59ae9bb2d47066c3c460b25d2ffeb211 Mon Sep 17 00:00:00 2001\nFrom: Daniel Stenberg <daniel@haxx.se>\nDate: Sun, 28 Oct 2018 01:33:23 +0200\nSubject: [PATCH] voutf: fix bad arethmetic when outputting warnings to stderr\n\nCVE-2018-16842\nReported-by: Brian Carpenter\nBug: https:\/\/curl.haxx.se\/docs\/CVE-2018-16842.html\n---\n src\/tool_msgs.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/tool_msgs.c b\/src\/tool_msgs.c\nindex 832ed8147b..f5e1df25fb 100644\n--- a\/src\/tool_msgs.c\n+++ b\/src\/tool_msgs.c\n@@ -67,7 +67,7 @@ static void voutf(struct GlobalConfig *config,\n         (void)fwrite(ptr, cut + 1, 1, config->errors);\n         fputs(\"\\n\", config->errors);\n         ptr += cut + 1; \/* skip the space too *\/\n-        len -= cut;\n+        len -= cut + 1;\n       }\n       else {\n         fputs(ptr, config->errors);\n","owner":"curl","repo":"curl","source":"cve"},{"CVE_ID":"CVE-2018-20102","CWE_ID":"125","category":"security","commit_id":"efbbdf72992cd20458259962346044cafd9331c0","commit_message":"From efbbdf72992cd20458259962346044cafd9331c0 Mon Sep 17 00:00:00 2001\nFrom: Remi Gacogne <remi.gacogne@powerdns.com>\nDate: Wed, 5 Dec 2018 17:56:29 +0100\nSubject: [PATCH] BUG: dns: Prevent out-of-bounds read in\n dns_validate_dns_response()\n\nWe need to make sure that the record length is not making us read\npast the end of the data we received.\nBefore this patch we could for example read the 16 bytes\ncorresponding to an AAAA record from the non-initialized part of\nthe buffer, possibly accessing anything that was left on the stack,\nor even past the end of the 8193-byte buffer, depending on the\nvalue of accepted_payload_size.\n\nTo be backported to 1.8, probably also 1.7.\n---\n src\/dns.c |    5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/src\/dns.c b\/src\/dns.c\nindex fead261..c1396f5 100644\n--- a\/src\/dns.c\n+++ b\/src\/dns.c\n@@ -810,6 +810,11 @@ static int dns_validate_dns_response(unsigned char *resp, unsigned char *bufend,\n \t\t\/* Move forward 2 bytes for data len *\/\n \t\treader += 2;\n \n+\t\tif (reader + dns_answer_record->data_len >= bufend) {\n+\t\t\tpool_free(dns_answer_item_pool, dns_answer_record);\n+\t\t\treturn DNS_RESP_INVALID;\n+\t\t}\n+\n \t\t\/* Analyzing record content *\/\n \t\tswitch (dns_answer_record->type) {\n \t\t\tcase DNS_RTYPE_A:\n-- \n1.7.10.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6500","CWE_ID":"125","category":"security","commit_id":"3007531bfd326c5c1e29cd41d2cd80c166de8528","commit_message":"From 3007531bfd326c5c1e29cd41d2cd80c166de8528 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Wed, 8 Feb 2017 13:38:04 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/375\n https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/376\n\n---\n coders\/sun.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/sun.c b\/coders\/sun.c\nindex 150f3357fd..c11a33c62b 100644\n--- a\/coders\/sun.c\n+++ b\/coders\/sun.c\n@@ -458,7 +458,7 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n       }\n     pixels_length=height*bytes_per_line;\n-    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length,\n+    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,\n       sizeof(*sun_pixels));\n     if (sun_pixels == (unsigned char *) NULL)\n       {\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-6262","CWE_ID":"125","category":"security","commit_id":"5e3cb9c7b5bf0ce665b9d68f5ddf095af5c9ba60","commit_message":"From 5e3cb9c7b5bf0ce665b9d68f5ddf095af5c9ba60 Mon Sep 17 00:00:00 2001\nFrom: Simon Josefsson <simon@josefsson.org>\nDate: Thu, 14 Jan 2016 14:59:19 +0100\nSubject: Really fix bug when reading \\00 inputs.\n\n---\n src\/idn.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/idn.c b\/src\/idn.c\nindex b40ed62..be1c7d1 100644\n--- a\/src\/idn.c\n+++ b\/src\/idn.c\n@@ -200,8 +200,9 @@ main (int argc, char *argv[])\n \t  error (EXIT_FAILURE, errno, _(\"input error\"));\n \t}\n \n-      if (line[strlen (line) - 1] == '\\n')\n-\tline[strlen (line) - 1] = '\\0';\n+      if (strlen (line) > 0)\n+\tif (line[strlen (line) - 1] == '\\n')\n+\t  line[strlen (line) - 1] = '\\0';\n \n       if (args_info.stringprep_given)\n \t{\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-16642","CWE_ID":"125","category":"security","commit_id":"5c0455bf2c8cd3c25401407f158e820aa3b239e1","commit_message":"From 5c0455bf2c8cd3c25401407f158e820aa3b239e1 Mon Sep 17 00:00:00 2001\nFrom: Anatol Belski <ab@php.net>\nDate: Tue, 24 Oct 2017 13:44:03 +0200\nSubject: [PATCH] Merge branch 'PHP-7.0' into PHP-7.1\n\n* PHP-7.0:\n  Fixed bug #75055 Out-Of-Bounds Read in timelib_meridian()\n  Apply upstream patch for CVE-2016-1283\n---\n ext\/date\/lib\/parse_date.c         | 1952 +++++++++++++++--------------\n ext\/date\/lib\/parse_date.re        |    4 +-\n ext\/date\/tests\/bug53437_var3.phpt |    2 +-\n ext\/wddx\/tests\/bug75055.phpt      |   20 +\n ext\/wddx\/tests\/bug75055.wddx      |   13 +\n 5 files changed, 1066 insertions(+), 925 deletions(-)\n create mode 100644 ext\/wddx\/tests\/bug75055.phpt\n create mode 100644 ext\/wddx\/tests\/bug75055.wddx\n\n","diff_code":"diff --git a\/ext\/date\/lib\/parse_date.c b\/ext\/date\/lib\/parse_date.c\nindex 01e79d2093f5..36bcdcc28aa8 100644\n--- a\/ext\/date\/lib\/parse_date.c\n+++ b\/ext\/date\/lib\/parse_date.c\n@@ -1,4 +1,4 @@\n-\/* Generated by re2c 0.15.3 on Wed Aug 16 15:51:34 2017 *\/\n+\/* Generated by re2c 0.15.3 on Tue Oct 24 13:42:24 2017 *\/\n #line 1 \"ext\/date\/lib\/parse_date.re\"\n \/*\n  * The MIT License (MIT)\n@@ -967,14 +967,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'D') goto yy165;\n-\t\t\tgoto yy1521;\n+\t\t\tgoto yy1523;\n \t\t}\n \t} else {\n \t\tif (yych <= 'd') {\n \t\t\tif (yych <= 'Z') goto yy165;\n \t\t\tif (yych >= 'a') goto yy170;\n \t\t} else {\n-\t\t\tif (yych <= 'e') goto yy1530;\n+\t\t\tif (yych <= 'e') goto yy1532;\n \t\t\tif (yych <= 'z') goto yy170;\n \t\t}\n \t}\n@@ -1004,7 +1004,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'D') goto yy165;\n-\t\t\tgoto yy1521;\n+\t\t\tgoto yy1523;\n \t\t}\n \t} else {\n \t\tif (yych <= 'd') {\n@@ -1012,7 +1012,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy165;\n \t\t} else {\n-\t\t\tif (yych <= 'e') goto yy1521;\n+\t\t\tif (yych <= 'e') goto yy1523;\n \t\t\tif (yych <= 'z') goto yy165;\n \t\t\tgoto yy3;\n \t\t}\n@@ -1027,12 +1027,12 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy165;\n \t\t} else {\n \t\t\tif (yych <= 'H') {\n-\t\t\t\tif (yych <= 'E') goto yy1492;\n+\t\t\t\tif (yych <= 'E') goto yy1494;\n \t\t\t\tgoto yy165;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'I') goto yy1493;\n+\t\t\t\tif (yych <= 'I') goto yy1495;\n \t\t\t\tif (yych <= 'N') goto yy165;\n-\t\t\t\tgoto yy1491;\n+\t\t\t\tgoto yy1493;\n \t\t\t}\n \t\t}\n \t} else {\n@@ -1041,15 +1041,15 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= 'Z') goto yy165;\n \t\t\t\tgoto yy3;\n \t\t\t} else {\n-\t\t\t\tif (yych == 'e') goto yy1508;\n+\t\t\t\tif (yych == 'e') goto yy1510;\n \t\t\t\tgoto yy170;\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'n') {\n-\t\t\t\tif (yych <= 'i') goto yy1509;\n+\t\t\t\tif (yych <= 'i') goto yy1511;\n \t\t\t\tgoto yy170;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'o') goto yy1507;\n+\t\t\t\tif (yych <= 'o') goto yy1509;\n \t\t\t\tif (yych <= 'z') goto yy170;\n \t\t\t\tgoto yy3;\n \t\t\t}\n@@ -1065,12 +1065,12 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy165;\n \t\t} else {\n \t\t\tif (yych <= 'H') {\n-\t\t\t\tif (yych <= 'E') goto yy1492;\n+\t\t\t\tif (yych <= 'E') goto yy1494;\n \t\t\t\tgoto yy165;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'I') goto yy1493;\n+\t\t\t\tif (yych <= 'I') goto yy1495;\n \t\t\t\tif (yych <= 'N') goto yy165;\n-\t\t\t\tgoto yy1491;\n+\t\t\t\tgoto yy1493;\n \t\t\t}\n \t\t}\n \t} else {\n@@ -1079,15 +1079,15 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= 'Z') goto yy165;\n \t\t\t\tgoto yy3;\n \t\t\t} else {\n-\t\t\t\tif (yych == 'e') goto yy1492;\n+\t\t\t\tif (yych == 'e') goto yy1494;\n \t\t\t\tgoto yy165;\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'n') {\n-\t\t\t\tif (yych <= 'i') goto yy1493;\n+\t\t\t\tif (yych <= 'i') goto yy1495;\n \t\t\t\tgoto yy165;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'o') goto yy1491;\n+\t\t\t\tif (yych <= 'o') goto yy1493;\n \t\t\t\tif (yych <= 'z') goto yy165;\n \t\t\t\tgoto yy3;\n \t\t\t}\n@@ -1100,24 +1100,24 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tif (yych <= 'A') {\n \t\t\tif (yych == ')') goto yy164;\n \t\t\tif (yych <= '@') goto yy3;\n-\t\t\tgoto yy1461;\n+\t\t\tgoto yy1463;\n \t\t} else {\n-\t\t\tif (yych == 'I') goto yy1462;\n+\t\t\tif (yych == 'I') goto yy1464;\n \t\t\tif (yych <= 'N') goto yy165;\n-\t\t\tgoto yy1463;\n+\t\t\tgoto yy1465;\n \t\t}\n \t} else {\n \t\tif (yych <= 'h') {\n \t\t\tif (yych <= 'Z') goto yy165;\n \t\t\tif (yych <= '`') goto yy3;\n-\t\t\tif (yych <= 'a') goto yy1476;\n+\t\t\tif (yych <= 'a') goto yy1478;\n \t\t\tgoto yy170;\n \t\t} else {\n \t\t\tif (yych <= 'n') {\n-\t\t\t\tif (yych <= 'i') goto yy1477;\n+\t\t\t\tif (yych <= 'i') goto yy1479;\n \t\t\t\tgoto yy170;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'o') goto yy1478;\n+\t\t\t\tif (yych <= 'o') goto yy1480;\n \t\t\t\tif (yych <= 'z') goto yy170;\n \t\t\t\tgoto yy3;\n \t\t\t}\n@@ -1130,24 +1130,24 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tif (yych <= 'A') {\n \t\t\tif (yych == ')') goto yy164;\n \t\t\tif (yych <= '@') goto yy3;\n-\t\t\tgoto yy1461;\n+\t\t\tgoto yy1463;\n \t\t} else {\n-\t\t\tif (yych == 'I') goto yy1462;\n+\t\t\tif (yych == 'I') goto yy1464;\n \t\t\tif (yych <= 'N') goto yy165;\n-\t\t\tgoto yy1463;\n+\t\t\tgoto yy1465;\n \t\t}\n \t} else {\n \t\tif (yych <= 'h') {\n \t\t\tif (yych <= 'Z') goto yy165;\n \t\t\tif (yych <= '`') goto yy3;\n-\t\t\tif (yych <= 'a') goto yy1461;\n+\t\t\tif (yych <= 'a') goto yy1463;\n \t\t\tgoto yy165;\n \t\t} else {\n \t\t\tif (yych <= 'n') {\n-\t\t\t\tif (yych <= 'i') goto yy1462;\n+\t\t\t\tif (yych <= 'i') goto yy1464;\n \t\t\t\tgoto yy165;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'o') goto yy1463;\n+\t\t\t\tif (yych <= 'o') goto yy1465;\n \t\t\t\tif (yych <= 'z') goto yy165;\n \t\t\t\tgoto yy3;\n \t\t\t}\n@@ -1160,15 +1160,15 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \tswitch (yych) {\n \tcase ')':\tgoto yy164;\n \tcase '0':\n-\tcase '1':\tgoto yy1391;\n-\tcase '2':\tgoto yy1392;\n+\tcase '1':\tgoto yy1393;\n+\tcase '2':\tgoto yy1394;\n \tcase '3':\n \tcase '4':\n \tcase '5':\n \tcase '6':\n \tcase '7':\n \tcase '8':\n-\tcase '9':\tgoto yy1393;\n+\tcase '9':\tgoto yy1395;\n \tcase 'A':\n \tcase 'B':\n \tcase 'C':\n@@ -1190,11 +1190,11 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \tcase 'X':\n \tcase 'Y':\n \tcase 'Z':\tgoto yy165;\n-\tcase 'E':\tgoto yy1386;\n-\tcase 'H':\tgoto yy1387;\n-\tcase 'O':\tgoto yy1388;\n-\tcase 'U':\tgoto yy1389;\n-\tcase 'W':\tgoto yy1390;\n+\tcase 'E':\tgoto yy1388;\n+\tcase 'H':\tgoto yy1389;\n+\tcase 'O':\tgoto yy1390;\n+\tcase 'U':\tgoto yy1391;\n+\tcase 'W':\tgoto yy1392;\n \tcase 'a':\n \tcase 'b':\n \tcase 'c':\n@@ -1216,11 +1216,11 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \tcase 'x':\n \tcase 'y':\n \tcase 'z':\tgoto yy170;\n-\tcase 'e':\tgoto yy1429;\n-\tcase 'h':\tgoto yy1430;\n-\tcase 'o':\tgoto yy1431;\n-\tcase 'u':\tgoto yy1432;\n-\tcase 'w':\tgoto yy1433;\n+\tcase 'e':\tgoto yy1431;\n+\tcase 'h':\tgoto yy1432;\n+\tcase 'o':\tgoto yy1433;\n+\tcase 'u':\tgoto yy1434;\n+\tcase 'w':\tgoto yy1435;\n \tdefault:\tgoto yy3;\n \t}\n yy10:\n@@ -1230,15 +1230,15 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \tswitch (yych) {\n \tcase ')':\tgoto yy164;\n \tcase '0':\n-\tcase '1':\tgoto yy1391;\n-\tcase '2':\tgoto yy1392;\n+\tcase '1':\tgoto yy1393;\n+\tcase '2':\tgoto yy1394;\n \tcase '3':\n \tcase '4':\n \tcase '5':\n \tcase '6':\n \tcase '7':\n \tcase '8':\n-\tcase '9':\tgoto yy1393;\n+\tcase '9':\tgoto yy1395;\n \tcase 'A':\n \tcase 'B':\n \tcase 'C':\n@@ -1282,24 +1282,24 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \tcase 'y':\n \tcase 'z':\tgoto yy165;\n \tcase 'E':\n-\tcase 'e':\tgoto yy1386;\n+\tcase 'e':\tgoto yy1388;\n \tcase 'H':\n-\tcase 'h':\tgoto yy1387;\n+\tcase 'h':\tgoto yy1389;\n \tcase 'O':\n-\tcase 'o':\tgoto yy1388;\n+\tcase 'o':\tgoto yy1390;\n \tcase 'U':\n-\tcase 'u':\tgoto yy1389;\n+\tcase 'u':\tgoto yy1391;\n \tcase 'W':\n-\tcase 'w':\tgoto yy1390;\n+\tcase 'w':\tgoto yy1392;\n \tdefault:\tgoto yy3;\n \t}\n yy11:\n \tYYDEBUG(11, *YYCURSOR);\n \tyyaccept = 1;\n \tyych = *(YYMARKER = ++YYCURSOR);\n-\tif (yych == '-') goto yy1374;\n+\tif (yych == '-') goto yy1376;\n \tif (yych <= '\/') goto yy12;\n-\tif (yych <= '9') goto yy1375;\n+\tif (yych <= '9') goto yy1377;\n yy12:\n \tYYDEBUG(12, *YYCURSOR);\n #line 1768 \"ext\/date\/lib\/parse_date.re\"\n@@ -1319,16 +1319,16 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t} else {\n \t\t\t\tif (yych <= '@') goto yy3;\n \t\t\t\tif (yych <= 'D') goto yy165;\n-\t\t\t\tgoto yy1310;\n+\t\t\t\tgoto yy1311;\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'N') {\n-\t\t\t\tif (yych == 'I') goto yy1311;\n+\t\t\t\tif (yych == 'I') goto yy1312;\n \t\t\t\tgoto yy165;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'O') goto yy1312;\n+\t\t\t\tif (yych <= 'O') goto yy1313;\n \t\t\t\tif (yych <= 'Q') goto yy165;\n-\t\t\t\tgoto yy1313;\n+\t\t\t\tgoto yy1314;\n \t\t\t}\n \t\t}\n \t} else {\n@@ -1338,16 +1338,16 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy170;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'e') goto yy1351;\n+\t\t\t\tif (yych <= 'e') goto yy1353;\n \t\t\t\tif (yych <= 'h') goto yy170;\n-\t\t\t\tgoto yy1352;\n+\t\t\t\tgoto yy1354;\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'q') {\n-\t\t\t\tif (yych == 'o') goto yy1353;\n+\t\t\t\tif (yych == 'o') goto yy1355;\n \t\t\t\tgoto yy170;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'r') goto yy1354;\n+\t\t\t\tif (yych <= 'r') goto yy1356;\n \t\t\t\tif (yych <= 'z') goto yy170;\n \t\t\t\tgoto yy3;\n \t\t\t}\n@@ -1364,16 +1364,16 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t} else {\n \t\t\t\tif (yych <= '@') goto yy3;\n \t\t\t\tif (yych <= 'D') goto yy165;\n-\t\t\t\tgoto yy1310;\n+\t\t\t\tgoto yy1311;\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'N') {\n-\t\t\t\tif (yych == 'I') goto yy1311;\n+\t\t\t\tif (yych == 'I') goto yy1312;\n \t\t\t\tgoto yy165;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'O') goto yy1312;\n+\t\t\t\tif (yych <= 'O') goto yy1313;\n \t\t\t\tif (yych <= 'Q') goto yy165;\n-\t\t\t\tgoto yy1313;\n+\t\t\t\tgoto yy1314;\n \t\t\t}\n \t\t}\n \t} else {\n@@ -1383,16 +1383,16 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy165;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'e') goto yy1310;\n+\t\t\t\tif (yych <= 'e') goto yy1311;\n \t\t\t\tif (yych <= 'h') goto yy165;\n-\t\t\t\tgoto yy1311;\n+\t\t\t\tgoto yy1312;\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'q') {\n-\t\t\t\tif (yych == 'o') goto yy1312;\n+\t\t\t\tif (yych == 'o') goto yy1313;\n \t\t\t\tgoto yy165;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'r') goto yy1313;\n+\t\t\t\tif (yych <= 'r') goto yy1314;\n \t\t\t\tif (yych <= 'z') goto yy165;\n \t\t\t\tgoto yy3;\n \t\t\t}\n@@ -1404,13 +1404,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \tif (yych <= 'A') {\n \t\tif (yych == ')') goto yy164;\n \t\tif (yych <= '@') goto yy3;\n-\t\tgoto yy1296;\n+\t\tgoto yy1297;\n \t} else {\n \t\tif (yych <= '`') {\n \t\t\tif (yych <= 'Z') goto yy165;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych <= 'a') goto yy1307;\n+\t\t\tif (yych <= 'a') goto yy1308;\n \t\t\tif (yych <= 'z') goto yy170;\n \t\t\tgoto yy3;\n \t\t}\n@@ -1421,13 +1421,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \tif (yych <= 'A') {\n \t\tif (yych == ')') goto yy164;\n \t\tif (yych <= '@') goto yy3;\n-\t\tgoto yy1296;\n+\t\tgoto yy1297;\n \t} else {\n \t\tif (yych <= '`') {\n \t\t\tif (yych <= 'Z') goto yy165;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych <= 'a') goto yy1296;\n+\t\t\tif (yych <= 'a') goto yy1297;\n \t\t\tif (yych <= 'z') goto yy165;\n \t\t\tgoto yy3;\n \t\t}\n@@ -1444,7 +1444,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= 'Z') goto yy165;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych <= 'a') goto yy1293;\n+\t\t\tif (yych <= 'a') goto yy1294;\n \t\t\tif (yych <= 'z') goto yy170;\n \t\t\tgoto yy3;\n \t\t}\n@@ -2760,23 +2760,23 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (yyaccept == 28) {\n-\t\t\t\t\t\tgoto yy1377;\n+\t\t\t\t\t\tgoto yy1379;\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tgoto yy1415;\n+\t\t\t\t\t\tgoto yy1417;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (yyaccept <= 31) {\n \t\t\t\t\tif (yyaccept == 30) {\n-\t\t\t\t\t\tgoto yy1418;\n+\t\t\t\t\t\tgoto yy1420;\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tgoto yy1498;\n+\t\t\t\t\t\tgoto yy1500;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif (yyaccept == 32) {\n-\t\t\t\t\t\tgoto yy1506;\n+\t\t\t\t\t\tgoto yy1508;\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tgoto yy1529;\n+\t\t\t\t\t\tgoto yy1531;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n@@ -19570,9 +19570,23 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \tYYDEBUG(1283, *YYCURSOR);\n \tyyaccept = 27;\n \tyych = *(YYMARKER = ++YYCURSOR);\n-\tif (yych <= '\/') goto yy1287;\n-\tif (yych <= '9') goto yy1286;\n-\tgoto yy1287;\n+\tif (yych <= '@') {\n+\t\tif (yych <= 0x1F) {\n+\t\t\tif (yych == '\\t') goto yy1287;\n+\t\t} else {\n+\t\t\tif (yych <= ' ') goto yy1287;\n+\t\t\tif (yych <= '\/') goto yy1284;\n+\t\t\tif (yych <= '9') goto yy1286;\n+\t\t}\n+\t} else {\n+\t\tif (yych <= '`') {\n+\t\t\tif (yych <= 'A') goto yy1289;\n+\t\t\tif (yych == 'P') goto yy1289;\n+\t\t} else {\n+\t\t\tif (yych <= 'a') goto yy1289;\n+\t\t\tif (yych == 'p') goto yy1289;\n+\t\t}\n+\t}\n yy1284:\n \tYYDEBUG(1284, *YYCURSOR);\n #line 1096 \"ext\/date\/lib\/parse_date.re\"\n@@ -19597,76 +19611,114 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tTIMELIB_DEINIT;\n \t\treturn TIMELIB_LF_DAY_OF_MONTH;\n \t}\n-#line 19601 \"<stdout>\"\n+#line 19615 \"<stdout>\"\n yy1285:\n \tYYDEBUG(1285, *YYCURSOR);\n \tyyaccept = 27;\n \tyych = *(YYMARKER = ++YYCURSOR);\n-\tif (yych <= '\/') goto yy1287;\n-\tif (yych >= '5') goto yy1287;\n+\tif (yych <= '@') {\n+\t\tif (yych <= 0x1F) {\n+\t\t\tif (yych == '\\t') goto yy1287;\n+\t\t\tgoto yy1284;\n+\t\t} else {\n+\t\t\tif (yych <= ' ') goto yy1287;\n+\t\t\tif (yych <= '\/') goto yy1284;\n+\t\t\tif (yych >= '5') goto yy1284;\n+\t\t}\n+\t} else {\n+\t\tif (yych <= '`') {\n+\t\t\tif (yych <= 'A') goto yy1289;\n+\t\t\tif (yych == 'P') goto yy1289;\n+\t\t\tgoto yy1284;\n+\t\t} else {\n+\t\t\tif (yych <= 'a') goto yy1289;\n+\t\t\tif (yych == 'p') goto yy1289;\n+\t\t\tgoto yy1284;\n+\t\t}\n+\t}\n yy1286:\n \tYYDEBUG(1286, *YYCURSOR);\n \tyyaccept = 27;\n-\tYYMARKER = ++YYCURSOR;\n-\tif ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);\n-\tyych = *YYCURSOR;\n-yy1287:\n-\tYYDEBUG(1287, *YYCURSOR);\n+\tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'A') {\n \t\tif (yych <= 0x1F) {\n-\t\t\tif (yych == '\\t') goto yy1286;\n-\t\t\tgoto yy1284;\n+\t\t\tif (yych != '\\t') goto yy1284;\n \t\t} else {\n-\t\t\tif (yych <= ' ') goto yy1286;\n+\t\t\tif (yych <= ' ') goto yy1287;\n \t\t\tif (yych <= '@') goto yy1284;\n+\t\t\tgoto yy1289;\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n-\t\t\tif (yych != 'P') goto yy1284;\n+\t\t\tif (yych == 'P') goto yy1289;\n+\t\t\tgoto yy1284;\n \t\t} else {\n-\t\t\tif (yych <= 'a') goto yy1288;\n-\t\t\tif (yych != 'p') goto yy1284;\n+\t\t\tif (yych <= 'a') goto yy1289;\n+\t\t\tif (yych == 'p') goto yy1289;\n+\t\t\tgoto yy1284;\n \t\t}\n \t}\n-yy1288:\n+yy1287:\n+\tYYDEBUG(1287, *YYCURSOR);\n+\t++YYCURSOR;\n+\tif ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);\n+\tyych = *YYCURSOR;\n \tYYDEBUG(1288, *YYCURSOR);\n+\tif (yych <= 'A') {\n+\t\tif (yych <= 0x1F) {\n+\t\t\tif (yych == '\\t') goto yy1287;\n+\t\t\tgoto yy56;\n+\t\t} else {\n+\t\t\tif (yych <= ' ') goto yy1287;\n+\t\t\tif (yych <= '@') goto yy56;\n+\t\t}\n+\t} else {\n+\t\tif (yych <= '`') {\n+\t\t\tif (yych != 'P') goto yy56;\n+\t\t} else {\n+\t\t\tif (yych <= 'a') goto yy1289;\n+\t\t\tif (yych != 'p') goto yy56;\n+\t\t}\n+\t}\n+yy1289:\n+\tYYDEBUG(1289, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'L') {\n \t\tif (yych != '.') goto yy56;\n \t} else {\n-\t\tif (yych <= 'M') goto yy1290;\n-\t\tif (yych == 'm') goto yy1290;\n+\t\tif (yych <= 'M') goto yy1291;\n+\t\tif (yych == 'm') goto yy1291;\n \t\tgoto yy56;\n \t}\n-\tYYDEBUG(1289, *YYCURSOR);\n+\tYYDEBUG(1290, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'M') goto yy1290;\n+\tif (yych == 'M') goto yy1291;\n \tif (yych != 'm') goto yy56;\n-yy1290:\n-\tYYDEBUG(1290, *YYCURSOR);\n+yy1291:\n+\tYYDEBUG(1291, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 0x1F) {\n-\t\tif (yych <= 0x00) goto yy1292;\n-\t\tif (yych == '\\t') goto yy1292;\n+\t\tif (yych <= 0x00) goto yy1293;\n+\t\tif (yych == '\\t') goto yy1293;\n \t\tgoto yy56;\n \t} else {\n-\t\tif (yych <= ' ') goto yy1292;\n+\t\tif (yych <= ' ') goto yy1293;\n \t\tif (yych != '.') goto yy56;\n \t}\n-\tYYDEBUG(1291, *YYCURSOR);\n+\tYYDEBUG(1292, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\\t') {\n-\t\tif (yych <= 0x00) goto yy1292;\n+\t\tif (yych <= 0x00) goto yy1293;\n \t\tif (yych <= 0x08) goto yy56;\n \t} else {\n \t\tif (yych != ' ') goto yy56;\n \t}\n-yy1292:\n-\tYYDEBUG(1292, *YYCURSOR);\n-\tyych = *++YYCURSOR;\n-\tgoto yy1284;\n yy1293:\n \tYYDEBUG(1293, *YYCURSOR);\n+\tyych = *++YYCURSOR;\n+\tgoto yy1284;\n+yy1294:\n+\tYYDEBUG(1294, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'B') {\n@@ -19690,14 +19742,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'c') goto yy1294;\n+\t\t\t\tif (yych <= 'c') goto yy1295;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1294:\n-\tYYDEBUG(1294, *YYCURSOR);\n+yy1295:\n+\tYYDEBUG(1295, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'J') {\n@@ -19721,14 +19773,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'k') goto yy1295;\n+\t\t\t\tif (yych <= 'k') goto yy1296;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1295:\n-\tYYDEBUG(1295, *YYCURSOR);\n+yy1296:\n+\tYYDEBUG(1296, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '.') {\n@@ -19753,8 +19805,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1296:\n-\tYYDEBUG(1296, *YYCURSOR);\n+yy1297:\n+\tYYDEBUG(1297, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'S') {\n \t\tif (yych <= ')') {\n@@ -19770,13 +19822,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 's') goto yy1297;\n+\t\t\tif (yych <= 's') goto yy1298;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1297:\n-\tYYDEBUG(1297, *YYCURSOR);\n+yy1298:\n+\tYYDEBUG(1298, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'T') {\n \t\tif (yych <= ')') {\n@@ -19792,13 +19844,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 't') goto yy1298;\n+\t\t\tif (yych <= 't') goto yy1299;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1298:\n-\tYYDEBUG(1298, *YYCURSOR);\n+yy1299:\n+\tYYDEBUG(1299, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '(') {\n@@ -19819,23 +19871,23 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1299:\n-\tYYDEBUG(1299, *YYCURSOR);\n-\tyych = *++YYCURSOR;\n-\tif (yych == 'D') goto yy1300;\n-\tif (yych != 'd') goto yy1070;\n yy1300:\n \tYYDEBUG(1300, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'A') goto yy1301;\n-\tif (yych != 'a') goto yy56;\n+\tif (yych == 'D') goto yy1301;\n+\tif (yych != 'd') goto yy1070;\n yy1301:\n \tYYDEBUG(1301, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'Y') goto yy1302;\n-\tif (yych != 'y') goto yy56;\n+\tif (yych == 'A') goto yy1302;\n+\tif (yych != 'a') goto yy56;\n yy1302:\n \tYYDEBUG(1302, *YYCURSOR);\n+\tyych = *++YYCURSOR;\n+\tif (yych == 'Y') goto yy1303;\n+\tif (yych != 'y') goto yy56;\n+yy1303:\n+\tYYDEBUG(1303, *YYCURSOR);\n \tyyaccept = 25;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'R') {\n@@ -19845,19 +19897,19 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tif (yych == 's') goto yy1109;\n \t\tgoto yy1084;\n \t}\n-\tYYDEBUG(1303, *YYCURSOR);\n-\tyych = *++YYCURSOR;\n-\tif (yych == 'O') goto yy1304;\n-\tif (yych != 'o') goto yy56;\n-yy1304:\n \tYYDEBUG(1304, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'F') goto yy1305;\n-\tif (yych != 'f') goto yy56;\n+\tif (yych == 'O') goto yy1305;\n+\tif (yych != 'o') goto yy56;\n yy1305:\n \tYYDEBUG(1305, *YYCURSOR);\n-\t++YYCURSOR;\n+\tyych = *++YYCURSOR;\n+\tif (yych == 'F') goto yy1306;\n+\tif (yych != 'f') goto yy56;\n+yy1306:\n \tYYDEBUG(1306, *YYCURSOR);\n+\t++YYCURSOR;\n+\tYYDEBUG(1307, *YYCURSOR);\n #line 1079 \"ext\/date\/lib\/parse_date.re\"\n \t{\n \t\tDEBUG_OUTPUT(\"firstdayof | lastdayof\");\n@@ -19874,9 +19926,9 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tTIMELIB_DEINIT;\n \t\treturn TIMELIB_LF_DAY_OF_MONTH;\n \t}\n-#line 19878 \"<stdout>\"\n-yy1307:\n-\tYYDEBUG(1307, *YYCURSOR);\n+#line 19930 \"<stdout>\"\n+yy1308:\n+\tYYDEBUG(1308, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'R') {\n@@ -19891,7 +19943,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'S') goto yy1297;\n+\t\t\tif (yych <= 'S') goto yy1298;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -19900,14 +19952,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 's') goto yy1308;\n+\t\t\t\tif (yych <= 's') goto yy1309;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1308:\n-\tYYDEBUG(1308, *YYCURSOR);\n+yy1309:\n+\tYYDEBUG(1309, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'S') {\n@@ -19922,7 +19974,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'T') goto yy1298;\n+\t\t\tif (yych <= 'T') goto yy1299;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -19931,21 +19983,21 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 't') goto yy1309;\n+\t\t\t\tif (yych <= 't') goto yy1310;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1309:\n-\tYYDEBUG(1309, *YYCURSOR);\n+yy1310:\n+\tYYDEBUG(1310, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '-') {\n \t\tif (yych <= ' ') {\n \t\t\tif (yych == '\\t') goto yy1069;\n \t\t\tif (yych <= 0x1F) goto yy3;\n-\t\t\tgoto yy1299;\n+\t\t\tgoto yy1300;\n \t\t} else {\n \t\t\tif (yych == ')') goto yy164;\n \t\t\tif (yych <= ',') goto yy3;\n@@ -19967,8 +20019,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1310:\n-\tYYDEBUG(1310, *YYCURSOR);\n+yy1311:\n+\tYYDEBUG(1311, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'B') {\n \t\tif (yych <= ')') {\n@@ -19977,7 +20029,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'A') goto yy166;\n-\t\t\tgoto yy1346;\n+\t\t\tgoto yy1348;\n \t\t}\n \t} else {\n \t\tif (yych <= 'a') {\n@@ -19985,37 +20037,37 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 'b') goto yy1346;\n+\t\t\tif (yych <= 'b') goto yy1348;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1311:\n-\tYYDEBUG(1311, *YYCURSOR);\n+yy1312:\n+\tYYDEBUG(1312, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'R') {\n \t\tif (yych <= '@') {\n \t\t\tif (yych == ')') goto yy164;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych == 'F') goto yy1336;\n+\t\t\tif (yych == 'F') goto yy1338;\n \t\t\tif (yych <= 'Q') goto yy166;\n-\t\t\tgoto yy1335;\n+\t\t\tgoto yy1337;\n \t\t}\n \t} else {\n \t\tif (yych <= 'f') {\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tif (yych <= 'e') goto yy166;\n-\t\t\tgoto yy1336;\n+\t\t\tgoto yy1338;\n \t\t} else {\n-\t\t\tif (yych == 'r') goto yy1335;\n+\t\t\tif (yych == 'r') goto yy1337;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1312:\n-\tYYDEBUG(1312, *YYCURSOR);\n+yy1313:\n+\tYYDEBUG(1313, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'U') {\n \t\tif (yych <= ')') {\n@@ -20024,7 +20076,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'T') goto yy166;\n-\t\t\tgoto yy1332;\n+\t\t\tgoto yy1334;\n \t\t}\n \t} else {\n \t\tif (yych <= 't') {\n@@ -20032,20 +20084,20 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 'u') goto yy1332;\n+\t\t\tif (yych <= 'u') goto yy1334;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1313:\n-\tYYDEBUG(1313, *YYCURSOR);\n+yy1314:\n+\tYYDEBUG(1314, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'O') {\n \t\tif (yych <= '@') {\n \t\t\tif (yych == ')') goto yy164;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych == 'I') goto yy1315;\n+\t\t\tif (yych == 'I') goto yy1316;\n \t\t\tif (yych <= 'N') goto yy166;\n \t\t}\n \t} else {\n@@ -20053,15 +20105,15 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tif (yych <= 'h') goto yy166;\n-\t\t\tgoto yy1315;\n+\t\t\tgoto yy1316;\n \t\t} else {\n-\t\t\tif (yych == 'o') goto yy1314;\n+\t\t\tif (yych == 'o') goto yy1315;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1314:\n-\tYYDEBUG(1314, *YYCURSOR);\n+yy1315:\n+\tYYDEBUG(1315, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'N') {\n \t\tif (yych <= ')') {\n@@ -20070,7 +20122,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'M') goto yy167;\n-\t\t\tgoto yy1318;\n+\t\t\tgoto yy1319;\n \t\t}\n \t} else {\n \t\tif (yych <= 'm') {\n@@ -20078,13 +20130,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 'n') goto yy1318;\n+\t\t\tif (yych <= 'n') goto yy1319;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1315:\n-\tYYDEBUG(1315, *YYCURSOR);\n+yy1316:\n+\tYYDEBUG(1316, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'D') {\n \t\tif (yych <= ')') {\n@@ -20100,13 +20152,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy191;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 'd') goto yy1316;\n+\t\t\tif (yych <= 'd') goto yy1317;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy191;\n \t\t}\n \t}\n-yy1316:\n-\tYYDEBUG(1316, *YYCURSOR);\n+yy1317:\n+\tYYDEBUG(1317, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'A') {\n \t\tif (yych == ')') goto yy164;\n@@ -20116,13 +20168,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych <= 'a') goto yy1317;\n+\t\t\tif (yych <= 'a') goto yy1318;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1317:\n-\tYYDEBUG(1317, *YYCURSOR);\n+yy1318:\n+\tYYDEBUG(1318, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'Y') {\n \t\tif (yych <= ')') {\n@@ -20144,8 +20196,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1318:\n-\tYYDEBUG(1318, *YYCURSOR);\n+yy1319:\n+\tYYDEBUG(1319, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'T') {\n \t\tif (yych <= ')') {\n@@ -20161,17 +20213,17 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 't') goto yy1319;\n+\t\t\tif (yych <= 't') goto yy1320;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1319:\n-\tYYDEBUG(1319, *YYCURSOR);\n+yy1320:\n+\tYYDEBUG(1320, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= ')') {\n-\t\tif (yych == ' ') goto yy1320;\n+\t\tif (yych == ' ') goto yy1321;\n \t\tif (yych <= '(') goto yy3;\n \t\tgoto yy164;\n \t} else {\n@@ -20184,101 +20236,157 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1320:\n-\tYYDEBUG(1320, *YYCURSOR);\n-\tyych = *++YYCURSOR;\n-\tif (yych == 'O') goto yy1321;\n-\tif (yych != 'o') goto yy56;\n yy1321:\n \tYYDEBUG(1321, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'F') goto yy1322;\n-\tif (yych != 'f') goto yy56;\n+\tif (yych == 'O') goto yy1322;\n+\tif (yych != 'o') goto yy56;\n yy1322:\n \tYYDEBUG(1322, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych != ' ') goto yy56;\n+\tif (yych == 'F') goto yy1323;\n+\tif (yych != 'f') goto yy56;\n+yy1323:\n \tYYDEBUG(1323, *YYCURSOR);\n \tyych = *++YYCURSOR;\n+\tif (yych != ' ') goto yy56;\n+\tYYDEBUG(1324, *YYCURSOR);\n+\tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy56;\n-\tif (yych <= '1') goto yy1324;\n-\tif (yych <= '2') goto yy1325;\n-\tif (yych <= '9') goto yy1326;\n+\tif (yych <= '1') goto yy1325;\n+\tif (yych <= '2') goto yy1326;\n+\tif (yych <= '9') goto yy1327;\n \tgoto yy56;\n-yy1324:\n-\tYYDEBUG(1324, *YYCURSOR);\n-\tyyaccept = 27;\n-\tyych = *(YYMARKER = ++YYCURSOR);\n-\tif (yych <= '\/') goto yy1327;\n-\tif (yych <= '9') goto yy1326;\n-\tgoto yy1327;\n yy1325:\n \tYYDEBUG(1325, *YYCURSOR);\n \tyyaccept = 27;\n \tyych = *(YYMARKER = ++YYCURSOR);\n-\tif (yych <= '\/') goto yy1327;\n-\tif (yych >= '5') goto yy1327;\n+\tif (yych <= '@') {\n+\t\tif (yych <= 0x1F) {\n+\t\t\tif (yych == '\\t') goto yy1328;\n+\t\t\tgoto yy1284;\n+\t\t} else {\n+\t\t\tif (yych <= ' ') goto yy1328;\n+\t\t\tif (yych <= '\/') goto yy1284;\n+\t\t\tif (yych <= '9') goto yy1327;\n+\t\t\tgoto yy1284;\n+\t\t}\n+\t} else {\n+\t\tif (yych <= '`') {\n+\t\t\tif (yych <= 'A') goto yy1330;\n+\t\t\tif (yych == 'P') goto yy1330;\n+\t\t\tgoto yy1284;\n+\t\t} else {\n+\t\t\tif (yych <= 'a') goto yy1330;\n+\t\t\tif (yych == 'p') goto yy1330;\n+\t\t\tgoto yy1284;\n+\t\t}\n+\t}\n yy1326:\n \tYYDEBUG(1326, *YYCURSOR);\n \tyyaccept = 27;\n-\tYYMARKER = ++YYCURSOR;\n-\tif ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);\n-\tyych = *YYCURSOR;\n+\tyych = *(YYMARKER = ++YYCURSOR);\n+\tif (yych <= '@') {\n+\t\tif (yych <= 0x1F) {\n+\t\t\tif (yych == '\\t') goto yy1328;\n+\t\t\tgoto yy1284;\n+\t\t} else {\n+\t\t\tif (yych <= ' ') goto yy1328;\n+\t\t\tif (yych <= '\/') goto yy1284;\n+\t\t\tif (yych >= '5') goto yy1284;\n+\t\t}\n+\t} else {\n+\t\tif (yych <= '`') {\n+\t\t\tif (yych <= 'A') goto yy1330;\n+\t\t\tif (yych == 'P') goto yy1330;\n+\t\t\tgoto yy1284;\n+\t\t} else {\n+\t\t\tif (yych <= 'a') goto yy1330;\n+\t\t\tif (yych == 'p') goto yy1330;\n+\t\t\tgoto yy1284;\n+\t\t}\n+\t}\n yy1327:\n \tYYDEBUG(1327, *YYCURSOR);\n+\tyyaccept = 27;\n+\tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'A') {\n \t\tif (yych <= 0x1F) {\n-\t\t\tif (yych == '\\t') goto yy1326;\n-\t\t\tgoto yy1284;\n+\t\t\tif (yych != '\\t') goto yy1284;\n \t\t} else {\n-\t\t\tif (yych <= ' ') goto yy1326;\n+\t\t\tif (yych <= ' ') goto yy1328;\n \t\t\tif (yych <= '@') goto yy1284;\n+\t\t\tgoto yy1330;\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n-\t\t\tif (yych != 'P') goto yy1284;\n+\t\t\tif (yych == 'P') goto yy1330;\n+\t\t\tgoto yy1284;\n \t\t} else {\n-\t\t\tif (yych <= 'a') goto yy1328;\n-\t\t\tif (yych != 'p') goto yy1284;\n+\t\t\tif (yych <= 'a') goto yy1330;\n+\t\t\tif (yych == 'p') goto yy1330;\n+\t\t\tgoto yy1284;\n \t\t}\n \t}\n yy1328:\n \tYYDEBUG(1328, *YYCURSOR);\n+\t++YYCURSOR;\n+\tif ((YYLIMIT - YYCURSOR) < 5) YYFILL(5);\n+\tyych = *YYCURSOR;\n+\tYYDEBUG(1329, *YYCURSOR);\n+\tif (yych <= 'A') {\n+\t\tif (yych <= 0x1F) {\n+\t\t\tif (yych == '\\t') goto yy1328;\n+\t\t\tgoto yy56;\n+\t\t} else {\n+\t\t\tif (yych <= ' ') goto yy1328;\n+\t\t\tif (yych <= '@') goto yy56;\n+\t\t}\n+\t} else {\n+\t\tif (yych <= '`') {\n+\t\t\tif (yych != 'P') goto yy56;\n+\t\t} else {\n+\t\t\tif (yych <= 'a') goto yy1330;\n+\t\t\tif (yych != 'p') goto yy56;\n+\t\t}\n+\t}\n+yy1330:\n+\tYYDEBUG(1330, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'L') {\n \t\tif (yych != '.') goto yy56;\n \t} else {\n-\t\tif (yych <= 'M') goto yy1330;\n-\t\tif (yych == 'm') goto yy1330;\n+\t\tif (yych <= 'M') goto yy1332;\n+\t\tif (yych == 'm') goto yy1332;\n \t\tgoto yy56;\n \t}\n-\tYYDEBUG(1329, *YYCURSOR);\n+\tYYDEBUG(1331, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'M') goto yy1330;\n+\tif (yych == 'M') goto yy1332;\n \tif (yych != 'm') goto yy56;\n-yy1330:\n-\tYYDEBUG(1330, *YYCURSOR);\n+yy1332:\n+\tYYDEBUG(1332, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 0x1F) {\n-\t\tif (yych <= 0x00) goto yy1292;\n-\t\tif (yych == '\\t') goto yy1292;\n+\t\tif (yych <= 0x00) goto yy1293;\n+\t\tif (yych == '\\t') goto yy1293;\n \t\tgoto yy56;\n \t} else {\n-\t\tif (yych <= ' ') goto yy1292;\n+\t\tif (yych <= ' ') goto yy1293;\n \t\tif (yych != '.') goto yy56;\n \t}\n-\tYYDEBUG(1331, *YYCURSOR);\n+\tYYDEBUG(1333, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\\t') {\n-\t\tif (yych <= 0x00) goto yy1292;\n+\t\tif (yych <= 0x00) goto yy1293;\n \t\tif (yych <= 0x08) goto yy56;\n-\t\tgoto yy1292;\n+\t\tgoto yy1293;\n \t} else {\n-\t\tif (yych == ' ') goto yy1292;\n+\t\tif (yych == ' ') goto yy1293;\n \t\tgoto yy56;\n \t}\n-yy1332:\n-\tYYDEBUG(1332, *YYCURSOR);\n+yy1334:\n+\tYYDEBUG(1334, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'R') {\n \t\tif (yych <= ')') {\n@@ -20294,13 +20402,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 'r') goto yy1333;\n+\t\t\tif (yych <= 'r') goto yy1335;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1333:\n-\tYYDEBUG(1333, *YYCURSOR);\n+yy1335:\n+\tYYDEBUG(1335, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'T') {\n \t\tif (yych <= ')') {\n@@ -20316,13 +20424,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 't') goto yy1334;\n+\t\t\tif (yych <= 't') goto yy1336;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1334:\n-\tYYDEBUG(1334, *YYCURSOR);\n+yy1336:\n+\tYYDEBUG(1336, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'H') {\n \t\tif (yych <= ')') {\n@@ -20344,8 +20452,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1335:\n-\tYYDEBUG(1335, *YYCURSOR);\n+yy1337:\n+\tYYDEBUG(1337, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'S') {\n \t\tif (yych <= ')') {\n@@ -20354,7 +20462,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'R') goto yy167;\n-\t\t\tgoto yy1338;\n+\t\t\tgoto yy1340;\n \t\t}\n \t} else {\n \t\tif (yych <= 'r') {\n@@ -20362,13 +20470,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 's') goto yy1338;\n+\t\t\tif (yych <= 's') goto yy1340;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1336:\n-\tYYDEBUG(1336, *YYCURSOR);\n+yy1338:\n+\tYYDEBUG(1338, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'T') {\n \t\tif (yych <= ')') {\n@@ -20384,13 +20492,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 't') goto yy1337;\n+\t\t\tif (yych <= 't') goto yy1339;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1337:\n-\tYYDEBUG(1337, *YYCURSOR);\n+yy1339:\n+\tYYDEBUG(1339, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'H') {\n \t\tif (yych <= ')') {\n@@ -20412,8 +20520,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1338:\n-\tYYDEBUG(1338, *YYCURSOR);\n+yy1340:\n+\tYYDEBUG(1340, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'T') {\n \t\tif (yych <= ')') {\n@@ -20429,13 +20537,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 't') goto yy1339;\n+\t\t\tif (yych <= 't') goto yy1341;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1339:\n-\tYYDEBUG(1339, *YYCURSOR);\n+yy1341:\n+\tYYDEBUG(1341, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '(') {\n@@ -20456,23 +20564,23 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1340:\n-\tYYDEBUG(1340, *YYCURSOR);\n+yy1342:\n+\tYYDEBUG(1342, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'D') goto yy1341;\n+\tif (yych == 'D') goto yy1343;\n \tif (yych != 'd') goto yy1197;\n-yy1341:\n-\tYYDEBUG(1341, *YYCURSOR);\n+yy1343:\n+\tYYDEBUG(1343, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'A') goto yy1342;\n+\tif (yych == 'A') goto yy1344;\n \tif (yych != 'a') goto yy56;\n-yy1342:\n-\tYYDEBUG(1342, *YYCURSOR);\n+yy1344:\n+\tYYDEBUG(1344, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'Y') goto yy1343;\n+\tif (yych == 'Y') goto yy1345;\n \tif (yych != 'y') goto yy56;\n-yy1343:\n-\tYYDEBUG(1343, *YYCURSOR);\n+yy1345:\n+\tYYDEBUG(1345, *YYCURSOR);\n \tyyaccept = 25;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'R') {\n@@ -20482,18 +20590,18 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tif (yych == 's') goto yy1109;\n \t\tgoto yy1084;\n \t}\n-\tYYDEBUG(1344, *YYCURSOR);\n+\tYYDEBUG(1346, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'O') goto yy1345;\n+\tif (yych == 'O') goto yy1347;\n \tif (yych != 'o') goto yy56;\n-yy1345:\n-\tYYDEBUG(1345, *YYCURSOR);\n+yy1347:\n+\tYYDEBUG(1347, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'F') goto yy1305;\n-\tif (yych == 'f') goto yy1305;\n+\tif (yych == 'F') goto yy1306;\n+\tif (yych == 'f') goto yy1306;\n \tgoto yy56;\n-yy1346:\n-\tYYDEBUG(1346, *YYCURSOR);\n+yy1348:\n+\tYYDEBUG(1348, *YYCURSOR);\n \tyyaccept = 5;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '\/') {\n@@ -20528,14 +20636,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy218;\n \t\t\t\tgoto yy167;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'r') goto yy1347;\n+\t\t\t\tif (yych <= 'r') goto yy1349;\n \t\t\t\tif (yych <= 'z') goto yy167;\n \t\t\t\tgoto yy218;\n \t\t\t}\n \t\t}\n \t}\n-yy1347:\n-\tYYDEBUG(1347, *YYCURSOR);\n+yy1349:\n+\tYYDEBUG(1349, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'U') {\n \t\tif (yych <= ')') {\n@@ -20551,13 +20659,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 'u') goto yy1348;\n+\t\t\tif (yych <= 'u') goto yy1350;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1348:\n-\tYYDEBUG(1348, *YYCURSOR);\n+yy1350:\n+\tYYDEBUG(1350, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'A') {\n \t\tif (yych == ')') goto yy164;\n@@ -20567,30 +20675,30 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= 'Z') goto yy169;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych <= 'a') goto yy1349;\n+\t\t\tif (yych <= 'a') goto yy1351;\n \t\t\tif (yych <= 'z') goto yy169;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1349:\n-\tYYDEBUG(1349, *YYCURSOR);\n+yy1351:\n+\tYYDEBUG(1351, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'Q') {\n \t\tif (yych == ')') goto yy164;\n \t\tgoto yy3;\n \t} else {\n-\t\tif (yych <= 'R') goto yy1350;\n+\t\tif (yych <= 'R') goto yy1352;\n \t\tif (yych != 'r') goto yy3;\n \t}\n-yy1350:\n-\tYYDEBUG(1350, *YYCURSOR);\n+yy1352:\n+\tYYDEBUG(1352, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych == 'Y') goto yy229;\n \tif (yych == 'y') goto yy229;\n \tgoto yy56;\n-yy1351:\n-\tYYDEBUG(1351, *YYCURSOR);\n+yy1353:\n+\tYYDEBUG(1353, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'A') {\n@@ -20605,7 +20713,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'B') goto yy1346;\n+\t\t\tif (yych <= 'B') goto yy1348;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -20614,14 +20722,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'b') goto yy1369;\n+\t\t\t\tif (yych <= 'b') goto yy1371;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1352:\n-\tYYDEBUG(1352, *YYCURSOR);\n+yy1354:\n+\tYYDEBUG(1354, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'Q') {\n@@ -20638,14 +20746,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '\/') goto yy172;\n \t\t\t\tgoto yy3;\n \t\t\t} else {\n-\t\t\t\tif (yych == 'F') goto yy1336;\n+\t\t\t\tif (yych == 'F') goto yy1338;\n \t\t\t\tgoto yy166;\n \t\t\t}\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n \t\t\tif (yych <= 'Z') {\n-\t\t\t\tif (yych <= 'R') goto yy1335;\n+\t\t\t\tif (yych <= 'R') goto yy1337;\n \t\t\t\tgoto yy166;\n \t\t\t} else {\n \t\t\t\tif (yych == '_') goto yy172;\n@@ -20653,17 +20761,17 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'q') {\n-\t\t\t\tif (yych == 'f') goto yy1365;\n+\t\t\t\tif (yych == 'f') goto yy1367;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'r') goto yy1364;\n+\t\t\t\tif (yych <= 'r') goto yy1366;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1353:\n-\tYYDEBUG(1353, *YYCURSOR);\n+yy1355:\n+\tYYDEBUG(1355, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'T') {\n@@ -20678,7 +20786,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'U') goto yy1332;\n+\t\t\tif (yych <= 'U') goto yy1334;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -20687,14 +20795,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'u') goto yy1361;\n+\t\t\t\tif (yych <= 'u') goto yy1363;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1354:\n-\tYYDEBUG(1354, *YYCURSOR);\n+yy1356:\n+\tYYDEBUG(1356, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'N') {\n@@ -20711,14 +20819,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '\/') goto yy172;\n \t\t\t\tgoto yy3;\n \t\t\t} else {\n-\t\t\t\tif (yych == 'I') goto yy1315;\n+\t\t\t\tif (yych == 'I') goto yy1316;\n \t\t\t\tgoto yy166;\n \t\t\t}\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n \t\t\tif (yych <= 'Z') {\n-\t\t\t\tif (yych <= 'O') goto yy1314;\n+\t\t\t\tif (yych <= 'O') goto yy1315;\n \t\t\t\tgoto yy166;\n \t\t\t} else {\n \t\t\t\tif (yych == '_') goto yy172;\n@@ -20726,17 +20834,17 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'n') {\n-\t\t\t\tif (yych == 'i') goto yy1356;\n+\t\t\t\tif (yych == 'i') goto yy1358;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'o') goto yy1355;\n+\t\t\t\tif (yych <= 'o') goto yy1357;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1355:\n-\tYYDEBUG(1355, *YYCURSOR);\n+yy1357:\n+\tYYDEBUG(1357, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'M') {\n@@ -20751,7 +20859,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'N') goto yy1318;\n+\t\t\tif (yych <= 'N') goto yy1319;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -20760,14 +20868,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'n') goto yy1359;\n+\t\t\t\tif (yych <= 'n') goto yy1361;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1356:\n-\tYYDEBUG(1356, *YYCURSOR);\n+yy1358:\n+\tYYDEBUG(1358, *YYCURSOR);\n \tyyaccept = 4;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'C') {\n@@ -20782,7 +20890,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'D') goto yy1316;\n+\t\t\tif (yych <= 'D') goto yy1317;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy191;\n \t\t\tgoto yy172;\n@@ -20791,14 +20899,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy191;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'd') goto yy1357;\n+\t\t\t\tif (yych <= 'd') goto yy1359;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy191;\n \t\t\t}\n \t\t}\n \t}\n-yy1357:\n-\tYYDEBUG(1357, *YYCURSOR);\n+yy1359:\n+\tYYDEBUG(1359, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '@') {\n@@ -20812,19 +20920,19 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'A') goto yy1317;\n+\t\t\tif (yych <= 'A') goto yy1318;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n \t\t} else {\n \t\t\tif (yych <= '`') goto yy3;\n-\t\t\tif (yych <= 'a') goto yy1358;\n+\t\t\tif (yych <= 'a') goto yy1360;\n \t\t\tif (yych <= 'z') goto yy176;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1358:\n-\tYYDEBUG(1358, *YYCURSOR);\n+yy1360:\n+\tYYDEBUG(1360, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'X') {\n@@ -20854,8 +20962,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1359:\n-\tYYDEBUG(1359, *YYCURSOR);\n+yy1361:\n+\tYYDEBUG(1361, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'S') {\n@@ -20870,7 +20978,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'T') goto yy1319;\n+\t\t\tif (yych <= 'T') goto yy1320;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -20879,19 +20987,19 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 't') goto yy1360;\n+\t\t\t\tif (yych <= 't') goto yy1362;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1360:\n-\tYYDEBUG(1360, *YYCURSOR);\n+yy1362:\n+\tYYDEBUG(1362, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '.') {\n \t\tif (yych <= '(') {\n-\t\t\tif (yych == ' ') goto yy1320;\n+\t\t\tif (yych == ' ') goto yy1321;\n \t\t\tgoto yy3;\n \t\t} else {\n \t\t\tif (yych <= ')') goto yy164;\n@@ -20911,8 +21019,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1361:\n-\tYYDEBUG(1361, *YYCURSOR);\n+yy1363:\n+\tYYDEBUG(1363, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'Q') {\n@@ -20927,7 +21035,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'R') goto yy1333;\n+\t\t\tif (yych <= 'R') goto yy1335;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -20936,14 +21044,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'r') goto yy1362;\n+\t\t\t\tif (yych <= 'r') goto yy1364;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1362:\n-\tYYDEBUG(1362, *YYCURSOR);\n+yy1364:\n+\tYYDEBUG(1364, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'S') {\n@@ -20958,7 +21066,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'T') goto yy1334;\n+\t\t\tif (yych <= 'T') goto yy1336;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -20967,14 +21075,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 't') goto yy1363;\n+\t\t\t\tif (yych <= 't') goto yy1365;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1363:\n-\tYYDEBUG(1363, *YYCURSOR);\n+yy1365:\n+\tYYDEBUG(1365, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'G') {\n@@ -21004,8 +21112,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1364:\n-\tYYDEBUG(1364, *YYCURSOR);\n+yy1366:\n+\tYYDEBUG(1366, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'R') {\n@@ -21020,7 +21128,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'S') goto yy1338;\n+\t\t\tif (yych <= 'S') goto yy1340;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -21029,14 +21137,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 's') goto yy1367;\n+\t\t\t\tif (yych <= 's') goto yy1369;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1365:\n-\tYYDEBUG(1365, *YYCURSOR);\n+yy1367:\n+\tYYDEBUG(1367, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'S') {\n@@ -21051,7 +21159,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'T') goto yy1337;\n+\t\t\tif (yych <= 'T') goto yy1339;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -21060,14 +21168,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 't') goto yy1366;\n+\t\t\t\tif (yych <= 't') goto yy1368;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1366:\n-\tYYDEBUG(1366, *YYCURSOR);\n+yy1368:\n+\tYYDEBUG(1368, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'G') {\n@@ -21097,8 +21205,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1367:\n-\tYYDEBUG(1367, *YYCURSOR);\n+yy1369:\n+\tYYDEBUG(1369, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'S') {\n@@ -21113,7 +21221,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'T') goto yy1339;\n+\t\t\tif (yych <= 'T') goto yy1341;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -21122,21 +21230,21 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 't') goto yy1368;\n+\t\t\t\tif (yych <= 't') goto yy1370;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1368:\n-\tYYDEBUG(1368, *YYCURSOR);\n+yy1370:\n+\tYYDEBUG(1370, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '-') {\n \t\tif (yych <= ' ') {\n \t\t\tif (yych == '\\t') goto yy1196;\n \t\t\tif (yych <= 0x1F) goto yy3;\n-\t\t\tgoto yy1340;\n+\t\t\tgoto yy1342;\n \t\t} else {\n \t\t\tif (yych == ')') goto yy164;\n \t\t\tif (yych <= ',') goto yy3;\n@@ -21158,8 +21266,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1369:\n-\tYYDEBUG(1369, *YYCURSOR);\n+yy1371:\n+\tYYDEBUG(1371, *YYCURSOR);\n \tyyaccept = 5;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '9') {\n@@ -21187,7 +21295,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '@') goto yy218;\n \t\t\t\tgoto yy167;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'R') goto yy1347;\n+\t\t\t\tif (yych <= 'R') goto yy1349;\n \t\t\t\tif (yych <= 'Z') goto yy167;\n \t\t\t\tgoto yy218;\n \t\t\t}\n@@ -21197,14 +21305,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy218;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'r') goto yy1370;\n+\t\t\t\tif (yych <= 'r') goto yy1372;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy218;\n \t\t\t}\n \t\t}\n \t}\n-yy1370:\n-\tYYDEBUG(1370, *YYCURSOR);\n+yy1372:\n+\tYYDEBUG(1372, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'T') {\n@@ -21219,7 +21327,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'U') goto yy1348;\n+\t\t\tif (yych <= 'U') goto yy1350;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -21228,14 +21336,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'u') goto yy1371;\n+\t\t\t\tif (yych <= 'u') goto yy1373;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1371:\n-\tYYDEBUG(1371, *YYCURSOR);\n+yy1373:\n+\tYYDEBUG(1373, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '@') {\n@@ -21249,19 +21357,19 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'A') goto yy1349;\n+\t\t\tif (yych <= 'A') goto yy1351;\n \t\t\tif (yych <= 'Z') goto yy169;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n \t\t} else {\n \t\t\tif (yych <= '`') goto yy3;\n-\t\t\tif (yych <= 'a') goto yy1372;\n+\t\t\tif (yych <= 'a') goto yy1374;\n \t\t\tif (yych <= 'z') goto yy177;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1372:\n-\tYYDEBUG(1372, *YYCURSOR);\n+yy1374:\n+\tYYDEBUG(1374, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'Q') {\n@@ -21275,38 +21383,38 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n-\t\t\tif (yych <= 'R') goto yy1350;\n+\t\t\tif (yych <= 'R') goto yy1352;\n \t\t\tif (yych == '_') goto yy172;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych == 'r') goto yy1373;\n+\t\t\tif (yych == 'r') goto yy1375;\n \t\t\tif (yych <= 'z') goto yy178;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1373:\n-\tYYDEBUG(1373, *YYCURSOR);\n+yy1375:\n+\tYYDEBUG(1375, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych == 'Y') goto yy229;\n \tif (yych == 'y') goto yy341;\n \tgoto yy179;\n-yy1374:\n-\tYYDEBUG(1374, *YYCURSOR);\n+yy1376:\n+\tYYDEBUG(1376, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy56;\n \tif (yych >= ':') goto yy56;\n-yy1375:\n-\tYYDEBUG(1375, *YYCURSOR);\n+yy1377:\n+\tYYDEBUG(1377, *YYCURSOR);\n \tyyaccept = 28;\n \tYYMARKER = ++YYCURSOR;\n \tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);\n \tyych = *YYCURSOR;\n-\tYYDEBUG(1376, *YYCURSOR);\n-\tif (yych == '.') goto yy1378;\n-\tif (yych <= '\/') goto yy1377;\n-\tif (yych <= '9') goto yy1375;\n-yy1377:\n-\tYYDEBUG(1377, *YYCURSOR);\n+\tYYDEBUG(1378, *YYCURSOR);\n+\tif (yych == '.') goto yy1380;\n+\tif (yych <= '\/') goto yy1379;\n+\tif (yych <= '9') goto yy1377;\n+yy1379:\n+\tYYDEBUG(1379, *YYCURSOR);\n #line 1025 \"ext\/date\/lib\/parse_date.re\"\n \t{\n \t\ttimelib_ull i;\n@@ -21332,35 +21440,35 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tTIMELIB_DEINIT;\n \t\treturn TIMELIB_RELATIVE;\n \t}\n-#line 21336 \"<stdout>\"\n-yy1378:\n-\tYYDEBUG(1378, *YYCURSOR);\n+#line 21444 \"<stdout>\"\n+yy1380:\n+\tYYDEBUG(1380, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy56;\n \tif (yych >= ':') goto yy56;\n-\tYYDEBUG(1379, *YYCURSOR);\n+\tYYDEBUG(1381, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy56;\n \tif (yych >= ':') goto yy56;\n-\tYYDEBUG(1380, *YYCURSOR);\n+\tYYDEBUG(1382, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy56;\n \tif (yych >= ':') goto yy56;\n-\tYYDEBUG(1381, *YYCURSOR);\n+\tYYDEBUG(1383, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy56;\n \tif (yych >= ':') goto yy56;\n-\tYYDEBUG(1382, *YYCURSOR);\n+\tYYDEBUG(1384, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy56;\n \tif (yych >= ':') goto yy56;\n-\tYYDEBUG(1383, *YYCURSOR);\n+\tYYDEBUG(1385, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy56;\n \tif (yych >= ':') goto yy56;\n-\tYYDEBUG(1384, *YYCURSOR);\n+\tYYDEBUG(1386, *YYCURSOR);\n \t++YYCURSOR;\n-\tYYDEBUG(1385, *YYCURSOR);\n+\tYYDEBUG(1387, *YYCURSOR);\n #line 1051 \"ext\/date\/lib\/parse_date.re\"\n \t{\n \t\ttimelib_ull i, ms;\n@@ -21388,9 +21496,9 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tTIMELIB_DEINIT;\n \t\treturn TIMELIB_RELATIVE;\n \t}\n-#line 21392 \"<stdout>\"\n-yy1386:\n-\tYYDEBUG(1386, *YYCURSOR);\n+#line 21500 \"<stdout>\"\n+yy1388:\n+\tYYDEBUG(1388, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'N') {\n \t\tif (yych <= ')') {\n@@ -21399,7 +21507,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'M') goto yy166;\n-\t\t\tgoto yy1427;\n+\t\t\tgoto yy1429;\n \t\t}\n \t} else {\n \t\tif (yych <= 'm') {\n@@ -21407,61 +21515,61 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 'n') goto yy1427;\n+\t\t\tif (yych <= 'n') goto yy1429;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1387:\n-\tYYDEBUG(1387, *YYCURSOR);\n+yy1389:\n+\tYYDEBUG(1389, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'U') {\n \t\tif (yych <= '@') {\n \t\t\tif (yych == ')') goto yy164;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych == 'I') goto yy1419;\n+\t\t\tif (yych == 'I') goto yy1421;\n \t\t\tif (yych <= 'T') goto yy166;\n-\t\t\tgoto yy1420;\n+\t\t\tgoto yy1422;\n \t\t}\n \t} else {\n \t\tif (yych <= 'i') {\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tif (yych <= 'h') goto yy166;\n-\t\t\tgoto yy1419;\n+\t\t\tgoto yy1421;\n \t\t} else {\n-\t\t\tif (yych == 'u') goto yy1420;\n+\t\t\tif (yych == 'u') goto yy1422;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1388:\n-\tYYDEBUG(1388, *YYCURSOR);\n+yy1390:\n+\tYYDEBUG(1390, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'M') {\n \t\tif (yych <= '@') {\n \t\t\tif (yych == ')') goto yy164;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych == 'D') goto yy1408;\n+\t\t\tif (yych == 'D') goto yy1410;\n \t\t\tif (yych <= 'L') goto yy166;\n-\t\t\tgoto yy1409;\n+\t\t\tgoto yy1411;\n \t\t}\n \t} else {\n \t\tif (yych <= 'd') {\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tif (yych <= 'c') goto yy166;\n-\t\t\tgoto yy1408;\n+\t\t\tgoto yy1410;\n \t\t} else {\n-\t\t\tif (yych == 'm') goto yy1409;\n+\t\t\tif (yych == 'm') goto yy1411;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1389:\n-\tYYDEBUG(1389, *YYCURSOR);\n+yy1391:\n+\tYYDEBUG(1391, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'E') {\n \t\tif (yych <= ')') {\n@@ -21470,7 +21578,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'D') goto yy166;\n-\t\t\tgoto yy1404;\n+\t\t\tgoto yy1406;\n \t\t}\n \t} else {\n \t\tif (yych <= 'd') {\n@@ -21478,13 +21586,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 'e') goto yy1404;\n+\t\t\tif (yych <= 'e') goto yy1406;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1390:\n-\tYYDEBUG(1390, *YYCURSOR);\n+yy1392:\n+\tYYDEBUG(1392, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'E') {\n \t\tif (yych <= ')') {\n@@ -21493,7 +21601,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'D') goto yy166;\n-\t\t\tgoto yy1400;\n+\t\t\tgoto yy1402;\n \t\t}\n \t} else {\n \t\tif (yych <= 'd') {\n@@ -21501,78 +21609,78 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 'e') goto yy1400;\n+\t\t\tif (yych <= 'e') goto yy1402;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1391:\n-\tYYDEBUG(1391, *YYCURSOR);\n+yy1393:\n+\tYYDEBUG(1393, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') {\n \t\tif (yych == '.') goto yy1029;\n \t\tgoto yy56;\n \t} else {\n-\t\tif (yych <= '9') goto yy1394;\n+\t\tif (yych <= '9') goto yy1396;\n \t\tif (yych <= ':') goto yy1029;\n \t\tgoto yy56;\n \t}\n-yy1392:\n-\tYYDEBUG(1392, *YYCURSOR);\n+yy1394:\n+\tYYDEBUG(1394, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') {\n \t\tif (yych == '.') goto yy1029;\n \t\tgoto yy56;\n \t} else {\n-\t\tif (yych <= '4') goto yy1394;\n+\t\tif (yych <= '4') goto yy1396;\n \t\tif (yych == ':') goto yy1029;\n \t\tgoto yy56;\n \t}\n-yy1393:\n-\tYYDEBUG(1393, *YYCURSOR);\n+yy1395:\n+\tYYDEBUG(1395, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych == '.') goto yy1029;\n \tif (yych == ':') goto yy1029;\n \tgoto yy56;\n-yy1394:\n-\tYYDEBUG(1394, *YYCURSOR);\n+yy1396:\n+\tYYDEBUG(1396, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') {\n \t\tif (yych == '.') goto yy1029;\n \t\tgoto yy56;\n \t} else {\n-\t\tif (yych <= '5') goto yy1395;\n+\t\tif (yych <= '5') goto yy1397;\n \t\tif (yych == ':') goto yy1029;\n \t\tgoto yy56;\n \t}\n-yy1395:\n-\tYYDEBUG(1395, *YYCURSOR);\n+yy1397:\n+\tYYDEBUG(1397, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy56;\n \tif (yych >= ':') goto yy56;\n-\tYYDEBUG(1396, *YYCURSOR);\n+\tYYDEBUG(1398, *YYCURSOR);\n \tyyaccept = 23;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '\/') goto yy1032;\n-\tif (yych <= '5') goto yy1397;\n-\tif (yych <= '6') goto yy1398;\n+\tif (yych <= '5') goto yy1399;\n+\tif (yych <= '6') goto yy1400;\n \tgoto yy1032;\n-yy1397:\n-\tYYDEBUG(1397, *YYCURSOR);\n+yy1399:\n+\tYYDEBUG(1399, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy56;\n-\tif (yych <= '9') goto yy1399;\n+\tif (yych <= '9') goto yy1401;\n \tgoto yy56;\n-yy1398:\n-\tYYDEBUG(1398, *YYCURSOR);\n+yy1400:\n+\tYYDEBUG(1400, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych != '0') goto yy56;\n-yy1399:\n-\tYYDEBUG(1399, *YYCURSOR);\n+yy1401:\n+\tYYDEBUG(1401, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tgoto yy1040;\n-yy1400:\n-\tYYDEBUG(1400, *YYCURSOR);\n+yy1402:\n+\tYYDEBUG(1402, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'L') {\n \t\tif (yych <= ')') {\n@@ -21588,13 +21696,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 'l') goto yy1401;\n+\t\t\tif (yych <= 'l') goto yy1403;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1401:\n-\tYYDEBUG(1401, *YYCURSOR);\n+yy1403:\n+\tYYDEBUG(1403, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'F') {\n \t\tif (yych <= ')') {\n@@ -21610,13 +21718,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 'f') goto yy1402;\n+\t\t\tif (yych <= 'f') goto yy1404;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1402:\n-\tYYDEBUG(1402, *YYCURSOR);\n+yy1404:\n+\tYYDEBUG(1404, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'T') {\n \t\tif (yych <= ')') {\n@@ -21632,13 +21740,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy169;\n \t\t} else {\n-\t\t\tif (yych <= 't') goto yy1403;\n+\t\t\tif (yych <= 't') goto yy1405;\n \t\t\tif (yych <= 'z') goto yy169;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1403:\n-\tYYDEBUG(1403, *YYCURSOR);\n+yy1405:\n+\tYYDEBUG(1405, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'G') {\n@@ -21649,8 +21757,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tif (yych == 'h') goto yy1195;\n \t\tgoto yy3;\n \t}\n-yy1404:\n-\tYYDEBUG(1404, *YYCURSOR);\n+yy1406:\n+\tYYDEBUG(1406, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'S') {\n \t\tif (yych <= ')') {\n@@ -21666,13 +21774,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy191;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 's') goto yy1405;\n+\t\t\tif (yych <= 's') goto yy1407;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy191;\n \t\t}\n \t}\n-yy1405:\n-\tYYDEBUG(1405, *YYCURSOR);\n+yy1407:\n+\tYYDEBUG(1407, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'D') {\n \t\tif (yych <= ')') {\n@@ -21688,13 +21796,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 'd') goto yy1406;\n+\t\t\tif (yych <= 'd') goto yy1408;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1406:\n-\tYYDEBUG(1406, *YYCURSOR);\n+yy1408:\n+\tYYDEBUG(1408, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'A') {\n \t\tif (yych == ')') goto yy164;\n@@ -21704,13 +21812,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= 'Z') goto yy169;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych <= 'a') goto yy1407;\n+\t\t\tif (yych <= 'a') goto yy1409;\n \t\t\tif (yych <= 'z') goto yy169;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1407:\n-\tYYDEBUG(1407, *YYCURSOR);\n+yy1409:\n+\tYYDEBUG(1409, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'X') {\n \t\tif (yych == ')') goto yy164;\n@@ -21720,25 +21828,25 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tif (yych == 'y') goto yy197;\n \t\tgoto yy3;\n \t}\n-yy1408:\n-\tYYDEBUG(1408, *YYCURSOR);\n+yy1410:\n+\tYYDEBUG(1410, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'A') {\n \t\tif (yych == ')') goto yy164;\n \t\tif (yych <= '@') goto yy3;\n-\t\tgoto yy1416;\n+\t\tgoto yy1418;\n \t} else {\n \t\tif (yych <= '`') {\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych <= 'a') goto yy1416;\n+\t\t\tif (yych <= 'a') goto yy1418;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1409:\n-\tYYDEBUG(1409, *YYCURSOR);\n+yy1411:\n+\tYYDEBUG(1411, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'O') {\n \t\tif (yych <= ')') {\n@@ -21754,13 +21862,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 'o') goto yy1410;\n+\t\t\tif (yych <= 'o') goto yy1412;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1410:\n-\tYYDEBUG(1410, *YYCURSOR);\n+yy1412:\n+\tYYDEBUG(1412, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'R') {\n \t\tif (yych <= ')') {\n@@ -21776,13 +21884,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 'r') goto yy1411;\n+\t\t\tif (yych <= 'r') goto yy1413;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1411:\n-\tYYDEBUG(1411, *YYCURSOR);\n+yy1413:\n+\tYYDEBUG(1413, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'R') {\n \t\tif (yych <= ')') {\n@@ -21798,32 +21906,32 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy169;\n \t\t} else {\n-\t\t\tif (yych <= 'r') goto yy1412;\n+\t\t\tif (yych <= 'r') goto yy1414;\n \t\t\tif (yych <= 'z') goto yy169;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1412:\n-\tYYDEBUG(1412, *YYCURSOR);\n+yy1414:\n+\tYYDEBUG(1414, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'N') {\n \t\tif (yych == ')') goto yy164;\n \t\tgoto yy3;\n \t} else {\n-\t\tif (yych <= 'O') goto yy1413;\n+\t\tif (yych <= 'O') goto yy1415;\n \t\tif (yych != 'o') goto yy3;\n \t}\n-yy1413:\n-\tYYDEBUG(1413, *YYCURSOR);\n+yy1415:\n+\tYYDEBUG(1415, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'W') goto yy1414;\n+\tif (yych == 'W') goto yy1416;\n \tif (yych != 'w') goto yy56;\n-yy1414:\n-\tYYDEBUG(1414, *YYCURSOR);\n+yy1416:\n+\tYYDEBUG(1416, *YYCURSOR);\n \t++YYCURSOR;\n-yy1415:\n-\tYYDEBUG(1415, *YYCURSOR);\n+yy1417:\n+\tYYDEBUG(1417, *YYCURSOR);\n #line 1013 \"ext\/date\/lib\/parse_date.re\"\n \t{\n \t\tDEBUG_OUTPUT(\"tomorrow\");\n@@ -21835,9 +21943,9 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tTIMELIB_DEINIT;\n \t\treturn TIMELIB_RELATIVE;\n \t}\n-#line 21839 \"<stdout>\"\n-yy1416:\n-\tYYDEBUG(1416, *YYCURSOR);\n+#line 21947 \"<stdout>\"\n+yy1418:\n+\tYYDEBUG(1418, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'Y') {\n \t\tif (yych <= ')') {\n@@ -21853,23 +21961,23 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 'y') goto yy1417;\n+\t\t\tif (yych <= 'y') goto yy1419;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1417:\n-\tYYDEBUG(1417, *YYCURSOR);\n+yy1419:\n+\tYYDEBUG(1419, *YYCURSOR);\n \t++YYCURSOR;\n \tif ((yych = *YYCURSOR) <= '@') {\n \t\tif (yych == ')') goto yy164;\n \t} else {\n \t\tif (yych <= 'Z') goto yy169;\n-\t\tif (yych <= '`') goto yy1418;\n+\t\tif (yych <= '`') goto yy1420;\n \t\tif (yych <= 'z') goto yy169;\n \t}\n-yy1418:\n-\tYYDEBUG(1418, *YYCURSOR);\n+yy1420:\n+\tYYDEBUG(1420, *YYCURSOR);\n #line 1003 \"ext\/date\/lib\/parse_date.re\"\n \t{\n \t\tDEBUG_OUTPUT(\"midnight | today\");\n@@ -21879,9 +21987,9 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tTIMELIB_DEINIT;\n \t\treturn TIMELIB_RELATIVE;\n \t}\n-#line 21883 \"<stdout>\"\n-yy1419:\n-\tYYDEBUG(1419, *YYCURSOR);\n+#line 21991 \"<stdout>\"\n+yy1421:\n+\tYYDEBUG(1421, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'S') {\n \t\tif (yych <= '@') {\n@@ -21889,8 +21997,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t} else {\n \t\t\tif (yych <= 'Q') goto yy167;\n-\t\t\tif (yych <= 'R') goto yy1425;\n-\t\t\tgoto yy1426;\n+\t\t\tif (yych <= 'R') goto yy1427;\n+\t\t\tgoto yy1428;\n \t\t}\n \t} else {\n \t\tif (yych <= 'q') {\n@@ -21898,14 +22006,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 'r') goto yy1425;\n-\t\t\tif (yych <= 's') goto yy1426;\n+\t\t\tif (yych <= 'r') goto yy1427;\n+\t\t\tif (yych <= 's') goto yy1428;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1420:\n-\tYYDEBUG(1420, *YYCURSOR);\n+yy1422:\n+\tYYDEBUG(1422, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'R') {\n \t\tif (yych <= ')') {\n@@ -21921,13 +22029,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy191;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 'r') goto yy1421;\n+\t\t\tif (yych <= 'r') goto yy1423;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy191;\n \t\t}\n \t}\n-yy1421:\n-\tYYDEBUG(1421, *YYCURSOR);\n+yy1423:\n+\tYYDEBUG(1423, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'S') {\n \t\tif (yych <= ')') {\n@@ -21943,13 +22051,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 's') goto yy1422;\n+\t\t\tif (yych <= 's') goto yy1424;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1422:\n-\tYYDEBUG(1422, *YYCURSOR);\n+yy1424:\n+\tYYDEBUG(1424, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'D') {\n \t\tif (yych <= ')') {\n@@ -21965,30 +22073,30 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy169;\n \t\t} else {\n-\t\t\tif (yych <= 'd') goto yy1423;\n+\t\t\tif (yych <= 'd') goto yy1425;\n \t\t\tif (yych <= 'z') goto yy169;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1423:\n-\tYYDEBUG(1423, *YYCURSOR);\n+yy1425:\n+\tYYDEBUG(1425, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '@') {\n \t\tif (yych == ')') goto yy164;\n \t\tgoto yy3;\n \t} else {\n-\t\tif (yych <= 'A') goto yy1424;\n+\t\tif (yych <= 'A') goto yy1426;\n \t\tif (yych != 'a') goto yy3;\n \t}\n-yy1424:\n-\tYYDEBUG(1424, *YYCURSOR);\n+yy1426:\n+\tYYDEBUG(1426, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych == 'Y') goto yy197;\n \tif (yych == 'y') goto yy197;\n \tgoto yy56;\n-yy1425:\n-\tYYDEBUG(1425, *YYCURSOR);\n+yy1427:\n+\tYYDEBUG(1427, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'D') {\n \t\tif (yych <= ')') {\n@@ -22010,8 +22118,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1426:\n-\tYYDEBUG(1426, *YYCURSOR);\n+yy1428:\n+\tYYDEBUG(1428, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '(') {\n@@ -22033,8 +22141,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1427:\n-\tYYDEBUG(1427, *YYCURSOR);\n+yy1429:\n+\tYYDEBUG(1429, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'T') {\n \t\tif (yych <= ')') {\n@@ -22050,13 +22158,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 't') goto yy1428;\n+\t\t\tif (yych <= 't') goto yy1430;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1428:\n-\tYYDEBUG(1428, *YYCURSOR);\n+yy1430:\n+\tYYDEBUG(1430, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'H') {\n \t\tif (yych <= ')') {\n@@ -22078,8 +22186,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1429:\n-\tYYDEBUG(1429, *YYCURSOR);\n+yy1431:\n+\tYYDEBUG(1431, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'M') {\n@@ -22094,7 +22202,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'N') goto yy1427;\n+\t\t\tif (yych <= 'N') goto yy1429;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22103,14 +22211,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'n') goto yy1459;\n+\t\t\t\tif (yych <= 'n') goto yy1461;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1430:\n-\tYYDEBUG(1430, *YYCURSOR);\n+yy1432:\n+\tYYDEBUG(1432, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'T') {\n@@ -22127,14 +22235,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '\/') goto yy172;\n \t\t\t\tgoto yy3;\n \t\t\t} else {\n-\t\t\t\tif (yych == 'I') goto yy1419;\n+\t\t\t\tif (yych == 'I') goto yy1421;\n \t\t\t\tgoto yy166;\n \t\t\t}\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n \t\t\tif (yych <= 'Z') {\n-\t\t\t\tif (yych <= 'U') goto yy1420;\n+\t\t\t\tif (yych <= 'U') goto yy1422;\n \t\t\t\tgoto yy166;\n \t\t\t} else {\n \t\t\t\tif (yych == '_') goto yy172;\n@@ -22142,17 +22250,17 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 't') {\n-\t\t\t\tif (yych == 'i') goto yy1451;\n+\t\t\t\tif (yych == 'i') goto yy1453;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'u') goto yy1452;\n+\t\t\t\tif (yych <= 'u') goto yy1454;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1431:\n-\tYYDEBUG(1431, *YYCURSOR);\n+yy1433:\n+\tYYDEBUG(1433, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'L') {\n@@ -22169,14 +22277,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '\/') goto yy172;\n \t\t\t\tgoto yy3;\n \t\t\t} else {\n-\t\t\t\tif (yych == 'D') goto yy1408;\n+\t\t\t\tif (yych == 'D') goto yy1410;\n \t\t\t\tgoto yy166;\n \t\t\t}\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n \t\t\tif (yych <= 'Z') {\n-\t\t\t\tif (yych <= 'M') goto yy1409;\n+\t\t\t\tif (yych <= 'M') goto yy1411;\n \t\t\t\tgoto yy166;\n \t\t\t} else {\n \t\t\t\tif (yych == '_') goto yy172;\n@@ -22184,17 +22292,17 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'l') {\n-\t\t\t\tif (yych == 'd') goto yy1442;\n+\t\t\t\tif (yych == 'd') goto yy1444;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'm') goto yy1443;\n+\t\t\t\tif (yych <= 'm') goto yy1445;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1432:\n-\tYYDEBUG(1432, *YYCURSOR);\n+yy1434:\n+\tYYDEBUG(1434, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'D') {\n@@ -22209,7 +22317,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'E') goto yy1404;\n+\t\t\tif (yych <= 'E') goto yy1406;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22218,14 +22326,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'e') goto yy1438;\n+\t\t\t\tif (yych <= 'e') goto yy1440;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1433:\n-\tYYDEBUG(1433, *YYCURSOR);\n+yy1435:\n+\tYYDEBUG(1435, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'D') {\n@@ -22240,7 +22348,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'E') goto yy1400;\n+\t\t\tif (yych <= 'E') goto yy1402;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22249,14 +22357,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'e') goto yy1434;\n+\t\t\t\tif (yych <= 'e') goto yy1436;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1434:\n-\tYYDEBUG(1434, *YYCURSOR);\n+yy1436:\n+\tYYDEBUG(1436, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'K') {\n@@ -22271,7 +22379,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'L') goto yy1401;\n+\t\t\tif (yych <= 'L') goto yy1403;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22280,14 +22388,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'l') goto yy1435;\n+\t\t\t\tif (yych <= 'l') goto yy1437;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1435:\n-\tYYDEBUG(1435, *YYCURSOR);\n+yy1437:\n+\tYYDEBUG(1437, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'E') {\n@@ -22302,7 +22410,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'F') goto yy1402;\n+\t\t\tif (yych <= 'F') goto yy1404;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22311,14 +22419,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'f') goto yy1436;\n+\t\t\t\tif (yych <= 'f') goto yy1438;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1436:\n-\tYYDEBUG(1436, *YYCURSOR);\n+yy1438:\n+\tYYDEBUG(1438, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'S') {\n@@ -22333,7 +22441,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'T') goto yy1403;\n+\t\t\tif (yych <= 'T') goto yy1405;\n \t\t\tif (yych <= 'Z') goto yy169;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22342,14 +22450,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy177;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 't') goto yy1437;\n+\t\t\t\tif (yych <= 't') goto yy1439;\n \t\t\t\tif (yych <= 'z') goto yy177;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1437:\n-\tYYDEBUG(1437, *YYCURSOR);\n+yy1439:\n+\tYYDEBUG(1439, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'G') {\n@@ -22372,8 +22480,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1438:\n-\tYYDEBUG(1438, *YYCURSOR);\n+yy1440:\n+\tYYDEBUG(1440, *YYCURSOR);\n \tyyaccept = 4;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'R') {\n@@ -22388,7 +22496,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'S') goto yy1405;\n+\t\t\tif (yych <= 'S') goto yy1407;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy191;\n \t\t\tgoto yy172;\n@@ -22397,14 +22505,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy191;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 's') goto yy1439;\n+\t\t\t\tif (yych <= 's') goto yy1441;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy191;\n \t\t\t}\n \t\t}\n \t}\n-yy1439:\n-\tYYDEBUG(1439, *YYCURSOR);\n+yy1441:\n+\tYYDEBUG(1441, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'C') {\n@@ -22419,7 +22527,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'D') goto yy1406;\n+\t\t\tif (yych <= 'D') goto yy1408;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22428,14 +22536,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'd') goto yy1440;\n+\t\t\t\tif (yych <= 'd') goto yy1442;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1440:\n-\tYYDEBUG(1440, *YYCURSOR);\n+yy1442:\n+\tYYDEBUG(1442, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '@') {\n@@ -22449,19 +22557,19 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'A') goto yy1407;\n+\t\t\tif (yych <= 'A') goto yy1409;\n \t\t\tif (yych <= 'Z') goto yy169;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n \t\t} else {\n \t\t\tif (yych <= '`') goto yy3;\n-\t\t\tif (yych <= 'a') goto yy1441;\n+\t\t\tif (yych <= 'a') goto yy1443;\n \t\t\tif (yych <= 'z') goto yy177;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1441:\n-\tYYDEBUG(1441, *YYCURSOR);\n+yy1443:\n+\tYYDEBUG(1443, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'X') {\n@@ -22484,8 +22592,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1442:\n-\tYYDEBUG(1442, *YYCURSOR);\n+yy1444:\n+\tYYDEBUG(1444, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '@') {\n@@ -22499,19 +22607,19 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'A') goto yy1416;\n+\t\t\tif (yych <= 'A') goto yy1418;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n \t\t} else {\n \t\t\tif (yych <= '`') goto yy3;\n-\t\t\tif (yych <= 'a') goto yy1449;\n+\t\t\tif (yych <= 'a') goto yy1451;\n \t\t\tif (yych <= 'z') goto yy175;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1443:\n-\tYYDEBUG(1443, *YYCURSOR);\n+yy1445:\n+\tYYDEBUG(1445, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'N') {\n@@ -22526,7 +22634,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'O') goto yy1410;\n+\t\t\tif (yych <= 'O') goto yy1412;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22535,14 +22643,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'o') goto yy1444;\n+\t\t\t\tif (yych <= 'o') goto yy1446;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1444:\n-\tYYDEBUG(1444, *YYCURSOR);\n+yy1446:\n+\tYYDEBUG(1446, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'Q') {\n@@ -22557,7 +22665,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'R') goto yy1411;\n+\t\t\tif (yych <= 'R') goto yy1413;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22566,14 +22674,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'r') goto yy1445;\n+\t\t\t\tif (yych <= 'r') goto yy1447;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1445:\n-\tYYDEBUG(1445, *YYCURSOR);\n+yy1447:\n+\tYYDEBUG(1447, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'Q') {\n@@ -22588,7 +22696,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'R') goto yy1412;\n+\t\t\tif (yych <= 'R') goto yy1414;\n \t\t\tif (yych <= 'Z') goto yy169;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22597,14 +22705,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy177;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'r') goto yy1446;\n+\t\t\t\tif (yych <= 'r') goto yy1448;\n \t\t\t\tif (yych <= 'z') goto yy177;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1446:\n-\tYYDEBUG(1446, *YYCURSOR);\n+yy1448:\n+\tYYDEBUG(1448, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'N') {\n@@ -22618,21 +22726,21 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n-\t\t\tif (yych <= 'O') goto yy1413;\n+\t\t\tif (yych <= 'O') goto yy1415;\n \t\t\tif (yych == '_') goto yy172;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych == 'o') goto yy1447;\n+\t\t\tif (yych == 'o') goto yy1449;\n \t\t\tif (yych <= 'z') goto yy178;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1447:\n-\tYYDEBUG(1447, *YYCURSOR);\n+yy1449:\n+\tYYDEBUG(1449, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'W') goto yy1414;\n+\tif (yych == 'W') goto yy1416;\n \tif (yych != 'w') goto yy179;\n-\tYYDEBUG(1448, *YYCURSOR);\n+\tYYDEBUG(1450, *YYCURSOR);\n \tyyaccept = 29;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yybm[0+yych] & 16) {\n@@ -22640,14 +22748,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t}\n \tif (yych <= '.') {\n \t\tif (yych == '-') goto yy172;\n-\t\tgoto yy1415;\n+\t\tgoto yy1417;\n \t} else {\n \t\tif (yych <= '\/') goto yy172;\n \t\tif (yych == '_') goto yy172;\n-\t\tgoto yy1415;\n+\t\tgoto yy1417;\n \t}\n-yy1449:\n-\tYYDEBUG(1449, *YYCURSOR);\n+yy1451:\n+\tYYDEBUG(1451, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'X') {\n@@ -22662,7 +22770,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'Y') goto yy1417;\n+\t\t\tif (yych <= 'Y') goto yy1419;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22671,38 +22779,38 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'y') goto yy1450;\n+\t\t\t\tif (yych <= 'y') goto yy1452;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1450:\n-\tYYDEBUG(1450, *YYCURSOR);\n+yy1452:\n+\tYYDEBUG(1452, *YYCURSOR);\n \tyyaccept = 30;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '\/') {\n \t\tif (yych <= ',') {\n \t\t\tif (yych == ')') goto yy164;\n-\t\t\tgoto yy1418;\n+\t\t\tgoto yy1420;\n \t\t} else {\n-\t\t\tif (yych == '.') goto yy1418;\n+\t\t\tif (yych == '.') goto yy1420;\n \t\t\tgoto yy172;\n \t\t}\n \t} else {\n \t\tif (yych <= '^') {\n-\t\t\tif (yych <= '@') goto yy1418;\n+\t\t\tif (yych <= '@') goto yy1420;\n \t\t\tif (yych <= 'Z') goto yy169;\n-\t\t\tgoto yy1418;\n+\t\t\tgoto yy1420;\n \t\t} else {\n \t\t\tif (yych <= '_') goto yy172;\n-\t\t\tif (yych <= '`') goto yy1418;\n+\t\t\tif (yych <= '`') goto yy1420;\n \t\t\tif (yych <= 'z') goto yy177;\n-\t\t\tgoto yy1418;\n+\t\t\tgoto yy1420;\n \t\t}\n \t}\n-yy1451:\n-\tYYDEBUG(1451, *YYCURSOR);\n+yy1453:\n+\tYYDEBUG(1453, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'R') {\n@@ -22717,13 +22825,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t} else {\n \t\t\t\tif (yych <= '@') goto yy3;\n \t\t\t\tif (yych <= 'Q') goto yy167;\n-\t\t\t\tgoto yy1425;\n+\t\t\t\tgoto yy1427;\n \t\t\t}\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n \t\t\tif (yych <= 'Z') {\n-\t\t\t\tif (yych <= 'S') goto yy1426;\n+\t\t\t\tif (yych <= 'S') goto yy1428;\n \t\t\t\tgoto yy167;\n \t\t\t} else {\n \t\t\t\tif (yych == '_') goto yy172;\n@@ -22732,16 +22840,16 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= 'r') {\n \t\t\t\tif (yych <= 'q') goto yy175;\n-\t\t\t\tgoto yy1457;\n+\t\t\t\tgoto yy1459;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 's') goto yy1458;\n+\t\t\t\tif (yych <= 's') goto yy1460;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1452:\n-\tYYDEBUG(1452, *YYCURSOR);\n+yy1454:\n+\tYYDEBUG(1454, *YYCURSOR);\n \tyyaccept = 4;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'Q') {\n@@ -22756,7 +22864,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'R') goto yy1421;\n+\t\t\tif (yych <= 'R') goto yy1423;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy191;\n \t\t\tgoto yy172;\n@@ -22765,14 +22873,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy191;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'r') goto yy1453;\n+\t\t\t\tif (yych <= 'r') goto yy1455;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy191;\n \t\t\t}\n \t\t}\n \t}\n-yy1453:\n-\tYYDEBUG(1453, *YYCURSOR);\n+yy1455:\n+\tYYDEBUG(1455, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'R') {\n@@ -22787,7 +22895,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'S') goto yy1422;\n+\t\t\tif (yych <= 'S') goto yy1424;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22796,14 +22904,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 's') goto yy1454;\n+\t\t\t\tif (yych <= 's') goto yy1456;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1454:\n-\tYYDEBUG(1454, *YYCURSOR);\n+yy1456:\n+\tYYDEBUG(1456, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'C') {\n@@ -22818,7 +22926,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'D') goto yy1423;\n+\t\t\tif (yych <= 'D') goto yy1425;\n \t\t\tif (yych <= 'Z') goto yy169;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22827,14 +22935,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy177;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'd') goto yy1455;\n+\t\t\t\tif (yych <= 'd') goto yy1457;\n \t\t\t\tif (yych <= 'z') goto yy177;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1455:\n-\tYYDEBUG(1455, *YYCURSOR);\n+yy1457:\n+\tYYDEBUG(1457, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '@') {\n@@ -22848,24 +22956,24 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'A') goto yy1424;\n+\t\t\tif (yych <= 'A') goto yy1426;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n \t\t} else {\n \t\t\tif (yych <= '`') goto yy3;\n-\t\t\tif (yych <= 'a') goto yy1456;\n+\t\t\tif (yych <= 'a') goto yy1458;\n \t\t\tif (yych <= 'z') goto yy178;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1456:\n-\tYYDEBUG(1456, *YYCURSOR);\n+yy1458:\n+\tYYDEBUG(1458, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych == 'Y') goto yy197;\n \tif (yych == 'y') goto yy210;\n \tgoto yy179;\n-yy1457:\n-\tYYDEBUG(1457, *YYCURSOR);\n+yy1459:\n+\tYYDEBUG(1459, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'C') {\n@@ -22895,8 +23003,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1458:\n-\tYYDEBUG(1458, *YYCURSOR);\n+yy1460:\n+\tYYDEBUG(1460, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '-') {\n@@ -22925,8 +23033,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1459:\n-\tYYDEBUG(1459, *YYCURSOR);\n+yy1461:\n+\tYYDEBUG(1461, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'S') {\n@@ -22941,7 +23049,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'T') goto yy1428;\n+\t\t\tif (yych <= 'T') goto yy1430;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -22950,14 +23058,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 't') goto yy1460;\n+\t\t\t\tif (yych <= 't') goto yy1462;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1460:\n-\tYYDEBUG(1460, *YYCURSOR);\n+yy1462:\n+\tYYDEBUG(1462, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'G') {\n@@ -22987,32 +23095,32 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1461:\n-\tYYDEBUG(1461, *YYCURSOR);\n+yy1463:\n+\tYYDEBUG(1463, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'Y') {\n \t\tif (yych <= '@') {\n \t\t\tif (yych == ')') goto yy164;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych == 'R') goto yy1473;\n+\t\t\tif (yych == 'R') goto yy1475;\n \t\t\tif (yych <= 'X') goto yy166;\n-\t\t\tgoto yy1474;\n+\t\t\tgoto yy1476;\n \t\t}\n \t} else {\n \t\tif (yych <= 'r') {\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tif (yych <= 'q') goto yy166;\n-\t\t\tgoto yy1473;\n+\t\t\tgoto yy1475;\n \t\t} else {\n-\t\t\tif (yych == 'y') goto yy1474;\n+\t\t\tif (yych == 'y') goto yy1476;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1462:\n-\tYYDEBUG(1462, *YYCURSOR);\n+yy1464:\n+\tYYDEBUG(1464, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'D') {\n \t\tif (yych <= ')') {\n@@ -23021,7 +23129,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'C') goto yy166;\n-\t\t\tgoto yy1467;\n+\t\t\tgoto yy1469;\n \t\t}\n \t} else {\n \t\tif (yych <= 'c') {\n@@ -23029,13 +23137,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 'd') goto yy1467;\n+\t\t\tif (yych <= 'd') goto yy1469;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1463:\n-\tYYDEBUG(1463, *YYCURSOR);\n+yy1465:\n+\tYYDEBUG(1465, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'N') {\n \t\tif (yych <= ')') {\n@@ -23051,13 +23159,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 'n') goto yy1464;\n+\t\t\tif (yych <= 'n') goto yy1466;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1464:\n-\tYYDEBUG(1464, *YYCURSOR);\n+yy1466:\n+\tYYDEBUG(1466, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'D') {\n \t\tif (yych <= ')') {\n@@ -23073,13 +23181,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy191;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 'd') goto yy1465;\n+\t\t\tif (yych <= 'd') goto yy1467;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy191;\n \t\t}\n \t}\n-yy1465:\n-\tYYDEBUG(1465, *YYCURSOR);\n+yy1467:\n+\tYYDEBUG(1467, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'A') {\n \t\tif (yych == ')') goto yy164;\n@@ -23089,13 +23197,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych <= 'a') goto yy1466;\n+\t\t\tif (yych <= 'a') goto yy1468;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1466:\n-\tYYDEBUG(1466, *YYCURSOR);\n+yy1468:\n+\tYYDEBUG(1468, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'Y') {\n \t\tif (yych <= ')') {\n@@ -23117,8 +23225,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1467:\n-\tYYDEBUG(1467, *YYCURSOR);\n+yy1469:\n+\tYYDEBUG(1469, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'N') {\n \t\tif (yych <= ')') {\n@@ -23134,13 +23242,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 'n') goto yy1468;\n+\t\t\tif (yych <= 'n') goto yy1470;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1468:\n-\tYYDEBUG(1468, *YYCURSOR);\n+yy1470:\n+\tYYDEBUG(1470, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'I') {\n \t\tif (yych <= ')') {\n@@ -23156,13 +23264,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 'i') goto yy1469;\n+\t\t\tif (yych <= 'i') goto yy1471;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1469:\n-\tYYDEBUG(1469, *YYCURSOR);\n+yy1471:\n+\tYYDEBUG(1471, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'G') {\n \t\tif (yych <= ')') {\n@@ -23178,33 +23286,33 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy169;\n \t\t} else {\n-\t\t\tif (yych <= 'g') goto yy1470;\n+\t\t\tif (yych <= 'g') goto yy1472;\n \t\t\tif (yych <= 'z') goto yy169;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1470:\n-\tYYDEBUG(1470, *YYCURSOR);\n+yy1472:\n+\tYYDEBUG(1472, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'G') {\n \t\tif (yych == ')') goto yy164;\n \t\tgoto yy3;\n \t} else {\n-\t\tif (yych <= 'H') goto yy1471;\n+\t\tif (yych <= 'H') goto yy1473;\n \t\tif (yych != 'h') goto yy3;\n \t}\n-yy1471:\n-\tYYDEBUG(1471, *YYCURSOR);\n+yy1473:\n+\tYYDEBUG(1473, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'T') goto yy1472;\n+\tif (yych == 'T') goto yy1474;\n \tif (yych != 't') goto yy56;\n-yy1472:\n-\tYYDEBUG(1472, *YYCURSOR);\n+yy1474:\n+\tYYDEBUG(1474, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tgoto yy1418;\n-yy1473:\n-\tYYDEBUG(1473, *YYCURSOR);\n+\tgoto yy1420;\n+yy1475:\n+\tYYDEBUG(1475, *YYCURSOR);\n \tyyaccept = 5;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '\/') {\n@@ -23232,7 +23340,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '9') goto yy220;\n \t\t\t\tgoto yy218;\n \t\t\t} else {\n-\t\t\t\tif (yych == 'C') goto yy1475;\n+\t\t\t\tif (yych == 'C') goto yy1477;\n \t\t\t\tgoto yy167;\n \t\t\t}\n \t\t} else {\n@@ -23240,14 +23348,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy218;\n \t\t\t\tgoto yy167;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'c') goto yy1475;\n+\t\t\t\tif (yych <= 'c') goto yy1477;\n \t\t\t\tif (yych <= 'z') goto yy167;\n \t\t\t\tgoto yy218;\n \t\t\t}\n \t\t}\n \t}\n-yy1474:\n-\tYYDEBUG(1474, *YYCURSOR);\n+yy1476:\n+\tYYDEBUG(1476, *YYCURSOR);\n \tyyaccept = 5;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '-') {\n@@ -23272,8 +23380,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy218;\n \t\t}\n \t}\n-yy1475:\n-\tYYDEBUG(1475, *YYCURSOR);\n+yy1477:\n+\tYYDEBUG(1477, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'H') {\n \t\tif (yych <= ')') {\n@@ -23295,8 +23403,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1476:\n-\tYYDEBUG(1476, *YYCURSOR);\n+yy1478:\n+\tYYDEBUG(1478, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'X') {\n@@ -23313,14 +23421,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '\/') goto yy172;\n \t\t\t\tgoto yy3;\n \t\t\t} else {\n-\t\t\t\tif (yych == 'R') goto yy1473;\n+\t\t\t\tif (yych == 'R') goto yy1475;\n \t\t\t\tgoto yy166;\n \t\t\t}\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n \t\t\tif (yych <= 'Z') {\n-\t\t\t\tif (yych <= 'Y') goto yy1474;\n+\t\t\t\tif (yych <= 'Y') goto yy1476;\n \t\t\t\tgoto yy166;\n \t\t\t} else {\n \t\t\t\tif (yych == '_') goto yy172;\n@@ -23328,17 +23436,17 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'x') {\n-\t\t\t\tif (yych == 'r') goto yy1488;\n+\t\t\t\tif (yych == 'r') goto yy1490;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'y') goto yy1489;\n+\t\t\t\tif (yych <= 'y') goto yy1491;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1477:\n-\tYYDEBUG(1477, *YYCURSOR);\n+yy1479:\n+\tYYDEBUG(1479, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'C') {\n@@ -23353,7 +23461,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'D') goto yy1467;\n+\t\t\tif (yych <= 'D') goto yy1469;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -23362,14 +23470,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'd') goto yy1482;\n+\t\t\t\tif (yych <= 'd') goto yy1484;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1478:\n-\tYYDEBUG(1478, *YYCURSOR);\n+yy1480:\n+\tYYDEBUG(1480, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'M') {\n@@ -23384,7 +23492,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'N') goto yy1464;\n+\t\t\tif (yych <= 'N') goto yy1466;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -23393,14 +23501,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'n') goto yy1479;\n+\t\t\t\tif (yych <= 'n') goto yy1481;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1479:\n-\tYYDEBUG(1479, *YYCURSOR);\n+yy1481:\n+\tYYDEBUG(1481, *YYCURSOR);\n \tyyaccept = 4;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'C') {\n@@ -23415,7 +23523,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'D') goto yy1465;\n+\t\t\tif (yych <= 'D') goto yy1467;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy191;\n \t\t\tgoto yy172;\n@@ -23424,14 +23532,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy191;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'd') goto yy1480;\n+\t\t\t\tif (yych <= 'd') goto yy1482;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy191;\n \t\t\t}\n \t\t}\n \t}\n-yy1480:\n-\tYYDEBUG(1480, *YYCURSOR);\n+yy1482:\n+\tYYDEBUG(1482, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '@') {\n@@ -23445,19 +23553,19 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'A') goto yy1466;\n+\t\t\tif (yych <= 'A') goto yy1468;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n \t\t} else {\n \t\t\tif (yych <= '`') goto yy3;\n-\t\t\tif (yych <= 'a') goto yy1481;\n+\t\t\tif (yych <= 'a') goto yy1483;\n \t\t\tif (yych <= 'z') goto yy176;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1481:\n-\tYYDEBUG(1481, *YYCURSOR);\n+yy1483:\n+\tYYDEBUG(1483, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'X') {\n@@ -23487,8 +23595,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1482:\n-\tYYDEBUG(1482, *YYCURSOR);\n+yy1484:\n+\tYYDEBUG(1484, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'M') {\n@@ -23503,7 +23611,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'N') goto yy1468;\n+\t\t\tif (yych <= 'N') goto yy1470;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -23512,14 +23620,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'n') goto yy1483;\n+\t\t\t\tif (yych <= 'n') goto yy1485;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1483:\n-\tYYDEBUG(1483, *YYCURSOR);\n+yy1485:\n+\tYYDEBUG(1485, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'H') {\n@@ -23534,7 +23642,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'I') goto yy1469;\n+\t\t\tif (yych <= 'I') goto yy1471;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -23543,14 +23651,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'i') goto yy1484;\n+\t\t\t\tif (yych <= 'i') goto yy1486;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1484:\n-\tYYDEBUG(1484, *YYCURSOR);\n+yy1486:\n+\tYYDEBUG(1486, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'F') {\n@@ -23565,7 +23673,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'G') goto yy1470;\n+\t\t\tif (yych <= 'G') goto yy1472;\n \t\t\tif (yych <= 'Z') goto yy169;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -23574,14 +23682,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy177;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'g') goto yy1485;\n+\t\t\t\tif (yych <= 'g') goto yy1487;\n \t\t\t\tif (yych <= 'z') goto yy177;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1485:\n-\tYYDEBUG(1485, *YYCURSOR);\n+yy1487:\n+\tYYDEBUG(1487, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'G') {\n@@ -23595,21 +23703,21 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n-\t\t\tif (yych <= 'H') goto yy1471;\n+\t\t\tif (yych <= 'H') goto yy1473;\n \t\t\tif (yych == '_') goto yy172;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych == 'h') goto yy1486;\n+\t\t\tif (yych == 'h') goto yy1488;\n \t\t\tif (yych <= 'z') goto yy178;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1486:\n-\tYYDEBUG(1486, *YYCURSOR);\n+yy1488:\n+\tYYDEBUG(1488, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'T') goto yy1472;\n+\tif (yych == 'T') goto yy1474;\n \tif (yych != 't') goto yy179;\n-\tYYDEBUG(1487, *YYCURSOR);\n+\tYYDEBUG(1489, *YYCURSOR);\n \tyyaccept = 30;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yybm[0+yych] & 16) {\n@@ -23617,14 +23725,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t}\n \tif (yych <= '.') {\n \t\tif (yych == '-') goto yy172;\n-\t\tgoto yy1418;\n+\t\tgoto yy1420;\n \t} else {\n \t\tif (yych <= '\/') goto yy172;\n \t\tif (yych == '_') goto yy172;\n-\t\tgoto yy1418;\n+\t\tgoto yy1420;\n \t}\n-yy1488:\n-\tYYDEBUG(1488, *YYCURSOR);\n+yy1490:\n+\tYYDEBUG(1490, *YYCURSOR);\n \tyyaccept = 5;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '9') {\n@@ -23652,7 +23760,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '@') goto yy218;\n \t\t\t\tgoto yy167;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'C') goto yy1475;\n+\t\t\t\tif (yych <= 'C') goto yy1477;\n \t\t\t\tif (yych <= 'Z') goto yy167;\n \t\t\t\tgoto yy218;\n \t\t\t}\n@@ -23662,14 +23770,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy218;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'c') goto yy1490;\n+\t\t\t\tif (yych <= 'c') goto yy1492;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy218;\n \t\t\t}\n \t\t}\n \t}\n-yy1489:\n-\tYYDEBUG(1489, *YYCURSOR);\n+yy1491:\n+\tYYDEBUG(1491, *YYCURSOR);\n \tyyaccept = 5;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '.') {\n@@ -23704,8 +23812,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1490:\n-\tYYDEBUG(1490, *YYCURSOR);\n+yy1492:\n+\tYYDEBUG(1492, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'G') {\n@@ -23735,8 +23843,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1491:\n-\tYYDEBUG(1491, *YYCURSOR);\n+yy1493:\n+\tYYDEBUG(1493, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'W') {\n \t\tif (yych <= 'N') {\n@@ -23744,30 +23852,30 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 'O') goto yy1499;\n+\t\t\tif (yych <= 'O') goto yy1501;\n \t\t\tif (yych <= 'U') goto yy166;\n-\t\t\tif (yych <= 'V') goto yy1500;\n-\t\t\tgoto yy1497;\n+\t\t\tif (yych <= 'V') goto yy1502;\n+\t\t\tgoto yy1499;\n \t\t}\n \t} else {\n \t\tif (yych <= 'o') {\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tif (yych <= 'n') goto yy166;\n-\t\t\tgoto yy1499;\n+\t\t\tgoto yy1501;\n \t\t} else {\n \t\t\tif (yych <= 'v') {\n \t\t\t\tif (yych <= 'u') goto yy166;\n-\t\t\t\tgoto yy1500;\n+\t\t\t\tgoto yy1502;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'w') goto yy1497;\n+\t\t\t\tif (yych <= 'w') goto yy1499;\n \t\t\t\tif (yych <= 'z') goto yy166;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1492:\n-\tYYDEBUG(1492, *YYCURSOR);\n+yy1494:\n+\tYYDEBUG(1494, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'X') {\n \t\tif (yych <= ')') {\n@@ -23776,7 +23884,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'W') goto yy166;\n-\t\t\tgoto yy1496;\n+\t\t\tgoto yy1498;\n \t\t}\n \t} else {\n \t\tif (yych <= 'w') {\n@@ -23784,13 +23892,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 'x') goto yy1496;\n+\t\t\tif (yych <= 'x') goto yy1498;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1493:\n-\tYYDEBUG(1493, *YYCURSOR);\n+yy1495:\n+\tYYDEBUG(1495, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'N') {\n \t\tif (yych <= ')') {\n@@ -23806,13 +23914,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 'n') goto yy1494;\n+\t\t\tif (yych <= 'n') goto yy1496;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1494:\n-\tYYDEBUG(1494, *YYCURSOR);\n+yy1496:\n+\tYYDEBUG(1496, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'T') {\n \t\tif (yych <= ')') {\n@@ -23828,13 +23936,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 't') goto yy1495;\n+\t\t\tif (yych <= 't') goto yy1497;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1495:\n-\tYYDEBUG(1495, *YYCURSOR);\n+yy1497:\n+\tYYDEBUG(1497, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'H') {\n \t\tif (yych <= ')') {\n@@ -23856,8 +23964,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1496:\n-\tYYDEBUG(1496, *YYCURSOR);\n+yy1498:\n+\tYYDEBUG(1498, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'T') {\n \t\tif (yych <= ')') {\n@@ -23866,7 +23974,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'S') goto yy167;\n-\t\t\tgoto yy1426;\n+\t\t\tgoto yy1428;\n \t\t}\n \t} else {\n \t\tif (yych <= 's') {\n@@ -23874,23 +23982,23 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 't') goto yy1426;\n+\t\t\tif (yych <= 't') goto yy1428;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1497:\n-\tYYDEBUG(1497, *YYCURSOR);\n+yy1499:\n+\tYYDEBUG(1499, *YYCURSOR);\n \t++YYCURSOR;\n \tif ((yych = *YYCURSOR) <= '@') {\n \t\tif (yych == ')') goto yy164;\n \t} else {\n \t\tif (yych <= 'Z') goto yy167;\n-\t\tif (yych <= '`') goto yy1498;\n+\t\tif (yych <= '`') goto yy1500;\n \t\tif (yych <= 'z') goto yy167;\n \t}\n-yy1498:\n-\tYYDEBUG(1498, *YYCURSOR);\n+yy1500:\n+\tYYDEBUG(1500, *YYCURSOR);\n #line 982 \"ext\/date\/lib\/parse_date.re\"\n \t{\n \t\tDEBUG_OUTPUT(\"now\");\n@@ -23899,9 +24007,9 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tTIMELIB_DEINIT;\n \t\treturn TIMELIB_RELATIVE;\n \t}\n-#line 23903 \"<stdout>\"\n-yy1499:\n-\tYYDEBUG(1499, *YYCURSOR);\n+#line 24011 \"<stdout>\"\n+yy1501:\n+\tYYDEBUG(1501, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'N') {\n \t\tif (yych <= ')') {\n@@ -23910,7 +24018,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t} else {\n \t\t\tif (yych <= '@') goto yy3;\n \t\t\tif (yych <= 'M') goto yy167;\n-\t\t\tgoto yy1505;\n+\t\t\tgoto yy1507;\n \t\t}\n \t} else {\n \t\tif (yych <= 'm') {\n@@ -23918,13 +24026,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 'n') goto yy1505;\n+\t\t\tif (yych <= 'n') goto yy1507;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1500:\n-\tYYDEBUG(1500, *YYCURSOR);\n+yy1502:\n+\tYYDEBUG(1502, *YYCURSOR);\n \tyyaccept = 5;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '\/') {\n@@ -23959,14 +24067,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy218;\n \t\t\t\tgoto yy167;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'e') goto yy1501;\n+\t\t\t\tif (yych <= 'e') goto yy1503;\n \t\t\t\tif (yych <= 'z') goto yy167;\n \t\t\t\tgoto yy218;\n \t\t\t}\n \t\t}\n \t}\n-yy1501:\n-\tYYDEBUG(1501, *YYCURSOR);\n+yy1503:\n+\tYYDEBUG(1503, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'M') {\n \t\tif (yych <= ')') {\n@@ -23982,13 +24090,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 'm') goto yy1502;\n+\t\t\tif (yych <= 'm') goto yy1504;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1502:\n-\tYYDEBUG(1502, *YYCURSOR);\n+yy1504:\n+\tYYDEBUG(1504, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'B') {\n \t\tif (yych <= ')') {\n@@ -24004,40 +24112,40 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy169;\n \t\t} else {\n-\t\t\tif (yych <= 'b') goto yy1503;\n+\t\t\tif (yych <= 'b') goto yy1505;\n \t\t\tif (yych <= 'z') goto yy169;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1503:\n-\tYYDEBUG(1503, *YYCURSOR);\n+yy1505:\n+\tYYDEBUG(1505, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'D') {\n \t\tif (yych == ')') goto yy164;\n \t\tgoto yy3;\n \t} else {\n-\t\tif (yych <= 'E') goto yy1504;\n+\t\tif (yych <= 'E') goto yy1506;\n \t\tif (yych != 'e') goto yy3;\n \t}\n-yy1504:\n-\tYYDEBUG(1504, *YYCURSOR);\n+yy1506:\n+\tYYDEBUG(1506, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych == 'R') goto yy229;\n \tif (yych == 'r') goto yy229;\n \tgoto yy56;\n-yy1505:\n-\tYYDEBUG(1505, *YYCURSOR);\n+yy1507:\n+\tYYDEBUG(1507, *YYCURSOR);\n \t++YYCURSOR;\n \tif ((yych = *YYCURSOR) <= '@') {\n \t\tif (yych == ')') goto yy164;\n \t} else {\n \t\tif (yych <= 'Z') goto yy168;\n-\t\tif (yych <= '`') goto yy1506;\n+\t\tif (yych <= '`') goto yy1508;\n \t\tif (yych <= 'z') goto yy168;\n \t}\n-yy1506:\n-\tYYDEBUG(1506, *YYCURSOR);\n+yy1508:\n+\tYYDEBUG(1508, *YYCURSOR);\n #line 991 \"ext\/date\/lib\/parse_date.re\"\n \t{\n \t\tDEBUG_OUTPUT(\"noon\");\n@@ -24049,9 +24157,9 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tTIMELIB_DEINIT;\n \t\treturn TIMELIB_RELATIVE;\n \t}\n-#line 24053 \"<stdout>\"\n-yy1507:\n-\tYYDEBUG(1507, *YYCURSOR);\n+#line 24161 \"<stdout>\"\n+yy1509:\n+\tYYDEBUG(1509, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'V') {\n@@ -24069,15 +24177,15 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '@') goto yy3;\n \t\t\t\tgoto yy166;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'O') goto yy1499;\n+\t\t\t\tif (yych <= 'O') goto yy1501;\n \t\t\t\tif (yych <= 'U') goto yy166;\n-\t\t\t\tgoto yy1500;\n+\t\t\t\tgoto yy1502;\n \t\t\t}\n \t\t}\n \t} else {\n \t\tif (yych <= 'n') {\n \t\t\tif (yych <= '^') {\n-\t\t\t\tif (yych <= 'W') goto yy1497;\n+\t\t\t\tif (yych <= 'W') goto yy1499;\n \t\t\t\tif (yych <= 'Z') goto yy166;\n \t\t\t\tgoto yy3;\n \t\t\t} else {\n@@ -24087,18 +24195,18 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t} else {\n \t\t\tif (yych <= 'v') {\n-\t\t\t\tif (yych <= 'o') goto yy1514;\n+\t\t\t\tif (yych <= 'o') goto yy1516;\n \t\t\t\tif (yych <= 'u') goto yy171;\n-\t\t\t\tgoto yy1515;\n+\t\t\t\tgoto yy1517;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'w') goto yy1513;\n+\t\t\t\tif (yych <= 'w') goto yy1515;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1508:\n-\tYYDEBUG(1508, *YYCURSOR);\n+yy1510:\n+\tYYDEBUG(1510, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'W') {\n@@ -24113,7 +24221,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'X') goto yy1496;\n+\t\t\tif (yych <= 'X') goto yy1498;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24122,14 +24230,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'x') goto yy1512;\n+\t\t\t\tif (yych <= 'x') goto yy1514;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1509:\n-\tYYDEBUG(1509, *YYCURSOR);\n+yy1511:\n+\tYYDEBUG(1511, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'M') {\n@@ -24144,7 +24252,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'N') goto yy1494;\n+\t\t\tif (yych <= 'N') goto yy1496;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24153,14 +24261,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'n') goto yy1510;\n+\t\t\t\tif (yych <= 'n') goto yy1512;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1510:\n-\tYYDEBUG(1510, *YYCURSOR);\n+yy1512:\n+\tYYDEBUG(1512, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'S') {\n@@ -24175,7 +24283,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'T') goto yy1495;\n+\t\t\tif (yych <= 'T') goto yy1497;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24184,14 +24292,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 't') goto yy1511;\n+\t\t\t\tif (yych <= 't') goto yy1513;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1511:\n-\tYYDEBUG(1511, *YYCURSOR);\n+yy1513:\n+\tYYDEBUG(1513, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'G') {\n@@ -24221,8 +24329,8 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t}\n \t\t}\n \t}\n-yy1512:\n-\tYYDEBUG(1512, *YYCURSOR);\n+yy1514:\n+\tYYDEBUG(1514, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'S') {\n@@ -24237,7 +24345,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'T') goto yy1426;\n+\t\t\tif (yych <= 'T') goto yy1428;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24246,38 +24354,38 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 't') goto yy1458;\n+\t\t\t\tif (yych <= 't') goto yy1460;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1513:\n-\tYYDEBUG(1513, *YYCURSOR);\n+yy1515:\n+\tYYDEBUG(1515, *YYCURSOR);\n \tyyaccept = 31;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '\/') {\n \t\tif (yych <= ',') {\n \t\t\tif (yych == ')') goto yy164;\n-\t\t\tgoto yy1498;\n+\t\t\tgoto yy1500;\n \t\t} else {\n-\t\t\tif (yych == '.') goto yy1498;\n+\t\t\tif (yych == '.') goto yy1500;\n \t\t\tgoto yy172;\n \t\t}\n \t} else {\n \t\tif (yych <= '^') {\n-\t\t\tif (yych <= '@') goto yy1498;\n+\t\t\tif (yych <= '@') goto yy1500;\n \t\t\tif (yych <= 'Z') goto yy167;\n-\t\t\tgoto yy1498;\n+\t\t\tgoto yy1500;\n \t\t} else {\n \t\t\tif (yych <= '_') goto yy172;\n-\t\t\tif (yych <= '`') goto yy1498;\n+\t\t\tif (yych <= '`') goto yy1500;\n \t\t\tif (yych <= 'z') goto yy175;\n-\t\t\tgoto yy1498;\n+\t\t\tgoto yy1500;\n \t\t}\n \t}\n-yy1514:\n-\tYYDEBUG(1514, *YYCURSOR);\n+yy1516:\n+\tYYDEBUG(1516, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'M') {\n@@ -24292,7 +24400,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'N') goto yy1505;\n+\t\t\tif (yych <= 'N') goto yy1507;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24301,14 +24409,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'n') goto yy1520;\n+\t\t\t\tif (yych <= 'n') goto yy1522;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1515:\n-\tYYDEBUG(1515, *YYCURSOR);\n+yy1517:\n+\tYYDEBUG(1517, *YYCURSOR);\n \tyyaccept = 5;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '9') {\n@@ -24336,7 +24444,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '@') goto yy218;\n \t\t\t\tgoto yy167;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'E') goto yy1501;\n+\t\t\t\tif (yych <= 'E') goto yy1503;\n \t\t\t\tif (yych <= 'Z') goto yy167;\n \t\t\t\tgoto yy218;\n \t\t\t}\n@@ -24346,14 +24454,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy218;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'e') goto yy1516;\n+\t\t\t\tif (yych <= 'e') goto yy1518;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy218;\n \t\t\t}\n \t\t}\n \t}\n-yy1516:\n-\tYYDEBUG(1516, *YYCURSOR);\n+yy1518:\n+\tYYDEBUG(1518, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'L') {\n@@ -24368,7 +24476,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'M') goto yy1502;\n+\t\t\tif (yych <= 'M') goto yy1504;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24377,14 +24485,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'm') goto yy1517;\n+\t\t\t\tif (yych <= 'm') goto yy1519;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1517:\n-\tYYDEBUG(1517, *YYCURSOR);\n+yy1519:\n+\tYYDEBUG(1519, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'A') {\n@@ -24399,7 +24507,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'B') goto yy1503;\n+\t\t\tif (yych <= 'B') goto yy1505;\n \t\t\tif (yych <= 'Z') goto yy169;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24408,14 +24516,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy177;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'b') goto yy1518;\n+\t\t\t\tif (yych <= 'b') goto yy1520;\n \t\t\t\tif (yych <= 'z') goto yy177;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1518:\n-\tYYDEBUG(1518, *YYCURSOR);\n+yy1520:\n+\tYYDEBUG(1520, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'D') {\n@@ -24429,47 +24537,47 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n-\t\t\tif (yych <= 'E') goto yy1504;\n+\t\t\tif (yych <= 'E') goto yy1506;\n \t\t\tif (yych == '_') goto yy172;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych == 'e') goto yy1519;\n+\t\t\tif (yych == 'e') goto yy1521;\n \t\t\tif (yych <= 'z') goto yy178;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1519:\n-\tYYDEBUG(1519, *YYCURSOR);\n+yy1521:\n+\tYYDEBUG(1521, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych == 'R') goto yy229;\n \tif (yych == 'r') goto yy341;\n \tgoto yy179;\n-yy1520:\n-\tYYDEBUG(1520, *YYCURSOR);\n+yy1522:\n+\tYYDEBUG(1522, *YYCURSOR);\n \tyyaccept = 32;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= '\/') {\n \t\tif (yych <= ',') {\n \t\t\tif (yych == ')') goto yy164;\n-\t\t\tgoto yy1506;\n+\t\t\tgoto yy1508;\n \t\t} else {\n-\t\t\tif (yych == '.') goto yy1506;\n+\t\t\tif (yych == '.') goto yy1508;\n \t\t\tgoto yy172;\n \t\t}\n \t} else {\n \t\tif (yych <= '^') {\n-\t\t\tif (yych <= '@') goto yy1506;\n+\t\t\tif (yych <= '@') goto yy1508;\n \t\t\tif (yych <= 'Z') goto yy168;\n-\t\t\tgoto yy1506;\n+\t\t\tgoto yy1508;\n \t\t} else {\n \t\t\tif (yych <= '_') goto yy172;\n-\t\t\tif (yych <= '`') goto yy1506;\n+\t\t\tif (yych <= '`') goto yy1508;\n \t\t\tif (yych <= 'z') goto yy176;\n-\t\t\tgoto yy1506;\n+\t\t\tgoto yy1508;\n \t\t}\n \t}\n-yy1521:\n-\tYYDEBUG(1521, *YYCURSOR);\n+yy1523:\n+\tYYDEBUG(1523, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'S') {\n \t\tif (yych <= ')') {\n@@ -24485,13 +24593,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy166;\n \t\t} else {\n-\t\t\tif (yych <= 's') goto yy1522;\n+\t\t\tif (yych <= 's') goto yy1524;\n \t\t\tif (yych <= 'z') goto yy166;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1522:\n-\tYYDEBUG(1522, *YYCURSOR);\n+yy1524:\n+\tYYDEBUG(1524, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'T') {\n \t\tif (yych <= ')') {\n@@ -24507,13 +24615,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy167;\n \t\t} else {\n-\t\t\tif (yych <= 't') goto yy1523;\n+\t\t\tif (yych <= 't') goto yy1525;\n \t\t\tif (yych <= 'z') goto yy167;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1523:\n-\tYYDEBUG(1523, *YYCURSOR);\n+yy1525:\n+\tYYDEBUG(1525, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'E') {\n \t\tif (yych <= ')') {\n@@ -24529,13 +24637,13 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy168;\n \t\t} else {\n-\t\t\tif (yych <= 'e') goto yy1524;\n+\t\t\tif (yych <= 'e') goto yy1526;\n \t\t\tif (yych <= 'z') goto yy168;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1524:\n-\tYYDEBUG(1524, *YYCURSOR);\n+yy1526:\n+\tYYDEBUG(1526, *YYCURSOR);\n \tyych = *++YYCURSOR;\n \tif (yych <= 'R') {\n \t\tif (yych <= ')') {\n@@ -24551,37 +24659,37 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\tif (yych <= '`') goto yy3;\n \t\t\tgoto yy169;\n \t\t} else {\n-\t\t\tif (yych <= 'r') goto yy1525;\n+\t\t\tif (yych <= 'r') goto yy1527;\n \t\t\tif (yych <= 'z') goto yy169;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1525:\n-\tYYDEBUG(1525, *YYCURSOR);\n+yy1527:\n+\tYYDEBUG(1527, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'C') {\n \t\tif (yych == ')') goto yy164;\n \t\tgoto yy3;\n \t} else {\n-\t\tif (yych <= 'D') goto yy1526;\n+\t\tif (yych <= 'D') goto yy1528;\n \t\tif (yych != 'd') goto yy3;\n \t}\n-yy1526:\n-\tYYDEBUG(1526, *YYCURSOR);\n+yy1528:\n+\tYYDEBUG(1528, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'A') goto yy1527;\n+\tif (yych == 'A') goto yy1529;\n \tif (yych != 'a') goto yy56;\n-yy1527:\n-\tYYDEBUG(1527, *YYCURSOR);\n+yy1529:\n+\tYYDEBUG(1529, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'Y') goto yy1528;\n+\tif (yych == 'Y') goto yy1530;\n \tif (yych != 'y') goto yy56;\n-yy1528:\n-\tYYDEBUG(1528, *YYCURSOR);\n+yy1530:\n+\tYYDEBUG(1530, *YYCURSOR);\n \t++YYCURSOR;\n-yy1529:\n-\tYYDEBUG(1529, *YYCURSOR);\n+yy1531:\n+\tYYDEBUG(1531, *YYCURSOR);\n #line 970 \"ext\/date\/lib\/parse_date.re\"\n \t{\n \t\tDEBUG_OUTPUT(\"yesterday\");\n@@ -24593,9 +24701,9 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\tTIMELIB_DEINIT;\n \t\treturn TIMELIB_RELATIVE;\n \t}\n-#line 24597 \"<stdout>\"\n-yy1530:\n-\tYYDEBUG(1530, *YYCURSOR);\n+#line 24705 \"<stdout>\"\n+yy1532:\n+\tYYDEBUG(1532, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'R') {\n@@ -24610,7 +24718,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'S') goto yy1522;\n+\t\t\tif (yych <= 'S') goto yy1524;\n \t\t\tif (yych <= 'Z') goto yy166;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24619,14 +24727,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy171;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 's') goto yy1531;\n+\t\t\t\tif (yych <= 's') goto yy1533;\n \t\t\t\tif (yych <= 'z') goto yy171;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1531:\n-\tYYDEBUG(1531, *YYCURSOR);\n+yy1533:\n+\tYYDEBUG(1533, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'S') {\n@@ -24641,7 +24749,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'T') goto yy1523;\n+\t\t\tif (yych <= 'T') goto yy1525;\n \t\t\tif (yych <= 'Z') goto yy167;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24650,14 +24758,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy175;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 't') goto yy1532;\n+\t\t\t\tif (yych <= 't') goto yy1534;\n \t\t\t\tif (yych <= 'z') goto yy175;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1532:\n-\tYYDEBUG(1532, *YYCURSOR);\n+yy1534:\n+\tYYDEBUG(1534, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'D') {\n@@ -24672,7 +24780,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'E') goto yy1524;\n+\t\t\tif (yych <= 'E') goto yy1526;\n \t\t\tif (yych <= 'Z') goto yy168;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24681,14 +24789,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy176;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'e') goto yy1533;\n+\t\t\t\tif (yych <= 'e') goto yy1535;\n \t\t\t\tif (yych <= 'z') goto yy176;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1533:\n-\tYYDEBUG(1533, *YYCURSOR);\n+yy1535:\n+\tYYDEBUG(1535, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'Q') {\n@@ -24703,7 +24811,7 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '_') {\n-\t\t\tif (yych <= 'R') goto yy1525;\n+\t\t\tif (yych <= 'R') goto yy1527;\n \t\t\tif (yych <= 'Z') goto yy169;\n \t\t\tif (yych <= '^') goto yy3;\n \t\t\tgoto yy172;\n@@ -24712,14 +24820,14 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t\t\tif (yych <= '`') goto yy3;\n \t\t\t\tgoto yy177;\n \t\t\t} else {\n-\t\t\t\tif (yych <= 'r') goto yy1534;\n+\t\t\t\tif (yych <= 'r') goto yy1536;\n \t\t\t\tif (yych <= 'z') goto yy177;\n \t\t\t\tgoto yy3;\n \t\t\t}\n \t\t}\n \t}\n-yy1534:\n-\tYYDEBUG(1534, *YYCURSOR);\n+yy1536:\n+\tYYDEBUG(1536, *YYCURSOR);\n \tyyaccept = 0;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych <= 'C') {\n@@ -24733,25 +24841,25 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t\t}\n \t} else {\n \t\tif (yych <= '`') {\n-\t\t\tif (yych <= 'D') goto yy1526;\n+\t\t\tif (yych <= 'D') goto yy1528;\n \t\t\tif (yych == '_') goto yy172;\n \t\t\tgoto yy3;\n \t\t} else {\n-\t\t\tif (yych == 'd') goto yy1535;\n+\t\t\tif (yych == 'd') goto yy1537;\n \t\t\tif (yych <= 'z') goto yy178;\n \t\t\tgoto yy3;\n \t\t}\n \t}\n-yy1535:\n-\tYYDEBUG(1535, *YYCURSOR);\n+yy1537:\n+\tYYDEBUG(1537, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'A') goto yy1527;\n+\tif (yych == 'A') goto yy1529;\n \tif (yych != 'a') goto yy179;\n-\tYYDEBUG(1536, *YYCURSOR);\n+\tYYDEBUG(1538, *YYCURSOR);\n \tyych = *++YYCURSOR;\n-\tif (yych == 'Y') goto yy1528;\n+\tif (yych == 'Y') goto yy1530;\n \tif (yych != 'y') goto yy179;\n-\tYYDEBUG(1537, *YYCURSOR);\n+\tYYDEBUG(1539, *YYCURSOR);\n \tyyaccept = 33;\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yybm[0+yych] & 16) {\n@@ -24759,11 +24867,11 @@ static int scan(Scanner *s, timelib_tz_get_wrapper tz_get_wrapper)\n \t}\n \tif (yych <= '.') {\n \t\tif (yych == '-') goto yy172;\n-\t\tgoto yy1529;\n+\t\tgoto yy1531;\n \t} else {\n \t\tif (yych <= '\/') goto yy172;\n \t\tif (yych == '_') goto yy172;\n-\t\tgoto yy1529;\n+\t\tgoto yy1531;\n \t}\n }\n #line 1772 \"ext\/date\/lib\/parse_date.re\"\ndiff --git a\/ext\/date\/lib\/parse_date.re b\/ext\/date\/lib\/parse_date.re\nindex 74d9ea3a0fb2..f26e276837c0 100644\n--- a\/ext\/date\/lib\/parse_date.re\n+++ b\/ext\/date\/lib\/parse_date.re\n@@ -931,8 +931,8 @@ isoweek          = year4 \"-\"? \"W\" weekofyear;\n exif             = year4 \":\" monthlz \":\" daylz \" \" hour24lz \":\" minutelz \":\" secondlz;\n firstdayof       = 'first day of';\n lastdayof        = 'last day of';\n-backof           = 'back of ' hour24 space? meridian?;\n-frontof          = 'front of ' hour24 space? meridian?;\n+backof           = 'back of ' hour24 (space? meridian)?;\n+frontof          = 'front of ' hour24 (space? meridian)?;\n \n \/* Common Log Format: 10\/Oct\/2000:13:55:36 -0700 *\/\n clf              = day \"\/\" monthabbr \"\/\" year4 \":\" hour24lz \":\" minutelz \":\" secondlz space tzcorrection;\ndiff --git a\/ext\/date\/tests\/bug53437_var3.phpt b\/ext\/date\/tests\/bug53437_var3.phpt\nindex 8f48b1b6446d..8dcd4c821f6b 100644\n--- a\/ext\/date\/tests\/bug53437_var3.phpt\n+++ b\/ext\/date\/tests\/bug53437_var3.phpt\n@@ -40,7 +40,7 @@ object(DateInterval)#%d (16) {\n   [\"special_amount\"]=>\n   int(-1)\n   [\"have_weekday_relative\"]=>\n-  int(9)\n+  int(0)\n   [\"have_special_relative\"]=>\n   int(0)\n   [\"f\"]=>\ndiff --git a\/ext\/wddx\/tests\/bug75055.phpt b\/ext\/wddx\/tests\/bug75055.phpt\nnew file mode 100644\nindex 000000000000..2956284d221c\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug75055.phpt\n@@ -0,0 +1,20 @@\n+--TEST--\n+Bug #75055 Out-Of-Bounds Read in timelib_meridian()\n+--SKIPIF--\n+<?php if (!extension_loaded(\"wddx\")) print \"skip\"; ?>\n+--FILE--\n+<?php\n+\n+$file_str = dirname(__FILE__) . \"\/bug75055.wddx\";\n+\n+$wddx_str = file_get_contents($file_str);\n+print strlen($wddx_str) . \" bytes read.\\n\";\n+\n+var_dump(wddx_deserialize($wddx_str));\n+?>\n+--EXPECT--\n+323 bytes read.\n+array(1) {\n+  [\"aDateTime\"]=>\n+  string(12) \"frONt of 0 0\"\n+}\ndiff --git a\/ext\/wddx\/tests\/bug75055.wddx b\/ext\/wddx\/tests\/bug75055.wddx\nnew file mode 100644\nindex 000000000000..64933524696a\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug75055.wddx\n@@ -0,0 +1,13 @@\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+<header\/>\n+\t<data>\n+        \t<struct>\n+                    <var name='aDateTime'>\n+                         <dateTime>frONt of 0 0<\/dateTime>\n+                     <\/var>\n+                <\/struct>\n+\t<\/data>\n+<\/wddxPacket>\n+\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2019-9718","CWE_ID":"125","category":"security","commit_id":"1f00c97bc3475c477f3c468cf2d924d5761d0982","commit_message":"From 1f00c97bc3475c477f3c468cf2d924d5761d0982 Mon Sep 17 00:00:00 2001\nFrom: Kevin Backhouse via RT <security-reports@semmle.com>\nDate: Wed, 6 Feb 2019 11:29:22 +0000\nSubject: [PATCH] avcodec\/htmlsubtitles: Fixes denial of service due to use of\n sscanf in inner loop for tag scaning\n\nFixes: [Semmle Security Reports #19438]\nFixes: dos_sscanf1.mkv\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/htmlsubtitles.c | 30 +++++++++++++++++++++++++++++-\n 1 file changed, 29 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/htmlsubtitles.c b\/libavcodec\/htmlsubtitles.c\nindex fb9f900..c0cfccf 100644\n--- a\/libavcodec\/htmlsubtitles.c\n+++ b\/libavcodec\/htmlsubtitles.c\n@@ -75,6 +75,34 @@ struct font_tag {\n };\n \n \/*\n+ * Fast code for scanning the rest of a tag. Functionally equivalent to\n+ * this sscanf call:\n+ *\n+ * sscanf(in, \"%127[^<>]>%n\", buffer, lenp) == 2\n+ *\/\n+static int scantag(const char* in, char* buffer, int* lenp) {\n+    int len;\n+\n+    for (len = 0; len < 128; len++) {\n+        const char c = *in++;\n+        switch (c) {\n+        case '\\0':\n+            return 0;\n+        case '<':\n+            return 0;\n+        case '>':\n+            buffer[len] = '\\0';\n+            *lenp = len+1;\n+            return 1;\n+        default:\n+            break;\n+        }\n+        buffer[len] = c;\n+    }\n+    return 0;\n+}\n+\n+\/*\n  * The general politic of the convert is to mask unsupported tags or formatting\n  * errors (but still alert the user\/subtitles writer with an error\/warning)\n  * without dropping any actual text content for the final user.\n@@ -155,7 +183,7 @@ int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in)\n \n             len = 0;\n \n-            if (sscanf(in+tag_close+1, \"%127[^<>]>%n\", buffer, &len) >= 1 && len > 0) {\n+            if (scantag(in+tag_close+1, buffer, &len) && len > 0) {\n                 const int skip = len + tag_close;\n                 const char *tagname = buffer;\n                 while (*tagname == ' ') {\n-- \n2.7.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-6294","CWE_ID":"125","category":"security","commit_id":"aa82e99ed8003c01f1ef4f0940e56b85c5b032d4","commit_message":"From aa82e99ed8003c01f1ef4f0940e56b85c5b032d4 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Tue, 12 Jul 2016 22:37:36 -0700\nSubject: [PATCH] Fix bug #72533 (locale_accept_from_http out-of-bounds access)\n\n---\n ext\/intl\/locale\/locale_methods.c | 18 ++++++++++++++++++\n ext\/intl\/tests\/bug72533.phpt     | 30 ++++++++++++++++++++++++++++++\n 2 files changed, 48 insertions(+)\n create mode 100644 ext\/intl\/tests\/bug72533.phpt\n\n","diff_code":"diff --git a\/ext\/intl\/locale\/locale_methods.c b\/ext\/intl\/locale\/locale_methods.c\nindex 31f60b3..443856f 100644\n--- a\/ext\/intl\/locale\/locale_methods.c\n+++ b\/ext\/intl\/locale\/locale_methods.c\n@@ -1591,6 +1591,24 @@ PHP_FUNCTION(locale_accept_from_http)\n \t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n+\tif(http_accept_len > ULOC_FULLNAME_CAPACITY) {\n+\t\t\/* check each fragment, if any bigger than capacity, can't do it due to bug #72533 *\/\n+\t\tchar *start = http_accept;\n+\t\tchar *end;\n+\t\tsize_t len;\n+\t\tdo {\n+\t\t\tend = strchr(start, ',');\n+\t\t\tlen = end ? end-start : http_accept_len-(start-http_accept);\n+\t\t\tif(len > ULOC_FULLNAME_CAPACITY) {\n+\t\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n+\t\t\t\t\t\t\"locale_accept_from_http: locale string too long\", 0 TSRMLS_CC );\n+\t\t\t\tRETURN_FALSE;\n+\t\t\t}\n+\t\t\tif(end) {\n+\t\t\t\tstart = end+1;\n+\t\t\t}\n+\t\t} while(end != NULL);\n+\t}\n \n \tavailable = ures_openAvailableLocales(NULL, &status);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\ndiff --git a\/ext\/intl\/tests\/bug72533.phpt b\/ext\/intl\/tests\/bug72533.phpt\nnew file mode 100644\nindex 0000000..c7fcba3\n--- \/dev\/null\n+++ b\/ext\/intl\/tests\/bug72533.phpt\n@@ -0,0 +1,30 @@\n+--TEST--\n+Bug #72533 (locale_accept_from_http out-of-bounds access)\n+--SKIPIF--\n+<?php if( !extension_loaded( 'intl' ) ) print 'skip'; ?>\n+--FILE--\n+<?php\n+\n+function ut_main()\n+{\n+    $ret = var_export(ut_loc_accept_http(str_repeat('x', 256)), true);\n+    $ret .= \"\\n\";\n+\tif(intl_is_failure(intl_get_error_code())) {\n+\t\t$ret .= var_export(intl_get_error_message(), true);\n+\t}\n+    $ret .= \"\\n\";\n+    $ret .= var_export(ut_loc_accept_http(str_repeat('en,', 256)), true);\n+    $ret .= \"\\n\";\n+\tif(intl_is_failure(intl_get_error_code())) {\n+\t\t$ret .= var_export(intl_get_error_message(), true);\n+\t}\n+    return $ret;\n+}\n+\n+include_once( 'ut_common.inc' );\n+ut_run();\n+?>\n+--EXPECTF--\n+false\n+'locale_accept_from_http: locale string too long: U_ILLEGAL_ARGUMENT_ERROR'\n+'en'\n\\ No newline at end of file\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10171","CWE_ID":"125","category":"security","commit_id":"4bc05fc490b66ef2d45b1de26abf1455b486b0dc","commit_message":"From 4bc05fc490b66ef2d45b1de26abf1455b486b0dc Mon Sep 17 00:00:00 2001\nFrom: David Bryant <david@wavpack.com>\nDate: Wed, 21 Dec 2016 22:18:36 -0800\nSubject: [PATCH] fixes for 4 fuzz failures posted to SourceForge mailing list\n\n---\n src\/open_utils.c | 6 +++++-\n src\/read_words.c | 4 ++++\n 2 files changed, 9 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/open_utils.c b\/src\/open_utils.c\nindex 7519f99..a844046 100644\n--- a\/src\/open_utils.c\n+++ b\/src\/open_utils.c\n@@ -560,7 +560,7 @@ static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n \n     \/\/ if there's any data, the first two bytes are file_format and qmode flags\n \n-    if (bytecnt) {\n+    if (bytecnt >= 2) {\n         wpc->file_format = *byteptr++;\n         wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n         bytecnt -= 2;\n@@ -593,6 +593,10 @@ static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n                         for (i = 0; i < nchans; ++i)\n                             if (bytecnt) {\n                                 wpc->channel_reordering [i] = *byteptr++;\n+\n+                                if (wpc->channel_reordering [i] >= nchans)  \/\/ make sure index is in range\n+                                    wpc->channel_reordering [i] = 0;\n+\n                                 bytecnt--;\n                             }\n                             else\ndiff --git a\/src\/read_words.c b\/src\/read_words.c\nindex 62acac3..a537bfa 100644\n--- a\/src\/read_words.c\n+++ b\/src\/read_words.c\n@@ -288,6 +288,10 @@ int32_t FASTCALL get_word (WavpackStream *wps, int chan, int32_t *correction)\n \n     low &= 0x7fffffff;\n     high &= 0x7fffffff;\n+\n+    if (low > high)         \/\/ make sure high and low make sense\n+        high = low;\n+\n     mid = (high + low + 1) >> 1;\n \n     if (!c->error_limit)\n","owner":"dbry","repo":"WavPack","source":"cve"},{"CVE_ID":"CVE-2019-8906","CWE_ID":"125","category":"security","commit_id":"2858eaf99f6cc5aae129bcbf1e24ad160240185f","commit_message":"From 2858eaf99f6cc5aae129bcbf1e24ad160240185f Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Wed, 2 Jan 2019 19:44:14 +0000\nSubject: [PATCH] Avoid OOB read (found by ASAN reported by F. Alonso)\n\n---\n src\/readelf.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/readelf.c b\/src\/readelf.c\nindex 4f4103a1d..8d5789664 100644\n--- a\/src\/readelf.c\n+++ b\/src\/readelf.c\n@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.156 2018\/10\/19 00:33:04 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.157 2019\/01\/02 19:44:14 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -752,7 +752,7 @@ do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n \t\t\tchar sbuf[512];\n \t\t\tstruct NetBSD_elfcore_procinfo pi;\n \t\t\tmemset(&pi, 0, sizeof(pi));\n-\t\t\tmemcpy(&pi, nbuf + doff, descsz);\n+\t\t\tmemcpy(&pi, nbuf + doff, MIN(descsz, sizeof(pi)));\n \n \t\t\tif (file_printf(ms, \", from '%.31s', pid=%u, uid=%u, \"\n \t\t\t    \"gid=%u, nlwps=%u, lwp=%u (signal %u\/code %u)\",\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2017-17081","CWE_ID":"125","category":"security","commit_id":"58cf31cee7a456057f337b3102a03206d833d5e8","commit_message":"From 58cf31cee7a456057f337b3102a03206d833d5e8 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Mon, 13 Nov 2017 20:47:48 +0100\nSubject: [PATCH] avcodec\/x86\/mpegvideodsp: Fix signedness bug in need_emu\n\nFixes: out of array read\nFixes: 3516\/attachment-311488.dat\n\nFound-by: Insu Yun, Georgia Tech.\nTested-by: wuninsu@gmail.com\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/x86\/mpegvideodsp.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/x86\/mpegvideodsp.c b\/libavcodec\/x86\/mpegvideodsp.c\nindex e0498f38496..6009b64e076 100644\n--- a\/libavcodec\/x86\/mpegvideodsp.c\n+++ b\/libavcodec\/x86\/mpegvideodsp.c\n@@ -52,8 +52,9 @@ static void gmc_mmx(uint8_t *dst, uint8_t *src,\n     const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);\n     const int dxh = dxy * (h - 1);\n     const int dyw = dyx * (w - 1);\n-    int need_emu  =  (unsigned) ix >= width  - w ||\n-                     (unsigned) iy >= height - h;\n+    int need_emu  =  (unsigned) ix >= width  - w || width < w ||\n+                     (unsigned) iy >= height - h || height< h\n+                     ;\n \n     if ( \/\/ non-constant fullpel offset (3% of blocks)\n         ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-18030","CWE_ID":"125","category":"security","commit_id":"f153b563f8cf121aebf5a2fff5f0110faf58ccb3","commit_message":"From f153b563f8cf121aebf5a2fff5f0110faf58ccb3 Mon Sep 17 00:00:00 2001\nFrom: Wolfgang Bumiller <w.bumiller@proxmox.com>\nDate: Wed, 25 Jan 2017 14:48:57 +0100\nSubject: [PATCH] cirrus: handle negative pitch in cirrus_invalidate_region()\n\ncirrus_invalidate_region() calls memory_region_set_dirty()\non a per-line basis, always ranging from off_begin to\noff_begin+bytesperline. With a negative pitch off_begin\nmarks the top most used address and thus we need to do an\ninitial shift backwards by a line for negative pitches of\nbackward blits, otherwise the first iteration covers the\nline going from the start offset forwards instead of\nbackwards.\nAdditionally since the start address is inclusive, if we\nshift by a full `bytesperline` we move to the first address\n*not* included in the blit, so we only shift by one less\nthan bytesperline.\n\nSigned-off-by: Wolfgang Bumiller <w.bumiller@proxmox.com>\nMessage-id: 1485352137-29367-1-git-send-email-w.bumiller@proxmox.com\n\n[ kraxel: codestyle fixes ]\n\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/display\/cirrus_vga.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/hw\/display\/cirrus_vga.c b\/hw\/display\/cirrus_vga.c\nindex 379910d..0f05e45 100644\n--- a\/hw\/display\/cirrus_vga.c\n+++ b\/hw\/display\/cirrus_vga.c\n@@ -661,9 +661,14 @@ static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n     int off_cur;\n     int off_cur_end;\n \n+    if (off_pitch < 0) {\n+        off_begin -= bytesperline - 1;\n+    }\n+\n     for (y = 0; y < lines; y++) {\n \toff_cur = off_begin;\n \toff_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;\n+        assert(off_cur_end >= off_cur);\n         memory_region_set_dirty(&s->vga.vram, off_cur, off_cur_end - off_cur);\n \toff_begin += off_pitch;\n     }\n-- \n1.8.3.1\n\n","owner":"qemu","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2016-6911","CWE_ID":"125","category":"security","commit_id":"4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae","commit_message":"From 4859d69e07504d4b0a4bdf9bcb4d9e3769ca35ae Mon Sep 17 00:00:00 2001\nFrom: \"Christoph M. Becker\" <cmbecker69@gmx.de>\nDate: Tue, 2 Aug 2016 12:10:33 +0200\nSubject: [PATCH] Fix invalid read in gdImageCreateFromTiffPtr()\n\ntiff_invalid_read.tiff is corrupt, and causes an invalid read in\ngdImageCreateFromTiffPtr(), but not in gdImageCreateFromTiff(). The culprit\nis dynamicGetbuf(), which doesn't check for out-of-bound reads. In this case,\ndynamicGetbuf() is called with a negative dp->pos, but also positive buffer\noverflows have to be handled, in which case 0 has to be returned (cf. commit\n75e29a9).\n\nFixing dynamicGetbuf() exhibits that the corrupt TIFF would still create\nthe image, because the return value of TIFFReadRGBAImage() is not checked.\nWe do that, and let createFromTiffRgba() fail if TIFFReadRGBAImage() fails.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org.\n\nCVE-2016-6911\n---\n src\/gd_io_dp.c                      |  15 ++++---\n src\/gd_tiff.c                       |  29 +++++++------\n tests\/tiff\/.gitignore               |   1 +\n tests\/tiff\/CMakeLists.txt           |   1 +\n tests\/tiff\/Makemodule.am            |   6 ++-\n tests\/tiff\/tiff_invalid_read.c      |  61 ++++++++++++++++++++++++++++\n tests\/tiff\/tiff_invalid_read_1.tiff | Bin 0 -> 3304 bytes\n tests\/tiff\/tiff_invalid_read_2.tiff | Bin 0 -> 429 bytes\n tests\/tiff\/tiff_invalid_read_3.tiff | Bin 0 -> 428 bytes\n 9 files changed, 94 insertions(+), 19 deletions(-)\n create mode 100644 tests\/tiff\/tiff_invalid_read.c\n create mode 100644 tests\/tiff\/tiff_invalid_read_1.tiff\n create mode 100644 tests\/tiff\/tiff_invalid_read_2.tiff\n create mode 100644 tests\/tiff\/tiff_invalid_read_3.tiff\n\n","diff_code":"diff --git a\/src\/gd_io_dp.c b\/src\/gd_io_dp.c\nindex 228bfa5c..eda2eeb0 100644\n--- a\/src\/gd_io_dp.c\n+++ b\/src\/gd_io_dp.c\n@@ -263,6 +263,7 @@ static void dynamicPutchar(struct gdIOCtx *ctx, int a)\n \tappendDynamic(dctx->dp, &b, 1);\n }\n \n+\/* returns the number of bytes actually read; 0 on EOF and error *\/\n static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n {\n \tint rlen, remain;\n@@ -272,21 +273,25 @@ static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n \tdctx = (dpIOCtxPtr) ctx;\n \tdp = dctx->dp;\n \n+\tif (dp->pos < 0 || dp->pos >= dp->realSize) {\n+\t\treturn 0;\n+\t}\n+\n \tremain = dp->logicalSize - dp->pos;\n \tif(remain >= len) {\n \t\trlen = len;\n \t} else {\n \t\tif(remain <= 0) {\n-\t\t\t\/* 2.0.34: EOF is incorrect. We use 0 for\n-\t\t\t * errors and EOF, just like fileGetbuf,\n-\t\t\t * which is a simple fread() wrapper.\n-\t\t\t * TBB. Original bug report: Daniel Cowgill. *\/\n-\t\t\treturn 0; \/* NOT EOF *\/\n+\t\t\treturn 0;\n \t\t}\n \n \t\trlen = remain;\n \t}\n \n+\tif (dp->pos + rlen > dp->realSize) {\n+\t\trlen = dp->realSize - dp->pos;\n+\t}\n+\n \tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n \tdp->pos += rlen;\n \ndiff --git a\/src\/gd_tiff.c b\/src\/gd_tiff.c\nindex b4f1e637..3f20c5b2 100644\n--- a\/src\/gd_tiff.c\n+++ b\/src\/gd_tiff.c\n@@ -759,6 +759,7 @@ static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n \tint height = im->sy;\n \tuint32 *buffer;\n \tuint32 rgba;\n+\tint success;\n \n \t\/* switch off colour merging on target gd image just while we write out\n \t * content - we want to preserve the alpha data until the user chooses\n@@ -771,18 +772,20 @@ static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n \t\treturn GD_FAILURE;\n \t}\n \n-\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n-\n-\tfor(y = 0; y < height; y++) {\n-\t\tfor(x = 0; x < width; x++) {\n-\t\t\t\/* if it doesn't already exist, allocate a new colour,\n-\t\t\t * else use existing one *\/\n-\t\t\trgba = buffer[(y * width + x)];\n-\t\t\ta = (0xff - TIFFGetA(rgba)) \/ 2;\n-\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n-\n-\t\t\t\/* set pixel colour to this colour *\/\n-\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n+\tsuccess = TIFFReadRGBAImage(tif, width, height, buffer, 1);\n+\n+\tif (success) {\n+\t\tfor(y = 0; y < height; y++) {\n+\t\t\tfor(x = 0; x < width; x++) {\n+\t\t\t\t\/* if it doesn't already exist, allocate a new colour,\n+\t\t\t\t * else use existing one *\/\n+\t\t\t\trgba = buffer[(y * width + x)];\n+\t\t\t\ta = (0xff - TIFFGetA(rgba)) \/ 2;\n+\t\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n+\t\n+\t\t\t\t\/* set pixel colour to this colour *\/\n+\t\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -790,7 +793,7 @@ static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n \n \t\/* now reset colour merge for alpha blending routines *\/\n \tgdImageAlphaBlending(im, alphaBlendingFlag);\n-\treturn GD_SUCCESS;\n+\treturn success;\n }\n \n \/*\ndiff --git a\/tests\/tiff\/.gitignore b\/tests\/tiff\/.gitignore\nindex 7cf35ee8..273e8499 100644\n--- a\/tests\/tiff\/.gitignore\n+++ b\/tests\/tiff\/.gitignore\n@@ -1,3 +1,4 @@\n \/tiff_dpi\n \/tiff_im2im\n \/tiff_null\n+\/tiff_invalid_read\ndiff --git a\/tests\/tiff\/CMakeLists.txt b\/tests\/tiff\/CMakeLists.txt\nindex 03f630ca..81f23033 100644\n--- a\/tests\/tiff\/CMakeLists.txt\n+++ b\/tests\/tiff\/CMakeLists.txt\n@@ -1,6 +1,7 @@\n IF(TIFF_FOUND)\n LIST(APPEND TESTS_FILES\n \ttiff_im2im\n+\ttiff_invalid_read\n \ttiff_null\n \ttiff_dpi\n )\ndiff --git a\/tests\/tiff\/Makemodule.am b\/tests\/tiff\/Makemodule.am\nindex fd396990..670434a7 100644\n--- a\/tests\/tiff\/Makemodule.am\n+++ b\/tests\/tiff\/Makemodule.am\n@@ -2,8 +2,12 @@ if HAVE_LIBTIFF\n libgd_test_programs += \\\n \ttiff\/tiff_dpi \\\n \ttiff\/tiff_im2im \\\n+\ttiff\/tiff_invalid_read \\\n \ttiff\/tiff_null\n endif\n \n EXTRA_DIST += \\\n-\ttiff\/CMakeLists.txt\n+\ttiff\/CMakeLists.txt \\\n+\ttiff\/tiff_invalid_read_1.tiff \\\n+\ttiff\/tiff_invalid_read_2.tiff \\\n+\ttiff\/tiff_invalid_read_3.tiff\ndiff --git a\/tests\/tiff\/tiff_invalid_read.c b\/tests\/tiff\/tiff_invalid_read.c\nnew file mode 100644\nindex 00000000..bed53891\n--- \/dev\/null\n+++ b\/tests\/tiff\/tiff_invalid_read.c\n@@ -0,0 +1,61 @@\n+\/*\n+We're testing that reading corrupt TIFF files doesn't cause any memory issues,\n+and that the operation gracefully fails (i.e. gdImageCreateFromTiffPtr() returns\n+NULL).\n+*\/\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+\n+static void check_file(char *basename);\n+static size_t read_test_file(char **buffer, char *basename);\n+\n+\n+int main()\n+{\n+    check_file(\"tiff_invalid_read_1.tiff\");\n+    check_file(\"tiff_invalid_read_2.tiff\");\n+    check_file(\"tiff_invalid_read_3.tiff\");\n+\n+    return gdNumFailures();\n+}\n+\n+\n+static void check_file(char *basename)\n+{\n+    gdImagePtr im;\n+    char *buffer;\n+    size_t size;\n+\n+    size = read_test_file(&buffer, basename);\n+    im = gdImageCreateFromTiffPtr(size, (void *) buffer);\n+    gdTestAssert(im == NULL);\n+    free(buffer);\n+}\n+\n+\n+static size_t read_test_file(char **buffer, char *basename)\n+{\n+    char *filename;\n+    FILE *fp;\n+    size_t exp_size, act_size;\n+\n+    filename = gdTestFilePath2(\"tiff\", basename);\n+    fp = fopen(filename, \"rb\");\n+    gdTestAssert(fp != NULL);\n+\n+\tfseek(fp, 0, SEEK_END);\n+\texp_size = ftell(fp);\n+\tfseek(fp, 0, SEEK_SET);\n+\n+    *buffer = malloc(exp_size);\n+    gdTestAssert(*buffer != NULL);\n+    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n+    gdTestAssert(act_size == exp_size);\n+\n+    fclose(fp);\n+    free(filename);\n+\n+    return act_size;\n+}\ndiff --git a\/tests\/tiff\/tiff_invalid_read_1.tiff b\/tests\/tiff\/tiff_invalid_read_1.tiff\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..b3877e337b3c0a7ccdee988647a907749d7c8ad7\nGIT binary patch\nliteral 3304\nzcmebD)MD`9W?=X~3Q$7e-+vIq1h~X8RSt{@vF;;Q9ld-(u6xMUM=gI*%YJH^LoI&|\nzR&(eTPSm!C+U5}(Ka|=_seWSJNk|>3?jTh?A^WK%Psm+_<f-KjO3gucCpw=}^Xa7@\nz=582GFMFwF54yY2`P8y!)ExXFAi}`F$jrdVz`!5@#EeijKakA?WU~NiKOP1KW~eww\nz9UGL*1Y~m|iSsftG57+-rUBIpGO~cp<fv_%Erz5<6v_sf3lrA@vc;k59e^!*DMnVX\nzUOS*U(onV=kS&8`js_B26UYX+1?YMPJD_?HyA7z`9>`_`vcq~97=obcA?g?yJiw|E\nzv;YGHGH_jA3<|G?hgBgUn&IpjA22;@=1dUXkd~$fqCaTF@Pql%ya6DZA;J=@UOzXl\nzM87C8H?3H|B(=E2P`@}gF()S;i1kg(O-wAzER7N^fzZInC^03~FfGk2CDk-3Dbc{#\nZ$ig_)C?(0#P_MWwU9TiFEsX(80ssaYg@phB\n\nliteral 0\nHcmV?d00001\n\ndiff --git a\/tests\/tiff\/tiff_invalid_read_2.tiff b\/tests\/tiff\/tiff_invalid_read_2.tiff\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..f9967e542178cfbab902ec55c85479588dfb099e\nGIT binary patch\nliteral 429\nzcmYk1u};G<7=+JB6IB%jL0gb0Lnc%hn!2G)%>ay40x1In0}_}fMwOZlBok9!qm1x6\nzWrdkH;0@rn6{J}DeczqVmOY&wV-r9DFPhZb0JFi!n<?2PZ&h-;WQTIMWSh8A=`@*z\nzYswzzqHR_)_tnYon9iH=ol1YVWO%?{*>_Lz3G6dRKc+@ompSI(2Ju1VaIeBg#1{4S\nz7tW}!IimhKvHpk$Tu?=0n_|5#X*B*T9|Lg=v|1E4zTSUn72hv6TJf>IGWxn&X)TmG\nz)Oz>R+cLh}jI`obn7*GbbN^YUD)aLs%ekMWa<RCl@lPg$I2egh81R`CiI8F@hKU>m\nXlB=;)!%#j-9`dmNG*|t6t`z<ND|t=E\n\nliteral 0\nHcmV?d00001\n\ndiff --git a\/tests\/tiff\/tiff_invalid_read_3.tiff b\/tests\/tiff\/tiff_invalid_read_3.tiff\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..67ca2a7c6e1a7834bee9f15a632a3cf2d7d52819\nGIT binary patch\nliteral 428\nzcmYk1F-rqM5QX2~<w6KX(L@Dfag{`iTrOw4EP`4ZP`JXvLeMpLD}ltqyUObRMr{2%\nzT3h=M>@0O=UEvmn_s!$YEHjxLU==_KKN&YVfN&wGH)Xj_y;JdB%O3f4%Pw)Vl4%JC\nzm*m~iqIFR-`x?}5{AFsqf3uR`vJ4;Cwt4#Zdq;T3W|$|s!ZW-=yjvOWRd}D+q2+wS\nz3FVm+%AXSRAwF<M5ylSL{LZNu|22w$GzHpiGMgW-KlIAa=POpczg-x8SuR;it@l{J\nzdN*sP@3s<FTuYM=7LP^nq!v04iYza}AXoGGEmd$h9;DGoj^ZesDw#<or*fF7L8L-`\nVr1UUW_bQCTxc@NI{bHsyegQctOxyqf\n\nliteral 0\nHcmV?d00001\n\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2019-13303","CWE_ID":"125","category":"security","commit_id":"d29148fae06c01ef215940e084cf41853c117bab","commit_message":"From d29148fae06c01ef215940e084cf41853c117bab Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 18 Jun 2019 14:13:42 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1603\n\n---\n MagickCore\/composite.c | 17 +++++++++--------\n 1 file changed, 9 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/MagickCore\/composite.c b\/MagickCore\/composite.c\nindex 78d6dff921..99e91d1470 100644\n--- a\/MagickCore\/composite.c\n+++ b\/MagickCore\/composite.c\n@@ -654,18 +654,19 @@ MagickExport MagickBooleanType CompositeImage(Image *image,\n               q+=GetPixelChannels(image);\n               continue;\n             }\n-          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n+          for (i=0; i < (ssize_t) GetPixelChannels(source_image); i++)\n           {\n-            PixelChannel channel = GetPixelChannelChannel(image,i);\n-            PixelTrait traits = GetPixelChannelTraits(image,channel);\n-            PixelTrait source_traits=GetPixelChannelTraits(source_image,\n+            PixelChannel channel = GetPixelChannelChannel(source_image,i);\n+            PixelTrait source_traits = GetPixelChannelTraits(source_image,\n               channel);\n-            if (traits == UndefinedPixelTrait)\n+            PixelTrait traits = GetPixelChannelTraits(image,channel);\n+            if (source_traits == UndefinedPixelTrait)\n               continue;\n-            if (source_traits != UndefinedPixelTrait)\n+            if (traits != UndefinedPixelTrait)\n               SetPixelChannel(image,channel,p[i],q);\n-            else if (channel == AlphaPixelChannel)\n-              SetPixelChannel(image,channel,OpaqueAlpha,q);\n+            else\n+              if (channel == AlphaPixelChannel)\n+                SetPixelChannel(image,channel,OpaqueAlpha,q);\n           }\n           p+=GetPixelChannels(source_image);\n           q+=GetPixelChannels(image);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-11719","CWE_ID":"125","category":"security","commit_id":"296debd213bd6dce7647cedd34eb64e5b94cdc92","commit_message":"From 296debd213bd6dce7647cedd34eb64e5b94cdc92 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Wed, 26 Jul 2017 03:26:59 +0200\nSubject: [PATCH] avcodec\/dnxhddec: Move mb height check out of non hr branch\n\nFixes: out of array access\nFixes: poc.dnxhd\n\nFound-by: Bingchang, Liu@VARAS of IIE\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/dnxhddec.c | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/dnxhddec.c b\/libavcodec\/dnxhddec.c\nindex 40d41f9bf11..f46e41a4562 100644\n--- a\/libavcodec\/dnxhddec.c\n+++ b\/libavcodec\/dnxhddec.c\n@@ -298,14 +298,18 @@ static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,\n     if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {\n         ctx->data_offset = 0x170 + (ctx->mb_height << 2);\n     } else {\n-        if (ctx->mb_height > 68 ||\n-            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n+        if (ctx->mb_height > 68) {\n             av_log(ctx->avctx, AV_LOG_ERROR,\n                    \"mb height too big: %d\\n\", ctx->mb_height);\n             return AVERROR_INVALIDDATA;\n         }\n         ctx->data_offset = 0x280;\n     }\n+    if ((ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {\n+        av_log(ctx->avctx, AV_LOG_ERROR,\n+                \"mb height too big: %d\\n\", ctx->mb_height);\n+        return AVERROR_INVALIDDATA;\n+    }\n \n     if (buf_size < ctx->data_offset) {\n         av_log(ctx->avctx, AV_LOG_ERROR,\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-9207","CWE_ID":"125","category":"security","commit_id":"b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d","commit_message":"From b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d Mon Sep 17 00:00:00 2001\nFrom: Jason Summers <jason1@pobox.com>\nDate: Sun, 14 May 2017 12:37:43 -0400\nSubject: [PATCH] Fixed invalid memory access bugs when decoding JPEG Exif data\n\nFixes issues #22, #23, #24, #25\n---\n src\/imagew-jpeg.c | 38 +++++++++++++++++++++++++-------------\n 1 file changed, 25 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/src\/imagew-jpeg.c b\/src\/imagew-jpeg.c\nindex 43bf946..e810539 100644\n--- a\/src\/imagew-jpeg.c\n+++ b\/src\/imagew-jpeg.c\n@@ -58,6 +58,18 @@ struct iw_exif_state {\n \tsize_t d_len;\n };\n \n+static unsigned int get_exif_ui16(struct iw_exif_state *e, unsigned int pos)\n+{\n+\tif(e->d_len<2 || pos>e->d_len-2) return 0;\n+\treturn iw_get_ui16_e(&e->d[pos], e->endian);\n+}\n+\n+static unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)\n+{\n+\tif(e->d_len<4 || pos>e->d_len-4) return 0;\n+\treturn iw_get_ui32_e(&e->d[pos], e->endian);\n+}\n+\n \/\/ Try to read an Exif tag into an integer.\n \/\/ Returns zero on failure.\n static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n@@ -66,17 +78,17 @@ static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n \tunsigned int field_type;\n \tunsigned int value_count;\n \n-\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n-\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n+\tfield_type = get_exif_ui16(e, tag_pos+2);\n+\tvalue_count = get_exif_ui32(e, tag_pos+4);\n \n \tif(value_count!=1) return 0;\n \n \tif(field_type==3) { \/\/ SHORT (uint16)\n-\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n+\t\t*pv = get_exif_ui16(e, tag_pos+8);\n \t\treturn 1;\n \t}\n \telse if(field_type==4) { \/\/ LONG (uint32)\n-\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n+\t\t*pv = get_exif_ui32(e, tag_pos+8);\n \t\treturn 1;\n \t}\n \n@@ -93,8 +105,8 @@ static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n \tunsigned int value_pos;\n \tunsigned int numer, denom;\n \n-\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n-\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n+\tfield_type = get_exif_ui16(e, tag_pos+2);\n+\tvalue_count = get_exif_ui32(e, tag_pos+4);\n \n \tif(value_count!=1) return 0;\n \n@@ -103,12 +115,12 @@ static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n \t\/\/ A rational is 8 bytes. Since 8>4, it is stored indirectly. First, read\n \t\/\/ the location where it is stored.\n \n-\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n+\tvalue_pos = get_exif_ui32(e, tag_pos+8);\n \tif(value_pos > e->d_len-8) return 0;\n \n \t\/\/ Read the actual value.\n-\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n-\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n+\tnumer = get_exif_ui32(e, value_pos);\n+\tdenom = get_exif_ui32(e, value_pos+4);\n \tif(denom==0) return 0;\n \n \t*pv = ((double)numer)\/denom;\n@@ -125,15 +137,15 @@ static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n \tunsigned int v;\n \tdouble v_dbl;\n \n-\tif(ifd<8 || ifd>e->d_len-18) return;\n+\tif(ifd<8 || e->d_len<18 || ifd>e->d_len-18) return;\n \n-\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n+\ttag_count = get_exif_ui16(e, ifd);\n \tif(tag_count>1000) return; \/\/ Sanity check.\n \n \tfor(i=0;i<tag_count;i++) {\n \t\ttag_pos = ifd+2+i*12;\n \t\tif(tag_pos+12 > e->d_len) return; \/\/ Avoid overruns.\n-\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n+\t\ttag_id = get_exif_ui16(e, tag_pos);\n \n \t\tswitch(tag_id) {\n \t\tcase 274: \/\/ 274 = Orientation\n@@ -177,7 +189,7 @@ static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n \n \te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n \n-\tifd = iw_get_ui32_e(&d[4],e.endian);\n+\tifd = get_exif_ui32(&e, 4);\n \n \tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n }\n","owner":"jsummers","repo":"imageworsener","source":"cve"},{"CVE_ID":"CVE-2018-6611","CWE_ID":"125","category":"security","commit_id":"61fc6d3030a4d4283105cb5fb46b27b42fa5575e","commit_message":"From 61fc6d3030a4d4283105cb5fb46b27b42fa5575e Mon Sep 17 00:00:00 2001\nFrom: Johannes Schultz <sagamusix@openmpt.org>\nDate: Fri, 2 Feb 2018 15:42:41 +0000\nSubject: [PATCH] [Fix] STP: Possible out-of-bounds memory read with malformed\n STP files (caught with afl-fuzz).\n\ngit-svn-id: https:\/\/source.openmpt.org\/svn\/openmpt\/trunk\/OpenMPT@9567 56274372-70c3-4bfc-bfc3-4c3a0b034d27\n---\n contrib\/fuzzing\/all_formats.dict | 15 ++++----\n soundlib\/Load_stp.cpp            | 65 +++++++++++++++++---------------\n 2 files changed, 42 insertions(+), 38 deletions(-)\n\n","diff_code":"diff --git a\/contrib\/fuzzing\/all_formats.dict b\/contrib\/fuzzing\/all_formats.dict\nindex dc7042782..8761c0956 100644\n--- a\/contrib\/fuzzing\/all_formats.dict\n+++ b\/contrib\/fuzzing\/all_formats.dict\n@@ -138,9 +138,9 @@ ice=\"IT10\"\n pt36=\"CMNT\"\n pt36=\"PTDT\"\n sfx=\"SO31\"\n-# There is currently no way to fuzz external Startrekker instrument files.\n-#stam=\"ST1.3 ModuleINFO\"\n-#stam=\"AudioSculpture10\"\n+# External Startrekker instrument files.\n+stam=\"ST1.3 ModuleINFO\"\n+stam=\"AudioSculpture10\"\n \n mptm=\"->MPT_ORIGINAL_IT<-\"\n mptm=\".tpm\"\n@@ -204,10 +204,9 @@ ptm=\"\\x1A\\x03\\x02\"\n s3m=\"SCRM\"\n s3m=\"SCRS\"\n \n-stm=\"!Scream!\\x1A\\x02\"\n-#stm=\"BMOD2STM\\x1A\\x02\"\n+stm=\"\\x1A\\x02\\x15\"\n \n-stp=\"STP3\\x00\"\n+stp=\"STP3\\x02\"\n \n ult=\"MAS_UTrack_V004\"\n \n@@ -217,7 +216,7 @@ umx=\"sound\"\n \n xm=\"Extended Module: \"\n xm=\"OpenMPT \"\n-xm=\"FastTracker v 2.00  \"\n+#xm=\"FastTracker v 2.00  \"\n xm=\"MilkyTracker        \"\n xm=\"text\"\n xm=\"MIDI\"\n@@ -302,4 +301,4 @@ plugin_dbproecho=\"DBM0Echo\"\n midi=\"MThd\\x00\\x00\\x00\\x06\\x00\\x01\\x00\\x01\\x01\\xE0MTrk\"\n \n wave=\"WAVEfmt \"\n-wave=\"data\"\n\\ No newline at end of file\n+wave=\"data\"\ndiff --git a\/soundlib\/Load_stp.cpp b\/soundlib\/Load_stp.cpp\nindex 207521d7e..4389a4f35 100644\n--- a\/soundlib\/Load_stp.cpp\n+++ b\/soundlib\/Load_stp.cpp\n@@ -20,7 +20,7 @@\n \n OPENMPT_NAMESPACE_BEGIN\n \n-\/\/ File header (except for \"STP3\" magic)\n+\/\/ File header\n struct STPFileHeader\n {\n \tchar     magic[4];\n@@ -108,10 +108,14 @@ static TEMPO ConvertTempo(uint16 ciaSpeed)\n \n static void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)\n {\n-\tif(!src.HasSampleData()) return;\n+\tif(!src.HasSampleData()\n+\t\t|| start >= src.nLength\n+\t\t|| src.nLength - start < len)\n+\t{\n+\t\treturn;\n+\t}\n \n \tdest.FreeSample();\n-\n \tdest = src;\n \tdest.nLength = len;\n \tdest.pSample = nullptr;\n@@ -150,16 +154,16 @@ static void ConvertLoopSequence(ModSample &smp, STPLoopList &loopList)\n \n \tsize_t numLoops = loopList.size();\n \n-\t\/\/ get the total length of the sample after combining all looped sections\n+\t\/\/ Get the total length of the sample after combining all looped sections\n \tfor(size_t i = 0; i < numLoops; i++)\n \t{\n \t\tSTPLoopInfo &info = loopList[i];\n \n-\t\t\/\/ if adding this loop would cause the sample length to exceed maximum,\n+\t\t\/\/ If adding this loop would cause the sample length to exceed maximum,\n \t\t\/\/ then limit and bail out\n-\t\tif((newSmp.nLength + info.loopLength > MAX_SAMPLE_LENGTH) ||\n-\t\t   (info.loopLength > MAX_SAMPLE_LENGTH) ||\n-\t\t   (info.loopStart + info.loopLength > smp.nLength))\n+\t\tif(info.loopStart >= smp.nLength\n+\t\t\t|| smp.nLength - info.loopStart < info.loopLength\n+\t\t\t|| newSmp.nLength > MAX_SAMPLE_LENGTH - info.loopLength)\n \t\t{\n \t\t\tnumLoops = i;\n \t\t\tbreak;\n@@ -264,7 +268,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \tReadOrderFromArray(Order(), fileHeader.orderList, fileHeader.numOrders);\n \n \tstd::vector<STPLoopList> loopInfo;\n-\t\/\/ non-looped versions of samples with loops (when needed)\n+\t\/\/ Non-looped versions of samples with loops (when needed)\n \tstd::vector<SAMPLEINDEX> nonLooped;\n \n \t\/\/ Load sample headers\n@@ -380,6 +384,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t};\n \tstd::vector<ChannelMemory> channelMemory(m_nChannels);\n \tuint8 globalVolSlide = 0;\n+\tuint8 speedFrac = static_cast<uint8>(fileHeader.speedFrac);\n \n \tfor(uint16 pat = 0; pat < numPatterns; pat++)\n \t{\n@@ -409,7 +414,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \n \t\t\t\/\/ if a fractional speed value is in use then determine if we should stick a fine pattern delay somewhere\n \t\t\tbool shouldDelay;\n-\t\t\tswitch(fileHeader.speedFrac & 3)\n+\t\t\tswitch(speedFrac & 3)\n \t\t\t{\n \t\t\tdefault: shouldDelay = false; break;\n \t\t\t\/\/ 1\/4\n@@ -475,7 +480,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\tchnMem.autoPortaDown = 0;\n \t\t\t\t\tchnMem.autoTonePorta = 0;\n \n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x04: \/\/ auto fine portamento down\n@@ -484,7 +489,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\tchnMem.autoPortaDown = 0;\n \t\t\t\t\tchnMem.autoTonePorta = 0;\n \n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x05: \/\/ auto portamento up\n@@ -493,7 +498,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\tchnMem.autoPortaDown = 0;\n \t\t\t\t\tchnMem.autoTonePorta = 0;\n \n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x06: \/\/ auto portamento down\n@@ -502,7 +507,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\tchnMem.autoPortaDown = m.param;\n \t\t\t\t\tchnMem.autoTonePorta = 0;\n \n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x07: \/\/ set global volume\n@@ -512,7 +517,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \n \t\t\t\tcase 0x08: \/\/ auto global fine volume slide\n \t\t\t\t\tglobalVolSlide = swapped;\n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x09: \/\/ fine portamento up\n@@ -527,14 +532,14 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \n \t\t\t\tcase 0x0B: \/\/ auto fine volume slide\n \t\t\t\t\tchnMem.autoVolSlide = swapped;\n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x0C: \/\/ set volume\n \t\t\t\t\tm.volcmd = VOLCMD_VOLUME;\n \t\t\t\t\tm.vol = m.param;\n \t\t\t\t\tchnMem.autoVolSlide = 0;\n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x0D: \/\/ volume slide (param is swapped compared to .mod)\n@@ -548,7 +553,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\t\tm.vol = m.param & 0xF;\n \t\t\t\t\t}\n \t\t\t\t\tchnMem.autoVolSlide = 0;\n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x0E: \/\/ set filter (also uses opposite value compared to .mod)\n@@ -558,14 +563,14 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \n \t\t\t\tcase 0x0F: \/\/ set speed\n \t\t\t\t\tm.command = CMD_SPEED;\n-\t\t\t\t\tfileHeader.speedFrac = m.param & 0xF;\n+\t\t\t\t\tspeedFrac = m.param & 0x0F;\n \t\t\t\t\tm.param >>= 4;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x10: \/\/ auto vibrato\n \t\t\t\t\tchnMem.autoVibrato = m.param;\n \t\t\t\t\tchnMem.vibratoMem = 0;\n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x11: \/\/ auto tremolo\n@@ -573,7 +578,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\t\tchnMem.autoTremolo = m.param;\n \t\t\t\t\telse\n \t\t\t\t\t\tchnMem.autoTremolo = 0;\n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x12: \/\/ pattern break\n@@ -587,7 +592,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\tchnMem.autoTonePorta = m.param;\n \n \t\t\t\t\tchnMem.tonePortaMem = 0;\n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x14: \/\/ position jump\n@@ -607,7 +612,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x17: \/\/ play only loop nn\n@@ -624,7 +629,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x18: \/\/ play sequence without loop\n@@ -644,7 +649,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\t\tm.instr = static_cast<ModCommand::INSTR>(nonLooped[m.instr - 1]);\n \t\t\t\t\t}\n \n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x19: \/\/ play only loop nn without loop\n@@ -661,7 +666,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n-\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x1D: \/\/ fine volume slide (nibble order also swapped)\n@@ -679,7 +684,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\tif(m.param & 0xF0)\n \t\t\t\t\t{\n \t\t\t\t\t\tchnMem.autoVolSlide = m.param >> 4;\n-\t\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\t} else\n \t\t\t\t\t{\n \t\t\t\t\t\tm.command = CMD_MODCMDEX;\n@@ -705,14 +710,14 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\t\tif((m.param & 0xF0) == 0x60 || (m.param & 0xF0) == 0xE0)\n \t\t\t\t\t\tm.command = CMD_MODCMDEX;\n \t\t\t\t\telse\n-\t\t\t\t\t\tm.command = m.param = 0;\n+\t\t\t\t\t\tm.command = CMD_NONE;\n \t\t\t\t\tbreak;\n \n \t\t\t\tcase 0x4F: \/\/ set speed\/tempo\n \t\t\t\t\tif(m.param < 0x20)\n \t\t\t\t\t{\n \t\t\t\t\t\tm.command = CMD_SPEED;\n-\t\t\t\t\t\tfileHeader.speedFrac = 0;\n+\t\t\t\t\t\tspeedFrac = 0;\n \t\t\t\t\t} else\n \t\t\t\t\t{\n \t\t\t\t\t\tm.command = CMD_TEMPO;\n@@ -727,7 +732,7 @@ bool CSoundFile::ReadSTP(FileReader &file, ModLoadingFlags loadFlags)\n \t\t\t\tbool didVolSlide = false;\n \n \t\t\t\t\/\/ try to put volume slide in volume command\n-\t\t\t\tif(chnMem.autoVolSlide && !m.volcmd)\n+\t\t\t\tif(chnMem.autoVolSlide && m.volcmd == VOLCMD_NONE)\n \t\t\t\t{\n \t\t\t\t\tif(chnMem.autoVolSlide & 0xF0)\n \t\t\t\t\t{\n","owner":"OpenMPT","repo":"openmpt","source":"cve"},{"CVE_ID":"CVE-2019-11339","CWE_ID":"125","category":"security","commit_id":"1f686d023b95219db933394a7704ad9aa5f01cbb","commit_message":"From 1f686d023b95219db933394a7704ad9aa5f01cbb Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Fri, 15 Feb 2019 01:57:09 +0100\nSubject: [PATCH] avcodec\/mpeg4videodec: Clear interlaced_dct for studio\n profile\n\nFixes: Out of array access\nFixes: 13090\/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_MPEG4_fuzzer-5408668986638336\n\nFound-by: continuous fuzzing process https:\/\/github.com\/google\/oss-fuzz\/tree\/master\/projects\/ffmpeg\nReviewed-by: Kieran Kunhya <kierank@obe.tv>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/mpeg4videodec.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/libavcodec\/mpeg4videodec.c b\/libavcodec\/mpeg4videodec.c\nindex f44ee76bd41..ecd028a87c7 100644\n--- a\/libavcodec\/mpeg4videodec.c\n+++ b\/libavcodec\/mpeg4videodec.c\n@@ -3057,6 +3057,7 @@ static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n         return 0;\n \n     s->partitioned_frame = 0;\n+    s->interlaced_dct = 0;\n     s->decode_mb = mpeg4_decode_studio_mb;\n \n     decode_smpte_tc(ctx, gb);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-9204","CWE_ID":"125","category":"security","commit_id":"b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d","commit_message":"From b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d Mon Sep 17 00:00:00 2001\nFrom: Jason Summers <jason1@pobox.com>\nDate: Sun, 14 May 2017 12:37:43 -0400\nSubject: [PATCH] Fixed invalid memory access bugs when decoding JPEG Exif data\n\nFixes issues #22, #23, #24, #25\n---\n src\/imagew-jpeg.c | 38 +++++++++++++++++++++++++-------------\n 1 file changed, 25 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/src\/imagew-jpeg.c b\/src\/imagew-jpeg.c\nindex 43bf946..e810539 100644\n--- a\/src\/imagew-jpeg.c\n+++ b\/src\/imagew-jpeg.c\n@@ -58,6 +58,18 @@ struct iw_exif_state {\n \tsize_t d_len;\n };\n \n+static unsigned int get_exif_ui16(struct iw_exif_state *e, unsigned int pos)\n+{\n+\tif(e->d_len<2 || pos>e->d_len-2) return 0;\n+\treturn iw_get_ui16_e(&e->d[pos], e->endian);\n+}\n+\n+static unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)\n+{\n+\tif(e->d_len<4 || pos>e->d_len-4) return 0;\n+\treturn iw_get_ui32_e(&e->d[pos], e->endian);\n+}\n+\n \/\/ Try to read an Exif tag into an integer.\n \/\/ Returns zero on failure.\n static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n@@ -66,17 +78,17 @@ static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n \tunsigned int field_type;\n \tunsigned int value_count;\n \n-\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n-\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n+\tfield_type = get_exif_ui16(e, tag_pos+2);\n+\tvalue_count = get_exif_ui32(e, tag_pos+4);\n \n \tif(value_count!=1) return 0;\n \n \tif(field_type==3) { \/\/ SHORT (uint16)\n-\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n+\t\t*pv = get_exif_ui16(e, tag_pos+8);\n \t\treturn 1;\n \t}\n \telse if(field_type==4) { \/\/ LONG (uint32)\n-\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n+\t\t*pv = get_exif_ui32(e, tag_pos+8);\n \t\treturn 1;\n \t}\n \n@@ -93,8 +105,8 @@ static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n \tunsigned int value_pos;\n \tunsigned int numer, denom;\n \n-\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n-\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n+\tfield_type = get_exif_ui16(e, tag_pos+2);\n+\tvalue_count = get_exif_ui32(e, tag_pos+4);\n \n \tif(value_count!=1) return 0;\n \n@@ -103,12 +115,12 @@ static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n \t\/\/ A rational is 8 bytes. Since 8>4, it is stored indirectly. First, read\n \t\/\/ the location where it is stored.\n \n-\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n+\tvalue_pos = get_exif_ui32(e, tag_pos+8);\n \tif(value_pos > e->d_len-8) return 0;\n \n \t\/\/ Read the actual value.\n-\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n-\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n+\tnumer = get_exif_ui32(e, value_pos);\n+\tdenom = get_exif_ui32(e, value_pos+4);\n \tif(denom==0) return 0;\n \n \t*pv = ((double)numer)\/denom;\n@@ -125,15 +137,15 @@ static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n \tunsigned int v;\n \tdouble v_dbl;\n \n-\tif(ifd<8 || ifd>e->d_len-18) return;\n+\tif(ifd<8 || e->d_len<18 || ifd>e->d_len-18) return;\n \n-\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n+\ttag_count = get_exif_ui16(e, ifd);\n \tif(tag_count>1000) return; \/\/ Sanity check.\n \n \tfor(i=0;i<tag_count;i++) {\n \t\ttag_pos = ifd+2+i*12;\n \t\tif(tag_pos+12 > e->d_len) return; \/\/ Avoid overruns.\n-\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n+\t\ttag_id = get_exif_ui16(e, tag_pos);\n \n \t\tswitch(tag_id) {\n \t\tcase 274: \/\/ 274 = Orientation\n@@ -177,7 +189,7 @@ static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n \n \te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n \n-\tifd = iw_get_ui32_e(&d[4],e.endian);\n+\tifd = get_exif_ui32(&e, 4);\n \n \tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n }\n","owner":"jsummers","repo":"imageworsener","source":"cve"},{"CVE_ID":"CVE-2017-9224","CWE_ID":"125","category":"security","commit_id":"690313a061f7a4fa614ec5cc8368b4f2284e059b","commit_message":"From 690313a061f7a4fa614ec5cc8368b4f2284e059b Mon Sep 17 00:00:00 2001\nFrom: \"K.Kosako\" <kosako@sofnec.co.jp>\nDate: Tue, 23 May 2017 10:28:58 +0900\nSubject: [PATCH] fix #57 : DATA_ENSURE() check must be before data access\n\n---\n src\/regexec.c | 5 -----\n 1 file changed, 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/regexec.c b\/src\/regexec.c\nindex 35fef11..d4e577d 100644\n--- a\/src\/regexec.c\n+++ b\/src\/regexec.c\n@@ -1473,14 +1473,9 @@ match_at(regex_t* reg, const UChar* str, const UChar* end,\n       break;\n \n     case OP_EXACT1:  MOP_IN(OP_EXACT1);\n-#if 0\n       DATA_ENSURE(1);\n       if (*p != *s) goto fail;\n       p++; s++;\n-#endif\n-      if (*p != *s++) goto fail;\n-      DATA_ENSURE(0);\n-      p++;\n       MOP_OUT;\n       break;\n \n","owner":"kkos","repo":"oniguruma","source":"cve"},{"CVE_ID":"CVE-2016-10170","CWE_ID":"125","category":"security","commit_id":"4bc05fc490b66ef2d45b1de26abf1455b486b0dc","commit_message":"From 4bc05fc490b66ef2d45b1de26abf1455b486b0dc Mon Sep 17 00:00:00 2001\nFrom: David Bryant <david@wavpack.com>\nDate: Wed, 21 Dec 2016 22:18:36 -0800\nSubject: [PATCH] fixes for 4 fuzz failures posted to SourceForge mailing list\n\n---\n src\/open_utils.c | 6 +++++-\n src\/read_words.c | 4 ++++\n 2 files changed, 9 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/open_utils.c b\/src\/open_utils.c\nindex 7519f99..a844046 100644\n--- a\/src\/open_utils.c\n+++ b\/src\/open_utils.c\n@@ -560,7 +560,7 @@ static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n \n     \/\/ if there's any data, the first two bytes are file_format and qmode flags\n \n-    if (bytecnt) {\n+    if (bytecnt >= 2) {\n         wpc->file_format = *byteptr++;\n         wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n         bytecnt -= 2;\n@@ -593,6 +593,10 @@ static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n                         for (i = 0; i < nchans; ++i)\n                             if (bytecnt) {\n                                 wpc->channel_reordering [i] = *byteptr++;\n+\n+                                if (wpc->channel_reordering [i] >= nchans)  \/\/ make sure index is in range\n+                                    wpc->channel_reordering [i] = 0;\n+\n                                 bytecnt--;\n                             }\n                             else\ndiff --git a\/src\/read_words.c b\/src\/read_words.c\nindex 62acac3..a537bfa 100644\n--- a\/src\/read_words.c\n+++ b\/src\/read_words.c\n@@ -288,6 +288,10 @@ int32_t FASTCALL get_word (WavpackStream *wps, int chan, int32_t *correction)\n \n     low &= 0x7fffffff;\n     high &= 0x7fffffff;\n+\n+    if (low > high)         \/\/ make sure high and low make sense\n+        high = low;\n+\n     mid = (high + low + 1) >> 1;\n \n     if (!c->error_limit)\n","owner":"dbry","repo":"WavPack","source":"cve"},{"CVE_ID":"CVE-2018-11376","CWE_ID":"125","category":"security","commit_id":"1f37c04f2a762500222dda2459e6a04646feeedf","commit_message":"From 1f37c04f2a762500222dda2459e6a04646feeedf Mon Sep 17 00:00:00 2001\nFrom: radare <pancake@nopcode.org>\nDate: Wed, 18 Apr 2018 13:38:22 +0200\nSubject: [PATCH] Fix #9904 - crash in r2_hoobr_r_read_le32 (over 9000\n entrypoints) and read_le oobread (#9923)\n\n---\n libr\/bin\/p\/bin_elf.c | 4 ++--\n libr\/core\/cbin.c     | 4 ++++\n 2 files changed, 6 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libr\/bin\/p\/bin_elf.c b\/libr\/bin\/p\/bin_elf.c\nindex c766d5b900..f2043dbc8c 100644\n--- a\/libr\/bin\/p\/bin_elf.c\n+++ b\/libr\/bin\/p\/bin_elf.c\n@@ -348,7 +348,7 @@ static void process_constructors (RBinFile *bf, RList *ret, int bits) {\n \t\t\t}\n \t\t\t(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);\n \t\t\tif (bits == 32) {\n-\t\t\t\tfor (i = 0; i < sec->size; i += 4) {\n+\t\t\t\tfor (i = 0; (i + 3) < sec->size; i += 4) {\n \t\t\t\t\tut32 addr32 = r_read_le32 (buf + i);\n \t\t\t\t\tif (addr32) {\n \t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);\n@@ -356,7 +356,7 @@ static void process_constructors (RBinFile *bf, RList *ret, int bits) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tfor (i = 0; i < sec->size; i += 8) {\n+\t\t\t\tfor (i = 0; (i + 7) < sec->size; i += 8) {\n \t\t\t\t\tut64 addr64 = r_read_le64 (buf + i);\n \t\t\t\t\tif (addr64) {\n \t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);\ndiff --git a\/libr\/core\/cbin.c b\/libr\/core\/cbin.c\nindex b8c9d554d1..523ddcad48 100644\n--- a\/libr\/core\/cbin.c\n+++ b\/libr\/core\/cbin.c\n@@ -1044,6 +1044,10 @@ static int bin_entry(RCore *r, int mode, ut64 laddr, int va, bool inifin) {\n \t\t\tr_cons_printf (\"[Entrypoints]\\n\");\n \t\t}\n \t}\n+\tif (r_list_length (entries) > 1024) {\n+\t\teprintf (\"Too many entrypoints (%d)\\n\", r_list_length (entries));\n+\t\treturn false;\n+\t}\n \n \tr_list_foreach (entries, iter, entry) {\n \t\tut64 paddr = entry->paddr;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2018-17292","CWE_ID":"125","category":"security","commit_id":"2de6cf70c5ef31e22ed119a25ac2daeefd3d18a1","commit_message":"From 2de6cf70c5ef31e22ed119a25ac2daeefd3d18a1 Mon Sep 17 00:00:00 2001\nFrom: Andrew Scheidecker <andrew@scheidecker.net>\nDate: Sun, 16 Sep 2018 08:20:54 -0400\nSubject: [PATCH] Fix out-of-bounds array access when passing a <4 byte input\n file to wavm or wavm-compile\n\n---\n Include\/Inline\/CLI.h | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/Include\/Inline\/CLI.h b\/Include\/Inline\/CLI.h\nindex 2cd490c0..05d0c614 100644\n--- a\/Include\/Inline\/CLI.h\n+++ b\/Include\/Inline\/CLI.h\n@@ -144,7 +144,7 @@ inline bool loadModule(const char* filename, IR::Module& outModule)\n \tif(!loadFile(filename, fileBytes)) { return false; }\n \n \t\/\/ If the file starts with the WASM binary magic number, load it as a binary irModule.\n-\tif(*(U32*)fileBytes.data() == 0x6d736100)\n+\tif(fileBytes.size() >= 4 && *(U32*)fileBytes.data() == 0x6d736100)\n \t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n \telse\n \t{\n","owner":"WAVM","repo":"WAVM","source":"cve"},{"CVE_ID":"CVE-2016-9555","CWE_ID":"125","category":"security","commit_id":"bf911e985d6bbaa328c20c3e05f4eb03de11fdd6","commit_message":"From bf911e985d6bbaa328c20c3e05f4eb03de11fdd6 Mon Sep 17 00:00:00 2001\nFrom: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>\nDate: Tue, 25 Oct 2016 14:27:39 -0200\nSubject: [PATCH] sctp: validate chunk len before actually using it\n\nAndrey Konovalov reported that KASAN detected that SCTP was using a slab\nbeyond the boundaries. It was caused because when handling out of the\nblue packets in function sctp_sf_ootb() it was checking the chunk len\nonly after already processing the first chunk, validating only for the\n2nd and subsequent ones.\n\nThe fix is to just move the check upwards so it's also validated for the\n1st chunk.\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>\nReviewed-by: Xin Long <lucien.xin@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/sctp\/sm_statefuns.c | 12 ++++++------\n 1 file changed, 6 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/net\/sctp\/sm_statefuns.c b\/net\/sctp\/sm_statefuns.c\nindex 026e3bca4a94b..8ec20a64a3f80 100644\n--- a\/net\/sctp\/sm_statefuns.c\n+++ b\/net\/sctp\/sm_statefuns.c\n@@ -3422,6 +3422,12 @@ sctp_disposition_t sctp_sf_ootb(struct net *net,\n \t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n \t\t\t\t\t\t  commands);\n \n+\t\t\/* Report violation if chunk len overflows *\/\n+\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n+\t\tif (ch_end > skb_tail_pointer(skb))\n+\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n+\t\t\t\t\t\t  commands);\n+\n \t\t\/* Now that we know we at least have a chunk header,\n \t\t * do things that are type appropriate.\n \t\t *\/\n@@ -3453,12 +3459,6 @@ sctp_disposition_t sctp_sf_ootb(struct net *net,\n \t\t\t}\n \t\t}\n \n-\t\t\/* Report violation if chunk len overflows *\/\n-\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n-\t\tif (ch_end > skb_tail_pointer(skb))\n-\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n-\t\t\t\t\t\t  commands);\n-\n \t\tch = (sctp_chunkhdr_t *) ch_end;\n \t} while (ch_end < skb_tail_pointer(skb));\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7163","CWE_ID":"125","category":"security","commit_id":"ef01f18dfc6780b776d0674ed3e7415c6ef54d24","commit_message":"From ef01f18dfc6780b776d0674ed3e7415c6ef54d24 Mon Sep 17 00:00:00 2001\nFrom: Matthieu Darbois <mayeut@users.noreply.github.com>\nDate: Thu, 8 Sep 2016 07:34:46 +0200\nSubject: [PATCH] Cast to size_t before multiplication\n\nNeed to cast to size_t before multiplication otherwise overflow check is useless.\n---\n src\/lib\/openjp2\/pi.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/lib\/openjp2\/pi.c b\/src\/lib\/openjp2\/pi.c\nindex 36e2ff0cf..809b33d73 100644\n--- a\/src\/lib\/openjp2\/pi.c\n+++ b\/src\/lib\/openjp2\/pi.c\n@@ -1241,7 +1241,7 @@ opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,\n \tl_current_pi->include = 00;\n \tif (l_step_l <= (SIZE_MAX \/ (l_tcp->numlayers + 1U)))\n \t{\n-\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n+\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((size_t)(l_tcp->numlayers + 1U) * l_step_l, sizeof(OPJ_INT16));\n \t}\n \n \tif\n","owner":"uclouvain","repo":"openjpeg","source":"cve"},{"CVE_ID":"CVE-2016-7917","CWE_ID":"125","category":"security","commit_id":"c58d6c93680f28ac58984af61d0a7ebf4319c241","commit_message":"From c58d6c93680f28ac58984af61d0a7ebf4319c241 Mon Sep 17 00:00:00 2001\nFrom: Phil Turnbull <phil.turnbull@oracle.com>\nDate: Tue, 2 Feb 2016 13:36:45 -0500\nSubject: netfilter: nfnetlink: correctly validate length of batch messages\n\nIf nlh->nlmsg_len is zero then an infinite loop is triggered because\n'skb_pull(skb, msglen);' pulls zero bytes.\n\nThe calculation in nlmsg_len() underflows if 'nlh->nlmsg_len <\nNLMSG_HDRLEN' which bypasses the length validation and will later\ntrigger an out-of-bound read.\n\nIf the length validation does fail then the malformed batch message is\ncopied back to userspace. However, we cannot do this because the\nnlh->nlmsg_len can be invalid. This leads to an out-of-bounds read in\nnetlink_ack:\n\n    [   41.455421] ==================================================================\n    [   41.456431] BUG: KASAN: slab-out-of-bounds in memcpy+0x1d\/0x40 at addr ffff880119e79340\n    [   41.456431] Read of size 4294967280 by task a.out\/987\n    [   41.456431] =============================================================================\n    [   41.456431] BUG kmalloc-512 (Not tainted): kasan: bad access detected\n    [   41.456431] -----------------------------------------------------------------------------\n    ...\n    [   41.456431] Bytes b4 ffff880119e79310: 00 00 00 00 d5 03 00 00 b0 fb fe ff 00 00 00 00  ................\n    [   41.456431] Object ffff880119e79320: 20 00 00 00 10 00 05 00 00 00 00 00 00 00 00 00   ...............\n    [   41.456431] Object ffff880119e79330: 14 00 0a 00 01 03 fc 40 45 56 11 22 33 10 00 05  .......@EV.\"3...\n    [   41.456431] Object ffff880119e79340: f0 ff ff ff 88 99 aa bb 00 14 00 0a 00 06 fe fb  ................\n                                            ^^ start of batch nlmsg with\n                                               nlmsg_len=4294967280\n    ...\n    [   41.456431] Memory state around the buggy address:\n    [   41.456431]  ffff880119e79400: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n    [   41.456431]  ffff880119e79480: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n    [   41.456431] >ffff880119e79500: 00 00 00 00 fc fc fc fc fc fc fc fc fc fc fc fc\n    [   41.456431]                                ^\n    [   41.456431]  ffff880119e79580: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n    [   41.456431]  ffff880119e79600: fc fc fc fc fc fc fc fc fc fc fb fb fb fb fb fb\n    [   41.456431] ==================================================================\n\nFix this with better validation of nlh->nlmsg_len and by setting\nNFNL_BATCH_FAILURE if any batch message fails length validation.\n\nCAP_NET_ADMIN is required to trigger the bugs.\n\nFixes: 9ea2aa8b7dba (\"netfilter: nfnetlink: validate nfnetlink header from batch\")\nSigned-off-by: Phil Turnbull <phil.turnbull@oracle.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>\n---\n net\/netfilter\/nfnetlink.c | 10 ++++++----\n 1 file changed, 6 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/net\/netfilter\/nfnetlink.c b\/net\/netfilter\/nfnetlink.c\nindex 62e92af2384a..857ae89633af 100644\n--- a\/net\/netfilter\/nfnetlink.c\n+++ b\/net\/netfilter\/nfnetlink.c\n@@ -328,10 +328,12 @@ replay:\n \t\tnlh = nlmsg_hdr(skb);\n \t\terr = 0;\n \n-\t\tif (nlmsg_len(nlh) < sizeof(struct nfgenmsg) ||\n-\t\t    skb->len < nlh->nlmsg_len) {\n-\t\t\terr = -EINVAL;\n-\t\t\tgoto ack;\n+\t\tif (nlh->nlmsg_len < NLMSG_HDRLEN ||\n+\t\t    skb->len < nlh->nlmsg_len ||\n+\t\t    nlmsg_len(nlh) < sizeof(struct nfgenmsg)) {\n+\t\t\tnfnl_err_reset(&err_list);\n+\t\t\tstatus |= NFNL_BATCH_FAILURE;\n+\t\t\tgoto done;\n \t\t}\n \n \t\t\/* Only requests are handled by the kernel *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-10161","CWE_ID":"125","category":"security","commit_id":"16b3003ffc6393e250f069aa28a78dc5a2c064b2","commit_message":"From 16b3003ffc6393e250f069aa28a78dc5a2c064b2 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Fri, 30 Dec 2016 16:59:46 -0800\nSubject: [PATCH] Fix bug #73825 - Heap out of bounds read on unserialize in\n finish_nested_data()\n\n---\n ext\/standard\/tests\/serialize\/bug73825.phpt | 12 ++++\n ext\/standard\/var_unserializer.c            | 80 +++++++++++++---------\n ext\/standard\/var_unserializer.re           | 20 +++++-\n 3 files changed, 76 insertions(+), 36 deletions(-)\n create mode 100644 ext\/standard\/tests\/serialize\/bug73825.phpt\n\n","diff_code":"diff --git a\/ext\/standard\/tests\/serialize\/bug73825.phpt b\/ext\/standard\/tests\/serialize\/bug73825.phpt\nnew file mode 100644\nindex 000000000000..adbfca1bbb17\n--- \/dev\/null\n+++ b\/ext\/standard\/tests\/serialize\/bug73825.phpt\n@@ -0,0 +1,12 @@\n+--TEST--\n+Bug #73825 Heap out of bounds read on unserialize in finish_nested_data()\n+--FILE--\n+<?php\n+$obj = unserialize('O:8:\"00000000\":');\n+var_dump($obj);\n+?>\n+--EXPECTF--\n+Warning: Bad unserialize data in %sbug73825.php on line %d\n+\n+Notice: unserialize(): Error at offset 13 of 15 bytes in %sbug73825.php on line %d\n+bool(false)\ndiff --git a\/ext\/standard\/var_unserializer.c b\/ext\/standard\/var_unserializer.c\nindex 549149267eb2..efb0942b05dd 100644\n--- a\/ext\/standard\/var_unserializer.c\n+++ b\/ext\/standard\/var_unserializer.c\n@@ -405,6 +405,11 @@ static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n {\n \tlong elements;\n \n+\tif( *p >= max - 2) {\n+\t\tzend_error(E_WARNING, \"Bad unserialize data\");\n+\t\treturn -1;\n+\t}\n+\n \telements = parse_iv2((*p) + 2, p);\n \n \t(*p) += 2;\n@@ -415,7 +420,7 @@ static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n \t\t\/* If this class implements Serializable, it should not land here but in object_custom(). The passed string\n \t\tobviously doesn't descend from the regular serializer. *\/\n \t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n-\t\treturn 0;\n+\t\treturn -1;\n \t}\n \n \treturn elements;\n@@ -492,7 +497,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \n \n \n-#line 496 \"ext\/standard\/var_unserializer.c\"\n+#line 501 \"ext\/standard\/var_unserializer.c\"\n {\n \tYYCTYPE yych;\n \tstatic const unsigned char yybm[] = {\n@@ -552,9 +557,9 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych == ':') goto yy95;\n yy3:\n-#line 861 \"ext\/standard\/var_unserializer.re\"\n+#line 875 \"ext\/standard\/var_unserializer.re\"\n \t{ return 0; }\n-#line 558 \"ext\/standard\/var_unserializer.c\"\n+#line 563 \"ext\/standard\/var_unserializer.c\"\n yy4:\n \tyych = *(YYMARKER = ++YYCURSOR);\n \tif (yych == ':') goto yy89;\n@@ -597,13 +602,13 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tgoto yy3;\n yy14:\n \t++YYCURSOR;\n-#line 855 \"ext\/standard\/var_unserializer.re\"\n+#line 869 \"ext\/standard\/var_unserializer.re\"\n \t{\n \t\/* this is the case where we have less data than planned *\/\n \tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Unexpected end of serialized data\");\n \treturn 0; \/* not sure if it should be 0 or 1 here? *\/\n }\n-#line 607 \"ext\/standard\/var_unserializer.c\"\n+#line 612 \"ext\/standard\/var_unserializer.c\"\n yy16:\n \tyych = *++YYCURSOR;\n \tgoto yy3;\n@@ -634,7 +639,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tyych = *++YYCURSOR;\n \tif (yych != '\"') goto yy18;\n \t++YYCURSOR;\n-#line 708 \"ext\/standard\/var_unserializer.re\"\n+#line 717 \"ext\/standard\/var_unserializer.re\"\n \t{\n \tsize_t len, len2, len3, maxlen;\n \tlong elements;\n@@ -774,6 +779,11 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \n \telements = object_common1(UNSERIALIZE_PASSTHRU, ce);\n \n+\tif (elements < 0) {\n+\t   efree(class_name);\n+\t   return 0;\n+\t}\n+\n \tif (incomplete_class) {\n \t\tphp_store_class_name(*rval, class_name, len2);\n \t}\n@@ -781,7 +791,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \n \treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n }\n-#line 785 \"ext\/standard\/var_unserializer.c\"\n+#line 795 \"ext\/standard\/var_unserializer.c\"\n yy25:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n@@ -806,16 +816,20 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tyych = *++YYCURSOR;\n \tif (yych != '\"') goto yy18;\n \t++YYCURSOR;\n-#line 699 \"ext\/standard\/var_unserializer.re\"\n+#line 704 \"ext\/standard\/var_unserializer.re\"\n \t{\n+\tlong elements;\n     if (!var_hash) return 0;\n \n \tINIT_PZVAL(*rval);\n \n-\treturn object_common2(UNSERIALIZE_PASSTHRU,\n-\t\t\tobject_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR));\n+\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n+\tif (elements < 0) {\n+\t\treturn 0;\n+\t}\n+\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n }\n-#line 819 \"ext\/standard\/var_unserializer.c\"\n+#line 833 \"ext\/standard\/var_unserializer.c\"\n yy32:\n \tyych = *++YYCURSOR;\n \tif (yych == '+') goto yy33;\n@@ -836,7 +850,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tyych = *++YYCURSOR;\n \tif (yych != '{') goto yy18;\n \t++YYCURSOR;\n-#line 678 \"ext\/standard\/var_unserializer.re\"\n+#line 683 \"ext\/standard\/var_unserializer.re\"\n \t{\n \tlong elements = parse_iv(start + 2);\n \t\/* use iv() not uiv() in order to check data range *\/\n@@ -857,7 +871,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \n \treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n }\n-#line 861 \"ext\/standard\/var_unserializer.c\"\n+#line 875 \"ext\/standard\/var_unserializer.c\"\n yy39:\n \tyych = *++YYCURSOR;\n \tif (yych == '+') goto yy40;\n@@ -878,7 +892,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tyych = *++YYCURSOR;\n \tif (yych != '\"') goto yy18;\n \t++YYCURSOR;\n-#line 643 \"ext\/standard\/var_unserializer.re\"\n+#line 648 \"ext\/standard\/var_unserializer.re\"\n \t{\n \tsize_t len, maxlen;\n \tchar *str;\n@@ -913,7 +927,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tZVAL_STRINGL(*rval, str, len, 0);\n \treturn 1;\n }\n-#line 917 \"ext\/standard\/var_unserializer.c\"\n+#line 931 \"ext\/standard\/var_unserializer.c\"\n yy46:\n \tyych = *++YYCURSOR;\n \tif (yych == '+') goto yy47;\n@@ -934,7 +948,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tyych = *++YYCURSOR;\n \tif (yych != '\"') goto yy18;\n \t++YYCURSOR;\n-#line 610 \"ext\/standard\/var_unserializer.re\"\n+#line 615 \"ext\/standard\/var_unserializer.re\"\n \t{\n \tsize_t len, maxlen;\n \tchar *str;\n@@ -967,7 +981,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tZVAL_STRINGL(*rval, str, len, 1);\n \treturn 1;\n }\n-#line 971 \"ext\/standard\/var_unserializer.c\"\n+#line 985 \"ext\/standard\/var_unserializer.c\"\n yy53:\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') {\n@@ -1055,7 +1069,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \t}\n yy63:\n \t++YYCURSOR;\n-#line 600 \"ext\/standard\/var_unserializer.re\"\n+#line 605 \"ext\/standard\/var_unserializer.re\"\n \t{\n #if SIZEOF_LONG == 4\n use_double:\n@@ -1065,7 +1079,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tZVAL_DOUBLE(*rval, zend_strtod((const char *)start + 2, NULL));\n \treturn 1;\n }\n-#line 1069 \"ext\/standard\/var_unserializer.c\"\n+#line 1083 \"ext\/standard\/var_unserializer.c\"\n yy65:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n@@ -1124,7 +1138,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tyych = *++YYCURSOR;\n \tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n-#line 585 \"ext\/standard\/var_unserializer.re\"\n+#line 590 \"ext\/standard\/var_unserializer.re\"\n \t{\n \t*p = YYCURSOR;\n \tINIT_PZVAL(*rval);\n@@ -1139,7 +1153,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \n \treturn 1;\n }\n-#line 1143 \"ext\/standard\/var_unserializer.c\"\n+#line 1157 \"ext\/standard\/var_unserializer.c\"\n yy76:\n \tyych = *++YYCURSOR;\n \tif (yych == 'N') goto yy73;\n@@ -1166,7 +1180,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tif (yych <= '9') goto yy79;\n \tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n-#line 558 \"ext\/standard\/var_unserializer.re\"\n+#line 563 \"ext\/standard\/var_unserializer.re\"\n \t{\n #if SIZEOF_LONG == 4\n \tint digits = YYCURSOR - start - 3;\n@@ -1193,7 +1207,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tZVAL_LONG(*rval, parse_iv(start + 2));\n \treturn 1;\n }\n-#line 1197 \"ext\/standard\/var_unserializer.c\"\n+#line 1211 \"ext\/standard\/var_unserializer.c\"\n yy83:\n \tyych = *++YYCURSOR;\n \tif (yych <= '\/') goto yy18;\n@@ -1201,24 +1215,24 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tyych = *++YYCURSOR;\n \tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n-#line 551 \"ext\/standard\/var_unserializer.re\"\n+#line 556 \"ext\/standard\/var_unserializer.re\"\n \t{\n \t*p = YYCURSOR;\n \tINIT_PZVAL(*rval);\n \tZVAL_BOOL(*rval, parse_iv(start + 2));\n \treturn 1;\n }\n-#line 1212 \"ext\/standard\/var_unserializer.c\"\n+#line 1226 \"ext\/standard\/var_unserializer.c\"\n yy87:\n \t++YYCURSOR;\n-#line 544 \"ext\/standard\/var_unserializer.re\"\n+#line 549 \"ext\/standard\/var_unserializer.re\"\n \t{\n \t*p = YYCURSOR;\n \tINIT_PZVAL(*rval);\n \tZVAL_NULL(*rval);\n \treturn 1;\n }\n-#line 1222 \"ext\/standard\/var_unserializer.c\"\n+#line 1236 \"ext\/standard\/var_unserializer.c\"\n yy89:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n@@ -1241,7 +1255,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tif (yych <= '9') goto yy91;\n \tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n-#line 521 \"ext\/standard\/var_unserializer.re\"\n+#line 526 \"ext\/standard\/var_unserializer.re\"\n \t{\n \tlong id;\n \n@@ -1264,7 +1278,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \n \treturn 1;\n }\n-#line 1268 \"ext\/standard\/var_unserializer.c\"\n+#line 1282 \"ext\/standard\/var_unserializer.c\"\n yy95:\n \tyych = *++YYCURSOR;\n \tif (yych <= ',') {\n@@ -1287,7 +1301,7 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \tif (yych <= '9') goto yy97;\n \tif (yych != ';') goto yy18;\n \t++YYCURSOR;\n-#line 500 \"ext\/standard\/var_unserializer.re\"\n+#line 505 \"ext\/standard\/var_unserializer.re\"\n \t{\n \tlong id;\n \n@@ -1308,9 +1322,9 @@ PHPAPI int php_var_unserialize(UNSERIALIZE_PARAMETER)\n \n \treturn 1;\n }\n-#line 1312 \"ext\/standard\/var_unserializer.c\"\n+#line 1326 \"ext\/standard\/var_unserializer.c\"\n }\n-#line 863 \"ext\/standard\/var_unserializer.re\"\n+#line 877 \"ext\/standard\/var_unserializer.re\"\n \n \n \treturn 0;\ndiff --git a\/ext\/standard\/var_unserializer.re b\/ext\/standard\/var_unserializer.re\nindex ce84bf5eb40c..4cdf31373508 100644\n--- a\/ext\/standard\/var_unserializer.re\n+++ b\/ext\/standard\/var_unserializer.re\n@@ -409,6 +409,11 @@ static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n {\n \tlong elements;\n \n+\tif( *p >= max - 2) {\n+\t\tzend_error(E_WARNING, \"Bad unserialize data\");\n+\t\treturn -1;\n+\t}\n+\n \telements = parse_iv2((*p) + 2, p);\n \n \t(*p) += 2;\n@@ -419,7 +424,7 @@ static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n \t\t\/* If this class implements Serializable, it should not land here but in object_custom(). The passed string\n \t\tobviously doesn't descend from the regular serializer. *\/\n \t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n-\t\treturn 0;\n+\t\treturn -1;\n \t}\n \n \treturn elements;\n@@ -697,12 +702,16 @@ use_double:\n }\n \n \"o:\" iv \":\" [\"] {\n+\tlong elements;\n     if (!var_hash) return 0;\n \n \tINIT_PZVAL(*rval);\n \n-\treturn object_common2(UNSERIALIZE_PASSTHRU,\n-\t\t\tobject_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR));\n+\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n+\tif (elements < 0) {\n+\t\treturn 0;\n+\t}\n+\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n }\n \n object \":\" uiv \":\" [\"]\t{\n@@ -844,6 +853,11 @@ object \":\" uiv \":\" [\"]\t{\n \n \telements = object_common1(UNSERIALIZE_PASSTHRU, ce);\n \n+\tif (elements < 0) {\n+\t   efree(class_name);\n+\t   return 0;\n+\t}\n+\n \tif (incomplete_class) {\n \t\tphp_store_class_name(*rval, class_name, len2);\n \t}\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2016-9572","CWE_ID":"125","category":"security","commit_id":"7b28bd2b723df6be09fe7791eba33147c1c47d0d","commit_message":"From 7b28bd2b723df6be09fe7791eba33147c1c47d0d Mon Sep 17 00:00:00 2001\nFrom: szukw000 <szukw000@arcor.de>\nDate: Mon, 28 Nov 2016 21:57:20 +0100\nSubject: [PATCH] Changes for issues #863 and #862\n\n---\n src\/bin\/jp2\/convert.c        | 59 ++++++++++++++++++++++++++++++++----\n src\/bin\/jp2\/convertbmp.c     | 29 +++++++++++++++++-\n src\/bin\/jp2\/opj_decompress.c |  2 +-\n src\/lib\/openjp2\/j2k.c        | 11 +++++--\n 4 files changed, 90 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/src\/bin\/jp2\/convert.c b\/src\/bin\/jp2\/convert.c\nindex deee4f6e0..6a3f65b76 100644\n--- a\/src\/bin\/jp2\/convert.c\n+++ b\/src\/bin\/jp2\/convert.c\n@@ -906,7 +906,8 @@ int imagetotga(opj_image_t * image, const char *outfile) {\n     for (i = 0; i < image->numcomps-1; i++)\t{\n         if ((image->comps[0].dx != image->comps[i+1].dx)\n                 ||(image->comps[0].dy != image->comps[i+1].dy)\n-                ||(image->comps[0].prec != image->comps[i+1].prec))\t{\n+                ||(image->comps[0].prec != image->comps[i+1].prec)\n+\t\t\t\t||(image->comps[0].sgnd != image->comps[i+1].sgnd))\t{\n             fclose(fdest);\n             fprintf(stderr, \"Unable to create a tga file with such J2K image charateristics.\");\n             return 1;\n@@ -1743,7 +1744,7 @@ int imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n     int *red, *green, *blue, *alpha;\n     int wr, hr, max;\n     int i;\n-    unsigned int compno, ncomp;\n+    unsigned int compno, ncomp, ui;\n     int adjustR, adjustG, adjustB, adjustA;\n     int fails, two, want_gray, has_alpha, triple;\n     int prec, v;\n@@ -1768,6 +1769,27 @@ int imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n \n     if(want_gray) ncomp = 1;\n \n+    for (ui = 1; ui < ncomp; ++ui) {\n+        if (image->comps[0].dx != image->comps[ui].dx) {\n+            break;\n+        }\n+        if (image->comps[0].dy != image->comps[ui].dy) {\n+            break;\n+        }\n+        if (image->comps[0].prec != image->comps[ui].prec) {\n+            break;\n+        }\n+        if (image->comps[0].sgnd != image->comps[ui].sgnd) {\n+            break;\n+        }\n+    }\n+    if (ui != ncomp) {\n+        fprintf(stderr,\"imagetopnm: All components\\n    shall have \"\n+         \"the same subsampling, same bit depth, same sign.\\n\"\n+         \"    Aborting\\n\");\n+        return 1;\n+    }\n+\n     if ((force_split == 0) &&\n \t\t\t\t(ncomp == 2 \/* GRAYA *\/\n             || (ncomp > 2 \/* RGB, RGBA *\/\n@@ -2126,7 +2148,7 @@ static int imagetoraw_common(opj_image_t * image, const char *outfile, OPJ_BOOL\n {\n     FILE *rawFile = NULL;\n     size_t res;\n-    unsigned int compno;\n+    unsigned int compno, numcomps;\n     int w, h, fails;\n     int line, row, curr, mask;\n     int *ptr;\n@@ -2139,6 +2161,31 @@ static int imagetoraw_common(opj_image_t * image, const char *outfile, OPJ_BOOL\n         return 1;\n     }\n \n+    numcomps = image->numcomps;\n+\n+    if (numcomps > 4) {\n+        numcomps = 4;\n+    }\n+    for (compno = 1; compno < numcomps; ++compno) {\n+        if (image->comps[0].dx != image->comps[compno].dx) {\n+            break;\n+        }\n+        if (image->comps[0].dy != image->comps[compno].dy) {\n+            break;\n+        }\n+        if (image->comps[0].prec != image->comps[compno].prec) {\n+            break;\n+        }\n+        if (image->comps[0].sgnd != image->comps[compno].sgnd) {\n+            break;\n+        }\n+    }\n+    if (compno != numcomps) {\n+        fprintf(stderr,\"imagetoraw_common: All components shall have the same subsampling, same bit depth, same sign.\\n\");\n+        fprintf(stderr,\"\\tAborting\\n\");\n+        return 1;\n+    }\n+\n     rawFile = fopen(outfile, \"wb\");\n     if (!rawFile) {\n         fprintf(stderr, \"Failed to open %s for writing !!\\n\", outfile);\n@@ -2146,9 +2193,9 @@ static int imagetoraw_common(opj_image_t * image, const char *outfile, OPJ_BOOL\n     }\n \n     fails = 1;\n-    fprintf(stdout,\"Raw image characteristics: %d components\\n\", image->numcomps);\n+    fprintf(stdout,\"Raw image characteristics: %d components\\n\", numcomps);\n \n-    for(compno = 0; compno < image->numcomps; compno++)\n+    for(compno = 0; compno < numcomps; compno++)\n     {\n         fprintf(stdout,\"Component %u characteristics: %dx%dx%d %s\\n\", compno, image->comps[compno].w,\n                 image->comps[compno].h, image->comps[compno].prec, image->comps[compno].sgnd==1 ? \"signed\": \"unsigned\");\n@@ -2238,7 +2285,7 @@ static int imagetoraw_common(opj_image_t * image, const char *outfile, OPJ_BOOL\n         }\n         else if (image->comps[compno].prec <= 32)\n         {\n-            fprintf(stderr,\"More than 16 bits per component no handled yet\\n\");\n+            fprintf(stderr,\"More than 16 bits per component not handled yet\\n\");\n             goto fin;\n         }\n         else\ndiff --git a\/src\/bin\/jp2\/convertbmp.c b\/src\/bin\/jp2\/convertbmp.c\nindex ae83077ca..8017ba86d 100644\n--- a\/src\/bin\/jp2\/convertbmp.c\n+++ b\/src\/bin\/jp2\/convertbmp.c\n@@ -806,8 +806,35 @@ int imagetobmp(opj_image_t * image, const char *outfile) {\n     FILE *fdest = NULL;\n     int adjustR, adjustG, adjustB;\n \n+   {\n+    unsigned int ui, ncomp = image->numcomps;\n+\n+    if (ncomp > 4) { \/* RGBA in bmpmask32toimage *\/\n+        ncomp = 4;\n+    }\n+    for (ui = 1; ui < ncomp; ++ui) {\n+        if (image->comps[0].dx != image->comps[ui].dx) {\n+            break;\n+        }\n+        if (image->comps[0].dy != image->comps[ui].dy) {\n+            break;\n+        }\n+        if (image->comps[0].prec != image->comps[ui].prec) {\n+            break;\n+        }\n+        if (image->comps[0].sgnd != image->comps[ui].sgnd) {\n+            break;\n+        }\n+    }\n+    if (ui != ncomp) {\n+        fprintf(stderr,\"imagetobmp: All components shall have the same subsampling, same bit depth, same sign.\\n\");\n+        fprintf(stderr,\"\\tAborting\\n\");\n+        return 1;\n+    }\n+\n+   }\n     if (image->comps[0].prec < 8) {\n-        fprintf(stderr, \"Unsupported number of components: %d\\n\", image->comps[0].prec);\n+        fprintf(stderr, \"imagetobmp: Unsupported precision: %d\\n\", image->comps[0].prec);\n         return 1;\n     }\n     if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx\ndiff --git a\/src\/bin\/jp2\/opj_decompress.c b\/src\/bin\/jp2\/opj_decompress.c\nindex 83160c3d1..c30079b50 100644\n--- a\/src\/bin\/jp2\/opj_decompress.c\n+++ b\/src\/bin\/jp2\/opj_decompress.c\n@@ -1607,7 +1607,7 @@ int main(int argc, char **argv)\n \t\tif(dirptr->filename_buf) free(dirptr->filename_buf);\n \t\tfree(dirptr);\n \t}\n-\tif (numDecompressedImages) {\n+\tif (numDecompressedImages && !failed) {\n \t\tfprintf(stdout, \"decode time: %d ms\\n\", (int)( (tCumulative * 1000.0) \/ (OPJ_FLOAT64)numDecompressedImages));\n \t}\n \treturn failed ? EXIT_FAILURE : EXIT_SUCCESS;\ndiff --git a\/src\/lib\/openjp2\/j2k.c b\/src\/lib\/openjp2\/j2k.c\nindex 66802bb96..b6daa3200 100644\n--- a\/src\/lib\/openjp2\/j2k.c\n+++ b\/src\/lib\/openjp2\/j2k.c\n@@ -2158,7 +2158,7 @@ static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,\n                                   i, l_img_comp->dx, l_img_comp->dy);\n                     return OPJ_FALSE;\n                 }\n-                if( l_img_comp->prec > 38) { \/* TODO openjpeg won't handle more than ? *\/\n+                if( l_img_comp->prec < 1 || l_img_comp->prec > 38) { \/* TODO openjpeg won't handle more than ? *\/\n                     opj_event_msg(p_manager, EVT_ERROR,\n                                   \"Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm)\\n\",\n                                   i, l_img_comp->prec);\n@@ -10029,7 +10029,11 @@ OPJ_BOOL opj_j2k_decode(opj_j2k_t * p_j2k,\n         \/* Move data and copy one information from codec to output image*\/\n         for (compno = 0; compno < p_image->numcomps; compno++) {\n                 p_image->comps[compno].resno_decoded = p_j2k->m_output_image->comps[compno].resno_decoded;\n-                p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n+\t\tp_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n+\n+\t\tif(p_image->comps[compno].data == NULL) return OPJ_FALSE;\n+\n+                p_j2k->m_output_image->comps[compno].data = NULL;\n #if 0\n                 char fn[256];\n                 sprintf( fn, \"\/tmp\/%d.raw\", compno );\n@@ -10037,7 +10041,6 @@ OPJ_BOOL opj_j2k_decode(opj_j2k_t * p_j2k,\n                 fwrite( p_image->comps[compno].data, sizeof(OPJ_INT32), p_image->comps[compno].w * p_image->comps[compno].h, debug );\n                 fclose( debug );\n #endif\n-                p_j2k->m_output_image->comps[compno].data = NULL;\n         }\n \n         return OPJ_TRUE;\n@@ -10131,6 +10134,8 @@ OPJ_BOOL opj_j2k_get_tile(      opj_j2k_t *p_j2k,\n \n                 p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n \n+\t\t\t\tif (p_image->comps[compno].data == NULL) return OPJ_FALSE;\n+\n                 p_j2k->m_output_image->comps[compno].data = NULL;\n         }\n \n","owner":"szukw000","repo":"openjpeg","source":"cve"},{"CVE_ID":"CVE-2016-7532","CWE_ID":"125","category":"security","commit_id":"4f2c04ea6673863b87ac7f186cbb0d911f74085c","commit_message":"From 4f2c04ea6673863b87ac7f186cbb0d911f74085c Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Tue, 2 Feb 2016 21:35:45 +0100\nSubject: [PATCH] Added check for out of bounds read\n (https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/108).\n\n---\n coders\/psd.c | 19 ++++++++++++-------\n 1 file changed, 12 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex 47c6bcf735..ba9bbba660 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -2605,18 +2605,23 @@ static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n     register unsigned char\n       *q;\n \n+    ssize_t\n+      cnt;\n+\n     q=(unsigned char *) p;\n     if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n-      break;\n+      return;\n     p=PushLongPixel(MSBEndian,p,&long_sans);\n     p=PushShortPixel(MSBEndian,p,&id);\n     p=PushShortPixel(MSBEndian,p,&short_sans);\n     p=PushLongPixel(MSBEndian,p,&count);\n-    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))\n+    cnt=PSDQuantum(count);\n+    if (cnt < 0)\n+      return;\n+    if ((id == 0x000003ed) && (cnt < (ssize_t) (length-12)))\n       {\n-        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n-          (PSDQuantum(count)+12)-(q-datum));\n-        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n+        (void) CopyMagickMemory(q,q+cnt+12,length-(cnt+12)-(q-datum));\n+        SetStringInfoLength(bim_profile,length-(cnt+12));\n         break;\n       }\n     p+=count;\n@@ -2625,8 +2630,8 @@ static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n   }\n }\n \n-static MagickBooleanType WritePSDImage(const ImageInfo *image_info,Image *image,\n-  ExceptionInfo *exception)\n+static MagickBooleanType WritePSDImage(const ImageInfo *image_info,\n+  Image *image,ExceptionInfo *exception)\n {\n   const char\n     *property;\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-6306","CWE_ID":"125","category":"security","commit_id":"52e623c4cb06fffa9d5e75c60b34b4bc130b12e9","commit_message":"From 52e623c4cb06fffa9d5e75c60b34b4bc130b12e9 Mon Sep 17 00:00:00 2001\nFrom: \"Dr. Stephen Henson\" <steve@openssl.org>\nDate: Sat, 17 Sep 2016 12:36:58 +0100\nSubject: [PATCH] Fix small OOB reads.\n\nIn ssl3_get_client_certificate, ssl3_get_server_certificate and\nssl3_get_certificate_request check we have enough room\nbefore reading a length.\n\nThanks to Shi Lei (Gear Team, Qihoo 360 Inc.) for reporting these bugs.\n\nCVE-2016-6306\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(cherry picked from commit ff553f837172ecb2b5c8eca257ec3c5619a4b299)\n---\n ssl\/s3_clnt.c | 11 +++++++++++\n ssl\/s3_srvr.c |  6 ++++++\n 2 files changed, 17 insertions(+)\n\n","diff_code":"diff --git a\/ssl\/s3_clnt.c b\/ssl\/s3_clnt.c\nindex 9e5875f1f9..40ca13da24 100644\n--- a\/ssl\/s3_clnt.c\n+++ b\/ssl\/s3_clnt.c\n@@ -1143,6 +1143,12 @@ int ssl3_get_server_certificate(SSL *s)\n         goto f_err;\n     }\n     for (nc = 0; nc < llen;) {\n+        if (nc + 3 > llen) {\n+            al = SSL_AD_DECODE_ERROR;\n+            SSLerr(SSL_F_SSL3_GET_SERVER_CERTIFICATE,\n+                   SSL_R_CERT_LENGTH_MISMATCH);\n+            goto f_err;\n+        }\n         n2l3(p, l);\n         if ((l + nc + 3) > llen) {\n             al = SSL_AD_DECODE_ERROR;\n@@ -2072,6 +2078,11 @@ int ssl3_get_certificate_request(SSL *s)\n     }\n \n     for (nc = 0; nc < llen;) {\n+        if (nc + 2 > llen) {\n+            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_DECODE_ERROR);\n+            SSLerr(SSL_F_SSL3_GET_CERTIFICATE_REQUEST, SSL_R_CA_DN_TOO_LONG);\n+            goto err;\n+        }\n         n2s(p, l);\n         if ((l + nc + 2) > llen) {\n             if ((s->options & SSL_OP_NETSCAPE_CA_DN_BUG))\ndiff --git a\/ssl\/s3_srvr.c b\/ssl\/s3_srvr.c\nindex 591b13ecea..4f1a2e9aba 100644\n--- a\/ssl\/s3_srvr.c\n+++ b\/ssl\/s3_srvr.c\n@@ -3234,6 +3234,12 @@ int ssl3_get_client_certificate(SSL *s)\n         goto f_err;\n     }\n     for (nc = 0; nc < llen;) {\n+        if (nc + 3 > llen) {\n+            al = SSL_AD_DECODE_ERROR;\n+            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,\n+                   SSL_R_CERT_LENGTH_MISMATCH);\n+            goto f_err;\n+        }\n         n2l3(p, l);\n         if ((l + nc + 3) > llen) {\n             al = SSL_AD_DECODE_ERROR;\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7522","CWE_ID":"125","category":"security","commit_id":"4b1b9c0522628887195bad3a6723f7000b0c9a58","commit_message":"From 4b1b9c0522628887195bad3a6723f7000b0c9a58 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Tue, 2 Feb 2016 21:15:13 +0100\nSubject: [PATCH] Added extra check to fix\n https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/93\n\n---\n coders\/psd.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex 9f69d8a712..47c6bcf735 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -1936,7 +1936,7 @@ static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n       if (blocks == (unsigned char *) NULL)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       count=ReadBlob(image,(size_t) length,blocks);\n-      if ((count != (ssize_t) length) ||\n+      if ((count != (ssize_t) length) || (length < 4) ||\n           (LocaleNCompare((char *) blocks,\"8BIM\",4) != 0))\n         {\n           blocks=(unsigned char *) RelinquishMagickMemory(blocks);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-9988","CWE_ID":"125","category":"security","commit_id":"027f84c69f4ef30c0693832a6c396ef19e563ca1","commit_message":"From 027f84c69f4ef30c0693832a6c396ef19e563ca1 Mon Sep 17 00:00:00 2001\nFrom: Krzysztof Stachowiak <krzysiek.stachowiak@gmail.com>\nDate: Tue, 13 Mar 2018 11:29:24 +0100\nSubject: [PATCH] Prevent arithmetic overflow on bounds check\n\n---\n library\/ssl_cli.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/library\/ssl_cli.c b\/library\/ssl_cli.c\nindex 279a127ba2..df6abc389e 100644\n--- a\/library\/ssl_cli.c\n+++ b\/library\/ssl_cli.c\n@@ -2489,7 +2489,7 @@ static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )\n         sig_len = ( p[0] << 8 ) | p[1];\n         p += 2;\n \n-        if( end != p + sig_len )\n+        if( p != end - sig_len )\n         {\n             MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n             mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n","owner":"ARMmbed","repo":"mbedtls","source":"cve"},{"CVE_ID":"CVE-2018-1999010","CWE_ID":"125","category":"security","commit_id":"cced03dd667a5df6df8fd40d8de0bff477ee02e8","commit_message":"From cced03dd667a5df6df8fd40d8de0bff477ee02e8 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Tue, 3 Jul 2018 20:33:04 +0200\nSubject: [PATCH] avformat\/mms: Add missing chunksize check\n\nFixes: out of array read\nFixes: mms-crash-01b6c5d85f9d9f40f4e879896103e9f5b222816a\n\nFound-by: Paul Ch <paulcher@icloud.com>\n1st hunk by Paul Ch <paulcher@icloud.com>\nTested-by: Paul Ch <paulcher@icloud.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/mms.c | 44 ++++++++++++++++++++++++++------------------\n 1 file changed, 26 insertions(+), 18 deletions(-)\n\n","diff_code":"diff --git a\/libavformat\/mms.c b\/libavformat\/mms.c\nindex 17fa76a8d44..768fda65254 100644\n--- a\/libavformat\/mms.c\n+++ b\/libavformat\/mms.c\n@@ -94,24 +94,26 @@ int ff_mms_asf_header_parser(MMSContext *mms)\n                 }\n             }\n         } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {\n-            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);\n-            stream_id = flags & 0x7F;\n-            \/\/The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,\n-            \/\/we can calculate the packet size by stream_num.\n-            \/\/Please see function send_stream_selection_request().\n-            if (mms->stream_num < MMS_MAX_STREAMS &&\n-                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {\n-                mms->streams = av_fast_realloc(mms->streams,\n-                                   &mms->nb_streams_allocated,\n-                                   (mms->stream_num + 1) * sizeof(MMSStream));\n-                if (!mms->streams)\n-                    return AVERROR(ENOMEM);\n-                mms->streams[mms->stream_num].id = stream_id;\n-                mms->stream_num++;\n-            } else {\n-                av_log(NULL, AV_LOG_ERROR,\n-                       \"Corrupt stream (too many A\/V streams)\\n\");\n-                return AVERROR_INVALIDDATA;\n+            if (end - p >= (sizeof(ff_asf_guid) * 3 + 26)) {\n+                flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);\n+                stream_id = flags & 0x7F;\n+                \/\/The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,\n+                \/\/we can calculate the packet size by stream_num.\n+                \/\/Please see function send_stream_selection_request().\n+                if (mms->stream_num < MMS_MAX_STREAMS &&\n+                        46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {\n+                    mms->streams = av_fast_realloc(mms->streams,\n+                                       &mms->nb_streams_allocated,\n+                                       (mms->stream_num + 1) * sizeof(MMSStream));\n+                    if (!mms->streams)\n+                        return AVERROR(ENOMEM);\n+                    mms->streams[mms->stream_num].id = stream_id;\n+                    mms->stream_num++;\n+                } else {\n+                    av_log(NULL, AV_LOG_ERROR,\n+                           \"Corrupt stream (too many A\/V streams)\\n\");\n+                    return AVERROR_INVALIDDATA;\n+                }\n             }\n         } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {\n             if (end - p >= 88) {\n@@ -143,6 +145,12 @@ int ff_mms_asf_header_parser(MMSContext *mms)\n             }\n         } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {\n             chunksize = 46; \/\/ see references [2] section 3.4. This should be set 46.\n+            if (chunksize > end - p) {\n+                av_log(NULL, AV_LOG_ERROR,\n+                    \"Corrupt stream (header chunksize %\"PRId64\" is invalid)\\n\",\n+                    chunksize);\n+                return AVERROR_INVALIDDATA;\n+            }\n         }\n         p += chunksize;\n     }\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2016-2180","CWE_ID":"125","category":"security","commit_id":"0ed26acce328ec16a3aa635f1ca37365e8c7403a","commit_message":"From 0ed26acce328ec16a3aa635f1ca37365e8c7403a Mon Sep 17 00:00:00 2001\nFrom: \"Dr. Stephen Henson\" <steve@openssl.org>\nDate: Thu, 21 Jul 2016 15:24:16 +0100\nSubject: [PATCH] Fix OOB read in TS_OBJ_print_bio().\n\nTS_OBJ_print_bio() misuses OBJ_txt2obj: it should print the result\nas a null terminated buffer. The length value returned is the total\nlength the complete text reprsentation would need not the amount of\ndata written.\n\nCVE-2016-2180\n\nThanks to Shi Lei for reporting this bug.\n\nReviewed-by: Matt Caswell <matt@openssl.org>\n---\n crypto\/ts\/ts_lib.c | 5 ++---\n 1 file changed, 2 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/ts\/ts_lib.c b\/crypto\/ts\/ts_lib.c\nindex bde1bd75e47..e18f1f3f7e3 100644\n--- a\/crypto\/ts\/ts_lib.c\n+++ b\/crypto\/ts\/ts_lib.c\n@@ -40,9 +40,8 @@ int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n {\n     char obj_txt[128];\n \n-    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n-    BIO_write(bio, obj_txt, len);\n-    BIO_write(bio, \"\\n\", 1);\n+    OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n+    BIO_printf(bio, \"%s\\n\", obj_txt);\n \n     return 1;\n }\n","owner":"openssl","repo":"openssl","source":"cve"},{"CVE_ID":"CVE-2018-11380","CWE_ID":"125","category":"security","commit_id":"60208765887f5f008b3b9a883f3addc8bdb9c134","commit_message":"From 60208765887f5f008b3b9a883f3addc8bdb9c134 Mon Sep 17 00:00:00 2001\nFrom: radare <pancake@nopcode.org>\nDate: Sun, 6 May 2018 15:59:08 +0200\nSubject: [PATCH] Fix #9970 - heap oobread in mach0 parser (#10026)\n\n---\n libr\/bin\/format\/mach0\/mach0.c | 16 +++++++++++-----\n 1 file changed, 11 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/libr\/bin\/format\/mach0\/mach0.c b\/libr\/bin\/format\/mach0\/mach0.c\nindex b7d866284f..35b207c87a 100644\n--- a\/libr\/bin\/format\/mach0\/mach0.c\n+++ b\/libr\/bin\/format\/mach0\/mach0.c\n@@ -1586,8 +1586,9 @@ struct symbol_t* MACH0_(get_symbols)(struct MACH0_(obj_t)* bin) {\n \t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n \t\t\tbreak;\n \t\t}\n-\t\tif (parse_import_stub(bin, &symbols[j], i))\n+\t\tif (parse_import_stub(bin, &symbols[j], i)) {\n \t\t\tsymbols[j++].last = 0;\n+\t\t}\n \t}\n \n #if 1\n@@ -1662,12 +1663,16 @@ static int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, in\n \n \tfor (i = 0; i < bin->nsects; i++) {\n \t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n-\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n-\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n+\t\t\tfor (j = 0, sym = -1; bin->sects[i].reserved1 + j < bin->nindirectsyms; j++) {\n+\t\t\t\tint indidx = bin->sects[i].reserved1 + j;\n+\t\t\t\tif (indidx < 0 || indidx >= bin->nindirectsyms) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tif (idx == bin->indirectsyms[indidx]) {\n \t\t\t\t\tsym = j;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n-\n+\t\t\t}\n \t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n \t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n \t\t\treturn true;\n@@ -1681,8 +1686,9 @@ struct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {\n \tint i, j, idx, stridx;\n \tconst char *symstr;\n \n-\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n+\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {\n \t\treturn NULL;\n+\t}\n \tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n \t\treturn NULL;\n \t}\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2018-10887","CWE_ID":"125","category":"security","commit_id":"c1577110467b701dcbcf9439ac225ea851b47d22","commit_message":"From c1577110467b701dcbcf9439ac225ea851b47d22 Mon Sep 17 00:00:00 2001\nFrom: Patrick Steinhardt <ps@pks.im>\nDate: Thu, 5 Jul 2018 13:30:46 +0200\nSubject: [PATCH] delta: fix overflow when computing limit\n\nWhen checking whether a delta base offset and length fit into the base\nwe have in memory already, we can trigger an overflow which breaks the\ncheck. This would subsequently result in us reading memory from out of\nbounds of the base.\n\nThe issue is easily fixed by checking for overflow when adding `off` and\n`len`, thus guaranteeting that we are never indexing beyond `base_len`.\nThis corresponds to the git patch 8960844a7 (check patch_delta bounds\nmore carefully, 2006-04-07), which adds these overflow checks.\n\nReported-by: Riccardo Schirone <rschiron@redhat.com>\n---\n src\/delta.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/delta.c b\/src\/delta.c\nindex 8676e7a8f2..b9352b8ee0 100644\n--- a\/src\/delta.c\n+++ b\/src\/delta.c\n@@ -566,7 +566,7 @@ int git_delta_apply(\n \t\tunsigned char cmd = *delta++;\n \t\tif (cmd & 0x80) {\n \t\t\t\/* cmd is a copy instruction; copy from the base. *\/\n-\t\t\tsize_t off = 0, len = 0;\n+\t\t\tsize_t off = 0, len = 0, end;\n \n #define ADD_DELTA(o, shift) { if (delta < delta_end) (o) |= ((unsigned) *delta++ << shift); else goto fail; }\n \t\t\tif (cmd & 0x01) ADD_DELTA(off, 0UL);\n@@ -580,8 +580,10 @@ int git_delta_apply(\n \t\t\tif (!len)       len = 0x10000;\n #undef ADD_DELTA\n \n-\t\t\tif (base_len < off + len || res_sz < len)\n+\t\t\tif (GIT_ADD_SIZET_OVERFLOW(&end, off, len) ||\n+\t\t\t    base_len < end || res_sz < len)\n \t\t\t\tgoto fail;\n+\n \t\t\tmemcpy(res_dp, base + off, len);\n \t\t\tres_dp += len;\n \t\t\tres_sz -= len;\n","owner":"libgit2","repo":"libgit2","source":"cve"},{"CVE_ID":"CVE-2018-20721","CWE_ID":"125","category":"security","commit_id":"cef25028de5ff872c2e1f0a6c562eb3ea9ecbce4","commit_message":"From cef25028de5ff872c2e1f0a6c562eb3ea9ecbce4 Mon Sep 17 00:00:00 2001\nFrom: Sebastian Pipping <sebastian@pipping.org>\nDate: Sat, 8 Dec 2018 18:44:11 +0100\nSubject: [PATCH] Fix uriParse*Ex* out-of-bounds read\n\n---\n ChangeLog      |  6 ++++++\n src\/UriParse.c |  5 +++++\n test\/test.cpp  | 13 +++++++++++++\n 3 files changed, 24 insertions(+)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 8a3f49c..1ab4552 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -4,6 +4,12 @@ NOTE: uriparser is looking for help with a few things:\n \n 201x-xx-xx -- x.x.x\n \n+  * Fixed:\n+      Out-of-bounds read in uriParse*Ex* for incomplete URIs with IPv6\n+      addresses with embedded IPv4 address, e.g. \"\/\/[::44.1\";\n+      mitigated if passed parameter <afterLast> points to readable memory\n+      containing a '\\0' byte.\n+      Thanks to Joergen Ibsen for the report!\n   * Fixed: uriToStringCharsRequired* reported 1 more byte than actually needed\n       for IPv4 address URIs (GitHub #41); Thanks to @gyh007 for the patch!\n   * Fixed: Compilation with MinGW\ndiff --git a\/src\/UriParse.c b\/src\/UriParse.c\nindex f4bdda9..33ac891 100644\n--- a\/src\/UriParse.c\n+++ b\/src\/UriParse.c\n@@ -692,6 +692,11 @@ static const URI_CHAR * URI_FUNC(ParseIPv6address2)(\n \t\t\t\t\treturn NULL;\n \t\t\t\t}\n \t\t\t\tfirst++;\n+\n+\t\t\t\tif (first >= afterLast) {\n+\t\t\t\t\tURI_FUNC(StopSyntax)(state, first, memory);\n+\t\t\t\t\treturn NULL;\n+\t\t\t\t}\n \t\t\t}\n \t\t} else {\n \t\t\t\/* Eat while no dot in sight *\/\ndiff --git a\/test\/test.cpp b\/test\/test.cpp\nindex 2ffbc82..8eabee6 100644\n--- a\/test\/test.cpp\n+++ b\/test\/test.cpp\n@@ -242,6 +242,19 @@ TEST(UriSuite, TestIpSixFail) {\n \t\tURI_TEST_IP_SIX_FAIL(\"g:0:0:0:0:0:0\");\n }\n \n+TEST(UriSuite, TestIpSixOverread) {\n+\t\tUriUriA uri;\n+\t\tconst char * errorPos;\n+\n+\t\t\/\/ NOTE: This string is designed to not have a terminator\n+\t\tchar uriText[2 + 3 + 2 + 1 + 1];\n+\t\tstrncpy(uriText, \"\/\/[::44.1\", sizeof(uriText));\n+\n+\t\tEXPECT_EQ(uriParseSingleUriExA(&uri, uriText,\n+\t\t\t\turiText + sizeof(uriText), &errorPos), URI_ERROR_SYNTAX);\n+\t\tEXPECT_EQ(errorPos, uriText + sizeof(uriText));\n+}\n+\n TEST(UriSuite, TestUri) {\n \t\tUriParserStateA stateA;\n \t\tUriParserStateW stateW;\n","owner":"uriparser","repo":"uriparser","source":"cve"},{"CVE_ID":"CVE-2018-1000127","CWE_ID":"125","category":"security","commit_id":"a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00","commit_message":"From a8c4a82787b8b6c256d61bd5c42fb7f92d1bae00 Mon Sep 17 00:00:00 2001\nFrom: dormando <dormando@rydia.net>\nDate: Sun, 21 May 2017 21:49:54 -0700\nSubject: [PATCH] Don't overflow item refcount on get\n\nCounts as a miss if the refcount is too high. ASCII multigets are the only\ntime refcounts can be held for so long.\n\ndoing a dirty read of refcount. is aligned.\n\ntrying to avoid adding an extra refcount branch for all calls of item_get due\nto performance. might be able to move it in there after logging refactoring\nsimplifies some of the branches.\n---\n memcached.c | 12 +++++++++++-\n 1 file changed, 11 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/memcached.c b\/memcached.c\nindex d0533c5ad..044064fc8 100644\n--- a\/memcached.c\n+++ b\/memcached.c\n@@ -3249,6 +3249,16 @@ static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas)\n     return (p - suffix) + 2;\n }\n \n+#define IT_REFCOUNT_LIMIT 60000\n+static inline item* limited_get(char *key, size_t nkey, conn *c) {\n+    item *it = item_get(key, nkey, c, DO_UPDATE);\n+    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n+        item_remove(it);\n+        it = NULL;\n+    }\n+    return it;\n+}\n+\n \/* ntokens is overwritten here... shrug.. *\/\n static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n     char *key;\n@@ -3273,7 +3283,7 @@ static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens,\n                 return;\n             }\n \n-            it = item_get(key, nkey, c, DO_UPDATE);\n+            it = limited_get(key, nkey, c);\n             if (settings.detail_enabled) {\n                 stats_prefix_record_get(key, nkey, NULL != it);\n             }\n","owner":"memcached","repo":"memcached","source":"cve"},{"CVE_ID":"CVE-2018-1000085","CWE_ID":"125","category":"security","commit_id":"d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6","commit_message":"From d96a6b8bcc7439fa7e3876207aa0a8e79c8451b6 Mon Sep 17 00:00:00 2001\nFrom: Steven Morgan <smorgan@sourcefire.com>\nDate: Tue, 21 Jun 2016 17:22:52 -0400\nSubject: [PATCH] bb11588 - fix out of bounds read.\n\n---\n libclamav\/xar.c | 79 +++++++++++++++++++++++++++++++------------------\n 1 file changed, 50 insertions(+), 29 deletions(-)\n\n","diff_code":"diff --git a\/libclamav\/xar.c b\/libclamav\/xar.c\nindex 6a1a287d79..edba7e5027 100644\n--- a\/libclamav\/xar.c\n+++ b\/libclamav\/xar.c\n@@ -71,17 +71,20 @@ static int xar_cleanup_temp_file(cli_ctx *ctx, int fd, char * tmpname)\n      value - pointer to long to contain the returned value\n    returns - CL_SUCCESS or CL_EFORMAT\n  *\/\n-static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n+static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, size_t * value)\n {\n     const xmlChar * numstr;\n+    ssize_t numval;\n+\n     if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n         numstr = xmlTextReaderConstValue(reader);\n         if (numstr) {\n-            *value = atol((const char *)numstr);\n-            if (*value < 0) {\n+            numval = atol((const char *)numstr);\n+            if (numval < 0) {\n                 cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                 return CL_EFORMAT;\n             }\n+            *value = numval;\n             return CL_SUCCESS;\n         }\n     }\n@@ -123,8 +126,18 @@ static void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** ck\n     if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n         xmlval = xmlTextReaderConstValue(reader);\n         if (xmlval) {\n-            *cksum = xmlStrdup(xmlval); \n-            cli_dbgmsg(\"cli_scanxar: checksum value is %s.\\n\", *cksum);\n+            cli_dbgmsg(\"cli_scanxar: checksum value is %s.\\n\", xmlval);\n+            if (*hash == XAR_CKSUM_SHA1 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_SHA1 ||\n+                *hash == XAR_CKSUM_MD5 && xmlStrlen(xmlval) == 2 * CLI_HASHLEN_MD5)\n+                {\n+                    *cksum = xmlStrdup(xmlval); \n+                } \n+            else\n+                {\n+                    cli_dbgmsg(\"cli_scanxar: checksum type is unknown or length is invalid.\\n\");\n+                    *hash = XAR_CKSUM_OTHER;\n+                    *cksum = NULL;\n+                }\n         } else {\n             *cksum = NULL;\n             cli_dbgmsg(\"cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\\n\");           \n@@ -149,7 +162,7 @@ static void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** ck\n      e_hash - pointer to int for returning extracted checksum algorithm.\n    returns - CL_FORMAT, CL_SUCCESS, CL_BREAK. CL_BREAK indicates no more <data>\/<ea> element.\n  *\/\n-static int xar_get_toc_data_values(xmlTextReaderPtr reader, long *length, long *offset, long *size, int *encoding,\n+static int xar_get_toc_data_values(xmlTextReaderPtr reader, size_t *length, size_t *offset, size_t *size, int *encoding,\n                                    unsigned char ** a_cksum, int * a_hash, unsigned char ** e_cksum, int * e_hash)\n {\n     const xmlChar *name;\n@@ -386,10 +399,10 @@ static int xar_hash_check(int hash, const void * result, const void * expected)\n         return 1;\n     switch (hash) {\n     case XAR_CKSUM_SHA1:\n-        len = SHA1_HASH_SIZE;\n+        len = CLI_HASHLEN_SHA1;\n         break;\n     case XAR_CKSUM_MD5:\n-        len = CLI_HASH_MD5;\n+        len = CLI_HASHLEN_MD5;\n         break;\n     case XAR_CKSUM_OTHER:\n     case XAR_CKSUM_NONE:\n@@ -417,7 +430,7 @@ int cli_scanxar(cli_ctx *ctx)\n     int fd = -1;\n     struct xar_header hdr;\n     fmap_t *map = *ctx->fmap;\n-    long length, offset, size, at;\n+    size_t length, offset, size, at;\n     int encoding;\n     z_stream strm;\n     char *toc, *tmpname;\n@@ -490,6 +503,13 @@ int cli_scanxar(cli_ctx *ctx)\n         goto exit_toc;\n     }\n \n+    if (hdr.toc_length_decompressed != strm.total_out) {\n+        cli_dbgmsg(\"TOC decompress length %\" PRIu64 \" does not match amount decompressed %lu\\n\",\n+                   hdr.toc_length_decompressed, strm.total_out);\n+        toc[strm.total_out] = '\\0';\n+        hdr.toc_length_decompressed = strm.total_out;\n+    }\n+\n     \/* cli_dbgmsg(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); *\/\n     \/* printf(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); *\/\n     \/* cli_dbgmsg(\"cli_scanxar: TOC end:\\n\"); *\/\n@@ -557,8 +577,8 @@ int cli_scanxar(cli_ctx *ctx)\n             goto exit_reader;\n         }\n \n-        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %li,\\n\"\n-                   \"from xar heap offset %li length %li\\n\",\n+        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %zu,\\n\"\n+                   \"from xar heap offset %zu length %zu\\n\",\n                    tmpname, size, offset, length);\n \n \n@@ -638,11 +658,14 @@ int cli_scanxar(cli_ctx *ctx)\n #define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 \/* estimated compression ratio 25% *\/\n             {\n                 struct CLI_LZMA lz;\n-                unsigned long in_remaining = length;\n+                unsigned long in_remaining = MIN(length, map->len - at);\n                 unsigned long out_size = 0;\n                 unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);\n                 int lret;\n-                \n+\n+                if (length > in_remaining)\n+                    length = in_remaining;\n+\n                 memset(&lz, 0, sizeof(lz));\n                 if (buff == NULL) {\n                     cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n@@ -655,8 +678,8 @@ int cli_scanxar(cli_ctx *ctx)\n                 if (blockp == NULL) {\n                     char errbuff[128];\n                     cli_strerror(errno, errbuff, sizeof(errbuff));\n-                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n-                               length, at, errbuff);\n+                    cli_dbgmsg(\"cli_scanxar: Can't read %i bytes @ %li, errno:%s.\\n\",\n+                               CLI_LZMA_HDR_SIZE, at, errbuff);\n                     rc = CL_EREAD;\n                     __lzma_wrap_free(NULL, buff);\n                     goto exit_tmpfile;\n@@ -693,7 +716,7 @@ int cli_scanxar(cli_ctx *ctx)\n                         char errbuff[128];\n                         cli_strerror(errno, errbuff, sizeof(errbuff));\n                         cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n-                                   length, at, errbuff);\n+                                   lz.avail_in, at, errbuff);\n                         rc = CL_EREAD;\n                         __lzma_wrap_free(NULL, buff);\n                         cli_LzmaShutdown(&lz);\n@@ -758,33 +781,31 @@ int cli_scanxar(cli_ctx *ctx)\n             \/* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest *\/\n             do_extract_cksum = 0;\n             {\n-                unsigned long write_len;\n-                \n+                size_t writelen = MIN(map->len - at, length);\n+\n                 if (ctx->engine->maxfilesize)\n-                    write_len = MIN((size_t)(ctx->engine->maxfilesize), (size_t)length);\n-                else\n-                    write_len = length;\n+                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);\n                     \n-                if (!(blockp = (void*)fmap_need_off_once(map, at, length))) {\n+                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {\n                     char errbuff[128];\n                     cli_strerror(errno, errbuff, sizeof(errbuff));\n-                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n-                               length, at, errbuff);\n+                    cli_dbgmsg(\"cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\\n\",\n+                               writelen, at, errbuff);\n                     rc = CL_EREAD;\n                     goto exit_tmpfile;\n                 }\n                 \n                 if (a_hash_ctx != NULL)\n-                    xar_hash_update(a_hash_ctx, blockp, length, a_hash);\n+                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);\n                 \n-                if (cli_writen(fd, blockp, write_len) < 0) {\n-                    cli_dbgmsg(\"cli_scanxar: cli_writen error %li bytes @ %li.\\n\", length, at);\n+                if (cli_writen(fd, blockp, writelen) < 0) {\n+                    cli_dbgmsg(\"cli_scanxar: cli_writen error %zu bytes @ %li.\\n\", writelen, at);\n                     rc = CL_EWRITE;\n                     goto exit_tmpfile;\n                 }\n                 \/*break;*\/\n             }          \n-        }\n+        } \/* end of switch *\/\n \n         if (rc == CL_SUCCESS) {\n             if (a_hash_ctx != NULL) {\n@@ -871,7 +892,7 @@ int cli_scanxar(cli_ctx *ctx)\n     cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n #endif\n     if (cksum_fails + extract_errors != 0) {\n-        cli_warnmsg(\"cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\\n\",\n+        cli_dbgmsg(\"cli_scanxar: %u checksum errors and %u extraction errors.\\n\",\n                     cksum_fails, extract_errors);\n     }\n \n","owner":"Cisco-Talos","repo":"clamav-devel","source":"cve"},{"CVE_ID":"CVE-2017-9227","CWE_ID":"125","category":"security","commit_id":"9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814","commit_message":"From 9690d3ab1f9bcd2db8cbe1fe3ee4a5da606b8814 Mon Sep 17 00:00:00 2001\nFrom: \"K.Kosako\" <kosako@sofnec.co.jp>\nDate: Tue, 23 May 2017 16:15:35 +0900\nSubject: [PATCH] fix #58 : access to invalid address by reg->dmin value\n\n---\n src\/regexec.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/src\/regexec.c b\/src\/regexec.c\nindex d4e577d..2fa0f3d 100644\n--- a\/src\/regexec.c\n+++ b\/src\/regexec.c\n@@ -3154,6 +3154,8 @@ forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n     }\n     else {\n       UChar *q = p + reg->dmin;\n+\n+      if (q >= end) return 0; \/* fail *\/\n       while (p < q) p += enclen(reg->enc, p);\n     }\n   }\n","owner":"kkos","repo":"oniguruma","source":"cve"},{"CVE_ID":"CVE-2018-10360","CWE_ID":"125","category":"security","commit_id":"a642587a9c9e2dd7feacdf513c3643ce26ad3c22","commit_message":"From a642587a9c9e2dd7feacdf513c3643ce26ad3c22 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Sat, 9 Jun 2018 16:00:06 +0000\nSubject: [PATCH] Avoid reading past the end of buffer (Rui Reis)\n\n---\n src\/readelf.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/readelf.c b\/src\/readelf.c\nindex 79c83f9f5..1f41b4611 100644\n--- a\/src\/readelf.c\n+++ b\/src\/readelf.c\n@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.142 2018\/05\/24 18:08:01 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.143 2018\/06\/09 16:00:06 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -842,7 +842,8 @@ do_core_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n \n \t\t\t\tcname = (unsigned char *)\n \t\t\t\t    &nbuf[doff + prpsoffsets(i)];\n-\t\t\t\tfor (cp = cname; *cp && isprint(*cp); cp++)\n+\t\t\t\tfor (cp = cname; cp < nbuf + size && *cp\n+\t\t\t\t    && isprint(*cp); cp++)\n \t\t\t\t\tcontinue;\n \t\t\t\t\/*\n \t\t\t\t * Linux apparently appends a space at the end\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2016-6906","CWE_ID":"125","category":"security","commit_id":"fb0e0cce0b9f25389ab56604c3547351617e1415","commit_message":"From fb0e0cce0b9f25389ab56604c3547351617e1415 Mon Sep 17 00:00:00 2001\nFrom: \"Christoph M. Becker\" <cmbecker69@gmx.de>\nDate: Tue, 16 Aug 2016 16:26:19 +0200\nSubject: [PATCH] Fix OOB reads of the TGA decompression buffer\n\nIt is possible to craft TGA files which will overflow the decompression\nbuffer, but not the image's bitmap. Therefore we augment the check for the\nbitmap's overflow with a check for the buffer's overflow.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org.\n\nCVE-2016-6906\n---\n src\/gd_tga.c                |   6 +++--\n tests\/tga\/.gitignore        |   1 +\n tests\/tga\/CMakeLists.txt    |   1 +\n tests\/tga\/Makemodule.am     |   2 ++\n tests\/tga\/heap_overflow.c   |  51 ++++++++++++++++++++++++++++++++++++\n tests\/tga\/heap_overflow.tga | Bin 0 -> 605 bytes\n 6 files changed, 59 insertions(+), 2 deletions(-)\n create mode 100644 tests\/tga\/heap_overflow.c\n create mode 100644 tests\/tga\/heap_overflow.tga\n\n","diff_code":"diff --git a\/src\/gd_tga.c b\/src\/gd_tga.c\nindex 8737b045..68e4b17d 100644\n--- a\/src\/gd_tga.c\n+++ b\/src\/gd_tga.c\n@@ -300,7 +300,8 @@ int read_image_tga( gdIOCtx *ctx, oTga *tga )\n \t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n \t\t\t\tbuffer_caret++;\n \n-\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n+\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n+\t\t\t\t\t\t|| buffer_caret + pixel_block_size > rle_size) {\n \t\t\t\t\tgdFree( decompression_buffer );\n \t\t\t\t\tgdFree( conversion_buffer );\n \t\t\t\t\treturn -1;\n@@ -316,7 +317,8 @@ int read_image_tga( gdIOCtx *ctx, oTga *tga )\n \t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n \t\t\t\tbuffer_caret++;\n \n-\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {\n+\t\t\t\tif ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size\n+\t\t\t\t\t\t|| buffer_caret + (encoded_pixels * pixel_block_size) > rle_size) {\n \t\t\t\t\tgdFree( decompression_buffer );\n \t\t\t\t\tgdFree( conversion_buffer );\n \t\t\t\t\treturn -1;\ndiff --git a\/tests\/tga\/.gitignore b\/tests\/tga\/.gitignore\nindex 7a659b14..cf0556b5 100644\n--- a\/tests\/tga\/.gitignore\n+++ b\/tests\/tga\/.gitignore\n@@ -3,5 +3,6 @@\n \/bug00247a\n \/bug00248\n \/bug00248a\n+\/heap_overflow\n \/tga_null\n \/tga_read\ndiff --git a\/tests\/tga\/CMakeLists.txt b\/tests\/tga\/CMakeLists.txt\nindex 789fb146..11542a03 100644\n--- a\/tests\/tga\/CMakeLists.txt\n+++ b\/tests\/tga\/CMakeLists.txt\n@@ -5,6 +5,7 @@ LIST(APPEND TESTS_FILES\n \tbug00247a\n \tbug00248\n \tbug00248a\n+\theap_overflow\n \ttga_read\n )\n \ndiff --git a\/tests\/tga\/Makemodule.am b\/tests\/tga\/Makemodule.am\nindex a1e6af60..916d7073 100644\n--- a\/tests\/tga\/Makemodule.am\n+++ b\/tests\/tga\/Makemodule.am\n@@ -4,6 +4,7 @@ libgd_test_programs += \\\n \ttga\/bug00247a \\\n \ttga\/bug00248 \\\n \ttga\/bug00248a \\\n+\ttga\/heap_overflow \\\n \ttga\/tga_null \\\n \ttga\/tga_read\n \n@@ -14,6 +15,7 @@ EXTRA_DIST += \\\n \ttga\/bug00247a.tga \\\n \ttga\/bug00248.tga \\\n \ttga\/bug00248a.tga \\\n+\ttga\/heap_overflow.tga \\\n \ttga\/tga_read_rgb.png \\\n \ttga\/tga_read_rgb.tga \\\n \ttga\/tga_read_rgb_rle.tga\ndiff --git a\/tests\/tga\/heap_overflow.c b\/tests\/tga\/heap_overflow.c\nnew file mode 100644\nindex 00000000..0e9a2d00\n--- \/dev\/null\n+++ b\/tests\/tga\/heap_overflow.c\n@@ -0,0 +1,51 @@\n+\/**\n+ * Test that the crafted TGA file doesn't trigger OOB reads.\n+ *\/\n+\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+\n+static size_t read_test_file(char **buffer, char *basename);\n+\n+\n+int main()\n+{\n+    gdImagePtr im;\n+    char *buffer;\n+    size_t size;\n+\n+    size = read_test_file(&buffer, \"heap_overflow.tga\");\n+    im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n+    gdTestAssert(im == NULL);\n+    free(buffer);\n+\n+    return gdNumFailures();\n+}\n+\n+\n+static size_t read_test_file(char **buffer, char *basename)\n+{\n+    char *filename;\n+    FILE *fp;\n+    size_t exp_size, act_size;\n+\n+    filename = gdTestFilePath2(\"tga\", basename);\n+    fp = fopen(filename, \"rb\");\n+    gdTestAssert(fp != NULL);\n+\n+\tfseek(fp, 0, SEEK_END);\n+\texp_size = ftell(fp);\n+\tfseek(fp, 0, SEEK_SET);\n+\n+    *buffer = malloc(exp_size);\n+    gdTestAssert(*buffer != NULL);\n+    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n+    gdTestAssert(act_size == exp_size);\n+\n+    fclose(fp);\n+    free(filename);\n+\n+    return act_size;\n+}\ndiff --git a\/tests\/tga\/heap_overflow.tga b\/tests\/tga\/heap_overflow.tga\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9bc0ecb2a847ac6edba92dd0ff61167b49002cd\nGIT binary patch\nliteral 605\nzcmZQz;9`IQ9tIu;g&7<$F3o7Yg1qzyh6tefy9wZAs2d<Uh*yuz=?XwW4Qvuv#g2nS\nzp93+mT0rVR>T&8(2TGy=f_l)@gSap~$FayUFu(!|SyJIFga^{8fGj~vwq8kkVgvv>\nCavop+\n\nliteral 0\nHcmV?d00001\n\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2018-11598","CWE_ID":"125","category":"security","commit_id":"bf4416ab9129ee3afd56739ea4e3cd0da5484b6b","commit_message":"From bf4416ab9129ee3afd56739ea4e3cd0da5484b6b Mon Sep 17 00:00:00 2001\nFrom: Gordon Williams <gw@pur3.co.uk>\nDate: Wed, 23 May 2018 17:27:51 +0100\nSubject: [PATCH] Fix bug if using an undefined member of an object for for..in\n (fix #1437)\n\n---\n ChangeLog     |  1 +\n src\/jsparse.c | 29 ++++++++++++-----------------\n 2 files changed, 13 insertions(+), 17 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex d91c8fb6d..c60267149 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -3,6 +3,7 @@\n             Fix parsing of try..catch when not executing (fix #1439)\n             Add extra ReferenceError checks, even if variable is not used\n             Allow Ctrl-C out of while...continue loop (fix #1441)\n+            Fix bug if using an undefined member of an object for for..in (fix #1437)\n \n      1v99 : Increase jslMatch error buffer size to handle \"UNFINISHED TEMPLATE LITERAL\" string (#1426)\n             nRF5x: Make FlashWrite cope with flash writes > 4k\ndiff --git a\/src\/jsparse.c b\/src\/jsparse.c\nindex 136e511dd..e0af90ecc 100644\n--- a\/src\/jsparse.c\n+++ b\/src\/jsparse.c\n@@ -122,6 +122,16 @@ void jspReplaceWith(JsVar *dst, JsVar *src) {\n   }\n }\n \n+void jspReplaceWithOrAddToRoot(JsVar *dst, JsVar *src) {\n+  \/* If we're assigning to this and we don't have a parent,\n+   * add it to the symbol table root *\/\n+  if (!jsvGetRefs(dst) && jsvIsName(dst)) {\n+    if (!jsvIsArrayBufferName(dst) && !jsvIsNewChild(dst))\n+      jsvAddName(execInfo.root, dst);\n+  }\n+  jspReplaceWith(dst, src);\n+}\n+\n bool jspeiAddScope(JsVar *scope) {\n   if (execInfo.scopeCount >= JSPARSE_MAX_SCOPES) {\n     jsExceptionHere(JSET_ERROR, \"Maximum number of scopes exceeded\");\n@@ -1971,13 +1981,7 @@ NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {\n \n     if (JSP_SHOULD_EXECUTE && lhs) {\n       if (op=='=') {\n-        \/* If we're assigning to this and we don't have a parent,\n-         * add it to the symbol table root *\/\n-        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {\n-          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))\n-            jsvAddName(execInfo.root, lhs);\n-        }\n-        jspReplaceWith(lhs, rhs);\n+        jspReplaceWithOrAddToRoot(lhs, rhs);\n       } else {\n         if (op==LEX_PLUSEQUAL) op='+';\n         else if (op==LEX_MINUSEQUAL) op='-';\n@@ -2330,12 +2334,6 @@ NO_INLINE JsVar *jspeStatementFor() {\n       jsExceptionHere(JSET_ERROR, \"FOR a IN b - 'a' must be a variable name, not %t\", forStatement);\n       return 0;\n     }\n-    bool addedIteratorToScope = false;\n-    if (JSP_SHOULD_EXECUTE && !jsvGetRefs(forStatement)) {\n-      \/\/ if the variable did not exist, add it to the scope\n-      addedIteratorToScope = true;\n-      jsvAddName(execInfo.root, forStatement);\n-    }\n     JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_R_IN, jsvUnLock(forStatement), 0);\n     JsVar *array = jsvSkipNameAndUnLock(jspeExpression());\n     JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(forStatement, array), 0);\n@@ -2371,7 +2369,7 @@ NO_INLINE JsVar *jspeStatementFor() {\n                 loopIndexVar;\n             if (indexValue) { \/\/ could be out of memory\n               assert(!jsvIsName(indexValue) && jsvGetRefs(indexValue)==0);\n-              jsvSetValueOfName(forStatement, indexValue);\n+              jspReplaceWithOrAddToRoot(forStatement, indexValue);\n               if (indexValue!=loopIndexVar) jsvUnLock(indexValue);\n \n               jsvIteratorNext(&it);\n@@ -2410,9 +2408,6 @@ NO_INLINE JsVar *jspeStatementFor() {\n     jslCharPosFree(&forBodyStart);\n     jslCharPosFree(&forBodyEnd);\n \n-    if (addedIteratorToScope) {\n-      jsvRemoveChild(execInfo.root, forStatement);\n-    }\n     jsvUnLock2(forStatement, array);\n   } else { \/\/ ----------------------------------------------- NORMAL FOR LOOP\n #ifdef JSPARSE_MAX_LOOP_ITERATIONS\n","owner":"espruino","repo":"Espruino","source":"cve"},{"CVE_ID":"CVE-2017-8313","CWE_ID":"125","category":"security","commit_id":"05b653355ce303ada3b5e0e645ae717fea39186c","commit_message":"From 05b653355ce303ada3b5e0e645ae717fea39186c Mon Sep 17 00:00:00 2001\nFrom: =?utf8?q?Filip=20Ros=C3=A9en?= <filip@atch.se>\nDate: Mon, 20 Feb 2017 14:59:37 +0100\nSubject: [PATCH] demux\/subtitle: ParseJSS: fix out-of-bounds read\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nThe previous loop would continue until a space is found, which of course means\nthat it would step out of bounds if the string did not contain such.\n\nThese changes simply terminates the loop if the end of the string is reached.\n\nSigned-off-by: Jean-Baptiste Kempf <jb@videolan.org>\n(cherry picked from commit 181117ea2362ea2ccda69371ce8109970717d318)\nSigned-off-by: Hugo Beauz\u00c3\u00a9e-Luyssen <hugo@beauzee.fr>\n\nMissing backport pointed out by: Yannay Livneh <yannayl@checkpoint.com>\n                                 Omri Herscovici <omrih@checkpoint.com>\n                                 Omer Gull <omergu@checkpoint.com>\n---\n modules\/demux\/subtitle.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/modules\/demux\/subtitle.c b\/modules\/demux\/subtitle.c\nindex 6470756507..3e790fd307 100644\n--- a\/modules\/demux\/subtitle.c\n+++ b\/modules\/demux\/subtitle.c\n@@ -1809,8 +1809,8 @@ static int ParseJSS( demux_t *p_demux, subtitle_t *p_subtitle, int i_idx )\n     \/* Parse the directives *\/\n     if( isalpha( (unsigned char)*psz_text ) || *psz_text == '[' )\n     {\n-        while( *psz_text != ' ' )\n-        { psz_text++ ;};\n+        while( *psz_text && *psz_text != ' ' )\n+            ++psz_text;\n \n         \/* Directives are NOT parsed yet *\/\n         \/* This has probably a better place in a decoder ? *\/\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-7456","CWE_ID":"125","category":"security","commit_id":"7a1aac3343af85b4af4df5f8844946eaa27394ab","commit_message":"From 7a1aac3343af85b4af4df5f8844946eaa27394ab Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Mon, 23 May 2016 00:28:02 -0700\nSubject: [PATCH] Fixed bug #72227: imagescale out-of-bounds read\n\nPorted from https:\/\/github.com\/libgd\/libgd\/commit\/4f65a3e4eedaffa1efcf9ee1eb08f0b504fbc31a\n---\n ext\/gd\/libgd\/gd_interpolation.c | 16 ++++++++--------\n ext\/gd\/tests\/bug72227.phpt      | 15 +++++++++++++++\n 2 files changed, 23 insertions(+), 8 deletions(-)\n create mode 100644 ext\/gd\/tests\/bug72227.phpt\n\n","diff_code":"diff --git a\/ext\/gd\/libgd\/gd_interpolation.c b\/ext\/gd\/libgd\/gd_interpolation.c\nindex 6b7360a6def3..a01749838301 100644\n--- a\/ext\/gd\/libgd\/gd_interpolation.c\n+++ b\/ext\/gd\/libgd\/gd_interpolation.c\n@@ -39,8 +39,8 @@\n \tdownscaling using the fixed point implementations are usually much faster\n \tthan the existing gdImageCopyResampled while having a similar or better\n \tquality.\n-\t\n-\tFor image rotations, the optimized versions have a lazy antialiasing for \n+\n+\tFor image rotations, the optimized versions have a lazy antialiasing for\n \tthe edges of the images. For a much better antialiased result, the affine\n \tfunction is recommended.\n *\/\n@@ -633,7 +633,7 @@ static inline int _color_blend (const int dst, const int src)\n \t}\n }\n \n-static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) \n+static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)\n {\n \tconst gdFixed f_127 = gd_itofx(127);\n \tregister int c = src->tpixels[y][x];\n@@ -934,9 +934,6 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n         double dTotalWeight = 0.0;\n \t\tint iSrc;\n \n-        res->ContribRow[u].Left = iLeft;\n-        res->ContribRow[u].Right = iRight;\n-\n         \/* Cut edge points to fit in filter window in case of spill-off *\/\n         if (iRight - iLeft + 1 > windows_size)  {\n             if (iLeft < ((int)src_size - 1 \/ 2))  {\n@@ -946,6 +943,9 @@ static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsi\n             }\n         }\n \n+        res->ContribRow[u].Left = iLeft;\n+        res->ContribRow[u].Right = iRight;\n+\n         for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n             dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n         }\n@@ -2273,7 +2273,7 @@ int gdTransformAffineGetImage(gdImagePtr *dst,\n \tif (!src->trueColor) {\n \t\tgdImagePaletteToTrueColor(src);\n \t}\n-\t\n+\n \t\/* Translate to dst origin (0,0) *\/\n \tgdAffineTranslate(m, -bbox.x, -bbox.y);\n \tgdAffineConcat(m, affine, m);\n@@ -2332,7 +2332,7 @@ int gdTransformAffineCopy(gdImagePtr dst,\n \tif (src->interpolation_id == GD_BILINEAR_FIXED || src->interpolation_id == GD_BICUBIC_FIXED || src->interpolation_id == GD_NEAREST_NEIGHBOUR) {\n \t\tinterpolation_id_bak = src->interpolation_id;\n \t\tinterpolation_bak = src->interpolation;\n-\t\t\n+\n \t\tgdImageSetInterpolationMethod(src, GD_BICUBIC);\n \t}\n \ndiff --git a\/ext\/gd\/tests\/bug72227.phpt b\/ext\/gd\/tests\/bug72227.phpt\nnew file mode 100644\nindex 000000000000..6252be7d0ebf\n--- \/dev\/null\n+++ b\/ext\/gd\/tests\/bug72227.phpt\n@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #72227: imagescale out-of-bounds read\n+--SKIPIF--\n+<?php\n+\tif (!extension_loaded('gd')) die(\"skip gd extension not available\\n\");\n+?>\n+--FILE--\n+<?php\n+\n+$img = imagecreatetruecolor ( 100, 100);\n+imagescale($img, 13, 1, IMG_BICUBIC);\n+?>\n+DONE\n+--EXPECT--\n+DONE\n\\ No newline at end of file\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2016-9583","CWE_ID":"125","category":"security","commit_id":"f25486c3d4aa472fec79150f2c41ed4333395d3d","commit_message":"From f25486c3d4aa472fec79150f2c41ed4333395d3d Mon Sep 17 00:00:00 2001\nFrom: Michael Adams <mdadams@ece.uvic.ca>\nDate: Sat, 26 Nov 2016 20:54:24 -0800\nSubject: [PATCH] Fixed a bug in the packet iterator code. Added a new\n regression test case.\n\n---\n data\/test\/good\/PoC2.jpc       | Bin 0 -> 569 bytes\n src\/libjasper\/jpc\/jpc_t2cod.c |   4 ++--\n 2 files changed, 2 insertions(+), 2 deletions(-)\n create mode 100644 data\/test\/good\/PoC2.jpc\n\n","diff_code":"diff --git a\/data\/test\/good\/PoC2.jpc b\/data\/test\/good\/PoC2.jpc\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..6ce94dd1e096a689d092b436d0d373b55afc4c8e\nGIT binary patch\nliteral 569\nzcmYk0Jxc>Y5Qb;Z^ESD=Tt18%6D5a=L`WnCD+ReANYKJBu(A;~CZGn+6oO6i2Sm@x\nzPP?>9et=yHk)*Imnsm`$kiur&8#vsB8D{2r-`Qb1Y!A{P0e}uB4*;2m``r4!m#9oA\nzA#5KEDggl^%RGnK0ceC^6P{&9KrO3K*kz}X0kUDA9ak&%s+m8`Y~{Ai)XAcm%Vx7_\nzo|eu0#d*a%EMJ!^SL_~C_eb&uggvqc_k?yc%ACN!PWiAW?WW8einY|QrFi|cu=I`n\nzh`?lI1|4j6k&OyW!JYcBI{ZLJ1?KD5V$3n<4HCaV)OJ&6j{ciKq6tKAzw?`9oCjJx\nzf3OirmiQK_pvqcZS<{MjWJZlSSOmE!S(;z(SX}gTJD{JPJI!ACLKqUZg*`_^7>>1i\nzG}us+r4VxzYmUD9bTmdi@p!AJ0&_@FeNH2p5ZsfVDkco4T0O;eTn14e_cRG_Q~V`>\nLWLhxIxT@|S8-~Dq\n\nliteral 0\nHcmV?d00001\n\ndiff --git a\/src\/libjasper\/jpc\/jpc_t2cod.c b\/src\/libjasper\/jpc\/jpc_t2cod.c\nindex 5e2c862..91114e3 100644\n--- a\/src\/libjasper\/jpc\/jpc_t2cod.c\n+++ b\/src\/libjasper\/jpc\/jpc_t2cod.c\n@@ -249,9 +249,9 @@ static int jpc_pi_nextrpcl(register jpc_pi_t *pi)\n \t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n \t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n \t\t\t\t\/\/ Check for the potential for overflow problems.\n-\t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n+\t\t\t\tif (pirlvl->prcwidthexpn + picomp->numrlvls >\n \t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n-\t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n+\t\t\t\t  pirlvl->prcheightexpn + picomp->numrlvls >\n \t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n \t\t\t\t\treturn -1;\n \t\t\t\t}\n","owner":"mdadams","repo":"jasper","source":"cve"},{"CVE_ID":"CVE-2016-7151","CWE_ID":"125","category":"security","commit_id":"87a25bb543c8e4c09b48d4b4a6c7db31ce58df06","commit_message":"From 87a25bb543c8e4c09b48d4b4a6c7db31ce58df06 Mon Sep 17 00:00:00 2001\nFrom: Nguyen Anh Quynh <aquynh@gmail.com>\nDate: Sat, 27 Aug 2016 20:54:37 +0800\nSubject: [PATCH] x86: fast path checking for X86_insn_reg_intel()\n\n---\n arch\/X86\/X86Mapping.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/arch\/X86\/X86Mapping.c b\/arch\/X86\/X86Mapping.c\nindex 61c9ce430..a9d8980f3 100644\n--- a\/arch\/X86\/X86Mapping.c\n+++ b\/arch\/X86\/X86Mapping.c\n@@ -2930,15 +2930,15 @@ static int regs_cmp(const void *a, const void *b)\n \treturn (l - r);\n }\n \n-static bool intel_regs_sorted = false;\n \/\/ return register of given instruction id\n \/\/ return 0 if not found\n \/\/ this is to handle instructions embedding accumulate registers into AsmStrs[]\n x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)\n {\n+\tstatic bool intel_regs_sorted = false;\n \tunsigned int first = 0;\n \tunsigned int last = ARR_SIZE(insn_regs_intel) - 1;\n-\tunsigned int mid = ARR_SIZE(insn_regs_intel) \/ 2;\n+\tunsigned int mid;\n \n \tif (!intel_regs_sorted) {\n \t\tmemcpy(insn_regs_intel_sorted, insn_regs_intel,\n@@ -2949,7 +2949,13 @@ x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)\n \t\tintel_regs_sorted = true;\n \t}\n \n+\tif (insn_regs_intel_sorted[0].insn > id ||\n+\t\t\tinsn_regs_intel_sorted[last].insn < id) {\n+\t\treturn 0;\n+\t}\n+\n \twhile (first <= last) {\n+\t\tmid = (first + last) \/ 2;\n \t\tif (insn_regs_intel_sorted[mid].insn < id) {\n \t\t\tfirst = mid + 1;\n \t\t} else if (insn_regs_intel_sorted[mid].insn == id) {\n@@ -2962,7 +2968,6 @@ x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)\n \t\t\t\tbreak;\n \t\t\tlast = mid - 1;\n \t\t}\n-\t\tmid = (first + last) \/ 2;\n \t}\n \n \t\/\/ not found\n","owner":"aquynh","repo":"capstone","source":"cve"},{"CVE_ID":"CVE-2017-9454","CWE_ID":"125","category":"security","commit_id":"d67a9ca6fd06ca65d23e313bdbad1ef4dd3aa0df","commit_message":"From d67a9ca6fd06ca65d23e313bdbad1ef4dd3aa0df Mon Sep 17 00:00:00 2001\nFrom: Gregor Jasny <gjasny@googlemail.com>\nDate: Tue, 6 Jun 2017 17:49:32 +0200\nSubject: [PATCH] ares: Prevent buffer overlow in ares_parse_a_reply\n (CVE-2017-9454)\n\nThis buffer overflow is in the embedded copy of ares that will be\nused unless the external alternative c-ares is used by specifying\nthe configure argument --with-c-ares.\n\nIt has been found with LibFuzzer from the LLVM project.\n---\n rutil\/dns\/ares\/ares_parse_a_reply.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/rutil\/dns\/ares\/ares_parse_a_reply.c b\/rutil\/dns\/ares\/ares_parse_a_reply.c\nindex 2733fe4424..100f3848d7 100644\n--- a\/rutil\/dns\/ares\/ares_parse_a_reply.c\n+++ b\/rutil\/dns\/ares\/ares_parse_a_reply.c\n@@ -103,6 +103,12 @@ int ares_parse_a_reply(const unsigned char *abuf, int alen,\n       rr_class = DNS_RR_CLASS(aptr);\n       rr_len = DNS_RR_LEN(aptr);\n       aptr += RRFIXEDSZ;\n+      if (aptr + rr_len > abuf + alen)\n+\t{\n+\t  free(rr_name);\n+\t  status = ARES_EBADRESP;\n+\t  break;\n+\t}\n \n       if (rr_class == C_IN && rr_type == T_A\n \t  && rr_len == sizeof(struct in_addr)\n","owner":"resiprocate","repo":"resiprocate","source":"cve"},{"CVE_ID":"CVE-2016-1249","CWE_ID":"125","category":"security","commit_id":"793b72b1a0baa5070adacaac0e12fd995a6fbabe","commit_message":"From 793b72b1a0baa5070adacaac0e12fd995a6fbabe Mon Sep 17 00:00:00 2001\nFrom: root <patg@patg.net>\nDate: Wed, 16 Nov 2016 03:40:40 +0000\nSubject: [PATCH] Added Pali's fix for CVE-2016-1249\n\n---\n Changes                    |   3 +\n dbdimp.c                   |  18 +-----\n lib\/Bundle\/DBD\/mysql.pm    |   2 +-\n lib\/DBD\/mysql.pm           |   2 +-\n mysql.xs                   | 128 +++----------------------------------\n t\/40server_prepare_crash.t |   8 ++-\n 6 files changed, 22 insertions(+), 139 deletions(-)\n\n","diff_code":"diff --git a\/Changes b\/Changes\nindex a5c1b55..703f250 100644\n--- a\/Changes\n+++ b\/Changes\n@@ -1,3 +1,6 @@\n+2016-11-15 Patrick Galbraith, Michiel Beijen, DBI\/DBD community (4.039)\n+* Fix for security issue Out-of-bounds read by DBD::mysql CVE-2016-1249 (pali)\n+\n 2016-10-30 Patrick Galbraith, Michiel Beijen, DBI\/DBD community (4.038_01)\n * Fix compilation of embedded server (pali)\n   (https:\/\/github.com\/perl5-dbi\/DBD-mysql\/pull\/68)\ndiff --git a\/dbdimp.c b\/dbdimp.c\nindex bbc9622..c1ef3ff 100644\n--- a\/dbdimp.c\n+++ b\/dbdimp.c\n@@ -2750,7 +2750,7 @@ dbd_st_prepare(\n   int limit_flag=0;\n #endif\n #endif\n-  int col_type, prepare_retval;\n+  int prepare_retval;\n   MYSQL_BIND *bind, *bind_end;\n   imp_sth_phb_t *fbind;\n #endif\n@@ -2946,7 +2946,6 @@ dbd_st_prepare(\n \n       if (DBIc_NUM_PARAMS(imp_sth) > 0)\n       {\n-        int has_statement_fields= imp_sth->stmt->fields != 0;\n         \/* Allocate memory for bind variables *\/\n         imp_sth->bind=            alloc_bind(DBIc_NUM_PARAMS(imp_sth));\n         imp_sth->fbind=           alloc_fbind(DBIc_NUM_PARAMS(imp_sth));\n@@ -2960,20 +2959,7 @@ dbd_st_prepare(\n              bind < bind_end ;\n              bind++, fbind++, i++ )\n         {\n-          \/*\n-            if this statement has a result set, field types will be\n-            correctly identified. If there is no result set, such as\n-            with an INSERT, fields will not be defined, and all buffer_type\n-            will default to MYSQL_TYPE_VAR_STRING\n-          *\/\n-          col_type= (has_statement_fields ?\n-                     imp_sth->stmt->fields[i].type : MYSQL_TYPE_STRING);\n-\n-          bind->buffer_type=  mysql_to_perl_type(col_type);\n-\n-          if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n-            PerlIO_printf(DBIc_LOGPIO(imp_xxh), \"\\t\\tmysql_to_perl_type returned %d\\n\", col_type);\n-\n+          bind->buffer_type=  MYSQL_TYPE_STRING;\n           bind->buffer=       NULL;\n           bind->length=       &(fbind->length);\n           bind->is_null=      (char*) &(fbind->is_null);\ndiff --git a\/lib\/Bundle\/DBD\/mysql.pm b\/lib\/Bundle\/DBD\/mysql.pm\nindex b28e1d5..2bd5f32 100644\n--- a\/lib\/Bundle\/DBD\/mysql.pm\n+++ b\/lib\/Bundle\/DBD\/mysql.pm\n@@ -3,7 +3,7 @@ package Bundle::DBD::mysql;\n use strict;\n use warnings;\n \n-our $VERSION = '4.038_01';\n+our $VERSION = '4.039';\n \n 1;\n \ndiff --git a\/lib\/DBD\/mysql.pm b\/lib\/DBD\/mysql.pm\nindex fb86937..b74e66d 100644\n--- a\/lib\/DBD\/mysql.pm\n+++ b\/lib\/DBD\/mysql.pm\n@@ -15,7 +15,7 @@ our @ISA = qw(DynaLoader);\n # SQL_DRIVER_VER is formatted as dd.dd.dddd\n # for version 5.x please switch to 5.00(_00) version numbering\n # keep $VERSION in Bundle\/DBD\/mysql.pm in sync\n-our $VERSION = '4.038_01';\n+our $VERSION = '4.039';\n \n bootstrap DBD::mysql $VERSION;\n \ndiff --git a\/mysql.xs b\/mysql.xs\nindex 9343b75..462eb2a 100644\n--- a\/mysql.xs\n+++ b\/mysql.xs\n@@ -266,15 +266,11 @@ do(dbh, statement, attr=Nullsv, ...)\n   STRLEN slen;\n   char            *str_ptr, *buffer;\n   int             has_binded;\n-  int             col_type= MYSQL_TYPE_STRING;\n-  int             buffer_is_null= 0;\n   int             buffer_length= slen;\n   int             buffer_type= 0;\n-  int             param_type= SQL_VARCHAR;\n   int             use_server_side_prepare= 0;\n   MYSQL_STMT      *stmt= NULL;\n   MYSQL_BIND      *bind= NULL;\n-  imp_sth_phb_t   *fbind= NULL;\n #endif\n     ASYNC_CHECK_XS(dbh);\n #if MYSQL_VERSION_ID >= MULTIPLE_RESULT_SET_VERSION\n@@ -367,142 +363,36 @@ do(dbh, statement, attr=Nullsv, ...)\n         *\/\n         int i;\n         num_params= items - 3;\n-        \/*num_params = mysql_stmt_param_count(stmt);*\/\n-        Newz(0, params, sizeof(*params)*num_params, struct imp_sth_ph_st);\n         Newz(0, bind, (unsigned int) num_params, MYSQL_BIND);\n-        Newz(0, fbind, (unsigned int) num_params, imp_sth_phb_t);\n \n         for (i = 0; i < num_params; i++)\n         {\n           int defined= 0;\n-          params[i].value= ST(i+3);\n+          SV *param= ST(i+3);\n \n-          if (params[i].value)\n+          if (param)\n           {\n-            if (SvMAGICAL(params[i].value))\n-              mg_get(params[i].value);\n-            if (SvOK(params[i].value))\n+            if (SvMAGICAL(param))\n+              mg_get(param);\n+            if (SvOK(param))\n               defined= 1;\n           }\n           if (defined)\n           {\n-            buffer= SvPV(params[i].value, slen);\n-            buffer_is_null= 0;\n+            buffer= SvPV(param, slen);\n             buffer_length= slen;\n+            buffer_type= MYSQL_TYPE_STRING;\n           }\n           else\n           {\n             buffer= NULL;\n-            buffer_is_null= 1;\n             buffer_length= 0;\n-          }\n-\n-          \/*\n-            if this statement has a result set, field types will be\n-            correctly identified. If there is no result set, such as\n-            with an INSERT, fields will not be defined, and all\n-            buffer_type will default to MYSQL_TYPE_VAR_STRING\n-          *\/\n-          col_type= (stmt->fields) ? stmt->fields[i].type : MYSQL_TYPE_STRING;\n-\n-          switch (col_type) {\n-#if MYSQL_VERSION_ID > 50003\n-          case MYSQL_TYPE_NEWDECIMAL:\n-#endif\n-          case MYSQL_TYPE_DECIMAL:\n-            param_type= SQL_DECIMAL;\n-            buffer_type= MYSQL_TYPE_DOUBLE;\n-            break;\n-\n-          case MYSQL_TYPE_DOUBLE:\n-            param_type= SQL_DOUBLE;\n-            buffer_type= MYSQL_TYPE_DOUBLE;\n-            break;\n-\n-          case MYSQL_TYPE_FLOAT:\n-            buffer_type= MYSQL_TYPE_DOUBLE;\n-            param_type= SQL_FLOAT;\n-            break;\n-\n-          case MYSQL_TYPE_SHORT:\n-            buffer_type= MYSQL_TYPE_DOUBLE;\n-            param_type= SQL_FLOAT;\n-            break;\n-\n-          case MYSQL_TYPE_TINY:\n-            buffer_type= MYSQL_TYPE_DOUBLE;\n-            param_type= SQL_FLOAT;\n-            break;\n-\n-          case MYSQL_TYPE_LONG:\n-            buffer_type= MYSQL_TYPE_LONG;\n-            param_type= SQL_BIGINT;\n-            break;\n-\n-          case MYSQL_TYPE_INT24:\n-          case MYSQL_TYPE_YEAR:\n-            buffer_type= MYSQL_TYPE_LONG;\n-            param_type= SQL_INTEGER; \n-            break;\n-\n-          case MYSQL_TYPE_LONGLONG:\n-#if IVSIZE < 8\n-            \/* perl handles long long as double\n-             * so we'll set this to string *\/\n-            buffer_type= MYSQL_TYPE_STRING;\n-            param_type= SQL_VARCHAR;\n-#else\n-            buffer_type= MYSQL_TYPE_LONG;\n-            param_type= SQL_BIGINT;\n-#endif\n-            break;\n-\n-          case MYSQL_TYPE_NEWDATE:\n-          case MYSQL_TYPE_DATE:\n-            buffer_type= MYSQL_TYPE_STRING;\n-            param_type= SQL_DATE;\n-            break;\n-\n-          case MYSQL_TYPE_TIME:\n-            buffer_type= MYSQL_TYPE_STRING;\n-            param_type= SQL_TIME;\n-            break;\n-\n-          case MYSQL_TYPE_TIMESTAMP:\n-            buffer_type= MYSQL_TYPE_STRING;\n-            param_type= SQL_TIMESTAMP;\n-            break;\n-\n-          case MYSQL_TYPE_VAR_STRING:\n-          case MYSQL_TYPE_STRING:\n-          case MYSQL_TYPE_DATETIME:\n-            buffer_type= MYSQL_TYPE_STRING;\n-            param_type= SQL_VARCHAR;\n-            break;\n-\n-          case MYSQL_TYPE_BLOB:\n-            buffer_type= MYSQL_TYPE_BLOB;\n-            param_type= SQL_BINARY;\n-            break;\n-\n-          case MYSQL_TYPE_GEOMETRY:\n-            buffer_type= MYSQL_TYPE_BLOB;\n-            param_type= SQL_BINARY;\n-            break;\n-\n-\n-          default:\n-            buffer_type= MYSQL_TYPE_STRING;\n-            param_type= SQL_VARCHAR;\n-            break;\n+            buffer_type= MYSQL_TYPE_NULL;\n           }\n \n           bind[i].buffer_type = buffer_type;\n           bind[i].buffer_length= buffer_length;\n           bind[i].buffer= buffer;\n-          fbind[i].length= buffer_length;\n-          fbind[i].is_null= buffer_is_null;\n-          params[i].type= param_type;\n         }\n         has_binded= 0;\n       }\n@@ -514,8 +404,6 @@ do(dbh, statement, attr=Nullsv, ...)\n                                            &has_binded);\n       if (bind)\n         Safefree(bind);\n-      if (fbind)\n-        Safefree(fbind);\n \n       if(mysql_stmt_close(stmt))\n       {\ndiff --git a\/t\/40server_prepare_crash.t b\/t\/40server_prepare_crash.t\nindex ea732f7..99a06e1 100644\n--- a\/t\/40server_prepare_crash.t\n+++ b\/t\/40server_prepare_crash.t\n@@ -10,7 +10,7 @@ require \"t\/lib.pl\";\n my $dbh = eval { DBI->connect($test_dsn, $test_user, $test_password, { PrintError => 1, RaiseError => 1, AutoCommit => 0, mysql_server_prepare => 1 }) };\n plan skip_all => \"no database connection\" if $@ or not $dbh;\n \n-plan tests => 13;\n+plan tests => 17;\n \n ok $dbh->do(\"CREATE TEMPORARY TABLE t (i INTEGER NOT NULL, n TEXT)\");\n \n@@ -30,4 +30,10 @@ ok $sth = $dbh->prepare(\"SELECT * FROM t WHERE i=? AND n=?\");\n ok $sth->execute();\n ok $sth->finish();\n \n+ok $sth = $dbh->prepare(\"SELECT 1 FROM t WHERE i = ?\" . (\" OR i = ?\" x 10000));\n+ok $sth->execute((1) x (10001));\n+ok $sth->finish();\n+\n+ok $dbh->do(\"SELECT 1 FROM t WHERE i = ?\" . (\" OR i = ?\" x 10000), {}, (1) x (10001));\n+\n ok $dbh->disconnect();\n","owner":"perl5-dbi","repo":"DBD-mysql","source":"cve"},{"CVE_ID":"CVE-2017-7277","CWE_ID":"125","category":"security","commit_id":"4ef1b2869447411ad3ef91ad7d4891a83c1a509a","commit_message":"From 4ef1b2869447411ad3ef91ad7d4891a83c1a509a Mon Sep 17 00:00:00 2001\nFrom: Soheil Hassas Yeganeh <soheil@google.com>\nDate: Sat, 18 Mar 2017 17:03:00 -0400\nSubject: tcp: mark skbs with SCM_TIMESTAMPING_OPT_STATS\n\nSOF_TIMESTAMPING_OPT_STATS can be enabled and disabled\nwhile packets are collected on the error queue.\nSo, checking SOF_TIMESTAMPING_OPT_STATS in sk->sk_tsflags\nis not enough to safely assume that the skb contains\nOPT_STATS data.\n\nAdd a bit in sock_exterr_skb to indicate whether the\nskb contains opt_stats data.\n\nFixes: 1c885808e456 (\"tcp: SOF_TIMESTAMPING_OPT_STATS option for SO_TIMESTAMPING\")\nReported-by: JongHwan Kim <zzoru007@gmail.com>\nSigned-off-by: Soheil Hassas Yeganeh <soheil@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Willem de Bruijn <willemb@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/linux\/errqueue.h |  2 ++\n net\/core\/skbuff.c        | 17 +++++++++++------\n net\/socket.c             |  2 +-\n 3 files changed, 14 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/errqueue.h b\/include\/linux\/errqueue.h\nindex 9ca23fcfb5d7..6fdfc884fdeb 100644\n--- a\/include\/linux\/errqueue.h\n+++ b\/include\/linux\/errqueue.h\n@@ -20,6 +20,8 @@ struct sock_exterr_skb {\n \tstruct sock_extended_err\tee;\n \tu16\t\t\t\taddr_offset;\n \t__be16\t\t\t\tport;\n+\tu8\t\t\t\topt_stats:1,\n+\t\t\t\t\tunused:7;\n };\n \n #endif\ndiff --git a\/net\/core\/skbuff.c b\/net\/core\/skbuff.c\nindex b1fbd1958eb6..9f781092fda9 100644\n--- a\/net\/core\/skbuff.c\n+++ b\/net\/core\/skbuff.c\n@@ -3793,16 +3793,20 @@ EXPORT_SYMBOL(skb_clone_sk);\n \n static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n \t\t\t\t\tstruct sock *sk,\n-\t\t\t\t\tint tstype)\n+\t\t\t\t\tint tstype,\n+\t\t\t\t\tbool opt_stats)\n {\n \tstruct sock_exterr_skb *serr;\n \tint err;\n \n+\tBUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));\n+\n \tserr = SKB_EXT_ERR(skb);\n \tmemset(serr, 0, sizeof(*serr));\n \tserr->ee.ee_errno = ENOMSG;\n \tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n \tserr->ee.ee_info = tstype;\n+\tserr->opt_stats = opt_stats;\n \tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n \t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n \t\tif (sk->sk_protocol == IPPROTO_TCP &&\n@@ -3843,7 +3847,7 @@ void skb_complete_tx_timestamp(struct sk_buff *skb,\n \t *\/\n \tif (likely(atomic_inc_not_zero(&sk->sk_refcnt))) {\n \t\t*skb_hwtstamps(skb) = *hwtstamps;\n-\t\t__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);\n+\t\t__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND, false);\n \t\tsock_put(sk);\n \t}\n }\n@@ -3854,7 +3858,7 @@ void __skb_tstamp_tx(struct sk_buff *orig_skb,\n \t\t     struct sock *sk, int tstype)\n {\n \tstruct sk_buff *skb;\n-\tbool tsonly;\n+\tbool tsonly, opt_stats = false;\n \n \tif (!sk)\n \t\treturn;\n@@ -3867,9 +3871,10 @@ void __skb_tstamp_tx(struct sk_buff *orig_skb,\n #ifdef CONFIG_INET\n \t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&\n \t\t    sk->sk_protocol == IPPROTO_TCP &&\n-\t\t    sk->sk_type == SOCK_STREAM)\n+\t\t    sk->sk_type == SOCK_STREAM) {\n \t\t\tskb = tcp_get_timestamping_opt_stats(sk);\n-\t\telse\n+\t\t\topt_stats = true;\n+\t\t} else\n #endif\n \t\t\tskb = alloc_skb(0, GFP_ATOMIC);\n \t} else {\n@@ -3888,7 +3893,7 @@ void __skb_tstamp_tx(struct sk_buff *orig_skb,\n \telse\n \t\tskb->tstamp = ktime_get_real();\n \n-\t__skb_complete_tx_timestamp(skb, sk, tstype);\n+\t__skb_complete_tx_timestamp(skb, sk, tstype, opt_stats);\n }\n EXPORT_SYMBOL_GPL(__skb_tstamp_tx);\n \ndiff --git a\/net\/socket.c b\/net\/socket.c\nindex 692d6989d2c2..985ef06792d6 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -706,7 +706,7 @@ void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n \t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n \n \t\tif (skb_is_err_queue(skb) && skb->len &&\n-\t\t    (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS))\n+\t\t    SKB_EXT_ERR(skb)->opt_stats)\n \t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n \t\t\t\t skb->len, skb->data);\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-13391","CWE_ID":"125","category":"security","commit_id":"f6ffc702c6eecd963587273a429dcd608c648984","commit_message":"From f6ffc702c6eecd963587273a429dcd608c648984 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 16 Jun 2019 12:18:36 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1588\n\n---\n magick\/annotate.c |  3 +++\n magick\/fourier.c  | 12 ++++++++----\n 2 files changed, 11 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/magick\/annotate.c b\/magick\/annotate.c\nindex 757d4f8a1..63570f89c 100644\n--- a\/magick\/annotate.c\n+++ b\/magick\/annotate.c\n@@ -266,6 +266,7 @@ MagickExport MagickBooleanType AnnotateImage(Image *image,\n     {\n       annotate_info=DestroyDrawInfo(annotate_info);\n       annotate=DestroyDrawInfo(annotate);\n+      text=DestroyString(text);\n       return(MagickFalse);\n     }\n   p=text;\n@@ -300,6 +301,7 @@ MagickExport MagickBooleanType AnnotateImage(Image *image,\n       annotate_info=DestroyDrawInfo(annotate_info);\n       annotate=DestroyDrawInfo(annotate);\n       textlist=(char **) RelinquishMagickMemory(textlist);\n+      text=DestroyString(text);\n       return(MagickFalse);\n     }\n   if (IsGrayColorspace(image->colorspace) != MagickFalse)\n@@ -517,6 +519,7 @@ MagickExport MagickBooleanType AnnotateImage(Image *image,\n   annotate_info=DestroyDrawInfo(annotate_info);\n   annotate=DestroyDrawInfo(annotate);\n   textlist=(char **) RelinquishMagickMemory(textlist);\n+  text=DestroyString(text);\n   return(status);\n }\n \f\ndiff --git a\/magick\/fourier.c b\/magick\/fourier.c\nindex d833a067c..bff711d0f 100644\n--- a\/magick\/fourier.c\n+++ b\/magick\/fourier.c\n@@ -245,10 +245,14 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n \n     if (status == MagickFalse)\n       continue;\n-    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Ar_image->columns,1,exception);\n-    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Ai_image->columns,1,exception);\n-    Br=GetCacheViewVirtualPixels(Br_view,0,y,Br_image->columns,1,exception);\n-    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Bi_image->columns,1,exception);\n+    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,\n+      MagickMax(Ar_image->columns,Cr_image->columns),1,exception);\n+    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,\n+      MagickMax(Ai_image->columns,Ci_image->columns),1,exception);\n+    Br=GetCacheViewVirtualPixels(Br_view,0,y,\n+      MagickMax(Br_image->columns,Cr_image->columns),1,exception);\n+    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,\n+      MagickMax(Bi_image->columns,Ci_image->columns),1,exception);\n     Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n     Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n     if ((Ar == (const PixelPacket *) NULL) ||\n","owner":"ImageMagick","repo":"ImageMagick6","source":"cve"},{"CVE_ID":"CVE-2015-8897","CWE_ID":"125","category":"security","commit_id":"7b1cf5784b5bcd85aa9293ecf56769f68c037231","commit_message":"From 7b1cf5784b5bcd85aa9293ecf56769f68c037231 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Fri, 9 Oct 2015 10:07:51 +0200\nSubject: [PATCH] Fixed out of bounds error in SpliceImage.\n\n---\n MagickCore\/transform.c | 15 +++++++++------\n 1 file changed, 9 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/MagickCore\/transform.c b\/MagickCore\/transform.c\nindex 2e9040b30c..c3967242d0 100644\n--- a\/MagickCore\/transform.c\n+++ b\/MagickCore\/transform.c\n@@ -1722,6 +1722,7 @@ MagickExport Image *SpliceImage(const Image *image,\n     splice_geometry;\n \n   ssize_t\n+    columns,\n     y;\n \n   \/*\n@@ -1810,6 +1811,7 @@ MagickExport Image *SpliceImage(const Image *image,\n   *\/\n   status=MagickTrue;\n   progress=0;\n+  columns=MagickMin(splice_geometry.x,(ssize_t) splice_image->columns);\n   image_view=AcquireVirtualCacheView(image,exception);\n   splice_view=AcquireAuthenticCacheView(splice_image,exception);\n #if defined(MAGICKCORE_OPENMP_SUPPORT)\n@@ -1829,7 +1831,8 @@ MagickExport Image *SpliceImage(const Image *image,\n \n     if (status == MagickFalse)\n       continue;\n-    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n+    p=GetCacheViewVirtualPixels(image_view,0,y,splice_image->columns,1,\n+      exception);\n     q=QueueCacheViewAuthenticPixels(splice_view,0,y,splice_image->columns,1,\n       exception);\n     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n@@ -1837,7 +1840,7 @@ MagickExport Image *SpliceImage(const Image *image,\n         status=MagickFalse;\n         continue;\n       }\n-    for (x=0; x < splice_geometry.x; x++)\n+    for (x=0; x < columns; x++)\n     {\n       register ssize_t\n         i;\n@@ -1931,10 +1934,10 @@ MagickExport Image *SpliceImage(const Image *image,\n \n     if (status == MagickFalse)\n       continue;\n-    p=GetCacheViewVirtualPixels(image_view,0,y-(ssize_t) splice_geometry.height,\n-      image->columns,1,exception);\n-    if ((y < 0) || (y >= (ssize_t) splice_image->rows))\n+    if ((y < 0) || (y >= (ssize_t)splice_image->rows))\n       continue;\n+    p=GetCacheViewVirtualPixels(image_view,0,y-(ssize_t) splice_geometry.height,\n+      splice_image->columns,1,exception);\n     q=QueueCacheViewAuthenticPixels(splice_view,0,y,splice_image->columns,1,\n       exception);\n     if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n@@ -1942,7 +1945,7 @@ MagickExport Image *SpliceImage(const Image *image,\n         status=MagickFalse;\n         continue;\n       }\n-    for (x=0; x < splice_geometry.x; x++)\n+    for (x=0; x < columns; x++)\n     {\n       register ssize_t\n         i;\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-11384","CWE_ID":"125","category":"security","commit_id":"77c47cf873dd55b396da60baa2ca83bbd39e4add","commit_message":"From 77c47cf873dd55b396da60baa2ca83bbd39e4add Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Wed, 18 Apr 2018 13:26:49 +0200\nSubject: [PATCH] Fix #9903 - oobread in RAnal.sh\n\n---\n libr\/anal\/p\/anal_sh.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libr\/anal\/p\/anal_sh.c b\/libr\/anal\/p\/anal_sh.c\nindex d032621013..ee2b34133f 100644\n--- a\/libr\/anal\/p\/anal_sh.c\n+++ b\/libr\/anal\/p\/anal_sh.c\n@@ -763,8 +763,9 @@ static int (*first_nibble_decode[])(RAnal*,RAnalOp*,ut16) = {\n static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n \tut8 op_MSB,op_LSB;\n \tint ret;\n-\tif (!data)\n+\tif (!data || len < 2) {\n \t\treturn 0;\n+\t}\n \tmemset (op, '\\0', sizeof (RAnalOp));\n \top->addr = addr;\n \top->type = R_ANAL_OP_TYPE_UNK;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2017-13722","CWE_ID":"125","category":"security","commit_id":"672bb944311392e2415b39c0d63b1e1902905bcd","commit_message":"From 672bb944311392e2415b39c0d63b1e1902905bcd Mon Sep 17 00:00:00 2001\nFrom: Michal Srb <msrb@suse.com>\nDate: Thu, 20 Jul 2017 17:05:23 +0200\nSubject: pcfGetProperties: Check string boundaries (CVE-2017-13722)\n\nWithout the checks a malformed PCF file can cause the library to make\natom from random heap memory that was behind the `strings` buffer.\nThis may crash the process or leak information.\n\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n src\/bitmap\/pcfread.c | 13 +++++++++++--\n 1 file changed, 11 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/bitmap\/pcfread.c b\/src\/bitmap\/pcfread.c\nindex dab1c44..ae34c28 100644\n--- a\/src\/bitmap\/pcfread.c\n+++ b\/src\/bitmap\/pcfread.c\n@@ -45,6 +45,7 @@ from The Open Group.\n \n #include <stdarg.h>\n #include <stdint.h>\n+#include <string.h>\n \n void\n pcfError(const char* message, ...)\n@@ -311,11 +312,19 @@ pcfGetProperties(FontInfoPtr pFontInfo, FontFilePtr file,\n     if (IS_EOF(file)) goto Bail;\n     position += string_size;\n     for (i = 0; i < nprops; i++) {\n+\tif (props[i].name >= string_size) {\n+\t    pcfError(\"pcfGetProperties(): String starts out of bounds (%ld\/%d)\\n\", props[i].name, string_size);\n+\t    goto Bail;\n+\t}\n \tprops[i].name = MakeAtom(strings + props[i].name,\n-\t\t\t\t strlen(strings + props[i].name), TRUE);\n+\t\t\t\t strnlen(strings + props[i].name, string_size - props[i].name), TRUE);\n \tif (isStringProp[i]) {\n+\t    if (props[i].value >= string_size) {\n+\t\tpcfError(\"pcfGetProperties(): String starts out of bounds (%ld\/%d)\\n\", props[i].value, string_size);\n+\t\tgoto Bail;\n+\t    }\n \t    props[i].value = MakeAtom(strings + props[i].value,\n-\t\t\t\t      strlen(strings + props[i].value), TRUE);\n+\t\t\t\t      strnlen(strings + props[i].value, string_size - props[i].value), TRUE);\n \t}\n     }\n     free(strings);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-9573","CWE_ID":"125","category":"security","commit_id":"7b28bd2b723df6be09fe7791eba33147c1c47d0d","commit_message":"From 7b28bd2b723df6be09fe7791eba33147c1c47d0d Mon Sep 17 00:00:00 2001\nFrom: szukw000 <szukw000@arcor.de>\nDate: Mon, 28 Nov 2016 21:57:20 +0100\nSubject: [PATCH] Changes for issues #863 and #862\n\n---\n src\/bin\/jp2\/convert.c        | 59 ++++++++++++++++++++++++++++++++----\n src\/bin\/jp2\/convertbmp.c     | 29 +++++++++++++++++-\n src\/bin\/jp2\/opj_decompress.c |  2 +-\n src\/lib\/openjp2\/j2k.c        | 11 +++++--\n 4 files changed, 90 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/src\/bin\/jp2\/convert.c b\/src\/bin\/jp2\/convert.c\nindex deee4f6e0..6a3f65b76 100644\n--- a\/src\/bin\/jp2\/convert.c\n+++ b\/src\/bin\/jp2\/convert.c\n@@ -906,7 +906,8 @@ int imagetotga(opj_image_t * image, const char *outfile) {\n     for (i = 0; i < image->numcomps-1; i++)\t{\n         if ((image->comps[0].dx != image->comps[i+1].dx)\n                 ||(image->comps[0].dy != image->comps[i+1].dy)\n-                ||(image->comps[0].prec != image->comps[i+1].prec))\t{\n+                ||(image->comps[0].prec != image->comps[i+1].prec)\n+\t\t\t\t||(image->comps[0].sgnd != image->comps[i+1].sgnd))\t{\n             fclose(fdest);\n             fprintf(stderr, \"Unable to create a tga file with such J2K image charateristics.\");\n             return 1;\n@@ -1743,7 +1744,7 @@ int imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n     int *red, *green, *blue, *alpha;\n     int wr, hr, max;\n     int i;\n-    unsigned int compno, ncomp;\n+    unsigned int compno, ncomp, ui;\n     int adjustR, adjustG, adjustB, adjustA;\n     int fails, two, want_gray, has_alpha, triple;\n     int prec, v;\n@@ -1768,6 +1769,27 @@ int imagetopnm(opj_image_t * image, const char *outfile, int force_split)\n \n     if(want_gray) ncomp = 1;\n \n+    for (ui = 1; ui < ncomp; ++ui) {\n+        if (image->comps[0].dx != image->comps[ui].dx) {\n+            break;\n+        }\n+        if (image->comps[0].dy != image->comps[ui].dy) {\n+            break;\n+        }\n+        if (image->comps[0].prec != image->comps[ui].prec) {\n+            break;\n+        }\n+        if (image->comps[0].sgnd != image->comps[ui].sgnd) {\n+            break;\n+        }\n+    }\n+    if (ui != ncomp) {\n+        fprintf(stderr,\"imagetopnm: All components\\n    shall have \"\n+         \"the same subsampling, same bit depth, same sign.\\n\"\n+         \"    Aborting\\n\");\n+        return 1;\n+    }\n+\n     if ((force_split == 0) &&\n \t\t\t\t(ncomp == 2 \/* GRAYA *\/\n             || (ncomp > 2 \/* RGB, RGBA *\/\n@@ -2126,7 +2148,7 @@ static int imagetoraw_common(opj_image_t * image, const char *outfile, OPJ_BOOL\n {\n     FILE *rawFile = NULL;\n     size_t res;\n-    unsigned int compno;\n+    unsigned int compno, numcomps;\n     int w, h, fails;\n     int line, row, curr, mask;\n     int *ptr;\n@@ -2139,6 +2161,31 @@ static int imagetoraw_common(opj_image_t * image, const char *outfile, OPJ_BOOL\n         return 1;\n     }\n \n+    numcomps = image->numcomps;\n+\n+    if (numcomps > 4) {\n+        numcomps = 4;\n+    }\n+    for (compno = 1; compno < numcomps; ++compno) {\n+        if (image->comps[0].dx != image->comps[compno].dx) {\n+            break;\n+        }\n+        if (image->comps[0].dy != image->comps[compno].dy) {\n+            break;\n+        }\n+        if (image->comps[0].prec != image->comps[compno].prec) {\n+            break;\n+        }\n+        if (image->comps[0].sgnd != image->comps[compno].sgnd) {\n+            break;\n+        }\n+    }\n+    if (compno != numcomps) {\n+        fprintf(stderr,\"imagetoraw_common: All components shall have the same subsampling, same bit depth, same sign.\\n\");\n+        fprintf(stderr,\"\\tAborting\\n\");\n+        return 1;\n+    }\n+\n     rawFile = fopen(outfile, \"wb\");\n     if (!rawFile) {\n         fprintf(stderr, \"Failed to open %s for writing !!\\n\", outfile);\n@@ -2146,9 +2193,9 @@ static int imagetoraw_common(opj_image_t * image, const char *outfile, OPJ_BOOL\n     }\n \n     fails = 1;\n-    fprintf(stdout,\"Raw image characteristics: %d components\\n\", image->numcomps);\n+    fprintf(stdout,\"Raw image characteristics: %d components\\n\", numcomps);\n \n-    for(compno = 0; compno < image->numcomps; compno++)\n+    for(compno = 0; compno < numcomps; compno++)\n     {\n         fprintf(stdout,\"Component %u characteristics: %dx%dx%d %s\\n\", compno, image->comps[compno].w,\n                 image->comps[compno].h, image->comps[compno].prec, image->comps[compno].sgnd==1 ? \"signed\": \"unsigned\");\n@@ -2238,7 +2285,7 @@ static int imagetoraw_common(opj_image_t * image, const char *outfile, OPJ_BOOL\n         }\n         else if (image->comps[compno].prec <= 32)\n         {\n-            fprintf(stderr,\"More than 16 bits per component no handled yet\\n\");\n+            fprintf(stderr,\"More than 16 bits per component not handled yet\\n\");\n             goto fin;\n         }\n         else\ndiff --git a\/src\/bin\/jp2\/convertbmp.c b\/src\/bin\/jp2\/convertbmp.c\nindex ae83077ca..8017ba86d 100644\n--- a\/src\/bin\/jp2\/convertbmp.c\n+++ b\/src\/bin\/jp2\/convertbmp.c\n@@ -806,8 +806,35 @@ int imagetobmp(opj_image_t * image, const char *outfile) {\n     FILE *fdest = NULL;\n     int adjustR, adjustG, adjustB;\n \n+   {\n+    unsigned int ui, ncomp = image->numcomps;\n+\n+    if (ncomp > 4) { \/* RGBA in bmpmask32toimage *\/\n+        ncomp = 4;\n+    }\n+    for (ui = 1; ui < ncomp; ++ui) {\n+        if (image->comps[0].dx != image->comps[ui].dx) {\n+            break;\n+        }\n+        if (image->comps[0].dy != image->comps[ui].dy) {\n+            break;\n+        }\n+        if (image->comps[0].prec != image->comps[ui].prec) {\n+            break;\n+        }\n+        if (image->comps[0].sgnd != image->comps[ui].sgnd) {\n+            break;\n+        }\n+    }\n+    if (ui != ncomp) {\n+        fprintf(stderr,\"imagetobmp: All components shall have the same subsampling, same bit depth, same sign.\\n\");\n+        fprintf(stderr,\"\\tAborting\\n\");\n+        return 1;\n+    }\n+\n+   }\n     if (image->comps[0].prec < 8) {\n-        fprintf(stderr, \"Unsupported number of components: %d\\n\", image->comps[0].prec);\n+        fprintf(stderr, \"imagetobmp: Unsupported precision: %d\\n\", image->comps[0].prec);\n         return 1;\n     }\n     if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx\ndiff --git a\/src\/bin\/jp2\/opj_decompress.c b\/src\/bin\/jp2\/opj_decompress.c\nindex 83160c3d1..c30079b50 100644\n--- a\/src\/bin\/jp2\/opj_decompress.c\n+++ b\/src\/bin\/jp2\/opj_decompress.c\n@@ -1607,7 +1607,7 @@ int main(int argc, char **argv)\n \t\tif(dirptr->filename_buf) free(dirptr->filename_buf);\n \t\tfree(dirptr);\n \t}\n-\tif (numDecompressedImages) {\n+\tif (numDecompressedImages && !failed) {\n \t\tfprintf(stdout, \"decode time: %d ms\\n\", (int)( (tCumulative * 1000.0) \/ (OPJ_FLOAT64)numDecompressedImages));\n \t}\n \treturn failed ? EXIT_FAILURE : EXIT_SUCCESS;\ndiff --git a\/src\/lib\/openjp2\/j2k.c b\/src\/lib\/openjp2\/j2k.c\nindex 66802bb96..b6daa3200 100644\n--- a\/src\/lib\/openjp2\/j2k.c\n+++ b\/src\/lib\/openjp2\/j2k.c\n@@ -2158,7 +2158,7 @@ static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,\n                                   i, l_img_comp->dx, l_img_comp->dy);\n                     return OPJ_FALSE;\n                 }\n-                if( l_img_comp->prec > 38) { \/* TODO openjpeg won't handle more than ? *\/\n+                if( l_img_comp->prec < 1 || l_img_comp->prec > 38) { \/* TODO openjpeg won't handle more than ? *\/\n                     opj_event_msg(p_manager, EVT_ERROR,\n                                   \"Invalid values for comp = %d : prec=%u (should be between 1 and 38 according to the JPEG2000 norm)\\n\",\n                                   i, l_img_comp->prec);\n@@ -10029,7 +10029,11 @@ OPJ_BOOL opj_j2k_decode(opj_j2k_t * p_j2k,\n         \/* Move data and copy one information from codec to output image*\/\n         for (compno = 0; compno < p_image->numcomps; compno++) {\n                 p_image->comps[compno].resno_decoded = p_j2k->m_output_image->comps[compno].resno_decoded;\n-                p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n+\t\tp_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n+\n+\t\tif(p_image->comps[compno].data == NULL) return OPJ_FALSE;\n+\n+                p_j2k->m_output_image->comps[compno].data = NULL;\n #if 0\n                 char fn[256];\n                 sprintf( fn, \"\/tmp\/%d.raw\", compno );\n@@ -10037,7 +10041,6 @@ OPJ_BOOL opj_j2k_decode(opj_j2k_t * p_j2k,\n                 fwrite( p_image->comps[compno].data, sizeof(OPJ_INT32), p_image->comps[compno].w * p_image->comps[compno].h, debug );\n                 fclose( debug );\n #endif\n-                p_j2k->m_output_image->comps[compno].data = NULL;\n         }\n \n         return OPJ_TRUE;\n@@ -10131,6 +10134,8 @@ OPJ_BOOL opj_j2k_get_tile(      opj_j2k_t *p_j2k,\n \n                 p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;\n \n+\t\t\t\tif (p_image->comps[compno].data == NULL) return OPJ_FALSE;\n+\n                 p_j2k->m_output_image->comps[compno].data = NULL;\n         }\n \n","owner":"szukw000","repo":"openjpeg","source":"cve"},{"CVE_ID":"CVE-2017-7718","CWE_ID":"125","category":"security","commit_id":"215902d7b6fb50c6fc216fc74f770858278ed904","commit_message":"From 215902d7b6fb50c6fc216fc74f770858278ed904 Mon Sep 17 00:00:00 2001\nFrom: hangaohuai <hangaohuai@huawei.com>\nDate: Tue, 14 Mar 2017 14:39:19 +0800\nSubject: [PATCH] fix :cirrus_vga fix OOB read case qemu Segmentation fault\n\ncheck the validity of parameters in cirrus_bitblt_rop_fwd_transp_xxx\nand cirrus_bitblt_rop_fwd_xxx to avoid the OOB read which causes qemu Segmentation fault.\n\nAfter the fix, we will touch the assert in\ncirrus_invalidate_region:\nassert(off_cur_end >= off_cur);\n\nSigned-off-by: fangying <fangying1@huawei.com>\nSigned-off-by: hangaohuai <hangaohuai@huawei.com>\nMessage-id: 20170314063919.16200-1-hangaohuai@huawei.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/display\/cirrus_vga_rop.h | 10 ++++++++++\n 1 file changed, 10 insertions(+)\n\n","diff_code":"diff --git a\/hw\/display\/cirrus_vga_rop.h b\/hw\/display\/cirrus_vga_rop.h\nindex 0925a00..b7447f8 100644\n--- a\/hw\/display\/cirrus_vga_rop.h\n+++ b\/hw\/display\/cirrus_vga_rop.h\n@@ -97,6 +97,11 @@ glue(glue(cirrus_bitblt_rop_fwd_transp_, ROP_NAME),_8)(CirrusVGAState *s,\n     uint8_t p;\n     dstpitch -= bltwidth;\n     srcpitch -= bltwidth;\n+\n+    if (bltheight > 1 && (dstpitch < 0 || srcpitch < 0)) {\n+        return;\n+    }\n+\n     for (y = 0; y < bltheight; y++) {\n         for (x = 0; x < bltwidth; x++) {\n \t    p = *dst;\n@@ -143,6 +148,11 @@ glue(glue(cirrus_bitblt_rop_fwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,\n     uint8_t p1, p2;\n     dstpitch -= bltwidth;\n     srcpitch -= bltwidth;\n+\n+    if (bltheight > 1 && (dstpitch < 0 || srcpitch < 0)) {\n+        return;\n+    }\n+\n     for (y = 0; y < bltheight; y++) {\n         for (x = 0; x < bltwidth; x+=2) {\n \t    p1 = *dst;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-8789","CWE_ID":"125","category":"security","commit_id":"2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6","commit_message":"From 2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6 Mon Sep 17 00:00:00 2001\nFrom: Armin Novak <armin.novak@thincast.com>\nDate: Mon, 22 Oct 2018 16:00:03 +0200\nSubject: [PATCH] Fixed CVE-2018-8789\n\nThanks to Eyal Itkin from Check Point Software Technologies.\n---\n winpr\/libwinpr\/sspi\/NTLM\/ntlm_message.c | 24 +++++++++++++-----------\n 1 file changed, 13 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/winpr\/libwinpr\/sspi\/NTLM\/ntlm_message.c b\/winpr\/libwinpr\/sspi\/NTLM\/ntlm_message.c\nindex d785604976..ab42dc7377 100644\n--- a\/winpr\/libwinpr\/sspi\/NTLM\/ntlm_message.c\n+++ b\/winpr\/libwinpr\/sspi\/NTLM\/ntlm_message.c\n@@ -74,7 +74,7 @@ static const char* const NTLM_NEGOTIATE_STRINGS[] =\n \t\"NTLMSSP_NEGOTIATE_UNICODE\"\n };\n \n-void ntlm_print_negotiate_flags(UINT32 flags)\n+static void ntlm_print_negotiate_flags(UINT32 flags)\n {\n \tint i;\n \tconst char* str;\n@@ -90,7 +90,7 @@ void ntlm_print_negotiate_flags(UINT32 flags)\n \t}\n }\n \n-int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n+static int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n {\n \tif (Stream_GetRemainingLength(s) < 12)\n \t\treturn -1;\n@@ -104,19 +104,19 @@ int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n \treturn 1;\n }\n \n-void ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n+static void ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n {\n \tStream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));\n \tStream_Write_UINT32(s, header->MessageType);\n }\n \n-void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n+static void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n {\n \tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n \theader->MessageType = MessageType;\n }\n \n-int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n+static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n {\n \tif (Stream_GetRemainingLength(s) < 8)\n \t\treturn -1;\n@@ -127,7 +127,7 @@ int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n \treturn 1;\n }\n \n-void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n+static void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n {\n \tif (fields->MaxLen < 1)\n \t\tfields->MaxLen = fields->Len;\n@@ -137,11 +137,13 @@ void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n \tStream_Write_UINT32(s, fields->BufferOffset); \/* BufferOffset (4 bytes) *\/\n }\n \n-int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n+static int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n {\n \tif (fields->Len > 0)\n \t{\n-\t\tif ((fields->BufferOffset + fields->Len) > Stream_Length(s))\n+\t\tconst UINT64 offset = (UINT64)fields->BufferOffset + (UINT64)fields->Len;\n+\n+\t\tif (offset > Stream_Length(s))\n \t\t\treturn -1;\n \n \t\tfields->Buffer = (PBYTE) malloc(fields->Len);\n@@ -156,7 +158,7 @@ int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n \treturn 1;\n }\n \n-void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n+static void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n {\n \tif (fields->Len > 0)\n \t{\n@@ -165,7 +167,7 @@ void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n \t}\n }\n \n-void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n+static void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n {\n \tif (fields)\n \t{\n@@ -180,7 +182,7 @@ void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n \t}\n }\n \n-void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n+static void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n {\n \tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n \t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n","owner":"FreeRDP","repo":"FreeRDP","source":"cve"},{"CVE_ID":"CVE-2016-10749","CWE_ID":"125","category":"security","commit_id":"94df772485c92866ca417d92137747b2e3b0a917","commit_message":"From 94df772485c92866ca417d92137747b2e3b0a917 Mon Sep 17 00:00:00 2001\nFrom: Max Bruckner <max@maxbruckner.de>\nDate: Sun, 2 Oct 2016 18:56:53 +0700\nSubject: [PATCH] fix buffer overflow (#30)\n\n---\n cJSON.c | 17 ++++++++++++++---\n 1 file changed, 14 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/cJSON.c b\/cJSON.c\nindex cbd3a89f..93a1beca 100644\n--- a\/cJSON.c\n+++ b\/cJSON.c\n@@ -194,9 +194,20 @@ static const char *parse_string(cJSON *item,const char *str,const char **ep)\n {\n \tconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\n \tif (*str!='\\\"') {*ep=str;return 0;}\t\/* not a string! *\/\n-\t\n-\twhile (*end_ptr!='\\\"' && *end_ptr && ++len) if (*end_ptr++ == '\\\\') end_ptr++;\t\/* Skip escaped quotes. *\/\n-\t\n+\n+\twhile (*end_ptr!='\\\"' && *end_ptr && ++len)\n+\t{\n+\t    if (*end_ptr++ == '\\\\')\n+\t    {\n+\t\tif (*end_ptr == '\\0')\n+\t\t{\n+\t\t    \/* prevent buffer overflow when last input character is a backslash *\/\n+\t\t    return 0;\n+\t\t}\n+\t\tend_ptr++;\t\/* Skip escaped quotes. *\/\n+\t    }\n+\t}\n+\n \tout=(char*)cJSON_malloc(len+1);\t\/* This is how long we need for the string, roughly. *\/\n \tif (!out) return 0;\n \titem->valuestring=out; \/* assign here so out will be deleted during cJSON_Delete() later *\/\n","owner":"DaveGamble","repo":"cJSON","source":"cve"},{"CVE_ID":"CVE-2016-7514","CWE_ID":"125","category":"security","commit_id":"280215b9936d145dd5ee91403738ccce1333cab1","commit_message":"From 280215b9936d145dd5ee91403738ccce1333cab1 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Sat, 16 Jan 2016 00:07:51 +0100\nSubject: [PATCH] Rewrite reading pixel values.\n\n---\n coders\/psd.c | 167 +++++++++++++++++++++++++++------------------------\n 1 file changed, 87 insertions(+), 80 deletions(-)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex 976d9076fb..6b393c2a84 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -764,6 +764,72 @@ static inline void ReversePSDString(Image *image,char *p,size_t length)\n   }\n }\n \n+static inline void SetPSDPixel(Image *image,const size_t channels,\n+  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,\n+  ExceptionInfo *exception)\n+{\n+  if (image->storage_class == PseudoClass)\n+    {\n+      if (packet_size == 1)\n+        SetPixelIndex(image,ScaleQuantumToChar(pixel),q);\n+      else\n+        SetPixelIndex(image,ScaleQuantumToShort(pixel),q);\n+      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n+        ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);\n+      return;\n+    }\n+  switch (type)\n+  {\n+    case -1:\n+    {\n+      SetPixelAlpha(image, pixel,q);\n+      break;\n+    }\n+    case -2:\n+    case 0:\n+    {\n+      SetPixelRed(image,pixel,q);\n+      if (channels == 1 || type == -2)\n+        SetPixelGray(image,pixel,q);\n+      break;\n+    }\n+    case 1:\n+    {\n+      if (image->storage_class == PseudoClass)\n+        SetPixelAlpha(image,pixel,q);\n+      else\n+        SetPixelGreen(image,pixel,q);\n+      break;\n+    }\n+    case 2:\n+    {\n+      if (image->storage_class == PseudoClass)\n+        SetPixelAlpha(image,pixel,q);\n+      else\n+        SetPixelBlue(image,pixel,q);\n+      break;\n+    }\n+    case 3:\n+    {\n+      if (image->colorspace == CMYKColorspace)\n+        SetPixelBlack(image,pixel,q);\n+      else\n+        if (image->alpha_trait != UndefinedPixelTrait)\n+          SetPixelAlpha(image,pixel,q);\n+      break;\n+    }\n+    case 4:\n+    {\n+      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n+          (channels > 3))\n+        break;\n+      if (image->alpha_trait != UndefinedPixelTrait)\n+        SetPixelAlpha(image,pixel,q);\n+      break;\n+    }\n+  }\n+}\n+\n static MagickBooleanType ReadPSDChannelPixels(Image *image,\n   const size_t channels,const size_t row,const ssize_t type,\n   const unsigned char *pixels,ExceptionInfo *exception)\n@@ -800,90 +866,31 @@ static MagickBooleanType ReadPSDChannelPixels(Image *image,\n         p=PushShortPixel(MSBEndian,p,&nibble);\n         pixel=ScaleShortToQuantum(nibble);\n       }\n-    switch (type)\n-    {\n-      case -1:\n+    if (image->depth > 1)\n       {\n-        SetPixelAlpha(image,pixel,q);\n-        break;\n+        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n+        q+=GetPixelChannels(image);\n       }\n-      case -2:\n-      case 0:\n-      {\n-        SetPixelRed(image,pixel,q);\n-        if (channels == 1 || type == -2)\n-          SetPixelGray(image,pixel,q);\n-        if (image->storage_class == PseudoClass)\n-          {\n-            if (packet_size == 1)\n-              SetPixelIndex(image,ScaleQuantumToChar(pixel),q);\n-            else\n-              SetPixelIndex(image,ScaleQuantumToShort(pixel),q);\n-            SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n-              ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);\n-            if (image->depth == 1)\n-              {\n-                ssize_t\n-                  bit,\n-                  number_bits;\n-  \n-                number_bits=image->columns-x;\n-                if (number_bits > 8)\n-                  number_bits=8;\n-                for (bit=0; bit < number_bits; bit++)\n-                {\n-                  SetPixelIndex(image,(((unsigned char) pixel) &\n-                    (0x01 << (7-bit))) != 0 ? 0 : 255,q);\n-                  SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n-                    ConstrainColormapIndex(image,GetPixelIndex(image,q),\n-                      exception),q);\n-                  q+=GetPixelChannels(image);\n-                  x++;\n-                }\n-                x--;\n-                continue;\n-              }\n-          }\n-        break;\n-      }\n-      case 1:\n-      {\n-        if (image->storage_class == PseudoClass)\n-          SetPixelAlpha(image,pixel,q);\n-        else\n-          SetPixelGreen(image,pixel,q);\n-        break;\n-      }\n-      case 2:\n-      {\n-        if (image->storage_class == PseudoClass)\n-          SetPixelAlpha(image,pixel,q);\n-        else\n-          SetPixelBlue(image,pixel,q);\n-        break;\n-      }\n-      case 3:\n-      {\n-        if (image->colorspace == CMYKColorspace)\n-          SetPixelBlack(image,pixel,q);\n-        else\n-          if (image->alpha_trait != UndefinedPixelTrait)\n-            SetPixelAlpha(image,pixel,q);\n-        break;\n-      }\n-      case 4:\n+    else\n       {\n-        if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n-            (channels > 3))\n-          break;\n-        if (image->alpha_trait != UndefinedPixelTrait)\n-          SetPixelAlpha(image,pixel,q);\n-        break;\n+        ssize_t\n+          bit,\n+          number_bits;\n+      \n+        number_bits=image->columns-x;\n+        if (number_bits > 8)\n+          number_bits=8;\n+        for (bit = 0; bit < number_bits; bit++)\n+        {\n+          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n+            & (0x01 << (7-bit))) != 0 ? 0 : 255,q,exception);\n+          q+=GetPixelChannels(image);\n+          x++;\n+        }\n+        if (x != image->columns)\n+          x--;\n+        continue;\n       }\n-      default:\n-        break;\n-    }\n-    q+=GetPixelChannels(image);\n   }\n   return(SyncAuthenticPixels(image,exception));\n }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-6309","CWE_ID":"125","category":"security","commit_id":"8dccf79857ceeb7a6d3e42c1e762e7b865d5344d","commit_message":"From 8dccf79857ceeb7a6d3e42c1e762e7b865d5344d Mon Sep 17 00:00:00 2001\nFrom: Eric Sesterhenn <eric.sesterhenn@x41-dsec.de>\nDate: Sun, 19 Feb 2017 19:36:35 +0100\nSubject: [PATCH] Check types to avoid invalid reads\/writes.\n\n---\n src\/file.c |  4 ++++\n src\/tnef.c | 16 +++++++++-------\n 2 files changed, 13 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/src\/file.c b\/src\/file.c\nindex 4dacda4..4b3d81d 100644\n--- a\/src\/file.c\n+++ b\/src\/file.c\n@@ -173,11 +173,13 @@ file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n \t    switch (a->name)\n \t    {\n \t    case MAPI_ATTACH_LONG_FILENAME:\n+\t\tassert(a->type == szMAPI_STRING);\n \t\tif (file->name) XFREE(file->name);\n \t\tfile->name = strdup( (char*)a->values[0].data.buf );\n \t\tbreak;\n \n \t    case MAPI_ATTACH_DATA_OBJ:\n+\t\tassert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));\n \t\tfile->len = a->values[0].len;\n \t\tif (file->data) XFREE (file->data);\n \t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n@@ -185,12 +187,14 @@ file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n \t\tbreak;\n \n              case MAPI_ATTACH_MIME_TAG:\n+\t\tassert(a->type == szMAPI_STRING);\n \t\tif (file->mime_type) XFREE (file->mime_type);\n \t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n \t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n \t\tbreak;\n \n                 case MAPI_ATTACH_CONTENT_ID:\n+                    assert(a->type == szMAPI_STRING);\n                     if (file->content_id) XFREE(file->content_id);\n                     file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                     memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\ndiff --git a\/src\/tnef.c b\/src\/tnef.c\nindex 0f1d9e4..7f74e88 100644\n--- a\/src\/tnef.c\n+++ b\/src\/tnef.c\n@@ -165,10 +165,12 @@ get_html_data (MAPI_Attr *a)\n     int j;\n     for (j = 0; j < a->num_values; j++)\n     {\n-\tbody[j] = XMALLOC(VarLenData, 1);\n-\tbody[j]->len = a->values[j].len;\n-\tbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n-\tmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n+        if (a->type == szMAPI_BINARY) {\n+ \t    body[j] = XMALLOC(VarLenData, 1);\n+\t    body[j]->len = a->values[j].len;\n+\t    body[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n+\t    memmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n+        }\n     }\n     return body;\n }\n@@ -306,13 +308,13 @@ parse_file (FILE* input_file, char* directory,\n \t\t    for (i = 0; mapi_attrs[i]; i++)\n \t\t    {\n \t\t\tMAPI_Attr *a = mapi_attrs[i];\n-\t\t\t    \n-\t\t\tif (a->name == MAPI_BODY_HTML)\n+\t\t\n+\t\t\tif (a->type == szMAPI_BINARY && a->name == MAPI_BODY_HTML)\n \t\t\t{\n \t\t\t    body.html_bodies = get_html_data (a);\n                                 html_size = a->num_values;\n \t\t\t}\n-\t\t\telse if (a->name == MAPI_RTF_COMPRESSED)\n+\t\t\telse if (a->type == szMAPI_BINARY && a->name == MAPI_RTF_COMPRESSED)\n \t\t\t{\n \t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                 rtf_size = a->num_values;\n","owner":"verdammelt","repo":"tnef","source":"cve"},{"CVE_ID":"CVE-2016-4483","CWE_ID":"125","category":"security","commit_id":"c97750d11bb8b6f3303e7131fe526a61ac65bcfd","commit_message":"From c97750d11bb8b6f3303e7131fe526a61ac65bcfd Mon Sep 17 00:00:00 2001\nFrom: Daniel Veillard <veillard@redhat.com>\nDate: Mon, 23 May 2016 13:39:13 +0800\nSubject: [PATCH] Avoid an out of bound access when serializing malformed\n strings\n\nFor https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=766414\n\n* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value\n  is not UTF-8 be more careful when serializing it as we may do an\n  out of bound access as a result.\n---\n xmlsave.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/xmlsave.c b\/xmlsave.c\nindex 774404b8..4a8e3f39 100644\n--- a\/xmlsave.c\n+++ b\/xmlsave.c\n@@ -2097,8 +2097,8 @@ xmlBufAttrSerializeTxtContent(xmlBufPtr buf, xmlDocPtr doc,\n             xmlBufAdd(buf, BAD_CAST \"&amp;\", 5);\n             cur++;\n             base = cur;\n-        } else if ((*cur >= 0x80) && ((doc == NULL) ||\n-                                      (doc->encoding == NULL))) {\n+        } else if ((*cur >= 0x80) && (cur[1] != 0) &&\n+\t           ((doc == NULL) || (doc->encoding == NULL))) {\n             \/*\n              * We assume we have UTF-8 content.\n              *\/\n@@ -2121,14 +2121,14 @@ xmlBufAttrSerializeTxtContent(xmlBufPtr buf, xmlDocPtr doc,\n                 val <<= 6;\n                 val |= (cur[1]) & 0x3F;\n                 l = 2;\n-            } else if (*cur < 0xF0) {\n+            } else if ((*cur < 0xF0) && (cur [2] != 0)) {\n                 val = (cur[0]) & 0x0F;\n                 val <<= 6;\n                 val |= (cur[1]) & 0x3F;\n                 val <<= 6;\n                 val |= (cur[2]) & 0x3F;\n                 l = 3;\n-            } else if (*cur < 0xF8) {\n+            } else if ((*cur < 0xF8) && (cur [2] != 0) && (cur[3] != 0)) {\n                 val = (cur[0]) & 0x07;\n                 val <<= 6;\n                 val |= (cur[1]) & 0x3F;\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7155","CWE_ID":"125","category":"security","commit_id":"7f61f4690dd153be98900a2a508b88989e692753","commit_message":"From 7f61f4690dd153be98900a2a508b88989e692753 Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Wed, 31 Aug 2016 12:19:29 +0530\nSubject: [PATCH] vmw_pvscsi: check page count while initialising descriptor\n rings\n\nVmware Paravirtual SCSI emulation uses command descriptors to\nprocess SCSI commands. These descriptors come with their ring\nbuffers. A guest could set the page count for these rings to\nan arbitrary value, leading to infinite loop or OOB access.\nAdd check to avoid it.\n\nReported-by: Tom Victor <vv474172261@gmail.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-Id: <1472626169-12989-1-git-send-email-ppandit@redhat.com>\nCc: qemu-stable@nongnu.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n hw\/scsi\/vmw_pvscsi.c | 19 +++++++++----------\n 1 file changed, 9 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/hw\/scsi\/vmw_pvscsi.c b\/hw\/scsi\/vmw_pvscsi.c\nindex 5116f4a..4245c15 100644\n--- a\/hw\/scsi\/vmw_pvscsi.c\n+++ b\/hw\/scsi\/vmw_pvscsi.c\n@@ -152,7 +152,7 @@ pvscsi_log2(uint32_t input)\n     return log;\n }\n \n-static int\n+static void\n pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n {\n     int i;\n@@ -160,10 +160,6 @@ pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n     uint32_t req_ring_size, cmp_ring_size;\n     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n \n-    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)\n-        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {\n-        return -1;\n-    }\n     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n     txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n@@ -195,8 +191,6 @@ pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n \n     \/* Flush ring state page changes *\/\n     smp_wmb();\n-\n-    return 0;\n }\n \n static int\n@@ -746,7 +740,7 @@ pvscsi_dbg_dump_tx_rings_config(PVSCSICmdDescSetupRings *rc)\n \n     trace_pvscsi_tx_rings_num_pages(\"Confirm Ring\", rc->cmpRingNumPages);\n     for (i = 0; i < rc->cmpRingNumPages; i++) {\n-        trace_pvscsi_tx_rings_ppn(\"Confirm Ring\", rc->reqRingPPNs[i]);\n+        trace_pvscsi_tx_rings_ppn(\"Confirm Ring\", rc->cmpRingPPNs[i]);\n     }\n }\n \n@@ -779,11 +773,16 @@ pvscsi_on_cmd_setup_rings(PVSCSIState *s)\n \n     trace_pvscsi_on_cmd_arrived(\"PVSCSI_CMD_SETUP_RINGS\");\n \n-    pvscsi_dbg_dump_tx_rings_config(rc);\n-    if (pvscsi_ring_init_data(&s->rings, rc) < 0) {\n+    if (!rc->reqRingNumPages\n+        || rc->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES\n+        || !rc->cmpRingNumPages\n+        || rc->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES) {\n         return PVSCSI_COMMAND_PROCESSING_FAILED;\n     }\n \n+    pvscsi_dbg_dump_tx_rings_config(rc);\n+    pvscsi_ring_init_data(&s->rings, rc);\n+\n     s->rings_info_valid = TRUE;\n     return PVSCSI_COMMAND_PROCESSING_SUCCEEDED;\n }\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12640","CWE_ID":"125","category":"security","commit_id":"78d4c5db50fbab0b4beb69c46c6167f2c6513dec","commit_message":"From 78d4c5db50fbab0b4beb69c46c6167f2c6513dec Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 6 Jul 2017 19:20:38 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/542\n\n---\n coders\/png.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/coders\/png.c b\/coders\/png.c\nindex ad00b92f43..2ebb6e9d8f 100644\n--- a\/coders\/png.c\n+++ b\/coders\/png.c\n@@ -5871,6 +5871,8 @@ static Image *ReadOneMNGImage(MngInfo* mng_info, const ImageInfo *image_info,\n \n               for (i=(ssize_t) first_object; i <= (ssize_t) last_object; i++)\n               {\n+                if ((i < 0) || (i >= MNG_MAX_OBJECTS))\n+                  continue;\n                 if (mng_info->exists[i] && !mng_info->frozen[i] &&\n                     (p-chunk) < (ssize_t) (length-8))\n                   {\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2015-8817","CWE_ID":"125","category":"security","commit_id":"23820dbfc79d1c9dce090b4c555994f2bb6a69b3","commit_message":"From 23820dbfc79d1c9dce090b4c555994f2bb6a69b3 Mon Sep 17 00:00:00 2001\nFrom: Peter Crosthwaite <peter.crosthwaite@xilinx.com>\nDate: Mon, 16 Mar 2015 22:35:54 -0700\nSubject: [PATCH] exec: Respect as_translate_internal length clamp\n\naddress_space_translate_internal will clamp the *plen length argument\nbased on the size of the memory region being queried. The iommu walker\nlogic in addresss_space_translate was ignoring this by discarding the\npost fn call value of *plen. Fix by just always using *plen as the\nlength argument throughout the fn, removing the len local variable.\n\nThis fixes a bootloader bug when a single elf section spans multiple\nQEMU memory regions.\n\nSigned-off-by: Peter Crosthwaite <peter.crosthwaite@xilinx.com>\nMessage-Id: <1426570554-15940-1-git-send-email-peter.crosthwaite@xilinx.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n exec.c | 6 ++----\n 1 file changed, 2 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/exec.c b\/exec.c\nindex 065f5e8..4717928 100644\n--- a\/exec.c\n+++ b\/exec.c\n@@ -380,7 +380,6 @@ MemoryRegion *address_space_translate(AddressSpace *as, hwaddr addr,\n     IOMMUTLBEntry iotlb;\n     MemoryRegionSection *section;\n     MemoryRegion *mr;\n-    hwaddr len = *plen;\n \n     rcu_read_lock();\n     for (;;) {\n@@ -395,7 +394,7 @@ MemoryRegion *address_space_translate(AddressSpace *as, hwaddr addr,\n         iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n         addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                 | (addr & iotlb.addr_mask));\n-        len = MIN(len, (addr | iotlb.addr_mask) - addr + 1);\n+        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);\n         if (!(iotlb.perm & (1 << is_write))) {\n             mr = &io_mem_unassigned;\n             break;\n@@ -406,10 +405,9 @@ MemoryRegion *address_space_translate(AddressSpace *as, hwaddr addr,\n \n     if (xen_enabled() && memory_access_is_direct(mr, is_write)) {\n         hwaddr page = ((addr & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE) - addr;\n-        len = MIN(page, len);\n+        *plen = MIN(page, *plen);\n     }\n \n-    *plen = len;\n     *xlat = addr;\n     rcu_read_unlock();\n     return mr;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-11381","CWE_ID":"125","category":"security","commit_id":"3fcf41ed96ffa25b38029449520c8d0a198745f3","commit_message":"From 3fcf41ed96ffa25b38029449520c8d0a198745f3 Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Wed, 18 Apr 2018 13:36:45 +0200\nSubject: [PATCH] Fix #9902 - Fix oobread in RBin.string_scan_range\n\n---\n libr\/bin\/file.c | 9 +++++----\n 1 file changed, 5 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libr\/bin\/file.c b\/libr\/bin\/file.c\nindex 990338699a..8538600657 100644\n--- a\/libr\/bin\/file.c\n+++ b\/libr\/bin\/file.c\n@@ -76,11 +76,12 @@ static int string_scan_range(RList *list, RBinFile *bf, int min,\n \t\teprintf (\"Invalid range to find strings 0x%llx .. 0x%llx\\n\", from, to);\n \t\treturn -1;\n \t}\n-\tut8 *buf = calloc (to - from, 1);\n+\tint len = to - from;\n+\tut8 *buf = calloc (len, 1);\n \tif (!buf || !min) {\n \t\treturn -1;\n \t}\n-\tr_buf_read_at (bf->buf, from, buf, to - from);\n+\tr_buf_read_at (bf->buf, from, buf, len);\n \t\/\/ may oobread\n \twhile (needle < to) {\n \t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);\n@@ -90,8 +91,8 @@ static int string_scan_range(RList *list, RBinFile *bf, int min,\n \t\t}\n \t\tif (type == R_STRING_TYPE_DETECT) {\n \t\t\tchar *w = (char *)buf + needle + rc - from;\n-\t\t\tif ((to - needle) > 5) {\n-\t\t\t\tbool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];\n+\t\t\tif ((to - needle) > 5 + rc) {\n+\t\t\t\tbool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n \t\t\t\tif (is_wide32) {\n \t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32;\n \t\t\t\t} else {\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2017-6418","CWE_ID":"125","category":"security","commit_id":"586a5180287262070637c8943f2f7efd652e4a2c","commit_message":"From 586a5180287262070637c8943f2f7efd652e4a2c Mon Sep 17 00:00:00 2001\nFrom: Steven Morgan <stevmorg@cisco.com>\nDate: Thu, 2 Mar 2017 14:41:20 -0500\nSubject: [PATCH] bb11797 - fix invalid read in fuzzed mail file.\n\n---\n libclamav\/message.c | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libclamav\/message.c b\/libclamav\/message.c\nindex b5cf0ddc72..36bbf417d9 100644\n--- a\/libclamav\/message.c\n+++ b\/libclamav\/message.c\n@@ -445,8 +445,12 @@ messageAddArgument(message *m, const char *arg)\n \t\t\t * FIXME: Bounce message handling is corrupting the in\n \t\t\t * core copies of headers\n \t\t\t *\/\n-\t\t\tcli_dbgmsg(\"Possible data corruption fixed\\n\");\n-\t\t\tp[8] = '=';\n+                        if (strlen(p) > 8) {\n+                            cli_dbgmsg(\"Possible data corruption fixed\\n\");\n+                            p[8] = '=';\n+                        } else {\n+                            cli_dbgmsg(\"Possible data corruption not fixed\\n\");\n+                        }\n \t\t} else {\n \t\t\tif(*p)\n \t\t\t\tcli_dbgmsg(\"messageAddArgument, '%s' contains no '='\\n\", p);\n@@ -682,7 +686,7 @@ messageFindArgument(const message *m, const char *variable)\n \t\t\t\tcli_dbgmsg(\"messageFindArgument: no '=' sign found in MIME header '%s' (%s)\\n\", variable, messageGetArgument(m, i));\n \t\t\t\treturn NULL;\n \t\t\t}\n-\t\t\tif((*++ptr == '\"') && (strchr(&ptr[1], '\"') != NULL)) {\n+\t\t\tif((strlen(ptr) > 2) && (*++ptr == '\"') && (strchr(&ptr[1], '\"') != NULL)) {\n \t\t\t\t\/* Remove any quote characters *\/\n \t\t\t\tchar *ret = cli_strdup(++ptr);\n \t\t\t\tchar *p;\n","owner":"Cisco-Talos","repo":"clamav-devel","source":"cve"},{"CVE_ID":"CVE-2018-11592","CWE_ID":"125","category":"security","commit_id":"8a44b04b584b3d3ab1cb68fed410f7ecb165e50e","commit_message":"From 8a44b04b584b3d3ab1cb68fed410f7ecb165e50e Mon Sep 17 00:00:00 2001\nFrom: Gordon Williams <gw@pur3.co.uk>\nDate: Fri, 18 May 2018 10:02:14 +0100\nSubject: [PATCH] Add height check for\n Graphics.createArrayBuffer(...vertical_byte:true) (fix #1421)\n\n---\n ChangeLog                       |  1 +\n libs\/graphics\/jswrap_graphics.c | 10 ++++++++--\n libs\/graphics\/lcd_arraybuffer.c |  1 +\n 3 files changed, 10 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex dd990837e..fcadd4b6d 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -21,6 +21,7 @@\n             Make software I2C bitrate and waveform more accurate\n             Move default I2C bitrate to 100kbit\/sec\n             Linux: don't create a espruino.flash file if we're not writing to flash\n+            Add height check for Graphics.createArrayBuffer(...vertical_byte:true) (fix #1421)\n \n      1v97 : nRF52: fix NRF.on('connect',...) issue\n             STM32: Fix setDeviceClockCmd error for USB.setConsole()\ndiff --git a\/libs\/graphics\/jswrap_graphics.c b\/libs\/graphics\/jswrap_graphics.c\nindex 04505ce43..2704c4105 100644\n--- a\/libs\/graphics\/jswrap_graphics.c\n+++ b\/libs\/graphics\/jswrap_graphics.c\n@@ -129,8 +129,14 @@ JsVar *jswrap_graphics_createArrayBuffer(int width, int height, int bpp, JsVar *\n     if (jsvGetBoolAndUnLock(jsvObjectGetChild(options, \"vertical_byte\", 0))) {\n       if (gfx.data.bpp==1)\n         gfx.data.flags = (JsGraphicsFlags)(gfx.data.flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE);\n-      else\n-        jsWarn(\"vertical_byte only works for 1bpp ArrayBuffers\\n\");\n+      else {\n+        jsExceptionHere(JSET_ERROR, \"vertical_byte only works for 1bpp ArrayBuffers\\n\");\n+        return 0;\n+      }\n+      if (gfx.data.height&7) {\n+        jsExceptionHere(JSET_ERROR, \"height must be a multiple of 8 when using vertical_byte\\n\");\n+        return 0;\n+      }\n     }\n     JsVar *colorv = jsvObjectGetChild(options, \"color_order\", 0);\n     if (colorv) {\ndiff --git a\/libs\/graphics\/lcd_arraybuffer.c b\/libs\/graphics\/lcd_arraybuffer.c\nindex ec933b6ce..3a2995659 100644\n--- a\/libs\/graphics\/lcd_arraybuffer.c\n+++ b\/libs\/graphics\/lcd_arraybuffer.c\n@@ -161,6 +161,7 @@ void lcdSetPixels_ArrayBuffer_flat(JsGraphics *gfx, short x, short y, short pixe\n       unsigned int mask = (unsigned int)(1<<gfx->data.bpp)-1;\n       unsigned int existing = (unsigned int)*ptr;\n       unsigned int bitIdx = (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB) ? 8-(idx+gfx->data.bpp) : idx;\n+      assert(ptr>=gfx->backendData && ptr<((char*)gfx->backendData + graphicsGetMemoryRequired(gfx)));\n       *ptr = (char)((existing&~(mask<<bitIdx)) | ((col&mask)<<bitIdx));\n       if (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE) {\n         ptr++;\n","owner":"espruino","repo":"Espruino","source":"cve"},{"CVE_ID":"CVE-2018-1093","CWE_ID":"125","category":"security","commit_id":"7dac4a1726a9c64a517d595c40e95e2d0d135f6f","commit_message":"From 7dac4a1726a9c64a517d595c40e95e2d0d135f6f Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Mon, 26 Mar 2018 23:54:10 -0400\nSubject: ext4: add validity checks for bitmap block numbers\n\nAn privileged attacker can cause a crash by mounting a crafted ext4\nimage which triggers a out-of-bounds read in the function\next4_valid_block_bitmap() in fs\/ext4\/balloc.c.\n\nThis issue has been assigned CVE-2018-1093.\n\nBugLink: https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=199181\nBugLink: https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=1560782\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@vger.kernel.org\n---\n fs\/ext4\/balloc.c | 16 ++++++++++++++--\n fs\/ext4\/ialloc.c |  7 +++++++\n 2 files changed, 21 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/balloc.c b\/fs\/ext4\/balloc.c\nindex f82c4966f4ce..a33d8fb1bf2a 100644\n--- a\/fs\/ext4\/balloc.c\n+++ b\/fs\/ext4\/balloc.c\n@@ -338,20 +338,25 @@ static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb,\n \t\/* check whether block bitmap block number is set *\/\n \tblk = ext4_block_bitmap(sb, desc);\n \toffset = blk - group_first_block;\n-\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n+\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n+\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n \t\t\/* bad block bitmap *\/\n \t\treturn blk;\n \n \t\/* check whether the inode bitmap block number is set *\/\n \tblk = ext4_inode_bitmap(sb, desc);\n \toffset = blk - group_first_block;\n-\tif (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n+\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n+\t    !ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data))\n \t\t\/* bad block bitmap *\/\n \t\treturn blk;\n \n \t\/* check whether the inode table block number is set *\/\n \tblk = ext4_inode_table(sb, desc);\n \toffset = blk - group_first_block;\n+\tif (offset < 0 || EXT4_B2C(sbi, offset) >= sb->s_blocksize ||\n+\t    EXT4_B2C(sbi, offset + sbi->s_itb_per_group) >= sb->s_blocksize)\n+\t\treturn blk;\n \tnext_zero_bit = ext4_find_next_zero_bit(bh->b_data,\n \t\t\tEXT4_B2C(sbi, offset + sbi->s_itb_per_group),\n \t\t\tEXT4_B2C(sbi, offset));\n@@ -417,6 +422,7 @@ struct buffer_head *\n ext4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n {\n \tstruct ext4_group_desc *desc;\n+\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n \tstruct buffer_head *bh;\n \text4_fsblk_t bitmap_blk;\n \tint err;\n@@ -425,6 +431,12 @@ ext4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)\n \tif (!desc)\n \t\treturn ERR_PTR(-EFSCORRUPTED);\n \tbitmap_blk = ext4_block_bitmap(sb, desc);\n+\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n+\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n+\t\text4_error(sb, \"Invalid block bitmap block %llu in \"\n+\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n+\t\treturn ERR_PTR(-EFSCORRUPTED);\n+\t}\n \tbh = sb_getblk(sb, bitmap_blk);\n \tif (unlikely(!bh)) {\n \t\text4_error(sb, \"Cannot get buffer for block bitmap - \"\ndiff --git a\/fs\/ext4\/ialloc.c b\/fs\/ext4\/ialloc.c\nindex 3fa93665b4a3..df92e3ec9913 100644\n--- a\/fs\/ext4\/ialloc.c\n+++ b\/fs\/ext4\/ialloc.c\n@@ -122,6 +122,7 @@ static struct buffer_head *\n ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)\n {\n \tstruct ext4_group_desc *desc;\n+\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n \tstruct buffer_head *bh = NULL;\n \text4_fsblk_t bitmap_blk;\n \tint err;\n@@ -131,6 +132,12 @@ ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)\n \t\treturn ERR_PTR(-EFSCORRUPTED);\n \n \tbitmap_blk = ext4_inode_bitmap(sb, desc);\n+\tif ((bitmap_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n+\t    (bitmap_blk >= ext4_blocks_count(sbi->s_es))) {\n+\t\text4_error(sb, \"Invalid inode bitmap blk %llu in \"\n+\t\t\t   \"block_group %u\", bitmap_blk, block_group);\n+\t\treturn ERR_PTR(-EFSCORRUPTED);\n+\t}\n \tbh = sb_getblk(sb, bitmap_blk);\n \tif (unlikely(!bh)) {\n \t\text4_error(sb, \"Cannot read inode bitmap - \"\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7534","CWE_ID":"125","category":"security","commit_id":"430403b0029b37decf216d57f810899cab2317dd","commit_message":"From 430403b0029b37decf216d57f810899cab2317dd Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 7 Feb 2016 15:13:08 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/126\n\n---\n MagickCore\/quantum-import.c | 2 +-\n MagickCore\/quantum.c        | 4 +++-\n 2 files changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/MagickCore\/quantum-import.c b\/MagickCore\/quantum-import.c\nindex b04c82e724..a0085f3b73 100644\n--- a\/MagickCore\/quantum-import.c\n+++ b\/MagickCore\/quantum-import.c\n@@ -1421,7 +1421,7 @@ static void ImportCbYCrYQuantum(const Image *image,QuantumInfo *quantum_info,\n \n           n=0;\n           quantum=0;\n-          for (x=0; x < (ssize_t) number_pixels; x+=2)\n+          for (x=0; x < (ssize_t) number_pixels; x+=4)\n           {\n             for (i=0; i < 4; i++)\n             {\ndiff --git a\/MagickCore\/quantum.c b\/MagickCore\/quantum.c\nindex 9d8190a903..a594bb6fc2 100644\n--- a\/MagickCore\/quantum.c\n+++ b\/MagickCore\/quantum.c\n@@ -321,6 +321,9 @@ MagickExport size_t GetQuantumExtent(const Image *image,\n     case BGRAQuantum: packet_size=4; break;\n     case CMYKQuantum: packet_size=4; break;\n     case CMYKAQuantum: packet_size=5; break;\n+    case CbYCrAQuantum: packet_size=4; break;\n+    case CbYCrQuantum: packet_size=3; break;\n+    case CbYCrYQuantum: packet_size=4; break;\n     default: break;\n   }\n   extent=MagickMax(image->columns,image->rows);\n@@ -872,7 +875,6 @@ MagickExport void SetQuantumPack(QuantumInfo *quantum_info,\n   quantum_info->pack=pack;\n }\n \f\n-\f\n \/*\n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n %                                                                             %\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-5807","CWE_ID":"125","category":"security","commit_id":"fd6330292501983ac75fe4162275794b18445bd9","commit_message":"From fd6330292501983ac75fe4162275794b18445bd9 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Tue, 24 Apr 2018 15:17:31 +0300\nSubject: [PATCH] Secunia 81800#1: samsumg_load_raw\n\nSecunia 81800#2: find_green\n\nSecunia 81800#3: rollei_load_raw\n\nremove_trailing_spaces: isspace() does not works right with signed non-latin chars\n\nSecunia 81800#5\/6: nikon_coolscan_load_raw\n\nSecunia 81800#4: rollei_load_raw\n---\n dcraw\/dcraw.c             | 157 ++++++++++++++++++++++++++------------\n internal\/dcraw_common.cpp | 156 +++++++++++++++++++++++++------------\n internal\/defines.h        |   1 +\n 3 files changed, 216 insertions(+), 98 deletions(-)\n\n","diff_code":"diff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 1c6bf662..e2b9c7d4 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -251,6 +251,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n \/\/@end DEFINES\n@@ -1511,9 +1512,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1794,7 +1800,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1810,8 +1821,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3857,6 +3871,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3875,11 +3894,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -11081,37 +11106,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -15077,7 +15133,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -15100,14 +15157,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex cfb82a27..b430d3e5 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -1228,9 +1228,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1506,7 +1511,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1522,8 +1532,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3569,6 +3582,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3587,11 +3605,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -9890,37 +9914,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -13739,7 +13794,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -13762,14 +13818,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/defines.h b\/internal\/defines.h\nindex b84e1d28..06e171ec 100644\n--- a\/internal\/defines.h\n+++ b\/internal\/defines.h\n@@ -153,6 +153,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n #define BAYER(row,col) \\\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2017-9984","CWE_ID":"125","category":"security","commit_id":"20e2b791796bd68816fa115f12be5320de2b8021","commit_message":"From 20e2b791796bd68816fa115f12be5320de2b8021 Mon Sep 17 00:00:00 2001\nFrom: Takashi Iwai <tiwai@suse.de>\nDate: Thu, 6 Jul 2017 12:34:40 +0200\nSubject: ALSA: msnd: Optimize \/ harden DSP and MIDI loops\n\nThe ISA msnd drivers have loops fetching the ring-buffer head, tail\nand size values inside the loops.  Such codes are inefficient and\nfragile.\n\nThis patch optimizes it, and also adds the sanity check to avoid the\nendless loops.\n\nBugzilla: https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=196131\nBugzilla: https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=196133\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/isa\/msnd\/msnd_midi.c     | 30 +++++++++++++++---------------\n sound\/isa\/msnd\/msnd_pinnacle.c | 23 ++++++++++++-----------\n 2 files changed, 27 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/sound\/isa\/msnd\/msnd_midi.c b\/sound\/isa\/msnd\/msnd_midi.c\nindex 912b5a9ccbab..013d8d1170fe 100644\n--- a\/sound\/isa\/msnd\/msnd_midi.c\n+++ b\/sound\/isa\/msnd\/msnd_midi.c\n@@ -120,24 +120,24 @@ void snd_msndmidi_input_read(void *mpuv)\n \tunsigned long flags;\n \tstruct snd_msndmidi *mpu = mpuv;\n \tvoid *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;\n+\tu16 head, tail, size;\n \n \tspin_lock_irqsave(&mpu->input_lock, flags);\n-\twhile (readw(mpu->dev->MIDQ + JQS_wTail) !=\n-\t       readw(mpu->dev->MIDQ + JQS_wHead)) {\n-\t\tu16 wTmp, val;\n-\t\tval = readw(pwMIDQData + 2 * readw(mpu->dev->MIDQ + JQS_wHead));\n-\n-\t\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,\n-\t\t\t\t     &mpu->mode))\n-\t\t\t\tsnd_rawmidi_receive(mpu->substream_input,\n-\t\t\t\t\t\t    (unsigned char *)&val, 1);\n-\n-\t\twTmp = readw(mpu->dev->MIDQ + JQS_wHead) + 1;\n-\t\tif (wTmp > readw(mpu->dev->MIDQ + JQS_wSize))\n-\t\t\twritew(0,  mpu->dev->MIDQ + JQS_wHead);\n-\t\telse\n-\t\t\twritew(wTmp,  mpu->dev->MIDQ + JQS_wHead);\n+\thead = readw(mpu->dev->MIDQ + JQS_wHead);\n+\ttail = readw(mpu->dev->MIDQ + JQS_wTail);\n+\tsize = readw(mpu->dev->MIDQ + JQS_wSize);\n+\tif (head > size || tail > size)\n+\t\tgoto out;\n+\twhile (head != tail) {\n+\t\tunsigned char val = readw(pwMIDQData + 2 * head);\n+\n+\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &mpu->mode))\n+\t\t\tsnd_rawmidi_receive(mpu->substream_input, &val, 1);\n+\t\tif (++head > size)\n+\t\t\thead = 0;\n+\t\twritew(head, mpu->dev->MIDQ + JQS_wHead);\n \t}\n+ out:\n \tspin_unlock_irqrestore(&mpu->input_lock, flags);\n }\n EXPORT_SYMBOL(snd_msndmidi_input_read);\ndiff --git a\/sound\/isa\/msnd\/msnd_pinnacle.c b\/sound\/isa\/msnd\/msnd_pinnacle.c\nindex ad4897337df5..fc4fb1904aef 100644\n--- a\/sound\/isa\/msnd\/msnd_pinnacle.c\n+++ b\/sound\/isa\/msnd\/msnd_pinnacle.c\n@@ -170,23 +170,24 @@ static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n {\n \tstruct snd_msnd *chip = dev_id;\n \tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n+\tu16 head, tail, size;\n \n \t\/* Send ack to DSP *\/\n \t\/* inb(chip->io + HP_RXL); *\/\n \n \t\/* Evaluate queued DSP messages *\/\n-\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n-\t\tu16 wTmp;\n-\n-\t\tsnd_msnd_eval_dsp_msg(chip,\n-\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n-\n-\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n-\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n-\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n-\t\telse\n-\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n+\thead = readw(chip->DSPQ + JQS_wHead);\n+\ttail = readw(chip->DSPQ + JQS_wTail);\n+\tsize = readw(chip->DSPQ + JQS_wSize);\n+\tif (head > size || tail > size)\n+\t\tgoto out;\n+\twhile (head != tail) {\n+\t\tsnd_msnd_eval_dsp_msg(chip, readw(pwDSPQData + 2 * head));\n+\t\tif (++head > size)\n+\t\t\thead = 0;\n+\t\twritew(head, chip->DSPQ + JQS_wHead);\n \t}\n+ out:\n \t\/* Send ack to DSP *\/\n \tinb(chip->io + HP_RXL);\n \treturn IRQ_HANDLED;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7528","CWE_ID":"125","category":"security","commit_id":"ca0c886abd6d3ef335eb74150cd23b89ebd17135","commit_message":"From ca0c886abd6d3ef335eb74150cd23b89ebd17135 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 24 Jan 2016 17:42:22 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/99\n\n---\n coders\/viff.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/coders\/viff.c b\/coders\/viff.c\nindex ae17c0165a..b1c2153712 100644\n--- a\/coders\/viff.c\n+++ b\/coders\/viff.c\n@@ -506,8 +506,8 @@ static Image *ReadVIFFImage(const ImageInfo *image_info,\n       max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n     else\n       max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n-    pixels=(unsigned char *) AcquireQuantumMemory(max_packets,\n-      bytes_per_pixel*sizeof(*pixels));\n+    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n+      max_packets),bytes_per_pixel*sizeof(*pixels));\n     if (pixels == (unsigned char *) NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     (void) ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-9807","CWE_ID":"125","category":"security","commit_id":"153a8ae752c90d07190ef45803422a4f71ea8bff","commit_message":"From 153a8ae752c90d07190ef45803422a4f71ea8bff Mon Sep 17 00:00:00 2001\nFrom: Matthew Waters <matthew@centricular.com>\nDate: Wed, 23 Nov 2016 07:09:06 +1100\nSubject: flxdec: rewrite logic based on GstByteReader\/Writer\n\nSolves overreading\/writing the given arrays and will error out if the\nstreams asks to do that.\n\nAlso does more error checking that the stream is valid and won't\noverrun any allocated arrays.  Also mitigate integer overflow errors\ncalculating allocation sizes.\n\nhttps:\/\/bugzilla.gnome.org\/show_bug.cgi?id=774859\n---\n gst\/flx\/flx_color.c |   1 -\n gst\/flx\/flx_fmt.h   |  72 -------\n gst\/flx\/gstflxdec.c | 610 ++++++++++++++++++++++++++++++++++++----------------\n gst\/flx\/gstflxdec.h |   4 +-\n 4 files changed, 427 insertions(+), 260 deletions(-)\n\n","diff_code":"diff --git a\/gst\/flx\/flx_color.c b\/gst\/flx\/flx_color.c\nindex 047bfdf..3a58135 100644\n--- a\/gst\/flx\/flx_color.c\n+++ b\/gst\/flx\/flx_color.c\n@@ -101,7 +101,6 @@ flx_set_palette_vector (FlxColorSpaceConverter * flxpal, guint start, guint num,\n   } else {\n     memcpy (&flxpal->palvec[start * 3], newpal, grab * 3);\n   }\n-\n }\n \n void\ndiff --git a\/gst\/flx\/flx_fmt.h b\/gst\/flx\/flx_fmt.h\nindex 9ab31ba..abff200 100644\n--- a\/gst\/flx\/flx_fmt.h\n+++ b\/gst\/flx\/flx_fmt.h\n@@ -123,78 +123,6 @@ typedef struct _FlxFrameType\n } FlxFrameType;\n #define FlxFrameTypeSize 10\n \n-#if G_BYTE_ORDER == G_BIG_ENDIAN \n-#define LE_TO_BE_16(i16) ((guint16) (((i16) << 8) | ((i16) >> 8)))\n-#define LE_TO_BE_32(i32) \\\n-    (((guint32) (LE_TO_BE_16((guint16) (i32))) << 16) | (LE_TO_BE_16((i32) >> 16)))\n-\n-#define FLX_FRAME_TYPE_FIX_ENDIANNESS(frm_type_p) \\\n-    do { \\\n-     (frm_type_p)->chunks = LE_TO_BE_16((frm_type_p)->chunks); \\\n-     (frm_type_p)->delay = LE_TO_BE_16((frm_type_p)->delay); \\\n-    } while(0)\n-\n-#define FLX_HUFFMAN_TABLE_FIX_ENDIANNESS(hffmn_table_p) \\\n-    do { \\\n-     (hffmn_table_p)->codelength = \\\n-\tLE_TO_BE_16((hffmn_table_p)->codelength); \\\n-     (hffmn_table_p)->numcodes = LE_TO_BE_16((hffmn_table_p)->numcodes); \\\n-    } while(0)\n-\n-#define FLX_SEGMENT_TABLE_FIX_ENDIANNESS(sgmnt_table_p) \\\n-     ((sgmnt_table_p)->segments = LE_TO_BE_16((sgmnt_table_p)->segments))\n-\n-#define FLX_PREFIX_CHUNK_FIX_ENDIANNESS(prfx_chnk_p) \\\n-    do { \\\n-     (prfx_chnk_p)->chunks = LE_TO_BE_16((prfx_chnk_p)->chunks); \\\n-    } while(0)\n-\n-#define FLX_FRAME_CHUNK_FIX_ENDIANNESS(frm_chnk_p) \\\n-    do { \\\n-     (frm_chnk_p)->size = LE_TO_BE_32((frm_chnk_p)->size); \\\n-     (frm_chnk_p)->id = LE_TO_BE_16((frm_chnk_p)->id); \\\n-    } while(0)\n-\n-#define FLX_HDR_FIX_ENDIANNESS(hdr_p) \\\n-    do { \\\n-     (hdr_p)->size = LE_TO_BE_32((hdr_p)->size); \\\n-     (hdr_p)->type = LE_TO_BE_16((hdr_p)->type); \\\n-     (hdr_p)->frames = LE_TO_BE_16((hdr_p)->frames); \\\n-     (hdr_p)->width = LE_TO_BE_16((hdr_p)->width); \\\n-     (hdr_p)->height = LE_TO_BE_16((hdr_p)->height); \\\n-     (hdr_p)->depth = LE_TO_BE_16((hdr_p)->depth); \\\n-     (hdr_p)->flags = LE_TO_BE_16((hdr_p)->flags); \\\n-     (hdr_p)->speed = LE_TO_BE_32((hdr_p)->speed); \\\n-     (hdr_p)->reserved1 = LE_TO_BE_16((hdr_p)->reserved1); \\\n-     (hdr_p)->created = LE_TO_BE_32((hdr_p)->created); \\\n-     (hdr_p)->creator = LE_TO_BE_32((hdr_p)->creator); \\\n-     (hdr_p)->updated = LE_TO_BE_32((hdr_p)->updated); \\\n-     (hdr_p)->updater = LE_TO_BE_32((hdr_p)->updater); \\\n-     (hdr_p)->aspect_dx = LE_TO_BE_16((hdr_p)->aspect_dx); \\\n-     (hdr_p)->aspect_dy = LE_TO_BE_16((hdr_p)->aspect_dy); \\\n-     (hdr_p)->ext_flags = LE_TO_BE_16((hdr_p)->ext_flags); \\\n-     (hdr_p)->keyframes = LE_TO_BE_16((hdr_p)->keyframes); \\\n-     (hdr_p)->totalframes = LE_TO_BE_16((hdr_p)->totalframes); \\\n-     (hdr_p)->req_memory = LE_TO_BE_32((hdr_p)->req_memory); \\\n-     (hdr_p)->max_regions = LE_TO_BE_16((hdr_p)->max_regions); \\\n-     (hdr_p)->transp_num = LE_TO_BE_16((hdr_p)->transp_num); \\\n-     (hdr_p)->oframe1 = LE_TO_BE_32((hdr_p)->oframe1); \\\n-     (hdr_p)->oframe2 = LE_TO_BE_32((hdr_p)->oframe2); \\\n-    } while(0)\n-#else\n-\n-#define LE_TO_BE_16(i16) ((i16))\n-#define LE_TO_BE_32(i32) ((i32))\n-\n-#define FLX_FRAME_TYPE_FIX_ENDIANNESS(frm_type_p)\n-#define FLX_HUFFMAN_TABLE_FIX_ENDIANNESS(hffmn_table_p)\n-#define FLX_SEGMENT_TABLE_FIX_ENDIANNESS(sgmnt_table_p)\n-#define FLX_PREFIX_CHUNK_FIX_ENDIANNESS(prfx_chnk_p)\n-#define FLX_FRAME_CHUNK_FIX_ENDIANNESS(frm_chnk_p)\n-#define FLX_HDR_FIX_ENDIANNESS(hdr_p)\n-\n-#endif \/* G_BYTE_ORDER == G_BIG_ENDIAN *\/\n-\n G_END_DECLS\n \n #endif \/* __GST_FLX_FMT_H__ *\/\ndiff --git a\/gst\/flx\/gstflxdec.c b\/gst\/flx\/gstflxdec.c\nindex a237976..aa1bed5 100644\n--- a\/gst\/flx\/gstflxdec.c\n+++ b\/gst\/flx\/gstflxdec.c\n@@ -1,5 +1,6 @@\n \/* GStreamer\n  * Copyright (C) <1999> Erik Walthinsen <omega@temple-baptist.com>\n+ * Copyright (C) <2016> Matthew Waters <matthew@centricular.com>\n  *\n  * This library is free software; you can redistribute it and\/or\n  * modify it under the terms of the GNU Library General Public\n@@ -24,6 +25,7 @@\n \/*\n  * http:\/\/www.coolutils.com\/Formats\/FLI\n  * http:\/\/woodshole.er.usgs.gov\/operations\/modeling\/flc.html\n+ * http:\/\/www.compuphase.com\/flic.htm\n  *\/\n \n #ifdef HAVE_CONFIG_H\n@@ -73,10 +75,14 @@ static GstStateChangeReturn gst_flxdec_change_state (GstElement * element,\n static gboolean gst_flxdec_src_query_handler (GstPad * pad, GstObject * parent,\n     GstQuery * query);\n \n-static void flx_decode_color (GstFlxDec *, guchar *, guchar *, gint);\n-static gboolean flx_decode_brun (GstFlxDec *, guchar *, guchar *);\n-static gboolean flx_decode_delta_fli (GstFlxDec *, guchar *, guchar *);\n-static gboolean flx_decode_delta_flc (GstFlxDec *, guchar *, guchar *);\n+static gboolean flx_decode_color (GstFlxDec * flxdec, GstByteReader * reader,\n+    GstByteWriter * writer, gint scale);\n+static gboolean flx_decode_brun (GstFlxDec * flxdec,\n+    GstByteReader * reader, GstByteWriter * writer);\n+static gboolean flx_decode_delta_fli (GstFlxDec * flxdec,\n+    GstByteReader * reader, GstByteWriter * writer);\n+static gboolean flx_decode_delta_flc (GstFlxDec * flxdec,\n+    GstByteReader * reader, GstByteWriter * writer);\n \n #define rndalign(off) ((off) + ((off) & 1))\n \n@@ -204,57 +210,59 @@ gst_flxdec_sink_event_handler (GstPad * pad, GstObject * parent,\n }\n \n static gboolean\n-flx_decode_chunks (GstFlxDec * flxdec, gulong count, guchar * data,\n-    guchar * dest)\n+flx_decode_chunks (GstFlxDec * flxdec, gulong n_chunks, GstByteReader * reader,\n+    GstByteWriter * writer)\n {\n-  FlxFrameChunk *hdr;\n   gboolean ret = TRUE;\n \n-  g_return_val_if_fail (data != NULL, FALSE);\n-\n-  while (count--) {\n-    hdr = (FlxFrameChunk *) data;\n-    FLX_FRAME_CHUNK_FIX_ENDIANNESS (hdr);\n-    data += FlxFrameChunkSize;\n+  while (n_chunks--) {\n+    GstByteReader chunk;\n+    guint32 size;\n+    guint16 type;\n+\n+    if (!gst_byte_reader_get_uint32_le (reader, &size))\n+      goto parse_error;\n+    if (!gst_byte_reader_get_uint16_le (reader, &type))\n+      goto parse_error;\n+    GST_LOG_OBJECT (flxdec, \"chunk has type 0x%02x size %d\", type, size);\n+\n+    if (!gst_byte_reader_get_sub_reader (reader, &chunk,\n+            size - FlxFrameChunkSize)) {\n+      GST_ERROR_OBJECT (flxdec, \"Incorrect size in the chunk header\");\n+      goto error;\n+    }\n \n-    switch (hdr->id) {\n+    switch (type) {\n       case FLX_COLOR64:\n-        flx_decode_color (flxdec, data, dest, 2);\n-        data += rndalign (hdr->size) - FlxFrameChunkSize;\n+        ret = flx_decode_color (flxdec, &chunk, writer, 2);\n         break;\n \n       case FLX_COLOR256:\n-        flx_decode_color (flxdec, data, dest, 0);\n-        data += rndalign (hdr->size) - FlxFrameChunkSize;\n+        ret = flx_decode_color (flxdec, &chunk, writer, 0);\n         break;\n \n       case FLX_BRUN:\n-        ret = flx_decode_brun (flxdec, data, dest);\n-        data += rndalign (hdr->size) - FlxFrameChunkSize;\n+        ret = flx_decode_brun (flxdec, &chunk, writer);\n         break;\n \n       case FLX_LC:\n-        ret = flx_decode_delta_fli (flxdec, data, dest);\n-        data += rndalign (hdr->size) - FlxFrameChunkSize;\n+        ret = flx_decode_delta_fli (flxdec, &chunk, writer);\n         break;\n \n       case FLX_SS2:\n-        ret = flx_decode_delta_flc (flxdec, data, dest);\n-        data += rndalign (hdr->size) - FlxFrameChunkSize;\n+        ret = flx_decode_delta_flc (flxdec, &chunk, writer);\n         break;\n \n       case FLX_BLACK:\n-        memset (dest, 0, flxdec->size);\n+        ret = gst_byte_writer_fill (writer, 0, flxdec->size);\n         break;\n \n       case FLX_MINI:\n-        data += rndalign (hdr->size) - FlxFrameChunkSize;\n         break;\n \n       default:\n-        GST_WARNING (\"Unimplented chunk type: 0x%02x size: %d - skipping\",\n-            hdr->id, hdr->size);\n-        data += rndalign (hdr->size) - FlxFrameChunkSize;\n+        GST_WARNING (\"Unimplemented chunk type: 0x%02x size: %d - skipping\",\n+            type, size);\n         break;\n     }\n \n@@ -263,43 +271,60 @@ flx_decode_chunks (GstFlxDec * flxdec, gulong count, guchar * data,\n   }\n \n   return ret;\n+\n+parse_error:\n+  GST_ERROR_OBJECT (flxdec, \"Failed to decode chunk\");\n+error:\n+  return FALSE;\n }\n \n \n-static void\n-flx_decode_color (GstFlxDec * flxdec, guchar * data, guchar * dest, gint scale)\n+static gboolean\n+flx_decode_color (GstFlxDec * flxdec, GstByteReader * reader,\n+    GstByteWriter * writer, gint scale)\n {\n-  guint packs, count, indx;\n+  guint8 count, indx;\n+  guint16 packs;\n \n-  g_return_if_fail (flxdec != NULL);\n-\n-  packs = (data[0] + (data[1] << 8));\n-\n-  data += 2;\n+  if (!gst_byte_reader_get_uint16_le (reader, &packs))\n+    goto error;\n   indx = 0;\n \n-  GST_LOG (\"GstFlxDec: cmap packs: %d\", packs);\n+  GST_LOG (\"GstFlxDec: cmap packs: %d\", (guint) packs);\n   while (packs--) {\n+    const guint8 *data;\n+    guint16 actual_count;\n+\n     \/* color map index + skip count *\/\n-    indx += *data++;\n+    if (!gst_byte_reader_get_uint8 (reader, &indx))\n+      goto error;\n \n     \/* number of rgb triplets *\/\n-    count = *data++ & 0xff;\n-    if (count == 0)\n-      count = 256;\n+    if (!gst_byte_reader_get_uint8 (reader, &count))\n+      goto error;\n \n-    GST_LOG (\"GstFlxDec: cmap count: %d (indx: %d)\", count, indx);\n-    flx_set_palette_vector (flxdec->converter, indx, count, data, scale);\n+    actual_count = count == 0 ? 256 : count;\n \n-    data += (count * 3);\n+    if (!gst_byte_reader_get_data (reader, count * 3, &data))\n+      goto error;\n+\n+    GST_LOG_OBJECT (flxdec, \"cmap count: %d (indx: %d)\", actual_count, indx);\n+    flx_set_palette_vector (flxdec->converter, indx, actual_count,\n+        (guchar *) data, scale);\n   }\n+\n+  return TRUE;\n+\n+error:\n+  GST_ERROR_OBJECT (flxdec, \"Error decoding color palette\");\n+  return FALSE;\n }\n \n static gboolean\n-flx_decode_brun (GstFlxDec * flxdec, guchar * data, guchar * dest)\n+flx_decode_brun (GstFlxDec * flxdec, GstByteReader * reader,\n+    GstByteWriter * writer)\n {\n-  gulong count, lines, row;\n-  guchar x;\n+  gulong lines, row;\n \n   g_return_val_if_fail (flxdec != NULL, FALSE);\n \n@@ -310,82 +335,125 @@ flx_decode_brun (GstFlxDec * flxdec, guchar * data, guchar * dest)\n      * contain more then 255 RLE packets. we use the frame \n      * width instead. \n      *\/\n-    data++;\n+    if (!gst_byte_reader_skip (reader, 1))\n+      goto error;\n \n     row = flxdec->hdr.width;\n     while (row) {\n-      count = *data++;\n+      gint8 count;\n+\n+      if (!gst_byte_reader_get_int8 (reader, &count))\n+        goto error;\n+\n+      if (count <= 0) {\n+        const guint8 *data;\n \n-      if (count > 0x7f) {\n         \/* literal run *\/\n-        count = 0x100 - count;\n-        if ((glong) row - (glong) count < 0) {\n-          GST_ERROR_OBJECT (flxdec, \"Invalid BRUN packet detected.\");\n+        count = ABS (count);\n+\n+        GST_LOG_OBJECT (flxdec, \"have literal run of size %d\", count);\n+\n+        if (count > row) {\n+          GST_ERROR_OBJECT (flxdec, \"Invalid BRUN line detected. \"\n+              \"bytes to write exceeds the end of the row\");\n           return FALSE;\n         }\n         row -= count;\n \n-        while (count--)\n-          *dest++ = *data++;\n-\n+        if (!gst_byte_reader_get_data (reader, count, &data))\n+          goto error;\n+        if (!gst_byte_writer_put_data (writer, data, count))\n+          goto error;\n       } else {\n-        if ((glong) row - (glong) count < 0) {\n-          GST_ERROR_OBJECT (flxdec, \"Invalid BRUN packet detected.\");\n+        guint8 x;\n+\n+        GST_LOG_OBJECT (flxdec, \"have replicate run of size %d\", count);\n+\n+        if (count > row) {\n+          GST_ERROR_OBJECT (flxdec, \"Invalid BRUN packet detected.\"\n+              \"bytes to write exceeds the end of the row\");\n           return FALSE;\n         }\n \n         \/* replicate run *\/\n         row -= count;\n-        x = *data++;\n \n-        while (count--)\n-          *dest++ = x;\n+        if (!gst_byte_reader_get_uint8 (reader, &x))\n+          goto error;\n+        if (!gst_byte_writer_fill (writer, x, count))\n+          goto error;\n       }\n     }\n   }\n \n   return TRUE;\n+\n+error:\n+  GST_ERROR_OBJECT (flxdec, \"Failed to decode BRUN packet\");\n+  return FALSE;\n }\n \n static gboolean\n-flx_decode_delta_fli (GstFlxDec * flxdec, guchar * data, guchar * dest)\n+flx_decode_delta_fli (GstFlxDec * flxdec, GstByteReader * reader,\n+    GstByteWriter * writer)\n {\n-  gulong count, packets, lines, start_line;\n-  guchar *start_p, x;\n+  guint16 start_line, lines;\n+  guint line_start_i;\n \n   g_return_val_if_fail (flxdec != NULL, FALSE);\n   g_return_val_if_fail (flxdec->delta_data != NULL, FALSE);\n \n   \/* use last frame for delta *\/\n-  memcpy (dest, flxdec->delta_data, flxdec->size);\n+  if (!gst_byte_writer_put_data (writer, flxdec->delta_data, flxdec->size))\n+    goto error;\n+\n+  if (!gst_byte_reader_get_uint16_le (reader, &start_line))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &lines))\n+    goto error;\n+  GST_LOG_OBJECT (flxdec, \"height %d start line %d line count %d\",\n+      flxdec->hdr.height, start_line, lines);\n \n-  start_line = (data[0] + (data[1] << 8));\n-  lines = (data[2] + (data[3] << 8));\n   if (start_line + lines > flxdec->hdr.height) {\n     GST_ERROR_OBJECT (flxdec, \"Invalid FLI packet detected. too many lines.\");\n     return FALSE;\n   }\n-  data += 4;\n \n-  \/* start position of delta *\/\n-  dest += (flxdec->hdr.width * start_line);\n-  start_p = dest;\n+  line_start_i = flxdec->hdr.width * start_line;\n+  if (!gst_byte_writer_set_pos (writer, line_start_i))\n+    goto error;\n \n   while (lines--) {\n+    guint8 packets;\n+\n     \/* packet count *\/\n-    packets = *data++;\n+    if (!gst_byte_reader_get_uint8 (reader, &packets))\n+      goto error;\n+    GST_LOG_OBJECT (flxdec, \"have %d packets\", packets);\n \n     while (packets--) {\n       \/* skip count *\/\n-      guchar skip = *data++;\n-      dest += skip;\n+      guint8 skip;\n+      gint8 count;\n+      if (!gst_byte_reader_get_uint8 (reader, &skip))\n+        goto error;\n+\n+      \/* skip bytes *\/\n+      if (!gst_byte_writer_set_pos (writer,\n+              gst_byte_writer_get_pos (writer) + skip))\n+        goto error;\n \n       \/* RLE count *\/\n-      count = *data++;\n+      if (!gst_byte_reader_get_int8 (reader, &count))\n+        goto error;\n+\n+      if (count < 0) {\n+        guint8 x;\n \n-      if (count > 0x7f) {\n         \/* literal run *\/\n-        count = 0x100 - count;\n+        count = ABS (count);\n+        GST_LOG_OBJECT (flxdec, \"have literal run of size %d at offset %d\",\n+            count, skip);\n \n         if (skip + count > flxdec->hdr.width) {\n           GST_ERROR_OBJECT (flxdec, \"Invalid FLI packet detected. \"\n@@ -393,11 +461,16 @@ flx_decode_delta_fli (GstFlxDec * flxdec, guchar * data, guchar * dest)\n           return FALSE;\n         }\n \n-        x = *data++;\n-        while (count--)\n-          *dest++ = x;\n-\n+        if (!gst_byte_reader_get_uint8 (reader, &x))\n+          goto error;\n+        if (!gst_byte_writer_fill (writer, x, count))\n+          goto error;\n       } else {\n+        const guint8 *data;\n+\n+        GST_LOG_OBJECT (flxdec, \"have replicate run of size %d at offset %d\",\n+            count, skip);\n+\n         if (skip + count > flxdec->hdr.width) {\n           GST_ERROR_OBJECT (flxdec, \"Invalid FLI packet detected. \"\n               \"line too long.\");\n@@ -405,45 +478,60 @@ flx_decode_delta_fli (GstFlxDec * flxdec, guchar * data, guchar * dest)\n         }\n \n         \/* replicate run *\/\n-        while (count--)\n-          *dest++ = *data++;\n+        if (!gst_byte_reader_get_data (reader, count, &data))\n+          goto error;\n+        if (!gst_byte_writer_put_data (writer, data, count))\n+          goto error;\n       }\n     }\n-    start_p += flxdec->hdr.width;\n-    dest = start_p;\n+    line_start_i += flxdec->hdr.width;\n+    if (!gst_byte_writer_set_pos (writer, line_start_i))\n+      goto error;\n   }\n \n   return TRUE;\n+\n+error:\n+  GST_ERROR_OBJECT (flxdec, \"Failed to decode FLI packet\");\n+  return FALSE;\n }\n \n static gboolean\n-flx_decode_delta_flc (GstFlxDec * flxdec, guchar * data, guchar * dest)\n+flx_decode_delta_flc (GstFlxDec * flxdec, GstByteReader * reader,\n+    GstByteWriter * writer)\n {\n-  gulong count, lines, start_l, opcode;\n-  guchar *start_p;\n+  guint16 lines, start_l;\n \n   g_return_val_if_fail (flxdec != NULL, FALSE);\n   g_return_val_if_fail (flxdec->delta_data != NULL, FALSE);\n \n   \/* use last frame for delta *\/\n-  memcpy (dest, flxdec->delta_data, flxdec->size);\n+  if (!gst_byte_writer_put_data (writer, flxdec->delta_data, flxdec->size))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &lines))\n+    goto error;\n \n-  lines = (data[0] + (data[1] << 8));\n   if (lines > flxdec->hdr.height) {\n     GST_ERROR_OBJECT (flxdec, \"Invalid FLC packet detected. too many lines.\");\n     return FALSE;\n   }\n-  data += 2;\n \n-  start_p = dest;\n   start_l = lines;\n \n   while (lines) {\n-    dest = start_p + (flxdec->hdr.width * (start_l - lines));\n+    guint16 opcode;\n+\n+    if (!gst_byte_writer_set_pos (writer,\n+            flxdec->hdr.width * (start_l - lines)))\n+      goto error;\n \n     \/* process opcode(s) *\/\n-    while ((opcode = (data[0] + (data[1] << 8))) & 0xc000) {\n-      data += 2;\n+    while (TRUE) {\n+      if (!gst_byte_reader_get_uint16_le (reader, &opcode))\n+        goto error;\n+      if ((opcode & 0xc000) == 0)\n+        break;\n+\n       if ((opcode & 0xc000) == 0xc000) {\n         \/* line skip count *\/\n         gulong skip = (0x10000 - opcode);\n@@ -453,27 +541,44 @@ flx_decode_delta_flc (GstFlxDec * flxdec, guchar * data, guchar * dest)\n           return FALSE;\n         }\n         start_l += skip;\n-        dest += flxdec->hdr.width * skip;\n+        if (!gst_byte_writer_set_pos (writer,\n+                gst_byte_writer_get_pos (writer) + flxdec->hdr.width * skip))\n+          goto error;\n       } else {\n         \/* last pixel *\/\n-        dest += flxdec->hdr.width;\n-        *dest++ = (opcode & 0xff);\n+        if (!gst_byte_writer_set_pos (writer,\n+                gst_byte_writer_get_pos (writer) + flxdec->hdr.width))\n+          goto error;\n+        if (!gst_byte_writer_put_uint8 (writer, opcode & 0xff))\n+          goto error;\n       }\n     }\n-    data += 2;\n \n     \/* last opcode is the packet count *\/\n+    GST_LOG_OBJECT (flxdec, \"have %d packets\", opcode);\n     while (opcode--) {\n       \/* skip count *\/\n-      guchar skip = *data++;\n-      dest += skip;\n+      guint8 skip;\n+      gint8 count;\n+\n+      if (!gst_byte_reader_get_uint8 (reader, &skip))\n+        goto error;\n+      if (!gst_byte_writer_set_pos (writer,\n+              gst_byte_writer_get_pos (writer) + skip))\n+        goto error;\n \n       \/* RLE count *\/\n-      count = *data++;\n+      if (!gst_byte_reader_get_int8 (reader, &count))\n+        goto error;\n+\n+      if (count < 0) {\n+        guint16 x;\n \n-      if (count > 0x7f) {\n         \/* replicate word run *\/\n-        count = 0x100 - count;\n+        count = ABS (count);\n+\n+        GST_LOG_OBJECT (flxdec, \"have replicate run of size %d at offset %d\",\n+            count, skip);\n \n         if (skip + count > flxdec->hdr.width) {\n           GST_ERROR_OBJECT (flxdec, \"Invalid FLC packet detected. \"\n@@ -481,22 +586,31 @@ flx_decode_delta_flc (GstFlxDec * flxdec, guchar * data, guchar * dest)\n           return FALSE;\n         }\n \n+        if (!gst_byte_reader_get_uint16_le (reader, &x))\n+          goto error;\n+\n         while (count--) {\n-          *dest++ = data[0];\n-          *dest++ = data[1];\n+          if (!gst_byte_writer_put_uint16_le (writer, x)) {\n+            goto error;\n+          }\n         }\n-        data += 2;\n       } else {\n+        GST_LOG_OBJECT (flxdec, \"have literal run of size %d at offset %d\",\n+            count, skip);\n+\n         if (skip + count > flxdec->hdr.width) {\n           GST_ERROR_OBJECT (flxdec, \"Invalid FLC packet detected. \"\n               \"line too long.\");\n           return FALSE;\n         }\n \n-        \/* literal word run *\/\n         while (count--) {\n-          *dest++ = *data++;\n-          *dest++ = *data++;\n+          guint16 x;\n+\n+          if (!gst_byte_reader_get_uint16_le (reader, &x))\n+            goto error;\n+          if (!gst_byte_writer_put_uint16_le (writer, x))\n+            goto error;\n         }\n       }\n     }\n@@ -504,13 +618,91 @@ flx_decode_delta_flc (GstFlxDec * flxdec, guchar * data, guchar * dest)\n   }\n \n   return TRUE;\n+\n+error:\n+  GST_ERROR_OBJECT (flxdec, \"Failed to decode FLI packet\");\n+  return FALSE;\n+}\n+\n+static gboolean\n+_read_flx_header (GstFlxDec * flxdec, GstByteReader * reader, FlxHeader * flxh)\n+{\n+  memset (flxh, 0, sizeof (*flxh));\n+\n+  if (!gst_byte_reader_get_uint32_le (reader, &flxh->size))\n+    goto error;\n+  if (flxh->size < FlxHeaderSize) {\n+    GST_ERROR_OBJECT (flxdec, \"Invalid file size in the header\");\n+    return FALSE;\n+  }\n+\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->type))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->frames))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->width))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->height))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->depth))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->flags))\n+    goto error;\n+  if (!gst_byte_reader_get_uint32_le (reader, &flxh->speed))\n+    goto error;\n+  if (!gst_byte_reader_skip (reader, 2))        \/* reserved *\/\n+    goto error;\n+  \/* FLC *\/\n+  if (!gst_byte_reader_get_uint32_le (reader, &flxh->created))\n+    goto error;\n+  if (!gst_byte_reader_get_uint32_le (reader, &flxh->creator))\n+    goto error;\n+  if (!gst_byte_reader_get_uint32_le (reader, &flxh->updated))\n+    goto error;\n+  if (!gst_byte_reader_get_uint32_le (reader, &flxh->updater))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->aspect_dx))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->aspect_dy))\n+    goto error;\n+  \/* EGI *\/\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->ext_flags))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->keyframes))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->totalframes))\n+    goto error;\n+  if (!gst_byte_reader_get_uint32_le (reader, &flxh->req_memory))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->max_regions))\n+    goto error;\n+  if (!gst_byte_reader_get_uint16_le (reader, &flxh->transp_num))\n+    goto error;\n+  if (!gst_byte_reader_skip (reader, 24))       \/* reserved *\/\n+    goto error;\n+  \/* FLC *\/\n+  if (!gst_byte_reader_get_uint32_le (reader, &flxh->oframe1))\n+    goto error;\n+  if (!gst_byte_reader_get_uint32_le (reader, &flxh->oframe2))\n+    goto error;\n+  if (!gst_byte_reader_skip (reader, 40))       \/* reserved *\/\n+    goto error;\n+\n+  return TRUE;\n+\n+error:\n+  GST_ERROR_OBJECT (flxdec, \"Error reading file header\");\n+  return FALSE;\n }\n \n static GstFlowReturn\n gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n {\n+  GstByteReader reader;\n+  GstBuffer *input;\n+  GstMapInfo map_info;\n   GstCaps *caps;\n-  guint avail;\n+  guint available;\n   GstFlowReturn res = GST_FLOW_OK;\n \n   GstFlxDec *flxdec;\n@@ -521,31 +713,50 @@ gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n   g_return_val_if_fail (flxdec != NULL, GST_FLOW_ERROR);\n \n   gst_adapter_push (flxdec->adapter, buf);\n-  avail = gst_adapter_available (flxdec->adapter);\n+  available = gst_adapter_available (flxdec->adapter);\n+  input = gst_adapter_get_buffer (flxdec->adapter, available);\n+  if (!gst_buffer_map (input, &map_info, GST_MAP_READ)) {\n+    GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n+        (\"%s\", \"Failed to map buffer\"), (NULL));\n+    goto error;\n+  }\n+  gst_byte_reader_init (&reader, map_info.data, map_info.size);\n \n   if (flxdec->state == GST_FLXDEC_READ_HEADER) {\n-    if (avail >= FlxHeaderSize) {\n-      const guint8 *data = gst_adapter_map (flxdec->adapter, FlxHeaderSize);\n+    if (available >= FlxHeaderSize) {\n+      GstByteReader header;\n       GstCaps *templ;\n \n-      memcpy ((gchar *) & flxdec->hdr, data, FlxHeaderSize);\n-      FLX_HDR_FIX_ENDIANNESS (&(flxdec->hdr));\n-      gst_adapter_unmap (flxdec->adapter);\n+      if (!gst_byte_reader_get_sub_reader (&reader, &header, FlxHeaderSize)) {\n+        GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n+            (\"%s\", \"Could not read header\"), (NULL));\n+        goto unmap_input_error;\n+      }\n       gst_adapter_flush (flxdec->adapter, FlxHeaderSize);\n+      available -= FlxHeaderSize;\n+\n+      if (!_read_flx_header (flxdec, &header, &flxdec->hdr)) {\n+        GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n+            (\"%s\", \"Failed to parse header\"), (NULL));\n+        goto unmap_input_error;\n+      }\n \n       flxh = &flxdec->hdr;\n \n       \/* check header *\/\n       if (flxh->type != FLX_MAGICHDR_FLI &&\n-          flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX)\n-        goto wrong_type;\n+          flxh->type != FLX_MAGICHDR_FLC && flxh->type != FLX_MAGICHDR_FLX) {\n+        GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n+            (\"not a flx file (type %x)\", flxh->type));\n+        goto unmap_input_error;\n+      }\n \n-      GST_LOG (\"size      :  %d\", flxh->size);\n-      GST_LOG (\"frames    :  %d\", flxh->frames);\n-      GST_LOG (\"width     :  %d\", flxh->width);\n-      GST_LOG (\"height    :  %d\", flxh->height);\n-      GST_LOG (\"depth     :  %d\", flxh->depth);\n-      GST_LOG (\"speed     :  %d\", flxh->speed);\n+      GST_INFO_OBJECT (flxdec, \"size      :  %d\", flxh->size);\n+      GST_INFO_OBJECT (flxdec, \"frames    :  %d\", flxh->frames);\n+      GST_INFO_OBJECT (flxdec, \"width     :  %d\", flxh->width);\n+      GST_INFO_OBJECT (flxdec, \"height    :  %d\", flxh->height);\n+      GST_INFO_OBJECT (flxdec, \"depth     :  %d\", flxh->depth);\n+      GST_INFO_OBJECT (flxdec, \"speed     :  %d\", flxh->speed);\n \n       flxdec->next_time = 0;\n \n@@ -573,18 +784,32 @@ gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n       gst_pad_set_caps (flxdec->srcpad, caps);\n       gst_caps_unref (caps);\n \n-      if (flxh->depth <= 8)\n-        flxdec->converter =\n-            flx_colorspace_converter_new (flxh->width, flxh->height);\n+      \/* zero means 8 *\/\n+      if (flxh->depth == 0)\n+        flxh->depth = 8;\n+\n+      if (flxh->depth != 8) {\n+        GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE,\n+            (\"%s\", \"Don't know how to decode non 8 bit depth streams\"), (NULL));\n+        goto unmap_input_error;\n+      }\n+\n+      flxdec->converter =\n+          flx_colorspace_converter_new (flxh->width, flxh->height);\n \n       if (flxh->type == FLX_MAGICHDR_FLC || flxh->type == FLX_MAGICHDR_FLX) {\n-        GST_LOG (\"(FLC) aspect_dx :  %d\", flxh->aspect_dx);\n-        GST_LOG (\"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n-        GST_LOG (\"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n-        GST_LOG (\"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n+        GST_INFO_OBJECT (flxdec, \"(FLC) aspect_dx :  %d\", flxh->aspect_dx);\n+        GST_INFO_OBJECT (flxdec, \"(FLC) aspect_dy :  %d\", flxh->aspect_dy);\n+        GST_INFO_OBJECT (flxdec, \"(FLC) oframe1   :  0x%08x\", flxh->oframe1);\n+        GST_INFO_OBJECT (flxdec, \"(FLC) oframe2   :  0x%08x\", flxh->oframe2);\n       }\n \n       flxdec->size = ((guint) flxh->width * (guint) flxh->height);\n+      if (flxdec->size >= G_MAXSIZE \/ 4) {\n+        GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n+            (\"%s\", \"Cannot allocate required memory\"), (NULL));\n+        goto unmap_input_error;\n+      }\n \n       \/* create delta and output frame *\/\n       flxdec->frame_data = g_malloc (flxdec->size);\n@@ -596,55 +821,66 @@ gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n     GstBuffer *out;\n \n     \/* while we have enough data in the adapter *\/\n-    while (avail >= FlxFrameChunkSize && res == GST_FLOW_OK) {\n-      FlxFrameChunk flxfh;\n-      guchar *chunk;\n-      const guint8 *data;\n-      GstMapInfo map;\n-\n-      chunk = NULL;\n-      data = gst_adapter_map (flxdec->adapter, FlxFrameChunkSize);\n-      memcpy (&flxfh, data, FlxFrameChunkSize);\n-      FLX_FRAME_CHUNK_FIX_ENDIANNESS (&flxfh);\n-      gst_adapter_unmap (flxdec->adapter);\n-\n-      switch (flxfh.id) {\n-        case FLX_FRAME_TYPE:\n-          \/* check if we have the complete frame *\/\n-          if (avail < flxfh.size)\n-            goto need_more_data;\n-\n-          \/* flush header *\/\n-          gst_adapter_flush (flxdec->adapter, FlxFrameChunkSize);\n-\n-          chunk = gst_adapter_take (flxdec->adapter,\n-              flxfh.size - FlxFrameChunkSize);\n-          FLX_FRAME_TYPE_FIX_ENDIANNESS ((FlxFrameType *) chunk);\n-          if (((FlxFrameType *) chunk)->chunks == 0)\n-            break;\n+    while (available >= FlxFrameChunkSize && res == GST_FLOW_OK) {\n+      guint32 size;\n+      guint16 type;\n \n-          \/* create 32 bits output frame *\/\n-\/\/          res = gst_pad_alloc_buffer_and_set_caps (flxdec->srcpad,\n-\/\/              GST_BUFFER_OFFSET_NONE,\n-\/\/              flxdec->size * 4, GST_PAD_CAPS (flxdec->srcpad), &out);\n-\/\/          if (res != GST_FLOW_OK)\n-\/\/            break;\n+      if (!gst_byte_reader_get_uint32_le (&reader, &size))\n+        goto parse_error;\n+      if (available < size)\n+        goto need_more_data;\n \n-          out = gst_buffer_new_and_alloc (flxdec->size * 4);\n+      available -= size;\n+      gst_adapter_flush (flxdec->adapter, size);\n+\n+      if (!gst_byte_reader_get_uint16_le (&reader, &type))\n+        goto parse_error;\n+\n+      switch (type) {\n+        case FLX_FRAME_TYPE:{\n+          GstByteReader chunks;\n+          GstByteWriter writer;\n+          guint16 n_chunks;\n+          GstMapInfo map;\n+\n+          GST_LOG_OBJECT (flxdec, \"Have frame type 0x%02x of size %d\", type,\n+              size);\n+\n+          if (!gst_byte_reader_get_sub_reader (&reader, &chunks,\n+                  size - FlxFrameChunkSize))\n+            goto parse_error;\n+\n+          if (!gst_byte_reader_get_uint16_le (&chunks, &n_chunks))\n+            goto parse_error;\n+          GST_LOG_OBJECT (flxdec, \"Have %d chunks\", n_chunks);\n+\n+          if (n_chunks == 0)\n+            break;\n+          if (!gst_byte_reader_skip (&chunks, 8))       \/* reserved *\/\n+            goto parse_error;\n+\n+          gst_byte_writer_init_with_data (&writer, flxdec->frame_data,\n+              flxdec->size, TRUE);\n \n           \/* decode chunks *\/\n-          if (!flx_decode_chunks (flxdec,\n-                  ((FlxFrameType *) chunk)->chunks,\n-                  chunk + FlxFrameTypeSize, flxdec->frame_data)) {\n+          if (!flx_decode_chunks (flxdec, n_chunks, &chunks, &writer)) {\n             GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n                 (\"%s\", \"Could not decode chunk\"), NULL);\n-            return GST_FLOW_ERROR;\n+            goto unmap_input_error;\n           }\n+          gst_byte_writer_reset (&writer);\n \n           \/* save copy of the current frame for possible delta. *\/\n           memcpy (flxdec->delta_data, flxdec->frame_data, flxdec->size);\n \n-          gst_buffer_map (out, &map, GST_MAP_WRITE);\n+          out = gst_buffer_new_and_alloc (flxdec->size * 4);\n+          if (!gst_buffer_map (out, &map, GST_MAP_WRITE)) {\n+            GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n+                (\"%s\", \"Could not map output buffer\"), NULL);\n+            gst_buffer_unref (out);\n+            goto unmap_input_error;\n+          }\n+\n           \/* convert current frame. *\/\n           flx_colorspace_convert (flxdec->converter, flxdec->frame_data,\n               map.data);\n@@ -655,30 +891,32 @@ gst_flxdec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)\n \n           res = gst_pad_push (flxdec->srcpad, out);\n           break;\n+        }\n         default:\n-          \/* check if we have the complete frame *\/\n-          if (avail < flxfh.size)\n-            goto need_more_data;\n-\n-          gst_adapter_flush (flxdec->adapter, flxfh.size);\n+          GST_DEBUG_OBJECT (flxdec, \"Unknown frame type 0x%02x, skipping %d\",\n+              type, size);\n+          if (!gst_byte_reader_skip (&reader, size - FlxFrameChunkSize))\n+            goto parse_error;\n           break;\n       }\n-\n-      g_free (chunk);\n-\n-      avail = gst_adapter_available (flxdec->adapter);\n     }\n   }\n+\n+  gst_buffer_unmap (input, &map_info);\n+  gst_buffer_unref (input);\n+\n need_more_data:\n   return res;\n \n   \/* ERRORS *\/\n-wrong_type:\n-  {\n-    GST_ELEMENT_ERROR (flxdec, STREAM, WRONG_TYPE, (NULL),\n-        (\"not a flx file (type %x)\", flxh->type));\n-    return GST_FLOW_ERROR;\n-  }\n+parse_error:\n+  GST_ELEMENT_ERROR (flxdec, STREAM, DECODE,\n+      (\"%s\", \"Failed to parse stream\"), (NULL));\n+unmap_input_error:\n+  gst_buffer_unmap (input, &map_info);\n+  gst_buffer_unref (input);\n+error:\n+  return GST_FLOW_ERROR;\n }\n \n static GstStateChangeReturn\ndiff --git a\/gst\/flx\/gstflxdec.h b\/gst\/flx\/gstflxdec.h\nindex 3f9a0aa..4fd8dfd 100644\n--- a\/gst\/flx\/gstflxdec.h\n+++ b\/gst\/flx\/gstflxdec.h\n@@ -23,6 +23,8 @@\n #include <gst\/gst.h>\n \n #include <gst\/base\/gstadapter.h>\n+#include <gst\/base\/gstbytereader.h>\n+#include <gst\/base\/gstbytewriter.h>\n #include \"flx_color.h\"\n \n G_BEGIN_DECLS\n@@ -45,7 +47,7 @@ struct _GstFlxDec {\n \n   guint8 *delta_data, *frame_data;\n   GstAdapter *adapter;\n-  gulong size;\n+  gsize size;\n   GstFlxDecState state;\n   gint64 frame_time;\n   gint64 next_time;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-10938","CWE_ID":"125","category":"security","commit_id":"40413955ee265a5e42f710940ec78f5450d49149","commit_message":"From 40413955ee265a5e42f710940ec78f5450d49149 Mon Sep 17 00:00:00 2001\nFrom: \"yujuan.qi\" <yujuan.qi@mediatek.com>\nDate: Mon, 31 Jul 2017 11:23:01 +0800\nSubject: Cipso: cipso_v4_optptr enter infinite loop\n\nin for(),if((optlen > 0) && (optptr[1] == 0)), enter infinite loop.\n\nTest: receive a packet which the ip length > 20 and the first byte of ip option is 0, produce this issue\n\nSigned-off-by: yujuan.qi <yujuan.qi@mediatek.com>\nAcked-by: Paul Moore <paul@paul-moore.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/cipso_ipv4.c | 12 ++++++++++--\n 1 file changed, 10 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/cipso_ipv4.c b\/net\/ipv4\/cipso_ipv4.c\nindex c4c6e1969ed0..2ae8f54cb321 100644\n--- a\/net\/ipv4\/cipso_ipv4.c\n+++ b\/net\/ipv4\/cipso_ipv4.c\n@@ -1523,9 +1523,17 @@ unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n \tint taglen;\n \n \tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n-\t\tif (optptr[0] == IPOPT_CIPSO)\n+\t\tswitch (optptr[0]) {\n+\t\tcase IPOPT_CIPSO:\n \t\t\treturn optptr;\n-\t\ttaglen = optptr[1];\n+\t\tcase IPOPT_END:\n+\t\t\treturn NULL;\n+\t\tcase IPOPT_NOOP:\n+\t\t\ttaglen = 1;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\ttaglen = optptr[1];\n+\t\t}\n \t\toptlen -= taglen;\n \t\toptptr += taglen;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7514","CWE_ID":"125","category":"security","commit_id":"e14fd0a2801f73bdc123baf4fbab97dec55919eb","commit_message":"From e14fd0a2801f73bdc123baf4fbab97dec55919eb Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Fri, 15 Jan 2016 01:27:31 +0100\nSubject: [PATCH] Added missing call to ConstrainColormapIndex.\n\n---\n coders\/psd.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex 5f5fba6c62..5a5c633807 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -835,7 +835,8 @@ static MagickBooleanType ReadPSDChannelPixels(Image *image,\n                   SetPixelIndex(image,(((unsigned char) pixel) &\n                     (0x01 << (7-bit))) != 0 ? 0 : 255,q);\n                   SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n-                    GetPixelIndex(image,q),q);\n+                    ConstrainColormapIndex(image,GetPixelIndex(image,q),\n+                      exception),q);\n                   q+=GetPixelChannels(image);\n                   x++;\n                 }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-6802","CWE_ID":"125","category":"security","commit_id":"22f8346c8d4f0020a40d9f258fdb3bfc097359cc","commit_message":"From 22f8346c8d4f0020a40d9f258fdb3bfc097359cc Mon Sep 17 00:00:00 2001\nFrom: Randall Hand <randall.hand@gmail.com>\nDate: Sat, 25 Feb 2017 07:41:45 -0500\nSubject: [PATCH] Added safety check for Compressed RTF Streams\n\nYou could potentially overflow the input pointer.\n\nin response to #34\n---\n ChangeLog   | 1 +\n lib\/ytnef.c | 2 +-\n 2 files changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex bbe88de..e94c97b 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -3,6 +3,7 @@ v1.9.2 - February 23, 2017\n Thanks to @hannob for finding some Out-of-bound exceptions in memory handline.\n * [SECURITY] An invalid memory access (heap overrun) in handling LONG datatypes\n * [SECURITY] Missing a check for fields of size 0\n+* [SECURITY] Potential buffer overrun on incoming Compressed RTF Streams\n \n This version  & the previous 1.9.1 resolves the following CVEs:\n * CVE-2017-6306\ndiff --git a\/lib\/ytnef.c b\/lib\/ytnef.c\nindex eea43b7..548fcfa 100644\n--- a\/lib\/ytnef.c\n+++ b\/lib\/ytnef.c\n@@ -1541,7 +1541,7 @@ BYTE *DecompressRTF(variableLength *p, int *size) {\n     ALLOCCHECK_CHAR(dst);\n     memcpy(dst, comp_Prebuf.data, comp_Prebuf.size);\n     out = comp_Prebuf.size;\n-    while (out < (comp_Prebuf.size + uncompressedSize)) {\n+    while ((out < (comp_Prebuf.size + uncompressedSize)) && (in < p->size)) {\n       \/\/ each flag byte flags 8 literals\/references, 1 per bit\n       flags = (flagCount++ % 8 == 0) ? src[in++] : flags >> 1;\n       if ((flags & 1) == 1) { \/\/ each flag bit is 1 for reference, 0 for literal\n","owner":"Yeraze","repo":"ytnef","source":"cve"},{"CVE_ID":"CVE-2018-5812","CWE_ID":"125","category":"security","commit_id":"fd6330292501983ac75fe4162275794b18445bd9","commit_message":"From fd6330292501983ac75fe4162275794b18445bd9 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Tue, 24 Apr 2018 15:17:31 +0300\nSubject: [PATCH] Secunia 81800#1: samsumg_load_raw\n\nSecunia 81800#2: find_green\n\nSecunia 81800#3: rollei_load_raw\n\nremove_trailing_spaces: isspace() does not works right with signed non-latin chars\n\nSecunia 81800#5\/6: nikon_coolscan_load_raw\n\nSecunia 81800#4: rollei_load_raw\n---\n dcraw\/dcraw.c             | 157 ++++++++++++++++++++++++++------------\n internal\/dcraw_common.cpp | 156 +++++++++++++++++++++++++------------\n internal\/defines.h        |   1 +\n 3 files changed, 216 insertions(+), 98 deletions(-)\n\n","diff_code":"diff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 1c6bf662..e2b9c7d4 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -251,6 +251,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n \/\/@end DEFINES\n@@ -1511,9 +1512,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1794,7 +1800,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1810,8 +1821,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3857,6 +3871,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3875,11 +3894,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -11081,37 +11106,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -15077,7 +15133,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -15100,14 +15157,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex cfb82a27..b430d3e5 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -1228,9 +1228,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1506,7 +1511,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1522,8 +1532,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3569,6 +3582,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3587,11 +3605,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -9890,37 +9914,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -13739,7 +13794,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -13762,14 +13818,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/defines.h b\/internal\/defines.h\nindex b84e1d28..06e171ec 100644\n--- a\/internal\/defines.h\n+++ b\/internal\/defines.h\n@@ -153,6 +153,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n #define BAYER(row,col) \\\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2018-19497","CWE_ID":"125","category":"security","commit_id":"dd679ad1d855e7f69a887eb343bb53d49dc664e7","commit_message":"From dd679ad1d855e7f69a887eb343bb53d49dc664e7 Mon Sep 17 00:00:00 2001\nFrom: Jordy Zomer <zome8499@student.alfa-college.nl>\nDate: Sat, 24 Nov 2018 12:19:38 +0100\nSubject: [PATCH 1\/3] Fix CVE-2018-19497.\n\nAn issue was discovered in The Sleuth Kit (TSK) through 4.6.4.\nThe \"tsk_getu16(hfs->fs_info.endian, &rec_buf[rec_off2])\" call in hfs_dir_open_meta_cb in\ntsk\/fs\/hfs_dent.c does not properly check boundaries. This results in\na crash (SEGV on unknown address\nREAD memory access)\nwhen reading too much in the destination buffer.\n---\n tsk\/fs\/hfs.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\nFrom fb2bc0ad693db852fac1dcc77a072aeabe106ac8 Mon Sep 17 00:00:00 2001\nFrom: Jordy Zomer <zome8499@student.alfa-college.nl>\nDate: Sat, 24 Nov 2018 12:37:09 +0100\nSubject: [PATCH 2\/3] fix length in printf of nodesize\n\nAlso fix the length in printf next to comit dd679ad1d855e7f69a887eb343bb53d49dc664e7\n---\n tsk\/fs\/hfs.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\nFrom 8242588f4354339d9cb1ad82622e7c16c55391c9 Mon Sep 17 00:00:00 2001\nFrom: Jordy Zomer <zome8499@student.alfa-college.nl>\nDate: Sat, 24 Nov 2018 12:47:23 +0100\nSubject: [PATCH 3\/3] UPDATE on CVE-2018-19497.\n\nmake it >= because if keylen == nodesize - rec_off it's already past it's destination.\nAlso fix the sprintf\n---\n tsk\/fs\/hfs.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/tsk\/fs\/hfs.c b\/tsk\/fs\/hfs.c\nindex 00f1720b1b..0dec507165 100644\n--- a\/tsk\/fs\/hfs.c\n+++ b\/tsk\/fs\/hfs.c\n@@ -956,7 +956,8 @@ hfs_cat_traverse(HFS_INFO * hfs,\n                 key = (hfs_btree_key_cat *) & node[rec_off];\n \n                 keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n-                if ((keylen) > nodesize) {\n+               \n+                if (keylen > nodesize - rec_off) {\n                     tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                     tsk_error_set_errstr\n                         (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n\ndiff --git a\/tsk\/fs\/hfs.c b\/tsk\/fs\/hfs.c\nindex 0dec507165..4f7c0679a8 100644\n--- a\/tsk\/fs\/hfs.c\n+++ b\/tsk\/fs\/hfs.c\n@@ -961,7 +961,7 @@ hfs_cat_traverse(HFS_INFO * hfs,\n                     tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                     tsk_error_set_errstr\n                         (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n-                        PRIu16 \")\", rec, cur_node, keylen, nodesize);\n+                        PRIu16 \")\", rec, cur_node, keylen, nodesize - rec_off);\n                     free(node);\n                     return 1;\n                 }\n\ndiff --git a\/tsk\/fs\/hfs.c b\/tsk\/fs\/hfs.c\nindex 4f7c0679a8..bb3819ada9 100644\n--- a\/tsk\/fs\/hfs.c\n+++ b\/tsk\/fs\/hfs.c\n@@ -957,11 +957,11 @@ hfs_cat_traverse(HFS_INFO * hfs,\n \n                 keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len);\n                \n-                if (keylen > nodesize - rec_off) {\n+                if (keylen >= nodesize - rec_off) {\n                     tsk_error_set_errno(TSK_ERR_FS_GENFS);\n                     tsk_error_set_errstr\n                         (\"hfs_cat_traverse: length of key %d in index node %d too large (%d vs %\"\n-                        PRIu16 \")\", rec, cur_node, keylen, nodesize - rec_off);\n+                        PRIu16 \")\", rec, cur_node, keylen, (nodesize - rec_off));\n                     free(node);\n                     return 1;\n                 }\n","owner":"sleuthkit","repo":"sleuthkit.sleuthkit.sleuthkit","source":"cve"},{"CVE_ID":"CVE-2016-10169","CWE_ID":"125","category":"security","commit_id":"4bc05fc490b66ef2d45b1de26abf1455b486b0dc","commit_message":"From 4bc05fc490b66ef2d45b1de26abf1455b486b0dc Mon Sep 17 00:00:00 2001\nFrom: David Bryant <david@wavpack.com>\nDate: Wed, 21 Dec 2016 22:18:36 -0800\nSubject: [PATCH] fixes for 4 fuzz failures posted to SourceForge mailing list\n\n---\n src\/open_utils.c | 6 +++++-\n src\/read_words.c | 4 ++++\n 2 files changed, 9 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/open_utils.c b\/src\/open_utils.c\nindex 7519f99..a844046 100644\n--- a\/src\/open_utils.c\n+++ b\/src\/open_utils.c\n@@ -560,7 +560,7 @@ static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n \n     \/\/ if there's any data, the first two bytes are file_format and qmode flags\n \n-    if (bytecnt) {\n+    if (bytecnt >= 2) {\n         wpc->file_format = *byteptr++;\n         wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n         bytecnt -= 2;\n@@ -593,6 +593,10 @@ static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n                         for (i = 0; i < nchans; ++i)\n                             if (bytecnt) {\n                                 wpc->channel_reordering [i] = *byteptr++;\n+\n+                                if (wpc->channel_reordering [i] >= nchans)  \/\/ make sure index is in range\n+                                    wpc->channel_reordering [i] = 0;\n+\n                                 bytecnt--;\n                             }\n                             else\ndiff --git a\/src\/read_words.c b\/src\/read_words.c\nindex 62acac3..a537bfa 100644\n--- a\/src\/read_words.c\n+++ b\/src\/read_words.c\n@@ -288,6 +288,10 @@ int32_t FASTCALL get_word (WavpackStream *wps, int chan, int32_t *correction)\n \n     low &= 0x7fffffff;\n     high &= 0x7fffffff;\n+\n+    if (low > high)         \/\/ make sure high and low make sense\n+        high = low;\n+\n     mid = (high + low + 1) >> 1;\n \n     if (!c->error_limit)\n","owner":"dbry","repo":"WavPack","source":"cve"},{"CVE_ID":"CVE-2015-8958","CWE_ID":"125","category":"security","commit_id":"8ea44b48a182dd46d018f4b4f09a5e2ee9638105","commit_message":"From 8ea44b48a182dd46d018f4b4f09a5e2ee9638105 Mon Sep 17 00:00:00 2001\nFrom: cristy <urban-warrior@git.imagemagick.org>\nDate: Tue, 13 Jan 2015 13:31:27 +0000\nSubject: [PATCH]\n\n---\n coders\/sun.c | 15 +--------------\n 1 file changed, 1 insertion(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/coders\/sun.c b\/coders\/sun.c\nindex 7edf41b3a0..3f71a1eda9 100644\n--- a\/coders\/sun.c\n+++ b\/coders\/sun.c\n@@ -255,8 +255,7 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   size_t\n     bytes_per_line,\n     extent,\n-    height,\n-    length;\n+    height;\n \n   ssize_t\n     count,\n@@ -489,13 +488,6 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     else\n       if (image->storage_class == PseudoClass)\n         {\n-          if (bytes_per_line == 0)\n-            bytes_per_line=image->columns;\n-          length=image->rows*(image->columns+image->columns % 2);\n-          if (((sun_info.type == RT_ENCODED) &&\n-               (length > (bytes_per_line*image->rows))) ||\n-              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n-            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n@@ -529,11 +521,6 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n             bytes_per_pixel++;\n           if (bytes_per_line == 0)\n             bytes_per_line=bytes_per_pixel*image->columns;\n-          length=image->rows*(bytes_per_line+bytes_per_line % 2);\n-          if (((sun_info.type == RT_ENCODED) &&\n-               (length > (bytes_per_line*image->rows))) ||\n-              ((sun_info.type != RT_ENCODED) && (length > sun_info.length)))\n-            ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-5956","CWE_ID":"125","category":"security","commit_id":"a5ac49940c40ae415eac0cf912eac7070b4ba95d","commit_message":"From a5ac49940c40ae415eac0cf912eac7070b4ba95d Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Wed, 28 Dec 2016 06:58:43 -0500\nSubject: vrend: add sanity check for vertext buffer index\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe vertext_buffer_index is read from guest and then used\nto index the 'vbo' array in struct 'vrend_sub_context'.\nAdd sanity check for this to avoid oob issue.\n\nReviewed-by: Marc-Andr\u00e9 Lureau <marcandre.lureau@redhat.com>\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n src\/vrend_decode.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/src\/vrend_decode.c b\/src\/vrend_decode.c\nindex 09f08ae..cab3956 100644\n--- a\/src\/vrend_decode.c\n+++ b\/src\/vrend_decode.c\n@@ -612,6 +612,10 @@ static int vrend_decode_create_ve(struct vrend_decode_ctx *ctx, uint32_t handle,\n          ve[i].src_offset = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_OFFSET(i));\n          ve[i].instance_divisor = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_INSTANCE_DIVISOR(i));\n          ve[i].vertex_buffer_index = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_VERTEX_BUFFER_INDEX(i));\n+\n+         if (ve[i].vertex_buffer_index >= PIPE_MAX_ATTRIBS)\n+            return EINVAL;\n+\n          ve[i].src_format = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_FORMAT(i));\n       }\n    }\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6430","CWE_ID":"125","category":"security","commit_id":"626dc56686f15f2dda13c48f78c2a666cb6d8506","commit_message":"From 626dc56686f15f2dda13c48f78c2a666cb6d8506 Mon Sep 17 00:00:00 2001\nFrom: Gianfranco Costamagna <costamagnagianfranco@yahoo.it>\nDate: Thu, 9 Feb 2017 16:01:30 +0100\nSubject: [PATCH] Exit gracefully in case of corrupted filters (Closes issue\n #782)\n\n---\n utils\/etterfilter\/ef_compiler.c | 4 +++-\n utils\/etterfilter\/ef_main.c     | 9 +++++++--\n utils\/etterfilter\/ef_output.c   | 3 +++\n 3 files changed, 13 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/utils\/etterfilter\/ef_compiler.c b\/utils\/etterfilter\/ef_compiler.c\nindex 4ca676c2a..dc26043fc 100644\n--- a\/utils\/etterfilter\/ef_compiler.c\n+++ b\/utils\/etterfilter\/ef_compiler.c\n@@ -239,7 +239,9 @@ size_t compile_tree(struct filter_op **fop)\n    struct filter_op *array = NULL;\n    struct unfold_elm *ue;\n \n-   BUG_IF(tree_root == NULL);\n+   \/\/ invalid file\n+   if (tree_root == NULL)\n+      return 0;\n   \n    fprintf(stdout, \" Unfolding the meta-tree \");\n    fflush(stdout);\ndiff --git a\/utils\/etterfilter\/ef_main.c b\/utils\/etterfilter\/ef_main.c\nindex f17b83b21..2a2f0007c 100644\n--- a\/utils\/etterfilter\/ef_main.c\n+++ b\/utils\/etterfilter\/ef_main.c\n@@ -41,6 +41,7 @@ struct ef_globals *ef_gbls;\n \n int main(int argc, char *argv[])\n {\n+   int ret_value = 0;\n    libettercap_init();\n    ef_globals_alloc();\n    select_text_interface();\n@@ -88,8 +89,12 @@ int main(int argc, char *argv[])\n       fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n   \n    \/* write to file *\/\n-   if (write_output() != E_SUCCESS)\n-      FATAL_ERROR(\"Cannot write output file (%s)\", EF_GBL_OPTIONS->output_file);\n+   ret_value = write_output();\n+   if (ret_value == -E_NOTHANDLED)\n+      FATAL_ERROR(\"Cannot write output file (%s): the filter is not correctly handled.\", EF_GBL_OPTIONS->output_file);\n+   else if (ret_value == -E_INVALID)\n+      FATAL_ERROR(\"Cannot write output file (%s): the filter format is not correct. \", EF_GBL_OPTIONS->output_file);\n+\n    ef_globals_free();\n    return 0;\n }\ndiff --git a\/utils\/etterfilter\/ef_output.c b\/utils\/etterfilter\/ef_output.c\nindex 57e6b00a8..08c32fcb3 100644\n--- a\/utils\/etterfilter\/ef_output.c\n+++ b\/utils\/etterfilter\/ef_output.c\n@@ -51,6 +51,9 @@ int write_output(void)\n    if (fop == NULL)\n       return -E_NOTHANDLED;\n \n+   if (ninst == 0)\n+      return -E_INVALID;\n+\n    \/* create the file *\/\n    fd = open(EF_GBL_OPTIONS->output_file, O_CREAT | O_RDWR | O_TRUNC | O_BINARY, 0644);\n    ON_ERROR(fd, -1, \"Can't create file %s\", EF_GBL_OPTIONS->output_file);\n","owner":"LocutusOfBorg","repo":"ettercap","source":"cve"},{"CVE_ID":"CVE-2016-7393","CWE_ID":"125","category":"security","commit_id":"fb1473080223a634b8ac2cca48a632d037a0a69d","commit_message":"From fb1473080223a634b8ac2cca48a632d037a0a69d Mon Sep 17 00:00:00 2001\nFrom: Janne Grunau <janne-libav@jannau.net>\nDate: Mon, 8 Jun 2015 14:45:12 +0200\nSubject: [PATCH] aac_parser: add required padding for GetBitContext buffer\n\nFixes stack buffer overflow errors detected by address sanitizer in\nvarious fate tests.\n\nCC: libav-stable@libav.org\n---\n libavcodec\/aac_parser.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/aac_parser.c b\/libavcodec\/aac_parser.c\nindex fdaa5f8..acb05d4 100644\n--- a\/libavcodec\/aac_parser.c\n+++ b\/libavcodec\/aac_parser.c\n@@ -34,7 +34,7 @@ static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n     int size;\n     union {\n         uint64_t u64;\n-        uint8_t  u8[8];\n+        uint8_t  u8[8 + FF_INPUT_BUFFER_PADDING_SIZE];\n     } tmp;\n \n     tmp.u64 = av_be2ne64(state);\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-16645","CWE_ID":"125","category":"security","commit_id":"ea04efee7635c9120d015dcdeeeb6988130cb67a","commit_message":"From ea04efee7635c9120d015dcdeeeb6988130cb67a Mon Sep 17 00:00:00 2001\nFrom: Dmitry Torokhov <dmitry.torokhov@gmail.com>\nDate: Sat, 7 Oct 2017 11:07:47 -0700\nSubject: [PATCH] Input: ims-psu - check if CDC union descriptor is sane\n\nBefore trying to use CDC union descriptor, try to validate whether that it\nis sane by checking that intf->altsetting->extra is big enough and that\ndescriptor bLength is not too big and not too small.\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>\n---\n drivers\/input\/misc\/ims-pcu.c | 16 ++++++++++++++--\n 1 file changed, 14 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/input\/misc\/ims-pcu.c b\/drivers\/input\/misc\/ims-pcu.c\nindex 6bf82ea8c918a..ae473123583bb 100644\n--- a\/drivers\/input\/misc\/ims-pcu.c\n+++ b\/drivers\/input\/misc\/ims-pcu.c\n@@ -1635,13 +1635,25 @@ ims_pcu_get_cdc_union_desc(struct usb_interface *intf)\n \t\treturn NULL;\n \t}\n \n-\twhile (buflen > 0) {\n+\twhile (buflen >= sizeof(*union_desc)) {\n \t\tunion_desc = (struct usb_cdc_union_desc *)buf;\n \n+\t\tif (union_desc->bLength > buflen) {\n+\t\t\tdev_err(&intf->dev, \"Too large descriptor\\n\");\n+\t\t\treturn NULL;\n+\t\t}\n+\n \t\tif (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&\n \t\t    union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {\n \t\t\tdev_dbg(&intf->dev, \"Found union header\\n\");\n-\t\t\treturn union_desc;\n+\n+\t\t\tif (union_desc->bLength >= sizeof(*union_desc))\n+\t\t\t\treturn union_desc;\n+\n+\t\t\tdev_err(&intf->dev,\n+\t\t\t\t\"Union descriptor to short (%d vs %zd\\n)\",\n+\t\t\t\tunion_desc->bLength, sizeof(*union_desc));\n+\t\t\treturn NULL;\n \t\t}\n \n \t\tbuflen -= union_desc->bLength;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7952","CWE_ID":"125","category":"security","commit_id":"9556ad67af3129ec4a7a4f4b54a0d59701beeae3","commit_message":"From 9556ad67af3129ec4a7a4f4b54a0d59701beeae3 Mon Sep 17 00:00:00 2001\nFrom: Tobias Stoeckmann <tobias@stoeckmann.org>\nDate: Sun, 25 Sep 2016 21:37:01 +0200\nSubject: Out of boundary access and endless loop in libXtst\n\nA lack of range checks in libXtst allows out of boundary accesses.\nThe checks have to be done in-place here, because it cannot be done\nwithout in-depth knowledge of the read data.\n\nIf XRecordStartOfData, XRecordEndOfData, or XRecordClientDied\nwithout a client sequence have attached data, an endless loop would\noccur. The do-while-loop continues until the current index reaches\nthe end. But in these cases, the current index would not be\nincremented, leading to an endless processing.\n\nSigned-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>\nReviewed-by: Matthieu Herrb <matthieu@herrb.eu>\n---\n src\/XRecord.c | 43 +++++++++++++++++++++++++++++++++++++++----\n 1 file changed, 39 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/src\/XRecord.c b\/src\/XRecord.c\nindex 50420c0..fefd842 100644\n--- a\/src\/XRecord.c\n+++ b\/src\/XRecord.c\n@@ -749,15 +749,23 @@ parse_reply_call_callback(\n \tswitch (rep->category) {\n \tcase XRecordFromServer:\n \t    if (rep->elementHeader&XRecordFromServerTime) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->server_time);\n \t\tcurrent_index += 4;\n \t    }\n+\t    if (current_index + 1 > rep->length << 2)\n+\t\treturn Error;\n \t    switch (reply->buf[current_index]) {\n \t    case X_Reply: \/* reply *\/\n+\t\tif (current_index + 8 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index+4, datum_bytes);\n+\t\tif (datum_bytes < 0 || datum_bytes > ((INT_MAX >> 2) - 8))\n+\t\t    return Error;\n \t\tdatum_bytes = (datum_bytes+8) << 2;\n \t\tbreak;\n \t    default: \/* error or event *\/\n@@ -766,52 +774,73 @@ parse_reply_call_callback(\n \t    break;\n \tcase XRecordFromClient:\n \t    if (rep->elementHeader&XRecordFromClientTime) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->server_time);\n \t\tcurrent_index += 4;\n \t    }\n \t    if (rep->elementHeader&XRecordFromClientSequence) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->client_seq);\n \t\tcurrent_index += 4;\n \t    }\n+\t    if (current_index + 4 > rep->length<<2)\n+\t\treturn Error;\n \t    if (reply->buf[current_index+2] == 0\n \t\t&& reply->buf[current_index+3] == 0) \/* needn't swap 0 *\/\n \t    {\t\/* BIG-REQUESTS *\/\n+\t\tif (current_index + 8 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index+4, datum_bytes);\n \t    } else {\n \t\tEXTRACT_CARD16(rep->clientSwapped,\n \t\t\t       reply->buf+current_index+2, datum_bytes);\n \t    }\n+\t    if (datum_bytes < 0 || datum_bytes > INT_MAX >> 2)\n+\t\treturn Error;\n \t    datum_bytes <<= 2;\n \t    break;\n \tcase XRecordClientStarted:\n+\t    if (current_index + 8 > rep->length << 2)\n+\t\treturn Error;\n \t    EXTRACT_CARD16(rep->clientSwapped,\n \t\t\t   reply->buf+current_index+6, datum_bytes);\n \t    datum_bytes = (datum_bytes+2) << 2;\n \t    break;\n \tcase XRecordClientDied:\n \t    if (rep->elementHeader&XRecordFromClientSequence) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->client_seq);\n \t\tcurrent_index += 4;\n-\t    }\n-\t    \/* fall through *\/\n+\t    } else if (current_index < rep->length << 2)\n+\t\treturn Error;\n+\t    datum_bytes = 0;\n+\t    break;\n \tcase XRecordStartOfData:\n \tcase XRecordEndOfData:\n+\t    if (current_index < rep->length << 2)\n+\t\treturn Error;\n \t    datum_bytes = 0;\n+\t    break;\n \t}\n \n \tif (datum_bytes > 0) {\n-\t    if (current_index + datum_bytes > rep->length << 2)\n+\t    if (INT_MAX - datum_bytes < (rep->length << 2) - current_index) {\n \t\tfprintf(stderr,\n \t\t\t\"XRecord: %lu-byte reply claims %d-byte element (seq %lu)\\n\",\n-\t\t\t(long)rep->length << 2, current_index + datum_bytes,\n+\t\t\t(unsigned long)rep->length << 2, current_index + datum_bytes,\n \t\t\tdpy->last_request_read);\n+\t\treturn Error;\n+\t    }\n \t    \/*\n \t     * This assignment (and indeed the whole buffer sharing\n \t     * scheme) assumes arbitrary 4-byte boundaries are\n@@ -863,6 +892,12 @@ XRecordEnableContext(Display *dpy, XRecordContext context,\n \t    return 0;\n \t}\n \n+\tif (rep.length > INT_MAX >> 2) {\n+\t    UnlockDisplay(dpy);\n+\t    SyncHandle();\n+\t    return 0;\n+\t}\n+\n \tif (rep.length > 0) {\n \t    reply = alloc_reply_buffer(info, rep.length<<2);\n \t    if (!reply) {\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-2633","CWE_ID":"125","category":"security","commit_id":"9f64916da20eea67121d544698676295bbb105a7","commit_message":"From 9f64916da20eea67121d544698676295bbb105a7 Mon Sep 17 00:00:00 2001\nFrom: Gerd Hoffmann <kraxel@redhat.com>\nDate: Wed, 10 Oct 2012 13:29:43 +0200\nSubject: [PATCH] pixman\/vnc: use pixman images in vnc.\n\nThe vnc code uses *three* DisplaySurfaces:\n\nFirst is the surface of the actual QemuConsole, usually the guest\nscreen, but could also be a text console (monitor\/serial reachable via\nCtrl-Alt-<nr> keys).  This is left as-is.\n\nSecond is the current server's view of the screen content.  The vnc code\nuses this to figure which parts of the guest screen did _really_ change\nto reduce the amount of updates sent to the vnc clients.  It is also\nused as data source when sending out the updates to the clients.  This\nsurface gets replaced by a pixman image.  The format changes too,\ninstead of using the guest screen format we'll use fixed 32bit rgb\nframebuffer and convert the pixels on the fly when comparing and\nupdating the server framebuffer.\n\nThird surface carries the format expected by the vnc client.  That isn't\nused to store image data.  This surface is switched to PixelFormat and a\nboolean for bigendian byte order.\n\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n ui\/vnc-enc-hextile-template.h |  23 ++---\n ui\/vnc-enc-hextile.c          |  45 ++++----\n ui\/vnc-enc-tight.c            | 144 ++++++++++++--------------\n ui\/vnc-enc-zrle.c             |  18 ++--\n ui\/vnc-jobs.c                 |   3 +-\n ui\/vnc.c                      | 235 ++++++++++++++++++++++++------------------\n ui\/vnc.h                      |  19 +++-\n 7 files changed, 259 insertions(+), 228 deletions(-)\n\n","diff_code":"diff --git a\/ui\/vnc-enc-hextile-template.h b\/ui\/vnc-enc-hextile-template.h\nindex a7310e1..d868d75 100644\n--- a\/ui\/vnc-enc-hextile-template.h\n+++ b\/ui\/vnc-enc-hextile-template.h\n@@ -14,7 +14,7 @@ static void CONCAT(send_hextile_tile_, NAME)(VncState *vs,\n                                              int *has_bg, int *has_fg)\n {\n     VncDisplay *vd = vs->vd;\n-    uint8_t *row = vd->server->data + y * ds_get_linesize(vs->ds) + x * ds_get_bytes_per_pixel(vs->ds);\n+    uint8_t *row = vnc_server_fb_ptr(vd, x, y);\n     pixel_t *irow = (pixel_t *)row;\n     int j, i;\n     pixel_t *last_bg = (pixel_t *)last_bg_;\n@@ -25,7 +25,7 @@ static void CONCAT(send_hextile_tile_, NAME)(VncState *vs,\n     int bg_count = 0;\n     int fg_count = 0;\n     int flags = 0;\n-    uint8_t data[(vs->clientds.pf.bytes_per_pixel + 2) * 16 * 16];\n+    uint8_t data[(vs->client_pf.bytes_per_pixel + 2) * 16 * 16];\n     int n_data = 0;\n     int n_subtiles = 0;\n \n@@ -58,7 +58,7 @@ static void CONCAT(send_hextile_tile_, NAME)(VncState *vs,\n \t}\n \tif (n_colors > 2)\n \t    break;\n-\tirow += ds_get_linesize(vs->ds) \/ sizeof(pixel_t);\n+\tirow += vnc_server_fb_stride(vd) \/ sizeof(pixel_t);\n     }\n \n     if (n_colors > 1 && fg_count > bg_count) {\n@@ -106,7 +106,7 @@ static void CONCAT(send_hextile_tile_, NAME)(VncState *vs,\n \t\tn_data += 2;\n \t\tn_subtiles++;\n \t    }\n-\t    irow += ds_get_linesize(vs->ds) \/ sizeof(pixel_t);\n+\t    irow += vnc_server_fb_stride(vd) \/ sizeof(pixel_t);\n \t}\n \tbreak;\n     case 3:\n@@ -133,7 +133,7 @@ static void CONCAT(send_hextile_tile_, NAME)(VncState *vs,\n \t\t    has_color = 0;\n #ifdef GENERIC\n                     vnc_convert_pixel(vs, data + n_data, color);\n-                    n_data += vs->clientds.pf.bytes_per_pixel;\n+                    n_data += vs->client_pf.bytes_per_pixel;\n #else\n \t\t    memcpy(data + n_data, &color, sizeof(color));\n                     n_data += sizeof(pixel_t);\n@@ -153,7 +153,7 @@ static void CONCAT(send_hextile_tile_, NAME)(VncState *vs,\n \t    if (has_color) {\n #ifdef GENERIC\n                 vnc_convert_pixel(vs, data + n_data, color);\n-                n_data += vs->clientds.pf.bytes_per_pixel;\n+                n_data += vs->client_pf.bytes_per_pixel;\n #else\n                 memcpy(data + n_data, &color, sizeof(color));\n                 n_data += sizeof(pixel_t);\n@@ -162,7 +162,7 @@ static void CONCAT(send_hextile_tile_, NAME)(VncState *vs,\n \t\tn_data += 2;\n \t\tn_subtiles++;\n \t    }\n-\t    irow += ds_get_linesize(vs->ds) \/ sizeof(pixel_t);\n+\t    irow += vnc_server_fb_stride(vd) \/ sizeof(pixel_t);\n \t}\n \n \t\/* A SubrectsColoured subtile invalidates the foreground color *\/\n@@ -190,18 +190,17 @@ static void CONCAT(send_hextile_tile_, NAME)(VncState *vs,\n     vnc_write_u8(vs, flags);\n     if (n_colors < 4) {\n \tif (flags & 0x02)\n-\t    vs->write_pixels(vs, &vd->server->pf, last_bg, sizeof(pixel_t));\n+\t    vs->write_pixels(vs, last_bg, sizeof(pixel_t));\n \tif (flags & 0x04)\n-\t    vs->write_pixels(vs, &vd->server->pf, last_fg, sizeof(pixel_t));\n+\t    vs->write_pixels(vs, last_fg, sizeof(pixel_t));\n \tif (n_subtiles) {\n \t    vnc_write_u8(vs, n_subtiles);\n \t    vnc_write(vs, data, n_data);\n \t}\n     } else {\n \tfor (j = 0; j < h; j++) {\n-\t    vs->write_pixels(vs, &vd->server->pf, row,\n-                             w * ds_get_bytes_per_pixel(vs->ds));\n-\t    row += ds_get_linesize(vs->ds);\n+\t    vs->write_pixels(vs, row, w * 4);\n+\t    row += vnc_server_fb_stride(vd);\n \t}\n     }\n }\ndiff --git a\/ui\/vnc-enc-hextile.c b\/ui\/vnc-enc-hextile.c\nindex c860dbb..263a0ce 100644\n--- a\/ui\/vnc-enc-hextile.c\n+++ b\/ui\/vnc-enc-hextile.c\n@@ -68,10 +68,9 @@ int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n     int i, j;\n     int has_fg, has_bg;\n     uint8_t *last_fg, *last_bg;\n-    VncDisplay *vd = vs->vd;\n \n-    last_fg = (uint8_t *) g_malloc(vd->server->pf.bytes_per_pixel);\n-    last_bg = (uint8_t *) g_malloc(vd->server->pf.bytes_per_pixel);\n+    last_fg = (uint8_t *) g_malloc(VNC_SERVER_FB_BYTES);\n+    last_bg = (uint8_t *) g_malloc(VNC_SERVER_FB_BYTES);\n     has_fg = has_bg = 0;\n     for (j = y; j < (y + h); j += 16) {\n         for (i = x; i < (x + w); i += 16) {\n@@ -89,28 +88,28 @@ int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n void vnc_hextile_set_pixel_conversion(VncState *vs, int generic)\n {\n     if (!generic) {\n-        switch (vs->ds->surface->pf.bits_per_pixel) {\n-            case 8:\n-                vs->hextile.send_tile = send_hextile_tile_8;\n-                break;\n-            case 16:\n-                vs->hextile.send_tile = send_hextile_tile_16;\n-                break;\n-            case 32:\n-                vs->hextile.send_tile = send_hextile_tile_32;\n-                break;\n+        switch (VNC_SERVER_FB_BITS) {\n+        case 8:\n+            vs->hextile.send_tile = send_hextile_tile_8;\n+            break;\n+        case 16:\n+            vs->hextile.send_tile = send_hextile_tile_16;\n+            break;\n+        case 32:\n+            vs->hextile.send_tile = send_hextile_tile_32;\n+            break;\n         }\n     } else {\n-        switch (vs->ds->surface->pf.bits_per_pixel) {\n-            case 8:\n-                vs->hextile.send_tile = send_hextile_tile_generic_8;\n-                break;\n-            case 16:\n-                vs->hextile.send_tile = send_hextile_tile_generic_16;\n-                break;\n-            case 32:\n-                vs->hextile.send_tile = send_hextile_tile_generic_32;\n-                break;\n+        switch (VNC_SERVER_FB_BITS) {\n+        case 8:\n+            vs->hextile.send_tile = send_hextile_tile_generic_8;\n+            break;\n+        case 16:\n+            vs->hextile.send_tile = send_hextile_tile_generic_16;\n+            break;\n+        case 32:\n+            vs->hextile.send_tile = send_hextile_tile_generic_32;\n+            break;\n         }\n     }\n }\ndiff --git a\/ui\/vnc-enc-tight.c b\/ui\/vnc-enc-tight.c\nindex 5d492ab..8013c5c 100644\n--- a\/ui\/vnc-enc-tight.c\n+++ b\/ui\/vnc-enc-tight.c\n@@ -124,7 +124,7 @@ static bool tight_can_send_png_rect(VncState *vs, int w, int h)\n     }\n \n     if (ds_get_bytes_per_pixel(vs->ds) == 1 ||\n-        vs->clientds.pf.bytes_per_pixel == 1) {\n+        vs->client_pf.bytes_per_pixel == 1) {\n         return false;\n     }\n \n@@ -153,7 +153,7 @@ tight_detect_smooth_image24(VncState *vs, int w, int h)\n      * If client is big-endian, color samples begin from the second\n      * byte (offset 1) of a 32-bit pixel value.\n      *\/\n-    off = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n+    off = vs->client_be;\n \n     memset(stats, 0, sizeof (stats));\n \n@@ -216,16 +216,16 @@ tight_detect_smooth_image24(VncState *vs, int w, int h)\n         unsigned int errors;                                            \\\n         unsigned char *buf = vs->tight.tight.buffer;                    \\\n                                                                         \\\n-        endian = ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) !=        \\\n-                  (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG));     \\\n+        endian = 0; \/* FIXME: ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) != \\\n+                      (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)); *\/ \\\n                                                                         \\\n                                                                         \\\n-        max[0] = vs->clientds.pf.rmax;                                  \\\n-        max[1] = vs->clientds.pf.gmax;                                  \\\n-        max[2] = vs->clientds.pf.bmax;                                  \\\n-        shift[0] = vs->clientds.pf.rshift;                              \\\n-        shift[1] = vs->clientds.pf.gshift;                              \\\n-        shift[2] = vs->clientds.pf.bshift;                              \\\n+        max[0] = vs->client_pf.rmax;                                  \\\n+        max[1] = vs->client_pf.gmax;                                  \\\n+        max[2] = vs->client_pf.bmax;                                  \\\n+        shift[0] = vs->client_pf.rshift;                              \\\n+        shift[1] = vs->client_pf.gshift;                              \\\n+        shift[2] = vs->client_pf.bshift;                              \\\n                                                                         \\\n         memset(stats, 0, sizeof(stats));                                \\\n                                                                         \\\n@@ -302,7 +302,7 @@ tight_detect_smooth_image(VncState *vs, int w, int h)\n     }\n \n     if (ds_get_bytes_per_pixel(vs->ds) == 1 ||\n-        vs->clientds.pf.bytes_per_pixel == 1 ||\n+        vs->client_pf.bytes_per_pixel == 1 ||\n         w < VNC_TIGHT_DETECT_MIN_WIDTH || h < VNC_TIGHT_DETECT_MIN_HEIGHT) {\n         return 0;\n     }\n@@ -317,7 +317,7 @@ tight_detect_smooth_image(VncState *vs, int w, int h)\n         }\n     }\n \n-    if (vs->clientds.pf.bytes_per_pixel == 4) {\n+    if (vs->client_pf.bytes_per_pixel == 4) {\n         if (vs->tight.pixel24) {\n             errors = tight_detect_smooth_image24(vs, w, h);\n             if (vs->tight.quality != (uint8_t)-1) {\n@@ -430,7 +430,7 @@ static int tight_fill_palette(VncState *vs, int x, int y,\n         max = 256;\n     }\n \n-    switch(vs->clientds.pf.bytes_per_pixel) {\n+    switch (vs->client_pf.bytes_per_pixel) {\n     case 4:\n         return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);\n     case 2:\n@@ -557,15 +557,15 @@ tight_filter_gradient24(VncState *vs, uint8_t *buf, int w, int h)\n     buf32 = (uint32_t *)buf;\n     memset(vs->tight.gradient.buffer, 0, w * 3 * sizeof(int));\n \n-    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n-        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {\n-        shift[0] = vs->clientds.pf.rshift;\n-        shift[1] = vs->clientds.pf.gshift;\n-        shift[2] = vs->clientds.pf.bshift;\n+    if (1 \/* FIXME: (vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n+             (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG) *\/) {\n+        shift[0] = vs->client_pf.rshift;\n+        shift[1] = vs->client_pf.gshift;\n+        shift[2] = vs->client_pf.bshift;\n     } else {\n-        shift[0] = 24 - vs->clientds.pf.rshift;\n-        shift[1] = 24 - vs->clientds.pf.gshift;\n-        shift[2] = 24 - vs->clientds.pf.bshift;\n+        shift[0] = 24 - vs->client_pf.rshift;\n+        shift[1] = 24 - vs->client_pf.gshift;\n+        shift[2] = 24 - vs->client_pf.bshift;\n     }\n \n     for (y = 0; y < h; y++) {\n@@ -615,15 +615,15 @@ tight_filter_gradient24(VncState *vs, uint8_t *buf, int w, int h)\n                                                                         \\\n         memset (vs->tight.gradient.buffer, 0, w * 3 * sizeof(int));     \\\n                                                                         \\\n-        endian = ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) !=        \\\n-                  (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG));     \\\n+        endian = 0; \/* FIXME: ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) != \\\n+                       (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)); *\/ \\\n                                                                         \\\n-        max[0] = vs->clientds.pf.rmax;                                  \\\n-        max[1] = vs->clientds.pf.gmax;                                  \\\n-        max[2] = vs->clientds.pf.bmax;                                  \\\n-        shift[0] = vs->clientds.pf.rshift;                              \\\n-        shift[1] = vs->clientds.pf.gshift;                              \\\n-        shift[2] = vs->clientds.pf.bshift;                              \\\n+        max[0] = vs->client_pf.rmax;                                    \\\n+        max[1] = vs->client_pf.gmax;                                    \\\n+        max[2] = vs->client_pf.bmax;                                    \\\n+        shift[0] = vs->client_pf.rshift;                                \\\n+        shift[1] = vs->client_pf.gshift;                                \\\n+        shift[2] = vs->client_pf.bshift;                                \\\n                                                                         \\\n         for (y = 0; y < h; y++) {                                       \\\n             for (c = 0; c < 3; c++) {                                   \\\n@@ -682,9 +682,7 @@ DEFINE_GRADIENT_FILTER_FUNCTION(32)\n         uint##bpp##_t c;                                                \\\n         int dx, dy;                                                     \\\n                                                                         \\\n-        fbptr = (uint##bpp##_t *)                                       \\\n-            (vd->server->data + y * ds_get_linesize(vs->ds) +           \\\n-             x * ds_get_bytes_per_pixel(vs->ds));                       \\\n+        fbptr = vnc_server_fb_ptr(vd, x, y);                            \\\n                                                                         \\\n         c = *fbptr;                                                     \\\n         if (samecolor && (uint32_t)c != *color) {                       \\\n@@ -698,7 +696,7 @@ DEFINE_GRADIENT_FILTER_FUNCTION(32)\n                 }                                                       \\\n             }                                                           \\\n             fbptr = (uint##bpp##_t *)                                   \\\n-                ((uint8_t *)fbptr + ds_get_linesize(vs->ds));           \\\n+                ((uint8_t *)fbptr + vnc_server_fb_stride(vd));          \\\n         }                                                               \\\n                                                                         \\\n         *color = (uint32_t)c;                                           \\\n@@ -712,9 +710,7 @@ DEFINE_CHECK_SOLID_FUNCTION(8)\n static bool check_solid_tile(VncState *vs, int x, int y, int w, int h,\n                              uint32_t* color, bool samecolor)\n {\n-    VncDisplay *vd = vs->vd;\n-\n-    switch(vd->server->pf.bytes_per_pixel) {\n+    switch (VNC_SERVER_FB_BYTES) {\n     case 4:\n         return check_solid_tile32(vs, x, y, w, h, color, samecolor);\n     case 2:\n@@ -906,15 +902,15 @@ static void tight_pack24(VncState *vs, uint8_t *buf, size_t count, size_t *ret)\n \n     buf32 = (uint32_t *)buf;\n \n-    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n-        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {\n-        rshift = vs->clientds.pf.rshift;\n-        gshift = vs->clientds.pf.gshift;\n-        bshift = vs->clientds.pf.bshift;\n+    if (1 \/* FIXME: (vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n+             (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG) *\/) {\n+        rshift = vs->client_pf.rshift;\n+        gshift = vs->client_pf.gshift;\n+        bshift = vs->client_pf.bshift;\n     } else {\n-        rshift = 24 - vs->clientds.pf.rshift;\n-        gshift = 24 - vs->clientds.pf.gshift;\n-        bshift = 24 - vs->clientds.pf.bshift;\n+        rshift = 24 - vs->client_pf.rshift;\n+        gshift = 24 - vs->client_pf.gshift;\n+        bshift = 24 - vs->client_pf.bshift;\n     }\n \n     if (ret) {\n@@ -946,7 +942,7 @@ static int send_full_color_rect(VncState *vs, int x, int y, int w, int h)\n         tight_pack24(vs, vs->tight.tight.buffer, w * h, &vs->tight.tight.offset);\n         bytes = 3;\n     } else {\n-        bytes = vs->clientds.pf.bytes_per_pixel;\n+        bytes = vs->client_pf.bytes_per_pixel;\n     }\n \n     bytes = tight_compress_data(vs, stream, w * h * bytes,\n@@ -966,7 +962,7 @@ static int send_solid_rect(VncState *vs)\n         tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);\n         bytes = 3;\n     } else {\n-        bytes = vs->clientds.pf.bytes_per_pixel;\n+        bytes = vs->client_pf.bytes_per_pixel;\n     }\n \n     vnc_write(vs, vs->tight.tight.buffer, bytes);\n@@ -983,7 +979,7 @@ static int send_mono_rect(VncState *vs, int x, int y,\n #ifdef CONFIG_VNC_PNG\n     if (tight_can_send_png_rect(vs, w, h)) {\n         int ret;\n-        int bpp = vs->clientds.pf.bytes_per_pixel * 8;\n+        int bpp = vs->client_pf.bytes_per_pixel * 8;\n         VncPalette *palette = palette_new(2, bpp);\n \n         palette_put(palette, bg);\n@@ -1000,7 +996,7 @@ static int send_mono_rect(VncState *vs, int x, int y,\n     vnc_write_u8(vs, VNC_TIGHT_FILTER_PALETTE);\n     vnc_write_u8(vs, 1);\n \n-    switch(vs->clientds.pf.bytes_per_pixel) {\n+    switch (vs->client_pf.bytes_per_pixel) {\n     case 4:\n     {\n         uint32_t buf[2] = {bg, fg};\n@@ -1043,7 +1039,7 @@ static void write_palette(int idx, uint32_t color, void *opaque)\n {\n     struct palette_cb_priv *priv = opaque;\n     VncState *vs = priv->vs;\n-    uint32_t bytes = vs->clientds.pf.bytes_per_pixel;\n+    uint32_t bytes = vs->client_pf.bytes_per_pixel;\n \n     if (bytes == 4) {\n         ((uint32_t*)priv->header)[idx] = color;\n@@ -1058,8 +1054,9 @@ static bool send_gradient_rect(VncState *vs, int x, int y, int w, int h)\n     int level = tight_conf[vs->tight.compression].gradient_zlib_level;\n     ssize_t bytes;\n \n-    if (vs->clientds.pf.bytes_per_pixel == 1)\n+    if (vs->client_pf.bytes_per_pixel == 1) {\n         return send_full_color_rect(vs, x, y, w, h);\n+    }\n \n     vnc_write_u8(vs, (stream | VNC_TIGHT_EXPLICIT_FILTER) << 4);\n     vnc_write_u8(vs, VNC_TIGHT_FILTER_GRADIENT);\n@@ -1069,7 +1066,7 @@ static bool send_gradient_rect(VncState *vs, int x, int y, int w, int h)\n     if (vs->tight.pixel24) {\n         tight_filter_gradient24(vs, vs->tight.tight.buffer, w, h);\n         bytes = 3;\n-    } else if (vs->clientds.pf.bytes_per_pixel == 4) {\n+    } else if (vs->client_pf.bytes_per_pixel == 4) {\n         tight_filter_gradient32(vs, (uint32_t *)vs->tight.tight.buffer, w, h);\n         bytes = 4;\n     } else {\n@@ -1107,7 +1104,7 @@ static int send_palette_rect(VncState *vs, int x, int y,\n     vnc_write_u8(vs, VNC_TIGHT_FILTER_PALETTE);\n     vnc_write_u8(vs, colors - 1);\n \n-    switch(vs->clientds.pf.bytes_per_pixel) {\n+    switch (vs->client_pf.bytes_per_pixel) {\n     case 4:\n     {\n         size_t old_offset, offset;\n@@ -1156,8 +1153,7 @@ static void rgb_prepare_row24(VncState *vs, uint8_t *dst, int x, int y,\n     uint32_t *fbptr;\n     uint32_t pix;\n \n-    fbptr = (uint32_t *)(vd->server->data + y * ds_get_linesize(vs->ds) +\n-                         x * ds_get_bytes_per_pixel(vs->ds));\n+    fbptr = vnc_server_fb_ptr(vd, x, y);\n \n     while (count--) {\n         pix = *fbptr++;\n@@ -1178,9 +1174,7 @@ static void rgb_prepare_row24(VncState *vs, uint8_t *dst, int x, int y,\n         uint##bpp##_t pix;                                              \\\n         int r, g, b;                                                    \\\n                                                                         \\\n-        fbptr = (uint##bpp##_t *)                                       \\\n-            (vd->server->data + y * ds_get_linesize(vs->ds) +           \\\n-             x * ds_get_bytes_per_pixel(vs->ds));                       \\\n+        fbptr = vnc_server_fb_ptr(vd, x, y);                            \\\n                                                                         \\\n         while (count--) {                                               \\\n             pix = *fbptr++;                                             \\\n@@ -1207,10 +1201,8 @@ DEFINE_RGB_GET_ROW_FUNCTION(32)\n static void rgb_prepare_row(VncState *vs, uint8_t *dst, int x, int y,\n                             int count)\n {\n-    if (ds_get_bytes_per_pixel(vs->ds) == 4) {\n-        if (vs->ds->surface->pf.rmax == 0xFF &&\n-            vs->ds->surface->pf.gmax == 0xFF &&\n-            vs->ds->surface->pf.bmax == 0xFF) {\n+    if (VNC_SERVER_FB_BYTES == 4) {\n+        if (1) {\n             rgb_prepare_row24(vs, dst, x, y, count);\n         } else {\n             rgb_prepare_row32(vs, dst, x, y, count);\n@@ -1326,23 +1318,23 @@ static void write_png_palette(int idx, uint32_t pix, void *opaque)\n \n     if (vs->tight.pixel24)\n     {\n-        color->red = (pix >> vs->clientds.pf.rshift) & vs->clientds.pf.rmax;\n-        color->green = (pix >> vs->clientds.pf.gshift) & vs->clientds.pf.gmax;\n-        color->blue = (pix >> vs->clientds.pf.bshift) & vs->clientds.pf.bmax;\n+        color->red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;\n+        color->green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;\n+        color->blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;\n     }\n     else\n     {\n         int red, green, blue;\n \n-        red = (pix >> vs->clientds.pf.rshift) & vs->clientds.pf.rmax;\n-        green = (pix >> vs->clientds.pf.gshift) & vs->clientds.pf.gmax;\n-        blue = (pix >> vs->clientds.pf.bshift) & vs->clientds.pf.bmax;\n-        color->red = ((red * 255 + vs->clientds.pf.rmax \/ 2) \/\n-                      vs->clientds.pf.rmax);\n-        color->green = ((green * 255 + vs->clientds.pf.gmax \/ 2) \/\n-                        vs->clientds.pf.gmax);\n-        color->blue = ((blue * 255 + vs->clientds.pf.bmax \/ 2) \/\n-                       vs->clientds.pf.bmax);\n+        red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;\n+        green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;\n+        blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;\n+        color->red = ((red * 255 + vs->client_pf.rmax \/ 2) \/\n+                      vs->client_pf.rmax);\n+        color->green = ((green * 255 + vs->client_pf.gmax \/ 2) \/\n+                        vs->client_pf.gmax);\n+        color->blue = ((blue * 255 + vs->client_pf.bmax \/ 2) \/\n+                       vs->client_pf.bmax);\n     }\n }\n \n@@ -1422,7 +1414,7 @@ static int send_png_rect(VncState *vs, int x, int y, int w, int h,\n \n         png_set_PLTE(png_ptr, info_ptr, png_palette, palette_size(palette));\n \n-        if (vs->clientds.pf.bytes_per_pixel == 4) {\n+        if (vs->client_pf.bytes_per_pixel == 4) {\n             tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);\n         } else {\n             tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);\n@@ -1713,8 +1705,8 @@ static int tight_send_framebuffer_update(VncState *vs, int x, int y,\n {\n     int max_rows;\n \n-    if (vs->clientds.pf.bytes_per_pixel == 4 && vs->clientds.pf.rmax == 0xFF &&\n-        vs->clientds.pf.bmax == 0xFF && vs->clientds.pf.gmax == 0xFF) {\n+    if (vs->client_pf.bytes_per_pixel == 4 && vs->client_pf.rmax == 0xFF &&\n+        vs->client_pf.bmax == 0xFF && vs->client_pf.gmax == 0xFF) {\n         vs->tight.pixel24 = true;\n     } else {\n         vs->tight.pixel24 = false;\ndiff --git a\/ui\/vnc-enc-zrle.c b\/ui\/vnc-enc-zrle.c\nindex 917d384..ed3b484 100644\n--- a\/ui\/vnc-enc-zrle.c\n+++ b\/ui\/vnc-enc-zrle.c\n@@ -255,7 +255,7 @@ static void zrle_write_u8(VncState *vs, uint8_t value)\n static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n                                         int w, int h)\n {\n-    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n+    bool be = vs->client_be;\n     size_t bytes;\n     int zywrle_level;\n \n@@ -277,13 +277,13 @@ static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n \n     vnc_zrle_start(vs);\n \n-    switch(vs->clientds.pf.bytes_per_pixel) {\n+    switch (vs->client_pf.bytes_per_pixel) {\n     case 1:\n         zrle_encode_8ne(vs, x, y, w, h, zywrle_level);\n         break;\n \n     case 2:\n-        if (vs->clientds.pf.gmax > 0x1F) {\n+        if (vs->client_pf.gmax > 0x1F) {\n             if (be) {\n                 zrle_encode_16be(vs, x, y, w, h, zywrle_level);\n             } else {\n@@ -304,13 +304,13 @@ static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n         bool fits_in_ms3bytes;\n \n         fits_in_ls3bytes =\n-            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n-             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n-             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n+            ((vs->client_pf.rmax << vs->client_pf.rshift) < (1 << 24) &&\n+             (vs->client_pf.gmax << vs->client_pf.gshift) < (1 << 24) &&\n+             (vs->client_pf.bmax << vs->client_pf.bshift) < (1 << 24));\n \n-        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n-                            vs->clientds.pf.gshift > 7 &&\n-                            vs->clientds.pf.bshift > 7);\n+        fits_in_ms3bytes = (vs->client_pf.rshift > 7 &&\n+                            vs->client_pf.gshift > 7 &&\n+                            vs->client_pf.bshift > 7);\n \n         if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n             if (be) {\ndiff --git a\/ui\/vnc-jobs.c b\/ui\/vnc-jobs.c\nindex 3c592b3..04f139b 100644\n--- a\/ui\/vnc-jobs.c\n+++ b\/ui\/vnc-jobs.c\n@@ -187,7 +187,8 @@ static void vnc_async_encoding_start(VncState *orig, VncState *local)\n     local->vd = orig->vd;\n     local->lossy_rect = orig->lossy_rect;\n     local->write_pixels = orig->write_pixels;\n-    local->clientds = orig->clientds;\n+    local->client_pf = orig->client_pf;\n+    local->client_be = orig->client_be;\n     local->tight = orig->tight;\n     local->zlib = orig->zlib;\n     local->hextile = orig->hextile;\ndiff --git a\/ui\/vnc.c b\/ui\/vnc.c\nindex 0ae1c74..15aef86 100644\n--- a\/ui\/vnc.c\n+++ b\/ui\/vnc.c\n@@ -436,6 +436,8 @@ static void vnc_dpy_update(DisplayState *ds, int x, int y, int w, int h)\n     int i;\n     VncDisplay *vd = ds->opaque;\n     struct VncSurface *s = &vd->guest;\n+    int width = ds_get_width(ds);\n+    int height = ds_get_height(ds);\n \n     h += y;\n \n@@ -446,10 +448,10 @@ static void vnc_dpy_update(DisplayState *ds, int x, int y, int w, int h)\n     w += (x % 16);\n     x -= (x % 16);\n \n-    x = MIN(x, s->ds->width);\n-    y = MIN(y, s->ds->height);\n-    w = MIN(x + w, s->ds->width) - x;\n-    h = MIN(h, s->ds->height);\n+    x = MIN(x, width);\n+    y = MIN(y, height);\n+    w = MIN(x + w, width) - x;\n+    h = MIN(h, height);\n \n     for (; y < h; y++)\n         for (i = 0; i < w; i += 16)\n@@ -550,6 +552,21 @@ static void vnc_abort_display_jobs(VncDisplay *vd)\n     }\n }\n \n+int vnc_server_fb_stride(VncDisplay *vd)\n+{\n+    return pixman_image_get_stride(vd->server);\n+}\n+\n+void *vnc_server_fb_ptr(VncDisplay *vd, int x, int y)\n+{\n+    uint8_t *ptr;\n+\n+    ptr  = (uint8_t *)pixman_image_get_data(vd->server);\n+    ptr += y * vnc_server_fb_stride(vd);\n+    ptr += x * VNC_SERVER_FB_BYTES;\n+    return ptr;\n+}\n+\n static void vnc_dpy_resize(DisplayState *ds)\n {\n     VncDisplay *vd = ds->opaque;\n@@ -558,20 +575,20 @@ static void vnc_dpy_resize(DisplayState *ds)\n     vnc_abort_display_jobs(vd);\n \n     \/* server surface *\/\n-    if (!vd->server)\n-        vd->server = g_malloc0(sizeof(*vd->server));\n-    if (vd->server->data)\n-        g_free(vd->server->data);\n-    *(vd->server) = *(ds->surface);\n-    vd->server->data = g_malloc0(vd->server->linesize *\n-                                    vd->server->height);\n+    qemu_pixman_image_unref(vd->server);\n+    vd->server = pixman_image_create_bits(VNC_SERVER_FB_FORMAT,\n+                                          ds_get_width(ds),\n+                                          ds_get_height(ds),\n+                                          NULL, 0);\n \n     \/* guest surface *\/\n-    if (!vd->guest.ds)\n-        vd->guest.ds = g_malloc0(sizeof(*vd->guest.ds));\n+#if 0 \/* FIXME *\/\n     if (ds_get_bytes_per_pixel(ds) != vd->guest.ds->pf.bytes_per_pixel)\n         console_color_init(ds);\n-    *(vd->guest.ds) = *(ds->surface);\n+#endif\n+    qemu_pixman_image_unref(vd->guest.fb);\n+    vd->guest.fb = pixman_image_ref(ds->surface->image);\n+    vd->guest.format = ds->surface->format;\n     memset(vd->guest.dirty, 0xFF, sizeof(vd->guest.dirty));\n \n     QTAILQ_FOREACH(vs, &vd->clients, next) {\n@@ -585,7 +602,7 @@ static void vnc_dpy_resize(DisplayState *ds)\n }\n \n \/* fastest code *\/\n-static void vnc_write_pixels_copy(VncState *vs, struct PixelFormat *pf,\n+static void vnc_write_pixels_copy(VncState *vs,\n                                   void *pixels, int size)\n {\n     vnc_write(vs, pixels, size);\n@@ -595,23 +612,23 @@ static void vnc_write_pixels_copy(VncState *vs, struct PixelFormat *pf,\n void vnc_convert_pixel(VncState *vs, uint8_t *buf, uint32_t v)\n {\n     uint8_t r, g, b;\n-    VncDisplay *vd = vs->vd;\n \n-    r = ((((v & vd->server->pf.rmask) >> vd->server->pf.rshift) << vs->clientds.pf.rbits) >>\n-        vd->server->pf.rbits);\n-    g = ((((v & vd->server->pf.gmask) >> vd->server->pf.gshift) << vs->clientds.pf.gbits) >>\n-        vd->server->pf.gbits);\n-    b = ((((v & vd->server->pf.bmask) >> vd->server->pf.bshift) << vs->clientds.pf.bbits) >>\n-        vd->server->pf.bbits);\n-    v = (r << vs->clientds.pf.rshift) |\n-        (g << vs->clientds.pf.gshift) |\n-        (b << vs->clientds.pf.bshift);\n-    switch(vs->clientds.pf.bytes_per_pixel) {\n+#if VNC_SERVER_FB_FORMAT == PIXMAN_FORMAT(32, PIXMAN_TYPE_ARGB, 0, 8, 8, 8)\n+    r = (((v & 0x00ff0000) >> 16) << vs->client_pf.rbits) >> 8;\n+    g = (((v & 0x0000ff00) >>  8) << vs->client_pf.gbits) >> 8;\n+    b = (((v & 0x000000ff) >>  0) << vs->client_pf.bbits) >> 8;\n+#else\n+# error need some bits here if you change VNC_SERVER_FB_FORMAT\n+#endif\n+    v = (r << vs->client_pf.rshift) |\n+        (g << vs->client_pf.gshift) |\n+        (b << vs->client_pf.bshift);\n+    switch (vs->client_pf.bytes_per_pixel) {\n     case 1:\n         buf[0] = v;\n         break;\n     case 2:\n-        if (vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) {\n+        if (vs->client_be) {\n             buf[0] = v >> 8;\n             buf[1] = v;\n         } else {\n@@ -621,7 +638,7 @@ void vnc_convert_pixel(VncState *vs, uint8_t *buf, uint32_t v)\n         break;\n     default:\n     case 4:\n-        if (vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) {\n+        if (vs->client_be) {\n             buf[0] = v >> 24;\n             buf[1] = v >> 16;\n             buf[2] = v >> 8;\n@@ -636,37 +653,37 @@ void vnc_convert_pixel(VncState *vs, uint8_t *buf, uint32_t v)\n     }\n }\n \n-static void vnc_write_pixels_generic(VncState *vs, struct PixelFormat *pf,\n+static void vnc_write_pixels_generic(VncState *vs,\n                                      void *pixels1, int size)\n {\n     uint8_t buf[4];\n \n-    if (pf->bytes_per_pixel == 4) {\n+    if (VNC_SERVER_FB_BYTES == 4) {\n         uint32_t *pixels = pixels1;\n         int n, i;\n         n = size >> 2;\n-        for(i = 0; i < n; i++) {\n+        for (i = 0; i < n; i++) {\n             vnc_convert_pixel(vs, buf, pixels[i]);\n-            vnc_write(vs, buf, vs->clientds.pf.bytes_per_pixel);\n+            vnc_write(vs, buf, vs->client_pf.bytes_per_pixel);\n         }\n-    } else if (pf->bytes_per_pixel == 2) {\n+    } else if (VNC_SERVER_FB_BYTES == 2) {\n         uint16_t *pixels = pixels1;\n         int n, i;\n         n = size >> 1;\n-        for(i = 0; i < n; i++) {\n+        for (i = 0; i < n; i++) {\n             vnc_convert_pixel(vs, buf, pixels[i]);\n-            vnc_write(vs, buf, vs->clientds.pf.bytes_per_pixel);\n+            vnc_write(vs, buf, vs->client_pf.bytes_per_pixel);\n         }\n-    } else if (pf->bytes_per_pixel == 1) {\n+    } else if (VNC_SERVER_FB_BYTES == 1) {\n         uint8_t *pixels = pixels1;\n         int n, i;\n         n = size;\n-        for(i = 0; i < n; i++) {\n+        for (i = 0; i < n; i++) {\n             vnc_convert_pixel(vs, buf, pixels[i]);\n-            vnc_write(vs, buf, vs->clientds.pf.bytes_per_pixel);\n+            vnc_write(vs, buf, vs->client_pf.bytes_per_pixel);\n         }\n     } else {\n-        fprintf(stderr, \"vnc_write_pixels_generic: VncState color depth not supported\\n\");\n+        fprintf(stderr, \"%s: VncState color depth not supported\\n\", __func__);\n     }\n }\n \n@@ -676,10 +693,10 @@ int vnc_raw_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n     uint8_t *row;\n     VncDisplay *vd = vs->vd;\n \n-    row = vd->server->data + y * ds_get_linesize(vs->ds) + x * ds_get_bytes_per_pixel(vs->ds);\n+    row = vnc_server_fb_ptr(vd, x, y);\n     for (i = 0; i < h; i++) {\n-        vs->write_pixels(vs, &vd->server->pf, row, w * ds_get_bytes_per_pixel(vs->ds));\n-        row += ds_get_linesize(vs->ds);\n+        vs->write_pixels(vs, row, w * VNC_SERVER_FB_BYTES);\n+        row += vnc_server_fb_stride(vd);\n     }\n     return 1;\n }\n@@ -736,7 +753,7 @@ static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int\n     VncState *vs, *vn;\n     uint8_t *src_row;\n     uint8_t *dst_row;\n-    int i,x,y,pitch,depth,inc,w_lim,s;\n+    int i, x, y, pitch, inc, w_lim, s;\n     int cmp_bytes;\n \n     vnc_refresh_server_surface(vd);\n@@ -749,10 +766,9 @@ static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int\n     }\n \n     \/* do bitblit op on the local surface too *\/\n-    pitch = ds_get_linesize(vd->ds);\n-    depth = ds_get_bytes_per_pixel(vd->ds);\n-    src_row = vd->server->data + pitch * src_y + depth * src_x;\n-    dst_row = vd->server->data + pitch * dst_y + depth * dst_x;\n+    pitch = vnc_server_fb_stride(vd);\n+    src_row = vnc_server_fb_ptr(vd, src_x, src_y);\n+    dst_row = vnc_server_fb_ptr(vd, dst_x, dst_y);\n     y = dst_y;\n     inc = 1;\n     if (dst_y > src_y) {\n@@ -780,7 +796,7 @@ static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int\n             } else {\n                 s = 16;\n             }\n-            cmp_bytes = s * depth;\n+            cmp_bytes = s * VNC_SERVER_FB_BYTES;\n             if (memcmp(src_row, dst_row, cmp_bytes) == 0)\n                 continue;\n             memmove(dst_row, src_row, cmp_bytes);\n@@ -790,8 +806,8 @@ static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int\n                 }\n             }\n         }\n-        src_row += pitch - w * depth;\n-        dst_row += pitch - w * depth;\n+        src_row += pitch - w * VNC_SERVER_FB_BYTES;\n+        dst_row += pitch - w * VNC_SERVER_FB_BYTES;\n         y += inc;\n     }\n \n@@ -810,7 +826,6 @@ static void vnc_mouse_set(DisplayState *ds, int x, int y, int visible)\n static int vnc_cursor_define(VncState *vs)\n {\n     QEMUCursor *c = vs->vd->cursor;\n-    PixelFormat pf = qemu_default_pixelformat(32);\n     int isize;\n \n     if (vnc_has_feature(vs, VNC_FEATURE_RICH_CURSOR)) {\n@@ -820,8 +835,8 @@ static int vnc_cursor_define(VncState *vs)\n         vnc_write_u16(vs, 1);  \/*  # of rects  *\/\n         vnc_framebuffer_update(vs, c->hot_x, c->hot_y, c->width, c->height,\n                                VNC_ENCODING_RICH_CURSOR);\n-        isize = c->width * c->height * vs->clientds.pf.bytes_per_pixel;\n-        vnc_write_pixels_generic(vs, &pf, c->data, isize);\n+        isize = c->width * c->height * vs->client_pf.bytes_per_pixel;\n+        vnc_write_pixels_generic(vs, c->data, isize);\n         vnc_write(vs, vs->vd->cursor_mask, vs->vd->cursor_msize);\n         vnc_unlock_output(vs);\n         return 0;\n@@ -898,8 +913,8 @@ static int vnc_update_client(VncState *vs, int has_dirty)\n          *\/\n         job = vnc_job_new(vs);\n \n-        width = MIN(vd->server->width, vs->client_width);\n-        height = MIN(vd->server->height, vs->client_height);\n+        width = MIN(pixman_image_get_width(vd->server), vs->client_width);\n+        height = MIN(pixman_image_get_height(vd->server), vs->client_height);\n \n         for (y = 0; y < height; y++) {\n             int x;\n@@ -1861,9 +1876,9 @@ static void set_encodings(VncState *vs, int32_t *encodings, size_t n_encodings)\n \n static void set_pixel_conversion(VncState *vs)\n {\n-    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n-        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG) && \n-        !memcmp(&(vs->clientds.pf), &(vs->ds->surface->pf), sizeof(PixelFormat))) {\n+    pixman_format_code_t fmt = qemu_pixman_get_format(&vs->client_pf);\n+\n+    if (fmt == VNC_SERVER_FB_FORMAT) {\n         vs->write_pixels = vnc_write_pixels_copy;\n         vnc_hextile_set_pixel_conversion(vs, 0);\n     } else {\n@@ -1883,23 +1898,22 @@ static void set_pixel_format(VncState *vs,\n         return;\n     }\n \n-    vs->clientds = *(vs->vd->guest.ds);\n-    vs->clientds.pf.rmax = red_max;\n-    vs->clientds.pf.rbits = hweight_long(red_max);\n-    vs->clientds.pf.rshift = red_shift;\n-    vs->clientds.pf.rmask = red_max << red_shift;\n-    vs->clientds.pf.gmax = green_max;\n-    vs->clientds.pf.gbits = hweight_long(green_max);\n-    vs->clientds.pf.gshift = green_shift;\n-    vs->clientds.pf.gmask = green_max << green_shift;\n-    vs->clientds.pf.bmax = blue_max;\n-    vs->clientds.pf.bbits = hweight_long(blue_max);\n-    vs->clientds.pf.bshift = blue_shift;\n-    vs->clientds.pf.bmask = blue_max << blue_shift;\n-    vs->clientds.pf.bits_per_pixel = bits_per_pixel;\n-    vs->clientds.pf.bytes_per_pixel = bits_per_pixel \/ 8;\n-    vs->clientds.pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n-    vs->clientds.flags = big_endian_flag ? QEMU_BIG_ENDIAN_FLAG : 0x00;\n+    vs->client_pf.rmax = red_max;\n+    vs->client_pf.rbits = hweight_long(red_max);\n+    vs->client_pf.rshift = red_shift;\n+    vs->client_pf.rmask = red_max << red_shift;\n+    vs->client_pf.gmax = green_max;\n+    vs->client_pf.gbits = hweight_long(green_max);\n+    vs->client_pf.gshift = green_shift;\n+    vs->client_pf.gmask = green_max << green_shift;\n+    vs->client_pf.bmax = blue_max;\n+    vs->client_pf.bbits = hweight_long(blue_max);\n+    vs->client_pf.bshift = blue_shift;\n+    vs->client_pf.bmask = blue_max << blue_shift;\n+    vs->client_pf.bits_per_pixel = bits_per_pixel;\n+    vs->client_pf.bytes_per_pixel = bits_per_pixel \/ 8;\n+    vs->client_pf.depth = bits_per_pixel == 32 ? 24 : bits_per_pixel;\n+    vs->client_be = big_endian_flag;\n \n     set_pixel_conversion(vs);\n \n@@ -1910,8 +1924,10 @@ static void set_pixel_format(VncState *vs,\n static void pixel_format_message (VncState *vs) {\n     char pad[3] = { 0, 0, 0 };\n \n-    vnc_write_u8(vs, vs->ds->surface->pf.bits_per_pixel); \/* bits-per-pixel *\/\n-    vnc_write_u8(vs, vs->ds->surface->pf.depth); \/* depth *\/\n+    vs->client_pf = qemu_default_pixelformat(32);\n+\n+    vnc_write_u8(vs, vs->client_pf.bits_per_pixel); \/* bits-per-pixel *\/\n+    vnc_write_u8(vs, vs->client_pf.depth); \/* depth *\/\n \n #ifdef HOST_WORDS_BIGENDIAN\n     vnc_write_u8(vs, 1);             \/* big-endian-flag *\/\n@@ -1919,27 +1935,25 @@ static void pixel_format_message (VncState *vs) {\n     vnc_write_u8(vs, 0);             \/* big-endian-flag *\/\n #endif\n     vnc_write_u8(vs, 1);             \/* true-color-flag *\/\n-    vnc_write_u16(vs, vs->ds->surface->pf.rmax);     \/* red-max *\/\n-    vnc_write_u16(vs, vs->ds->surface->pf.gmax);     \/* green-max *\/\n-    vnc_write_u16(vs, vs->ds->surface->pf.bmax);     \/* blue-max *\/\n-    vnc_write_u8(vs, vs->ds->surface->pf.rshift);    \/* red-shift *\/\n-    vnc_write_u8(vs, vs->ds->surface->pf.gshift);    \/* green-shift *\/\n-    vnc_write_u8(vs, vs->ds->surface->pf.bshift);    \/* blue-shift *\/\n+    vnc_write_u16(vs, vs->client_pf.rmax);     \/* red-max *\/\n+    vnc_write_u16(vs, vs->client_pf.gmax);     \/* green-max *\/\n+    vnc_write_u16(vs, vs->client_pf.bmax);     \/* blue-max *\/\n+    vnc_write_u8(vs, vs->client_pf.rshift);    \/* red-shift *\/\n+    vnc_write_u8(vs, vs->client_pf.gshift);    \/* green-shift *\/\n+    vnc_write_u8(vs, vs->client_pf.bshift);    \/* blue-shift *\/\n+    vnc_write(vs, pad, 3);           \/* padding *\/\n \n     vnc_hextile_set_pixel_conversion(vs, 0);\n-\n-    vs->clientds = *(vs->ds->surface);\n-    vs->clientds.flags &= ~QEMU_ALLOCATED_FLAG;\n     vs->write_pixels = vnc_write_pixels_copy;\n-\n-    vnc_write(vs, pad, 3);           \/* padding *\/\n }\n \n static void vnc_dpy_setdata(DisplayState *ds)\n {\n     VncDisplay *vd = ds->opaque;\n \n-    *(vd->guest.ds) = *(ds->surface);\n+    qemu_pixman_image_unref(vd->guest.fb);\n+    vd->guest.fb = pixman_image_ref(ds->surface->image);\n+    vd->guest.format = ds->surface->format;\n     vnc_dpy_update(ds, 0, 0, ds_get_width(ds), ds_get_height(ds));\n }\n \n@@ -2443,12 +2457,14 @@ static int vnc_refresh_lossy_rect(VncDisplay *vd, int x, int y)\n \n static int vnc_update_stats(VncDisplay *vd,  struct timeval * tv)\n {\n+    int width = pixman_image_get_width(vd->guest.fb);\n+    int height = pixman_image_get_height(vd->guest.fb);\n     int x, y;\n     struct timeval res;\n     int has_dirty = 0;\n \n-    for (y = 0; y < vd->guest.ds->height; y += VNC_STAT_RECT) {\n-        for (x = 0; x < vd->guest.ds->width; x += VNC_STAT_RECT) {\n+    for (y = 0; y < height; y += VNC_STAT_RECT) {\n+        for (x = 0; x < width; x += VNC_STAT_RECT) {\n             VncRectStat *rect = vnc_stat_rect(vd, x, y);\n \n             rect->updated = false;\n@@ -2462,8 +2478,8 @@ static int vnc_update_stats(VncDisplay *vd,  struct timeval * tv)\n     }\n     vd->guest.last_freq_check = *tv;\n \n-    for (y = 0; y < vd->guest.ds->height; y += VNC_STAT_RECT) {\n-        for (x = 0; x < vd->guest.ds->width; x += VNC_STAT_RECT) {\n+    for (y = 0; y < height; y += VNC_STAT_RECT) {\n+        for (x = 0; x < width; x += VNC_STAT_RECT) {\n             VncRectStat *rect= vnc_stat_rect(vd, x, y);\n             int count = ARRAY_SIZE(rect->times);\n             struct timeval min, max;\n@@ -2532,12 +2548,15 @@ static void vnc_rect_updated(VncDisplay *vd, int x, int y, struct timeval * tv)\n \n static int vnc_refresh_server_surface(VncDisplay *vd)\n {\n+    int width = pixman_image_get_width(vd->guest.fb);\n+    int height = pixman_image_get_height(vd->guest.fb);\n     int y;\n     uint8_t *guest_row;\n     uint8_t *server_row;\n     int cmp_bytes;\n     VncState *vs;\n     int has_dirty = 0;\n+    pixman_image_t *tmpbuf = NULL;\n \n     struct timeval tv = { 0, 0 };\n \n@@ -2551,22 +2570,31 @@ static int vnc_refresh_server_surface(VncDisplay *vd)\n      * Check and copy modified bits from guest to server surface.\n      * Update server dirty map.\n      *\/\n-    cmp_bytes = 16 * ds_get_bytes_per_pixel(vd->ds);\n-    if (cmp_bytes > vd->ds->surface->linesize) {\n-        cmp_bytes = vd->ds->surface->linesize;\n+    cmp_bytes = 64;\n+    if (cmp_bytes > vnc_server_fb_stride(vd)) {\n+        cmp_bytes = vnc_server_fb_stride(vd);\n+    }\n+    if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n+        int width = pixman_image_get_width(vd->server);\n+        tmpbuf = qemu_pixman_linebuf_create(VNC_SERVER_FB_FORMAT, width);\n     }\n-    guest_row  = vd->guest.ds->data;\n-    server_row = vd->server->data;\n-    for (y = 0; y < vd->guest.ds->height; y++) {\n+    guest_row = (uint8_t *)pixman_image_get_data(vd->guest.fb);\n+    server_row = (uint8_t *)pixman_image_get_data(vd->server);\n+    for (y = 0; y < height; y++) {\n         if (!bitmap_empty(vd->guest.dirty[y], VNC_DIRTY_BITS)) {\n             int x;\n             uint8_t *guest_ptr;\n             uint8_t *server_ptr;\n \n-            guest_ptr  = guest_row;\n+            if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n+                qemu_pixman_linebuf_fill(tmpbuf, vd->guest.fb, width, y);\n+                guest_ptr = (uint8_t *)pixman_image_get_data(tmpbuf);\n+            } else {\n+                guest_ptr = guest_row;\n+            }\n             server_ptr = server_row;\n \n-            for (x = 0; x + 15 < vd->guest.ds->width;\n+            for (x = 0; x + 15 < width;\n                     x += 16, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n                 if (!test_and_clear_bit((x \/ 16), vd->guest.dirty[y]))\n                     continue;\n@@ -2581,9 +2609,10 @@ static int vnc_refresh_server_surface(VncDisplay *vd)\n                 has_dirty++;\n             }\n         }\n-        guest_row  += ds_get_linesize(vd->ds);\n-        server_row += ds_get_linesize(vd->ds);\n+        guest_row  += pixman_image_get_stride(vd->guest.fb);\n+        server_row += pixman_image_get_stride(vd->server);\n     }\n+    qemu_pixman_image_unref(tmpbuf);\n     return has_dirty;\n }\n \ndiff --git a\/ui\/vnc.h b\/ui\/vnc.h\nindex 068c2fc..d003afb 100644\n--- a\/ui\/vnc.h\n+++ b\/ui\/vnc.h\n@@ -69,7 +69,7 @@ typedef struct VncRectEntry VncRectEntry;\n \n typedef int VncReadEvent(VncState *vs, uint8_t *data, size_t len);\n \n-typedef void VncWritePixels(VncState *vs, struct PixelFormat *pf, void *data, int size);\n+typedef void VncWritePixels(VncState *vs, void *data, int size);\n \n typedef void VncSendHextileTile(VncState *vs,\n                                 int x, int y, int w, int h,\n@@ -117,7 +117,8 @@ struct VncSurface\n     struct timeval last_freq_check;\n     DECLARE_BITMAP(dirty[VNC_MAX_HEIGHT], VNC_MAX_WIDTH \/ 16);\n     VncRectStat stats[VNC_STAT_ROWS][VNC_STAT_COLS];\n-    DisplaySurface *ds;\n+    pixman_image_t *fb;\n+    pixman_format_code_t format;\n };\n \n typedef enum VncShareMode {\n@@ -151,7 +152,7 @@ struct VncDisplay\n     uint8_t *cursor_mask;\n \n     struct VncSurface guest;   \/* guest visible surface (aka ds->surface) *\/\n-    DisplaySurface *server;  \/* vnc server surface *\/\n+    pixman_image_t *server;    \/* vnc server surface *\/\n \n     char *display;\n     char *password;\n@@ -275,7 +276,9 @@ struct VncState\n     Buffer input;\n     \/* current output mode information *\/\n     VncWritePixels *write_pixels;\n-    DisplaySurface clientds;\n+    PixelFormat client_pf;\n+    pixman_format_code_t client_format;\n+    bool client_be;\n \n     CaptureVoiceOut *audio_cap;\n     struct audsettings as;\n@@ -527,6 +530,14 @@ static inline uint32_t vnc_has_feature(VncState *vs, int feature) {\n void vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,\n                             int32_t encoding);\n \n+\/* server fb is in PIXMAN_x8r8g8b8 *\/\n+#define VNC_SERVER_FB_FORMAT PIXMAN_FORMAT(32, PIXMAN_TYPE_ARGB, 0, 8, 8, 8)\n+#define VNC_SERVER_FB_BITS   (PIXMAN_FORMAT_BPP(VNC_SERVER_FB_FORMAT))\n+#define VNC_SERVER_FB_BYTES  ((VNC_SERVER_FB_BITS+7)\/8)\n+\n+void *vnc_server_fb_ptr(VncDisplay *vd, int x, int y);\n+int vnc_server_fb_stride(VncDisplay *vd);\n+\n void vnc_convert_pixel(VncState *vs, uint8_t *buf, uint32_t v);\n double vnc_update_freq(VncState *vs, int x, int y, int w, int h);\n void vnc_sent_lossy_rect(VncState *vs, int x, int y, int w, int h);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10070","CWE_ID":"125","category":"security","commit_id":"b173a352397877775c51c9a0e9d59eb6ce24c455","commit_message":"From b173a352397877775c51c9a0e9d59eb6ce24c455 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sat, 20 Feb 2016 09:52:34 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/131\n\n---\n coders\/mat.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/coders\/mat.c b\/coders\/mat.c\nindex b81dc6880e..5091a98769 100644\n--- a\/coders\/mat.c\n+++ b\/coders\/mat.c\n@@ -936,6 +936,7 @@ RestoreMSCWarning\n   }\n       }\n     } while(z-- >= 2);\n+    quantum_info=DestroyQuantumInfo(quantum_info);\n ExitLoop:\n \n \n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-16533","CWE_ID":"125","category":"security","commit_id":"f043bfc98c193c284e2cd768fefabe18ac2fed9b","commit_message":"From f043bfc98c193c284e2cd768fefabe18ac2fed9b Mon Sep 17 00:00:00 2001\nFrom: Jaejoong Kim <climbbb.kim@gmail.com>\nDate: Thu, 28 Sep 2017 19:16:30 +0900\nSubject: [PATCH] HID: usbhid: fix out-of-bounds bug\n\nThe hid descriptor identifies the length and type of subordinate\ndescriptors for a device. If the received hid descriptor is smaller than\nthe size of the struct hid_descriptor, it is possible to cause\nout-of-bounds.\n\nIn addition, if bNumDescriptors of the hid descriptor have an incorrect\nvalue, this can also cause out-of-bounds while approaching hdesc->desc[n].\n\nSo check the size of hid descriptor and bNumDescriptors.\n\n\tBUG: KASAN: slab-out-of-bounds in usbhid_parse+0x9b1\/0xa20\n\tRead of size 1 at addr ffff88006c5f8edf by task kworker\/1:2\/1261\n\n\tCPU: 1 PID: 1261 Comm: kworker\/1:2 Not tainted\n\t4.14.0-rc1-42251-gebb2c2437d80 #169\n\tHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01\/01\/2011\n\tWorkqueue: usb_hub_wq hub_event\n\tCall Trace:\n\t__dump_stack lib\/dump_stack.c:16\n\tdump_stack+0x292\/0x395 lib\/dump_stack.c:52\n\tprint_address_description+0x78\/0x280 mm\/kasan\/report.c:252\n\tkasan_report_error mm\/kasan\/report.c:351\n\tkasan_report+0x22f\/0x340 mm\/kasan\/report.c:409\n\t__asan_report_load1_noabort+0x19\/0x20 mm\/kasan\/report.c:427\n\tusbhid_parse+0x9b1\/0xa20 drivers\/hid\/usbhid\/hid-core.c:1004\n\thid_add_device+0x16b\/0xb30 drivers\/hid\/hid-core.c:2944\n\tusbhid_probe+0xc28\/0x1100 drivers\/hid\/usbhid\/hid-core.c:1369\n\tusb_probe_interface+0x35d\/0x8e0 drivers\/usb\/core\/driver.c:361\n\treally_probe drivers\/base\/dd.c:413\n\tdriver_probe_device+0x610\/0xa00 drivers\/base\/dd.c:557\n\t__device_attach_driver+0x230\/0x290 drivers\/base\/dd.c:653\n\tbus_for_each_drv+0x161\/0x210 drivers\/base\/bus.c:463\n\t__device_attach+0x26e\/0x3d0 drivers\/base\/dd.c:710\n\tdevice_initial_probe+0x1f\/0x30 drivers\/base\/dd.c:757\n\tbus_probe_device+0x1eb\/0x290 drivers\/base\/bus.c:523\n\tdevice_add+0xd0b\/0x1660 drivers\/base\/core.c:1835\n\tusb_set_configuration+0x104e\/0x1870 drivers\/usb\/core\/message.c:1932\n\tgeneric_probe+0x73\/0xe0 drivers\/usb\/core\/generic.c:174\n\tusb_probe_device+0xaf\/0xe0 drivers\/usb\/core\/driver.c:266\n\treally_probe drivers\/base\/dd.c:413\n\tdriver_probe_device+0x610\/0xa00 drivers\/base\/dd.c:557\n\t__device_attach_driver+0x230\/0x290 drivers\/base\/dd.c:653\n\tbus_for_each_drv+0x161\/0x210 drivers\/base\/bus.c:463\n\t__device_attach+0x26e\/0x3d0 drivers\/base\/dd.c:710\n\tdevice_initial_probe+0x1f\/0x30 drivers\/base\/dd.c:757\n\tbus_probe_device+0x1eb\/0x290 drivers\/base\/bus.c:523\n\tdevice_add+0xd0b\/0x1660 drivers\/base\/core.c:1835\n\tusb_new_device+0x7b8\/0x1020 drivers\/usb\/core\/hub.c:2457\n\thub_port_connect drivers\/usb\/core\/hub.c:4903\n\thub_port_connect_change drivers\/usb\/core\/hub.c:5009\n\tport_event drivers\/usb\/core\/hub.c:5115\n\thub_event+0x194d\/0x3740 drivers\/usb\/core\/hub.c:5195\n\tprocess_one_work+0xc7f\/0x1db0 kernel\/workqueue.c:2119\n\tworker_thread+0x221\/0x1850 kernel\/workqueue.c:2253\n\tkthread+0x3a1\/0x470 kernel\/kthread.c:231\n\tret_from_fork+0x2a\/0x40 arch\/x86\/entry\/entry_64.S:431\n\nCc: stable@vger.kernel.org\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: Jaejoong Kim <climbbb.kim@gmail.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nAcked-by: Alan Stern <stern@rowland.harvard.edu>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>\n---\n drivers\/hid\/usbhid\/hid-core.c | 12 +++++++++++-\n 1 file changed, 11 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/hid\/usbhid\/hid-core.c b\/drivers\/hid\/usbhid\/hid-core.c\nindex 089bad8a9a21d6..045b5da9b99287 100644\n--- a\/drivers\/hid\/usbhid\/hid-core.c\n+++ b\/drivers\/hid\/usbhid\/hid-core.c\n@@ -975,6 +975,8 @@ static int usbhid_parse(struct hid_device *hid)\n \tunsigned int rsize = 0;\n \tchar *rdesc;\n \tint ret, n;\n+\tint num_descriptors;\n+\tsize_t offset = offsetof(struct hid_descriptor, desc);\n \n \tquirks = usbhid_lookup_quirk(le16_to_cpu(dev->descriptor.idVendor),\n \t\t\tle16_to_cpu(dev->descriptor.idProduct));\n@@ -997,10 +999,18 @@ static int usbhid_parse(struct hid_device *hid)\n \t\treturn -ENODEV;\n \t}\n \n+\tif (hdesc->bLength < sizeof(struct hid_descriptor)) {\n+\t\tdbg_hid(\"hid descriptor is too short\\n\");\n+\t\treturn -EINVAL;\n+\t}\n+\n \thid->version = le16_to_cpu(hdesc->bcdHID);\n \thid->country = hdesc->bCountryCode;\n \n-\tfor (n = 0; n < hdesc->bNumDescriptors; n++)\n+\tnum_descriptors = min_t(int, hdesc->bNumDescriptors,\n+\t       (hdesc->bLength - offset) \/ sizeof(struct hid_class_descriptor));\n+\n+\tfor (n = 0; n < num_descriptors; n++)\n \t\tif (hdesc->desc[n].bDescriptorType == HID_DT_REPORT)\n \t\t\trsize = le16_to_cpu(hdesc->desc[n].wDescriptorLength);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-1839","CWE_ID":"125","category":"security","commit_id":"a820dbeac29d330bae4be05d9ecd939ad6b4aa33","commit_message":"From a820dbeac29d330bae4be05d9ecd939ad6b4aa33 Mon Sep 17 00:00:00 2001\nFrom: Pranjal Jumde <pjumde@apple.com>\nDate: Tue, 1 Mar 2016 11:34:04 -0800\nSubject: [PATCH] Bug 758605: Heap-based buffer overread in xmlDictAddString\n <https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=758605>\n\nReviewed by David Kilzer.\n\n* HTMLparser.c:\n(htmlParseName): Add bounds check.\n(htmlParseNameComplex): Ditto.\n* result\/HTML\/758605.html: Added.\n* result\/HTML\/758605.html.err: Added.\n* result\/HTML\/758605.html.sax: Added.\n* runtest.c:\n(pushParseTest): The input for the new test case was so small\n(4 bytes) that htmlParseChunk() was never called after\nhtmlCreatePushParserCtxt(), thereby creating a false positive\ntest failure.  Fixed by using a do-while loop so we always call\nhtmlParseChunk() at least once.\n* test\/HTML\/758605.html: Added.\n---\n HTMLparser.c                |  8 ++++++++\n result\/HTML\/758605.html     |  3 +++\n result\/HTML\/758605.html.err |  3 +++\n result\/HTML\/758605.html.sax | 13 +++++++++++++\n runtest.c                   |  4 ++--\n test\/HTML\/758605.html       |  1 +\n 6 files changed, 30 insertions(+), 2 deletions(-)\n create mode 100644 result\/HTML\/758605.html\n create mode 100644 result\/HTML\/758605.html.err\n create mode 100644 result\/HTML\/758605.html.sax\n create mode 100644 test\/HTML\/758605.html\n\n","diff_code":"diff --git a\/HTMLparser.c b\/HTMLparser.c\nindex 69eed2bd..1c112cc9 100644\n--- a\/HTMLparser.c\n+++ b\/HTMLparser.c\n@@ -2471,6 +2471,10 @@ htmlParseName(htmlParserCtxtPtr ctxt) {\n \t       (*in == '_') || (*in == '-') ||\n \t       (*in == ':') || (*in == '.'))\n \t    in++;\n+\n+\tif (in == ctxt->input->end)\n+\t    return(NULL);\n+\n \tif ((*in > 0) && (*in < 0x80)) {\n \t    count = in - ctxt->input->cur;\n \t    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n@@ -2514,6 +2518,10 @@ htmlParseNameComplex(xmlParserCtxtPtr ctxt) {\n \tNEXTL(l);\n \tc = CUR_CHAR(l);\n     }\n+\n+    if (ctxt->input->base > ctxt->input->cur - len)\n+\treturn(NULL);\n+\n     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));\n }\n \ndiff --git a\/result\/HTML\/758605.html b\/result\/HTML\/758605.html\nnew file mode 100644\nindex 00000000..a085cce3\n--- \/dev\/null\n+++ b\/result\/HTML\/758605.html\n@@ -0,0 +1,3 @@\n+<!DOCTYPE html PUBLIC \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\" \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\">\n+<html><body><p>&amp;\n+<\/p><\/body><\/html>\ndiff --git a\/result\/HTML\/758605.html.err b\/result\/HTML\/758605.html.err\nnew file mode 100644\nindex 00000000..2b82be66\n--- \/dev\/null\n+++ b\/result\/HTML\/758605.html.err\n@@ -0,0 +1,3 @@\n+.\/test\/HTML\/758605.html:1: HTML parser error : htmlParseEntityRef: no name\n+\u00ea\n+  ^\ndiff --git a\/result\/HTML\/758605.html.sax b\/result\/HTML\/758605.html.sax\nnew file mode 100644\nindex 00000000..1f5cd320\n--- \/dev\/null\n+++ b\/result\/HTML\/758605.html.sax\n@@ -0,0 +1,13 @@\n+SAX.setDocumentLocator()\n+SAX.startDocument()\n+SAX.error: htmlParseEntityRef: no name\n+SAX.startElement(html)\n+SAX.startElement(body)\n+SAX.startElement(p)\n+SAX.characters(&amp;, 1)\n+SAX.ignorableWhitespace(\n+, 1)\n+SAX.endElement(p)\n+SAX.endElement(body)\n+SAX.endElement(html)\n+SAX.endDocument()\ndiff --git a\/runtest.c b\/runtest.c\nindex 36fbe5ac..bb74d2a8 100644\n--- a\/runtest.c\n+++ b\/runtest.c\n@@ -1873,7 +1873,7 @@ pushParseTest(const char *filename, const char *result,\n     ctxt = xmlCreatePushParserCtxt(NULL, NULL, base + cur, 4, filename);\n     xmlCtxtUseOptions(ctxt, options);\n     cur += 4;\n-    while (cur < size) {\n+    do {\n         if (cur + 1024 >= size) {\n #ifdef LIBXML_HTML_ENABLED\n \t    if (options & XML_PARSE_HTML)\n@@ -1891,7 +1891,7 @@ pushParseTest(const char *filename, const char *result,\n \t    xmlParseChunk(ctxt, base + cur, 1024, 0);\n \t    cur += 1024;\n \t}\n-    }\n+    } while (cur < size);\n     doc = ctxt->myDoc;\n #ifdef LIBXML_HTML_ENABLED\n     if (options & XML_PARSE_HTML)\ndiff --git a\/test\/HTML\/758605.html b\/test\/HTML\/758605.html\nnew file mode 100644\nindex 00000000..9b1b3c24\n--- \/dev\/null\n+++ b\/test\/HTML\/758605.html\n@@ -0,0 +1 @@\n+&:\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-5093","CWE_ID":"125","category":"security","commit_id":"97eff7eb57fc2320c267a949cffd622c38712484","commit_message":"From 97eff7eb57fc2320c267a949cffd622c38712484 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 22 May 2016 17:49:02 -0700\nSubject: [PATCH] Fix bug #72241: get_icu_value_internal out-of-bounds read\n\n---\n ext\/intl\/locale\/locale_methods.c | 235 ++++++++++++++++---------------\n ext\/intl\/tests\/bug72241.phpt     |  14 ++\n 2 files changed, 132 insertions(+), 117 deletions(-)\n create mode 100644 ext\/intl\/tests\/bug72241.phpt\n\n","diff_code":"diff --git a\/ext\/intl\/locale\/locale_methods.c b\/ext\/intl\/locale\/locale_methods.c\nindex c8159bcd5ade..31f60b39a41b 100644\n--- a\/ext\/intl\/locale\/locale_methods.c\n+++ b\/ext\/intl\/locale\/locale_methods.c\n@@ -65,26 +65,26 @@ ZEND_EXTERN_MODULE_GLOBALS( intl )\n *\/\n static const char * const LOC_GRANDFATHERED[] = {\n \t\"art-lojban\",\t\t\"i-klingon\",\t\t\"i-lux\",\t\t\t\"i-navajo\",\t\t\"no-bok\",\t\t\"no-nyn\",\n-\t\"cel-gaulish\",\t\t\"en-GB-oed\",\t\t\"i-ami\", \t\t\n-\t\"i-bnn\",\t\t\"i-default\",\t\t\"i-enochian\",\t\n-\t\"i-mingo\",\t\t\"i-pwn\", \t\t\"i-tao\", \n+\t\"cel-gaulish\",\t\t\"en-GB-oed\",\t\t\"i-ami\",\n+\t\"i-bnn\",\t\t\"i-default\",\t\t\"i-enochian\",\n+\t\"i-mingo\",\t\t\"i-pwn\", \t\t\"i-tao\",\n \t\"i-tay\",\t\t\"i-tsu\",\t\t\"sgn-BE-fr\",\n \t\"sgn-BE-nl\",\t\t\"sgn-CH-de\", \t\t\"zh-cmn\",\n  \t\"zh-cmn-Hans\", \t\t\"zh-cmn-Hant\",\t\t\"zh-gan\" ,\n \t\"zh-guoyu\", \t\t\"zh-hakka\", \t\t\"zh-min\",\n-\t\"zh-min-nan\", \t\t\"zh-wuu\", \t\t\"zh-xiang\",\t\n+\t\"zh-min-nan\", \t\t\"zh-wuu\", \t\t\"zh-xiang\",\n \t\"zh-yue\",\t\tNULL\n };\n \n \/* Based on IANA registry at the time of writing this code\n *  This array lists the preferred values for the grandfathered tags if applicable\n-*  This is in sync with the array LOC_GRANDFATHERED\t \n+*  This is in sync with the array LOC_GRANDFATHERED\n *  e.g. the offsets of the grandfathered tags match the offset of the preferred  value\n *\/\n static const int \t\tLOC_PREFERRED_GRANDFATHERED_LEN = 6;\n static const char * const \tLOC_PREFERRED_GRANDFATHERED[]  = {\n \t\"jbo\",\t\t\t\"tlh\",\t\t\t\"lb\",\n-\t\"nv\", \t\t\t\"nb\",\t\t\t\"nn\",\t\t\t\n+\t\"nv\", \t\t\t\"nb\",\t\t\t\"nn\",\n \tNULL\n };\n \n@@ -122,7 +122,7 @@ static int16_t findOffset(const char* const* list, const char* key)\n \/*}}}*\/\n \n static char* getPreferredTag(const char* gf_tag)\n-{ \n+{\n \tchar* result = NULL;\n \tint grOffset = 0;\n \n@@ -141,15 +141,15 @@ static char* getPreferredTag(const char* gf_tag)\n }\n \n \/* {{{\n-* returns the position of next token for lookup \n+* returns the position of next token for lookup\n * or -1 if no token\n-* strtokr equivalent search for token in reverse direction \n+* strtokr equivalent search for token in reverse direction\n *\/\n static int getStrrtokenPos(char* str, int savedPos)\n {\n \tint result =-1;\n \tint i;\n-\t\n+\n \tfor(i=savedPos-1; i>=0; i--) {\n \t\tif(isIDSeparator(*(str+i)) ){\n \t\t\t\/* delimiter found; check for singleton *\/\n@@ -171,7 +171,7 @@ static int getStrrtokenPos(char* str, int savedPos)\n \/* }}} *\/\n \n \/* {{{\n-* returns the position of a singleton if present \n+* returns the position of a singleton if present\n * returns -1 if no singleton\n * strtok equivalent search for singleton\n *\/\n@@ -180,7 +180,7 @@ static int getSingletonPos(const char* str)\n \tint result =-1;\n \tint i=0;\n \tint len = 0;\n-\t\n+\n \tif( str && ((len=strlen(str))>0) ){\n \t\tfor( i=0; i<len ; i++){\n \t\t\tif( isIDSeparator(*(str+i)) ){\n@@ -198,7 +198,7 @@ static int getSingletonPos(const char* str)\n \t\t\t\t}\n \t\t\t}\n \t\t}\/* end of for *\/\n-\t\t\n+\n \t}\n \treturn result;\n }\n@@ -224,7 +224,7 @@ PHP_NAMED_FUNCTION(zif_locale_get_default)\n PHP_NAMED_FUNCTION(zif_locale_set_default)\n {\n \tchar* locale_name = NULL;\n-\tint   len=0;\t\n+\tint   len=0;\n \n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n \t\t&locale_name ,&len ) == FAILURE)\n@@ -240,14 +240,14 @@ PHP_NAMED_FUNCTION(zif_locale_set_default)\n \t\tlen = strlen(locale_name);\n \t}\n \n-\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n+\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n \n \tRETURN_TRUE;\n }\n \/* }}} *\/\n \n \/* {{{\n-* Gets the value from ICU \n+* Gets the value from ICU\n * common code shared by get_primary_language,get_script or get_region or get_variant\n * result = 0 if error, 1 if successful , -1 if no value\n *\/\n@@ -284,7 +284,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t\t\t}\n \t\t}\n \n-\t\tsingletonPos = getSingletonPos( loc_name );\t\n+\t\tsingletonPos = getSingletonPos( loc_name );\n \t\tif( singletonPos == 0){\n \t\t\t\/* singleton at start of script, region , variant etc.\n \t\t\t * or invalid singleton at start of language *\/\n@@ -299,7 +299,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t} \/* end of if != LOC_CANONICAL_TAG *\/\n \n \tif( mod_loc_name == NULL){\n-\t\tmod_loc_name = estrdup(loc_name );\t\n+\t\tmod_loc_name = estrdup(loc_name );\n \t}\n \n \t\/* Proceed to ICU *\/\n@@ -326,6 +326,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n \t\tif( U_FAILURE( status ) ) {\n \t\t\tif( status == U_BUFFER_OVERFLOW_ERROR ) {\n \t\t\t\tstatus = U_ZERO_ERROR;\n+\t\t\t\tbuflen++; \/* add space for \\0 *\/\n \t\t\t\tcontinue;\n \t\t\t}\n \n@@ -366,7 +367,7 @@ static char* get_icu_value_internal( const char* loc_name , char* tag_name, int*\n * Gets the value from ICU , called when PHP userspace function is called\n * common code shared by get_primary_language,get_script or get_region or get_variant\n *\/\n-static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n+static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n {\n \n \tconst char* loc_name        \t= NULL;\n@@ -422,37 +423,37 @@ static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n }\n \/* }}} *\/\n \n-\/* {{{ proto static string Locale::getScript($locale) \n- * gets the script for the $locale \n+\/* {{{ proto static string Locale::getScript($locale)\n+ * gets the script for the $locale\n  }}} *\/\n-\/* {{{ proto static string locale_get_script($locale) \n- * gets the script for the $locale \n+\/* {{{ proto static string locale_get_script($locale)\n+ * gets the script for the $locale\n  *\/\n-PHP_FUNCTION( locale_get_script ) \n+PHP_FUNCTION( locale_get_script )\n {\n \tget_icu_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n \/* }}} *\/\n \n-\/* {{{ proto static string Locale::getRegion($locale) \n- * gets the region for the $locale \n+\/* {{{ proto static string Locale::getRegion($locale)\n+ * gets the region for the $locale\n  }}} *\/\n-\/* {{{ proto static string locale_get_region($locale) \n- * gets the region for the $locale \n+\/* {{{ proto static string locale_get_region($locale)\n+ * gets the region for the $locale\n  *\/\n-PHP_FUNCTION( locale_get_region ) \n+PHP_FUNCTION( locale_get_region )\n {\n \tget_icu_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n \/* }}} *\/\n \n-\/* {{{ proto static string Locale::getPrimaryLanguage($locale) \n- * gets the primary language for the $locale \n+\/* {{{ proto static string Locale::getPrimaryLanguage($locale)\n+ * gets the primary language for the $locale\n  }}} *\/\n-\/* {{{ proto static string locale_get_primary_language($locale) \n- * gets the primary language for the $locale \n+\/* {{{ proto static string locale_get_primary_language($locale)\n+ * gets the primary language for the $locale\n  *\/\n-PHP_FUNCTION(locale_get_primary_language ) \n+PHP_FUNCTION(locale_get_primary_language )\n {\n \tget_icu_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -460,9 +461,9 @@ PHP_FUNCTION(locale_get_primary_language )\n \n \n \/* {{{\n- * common code shared by display_xyz functions to  get the value from ICU \n+ * common code shared by display_xyz functions to  get the value from ICU\n  }}} *\/\n-static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n+static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS)\n {\n \tconst char* loc_name        \t= NULL;\n \tint         loc_name_len    \t= 0;\n@@ -488,7 +489,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n \tintl_error_reset( NULL TSRMLS_CC );\n \n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s|s\",\n-\t\t&loc_name, &loc_name_len , \n+\t\t&loc_name, &loc_name_len ,\n \t\t&disp_loc_name ,&disp_loc_name_len ) == FAILURE)\n \t{\n \t\tspprintf(&msg , 0, \"locale_get_display_%s : unable to parse input params\", tag_name );\n@@ -525,7 +526,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n \tif( mod_loc_name==NULL ){\n \t\tmod_loc_name = estrdup( loc_name );\n \t}\n-\t\n+\n \t\/* Check if disp_loc_name passed , if not use default locale *\/\n \tif( !disp_loc_name){\n \t\tdisp_loc_name = estrdup(intl_locale_get_default(TSRMLS_C));\n@@ -604,7 +605,7 @@ static void get_icu_disp_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAME\n \/* {{{ proto static string get_display_name($locale[, $in_locale = null])\n * gets the name for the $locale in $in_locale or default_locale\n *\/\n-PHP_FUNCTION(locale_get_display_name) \n+PHP_FUNCTION(locale_get_display_name)\n {\n     get_icu_disp_value_src_php( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -616,7 +617,7 @@ PHP_FUNCTION(locale_get_display_name)\n \/* {{{ proto static string get_display_language($locale[, $in_locale = null])\n * gets the language for the $locale in $in_locale or default_locale\n *\/\n-PHP_FUNCTION(locale_get_display_language) \n+PHP_FUNCTION(locale_get_display_language)\n {\n     get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -628,7 +629,7 @@ PHP_FUNCTION(locale_get_display_language)\n \/* {{{ proto static string get_display_script($locale, $in_locale = null)\n * gets the script for the $locale in $in_locale or default_locale\n *\/\n-PHP_FUNCTION(locale_get_display_script) \n+PHP_FUNCTION(locale_get_display_script)\n {\n     get_icu_disp_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -640,7 +641,7 @@ PHP_FUNCTION(locale_get_display_script)\n \/* {{{ proto static string get_display_region($locale, $in_locale = null)\n * gets the region for the $locale in $in_locale or default_locale\n *\/\n-PHP_FUNCTION(locale_get_display_region) \n+PHP_FUNCTION(locale_get_display_region)\n {\n     get_icu_disp_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -654,7 +655,7 @@ PHP_FUNCTION(locale_get_display_region)\n * proto static string get_display_variant($locale, $in_locale = null)\n * gets the variant for the $locale in $in_locale or default_locale\n *\/\n-PHP_FUNCTION(locale_get_display_variant) \n+PHP_FUNCTION(locale_get_display_variant)\n {\n     get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n }\n@@ -667,7 +668,7 @@ PHP_FUNCTION(locale_get_display_variant)\n  \/* {{{ proto static array locale_get_keywords(string $locale) {\n  * return an associative array containing keyword-value\n  * pairs for this locale. The keys are keys to the array (doh!)\n- *\/ \n+ *\/\n PHP_FUNCTION( locale_get_keywords )\n {\n     UEnumeration*   e        = NULL;\n@@ -679,10 +680,10 @@ PHP_FUNCTION( locale_get_keywords )\n     const char*       \tloc_name        = NULL;\n     int        \t \tloc_name_len    = 0;\n \n-\/* \n-\tICU expects the buffer to be allocated  before calling the function \n-\tand so the buffer size has been explicitly specified \n-\tICU uloc.h #define \tULOC_KEYWORD_AND_VALUES_CAPACITY   100 \n+\/*\n+\tICU expects the buffer to be allocated  before calling the function\n+\tand so the buffer size has been explicitly specified\n+\tICU uloc.h #define \tULOC_KEYWORD_AND_VALUES_CAPACITY   100\n \thence the kw_value buffer size is 100\n *\/\n \tchar*\t \tkw_value        = NULL;\n@@ -721,7 +722,7 @@ PHP_FUNCTION( locale_get_keywords )\n \t\t\t\tkw_value_len=uloc_getKeywordValue( loc_name,kw_key, kw_value, kw_value_len+1 ,  &status );\n \t\t\t} else if(!U_FAILURE(status)) {\n \t\t\t\tkw_value = erealloc( kw_value , kw_value_len+1);\n-\t\t\t} \n+\t\t\t}\n \t\t\tif (U_FAILURE(status)) {\n \t        \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"locale_get_keywords: Error encountered while getting the keyword  value for the  keyword\", 0 TSRMLS_CC );\n \t\t\t\tif( kw_value){\n@@ -740,10 +741,10 @@ PHP_FUNCTION( locale_get_keywords )\n }\n \/* }}} *\/\n \n- \/* {{{ proto static string Locale::canonicalize($locale) \n- * @return string the canonicalized locale \n+ \/* {{{ proto static string Locale::canonicalize($locale)\n+ * @return string the canonicalized locale\n  * }}} *\/\n- \/* {{{ proto static string locale_canonicalize(Locale $loc, string $locale) \n+ \/* {{{ proto static string locale_canonicalize(Locale $loc, string $locale)\n  * @param string $locale\tThe locale string to canonicalize\n  *\/\n PHP_FUNCTION(locale_canonicalize)\n@@ -752,10 +753,10 @@ PHP_FUNCTION(locale_canonicalize)\n }\n \/* }}} *\/\n \n-\/* {{{ append_key_value \n+\/* {{{ append_key_value\n * Internal function which is called from locale_compose\n * gets the value for the key_name and appends to the loc_name\n-* returns 1 if successful , -1 if not found , \n+* returns 1 if successful , -1 if not found ,\n * 0 if array element is not a string , -2 if buffer-overflow\n *\/\n static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n@@ -767,7 +768,7 @@ static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_\n \t\t\t\/* element value is not a string *\/\n \t\t\treturn FAILURE;\n \t\t}\n-\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n+\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 &&\n \t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n \t\t\t\/* not lang or grandfathered tag *\/\n \t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n@@ -792,11 +793,11 @@ static void add_prefix(smart_str* loc_name, char* key_name)\n }\n \/* }}} *\/\n \n-\/* {{{ append_multiple_key_values \n+\/* {{{ append_multiple_key_values\n * Internal function which is called from locale_compose\n * gets the multiple values for the key_name and appends to the loc_name\n-* used for 'variant','extlang','private' \n-* returns 1 if successful , -1 if not found , \n+* used for 'variant','extlang','private'\n+* returns 1 if successful , -1 if not found ,\n * 0 if array element is not a string , -2 if buffer-overflow\n *\/\n static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr, char* key_name TSRMLS_DC)\n@@ -850,8 +851,8 @@ static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr,\n \n \t\t\/* Multiple variant values as variant0, variant1 ,variant2 *\/\n \t\tisFirstSubtag = 0;\n-\t\tfor( i=0 ; i< max_value; i++ ){  \n-\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\t\n+\t\tfor( i=0 ; i< max_value; i++ ){\n+\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\n \t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n \t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n \t\t\t\t\t\/* variant is not a string *\/\n@@ -873,7 +874,7 @@ static int append_multiple_key_values(smart_str* loc_name, HashTable* hash_arr,\n \n \/*{{{\n * If applicable sets error message and aborts locale_compose gracefully\n-* returns 0  if locale_compose needs to be aborted \n+* returns 0  if locale_compose needs to be aborted\n * otherwise returns 1\n *\/\n static int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)\n@@ -890,11 +891,11 @@ static int handleAppendResult( int result, smart_str* loc_name TSRMLS_DC)\n \/* }}} *\/\n \n #define RETURN_SMART_STR(s) smart_str_0((s)); RETURN_STRINGL((s)->c, (s)->len, 0)\n-\/* {{{ proto static string Locale::composeLocale($array) \n-* Creates a locale by combining the parts of locale-ID passed\t\n+\/* {{{ proto static string Locale::composeLocale($array)\n+* Creates a locale by combining the parts of locale-ID passed\n * }}} *\/\n-\/* {{{ proto static string compose_locale($array) \n-* Creates a locale by combining the parts of locale-ID passed\t\n+\/* {{{ proto static string compose_locale($array)\n+* Creates a locale by combining the parts of locale-ID passed\n * }}} *\/\n PHP_FUNCTION(locale_compose)\n {\n@@ -920,7 +921,7 @@ PHP_FUNCTION(locale_compose)\n \t\tRETURN_FALSE;\n \n \t\/* Check for grandfathered first *\/\n-\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\t\n+\tresult = append_key_value(loc_name, hash_arr,  LOC_GRANDFATHERED_LANG_TAG);\n \tif( result == SUCCESS){\n \t\tRETURN_SMART_STR(loc_name);\n \t}\n@@ -929,7 +930,7 @@ PHP_FUNCTION(locale_compose)\n \t}\n \n \t\/* Not grandfathered *\/\n-\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\t\n+\tresult = append_key_value(loc_name, hash_arr , LOC_LANG_TAG);\n \tif( result == LOC_NOT_FOUND ){\n \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n \t\t\"locale_compose: parameter array does not contain 'language' tag.\", 0 TSRMLS_CC );\n@@ -947,11 +948,11 @@ PHP_FUNCTION(locale_compose)\n \t}\n \n \t\/* Script *\/\n-\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG); \n+\tresult = append_key_value(loc_name, hash_arr , LOC_SCRIPT_TAG);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n \t\/* Region *\/\n \tresult = append_key_value( loc_name, hash_arr , LOC_REGION_TAG);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n@@ -959,7 +960,7 @@ PHP_FUNCTION(locale_compose)\n \t}\n \n \t\/* Variant *\/\n-\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC); \n+\tresult = append_multiple_key_values( loc_name, hash_arr , LOC_VARIANT_TAG TSRMLS_CC);\n \tif( !handleAppendResult( result, loc_name TSRMLS_CC)){\n \t\tRETURN_FALSE;\n \t}\n@@ -985,16 +986,16 @@ static char* get_private_subtags(const char* loc_name)\n {\n \tchar* \tresult =NULL;\n \tint \tsingletonPos = 0;\n-\tint \tlen =0; \n+\tint \tlen =0;\n \tconst char* \tmod_loc_name =NULL;\n \n \tif( loc_name && (len = strlen(loc_name)>0 ) ){\n-\t\tmod_loc_name = loc_name ; \n+\t\tmod_loc_name = loc_name ;\n \t\tlen   = strlen(mod_loc_name);\n \t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n \n-\t\t\tif( singletonPos!=-1){ \n-\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t\n+\t\t\tif( singletonPos!=-1){\n+\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\n \t\t\t\t\t\/* private subtag start found *\/\n \t\t\t\t\tif( singletonPos + 2 ==  len){\n \t\t\t\t\t\t\/* loc_name ends with '-x-' ; return  NULL *\/\n@@ -1019,7 +1020,7 @@ static char* get_private_subtags(const char* loc_name)\n \n \t\t} \/* end of while *\/\n \t}\n-\t\n+\n \treturn result;\n }\n \/* }}} *\/\n@@ -1044,20 +1045,20 @@ static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name\n \t} else {\n \t\tkey_value = get_icu_value_internal( loc_name , key_name , &result,1 );\n \t}\n-\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || \n+\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) ||\n \t\t( strcmp(key_name , LOC_VARIANT_TAG)==0) ){\n \t\tif( result > 0 && key_value){\n \t\t\t\/* Tokenize on the \"_\" or \"-\"  *\/\n-\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\t\n+\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\n \t\t\tif( cur_key_name ){\n \t\t\t\tefree( cur_key_name);\n \t\t\t}\n \t\t\tcur_key_name = (char*)ecalloc( 25,  25);\n-\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n+\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\n \t\t\tadd_assoc_string( hash_arr, cur_key_name , token ,TRUE );\n \t\t\t\/* tokenize on the \"_\" or \"-\" and stop  at singleton if any *\/\n \t\t\twhile( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){\n-\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n+\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\n \t\t\t\tadd_assoc_string( hash_arr, cur_key_name , token , TRUE );\n \t\t\t}\n \/*\n@@ -1077,16 +1078,16 @@ static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name\n \t}\n \t\/*if( key_name != LOC_PRIVATE_TAG && key_value){*\/\n \tif( key_value){\n-\t\tefree(key_value);\t\n+\t\tefree(key_value);\n \t}\n \treturn cur_result;\n }\n \/* }}} *\/\n \n-\/* {{{ proto static array Locale::parseLocale($locale) \n+\/* {{{ proto static array Locale::parseLocale($locale)\n * parses a locale-id into an array the different parts of it\n  }}} *\/\n-\/* {{{ proto static array parse_locale($locale) \n+\/* {{{ proto static array parse_locale($locale)\n * parses a locale-id into an array the different parts of it\n *\/\n PHP_FUNCTION(locale_parse)\n@@ -1144,7 +1145,7 @@ PHP_FUNCTION(locale_get_all_variants)\n \tchar*\tsaved_ptr\t= NULL;\n \n \tintl_error_reset( NULL TSRMLS_CC );\n-\t\n+\n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n \t&loc_name, &loc_name_len ) == FAILURE)\n \t{\n@@ -1162,15 +1163,15 @@ PHP_FUNCTION(locale_get_all_variants)\n \tarray_init( return_value );\n \n \t\/* If the locale is grandfathered, stop, no variants *\/\n-\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){ \n+\tif( findOffset( LOC_GRANDFATHERED , loc_name ) >=  0 ){\n \t\t\/* (\"Grandfathered Tag. No variants.\"); *\/\n \t}\n-\telse {\t\n+\telse {\n \t\/* Call ICU variant *\/\n \t\tvariant = get_icu_value_internal( loc_name , LOC_VARIANT_TAG , &result ,0);\n \t\tif( result > 0 && variant){\n \t\t\t\/* Tokenize on the \"_\" or \"-\" *\/\n-\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\t\n+\t\t\ttoken = php_strtok_r( variant , DELIMITER , &saved_ptr);\n \t\t\tadd_next_index_stringl( return_value, token , strlen(token) ,TRUE );\n \t\t\t\/* tokenize on the \"_\" or \"-\" and stop  at singleton if any\t*\/\n \t\t\twhile( (token = php_strtok_r(NULL , DELIMITER, &saved_ptr)) && (strlen(token)>1) ){\n@@ -1181,7 +1182,7 @@ PHP_FUNCTION(locale_get_all_variants)\n \t\t\tefree( variant );\n \t\t}\n \t}\n-\t\t\t\n+\n \n }\n \/* }}} *\/\n@@ -1220,11 +1221,11 @@ static int strToMatch(const char* str ,char *retstr)\n \/* }}} *\/\n \n \/* {{{ proto static boolean Locale::filterMatches(string $langtag, string $locale[, bool $canonicalize])\n-* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm \n+* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm\n *\/\n \/* }}} *\/\n \/* {{{ proto boolean locale_filter_matches(string $langtag, string $locale[, bool $canonicalize])\n-* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm \n+* Checks if a $langtag filter matches with $locale according to RFC 4647's basic filtering algorithm\n *\/\n PHP_FUNCTION(locale_filter_matches)\n {\n@@ -1243,13 +1244,13 @@ PHP_FUNCTION(locale_filter_matches)\n \tchar*       \tcur_lang_tag    = NULL;\n \tchar*       \tcur_loc_range   = NULL;\n \n-\tzend_bool \tboolCanonical \t= 0;\t\n+\tzend_bool \tboolCanonical \t= 0;\n \tUErrorCode\tstatus\t\t= U_ZERO_ERROR;\n \n \tintl_error_reset( NULL TSRMLS_CC );\n-\t\n+\n \tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"ss|b\",\n-\t\t&lang_tag, &lang_tag_len , &loc_range , &loc_range_len , \n+\t\t&lang_tag, &lang_tag_len , &loc_range , &loc_range_len ,\n \t\t&boolCanonical) == FAILURE)\n \t{\n \t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n@@ -1270,7 +1271,7 @@ PHP_FUNCTION(locale_filter_matches)\n \t\t\/* canonicalize loc_range *\/\n \t\tcan_loc_range=get_icu_value_internal( loc_range , LOC_CANONICALIZE_TAG , &result , 0);\n \t\tif( result ==0) {\n-\t\t\tintl_error_set( NULL, status, \n+\t\t\tintl_error_set( NULL, status,\n \t\t\t\t\"locale_filter_matches : unable to canonicalize loc_range\" , 0 TSRMLS_CC );\n \t\t\tRETURN_FALSE;\n \t\t}\n@@ -1278,7 +1279,7 @@ PHP_FUNCTION(locale_filter_matches)\n \t\t\/* canonicalize lang_tag *\/\n \t\tcan_lang_tag = get_icu_value_internal( lang_tag , LOC_CANONICALIZE_TAG , &result ,  0);\n \t\tif( result ==0) {\n-\t\t\tintl_error_set( NULL, status, \n+\t\t\tintl_error_set( NULL, status,\n \t\t\t\t\"locale_filter_matches : unable to canonicalize lang_tag\" , 0 TSRMLS_CC );\n \t\t\tRETURN_FALSE;\n \t\t}\n@@ -1306,11 +1307,11 @@ PHP_FUNCTION(locale_filter_matches)\n \n \t\t\/* check if prefix *\/\n \t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n-\t\n+\n \t\tif( token && (token==cur_lang_tag) ){\n \t\t\t\/* check if the char. after match is SEPARATOR *\/\n \t\t\tchrcheck = token + (strlen(cur_loc_range));\n-\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){ \n+\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n \t\t\t\tif( cur_lang_tag){\n \t\t\t\t\tefree( cur_lang_tag );\n \t\t\t\t}\n@@ -1346,7 +1347,7 @@ PHP_FUNCTION(locale_filter_matches)\n \telse{\n \t\t\/* Convert to lower case for case-insensitive comparison *\/\n \t\tcur_lang_tag = ecalloc( 1, strlen(lang_tag ) + 1);\n-\t\t\n+\n \t\tresult = strToMatch( lang_tag , cur_lang_tag);\n \t\tif( result == 0) {\n \t\t\tefree( cur_lang_tag );\n@@ -1362,11 +1363,11 @@ PHP_FUNCTION(locale_filter_matches)\n \n \t\t\/* check if prefix *\/\n \t\ttoken \t= strstr( cur_lang_tag , cur_loc_range );\n-\t\t\n+\n \t\tif( token && (token==cur_lang_tag) ){\n \t\t\t\/* check if the char. after match is SEPARATOR *\/\n \t\t\tchrcheck = token + (strlen(cur_loc_range));\n-\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){ \n+\t\t\tif( isIDSeparator(*chrcheck) || isEndOfTag(*chrcheck) ){\n \t\t\t\tif( cur_lang_tag){\n \t\t\t\t\tefree( cur_lang_tag );\n \t\t\t\t}\n@@ -1393,7 +1394,7 @@ PHP_FUNCTION(locale_filter_matches)\n static void array_cleanup( char* arr[] , int arr_size)\n {\n \tint i=0;\n-\tfor( i=0; i< arr_size; i++ ){ \n+\tfor( i=0; i< arr_size; i++ ){\n \t\tif( arr[i*2] ){\n \t\t\tefree( arr[i*2]);\n \t\t}\n@@ -1403,7 +1404,7 @@ static void array_cleanup( char* arr[] , int arr_size)\n \n #define LOOKUP_CLEAN_RETURN(value)\tarray_cleanup(cur_arr, cur_arr_len); return (value)\n \/* {{{\n-* returns the lookup result to lookup_loc_range_src_php \n+* returns the lookup result to lookup_loc_range_src_php\n * internal function\n *\/\n static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int canonicalize  TSRMLS_DC)\n@@ -1427,7 +1428,7 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \tfor(zend_hash_internal_pointer_reset(hash_arr);\n \t\tzend_hash_has_more_elements(hash_arr) == SUCCESS;\n \t\tzend_hash_move_forward(hash_arr)) {\n-\t\t\n+\n \t\tif (zend_hash_get_current_data(hash_arr, (void**)&ele_value) == FAILURE) {\n \t\t\t\/* Should never actually fail since the key is known to exist.*\/\n \t\t\tcontinue;\n@@ -1436,7 +1437,7 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t\t\/* element value is not a string *\/\n \t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: locale array element is not a string\", 0 TSRMLS_CC);\n \t\t\tLOOKUP_CLEAN_RETURN(NULL);\n-\t\t} \n+\t\t}\n \t\tcur_arr[cur_arr_len*2] = estrndup(Z_STRVAL_PP(ele_value), Z_STRLEN_PP(ele_value));\n \t\tresult = strToMatch(Z_STRVAL_PP(ele_value), cur_arr[cur_arr_len*2]);\n \t\tif(result == 0) {\n@@ -1444,12 +1445,12 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t\tLOOKUP_CLEAN_RETURN(NULL);\n \t\t}\n \t\tcur_arr[cur_arr_len*2+1] = Z_STRVAL_PP(ele_value);\n-\t\tcur_arr_len++ ; \n+\t\tcur_arr_len++ ;\n \t} \/* end of for *\/\n \n \t\/* Canonicalize array elements *\/\n \tif(canonicalize) {\n-\t\tfor(i=0; i<cur_arr_len; i++) { \n+\t\tfor(i=0; i<cur_arr_len; i++) {\n \t\t\tlang_tag = get_icu_value_internal(cur_arr[i*2], LOC_CANONICALIZE_TAG, &result, 0);\n \t\t\tif(result != 1 || lang_tag == NULL || !lang_tag[0]) {\n \t\t\t\tif(lang_tag) {\n@@ -1459,7 +1460,7 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t\t\tLOOKUP_CLEAN_RETURN(NULL);\n \t\t\t}\n \t\t\tcur_arr[i*2] = erealloc(cur_arr[i*2], strlen(lang_tag)+1);\n-\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\t\n+\t\t\tresult = strToMatch(lang_tag, cur_arr[i*2]);\n \t\t\tefree(lang_tag);\n \t\t\tif(result == 0) {\n \t\t\t\tintl_error_set(NULL, U_ILLEGAL_ARGUMENT_ERROR, \"lookup_loc_range: unable to canonicalize lang_tag\" , 0 TSRMLS_CC);\n@@ -1482,11 +1483,11 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\t} else {\n \t\t\tloc_range = can_loc_range;\n \t\t}\n-\t} \n+\t}\n \n \tcur_loc_range = ecalloc(1, strlen(loc_range)+1);\n \t\/* convert to lower and replace hyphens *\/\n-\tresult = strToMatch(loc_range, cur_loc_range);\t\n+\tresult = strToMatch(loc_range, cur_loc_range);\n \tif(can_loc_range) {\n \t\tefree(can_loc_range);\n \t}\n@@ -1498,8 +1499,8 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n \t\/* Lookup for the lang_tag match *\/\n \tsaved_pos = strlen(cur_loc_range);\n \twhile(saved_pos > 0) {\n-\t\tfor(i=0; i< cur_arr_len; i++){ \n-\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\t\n+\t\tfor(i=0; i< cur_arr_len; i++){\n+\t\t\tif(cur_arr[i*2] != NULL && strlen(cur_arr[i*2]) == saved_pos && strncmp(cur_loc_range, cur_arr[i*2], saved_pos) == 0) {\n \t\t\t\t\/* Match found *\/\n \t\t\t\treturn_value = estrdup(canonicalize?cur_arr[i*2]:cur_arr[i*2+1]);\n \t\t\t\tefree(cur_loc_range);\n@@ -1515,14 +1516,14 @@ static char* lookup_loc_range(const char* loc_range, HashTable* hash_arr, int ca\n }\n \/* }}} *\/\n \n-\/* {{{ proto string Locale::lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]]) \n+\/* {{{ proto string Locale::lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]])\n * Searchs the items in $langtag for the best match to the language\n-* range \n+* range\n *\/\n \/* }}} *\/\n \/* {{{ proto string locale_lookup(array $langtag, string $locale[, bool $canonicalize[, string $default = null]])\n * Searchs the items in $langtag for the best match to the language\n-* range \n+* range\n *\/\n PHP_FUNCTION(locale_lookup)\n {\n@@ -1552,8 +1553,8 @@ PHP_FUNCTION(locale_lookup)\n \n \tif( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 ) {\n \t\tRETURN_EMPTY_STRING();\n-\t} \n-\t\n+\t}\n+\n \tresult = lookup_loc_range(loc_range, hash_arr, boolCanonical TSRMLS_CC);\n \tif(result == NULL || result[0] == '\\0') {\n \t\tif( fallback_loc ) {\n@@ -1590,10 +1591,10 @@ PHP_FUNCTION(locale_accept_from_http)\n \t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n \tavailable = ures_openAvailableLocales(NULL, &status);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n-\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN, \n+\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,\n \t\t\t\t\t\t&outResult, http_accept, available, &status);\n \tuenum_close(available);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");\ndiff --git a\/ext\/intl\/tests\/bug72241.phpt b\/ext\/intl\/tests\/bug72241.phpt\nnew file mode 100644\nindex 000000000000..397e1e7834b1\n--- \/dev\/null\n+++ b\/ext\/intl\/tests\/bug72241.phpt\n@@ -0,0 +1,14 @@\n+--TEST--\n+Bug #72241: get_icu_value_internal out-of-bounds read\n+--SKIPIF--\n+<?php if( !extension_loaded( 'intl' ) ) print 'skip'; ?>\n+--FILE--\n+<?php\n+$var1=str_repeat(\"A\", 1000);\n+$out = locale_get_primary_language($var1);\n+echo strlen($out) . PHP_EOL;\n+echo unpack('H*', $out)[1] . PHP_EOL;\n+--EXPECT--\n+1000\n+61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161\n+\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2017-15931","CWE_ID":"125","category":"security","commit_id":"c6d0076c924891ad9948a62d89d0bcdaf965f0cd","commit_message":"From c6d0076c924891ad9948a62d89d0bcdaf965f0cd Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Wed, 25 Oct 2017 18:00:11 +0200\nSubject: [PATCH] Fix #8731 - Crash in ELF parser with negative 32bit number\n\n---\n libr\/bin\/format\/elf\/elf.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libr\/bin\/format\/elf\/elf.c b\/libr\/bin\/format\/elf\/elf.c\nindex 90f6acd301..e3c852fd33 100644\n--- a\/libr\/bin\/format\/elf\/elf.c\n+++ b\/libr\/bin\/format\/elf\/elf.c\n@@ -900,7 +900,11 @@ static Sdb *store_versioninfo_gnu_verneed(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\t\tfree (s);\n \t\t}\n \t\tsdb_num_set (sdb_version, \"cnt\", entry->vn_cnt, 0);\n-\t\tvstart += entry->vn_aux;\n+\t\tst32 vnaux = entry->vn_aux;\n+\t\tif (vnaux < 1) {\n+\t\t\tgoto beach;\n+\t\t}\n+\t\tvstart += vnaux;\n \t\tfor (j = 0, isum = i + entry->vn_aux; j < entry->vn_cnt && vstart + sizeof (Elf_(Vernaux)) <= end; ++j) {\n \t\t\tint k;\n \t\t\tElf_(Vernaux) * aux = NULL;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2017-14166","CWE_ID":"125","category":"security","commit_id":"fa7438a0ff4033e4741c807394a9af6207940d71","commit_message":"From fa7438a0ff4033e4741c807394a9af6207940d71 Mon Sep 17 00:00:00 2001\nFrom: Joerg Sonnenberger <joerg@bec.de>\nDate: Tue, 5 Sep 2017 18:12:19 +0200\nSubject: [PATCH] Do something sensible for empty strings to make fuzzers\n happy.\n\n---\n libarchive\/archive_read_support_format_xar.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libarchive\/archive_read_support_format_xar.c b\/libarchive\/archive_read_support_format_xar.c\nindex 7a22beb9d..93eeacc5e 100644\n--- a\/libarchive\/archive_read_support_format_xar.c\n+++ b\/libarchive\/archive_read_support_format_xar.c\n@@ -1040,6 +1040,9 @@ atol10(const char *p, size_t char_cnt)\n \tuint64_t l;\n \tint digit;\n \n+\tif (char_cnt == 0)\n+\t\treturn (0);\n+\n \tl = 0;\n \tdigit = *p - '0';\n \twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {\n@@ -1054,7 +1057,10 @@ atol8(const char *p, size_t char_cnt)\n {\n \tint64_t l;\n \tint digit;\n-        \n+\n+\tif (char_cnt == 0)\n+\t\treturn (0);\n+\n \tl = 0;\n \twhile (char_cnt-- > 0) {\n \t\tif (*p >= '0' && *p <= '7')\n","owner":"libarchive","repo":"libarchive","source":"cve"},{"CVE_ID":"CVE-2018-20679","CWE_ID":"125","category":"security","commit_id":"6d3b4bb24da9a07c263f3c1acf8df85382ff562c","commit_message":"From 6d3b4bb24da9a07c263f3c1acf8df85382ff562c Mon Sep 17 00:00:00 2001\nFrom: Denys Vlasenko <vda.linux@googlemail.com>\nDate: Mon, 17 Dec 2018 18:07:18 +0100\nSubject: udhcpc: check that 4-byte options are indeed 4-byte, closes 11506\n\nfunction                                             old     new   delta\nudhcp_get_option32                                     -      27     +27\nudhcp_get_option                                     231     248     +17\n------------------------------------------------------------------------------\n(add\/remove: 1\/0 grow\/shrink: 1\/0 up\/down: 44\/0)               Total: 44 bytes\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>\n---\n networking\/udhcp\/common.c | 19 +++++++++++++++++++\n networking\/udhcp\/common.h |  4 ++++\n networking\/udhcp\/dhcpc.c  |  6 +++---\n networking\/udhcp\/dhcpd.c  |  6 +++---\n 4 files changed, 29 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/networking\/udhcp\/common.c b\/networking\/udhcp\/common.c\nindex e5fd74f91..41b05b855 100644\n--- a\/networking\/udhcp\/common.c\n+++ b\/networking\/udhcp\/common.c\n@@ -272,6 +272,15 @@ uint8_t* FAST_FUNC udhcp_get_option(struct dhcp_packet *packet, int code)\n \t\t\tgoto complain; \/* complain and return NULL *\/\n \n \t\tif (optionptr[OPT_CODE] == code) {\n+\t\t\tif (optionptr[OPT_LEN] == 0) {\n+\t\t\t\t\/* So far no valid option with length 0 known.\n+\t\t\t\t * Having this check means that searching\n+\t\t\t\t * for DHCP_MESSAGE_TYPE need not worry\n+\t\t\t\t * that returned pointer might be unsafe\n+\t\t\t\t * to dereference.\n+\t\t\t\t *\/\n+\t\t\t\tgoto complain; \/* complain and return NULL *\/\n+\t\t\t}\n \t\t\tlog_option(\"option found\", optionptr);\n \t\t\treturn optionptr + OPT_DATA;\n \t\t}\n@@ -289,6 +298,16 @@ uint8_t* FAST_FUNC udhcp_get_option(struct dhcp_packet *packet, int code)\n \treturn NULL;\n }\n \n+uint8_t* FAST_FUNC udhcp_get_option32(struct dhcp_packet *packet, int code)\n+{\n+\tuint8_t *r = udhcp_get_option(packet, code);\n+\tif (r) {\n+\t\tif (r[-1] != 4)\n+\t\t\tr = NULL;\n+\t}\n+\treturn r;\n+}\n+\n \/* Return the position of the 'end' option (no bounds checking) *\/\n int FAST_FUNC udhcp_end_option(uint8_t *optionptr)\n {\ndiff --git a\/networking\/udhcp\/common.h b\/networking\/udhcp\/common.h\nindex 7ad603d33..9511152ff 100644\n--- a\/networking\/udhcp\/common.h\n+++ b\/networking\/udhcp\/common.h\n@@ -205,6 +205,10 @@ extern const uint8_t dhcp_option_lengths[] ALIGN1;\n unsigned FAST_FUNC udhcp_option_idx(const char *name, const char *option_strings);\n \n uint8_t *udhcp_get_option(struct dhcp_packet *packet, int code) FAST_FUNC;\n+\/* Same as above + ensures that option length is 4 bytes\n+ * (returns NULL if size is different)\n+ *\/\n+uint8_t *udhcp_get_option32(struct dhcp_packet *packet, int code) FAST_FUNC;\n int udhcp_end_option(uint8_t *optionptr) FAST_FUNC;\n void udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt) FAST_FUNC;\n #if ENABLE_UDHCPC || ENABLE_UDHCPD\ndiff --git a\/networking\/udhcp\/dhcpc.c b\/networking\/udhcp\/dhcpc.c\nindex 4b23e4d39..5b3fd531c 100644\n--- a\/networking\/udhcp\/dhcpc.c\n+++ b\/networking\/udhcp\/dhcpc.c\n@@ -1691,7 +1691,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)\n  * They say ISC DHCP client supports this case.\n  *\/\n \t\t\t\tserver_addr = 0;\n-\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_SERVER_ID);\n+\t\t\t\ttemp = udhcp_get_option32(&packet, DHCP_SERVER_ID);\n \t\t\t\tif (!temp) {\n \t\t\t\t\tbb_error_msg(\"no server ID, using 0.0.0.0\");\n \t\t\t\t} else {\n@@ -1718,7 +1718,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)\n \t\t\t\tstruct in_addr temp_addr;\n \t\t\t\tuint8_t *temp;\n \n-\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_LEASE_TIME);\n+\t\t\t\ttemp = udhcp_get_option32(&packet, DHCP_LEASE_TIME);\n \t\t\t\tif (!temp) {\n \t\t\t\t\tbb_error_msg(\"no lease time with ACK, using 1 hour lease\");\n \t\t\t\t\tlease_seconds = 60 * 60;\n@@ -1813,7 +1813,7 @@ int udhcpc_main(int argc UNUSED_PARAM, char **argv)\n \t\t\t\t\tuint32_t svid;\n \t\t\t\t\tuint8_t *temp;\n \n-\t\t\t\t\ttemp = udhcp_get_option(&packet, DHCP_SERVER_ID);\n+\t\t\t\t\ttemp = udhcp_get_option32(&packet, DHCP_SERVER_ID);\n \t\t\t\t\tif (!temp) {\n  non_matching_svid:\n \t\t\t\t\t\tlog1(\"received DHCP NAK with wrong\"\ndiff --git a\/networking\/udhcp\/dhcpd.c b\/networking\/udhcp\/dhcpd.c\nindex a8cd3f03b..477856d11 100644\n--- a\/networking\/udhcp\/dhcpd.c\n+++ b\/networking\/udhcp\/dhcpd.c\n@@ -640,7 +640,7 @@ static void add_server_options(struct dhcp_packet *packet)\n static uint32_t select_lease_time(struct dhcp_packet *packet)\n {\n \tuint32_t lease_time_sec = server_config.max_lease_sec;\n-\tuint8_t *lease_time_opt = udhcp_get_option(packet, DHCP_LEASE_TIME);\n+\tuint8_t *lease_time_opt = udhcp_get_option32(packet, DHCP_LEASE_TIME);\n \tif (lease_time_opt) {\n \t\tmove_from_unaligned32(lease_time_sec, lease_time_opt);\n \t\tlease_time_sec = ntohl(lease_time_sec);\n@@ -987,7 +987,7 @@ int udhcpd_main(int argc UNUSED_PARAM, char **argv)\n \t\t}\n \n \t\t\/* Get SERVER_ID if present *\/\n-\t\tserver_id_opt = udhcp_get_option(&packet, DHCP_SERVER_ID);\n+\t\tserver_id_opt = udhcp_get_option32(&packet, DHCP_SERVER_ID);\n \t\tif (server_id_opt) {\n \t\t\tuint32_t server_id_network_order;\n \t\t\tmove_from_unaligned32(server_id_network_order, server_id_opt);\n@@ -1011,7 +1011,7 @@ int udhcpd_main(int argc UNUSED_PARAM, char **argv)\n \t\t}\n \n \t\t\/* Get REQUESTED_IP if present *\/\n-\t\trequested_ip_opt = udhcp_get_option(&packet, DHCP_REQUESTED_IP);\n+\t\trequested_ip_opt = udhcp_get_option32(&packet, DHCP_REQUESTED_IP);\n \t\tif (requested_ip_opt) {\n \t\t\tmove_from_unaligned32(requested_nip, requested_ip_opt);\n \t\t}\n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6387","CWE_ID":"125","category":"security","commit_id":"ead645853a63bf83d8386702cad0cf23b31d7eeb","commit_message":"From ead645853a63bf83d8386702cad0cf23b31d7eeb Mon Sep 17 00:00:00 2001\nFrom: h4ng3r <h4ng3r@users.noreply.github.com>\nDate: Mon, 27 Feb 2017 23:55:33 +0100\nSubject: [PATCH] fix #6857\n\n---\n libr\/bin\/p\/bin_dex.c | 2 +-\n sys\/asan.sh          | 4 ++--\n 2 files changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libr\/bin\/p\/bin_dex.c b\/libr\/bin\/p\/bin_dex.c\nindex 74b6df706b..be0c0d320d 100644\n--- a\/libr\/bin\/p\/bin_dex.c\n+++ b\/libr\/bin\/p\/bin_dex.c\n@@ -1496,7 +1496,7 @@ static int dex_loadcode(RBinFile *arch, RBinDexObj *bin) {\n \t\t\t\tcontinue;\n \t\t\t}\n \n-\t\t\tif (bin->methods[i].class_id > bin->header.types_size - 1) {\n+\t\t\tif (bin->methods[i].class_id > bin->header.types_size) {\n \t\t\t\tcontinue;\n \t\t\t}\n \ndiff --git a\/sys\/asan.sh b\/sys\/asan.sh\nindex 3773f1abf8..0772fd5760 100755\n--- a\/sys\/asan.sh\n+++ b\/sys\/asan.sh\n@@ -22,12 +22,12 @@ printf \"\\033[32m\"\n echo \"=========================================================================\"\n printf \"\\033[0m\"\n sleep 1\n-export LDFLAGS=\"-lasan\"\n+#export LDFLAGS=\"-lasan\"\n \n for a in $ASAN ; do\n \texport CFLAGS=\"${CFLAGS} -fsanitize=$a\"\n done\n-export CFLAGS=\"${CFLAGS} -lasan\"\n+#export CFLAGS=\"${CFLAGS} -lasan\"\n \n echo 'int main(){return 0;}' > .a.c\n [ -z \"${CC}\" ] && CC=gcc\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2016-7514","CWE_ID":"125","category":"security","commit_id":"198fffab4daf8aea88badd9c629350e5b26ec32f","commit_message":"From 198fffab4daf8aea88badd9c629350e5b26ec32f Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Fri, 15 Jan 2016 11:17:30 +0100\nSubject: [PATCH] Added check for bit depth 1.\n\n---\n coders\/psd.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex 5a5c633807..976d9076fb 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -1908,6 +1908,8 @@ static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           image->alpha_trait=UndefinedPixelTrait;\n         }\n     }\n+  if ((image->depth == 1) && (image->storage_class != PseudoClass))\n+    ThrowReaderException(CorruptImageError, \"ImproperImageHeader\");\n   has_merged_image=MagickTrue;\n   length=ReadBlobMSBLong(image);\n   if (length != 0)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-3178","CWE_ID":"125","category":"security","commit_id":"b238cade9a173c6f751a34acf8ccff838a62aa47","commit_message":"From b238cade9a173c6f751a34acf8ccff838a62aa47 Mon Sep 17 00:00:00 2001\nFrom: Thomas Bernard <miniupnp@free.fr>\nDate: Tue, 1 Mar 2016 19:14:15 +0100\nSubject: [PATCH] minissdpd: Fix broken overflow test (p+l > buf+n) thanks to\n Salva Piero\n\n---\n minissdpd\/Changelog.txt   |  5 ++++-\n minissdpd\/minissdpd.c     | 10 +++++-----\n minissdpd\/testminissdpd.c | 12 +++++++++++-\n 3 files changed, 20 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/minissdpd\/Changelog.txt b\/minissdpd\/Changelog.txt\nindex c4d5e395..e66f0523 100644\n--- a\/minissdpd\/Changelog.txt\n+++ b\/minissdpd\/Changelog.txt\n@@ -1,4 +1,7 @@\n-$Id: Changelog.txt,v 1.43 2015\/08\/06 14:05:49 nanard Exp $\n+$Id: Changelog.txt,v 1.45 2016\/03\/01 18:06:46 nanard Exp $\n+\n+2016\/03\/01:\n+\tFix broken overflow test (p+l > buf+n) thanks to Salva Piero\n \n VERSION 1.5:\n \ndiff --git a\/minissdpd\/minissdpd.c b\/minissdpd\/minissdpd.c\nindex 51f82730..df304cdc 100644\n--- a\/minissdpd\/minissdpd.c\n+++ b\/minissdpd\/minissdpd.c\n@@ -1,4 +1,4 @@\n-\/* $Id: minissdpd.c,v 1.50 2015\/08\/06 14:05:49 nanard Exp $ *\/\n+\/* $Id: minissdpd.c,v 1.53 2016\/03\/01 18:06:46 nanard Exp $ *\/\n \/* vim: tabstop=4 shiftwidth=4 noexpandtab\n  * MiniUPnP project\n  * (c) 2007-2016 Thomas Bernard\n@@ -847,7 +847,7 @@ void processRequest(struct reqelem * req)\n \ttype = buf[0];\n \tp = buf + 1;\n \tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n-\tif(p+l > buf+n) {\n+\tif(l > (unsigned)(buf+n-p)) {\n \t\tsyslog(LOG_WARNING, \"bad request (length encoding l=%u n=%u)\",\n \t\t       l, (unsigned)n);\n \t\tgoto error;\n@@ -969,7 +969,7 @@ void processRequest(struct reqelem * req)\n \t\t\tgoto error;\n \t\t}\n \t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n-\t\tif(p+l > buf+n) {\n+\t\tif(l > (unsigned)(buf+n-p)) {\n \t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n \t\t\tgoto error;\n \t\t}\n@@ -987,7 +987,7 @@ void processRequest(struct reqelem * req)\n \t\tnewserv->usn[l] = '\\0';\n \t\tp += l;\n \t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n-\t\tif(p+l > buf+n) {\n+\t\tif(l > (unsigned)(buf+n-p)) {\n \t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n \t\t\tgoto error;\n \t\t}\n@@ -1005,7 +1005,7 @@ void processRequest(struct reqelem * req)\n \t\tnewserv->server[l] = '\\0';\n \t\tp += l;\n \t\tDECODELENGTH_CHECKLIMIT(l, p, buf + n);\n-\t\tif(p+l > buf+n) {\n+\t\tif(l > (unsigned)(buf+n-p)) {\n \t\t\tsyslog(LOG_WARNING, \"bad request (length encoding)\");\n \t\t\tgoto error;\n \t\t}\ndiff --git a\/minissdpd\/testminissdpd.c b\/minissdpd\/testminissdpd.c\nindex a8452729..0f9bf0ae 100644\n--- a\/minissdpd\/testminissdpd.c\n+++ b\/minissdpd\/testminissdpd.c\n@@ -1,4 +1,4 @@\n-\/* $Id: testminissdpd.c,v 1.12 2015\/08\/06 13:16:59 nanard Exp $ *\/\n+\/* $Id: testminissdpd.c,v 1.14 2016\/03\/01 17:49:51 nanard Exp $ *\/\n \/* Project : miniupnp\n  * website : http:\/\/miniupnp.free.fr\/ or http:\/\/miniupnp.tuxfamily.org\/\n  * Author : Thomas BERNARD\n@@ -65,6 +65,7 @@ main(int argc, char * * argv)\n \tconst char bad_command[] = { 0xff, 0xff };\n \tconst char overflow[] = { 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n \tconst char command5[] = { 0x05, 0x00 };\n+\tconst char bad_command4[] = { 0x04, 0x01, 0x60, 0x8f, 0xff, 0xff, 0xff, 0x7f};\n \tint s;\n \tint i;\n \tvoid * tmp;\n@@ -180,6 +181,15 @@ main(int argc, char * * argv)\n \tn = read(s, buf, sizeof(buf));\n \tprintf(\"Response received %d bytes\\n\", (int)n);\n \tprintresponse(buf, n);\n+\tif(n == 0) {\n+\t\tclose(s);\n+\t\ts = connect_unix_socket(sockpath);\n+\t}\n+\n+\tn = SENDCOMMAND(bad_command4, sizeof(bad_command4));\n+\tn = read(s, buf, sizeof(buf));\n+\tprintf(\"Response received %d bytes\\n\", (int)n);\n+\tprintresponse(buf, n);\n \n \tclose(s);\n \treturn 0;\n","owner":"miniupnp","repo":"miniupnp","source":"cve"},{"CVE_ID":"CVE-2016-3183","CWE_ID":"125","category":"security","commit_id":"15f081c89650dccee4aa4ae66f614c3fdb268767","commit_message":"From 15f081c89650dccee4aa4ae66f614c3fdb268767 Mon Sep 17 00:00:00 2001\nFrom: Matthieu Darbois <mayeut@users.noreply.github.com>\nDate: Sat, 30 Apr 2016 00:33:27 +0200\nSubject: [PATCH] Fix Out-Of-Bounds Read in sycc42x_to_rgb function (#745)\n\n42x Images with an odd x0\/y0 lead to subsampled component starting at the\n2nd column\/line.\nThat is offset = comp->dx * comp->x0 - image->x0 = 1\n\nFix #726\n---\n src\/bin\/common\/color.c   | 148 +++++++++++++++++++++++----------------\n src\/bin\/jp2\/convertbmp.c |   2 +-\n 2 files changed, 87 insertions(+), 63 deletions(-)\n\n","diff_code":"diff --git a\/src\/bin\/common\/color.c b\/src\/bin\/common\/color.c\nindex 00eac5150..20aba2ba1 100644\n--- a\/src\/bin\/common\/color.c\n+++ b\/src\/bin\/common\/color.c\n@@ -91,22 +91,22 @@ static void sycc444_to_rgb(opj_image_t *img)\n {\n \tint *d0, *d1, *d2, *r, *g, *b;\n \tconst int *y, *cb, *cr;\n-\tunsigned int maxw, maxh, max, i;\n+\tsize_t maxw, maxh, max, i;\n \tint offset, upb;\n \n \tupb = (int)img->comps[0].prec;\n \toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n \n-\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n+\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n \tmax = maxw * maxh;\n \n \ty = img->comps[0].data;\n \tcb = img->comps[1].data;\n \tcr = img->comps[2].data;\n \n-\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n-\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n-\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n+\td0 = r = (int*)malloc(sizeof(int) * max);\n+\td1 = g = (int*)malloc(sizeof(int) * max);\n+\td2 = b = (int*)malloc(sizeof(int) * max);\n \n \tif(r == NULL || g == NULL || b == NULL) goto fails;\n \n@@ -118,107 +118,138 @@ static void sycc444_to_rgb(opj_image_t *img)\n \tfree(img->comps[0].data); img->comps[0].data = d0;\n \tfree(img->comps[1].data); img->comps[1].data = d1;\n \tfree(img->comps[2].data); img->comps[2].data = d2;\n+\timg->color_space = OPJ_CLRSPC_SRGB;\n \treturn;\n \n fails:\n-\tif(r) free(r);\n-\tif(g) free(g);\n-\tif(b) free(b);\n-\n+\tfree(r);\n+\tfree(g);\n+\tfree(b);\n }\/* sycc444_to_rgb() *\/\n \n static void sycc422_to_rgb(opj_image_t *img)\n {\t\n \tint *d0, *d1, *d2, *r, *g, *b;\n \tconst int *y, *cb, *cr;\n-\tunsigned int maxw, maxh, max;\n+\tsize_t maxw, maxh, max, offx, loopmaxw;\n \tint offset, upb;\n-\tunsigned int i, j;\n+\tsize_t i;\n \n \tupb = (int)img->comps[0].prec;\n \toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n \n-\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n+\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n \tmax = maxw * maxh;\n \n \ty = img->comps[0].data;\n \tcb = img->comps[1].data;\n \tcr = img->comps[2].data;\n \n-\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n-\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n-\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n+\td0 = r = (int*)malloc(sizeof(int) * max);\n+\td1 = g = (int*)malloc(sizeof(int) * max);\n+\td2 = b = (int*)malloc(sizeof(int) * max);\n \n \tif(r == NULL || g == NULL || b == NULL) goto fails;\n \n+\t\/* if img->x0 is odd, then first column shall use Cb\/Cr = 0 *\/\n+\toffx = img->x0 & 1U;\n+\tloopmaxw = maxw - offx;\n+\t\n \tfor(i=0U; i < maxh; ++i)\n \t{\n-\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n+\t\tsize_t j;\n+\t\t\n+\t\tif (offx > 0U) {\n+\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n+\t\t\t++y; ++r; ++g; ++b;\n+\t\t}\n+\t\t\n+\t\tfor(j=0U; j < (loopmaxw & ~(size_t)1U); j += 2U)\n \t\t{\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b;\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n \t\t}\n-\t\tif (j < maxw) {\n+\t\tif (j < loopmaxw) {\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n \t\t}\n \t}\n+\t\n \tfree(img->comps[0].data); img->comps[0].data = d0;\n \tfree(img->comps[1].data); img->comps[1].data = d1;\n \tfree(img->comps[2].data); img->comps[2].data = d2;\n \n-#if defined(USE_JPWL) || defined(USE_MJ2)\n-\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n-\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n-#else\n-\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n-\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n-#endif\n-\timg->comps[1].dx = img->comps[0].dx;\n-\timg->comps[2].dx = img->comps[0].dx;\n-\timg->comps[1].dy = img->comps[0].dy;\n-\timg->comps[2].dy = img->comps[0].dy;\n+\timg->comps[1].w = img->comps[2].w = img->comps[0].w;\n+\timg->comps[1].h = img->comps[2].h = img->comps[0].h;\n+\timg->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n+\timg->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n+\timg->color_space = OPJ_CLRSPC_SRGB;\n \treturn;\n \n fails:\n-\tif(r) free(r);\n-\tif(g) free(g);\n-\tif(b) free(b);\n-\n+\tfree(r);\n+\tfree(g);\n+\tfree(b);\n }\/* sycc422_to_rgb() *\/\n \n static void sycc420_to_rgb(opj_image_t *img)\n {\n \tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n \tconst int *y, *cb, *cr, *ny;\n-\tunsigned int maxw, maxh, max;\n+\tsize_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;\n \tint offset, upb;\n-\tunsigned int i, j;\n+\tsize_t i;\n \n \tupb = (int)img->comps[0].prec;\n \toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n \n-\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n+\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n \tmax = maxw * maxh;\n \n \ty = img->comps[0].data;\n \tcb = img->comps[1].data;\n \tcr = img->comps[2].data;\n \n-\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n-\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n-\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n-\n-\tif(r == NULL || g == NULL || b == NULL) goto fails;\n+\td0 = r = (int*)malloc(sizeof(int) * max);\n+\td1 = g = (int*)malloc(sizeof(int) * max);\n+\td2 = b = (int*)malloc(sizeof(int) * max);\n+\t\n+\tif (r == NULL || g == NULL || b == NULL) goto fails;\n+\t\n+\t\/* if img->x0 is odd, then first column shall use Cb\/Cr = 0 *\/\n+\toffx = img->x0 & 1U;\n+\tloopmaxw = maxw - offx;\n+\t\/* if img->y0 is odd, then first line shall use Cb\/Cr = 0 *\/\n+\toffy = img->y0 & 1U;\n+\tloopmaxh = maxh - offy;\n+\t\n+\tif (offy > 0U) {\n+\t\tsize_t j;\n+\t\t\n+\t\tfor(j=0; j < maxw; ++j)\n+\t\t{\n+\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n+\t\t\t++y; ++r; ++g; ++b;\n+\t\t}\n+\t}\n \n-\tfor(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)\n+\tfor(i=0U; i < (loopmaxh & ~(size_t)1U); i += 2U)\n \t{\n+\t\tsize_t j;\n+\t\t\n \t\tny = y + maxw;\n \t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n+\t\t\n+\t\tif (offx > 0U) {\n+\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n+\t\t\t++y; ++r; ++g; ++b;\n+\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n+\t\t\t++ny; ++nr; ++ng; ++nb;\n+\t\t}\n \n-\t\tfor(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)\n+\t\tfor(j=0; j < (loopmaxw & ~(size_t)1U); j += 2U)\n \t\t{\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b;\n@@ -230,7 +261,7 @@ static void sycc420_to_rgb(opj_image_t *img)\n \t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n \t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n \t\t}\n-\t\tif(j < maxw)\n+\t\tif(j < loopmaxw)\n \t\t{\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \t\t\t++y; ++r; ++g; ++b;\n@@ -240,9 +271,11 @@ static void sycc420_to_rgb(opj_image_t *img)\n \t\t}\n \t\ty += maxw; r += maxw; g += maxw; b += maxw;\n \t}\n-\tif(i < maxh)\n+\tif(i < loopmaxh)\n \t{\n-\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n+\t\tsize_t j;\n+\t\t\n+\t\tfor(j=0U; j < (maxw & ~(size_t)1U); j += 2U)\n \t\t{\n \t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n \n@@ -262,24 +295,17 @@ static void sycc420_to_rgb(opj_image_t *img)\n \tfree(img->comps[1].data); img->comps[1].data = d1;\n \tfree(img->comps[2].data); img->comps[2].data = d2;\n \n-#if defined(USE_JPWL) || defined(USE_MJ2)\n-\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n-\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n-#else\n-\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n-\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n-#endif\n-\timg->comps[1].dx = img->comps[0].dx;\n-\timg->comps[2].dx = img->comps[0].dx;\n-\timg->comps[1].dy = img->comps[0].dy;\n-\timg->comps[2].dy = img->comps[0].dy;\n+\timg->comps[1].w = img->comps[2].w = img->comps[0].w;\n+\timg->comps[1].h = img->comps[2].h = img->comps[0].h;\n+\timg->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n+\timg->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n+\timg->color_space = OPJ_CLRSPC_SRGB;\n \treturn;\n \n fails:\n-\tif(r) free(r);\n-\tif(g) free(g);\n-\tif(b) free(b);\n-\n+\tfree(r);\n+\tfree(g);\n+\tfree(b);\n }\/* sycc420_to_rgb() *\/\n \n void color_sycc_to_rgb(opj_image_t *img)\n@@ -324,8 +350,6 @@ void color_sycc_to_rgb(opj_image_t *img)\n \t\tfprintf(stderr,\"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n \t\treturn;\n   }\n-\timg->color_space = OPJ_CLRSPC_SRGB;\n-\n }\/* color_sycc_to_rgb() *\/\n \n #if defined(OPJ_HAVE_LIBLCMS2) || defined(OPJ_HAVE_LIBLCMS1)\ndiff --git a\/src\/bin\/jp2\/convertbmp.c b\/src\/bin\/jp2\/convertbmp.c\nindex a09c0ae58..d264823f0 100644\n--- a\/src\/bin\/jp2\/convertbmp.c\n+++ b\/src\/bin\/jp2\/convertbmp.c\n@@ -967,7 +967,7 @@ int imagetobmp(opj_image_t * image, const char *outfile) {\n             fprintf(fdest, \"%c\", (OPJ_UINT8)r);\n \n             if ((i + 1) % w == 0) {\n-                for ((pad = w % 4) ? (4 - w % 4) : 0; pad > 0; pad--)\t\/* ADD *\/\n+                for (pad = (w % 4) ? (4 - w % 4) : 0; pad > 0; pad--)\t\/* ADD *\/\n                     fprintf(fdest, \"%c\", 0);\n             }\n         }\n","owner":"uclouvain","repo":"openjpeg","source":"cve"},{"CVE_ID":"CVE-2018-12322","CWE_ID":"125","category":"security","commit_id":"bbb4af56003c1afdad67af0c4339267ca38b1017","commit_message":"From bbb4af56003c1afdad67af0c4339267ca38b1017 Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Mon, 11 Jun 2018 03:03:25 +0200\nSubject: [PATCH] Fix #10294 - crash in r2_hoobr__6502_op\n\n---\n libr\/anal\/p\/anal_6502.c | 12 +++++++++---\n 1 file changed, 9 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libr\/anal\/p\/anal_6502.c b\/libr\/anal\/p\/anal_6502.c\nindex 6d00244772..770980f2f2 100644\n--- a\/libr\/anal\/p\/anal_6502.c\n+++ b\/libr\/anal\/p\/anal_6502.c\n@@ -682,9 +682,15 @@ static int _6502_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int le\n \t\top->cycles = 2;\n \t\top->failcycles = 3;\n \t\top->type = R_ANAL_OP_TYPE_CJMP;\n-\t\tif (data[1] <= 127)\n-\t\t\top->jump = addr + data[1] + op->size;\n-\t\telse\top->jump = addr - (256 - data[1]) + op->size;\n+\t\tif (len > 1) {\n+\t\t\tif (data[1] <= 127) {\n+\t\t\t\top->jump = addr + data[1] + op->size;\n+\t\t\t} else {\n+\t\t\t\top->jump = addr - (256 - data[1]) + op->size;\n+\t\t\t}\n+\t\t} else {\n+\t\t\top->jump = addr;\n+\t\t}\n \t\top->fail = addr + op->size;\n \t\t\/\/ FIXME: add a type of conditional\n \t\t\/\/ op->cond = R_ANAL_COND_LE;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2018-6767","CWE_ID":"125","category":"security","commit_id":"d5bf76b5a88d044a1be1d5656698e3ba737167e5","commit_message":"From d5bf76b5a88d044a1be1d5656698e3ba737167e5 Mon Sep 17 00:00:00 2001\nFrom: David Bryant <david@wavpack.com>\nDate: Sun, 4 Feb 2018 11:28:15 -0800\nSubject: [PATCH] issue #27, do not overwrite stack on corrupt RF64 file\n\n---\n cli\/riff.c | 39 ++++++++++++++++++++++++++++++++-------\n 1 file changed, 32 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/cli\/riff.c b\/cli\/riff.c\nindex 8b1af45..de98c1e 100644\n--- a\/cli\/riff.c\n+++ b\/cli\/riff.c\n@@ -42,6 +42,7 @@ typedef struct {\n \n #pragma pack(pop)\n \n+#define CS64ChunkFormat \"4D\"\n #define DS64ChunkFormat \"DDDL\"\n \n #define WAVPACK_NO_ERROR    0\n@@ -101,13 +102,13 @@ int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack\n \n         if (!strncmp (chunk_header.ckID, \"ds64\", 4)) {\n             if (chunk_header.ckSize < sizeof (DS64Chunk) ||\n-                !DoReadFile (infile, &ds64_chunk, chunk_header.ckSize, &bcount) ||\n-                bcount != chunk_header.ckSize) {\n+                !DoReadFile (infile, &ds64_chunk, sizeof (DS64Chunk), &bcount) ||\n+                bcount != sizeof (DS64Chunk)) {\n                     error_line (\"%s is not a valid .WAV file!\", infilename);\n                     return WAVPACK_SOFT_ERROR;\n             }\n             else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n-                !WavpackAddWrapper (wpc, &ds64_chunk, chunk_header.ckSize)) {\n+                !WavpackAddWrapper (wpc, &ds64_chunk, sizeof (DS64Chunk))) {\n                     error_line (\"%s\", WavpackGetErrorMessage (wpc));\n                     return WAVPACK_SOFT_ERROR;\n             }\n@@ -315,10 +316,11 @@ int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, Wavpack\n \n int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n {\n-    int do_rf64 = 0, write_junk = 1;\n+    int do_rf64 = 0, write_junk = 1, table_length = 0;\n     ChunkHeader ds64hdr, datahdr, fmthdr;\n     RiffChunkHeader riffhdr;\n     DS64Chunk ds64_chunk;\n+    CS64Chunk cs64_chunk;\n     JunkChunk junkchunk;\n     WaveHeader wavhdr;\n     uint32_t bcount;\n@@ -380,6 +382,7 @@ int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples,\n     strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n     total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n     if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n+    total_riff_bytes += table_length * sizeof (CS64Chunk);\n     if (write_junk) total_riff_bytes += sizeof (junkchunk);\n     strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n     strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n@@ -394,11 +397,12 @@ int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples,\n \n     if (do_rf64) {\n         strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n-        ds64hdr.ckSize = sizeof (ds64_chunk);\n+        ds64hdr.ckSize = sizeof (ds64_chunk) + (table_length * sizeof (CS64Chunk));\n         CLEAR (ds64_chunk);\n         ds64_chunk.riffSize64 = total_riff_bytes;\n         ds64_chunk.dataSize64 = total_data_bytes;\n         ds64_chunk.sampleCount64 = total_samples;\n+        ds64_chunk.tableLength = table_length;\n         riffhdr.ckSize = (uint32_t) -1;\n         datahdr.ckSize = (uint32_t) -1;\n         WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n@@ -409,6 +413,14 @@ int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples,\n         datahdr.ckSize = (uint32_t) total_data_bytes;\n     }\n \n+    \/\/ this \"table\" is just a dummy placeholder for testing (normally not written)\n+\n+    if (table_length) {\n+        strncpy (cs64_chunk.ckID, \"dmmy\", sizeof (cs64_chunk.ckID));\n+        cs64_chunk.chunkSize64 = 12345678;\n+        WavpackNativeToLittleEndian (&cs64_chunk, CS64ChunkFormat);\n+    }\n+\n     \/\/ write the RIFF chunks up to just before the data starts\n \n     WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n@@ -418,8 +430,21 @@ int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples,\n \n     if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n         (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n-        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk))) ||\n-        (write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n+        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk)))) {\n+            error_line (\"can't write .WAV data, disk probably full!\");\n+            return FALSE;\n+    }\n+\n+    \/\/ again, this is normally not written except for testing\n+\n+    while (table_length--)\n+        if (!DoWriteFile (outfile, &cs64_chunk, sizeof (cs64_chunk), &bcount) || bcount != sizeof (cs64_chunk)) {\n+            error_line (\"can't write .WAV data, disk probably full!\");\n+            return FALSE;\n+        }\n+\n+\n+    if ((write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n         !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n         !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n         !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n","owner":"dbry","repo":"WavPack","source":"cve"},{"CVE_ID":"CVE-2018-13300","CWE_ID":"125","category":"security","commit_id":"95556e27e2c1d56d9e18f5db34d6f756f3011148","commit_message":"From 95556e27e2c1d56d9e18f5db34d6f756f3011148 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Wed, 27 Jun 2018 17:27:50 +0200\nSubject: [PATCH] avformat\/movenc: Do not pass AVCodecParameters in\n avpriv_request_sample\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nFixes: out of array read\nFixes: ffmpeg_crash_8.avi\n\nFound-by: Thuan Pham, Marcel B\u00f6hme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/movenc.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavformat\/movenc.c b\/libavformat\/movenc.c\nindex 6eabf32fce3..4ce5c23ab80 100644\n--- a\/libavformat\/movenc.c\n+++ b\/libavformat\/movenc.c\n@@ -429,7 +429,7 @@ static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track)\n \n             if (hdr->substreamid == info->num_ind_sub + 1) {\n                 \/\/info->num_ind_sub++;\n-                avpriv_request_sample(track->par, \"Multiple independent substreams\");\n+                avpriv_request_sample(mov->fc, \"Multiple independent substreams\");\n                 ret = AVERROR_PATCHWELCOME;\n                 goto end;\n             } else if (hdr->substreamid < info->num_ind_sub ||\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2018-8754","CWE_ID":"125","category":"security","commit_id":"444ca3ce7853538c577e0ec3f6146d2d65780734","commit_message":"From 444ca3ce7853538c577e0ec3f6146d2d65780734 Mon Sep 17 00:00:00 2001\nFrom: Joachim Metz <joachim.metz@gmail.com>\nDate: Sat, 17 Mar 2018 08:35:13 +0100\nSubject: [PATCH] Applied updates and addition boundary checks for corrupted\n data\n\n---\n configure.ac                  | 14 +++----\n libevt.nuspec                 |  4 +-\n libevt\/libevt_libfvalue.h     |  1 +\n libevt\/libevt_record_values.c | 35 ++++++++++++++++-\n m4\/libcdata.m4                | 44 ++++++++++++++++++++-\n m4\/libcsplit.m4               |  4 +-\n m4\/libfdata.m4                | 73 ++++++++++++++++++++++++++++++++++-\n runtests.sh                   | 23 ++++++++++-\n 8 files changed, 182 insertions(+), 16 deletions(-)\n\n","diff_code":"diff --git a\/configure.ac b\/configure.ac\nindex c90de8f..f51519d 100644\n--- a\/configure.ac\n+++ b\/configure.ac\n@@ -2,7 +2,7 @@ AC_PREREQ( 2.59 )\n \n AC_INIT(\n  [libevt],\n- [20180125],\n+ [20180317],\n  [joachim.metz@gmail.com])\n \n AC_CONFIG_SRCDIR(\n@@ -48,6 +48,12 @@ AX_COMMON_CHECK_ENABLE_WINAPI\n dnl Check if wide character type should be enabled\n AX_COMMON_CHECK_ENABLE_WIDE_CHARACTER_TYPE\n \n+dnl Check if verbose output should be enabled\n+AX_COMMON_CHECK_ENABLE_VERBOSE_OUTPUT\n+\n+dnl Check if debug output should be enabled\n+AX_COMMON_CHECK_ENABLE_DEBUG_OUTPUT\n+\n dnl Check for type definitions\n AX_TYPES_CHECK_LOCAL\n \n@@ -146,12 +152,6 @@ AX_LIBCDIRECTORY_CHECK_ENABLE\n dnl Check if evttools required headers and functions are available\n AX_EVTTOOLS_CHECK_LOCAL\n \n-dnl Check if libevt should be build with verbose output\n-AX_COMMON_CHECK_ENABLE_VERBOSE_OUTPUT\n-\n-dnl Check if libevt should be build with debug output\n-AX_COMMON_CHECK_ENABLE_DEBUG_OUTPUT\n-\n dnl Check if tests required headers and functions are available\n AX_TESTS_CHECK_LOCAL\n \ndiff --git a\/libevt.nuspec b\/libevt.nuspec\nindex 3603086..a390283 100644\n--- a\/libevt.nuspec\n+++ b\/libevt.nuspec\n@@ -2,7 +2,7 @@\n <package >\n   <metadata>\n     <id>libevt<\/id>\n-    <version>20180125<\/version>\n+    <version>20180317<\/version>\n     <authors>Joachim Metz<\/authors>\n     <owners>joachimmetz<\/owners>\n     <licenseUrl>https:\/\/raw.githubusercontent.com\/libyal\/libevt\/master\/COPYING<\/licenseUrl>\n@@ -10,7 +10,7 @@\n     <requireLicenseAcceptance>false<\/requireLicenseAcceptance>\n     <title>libevt<\/title>\n     <description>Library to access the Windows Event Log (EVT) format<\/description>\n-    <releaseNotes>Release of libevt 20180125<\/releaseNotes>\n+    <releaseNotes>Release of libevt 20180317<\/releaseNotes>\n     <copyright>Copyright (C) 2011-2018<\/copyright>\n     <tags>native<\/tags>\n   <\/metadata>\ndiff --git a\/libevt\/libevt_libfvalue.h b\/libevt\/libevt_libfvalue.h\nindex fb914f4..4dc9a4e 100644\n--- a\/libevt\/libevt_libfvalue.h\n+++ b\/libevt\/libevt_libfvalue.h\n@@ -29,6 +29,7 @@\n #if defined( HAVE_LOCAL_LIBFVALUE )\n \n #include <libfvalue_codepage.h>\n+#include <libfvalue_data_handle.h>\n #include <libfvalue_definitions.h>\n #include <libfvalue_floating_point.h>\n #include <libfvalue_integer.h>\ndiff --git a\/libevt\/libevt_record_values.c b\/libevt\/libevt_record_values.c\nindex 879dff2..3d44871 100644\n--- a\/libevt\/libevt_record_values.c\n+++ b\/libevt\/libevt_record_values.c\n@@ -1157,6 +1157,17 @@ int libevt_record_values_read_event(\n \t}\n \tif( user_sid_size != 0 )\n \t{\n+\t\tif( user_sid_size > ( ( record_data_size - 4 ) - user_sid_offset ) )\n+\t\t{\n+\t\t\tlibcerror_error_set(\n+\t\t\t error,\n+\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n+\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n+\t\t\t \"%s: user SID data size value out of bounds.\",\n+\t\t\t function );\n+\n+\t\t\tgoto on_error;\n+\t\t}\n \t\tif( libfvalue_value_type_initialize(\n \t\t     &( record_values->user_security_identifier ),\n \t\t     LIBFVALUE_VALUE_TYPE_NT_SECURITY_IDENTIFIER,\n@@ -1218,6 +1229,17 @@ int libevt_record_values_read_event(\n \t}\n \tif( strings_size != 0 )\n \t{\n+\t\tif( strings_size > ( ( record_data_size - 4 ) - strings_offset ) )\n+\t\t{\n+\t\t\tlibcerror_error_set(\n+\t\t\t error,\n+\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n+\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n+\t\t\t \"%s: strings size value out of bounds.\",\n+\t\t\t function );\n+\n+\t\t\tgoto on_error;\n+\t\t}\n #if defined( HAVE_DEBUG_OUTPUT )\n \t\tif( libcnotify_verbose != 0 )\n \t\t{\n@@ -1285,6 +1307,17 @@ int libevt_record_values_read_event(\n \t}\n \tif( data_size != 0 )\n \t{\n+\t\tif( data_size > ( ( record_data_size - 4 ) - data_offset ) )\n+\t\t{\n+\t\t\tlibcerror_error_set(\n+\t\t\t error,\n+\t\t\t LIBCERROR_ERROR_DOMAIN_RUNTIME,\n+\t\t\t LIBCERROR_RUNTIME_ERROR_VALUE_OUT_OF_BOUNDS,\n+\t\t\t \"%s: data size value out of bounds.\",\n+\t\t\t function );\n+\n+\t\t\tgoto on_error;\n+\t\t}\n #if defined( HAVE_DEBUG_OUTPUT )\n \t\tif( libcnotify_verbose != 0 )\n \t\t{\n@@ -1292,7 +1325,7 @@ int libevt_record_values_read_event(\n \t\t\t \"%s: data:\\n\",\n \t\t\t function );\n \t\t\tlibcnotify_print_data(\n-\t\t\t &( record_data[ data_offset ] ),\n+\t\t\t &( record_data[ record_data_offset ] ),\n \t\t\t (size_t) data_size,\n \t\t\t LIBCNOTIFY_PRINT_DATA_FLAG_GROUP_DATA );\n \t\t}\ndiff --git a\/m4\/libcdata.m4 b\/m4\/libcdata.m4\nindex c19c04f..f4067aa 100644\n--- a\/m4\/libcdata.m4\n+++ b\/m4\/libcdata.m4\n@@ -1,6 +1,6 @@\n dnl Checks for libcdata or required headers and functions\n dnl\n-dnl Version: 20170904\n+dnl Version: 20180316\n \n dnl Function to detect if libcdata is available\n dnl ac_libcdata_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments\n@@ -123,6 +123,48 @@ AC_DEFUN([AX_LIBCDATA_CHECK_LIB],\n           [ac_cv_libcdata_dummy=yes],\n           [ac_cv_libcdata=no])\n \n+        dnl Balanced tree functions\n+        AC_CHECK_LIB(\n+          cdata,\n+          libfdata_btree_initialize,\n+          [ac_cv_libcdata_dummy=yes],\n+          [ac_cv_libcdata=no])\n+        AC_CHECK_LIB(\n+          cdata,\n+          libcdata_btree_free,\n+          [ac_cv_libcdata_dummy=yes],\n+          [ac_cv_libcdata=no])\n+        AC_CHECK_LIB(\n+          cdata,\n+          libcdata_btree_get_number_of_values,\n+          [ac_cv_libcdata_dummy=yes],\n+          [ac_cv_libcdata=no])\n+        AC_CHECK_LIB(\n+          cdata,\n+          libcdata_btree_get_value_by_index,\n+          [ac_cv_libcdata_dummy=yes],\n+          [ac_cv_libcdata=no])\n+        AC_CHECK_LIB(\n+          cdata,\n+          libcdata_btree_get_value_by_value,\n+          [ac_cv_libcdata_dummy=yes],\n+          [ac_cv_libcdata=no])\n+        AC_CHECK_LIB(\n+          cdata,\n+          libcdata_btree_insert_value,\n+          [ac_cv_libcdata_dummy=yes],\n+          [ac_cv_libcdata=no])\n+        AC_CHECK_LIB(\n+          cdata,\n+          libcdata_btree_replace_value,\n+          [ac_cv_libcdata_dummy=yes],\n+          [ac_cv_libcdata=no])\n+        AC_CHECK_LIB(\n+          cdata,\n+          libcdata_btree_remove_value,\n+          [ac_cv_libcdata_dummy=yes],\n+          [ac_cv_libcdata=no])\n+\n         dnl List functions\n         AC_CHECK_LIB(\n           cdata,\ndiff --git a\/m4\/libcsplit.m4 b\/m4\/libcsplit.m4\nindex f49d839..c911016 100644\n--- a\/m4\/libcsplit.m4\n+++ b\/m4\/libcsplit.m4\n@@ -1,6 +1,6 @@\n dnl Checks for libcsplit or required headers and functions\n dnl\n-dnl Version: 20170903\n+dnl Version: 20180217\n \n dnl Function to detect if libcsplit is available\n dnl ac_libcsplit_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments\n@@ -111,7 +111,7 @@ AC_DEFUN([AX_LIBCSPLIT_CHECK_LIB],\n         AS_IF(\n           [test \"x$ac_cv_enable_wide_character_type\" != xno],\n           [AC_CHECK_LIB(\n-          csplit,\n+            csplit,\n             libcsplit_wide_string_split,\n             [ac_cv_libcsplit_dummy=yes],\n             [ac_cv_libcsplit=no])\ndiff --git a\/m4\/libfdata.m4 b\/m4\/libfdata.m4\nindex 3e7670d..6dfec55 100644\n--- a\/m4\/libfdata.m4\n+++ b\/m4\/libfdata.m4\n@@ -1,6 +1,6 @@\n dnl Functions for libfdata\n dnl\n-dnl Version: 20170905\n+dnl Version: 20180316\n \n dnl Function to detect if libfdata is available\n dnl ac_libfdata_dummy is used to prevent AC_CHECK_LIB adding unnecessary -l<library> arguments\n@@ -49,7 +49,76 @@ AC_DEFUN([AX_LIBFDATA_CHECK_LIB],\n           [ac_cv_libfdata=no])\n \n         dnl Area functions\n-        dnl TODO: add functions\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_initialize,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_free,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_clone,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_empty,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_resize,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_get_number_of_segments,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_get_segment_by_index,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_set_segment_by_index,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_prepend_segment,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_append_segment,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_get_element_data_size,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_get_element_value_at_offset,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_set_element_value_at_offset,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n+        AC_CHECK_LIB(\n+          fdata,\n+          libfdata_area_get_size,\n+          [ac_cv_libfdata_dummy=yes],\n+          [ac_cv_libfdata=no])\n \n         dnl Balanced tree functions\n         dnl TODO: add functions\ndiff --git a\/runtests.sh b\/runtests.sh\nindex 49c7d09..0ef7640 100755\n--- a\/runtests.sh\n+++ b\/runtests.sh\n@@ -1,7 +1,7 @@\n #!\/bin\/bash\n # Script that runs the tests\n #\n-# Version: 20171210\n+# Version: 20180214\n \n EXIT_SUCCESS=0;\n EXIT_FAILURE=1;\n@@ -201,6 +201,14 @@ echo \"${CONFIGURE_HELP}\" | grep -- '--enable-wide-character-type' > \/dev\/null;\n \n HAVE_ENABLE_WIDE_CHARACTER_TYPE=$?;\n \n+echo \"${CONFIGURE_HELP}\" | grep -- '--enable-verbose-output' > \/dev\/null;\n+\n+HAVE_ENABLE_VERBOSE_OUTPUT=$?;\n+\n+echo \"${CONFIGURE_HELP}\" | grep -- '--enable-debug-output' > \/dev\/null;\n+\n+HAVE_ENABLE_DEBUG_OUTPUT=$?;\n+\n echo \"${CONFIGURE_HELP}\" | grep -- '--with-zlib' > \/dev\/null;\n \n HAVE_WITH_ZLIB=$?;\n@@ -230,6 +238,19 @@ then\n \texit ${EXIT_FAILURE};\n fi\n \n+if test ${HAVE_ENABLE_VERBOSE_OUTPUT} -eq 0 && test ${HAVE_ENABLE_DEBUG_OUTPUT} -eq 0;\n+then\n+\t# Test \".\/configure && make && make check\" with verbose and debug output.\n+\n+\trun_configure_make_check \"--enable-verbose-output --enable-debug-output\";\n+\tRESULT=$?;\n+\n+\tif test ${RESULT} -ne ${EXIT_SUCCESS};\n+\tthen\n+\t\texit ${EXIT_FAILURE};\n+\tfi\n+fi\n+\n if test ${HAVE_WITH_ZLIB} -eq 0;\n then\n \t# Test \".\/configure && make && make check\" with fallback zlib implementation.\n","owner":"libyal","repo":"libevt","source":"cve"},{"CVE_ID":"CVE-2018-6392","CWE_ID":"125","category":"security","commit_id":"c6939f65a116b1ffed345d29d8621ee4ffb32235","commit_message":"From c6939f65a116b1ffed345d29d8621ee4ffb32235 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Wed, 24 Jan 2018 19:38:05 +0100\nSubject: [PATCH] avfilter\/vf_transpose: Fix used plane count.\n\nFixes out of array access\nFixes: poc.mp4\n\nFound-by: GwanYeong Kim <gy741.kim@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavfilter\/vf_transpose.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavfilter\/vf_transpose.c b\/libavfilter\/vf_transpose.c\nindex 982fb0c..1e1a5c4 100644\n--- a\/libavfilter\/vf_transpose.c\n+++ b\/libavfilter\/vf_transpose.c\n@@ -27,6 +27,7 @@\n \n #include <stdio.h>\n \n+#include \"libavutil\/avassert.h\"\n #include \"libavutil\/imgutils.h\"\n #include \"libavutil\/internal.h\"\n #include \"libavutil\/intreadwrite.h\"\n@@ -54,6 +55,7 @@ enum TransposeDir {\n typedef struct TransContext {\n     const AVClass *class;\n     int hsub, vsub;\n+    int planes;\n     int pixsteps[4];\n \n     int passthrough;    \/\/\/< PassthroughType, landscape passthrough mode enabled\n@@ -215,6 +217,10 @@ static int config_props_output(AVFilterLink *outlink)\n \n     s->hsub = desc_in->log2_chroma_w;\n     s->vsub = desc_in->log2_chroma_h;\n+    s->planes = desc_in->nb_components;\n+\n+    av_assert0(desc_in->nb_components == desc_out->nb_components);\n+\n \n     av_image_fill_max_pixsteps(s->pixsteps, NULL, desc_out);\n \n@@ -272,7 +278,7 @@ static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr,\n     AVFrame *in = td->in;\n     int plane;\n \n-    for (plane = 0; out->data[plane]; plane++) {\n+    for (plane = 0; plane < s->planes; plane++) {\n         int hsub    = plane == 1 || plane == 2 ? s->hsub : 0;\n         int vsub    = plane == 1 || plane == 2 ? s->vsub : 0;\n         int pixstep = s->pixsteps[plane];\n-- \n2.7.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8817","CWE_ID":"125","category":"security","commit_id":"c3c1bb99d1c11978d9ce94d1bdcf0705378c1459","commit_message":"From c3c1bb99d1c11978d9ce94d1bdcf0705378c1459 Mon Sep 17 00:00:00 2001\nFrom: Peter Crosthwaite <peter.crosthwaite@xilinx.com>\nDate: Mon, 16 Mar 2015 22:35:54 -0700\nSubject: [PATCH] exec: Respect as_tranlsate_internal length clamp\n\naddress_space_translate_internal will clamp the *plen length argument\nbased on the size of the memory region being queried. The iommu walker\nlogic in addresss_space_translate was ignoring this by discarding the\npost fn call value of *plen. Fix by just always using *plen as the\nlength argument throughout the fn, removing the len local variable.\n\nThis fixes a bootloader bug when a single elf section spans multiple\nQEMU memory regions.\n\nSigned-off-by: Peter Crosthwaite <peter.crosthwaite@xilinx.com>\nMessage-Id: <1426570554-15940-1-git-send-email-peter.crosthwaite@xilinx.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n exec.c | 6 ++----\n 1 file changed, 2 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/exec.c b\/exec.c\nindex e97071a..8b922db 100644\n--- a\/exec.c\n+++ b\/exec.c\n@@ -380,7 +380,6 @@ MemoryRegion *address_space_translate(AddressSpace *as, hwaddr addr,\n     IOMMUTLBEntry iotlb;\n     MemoryRegionSection *section;\n     MemoryRegion *mr;\n-    hwaddr len = *plen;\n \n     rcu_read_lock();\n     for (;;) {\n@@ -395,7 +394,7 @@ MemoryRegion *address_space_translate(AddressSpace *as, hwaddr addr,\n         iotlb = mr->iommu_ops->translate(mr, addr, is_write);\n         addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                 | (addr & iotlb.addr_mask));\n-        len = MIN(len, (addr | iotlb.addr_mask) - addr + 1);\n+        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);\n         if (!(iotlb.perm & (1 << is_write))) {\n             mr = &io_mem_unassigned;\n             break;\n@@ -406,10 +405,9 @@ MemoryRegion *address_space_translate(AddressSpace *as, hwaddr addr,\n \n     if (xen_enabled() && memory_access_is_direct(mr, is_write)) {\n         hwaddr page = ((addr & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE) - addr;\n-        len = MIN(page, len);\n+        *plen = MIN(page, *plen);\n     }\n \n-    *plen = len;\n     *xlat = addr;\n     rcu_read_unlock();\n     return mr;\n-- \n1.8.3.1\n\n","owner":"bonzini","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2018-5801","CWE_ID":"125","category":"security","commit_id":"0df5490b985c419de008d32168650bff17128914","commit_message":"From 0df5490b985c419de008d32168650bff17128914 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Wed, 6 Dec 2017 21:41:19 +0300\nSubject: [PATCH] SA79000 advisory fix\n\n---\n Changelog.txt             |  9 ++++++-\n dcraw\/dcraw.c             | 54 +++++++++++++++++++++++++++++++++++++--\n internal\/dcraw_common.cpp | 46 +++++++++++++++++++++++++++++++--\n src\/libraw_cxx.cpp        |  2 +-\n 4 files changed, 105 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/Changelog.txt b\/Changelog.txt\nindex dff568a0..90b2971f 100755\n--- a\/Changelog.txt\n+++ b\/Changelog.txt\n@@ -1,4 +1,11 @@\n-Alex Tutubalin <lexa@lexa.ru>\n+2018-01-19  Alex Tutubalin <lexa@lexa.ru>\n+Secunia #79000: \n+Credit: Laurent Delosieres, Secunia Research at Flexera\n+ * All legacy (RGB raw) image loaders checks for imgdata.image is not NULL\n+ * kodak_radc_load_raw: check image size before processing\n+ * legacy memory allocator: allocate max(widh,raw_width)*max(height,raw_height)\n+\n+2017-12-06 Alex Tutubalin <lexa@lexa.ru>\n Secunia #76000:\n  * Fixed fuji_width handling if file is neither fuji nor DNG\n  * Fixed xtrans interpolate for broken xtrans pattern\ndiff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 033b26fa..d287089c 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -1886,6 +1886,10 @@ void CLASS nikon_load_raw()\n \n void CLASS nikon_yuv_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col, yuv[4], rgb[3], b, c;\n   UINT64 bitbuf = 0;\n   float cmul[4];\n@@ -2815,6 +2819,10 @@ void CLASS sinar_4shot_load_raw()\n     unpacked_load_raw();\n     return;\n   }\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  else if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n   merror(pixel, \"sinar_4shot_load_raw()\");\n #ifdef LIBRAW_LIBRARY_BUILD\n@@ -2857,8 +2865,10 @@ void CLASS imacon_full_load_raw()\n {\n   int row, col;\n \n-  if (!image)\n-    return;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n \n #ifdef LIBRAW_LIBRARY_BUILD\n   unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n@@ -3404,6 +3414,12 @@ void CLASS quicktake_100_load_raw()\n \n void CLASS kodak_radc_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  \/\/ All kodak radc images are 768x512\n+  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   static const signed char src[] = {\n       1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n       8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n@@ -3652,6 +3668,10 @@ void CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n \n void CLASS lossy_dng_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   struct jpeg_decompress_struct cinfo;\n   struct jpeg_error_mgr jerr;\n   JSAMPARRAY buf;\n@@ -3806,6 +3826,11 @@ void CLASS eight_bit_load_raw()\n \n void CLASS kodak_c330_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -3849,6 +3874,11 @@ void CLASS kodak_c330_load_raw()\n \n void CLASS kodak_c603_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -4028,6 +4058,10 @@ void CLASS kodak_65000_load_raw()\n \n void CLASS kodak_ycbcr_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[384], *bp;\n   int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n   ushort *ip;\n@@ -4067,6 +4101,10 @@ void CLASS kodak_ycbcr_load_raw()\n \n void CLASS kodak_rgb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[768], *bp;\n   int row, col, len, c, i, rgb[3], ret;\n   ushort *ip = image[0];\n@@ -4096,6 +4134,10 @@ void CLASS kodak_rgb_load_raw()\n \n void CLASS kodak_thumb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col;\n   colors = thumb_misc >> 5;\n   for (row = 0; row < height; row++)\n@@ -4809,6 +4851,10 @@ void CLASS foveon_thumb()\n \n void CLASS foveon_sd_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   struct decode *dindex;\n   short diff[1024];\n   unsigned bitbuf = 0;\n@@ -4869,6 +4915,10 @@ void CLASS foveon_huff(ushort *huff)\n \n void CLASS foveon_dp_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   unsigned c, roff[4], row, col, diff;\n   ushort huff[512], vpred[2][2], hpred[2];\n \ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex 207898de..877bce0f 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -1595,6 +1595,10 @@ void CLASS nikon_load_raw()\n \n void CLASS nikon_yuv_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col, yuv[4], rgb[3], b, c;\n   UINT64 bitbuf = 0;\n   float cmul[4];\n@@ -2519,6 +2523,10 @@ void CLASS sinar_4shot_load_raw()\n     unpacked_load_raw();\n     return;\n   }\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  else if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n   merror(pixel, \"sinar_4shot_load_raw()\");\n #ifdef LIBRAW_LIBRARY_BUILD\n@@ -2561,8 +2569,10 @@ void CLASS imacon_full_load_raw()\n {\n   int row, col;\n \n-  if (!image)\n-    return;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n \n #ifdef LIBRAW_LIBRARY_BUILD\n   unsigned short *buf = (unsigned short *)malloc(width * 3 * sizeof(unsigned short));\n@@ -3108,6 +3118,12 @@ void CLASS quicktake_100_load_raw()\n \n void CLASS kodak_radc_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  \/\/ All kodak radc images are 768x512\n+  if(width>768 || raw_width>768 || height > 512 || raw_height>512 )\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   static const signed char src[] = {\n       1, 1,   2, 3,   3, 4,   4, 2,   5, 7,   6, 5,   7, 6,  7, 8,   1, 0,   2, 1,  3, 3,  4, 4,  5, 2,   6, 7,   7, 6,\n       8, 5,   8, 8,   2, 1,   2, 3,   3, 0,   3, 2,   3, 4,  4, 6,   5, 5,   6, 7,  6, 8,  2, 0,  2, 1,   2, 3,   3, 2,\n@@ -3356,6 +3372,10 @@ void CLASS gamma_curve(double pwr, double ts, int mode, int imax);\n \n void CLASS lossy_dng_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   struct jpeg_decompress_struct cinfo;\n   struct jpeg_error_mgr jerr;\n   JSAMPARRAY buf;\n@@ -3510,6 +3530,11 @@ void CLASS eight_bit_load_raw()\n \n void CLASS kodak_c330_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -3553,6 +3578,11 @@ void CLASS kodak_c330_load_raw()\n \n void CLASS kodak_c603_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\n   uchar *pixel;\n   int row, col, y, cb, cr, rgb[3], c;\n \n@@ -3732,6 +3762,10 @@ void CLASS kodak_65000_load_raw()\n \n void CLASS kodak_ycbcr_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[384], *bp;\n   int row, col, len, c, i, j, k, y[2][2], cb, cr, rgb[3];\n   ushort *ip;\n@@ -3771,6 +3805,10 @@ void CLASS kodak_ycbcr_load_raw()\n \n void CLASS kodak_rgb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   short buf[768], *bp;\n   int row, col, len, c, i, rgb[3], ret;\n   ushort *ip = image[0];\n@@ -3800,6 +3838,10 @@ void CLASS kodak_rgb_load_raw()\n \n void CLASS kodak_thumb_load_raw()\n {\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n   int row, col;\n   colors = thumb_misc >> 5;\n   for (row = 0; row < height; row++)\ndiff --git a\/src\/libraw_cxx.cpp b\/src\/libraw_cxx.cpp\nindex 69206380..69f6c3ae 100644\n--- a\/src\/libraw_cxx.cpp\n+++ b\/src\/libraw_cxx.cpp\n@@ -2792,7 +2792,7 @@ int LibRaw::unpack(void)\n         \/\/ sRAW and old Foveon decoders only, so extra buffer size is just 1\/4\n         \/\/ allocate image as temporary buffer, size\n         imgdata.rawdata.raw_alloc = 0;\n-        imgdata.image = (ushort(*)[4])calloc(unsigned(S.raw_width) * unsigned(S.raw_height), sizeof(*imgdata.image));\n+        imgdata.image = (ushort(*)[4])calloc(unsigned(MAX(S.width,S.raw_width)) * unsigned(MAX(S.height,S.raw_height)), sizeof(*imgdata.image));\n         if (!(decoder_info.decoder_flags & LIBRAW_DECODER_ADOBECOPYPIXEL))\n         {\n           imgdata.rawdata.raw_image = (ushort *)imgdata.image;\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2017-11664","CWE_ID":"125","category":"security","commit_id":"660b513d99bced8783a4a5984ac2f742c74ebbdd","commit_message":"From 660b513d99bced8783a4a5984ac2f742c74ebbdd Mon Sep 17 00:00:00 2001\nFrom: sezero <sezero@users.sourceforge.net>\nDate: Wed, 2 Aug 2017 14:20:00 +0300\nSubject: [PATCH] Add a new size parameter to _WM_SetupMidiEvent() so that it\n knows where to stop reading, and adjust its users properly. Fixes bug #175\n (CVE-2017-11661, CVE-2017-11662, CVE-2017-11663, CVE-2017-11664.)\n\n---\n include\/internal_midi.h |  2 +-\n src\/f_hmi.c             | 40 +++++++++++++++++---\n src\/f_hmp.c             | 15 +++++++-\n src\/f_midi.c            | 55 ++++++++++++++++++---------\n src\/f_mus.c             |  5 ++-\n src\/f_xmidi.c           |  2 +-\n src\/internal_midi.c     | 83 ++++++++++++++++++++++++++++++++++++-----\n 7 files changed, 162 insertions(+), 40 deletions(-)\n\n","diff_code":"diff --git a\/include\/internal_midi.h b\/include\/internal_midi.h\nindex afe6319..4e1782e 100644\n--- a\/include\/internal_midi.h\n+++ b\/include\/internal_midi.h\n@@ -191,7 +191,7 @@ extern int _WM_midi_setup_divisions(struct _mdi *mdi, uint32_t divisions);\n \n extern struct _mdi * _WM_initMDI(void);\n extern void _WM_freeMDI(struct _mdi *mdi);\n-extern uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t running_event);\n+extern uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint32_t siz, uint8_t running_event);\n extern void _WM_ResetToStart(struct _mdi *mdi);\n extern void _WM_do_pan_adjust(struct _mdi *mdi, uint8_t ch);\n extern void _WM_do_note_off_extra(struct _note *nte);\ndiff --git a\/src\/f_hmi.c b\/src\/f_hmi.c\nindex 1a8808b..21d9363 100644\n--- a\/src\/f_hmi.c\n+++ b\/src\/f_hmi.c\n@@ -42,10 +42,10 @@ struct _mdi *\n _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n     uint32_t hmi_tmp = 0;\n     uint8_t *hmi_base = hmi_data;\n+    uint32_t data_siz;\n     uint16_t hmi_bpm = 0;\n     uint16_t hmi_division = 0;\n \n-\/\/  uint32_t hmi_duration_secs = 0;\n     uint32_t hmi_track_cnt = 0;\n     uint32_t *hmi_track_offset = NULL;\n     uint32_t i = 0;\n@@ -74,8 +74,6 @@ _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n         uint8_t channel;\n     } *note;\n \n-    \/\/FIXME: This needs to be used for sanity check.\n-    UNUSED(hmi_size);\n \n     if (memcmp(hmi_data, \"HMI-MIDISONG061595\", 18)) {\n         _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, NULL, 0);\n@@ -216,6 +214,11 @@ _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n             do {\n                 hmi_data = hmi_base + hmi_track_offset[i];\n                 hmi_delta[i] = 0;\n+                if (hmi_track_offset[i] >= hmi_size) {\n+                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n+                    goto _hmi_end;\n+                }\n+                data_siz = hmi_size - hmi_track_offset[i];\n \n                 if (hmi_data[0] == 0xfe) {\n                     \/\/ HMI only event of some sort.\n@@ -223,14 +226,23 @@ _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n                         hmi_tmp = (hmi_data[4] + 5);\n                         hmi_data += hmi_tmp;\n                         hmi_track_offset[i] += hmi_tmp;\n+                        hmi_tmp += 4;\n                     } else if (hmi_data[1] == 0x15) {\n                         hmi_data += 4;\n                         hmi_track_offset[i] += 4;\n+                        hmi_tmp = 8;\n+                    } else {\n+                        hmi_tmp = 4;\n                     }\n                     hmi_data += 4;\n                     hmi_track_offset[i] += 4;\n+                    if (hmi_tmp > data_siz) {\n+                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n+                        goto _hmi_end;\n+                    }\n+                    data_siz -= hmi_tmp;\n                 } else {\n-                    if ((setup_ret = _WM_SetupMidiEvent(hmi_mdi,hmi_data,hmi_running_event[i])) == 0) {\n+                    if ((setup_ret = _WM_SetupMidiEvent(hmi_mdi,hmi_data,data_siz,hmi_running_event[i])) == 0) {\n                         goto _hmi_end;\n                     }\n                     if ((hmi_data[0] == 0xff) && (hmi_data[1] == 0x2f) && (hmi_data[2] == 0x00)) {\n@@ -269,17 +281,25 @@ _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n \n                         hmi_data += setup_ret;\n                         hmi_track_offset[i] += setup_ret;\n+                        data_siz -= setup_ret;\n \n                         note[hmi_tmp].length = 0;\n-                        if (*hmi_data > 0x7f) {\n+                        if (data_siz && *hmi_data > 0x7f) {\n                             do {\n+                                if (!data_siz) break;\n                                 note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);\n                                 hmi_data++;\n+                                data_siz--;\n                                 hmi_track_offset[i]++;\n                             } while (*hmi_data > 0x7F);\n                         }\n+                        if (!data_siz) {\n+                            _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n+                            goto _hmi_end;\n+                        }\n                         note[hmi_tmp].length = (note[hmi_tmp].length << 7) | (*hmi_data & 0x7F);\n                         hmi_data++;\n+                        data_siz--;\n                         hmi_track_offset[i]++;\n \n                         if (note[hmi_tmp].length) {\n@@ -293,20 +313,28 @@ _WM_ParseNewHmi(uint8_t *hmi_data, uint32_t hmi_size) {\n                     } else {\n                         hmi_data += setup_ret;\n                         hmi_track_offset[i] += setup_ret;\n+                        data_siz -= setup_ret;\n                     }\n                 }\n \n                 \/\/ get track delta\n                 \/\/ hmi_delta[i] = 0; \/\/ set at start of loop\n-                if (*hmi_data > 0x7f) {\n+                if (data_siz && *hmi_data > 0x7f) {\n                     do {\n+                        if (!data_siz) break;\n                         hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);\n                         hmi_data++;\n+                        data_siz--;\n                         hmi_track_offset[i]++;\n                     } while (*hmi_data > 0x7F);\n                 }\n+                if (!data_siz) {\n+                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMI, \"file too short\", 0);\n+                    goto _hmi_end;\n+                }\n                 hmi_delta[i] = (hmi_delta[i] << 7) | (*hmi_data & 0x7F);\n                 hmi_data++;\n+                data_siz--;\n                 hmi_track_offset[i]++;\n             } while (!hmi_delta[i]);\n             if ((!smallest_delta) || (smallest_delta > hmi_delta[i])) {\ndiff --git a\/src\/f_hmp.c b\/src\/f_hmp.c\nindex 565d1fe..f0c64e4 100644\n--- a\/src\/f_hmp.c\n+++ b\/src\/f_hmp.c\n@@ -235,6 +235,7 @@ _WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) {\n \n         \/\/ goto start of next chunk\n         hmp_data = hmp_chunk[i] + chunk_length[i];\n+        chunk_length[i] -= chunk_ofs[i];\n         hmp_chunk[i] += chunk_ofs[i]++;\n         chunk_end[i] = 0;\n     }\n@@ -273,10 +274,11 @@ _WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) {\n                     \/\/ Reserved for loop markers\n                     \/\/ TODO: still deciding what to do about these\n                     hmp_chunk[i] += 3;\n+                    chunk_length[i] -= 3;\n                 } else {\n                     uint32_t setup_ret = 0;\n \n-                    if ((setup_ret = _WM_SetupMidiEvent(hmp_mdi, hmp_chunk[i], 0)) == 0) {\n+                    if ((setup_ret = _WM_SetupMidiEvent(hmp_mdi, hmp_chunk[i], chunk_length[i], 0)) == 0) {\n                         goto _hmp_end;\n                     }\n \n@@ -284,6 +286,7 @@ _WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) {\n                         \/* End of Chunk *\/\n                         end_of_chunks++;\n                         chunk_end[i] = 1;\n+                        chunk_length[i] -= 3;\n                         hmp_chunk[i] += 3;\n                         goto NEXT_CHUNK;\n                     } else if ((hmp_chunk[i][0] == 0xff) && (hmp_chunk[i][1] == 0x51) && (hmp_chunk[i][2] == 0x03)) {\n@@ -296,18 +299,26 @@ _WM_ParseNewHmp(uint8_t *hmp_data, uint32_t hmp_size) {\n                         fprintf(stderr,\"DEBUG: Tempo change %f\\r\\n\", tempo_f);\n                     }\n                     hmp_chunk[i] += setup_ret;\n+                    chunk_length[i] -= setup_ret;\n                 }\n                 var_len_shift = 0;\n                 chunk_delta[i] = 0;\n-                if (*hmp_chunk[i] < 0x80) {\n+                if (chunk_length[i] && *hmp_chunk[i] < 0x80) {\n                     do {\n+                        if (! chunk_length[i]) break;\n                         chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift);\n                         var_len_shift += 7;\n                         hmp_chunk[i]++;\n+                        chunk_length[i]--;\n                     } while (*hmp_chunk[i] < 0x80);\n                 }\n+                if (! chunk_length[i]) {\n+                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_HMP, \"file too short\", 0);\n+                    goto _hmp_end;\n+                }\n                 chunk_delta[i] = chunk_delta[i] + ((*hmp_chunk[i] & 0x7F) << var_len_shift);\n                 hmp_chunk[i]++;\n+                chunk_length[i]--;\n             } while (!chunk_delta[i]);\n \n             if ((!smallest_delta) || (smallest_delta > chunk_delta[i])) {\ndiff --git a\/src\/f_midi.c b\/src\/f_midi.c\nindex 6b52932..c8f278b 100644\n--- a\/src\/f_midi.c\n+++ b\/src\/f_midi.c\n@@ -43,8 +43,8 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n \n     uint32_t tmp_val;\n     uint32_t midi_type;\n-    uint32_t track_size;\n     uint8_t **tracks;\n+    uint32_t *track_size;\n     uint32_t end_of_tracks = 0;\n     uint32_t no_tracks;\n     uint32_t i;\n@@ -56,15 +56,11 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n     float sample_count_f = 0.0;\n     float sample_remainder = 0.0;\n     uint8_t *sysex_store = NULL;\n-\/\/  uint32_t sysex_store_len = 0;\n \n     uint32_t *track_delta;\n     uint8_t *track_end;\n     uint32_t smallest_delta = 0;\n     uint32_t subtract_delta = 0;\n-\/\/  uint32_t tmp_length = 0;\n-\/\/  uint8_t current_event = 0;\n-\/\/  uint8_t current_event_ch = 0;\n     uint8_t *running_event;\n     uint32_t setup_ret = 0;\n \n@@ -151,6 +147,7 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n     _WM_midi_setup_divisions(mdi,divisions);\n \n     tracks = malloc(sizeof(uint8_t *) * no_tracks);\n+    track_size = malloc(sizeof(uint32_t) * no_tracks);\n     track_delta = malloc(sizeof(uint32_t) * no_tracks);\n     track_end = malloc(sizeof(uint8_t) * no_tracks);\n     running_event = malloc(sizeof(uint8_t) * no_tracks);\n@@ -168,28 +165,30 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n         midi_data += 4;\n         midi_size -= 4;\n \n-        track_size = *midi_data++ << 24;\n-        track_size |= *midi_data++ << 16;\n-        track_size |= *midi_data++ << 8;\n-        track_size |= *midi_data++;\n+        \/* track size *\/\n+        tmp_val = *midi_data++ << 24;\n+        tmp_val |= *midi_data++ << 16;\n+        tmp_val |= *midi_data++ << 8;\n+        tmp_val |= *midi_data++;\n         midi_size -= 4;\n-        if (midi_size < track_size) {\n+        if (midi_size < tmp_val) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n             goto _end;\n         }\n-        if (track_size < 3) {\n+        if (tmp_val < 3) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(bad track size)\", 0);\n             goto _end;\n         }\n-        if ((midi_data[track_size - 3] != 0xFF)\n-                || (midi_data[track_size - 2] != 0x2F)\n-                || (midi_data[track_size - 1] != 0x00)) {\n+        if ((midi_data[tmp_val - 3] != 0xFF)\n+                || (midi_data[tmp_val - 2] != 0x2F)\n+                || (midi_data[tmp_val - 1] != 0x00)) {\n             _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing EOT)\", 0);\n             goto _end;\n         }\n         tracks[i] = midi_data;\n-        midi_data += track_size;\n-        midi_size -= track_size;\n+        track_size[i] = tmp_val;\n+        midi_data += tmp_val;\n+        midi_size -= tmp_val;\n         track_end[i] = 0;\n         running_event[i] = 0;\n         track_delta[i] = 0;\n@@ -197,9 +196,11 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n         while (*tracks[i] > 0x7F) {\n             track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n             tracks[i]++;\n+            track_size[i]--;\n         }\n         track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n         tracks[i]++;\n+        track_size[i]--;\n \n         if (midi_type == 1 ) {\n             if (track_delta[i] < smallest_delta) {\n@@ -243,7 +244,7 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n                     }\n                 }\n                 do {\n-                    setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], running_event[i]);\n+                    setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], track_size[i], running_event[i]);\n                     if (setup_ret == 0) {\n                         goto _end;\n                     }\n@@ -259,6 +260,7 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n                             end_of_tracks++;\n                             track_end[i] = 1;\n                             tracks[i] += 3;\n+                            track_size[i] -= 3;\n                             goto NEXT_TRACK;\n                         } else if ((tracks[i][0] == 0xff) && (tracks[i][1] == 0x51) && (tracks[i][2] == 0x03)) {\n                             \/* Tempo *\/\n@@ -270,15 +272,23 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n                         }\n                     }\n                     tracks[i] += setup_ret;\n+                    track_size[i] -= setup_ret;\n \n                     if (*tracks[i] > 0x7f) {\n                         do {\n+                            if (!track_size[i]) break;\n                             track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                             tracks[i]++;\n+                            track_size[i]--;\n                         } while (*tracks[i] > 0x7f);\n                     }\n+                    if (!track_size[i]) {\n+                        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n+                        goto _end;\n+                    }\n                     track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                     tracks[i]++;\n+                    track_size[i]--;\n                 } while (!track_delta[i]);\n                 if ((!smallest_delta) || (smallest_delta > track_delta[i])) {\n                     smallest_delta = track_delta[i];\n@@ -304,7 +314,7 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n         for (i = 0; i < no_tracks; i++) {\n             running_event[i] = 0;\n             do {\n-                setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], running_event[i]);\n+                setup_ret = _WM_SetupMidiEvent(mdi, tracks[i], track_size[i], running_event[i]);\n                 if (setup_ret == 0) {\n                     goto _end;\n                 }\n@@ -329,16 +339,24 @@ _WM_ParseNewMidi(uint8_t *midi_data, uint32_t midi_size) {\n                     }\n                 }\n                 tracks[i] += setup_ret;\n+                track_size[i] -= setup_ret;\n \n                 track_delta[i] = 0;\n                 if (*tracks[i] > 0x7f) {\n                     do {\n+                        if (!track_size[i]) break;\n                         track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                         tracks[i]++;\n+                        track_size[i]--;\n                     } while (*tracks[i] > 0x7f);\n                 }\n+                if (!track_size[i]) {\n+                    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n+                    goto _end;\n+                }\n                 track_delta[i] = (track_delta[i] << 7) + (*tracks[i] & 0x7F);\n                 tracks[i]++;\n+                track_size[i]--;\n \n                 sample_count_f = (((float) track_delta[i] * samples_per_delta_f)\n                                   + sample_remainder);\n@@ -372,6 +390,7 @@ _end:   free(sysex_store);\n     free(track_delta);\n     free(running_event);\n     free(tracks);\n+    free(track_size);\n     if (mdi->reverb) return (mdi);\n     _WM_freeMDI(mdi);\n     return (NULL);\ndiff --git a\/src\/f_mus.c b\/src\/f_mus.c\nindex 23baed5..b606150 100644\n--- a\/src\/f_mus.c\n+++ b\/src\/f_mus.c\n@@ -61,7 +61,8 @@ _WM_ParseNewMus(uint8_t *mus_data, uint32_t mus_size) {\n     float tempo_f = 0.0;\n     uint16_t mus_freq = 0;\n     float samples_per_tick_f = 0.0;\n-    uint8_t mus_event[] = { 0, 0, 0, 0 };\n+#define MUS_SZ 4\n+    uint8_t mus_event[MUS_SZ] = { 0, 0, 0, 0 };\n     uint8_t mus_event_size = 0;\n     uint8_t mus_prev_vol[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n     uint32_t setup_ret = 0;\n@@ -314,7 +315,7 @@ _WM_ParseNewMus(uint8_t *mus_data, uint32_t mus_size) {\n                 break;\n         }\n \n-        setup_ret = _WM_SetupMidiEvent(mus_mdi, (uint8_t *)mus_event, 0);\n+        setup_ret = _WM_SetupMidiEvent(mus_mdi, (uint8_t *)mus_event, MUS_SZ, 0);\n         if (setup_ret == 0) {\n             goto _mus_end;\n         }\ndiff --git a\/src\/f_xmidi.c b\/src\/f_xmidi.c\nindex 62c7131..fb3c6d1 100644\n--- a\/src\/f_xmidi.c\n+++ b\/src\/f_xmidi.c\n@@ -267,7 +267,7 @@ struct _mdi *_WM_ParseNewXmi(uint8_t *xmi_data, uint32_t xmi_size) {\n                             setup_ret = 6;\n                             goto _XMI_Next_Event;\n                         }\n-                        if ((setup_ret = _WM_SetupMidiEvent(xmi_mdi,xmi_data,0)) == 0) {\n+                        if ((setup_ret = _WM_SetupMidiEvent(xmi_mdi,xmi_data, xmi_size, 0)) == 0) {\n                             goto _xmi_end;\n                         }\n \ndiff --git a\/src\/internal_midi.c b\/src\/internal_midi.c\nindex cb7301d..f67f71a 100644\n--- a\/src\/internal_midi.c\n+++ b\/src\/internal_midi.c\n@@ -1962,7 +1962,7 @@ void _WM_freeMDI(struct _mdi *mdi) {\n     free(mdi);\n }\n \n-uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t running_event) {\n+uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint32_t siz, uint8_t running_event) {\n     \/*\n      Only add standard MIDI and Sysex events in here.\n      Non-standard events need to be handled by calling function\n@@ -1978,10 +1978,13 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n     uint8_t data_2 = 0;\n     char *text = NULL;\n \n+    if (!siz) goto shortbuf;\n+\n     if (event_data[0] >= 0x80) {\n         command = *event_data & 0xf0;\n         channel = *event_data++ & 0x0f;\n         ret_cnt++;\n+        if (--siz == 0) goto shortbuf;\n     } else {\n         command = running_event & 0xf0;\n         channel = running_event & 0x0f;\n@@ -1990,6 +1993,7 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n     switch(command) {\n         case 0x80:\n         _SETUP_NOTEOFF:\n+            if (siz < 2) goto shortbuf;\n             data_1 = *event_data++;\n             data_2 = *event_data++;\n             _WM_midi_setup_noteoff(mdi, channel, data_1, data_2);\n@@ -1997,18 +2001,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n             break;\n         case 0x90:\n             if (event_data[1] == 0) goto _SETUP_NOTEOFF; \/* A velocity of 0 in a note on is actually a note off *\/\n+            if (siz < 2) goto shortbuf;\n             data_1 = *event_data++;\n             data_2 = *event_data++;\n             midi_setup_noteon(mdi, channel, data_1, data_2);\n             ret_cnt += 2;\n             break;\n         case 0xa0:\n+            if (siz < 2) goto shortbuf;\n             data_1 = *event_data++;\n             data_2 = *event_data++;\n             midi_setup_aftertouch(mdi, channel, data_1, data_2);\n             ret_cnt += 2;\n             break;\n         case 0xb0:\n+            if (siz < 2) goto shortbuf;\n             data_1 = *event_data++;\n             data_2 = *event_data++;\n             midi_setup_control(mdi, channel, data_1, data_2);\n@@ -2025,6 +2032,7 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n             ret_cnt++;\n             break;\n         case 0xe0:\n+            if (siz < 2) goto shortbuf;\n             data_1 = *event_data++;\n             data_2 = *event_data++;\n             midi_setup_pitch(mdi, channel, ((data_2 << 7) | (data_1 & 0x7f)));\n@@ -2041,6 +2049,7 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Sequence Number\n                      We only setting this up here for WM_Event2Midi function\n                      *\/\n+                    if (siz < 4) goto shortbuf;\n                     midi_setup_sequenceno(mdi, ((event_data[2] << 8) + event_data[3]));\n                     ret_cnt += 4;\n                 } else if (event_data[0] == 0x01) {\n@@ -2048,16 +2057,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     \/* Get Length *\/\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; \/* bad file? *\/\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2071,16 +2085,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     \/* Get Length *\/\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; \/* bad file? *\/\n \n                     \/* Copy copyright info in the getinfo struct *\/\n                     if (mdi->extra_info.copyright) {\n@@ -2107,16 +2126,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     \/* Get Length *\/\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; \/* bad file? *\/\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2130,16 +2154,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     \/* Get Length *\/\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; \/* bad file? *\/\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2153,16 +2182,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     \/* Get Length *\/\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; \/* bad file? *\/\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2176,16 +2210,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     \/* Get Length *\/\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; \/* bad file? *\/\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2199,16 +2238,21 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                     \/* Get Length *\/\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     event_data++;\n                     ret_cnt++;\n+                    if (--siz < tmp_length) goto shortbuf;\n+                    if (!tmp_length) break; \/* bad file? *\/\n \n                     text = malloc(tmp_length + 1);\n                     memcpy(text, event_data, tmp_length);\n@@ -2222,6 +2266,7 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Channel Prefix\n                      We only setting this up here for WM_Event2Midi function\n                      *\/\n+                    if (siz < 3) goto shortbuf;\n                     midi_setup_channelprefix(mdi, event_data[2]);\n                     ret_cnt += 3;\n                 } else if ((event_data[0] == 0x21) && (event_data[1] == 0x01)) {\n@@ -2229,6 +2274,7 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Port Prefix\n                      We only setting this up here for WM_Event2Midi function\n                      *\/\n+                    if (siz < 3) goto shortbuf;\n                     midi_setup_portprefix(mdi, event_data[2]);\n                     ret_cnt += 3;\n                 } else if ((event_data[0] == 0x2F) && (event_data[1] == 0x00)) {\n@@ -2237,6 +2283,7 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Deal with this inside calling function\n                      We only setting this up here for _WM_Event2Midi function\n                      *\/\n+                    if (siz < 2) goto shortbuf;\n                     _WM_midi_setup_endoftrack(mdi);\n                     ret_cnt += 2;\n                 } else if ((event_data[0] == 0x51) && (event_data[1] == 0x03)) {\n@@ -2245,9 +2292,11 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Deal with this inside calling function.\n                      We only setting this up here for _WM_Event2Midi function\n                      *\/\n+                    if (siz < 5) goto shortbuf;\n                     _WM_midi_setup_tempo(mdi, ((event_data[2] << 16) + (event_data[3] << 8) + event_data[4]));\n                     ret_cnt += 5;\n                 } else if ((event_data[0] == 0x54) && (event_data[1] == 0x05)) {\n+                    if (siz < 7) goto shortbuf;\n                     \/*\n                      SMPTE Offset\n                      We only setting this up here for WM_Event2Midi function\n@@ -2265,6 +2314,7 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Time Signature\n                      We only setting this up here for WM_Event2Midi function\n                      *\/\n+                    if (siz < 6) goto shortbuf;\n                     midi_setup_timesignature(mdi, ((event_data[2] << 24) + (event_data[3] << 16) + (event_data[4] << 8) + event_data[5]));\n                     ret_cnt += 6;\n                 } else if ((event_data[0] == 0x59) && (event_data[1] == 0x02)) {\n@@ -2272,6 +2322,7 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      Key Signature\n                      We only setting this up here for WM_Event2Midi function\n                      *\/\n+                    if (siz < 4) goto shortbuf;\n                     midi_setup_keysignature(mdi, ((event_data[2] << 8) + event_data[3]));\n                     ret_cnt += 4;\n                 } else {\n@@ -2280,16 +2331,20 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n                      *\/\n                     event_data++;\n                     ret_cnt++;\n-                    if (*event_data > 0x7f) {\n+                    if (--siz && *event_data > 0x7f) {\n                         do {\n+                            if (!siz) break;\n                             tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                             event_data++;\n+                            siz--;\n                             ret_cnt++;\n                         } while (*event_data > 0x7f);\n                     }\n+                    if (!siz) goto shortbuf;\n                     tmp_length = (tmp_length << 7) + (*event_data & 0x7f);\n                     ret_cnt++;\n                     ret_cnt += tmp_length;\n+                    if (--siz < tmp_length) goto shortbuf;\n                 }\n \n             } else if ((channel == 0) || (channel == 7)) {\n@@ -2301,15 +2356,19 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n \n                 if (*event_data > 0x7f) {\n                     do {\n+                        if (!siz) break;\n                         sysex_len = (sysex_len << 7) + (*event_data & 0x7F);\n                         event_data++;\n+                        siz--;\n                         ret_cnt++;\n                     } while (*event_data > 0x7f);\n                 }\n+                if (!siz) goto shortbuf;\n                 sysex_len = (sysex_len << 7) + (*event_data & 0x7F);\n                 event_data++;\n-                if (!sysex_len) break;\n                 ret_cnt++;\n+                if (--siz < sysex_len) goto shortbuf;\n+                if (!sysex_len) break; \/* bad file? *\/\n \n                 sysex_store = malloc(sizeof(uint8_t) * sysex_len);\n                 memcpy(sysex_store, event_data, sysex_len);\n@@ -2381,5 +2440,9 @@ uint32_t _WM_SetupMidiEvent(struct _mdi *mdi, uint8_t * event_data, uint8_t runn\n     if (ret_cnt == 0)\n         _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(missing event)\", 0);\n     return ret_cnt;\n+\n+shortbuf:\n+    _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n+    return 0;\n }\n \n","owner":"Mindwerks","repo":"wildmidi","source":"cve"},{"CVE_ID":"CVE-2018-17294","CWE_ID":"125","category":"security","commit_id":"5e4089659bb49b3095fa541fa6387b4c40d7396e","commit_message":"From 5e4089659bb49b3095fa541fa6387b4c40d7396e Mon Sep 17 00:00:00 2001\nFrom: Christian Egli <christian.egli@sbs.ch>\nDate: Mon, 3 Sep 2018 11:52:24 +0200\nSubject: [PATCH] Fix a buffer overflow\n\nFixes #635\n\nThanks to HongxuChen for reporting it\n---\n liblouis\/lou_translateString.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/liblouis\/lou_translateString.c b\/liblouis\/lou_translateString.c\nindex dc1cb7ad2..7c207f453 100644\n--- a\/liblouis\/lou_translateString.c\n+++ b\/liblouis\/lou_translateString.c\n@@ -354,7 +354,9 @@ matchCurrentInput(\n \t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n \tint k;\n \tint kk = pos;\n-\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n+\tfor (k = passIC + 2;\n+\t\t\t((k < passIC + 2 + passInstructions[passIC + 1]) && (kk < input->length));\n+\t\t\tk++)\n \t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n \t\t\treturn 0;\n \treturn 1;\n","owner":"liblouis","repo":"liblouis","source":"cve"},{"CVE_ID":"CVE-2016-10165","CWE_ID":"125","category":"security","commit_id":"5ca71a7bc18b6897ab21d815d15e218e204581e2","commit_message":"From 5ca71a7bc18b6897ab21d815d15e218e204581e2 Mon Sep 17 00:00:00 2001\nFrom: Marti <marti.maria@tktbrainpower.com>\nDate: Mon, 15 Aug 2016 23:31:39 +0200\nSubject: [PATCH] Added an extra check to MLU bounds\n\nThanks to Ibrahim el-sayed for spotting the bug\n---\n src\/cmstypes.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/src\/cmstypes.c b\/src\/cmstypes.c\nindex cb61860..c7328b9 100644\n--- a\/src\/cmstypes.c\n+++ b\/src\/cmstypes.c\n@@ -1460,6 +1460,7 @@ void *Type_MLU_Read(struct _cms_typehandler_struct* self, cmsIOHANDLER* io, cmsU\n \n         \/\/ Check for overflow\n         if (Offset < (SizeOfHeader + 8)) goto Error;\n+        if ((Offset + Len) > SizeOfTag + 8) goto Error;\n \n         \/\/ True begin of the string\n         BeginOfThisString = Offset - SizeOfHeader - 8;\n","owner":"mm2","repo":"Little-CMS","source":"cve"},{"CVE_ID":"CVE-2018-7729","CWE_ID":"125","category":"security","commit_id":"baa4b8a02c1ffab9645d13f0bfb1c0d10d311a0c","commit_message":"From baa4b8a02c1ffab9645d13f0bfb1c0d10d311a0c Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Hubert=20Figui=C3=A8re?= <hub@figuiere.net>\nDate: Sun, 25 Feb 2018 02:29:31 -0500\nSubject: Bug 105206 - Fix a buffer overflow in the PS Handler\n\n---\n XMPFiles\/source\/FileHandlers\/PostScript_Handler.cpp | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/XMPFiles\/source\/FileHandlers\/PostScript_Handler.cpp b\/XMPFiles\/source\/FileHandlers\/PostScript_Handler.cpp\nindex d21ab8d..9ed0071 100644\n--- a\/XMPFiles\/source\/FileHandlers\/PostScript_Handler.cpp\n+++ b\/XMPFiles\/source\/FileHandlers\/PostScript_Handler.cpp\n@@ -885,7 +885,9 @@ void PostScript_MetaHandler::ParsePSFile()\n \t\t\t\t\tif (CheckBytes ( ioBuf.ptr, Uns8Ptr(\"iler\"), 4 ))\n \t\t\t\t\t{\n \t\t\t\t\t\tioBuf.ptr+=4;\n-\t\t\t\t\t\twhile(!IsNewline(*ioBuf.ptr)) ++ioBuf.ptr;\n+\t\t\t\t\t\twhile(ioBuf.ptr < ioBuf.limit &&\n+                                                      !IsNewline(*ioBuf.ptr))\n+                                                    ++ioBuf.ptr;\n \t\t\t\t\t\tsetTokenInfo(kPS_Trailer,begStartpos,ioBuf.filePos+ioBuf.ptr-ioBuf.data-begStartpos);\n \t\t\t\t\t}\n \t\t\t\t}\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-13006","CWE_ID":"125","category":"security","commit_id":"bceb03fd2be95097a7b409ea59914f332fb6bc86","commit_message":"From bceb03fd2be95097a7b409ea59914f332fb6bc86 Mon Sep 17 00:00:00 2001\nFrom: Aurelien David <aurelien.david@telecom-paristech.fr>\nDate: Thu, 28 Jun 2018 13:34:08 +0200\nSubject: [PATCH] fixed 2 possible heap overflows (inc. #1088)\n\n---\n include\/gpac\/internal\/isomedia_dev.h |  2 +-\n src\/isomedia\/box_code_base.c         |  2 +-\n src\/isomedia\/box_dump.c              | 14 +++++++-------\n 3 files changed, 9 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/include\/gpac\/internal\/isomedia_dev.h b\/include\/gpac\/internal\/isomedia_dev.h\nindex c8a5b9f2e..029662607 100644\n--- a\/include\/gpac\/internal\/isomedia_dev.h\n+++ b\/include\/gpac\/internal\/isomedia_dev.h\n@@ -3710,7 +3710,7 @@ GF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample_from_data(char *\n \t\tchar __ptype[5];\\\n \t\tstrcpy(__ptype, gf_4cc_to_str(__parent->type) );\\\n \t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] extra box %s found in %s, deleting\\n\", gf_4cc_to_str(__abox->type), __ptype)); \\\n-\t\tgf_isom_box_del(a);\\\n+\t\tgf_isom_box_del(__abox);\\\n \t\treturn GF_OK;\\\n \t}\n \ndiff --git a\/src\/isomedia\/box_code_base.c b\/src\/isomedia\/box_code_base.c\nindex 2cb81ef3f..0f5b40f7f 100644\n--- a\/src\/isomedia\/box_code_base.c\n+++ b\/src\/isomedia\/box_code_base.c\n@@ -632,7 +632,7 @@ GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)\n \n \t\/\/then get the break\n \ti = 0;\n-\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n+\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n \t\ti++;\n \t}\n \t\/\/check the data is consistent\ndiff --git a\/src\/isomedia\/box_dump.c b\/src\/isomedia\/box_dump.c\nindex a7371be03..c77847928 100644\n--- a\/src\/isomedia\/box_dump.c\n+++ b\/src\/isomedia\/box_dump.c\n@@ -484,7 +484,7 @@ GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n {\n \tGF_HandlerBox *p = (GF_HandlerBox *)a;\n \tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n-\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n+\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8)-1) {\n \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n \t} else {\n \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n@@ -4157,9 +4157,9 @@ static void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)\n \t\tfprintf(trace, \" maxPicWidth=\\\"%u\\\" maxPicHeight=\\\"%u\\\"\", op->maxPicWidth, op->maxPicHeight);\n \t\tfprintf(trace, \" maxChromaFormat=\\\"%u\\\" maxBitDepth=\\\"%u\\\"\", op->maxChromaFormat, op->maxBitDepth);\n \t\tfprintf(trace, \" frame_rate_info_flag=\\\"%u\\\" bit_rate_info_flag=\\\"%u\\\"\", op->frame_rate_info_flag, op->bit_rate_info_flag);\n-\t\tif (op->frame_rate_info_flag) \n+\t\tif (op->frame_rate_info_flag)\n \t\t\tfprintf(trace, \" avgFrameRate=\\\"%u\\\" constantFrameRate=\\\"%u\\\"\", op->avgFrameRate, op->constantFrameRate);\n-\t\tif (op->bit_rate_info_flag) \n+\t\tif (op->bit_rate_info_flag)\n \t\t\tfprintf(trace, \" maxBitRate=\\\"%u\\\" avgBitRate=\\\"%u\\\"\", op->maxBitRate, op->avgBitRate);\n \t\tfprintf(trace, \"\/>\\n\");\n \t}\n@@ -4261,14 +4261,14 @@ static void nalm_dump(FILE * trace, char *data, u32 data_size)\n \t\tfprintf(trace, \"<\/NALUMap>\\n\");\n \t\treturn;\n \t}\n-\t\n+\n \tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n \tgf_bs_read_int(bs, 6);\n \tlarge_size = gf_bs_read_int(bs, 1);\n \trle = gf_bs_read_int(bs, 1);\n \tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n \tfprintf(trace, \"<NALUMap rle=\\\"%d\\\" large_size=\\\"%d\\\">\\n\", rle, large_size);\n-\t\n+\n \twhile (entry_count) {\n \t\tu32 ID;\n \t\tfprintf(trace, \"<NALUMapEntry \");\n@@ -4338,7 +4338,7 @@ GF_Err sgpd_dump(GF_Box *a, FILE * trace)\n \t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n \t\t\ttrif_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n \t\t\tbreak;\n-\t\t\t\n+\n \t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n \t\t\tnalm_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n \t\t\tbreak;\n@@ -4507,7 +4507,7 @@ GF_Err tenc_dump(GF_Box *a, FILE * trace)\n \t\tfprintf(trace, \"\\\"  KID=\\\"\");\n \t}\n \tdump_data_hex(trace, (char *) ptr->KID, 16);\n-\tif (ptr->version) \n+\tif (ptr->version)\n \t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);\n \tfprintf(trace, \"\\\">\\n\");\n \tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);\n","owner":"gpac","repo":"gpac","source":"cve"},{"CVE_ID":"CVE-2016-8689","CWE_ID":"125","category":"security","commit_id":"7f17c791dcfd8c0416e2cd2485b19410e47ef126","commit_message":"From 7f17c791dcfd8c0416e2cd2485b19410e47ef126 Mon Sep 17 00:00:00 2001\nFrom: Tim Kientzle <kientzle@acm.org>\nDate: Sun, 18 Sep 2016 18:14:58 -0700\nSubject: [PATCH] Issue 761:  Heap overflow reading corrupted 7Zip files\n\nThe sample file that demonstrated this had multiple 'EmptyStream'\nattributes.  The first one ended up being used to calculate\ncertain statistics, then was overwritten by the second which\nwas incompatible with those statistics.\n\nThe fix here is to reject any header with multiple EmptyStream\nattributes.  While here, also reject headers with multiple\nEmptyFile, AntiFile, Name, or Attributes markers.\n---\n libarchive\/archive_read_support_format_7zip.c | 10 ++++++++++\n 1 file changed, 10 insertions(+)\n\n","diff_code":"diff --git a\/libarchive\/archive_read_support_format_7zip.c b\/libarchive\/archive_read_support_format_7zip.c\nindex 1dfe52b85..c0a536c4a 100644\n--- a\/libarchive\/archive_read_support_format_7zip.c\n+++ b\/libarchive\/archive_read_support_format_7zip.c\n@@ -2431,6 +2431,8 @@ read_Header(struct archive_read *a, struct _7z_header_info *h,\n \n \t\tswitch (type) {\n \t\tcase kEmptyStream:\n+\t\t\tif (h->emptyStreamBools != NULL)\n+\t\t\t\treturn (-1);\n \t\t\th->emptyStreamBools = calloc((size_t)zip->numFiles,\n \t\t\t    sizeof(*h->emptyStreamBools));\n \t\t\tif (h->emptyStreamBools == NULL)\n@@ -2451,6 +2453,8 @@ read_Header(struct archive_read *a, struct _7z_header_info *h,\n \t\t\t\t\treturn (-1);\n \t\t\t\tbreak;\n \t\t\t}\n+\t\t\tif (h->emptyFileBools != NULL)\n+\t\t\t\treturn (-1);\n \t\t\th->emptyFileBools = calloc(empty_streams,\n \t\t\t    sizeof(*h->emptyFileBools));\n \t\t\tif (h->emptyFileBools == NULL)\n@@ -2465,6 +2469,8 @@ read_Header(struct archive_read *a, struct _7z_header_info *h,\n \t\t\t\t\treturn (-1);\n \t\t\t\tbreak;\n \t\t\t}\n+\t\t\tif (h->antiBools != NULL)\n+\t\t\t\treturn (-1);\n \t\t\th->antiBools = calloc(empty_streams,\n \t\t\t    sizeof(*h->antiBools));\n \t\t\tif (h->antiBools == NULL)\n@@ -2491,6 +2497,8 @@ read_Header(struct archive_read *a, struct _7z_header_info *h,\n \t\t\tif ((ll & 1) || ll < zip->numFiles * 4)\n \t\t\t\treturn (-1);\n \n+\t\t\tif (zip->entry_names != NULL)\n+\t\t\t\treturn (-1);\n \t\t\tzip->entry_names = malloc(ll);\n \t\t\tif (zip->entry_names == NULL)\n \t\t\t\treturn (-1);\n@@ -2543,6 +2551,8 @@ read_Header(struct archive_read *a, struct _7z_header_info *h,\n \t\t\tif ((p = header_bytes(a, 2)) == NULL)\n \t\t\t\treturn (-1);\n \t\t\tallAreDefined = *p;\n+\t\t\tif (h->attrBools != NULL)\n+\t\t\t\treturn (-1);\n \t\t\th->attrBools = calloc((size_t)zip->numFiles,\n \t\t\t    sizeof(*h->attrBools));\n \t\t\tif (h->attrBools == NULL)\n","owner":"libarchive","repo":"libarchive","source":"cve"},{"CVE_ID":"CVE-2018-14498","CWE_ID":"125","category":"security","commit_id":"9c78a04df4e44ef6487eee99c4258397f4fdca55","commit_message":"From 9c78a04df4e44ef6487eee99c4258397f4fdca55 Mon Sep 17 00:00:00 2001\nFrom: DRC <information@libjpeg-turbo.org>\nDate: Fri, 20 Jul 2018 17:21:36 -0500\nSubject: [PATCH] cjpeg: Fix OOB read caused by malformed 8-bit BMP\n\n... in which one or more of the color indices is out of range for the\nnumber of palette entries.\n\nFix partly borrowed from jpeg-9c.  This commit also adopts Guido's\nJERR_PPM_OUTOFRANGE enum value in lieu of our project-specific\nJERR_PPM_TOOLARGE enum value.\n\nFixes #258\n---\n ChangeLog.md |  5 +++++\n cderror.h    |  5 +++--\n rdbmp.c      | 13 ++++++++++++-\n rdppm.c      | 12 ++++++------\n 4 files changed, 26 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog.md b\/ChangeLog.md\nindex 03f28dabf..41da06021 100644\n--- a\/ChangeLog.md\n+++ b\/ChangeLog.md\n@@ -47,6 +47,11 @@ a 4:2:2 or 4:2:0 JPEG image using the merged (non-fancy) upsampling algorithms\n 7. The new CMake-based build system will now disable the MIPS DSPr2 SIMD\n extensions if it detects that the compiler does not support DSPr2 instructions.\n \n+8. Fixed out-of-bounds read in cjpeg that occurred when attempting to compress\n+a specially-crafted malformed color-index (8-bit-per-sample) BMP file in which\n+some of the samples (color indices) exceeded the bounds of the BMP file's color\n+table.\n+\n \n 1.5.90 (2.0 beta1)\n ==================\ndiff --git a\/cderror.h b\/cderror.h\nindex 37034a986..4f2c7a3e5 100644\n--- a\/cderror.h\n+++ b\/cderror.h\n@@ -2,7 +2,7 @@\n  * cderror.h\n  *\n  * Copyright (C) 1994-1997, Thomas G. Lane.\n- * Modified 2009 by Guido Vollbeding.\n+ * Modified 2009-2017 by Guido Vollbeding.\n  * This file is part of the Independent JPEG Group's software.\n  * For conditions of distribution and use, see the accompanying README.ijg\n  * file.\n@@ -49,6 +49,7 @@ JMESSAGE(JERR_BMP_COLORSPACE, \"BMP output must be grayscale or RGB\")\n JMESSAGE(JERR_BMP_COMPRESSED, \"Sorry, compressed BMPs not yet supported\")\n JMESSAGE(JERR_BMP_EMPTY, \"Empty BMP image\")\n JMESSAGE(JERR_BMP_NOT, \"Not a BMP file - does not start with BM\")\n+JMESSAGE(JERR_BMP_OUTOFRANGE, \"Numeric value out of range in BMP file\")\n JMESSAGE(JTRC_BMP, \"%ux%u 24-bit BMP image\")\n JMESSAGE(JTRC_BMP_MAPPED, \"%ux%u 8-bit colormapped BMP image\")\n JMESSAGE(JTRC_BMP_OS2, \"%ux%u 24-bit OS2 BMP image\")\n@@ -75,8 +76,8 @@ JMESSAGE(JWRN_GIF_NOMOREDATA, \"Ran out of GIF bits\")\n #ifdef PPM_SUPPORTED\n JMESSAGE(JERR_PPM_COLORSPACE, \"PPM output must be grayscale or RGB\")\n JMESSAGE(JERR_PPM_NONNUMERIC, \"Nonnumeric data in PPM file\")\n-JMESSAGE(JERR_PPM_TOOLARGE, \"Integer value too large in PPM file\")\n JMESSAGE(JERR_PPM_NOT, \"Not a PPM\/PGM file\")\n+JMESSAGE(JERR_PPM_OUTOFRANGE, \"Numeric value out of range in PPM file\")\n JMESSAGE(JTRC_PGM, \"%ux%u PGM image\")\n JMESSAGE(JTRC_PGM_TEXT, \"%ux%u text PGM image\")\n JMESSAGE(JTRC_PPM, \"%ux%u PPM image\")\ndiff --git a\/rdbmp.c b\/rdbmp.c\nindex a02cfd909..51af23778 100644\n--- a\/rdbmp.c\n+++ b\/rdbmp.c\n@@ -3,7 +3,7 @@\n  *\n  * This file was part of the Independent JPEG Group's software:\n  * Copyright (C) 1994-1996, Thomas G. Lane.\n- * Modified 2009-2010 by Guido Vollbeding.\n+ * Modified 2009-2017 by Guido Vollbeding.\n  * libjpeg-turbo Modifications:\n  * Modified 2011 by Siarhei Siamashka.\n  * Copyright (C) 2015, 2017-2018, D. R. Commander.\n@@ -72,6 +72,7 @@ typedef struct _bmp_source_struct {\n   JDIMENSION row_width;         \/* Physical width of scanlines in file *\/\n \n   int bits_per_pixel;           \/* remembers 8- or 24-bit format *\/\n+  int cmap_length;              \/* colormap length *\/\n \n   boolean use_inversion_array;  \/* TRUE = preload the whole image, which is\n                                    stored in bottom-up order, and feed it to\n@@ -155,6 +156,7 @@ get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n {\n   bmp_source_ptr source = (bmp_source_ptr)sinfo;\n   register JSAMPARRAY colormap = source->colormap;\n+  int cmaplen = source->cmap_length;\n   JSAMPARRAY image_ptr;\n   register int t;\n   register JSAMPROW inptr, outptr;\n@@ -178,11 +180,15 @@ get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n   if (cinfo->in_color_space == JCS_GRAYSCALE) {\n     for (col = cinfo->image_width; col > 0; col--) {\n       t = GETJSAMPLE(*inptr++);\n+      if (t >= cmaplen)\n+        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n       *outptr++ = colormap[0][t];\n     }\n   } else if (cinfo->in_color_space == JCS_CMYK) {\n     for (col = cinfo->image_width; col > 0; col--) {\n       t = GETJSAMPLE(*inptr++);\n+      if (t >= cmaplen)\n+        ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n       rgb_to_cmyk(colormap[0][t], colormap[1][t], colormap[2][t], outptr,\n                   outptr + 1, outptr + 2, outptr + 3);\n       outptr += 4;\n@@ -197,6 +203,8 @@ get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n     if (aindex >= 0) {\n       for (col = cinfo->image_width; col > 0; col--) {\n         t = GETJSAMPLE(*inptr++);\n+        if (t >= cmaplen)\n+          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n         outptr[rindex] = colormap[0][t];\n         outptr[gindex] = colormap[1][t];\n         outptr[bindex] = colormap[2][t];\n@@ -206,6 +214,8 @@ get_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n     } else {\n       for (col = cinfo->image_width; col > 0; col--) {\n         t = GETJSAMPLE(*inptr++);\n+        if (t >= cmaplen)\n+          ERREXIT(cinfo, JERR_BMP_OUTOFRANGE);\n         outptr[rindex] = colormap[0][t];\n         outptr[gindex] = colormap[1][t];\n         outptr[bindex] = colormap[2][t];\n@@ -539,6 +549,7 @@ start_input_bmp(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n     \/* Allocate space to store the colormap *\/\n     source->colormap = (*cinfo->mem->alloc_sarray)\n       ((j_common_ptr)cinfo, JPOOL_IMAGE, (JDIMENSION)biClrUsed, (JDIMENSION)3);\n+    source->cmap_length = (int)biClrUsed;\n     \/* and read it from the file *\/\n     read_colormap(source, (int)biClrUsed, mapentrysize);\n     \/* account for size of colormap *\/\ndiff --git a\/rdppm.c b\/rdppm.c\nindex f3bb79ef9..87bc33090 100644\n--- a\/rdppm.c\n+++ b\/rdppm.c\n@@ -75,7 +75,7 @@ typedef struct {\n   JSAMPROW pixrow;              \/* compressor input buffer *\/\n   size_t buffer_width;          \/* width of I\/O buffer *\/\n   JSAMPLE *rescale;             \/* => maxval-remapping array, or NULL *\/\n-  int maxval;\n+  unsigned int maxval;\n } ppm_source_struct;\n \n typedef ppm_source_struct *ppm_source_ptr;\n@@ -125,7 +125,7 @@ read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n   }\n \n   if (val > maxval)\n-    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n+    ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n \n   return val;\n }\n@@ -509,7 +509,7 @@ get_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n-      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n+      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n     *ptr++ = rescale[temp];\n   }\n   return 1;\n@@ -536,17 +536,17 @@ get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n-      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n+      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n     *ptr++ = rescale[temp];\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n-      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n+      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n     *ptr++ = rescale[temp];\n     temp  = UCH(*bufferptr++) << 8;\n     temp |= UCH(*bufferptr++);\n     if (temp > maxval)\n-      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n+      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n     *ptr++ = rescale[temp];\n   }\n   return 1;\n","owner":"libjpeg-turbo","repo":"libjpeg-turbo","source":"cve"},{"CVE_ID":"CVE-2017-15932","CWE_ID":"125","category":"security","commit_id":"44ded3ff35b8264f54b5a900cab32ec489d9e5b9","commit_message":"From 44ded3ff35b8264f54b5a900cab32ec489d9e5b9 Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Wed, 25 Oct 2017 18:09:24 +0200\nSubject: [PATCH] Fix #8743 - Crash in ELF version parser on 32bit systems\n\n---\n libr\/bin\/format\/elf\/elf.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libr\/bin\/format\/elf\/elf.c b\/libr\/bin\/format\/elf\/elf.c\nindex e3c852fd33..2248731b38 100644\n--- a\/libr\/bin\/format\/elf\/elf.c\n+++ b\/libr\/bin\/format\/elf\/elf.c\n@@ -748,7 +748,12 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\tverdef->vd_hash = READ32 (dfs, j)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n-\t\tvstart += verdef->vd_aux;\n+\t\tint vdaux = verdef->vd_aux;\n+\t\tif (vdaux < 1) {\n+\t\t\tsdb_free (sdb_verdef);\n+\t\t\tgoto out_error;\n+\t\t}\n+\t\tvstart += vdaux;\n \t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2018-5808","CWE_ID":"125","category":"security","commit_id":"fd6330292501983ac75fe4162275794b18445bd9","commit_message":"From fd6330292501983ac75fe4162275794b18445bd9 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Tue, 24 Apr 2018 15:17:31 +0300\nSubject: [PATCH] Secunia 81800#1: samsumg_load_raw\n\nSecunia 81800#2: find_green\n\nSecunia 81800#3: rollei_load_raw\n\nremove_trailing_spaces: isspace() does not works right with signed non-latin chars\n\nSecunia 81800#5\/6: nikon_coolscan_load_raw\n\nSecunia 81800#4: rollei_load_raw\n---\n dcraw\/dcraw.c             | 157 ++++++++++++++++++++++++++------------\n internal\/dcraw_common.cpp | 156 +++++++++++++++++++++++++------------\n internal\/defines.h        |   1 +\n 3 files changed, 216 insertions(+), 98 deletions(-)\n\n","diff_code":"diff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 1c6bf662..e2b9c7d4 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -251,6 +251,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n \/\/@end DEFINES\n@@ -1511,9 +1512,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1794,7 +1800,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1810,8 +1821,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3857,6 +3871,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3875,11 +3894,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -11081,37 +11106,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -15077,7 +15133,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -15100,14 +15157,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex cfb82a27..b430d3e5 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -1228,9 +1228,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1506,7 +1511,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1522,8 +1532,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3569,6 +3582,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3587,11 +3605,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -9890,37 +9914,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -13739,7 +13794,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -13762,14 +13818,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/defines.h b\/internal\/defines.h\nindex b84e1d28..06e171ec 100644\n--- a\/internal\/defines.h\n+++ b\/internal\/defines.h\n@@ -153,6 +153,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n #define BAYER(row,col) \\\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2016-10071","CWE_ID":"125","category":"security","commit_id":"f3b483e8b054c50149912523b4773687e18afe25","commit_message":"From f3b483e8b054c50149912523b4773687e18afe25 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 14 Feb 2016 09:24:32 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/131\n\n---\n coders\/mat.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/mat.c b\/coders\/mat.c\nindex b451c40d77..b81dc6880e 100644\n--- a\/coders\/mat.c\n+++ b\/coders\/mat.c\n@@ -875,7 +875,7 @@ RestoreMSCWarning\n       }\n \n   \/* ----- Load raster data ----- *\/\n-    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(unsigned char));    \/* Ldblk was set in the check phase *\/\n+    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    \/* Ldblk was set in the check phase *\/\n     if (BImgBuff == NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n \n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-10197","CWE_ID":"125","category":"security","commit_id":"ec65c42052d95d2c23d1d837136d1cf1d9ecef9e","commit_message":"From ec65c42052d95d2c23d1d837136d1cf1d9ecef9e Mon Sep 17 00:00:00 2001\nFrom: Azat Khuzhin <a3at.mail@gmail.com>\nDate: Fri, 25 Mar 2016 00:33:47 +0300\nSubject: [PATCH] evdns: fix searching empty hostnames\n\nFrom #332:\n  Here follows a bug report by **Guido Vranken** via the _Tor bug bounty program_. Please credit Guido accordingly.\n\n  ## Bug report\n\n  The DNS code of Libevent contains this rather obvious OOB read:\n\n  ```c\n  static char *\n  search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n      const size_t base_len = strlen(base_name);\n      const char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n  ```\n\n  If the length of ```base_name``` is 0, then line 3125 reads 1 byte before the buffer. This will trigger a crash on ASAN-protected builds.\n\n  To reproduce:\n\n  Build libevent with ASAN:\n  ```\n  $ CFLAGS='-fomit-frame-pointer -fsanitize=address' .\/configure && make -j4\n  ```\n  Put the attached ```resolv.conf``` and ```poc.c``` in the source directory and then do:\n\n  ```\n  $ gcc -fsanitize=address -fomit-frame-pointer poc.c .libs\/libevent.a\n  $ .\/a.out\n  =================================================================\n  ==22201== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60060000efdf at pc 0x4429da bp 0x7ffe1ed47300 sp 0x7ffe1ed472f8\n  READ of size 1 at 0x60060000efdf thread T0\n  ```\n\nP.S. we can add a check earlier, but since this is very uncommon, I didn't add it.\n\nFixes: #332\n---\n evdns.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/evdns.c b\/evdns.c\nindex 905ff6b51..e9dbc35c6 100644\n--- a\/evdns.c\n+++ b\/evdns.c\n@@ -3175,9 +3175,12 @@ search_set_from_hostname(struct evdns_base *base) {\n static char *\n search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n \tconst size_t base_len = strlen(base_name);\n-\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n+\tchar need_to_append_dot;\n \tstruct search_domain *dom;\n \n+\tif (!base_len) return NULL;\n+\tneed_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n+\n \tfor (dom = state->head; dom; dom = dom->next) {\n \t\tif (!n--) {\n \t\t\t\/* this is the postfix we want *\/\n","owner":"libevent","repo":"libevent","source":"cve"},{"CVE_ID":"CVE-2016-7525","CWE_ID":"125","category":"security","commit_id":"5f16640725b1225e6337c62526e6577f0f88edb8","commit_message":"From 5f16640725b1225e6337c62526e6577f0f88edb8 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Sat, 6 Feb 2016 12:26:49 +0100\nSubject: [PATCH] Fixed head buffer overflow reported in:\n https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/98\n\n---\n coders\/psd.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex ba9bbba660..d8fd950311 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -575,7 +575,7 @@ static inline MagickSizeType GetPSDSize(const PSDInfo *psd_info,Image *image)\n static inline size_t GetPSDRowSize(Image *image)\n {\n   if (image->depth == 1)\n-    return((image->columns+7)\/8);\n+    return(((image->columns+7)\/8)*GetPSDPacketSize(image));\n   else\n     return(image->columns*GetPSDPacketSize(image));\n }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2019-10714","CWE_ID":"125","category":"security","commit_id":"58d9c46929ca0828edde34d263700c3a5fe8dc3c","commit_message":"From 58d9c46929ca0828edde34d263700c3a5fe8dc3c Mon Sep 17 00:00:00 2001\nFrom: Cristy <mikayla-grace@urban-warrior.org>\nDate: Mon, 4 Mar 2019 19:59:09 -0500\nSubject: [PATCH] ...\n\n---\n MagickCore\/locale.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/MagickCore\/locale.c b\/MagickCore\/locale.c\nindex 4bcab6df3e..943557e381 100644\n--- a\/MagickCore\/locale.c\n+++ b\/MagickCore\/locale.c\n@@ -1521,7 +1521,7 @@ MagickExport void LocaleLower(char *string)\n *\/\n MagickExport int LocaleLowercase(const int c)\n {\n-  if (c < 0)\n+  if (c == EOF)\n     return(c);\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n@@ -1661,7 +1661,7 @@ MagickExport void LocaleUpper(char *string)\n *\/\n MagickExport int LocaleUppercase(const int c)\n {\n-  if (c < 0)\n+  if (c == EOF)\n     return(c);\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-18313","CWE_ID":"125","category":"security","commit_id":"43b2f4ef399e2fd7240b4eeb0658686ad95f8e62","commit_message":"From 43b2f4ef399e2fd7240b4eeb0658686ad95f8e62 Mon Sep 17 00:00:00 2001\nFrom: Karl Williamson <khw@cpan.org>\nDate: Sat, 25 Mar 2017 15:00:22 -0600\nSubject: [PATCH] regcomp.c: Convert some strchr to memchr\n\nThis allows things to work properly in the face of embedded NULs.\nSee the branch merge message for more information.\n---\n regcomp.c | 10 ++++++----\n 1 file changed, 6 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/regcomp.c b\/regcomp.c\nindex 892aed82cdf..9aec81ddfa3 100644\n--- a\/regcomp.c\n+++ b\/regcomp.c\n@@ -12056,7 +12056,7 @@ S_grok_bslash_N(pTHX_ RExC_state_t *pRExC_state,\n \n     RExC_parse++;\t\/* Skip past the '{' *\/\n \n-    endbrace = strchr(RExC_parse, '}');\n+    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n     if (! endbrace) { \/* no trailing brace *\/\n         vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n     }\n@@ -12773,9 +12773,11 @@ S_regatom(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)\n             else {\n                 STRLEN length;\n                 char name = *RExC_parse;\n-                char * endbrace;\n+                char * endbrace = NULL;\n                 RExC_parse += 2;\n-                endbrace = strchr(RExC_parse, '}');\n+                if (RExC_parse < RExC_end) {\n+                    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n+                }\n \n                 if (! endbrace) {\n                     vFAIL2(\"Missing right brace on \\\\%c{}\", name);\n@@ -16312,7 +16314,7 @@ S_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth,\n \t\t    vFAIL2(\"Empty \\\\%c\", (U8)value);\n \t\tif (*RExC_parse == '{') {\n \t\t    const U8 c = (U8)value;\n-\t\t    e = strchr(RExC_parse, '}');\n+\t\t    e = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n                     if (!e) {\n                         RExC_parse++;\n                         vFAIL2(\"Missing right brace on \\\\%c{}\", c);\n","owner":"Perl","repo":"perl5","source":"cve"},{"CVE_ID":"CVE-2018-20457","CWE_ID":"125","category":"security","commit_id":"88a8adf080a9f8ed5a4250a2507752e133ba54dd","commit_message":"From 88a8adf080a9f8ed5a4250a2507752e133ba54dd Mon Sep 17 00:00:00 2001\nFrom: David Carlier <devnexen@gmail.com>\nDate: Mon, 10 Dec 2018 14:22:51 +0000\nSubject: [PATCH] Fix #12417\/#12418 attempts.\n\n---\n libr\/asm\/arch\/arm\/armass.c   | 2 +-\n libr\/asm\/arch\/arm\/armass64.c | 2 +-\n 2 files changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libr\/asm\/arch\/arm\/armass.c b\/libr\/asm\/arch\/arm\/armass.c\nindex 6b752c0463..dc1b05e9c3 100644\n--- a\/libr\/asm\/arch\/arm\/armass.c\n+++ b\/libr\/asm\/arch\/arm\/armass.c\n@@ -6545,7 +6545,7 @@ ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n \tint i, j;\n \tchar buf[128];\n \tArmOpcode aop = {.off = off};\n-\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n+\tfor (i = j = 0; i < sizeof (buf) - 1 && str[j]; i++, j++) {\n \t\tif (str[j] == '#') {\n \t\t\ti--; continue;\n \t\t}\ndiff --git a\/libr\/asm\/arch\/arm\/armass64.c b\/libr\/asm\/arch\/arm\/armass64.c\nindex 91bd4282a7..3c8ea1b72d 100644\n--- a\/libr\/asm\/arch\/arm\/armass64.c\n+++ b\/libr\/asm\/arch\/arm\/armass64.c\n@@ -756,7 +756,7 @@ static bool parseOperands(char* str, ArmOp *op) {\n \t\t} else if (!strncmp (token, \"asr\", 3)) {\n \t\t\top->operands[operand].shift = ARM_ASR;\n \t\t}\n-\t\tif (op->operands[operand].shift != ARM_NO_SHIFT) {\n+\t\tif (strlen(token) > 4 && op->operands[operand].shift != ARM_NO_SHIFT) {\n \t\t\top->operands_count ++;\n \t\t\top->operands[operand].shift_amount = r_num_math (NULL, token + 4);\n \t\t\tif (op->operands[operand].shift_amount > 63) {\n","owner":"devnexen","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2019-11339","CWE_ID":"125","category":"security","commit_id":"d227ed5d598340e719eff7156b1aa0a4469e9a6a","commit_message":"From d227ed5d598340e719eff7156b1aa0a4469e9a6a Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sun, 10 Mar 2019 01:40:59 +0100\nSubject: [PATCH] avcodec\/mpeg4videodec: Check idx in\n mpeg4_decode_studio_block()\n\nFixes: Out of array access\nFixes: 13500\/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_MPEG4_fuzzer-5769760178962432\n\nFound-by: continuous fuzzing process https:\/\/github.com\/google\/oss-fuzz\/tree\/master\/projects\/ffmpeg\nReviewed-by: Kieran Kunhya <kierank@obe.tv>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/mpeg4videodec.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/mpeg4videodec.c b\/libavcodec\/mpeg4videodec.c\nindex 99b1e106207..b6f2ae7b7b5 100644\n--- a\/libavcodec\/mpeg4videodec.c\n+++ b\/libavcodec\/mpeg4videodec.c\n@@ -1899,14 +1899,20 @@ static int mpeg4_decode_studio_block(MpegEncContext *s, int32_t block[64], int n\n             code >>= 1;\n             run = (1 << (additional_code_len - 1)) + code;\n             idx += run;\n+            if (idx > 63)\n+                return AVERROR_INVALIDDATA;\n             j = scantable[idx++];\n             block[j] = sign ? 1 : -1;\n         } else if (group >= 13 && group <= 20) {\n             \/* Level value (Table B.49) *\/\n+            if (idx > 63)\n+                return AVERROR_INVALIDDATA;\n             j = scantable[idx++];\n             block[j] = get_xbits(&s->gb, additional_code_len);\n         } else if (group == 21) {\n             \/* Escape *\/\n+            if (idx > 63)\n+                return AVERROR_INVALIDDATA;\n             j = scantable[idx++];\n             additional_code_len = s->avctx->bits_per_raw_sample + s->dct_precision + 4;\n             flc = get_bits(&s->gb, additional_code_len);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2018-10887","CWE_ID":"125","category":"security","commit_id":"3f461902dc1072acb8b7607ee65d0a0458ffac2a","commit_message":"From 3f461902dc1072acb8b7607ee65d0a0458ffac2a Mon Sep 17 00:00:00 2001\nFrom: Patrick Steinhardt <ps@pks.im>\nDate: Fri, 29 Jun 2018 07:45:18 +0200\nSubject: [PATCH] delta: fix sign-extension of big left-shift\n\nOur delta code was originally adapted from JGit, which itself adapted it\nfrom git itself. Due to this heritage, we inherited a bug from git.git\nin how we compute the delta offset, which was fixed upstream in\n48fb7deb5 (Fix big left-shifts of unsigned char, 2009-06-17). As\nexplained by Linus:\n\n    Shifting 'unsigned char' or 'unsigned short' left can result in sign\n    extension errors, since the C integer promotion rules means that the\n    unsigned char\/short will get implicitly promoted to a signed 'int' due to\n    the shift (or due to other operations).\n\n    This normally doesn't matter, but if you shift things up sufficiently, it\n    will now set the sign bit in 'int', and a subsequent cast to a bigger type\n    (eg 'long' or 'unsigned long') will now sign-extend the value despite the\n    original expression being unsigned.\n\n    One example of this would be something like\n\n            unsigned long size;\n            unsigned char c;\n\n            size += c << 24;\n\n    where despite all the variables being unsigned, 'c << 24' ends up being a\n    signed entity, and will get sign-extended when then doing the addition in\n    an 'unsigned long' type.\n\n    Since git uses 'unsigned char' pointers extensively, we actually have this\n    bug in a couple of places.\n\nIn our delta code, we inherited such a bogus shift when computing the\noffset at which the delta base is to be found. Due to the sign extension\nwe can end up with an offset where all the bits are set. This can allow\nan arbitrary memory read, as the addition in `base_len < off + len` can\nnow overflow if `off` has all its bits set.\n\nFix the issue by casting the result of `*delta++ << 24UL` to an unsigned\ninteger again. Add a test with a crafted delta that would actually\nsucceed with an out-of-bounds read in case where the cast wouldn't\nexist.\n\nReported-by: Riccardo Schirone <rschiron@redhat.com>\nTest-provided-by: Riccardo Schirone <rschiron@redhat.com>\n---\n src\/delta.c         | 32 +++++++++++++++-----------------\n tests\/delta\/apply.c | 12 ++++++++++++\n tests\/diff\/binary.c |  1 +\n 3 files changed, 28 insertions(+), 17 deletions(-)\n create mode 100644 tests\/delta\/apply.c\n\n","diff_code":"diff --git a\/src\/delta.c b\/src\/delta.c\nindex 073cba7c67..8d9e6146e7 100644\n--- a\/src\/delta.c\n+++ b\/src\/delta.c\n@@ -539,10 +539,11 @@ int git_delta_apply(\n \t*out = NULL;\n \t*out_len = 0;\n \n-\t\/* Check that the base size matches the data we were given;\n-\t* if not we would underflow while accessing data from the\n-\t* base object, resulting in data corruption or segfault.\n-\t*\/\n+\t\/*\n+\t * Check that the base size matches the data we were given;\n+\t * if not we would underflow while accessing data from the\n+\t * base object, resulting in data corruption or segfault.\n+\t *\/\n \tif ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {\n \t\tgiterr_set(GITERR_INVALID, \"failed to apply delta: base size does not match given data\");\n \t\treturn -1;\n@@ -564,19 +565,18 @@ int git_delta_apply(\n \twhile (delta < delta_end) {\n \t\tunsigned char cmd = *delta++;\n \t\tif (cmd & 0x80) {\n-\t\t\t\/* cmd is a copy instruction; copy from the base.\n-\t\t\t*\/\n+\t\t\t\/* cmd is a copy instruction; copy from the base. *\/\n \t\t\tsize_t off = 0, len = 0;\n \n \t\t\tif (cmd & 0x01) off = *delta++;\n \t\t\tif (cmd & 0x02) off |= *delta++ << 8UL;\n \t\t\tif (cmd & 0x04) off |= *delta++ << 16UL;\n-\t\t\tif (cmd & 0x08) off |= *delta++ << 24UL;\n+\t\t\tif (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);\n \n \t\t\tif (cmd & 0x10) len = *delta++;\n \t\t\tif (cmd & 0x20) len |= *delta++ << 8UL;\n \t\t\tif (cmd & 0x40) len |= *delta++ << 16UL;\n-\t\t\tif (!len)\t\tlen = 0x10000;\n+\t\t\tif (!len)       len = 0x10000;\n \n \t\t\tif (base_len < off + len || res_sz < len)\n \t\t\t\tgoto fail;\n@@ -584,11 +584,11 @@ int git_delta_apply(\n \t\t\tres_dp += len;\n \t\t\tres_sz -= len;\n \n-\t\t}\n-\t\telse if (cmd) {\n-\t\t\t\/* cmd is a literal insert instruction; copy from\n-\t\t\t* the delta stream itself.\n-\t\t\t*\/\n+\t\t} else if (cmd) {\n+\t\t\t\/*\n+\t\t\t * cmd is a literal insert instruction; copy from\n+\t\t\t * the delta stream itself.\n+\t\t\t *\/\n \t\t\tif (delta_end - delta < cmd || res_sz < cmd)\n \t\t\t\tgoto fail;\n \t\t\tmemcpy(res_dp, delta, cmd);\n@@ -596,10 +596,8 @@ int git_delta_apply(\n \t\t\tres_dp += cmd;\n \t\t\tres_sz -= cmd;\n \n-\t\t}\n-\t\telse {\n-\t\t\t\/* cmd == 0 is reserved for future encodings.\n-\t\t\t*\/\n+\t\t} else {\n+\t\t\t\/* cmd == 0 is reserved for future encodings. *\/\n \t\t\tgoto fail;\n \t\t}\n \t}\ndiff --git a\/tests\/delta\/apply.c b\/tests\/delta\/apply.c\nnew file mode 100644\nindex 0000000000..24513e040d\n--- \/dev\/null\n+++ b\/tests\/delta\/apply.c\n@@ -0,0 +1,12 @@\n+#include \"clar_libgit2.h\"\n+\n+#include \"delta.h\"\n+\n+void test_delta_apply__read_at_off(void)\n+{\n+\tunsigned char base[16] = { 0 }, delta[] = { 0x10, 0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0x00, 0x00 };\n+\tvoid *out;\n+\tsize_t outlen;\n+\n+\tcl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));\n+}\ndiff --git a\/tests\/diff\/binary.c b\/tests\/diff\/binary.c\nindex 173a5994e5..c17ba5ef4e 100644\n--- a\/tests\/diff\/binary.c\n+++ b\/tests\/diff\/binary.c\n@@ -3,6 +3,7 @@\n #include \"git2\/sys\/diff.h\"\n \n #include \"buffer.h\"\n+#include \"delta.h\"\n #include \"filebuf.h\"\n #include \"repository.h\"\n \n","owner":"libgit2","repo":"libgit2","source":"cve"},{"CVE_ID":"CVE-2017-9074","CWE_ID":"125","category":"security","commit_id":"2423496af35d94a87156b063ea5cedffc10a70a1","commit_message":"From 2423496af35d94a87156b063ea5cedffc10a70a1 Mon Sep 17 00:00:00 2001\nFrom: Craig Gallek <kraig@google.com>\nDate: Tue, 16 May 2017 14:36:23 -0400\nSubject: [PATCH] ipv6: Prevent overrun when parsing v6 header options\n\nThe KASAN warning repoted below was discovered with a syzkaller\nprogram.  The reproducer is basically:\n  int s = socket(AF_INET6, SOCK_RAW, NEXTHDR_HOP);\n  send(s, &one_byte_of_data, 1, MSG_MORE);\n  send(s, &more_than_mtu_bytes_data, 2000, 0);\n\nThe socket() call sets the nexthdr field of the v6 header to\nNEXTHDR_HOP, the first send call primes the payload with a non zero\nbyte of data, and the second send call triggers the fragmentation path.\n\nThe fragmentation code tries to parse the header options in order\nto figure out where to insert the fragment option.  Since nexthdr points\nto an invalid option, the calculation of the size of the network header\ncan made to be much larger than the linear section of the skb and data\nis read outside of it.\n\nThis fix makes ip6_find_1stfrag return an error if it detects\nrunning out-of-bounds.\n\n[   42.361487] ==================================================================\n[   42.364412] BUG: KASAN: slab-out-of-bounds in ip6_fragment+0x11c8\/0x3730\n[   42.365471] Read of size 840 at addr ffff88000969e798 by task ip6_fragment-oo\/3789\n[   42.366469]\n[   42.366696] CPU: 1 PID: 3789 Comm: ip6_fragment-oo Not tainted 4.11.0+ #41\n[   42.367628] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.1-1ubuntu1 04\/01\/2014\n[   42.368824] Call Trace:\n[   42.369183]  dump_stack+0xb3\/0x10b\n[   42.369664]  print_address_description+0x73\/0x290\n[   42.370325]  kasan_report+0x252\/0x370\n[   42.370839]  ? ip6_fragment+0x11c8\/0x3730\n[   42.371396]  check_memory_region+0x13c\/0x1a0\n[   42.371978]  memcpy+0x23\/0x50\n[   42.372395]  ip6_fragment+0x11c8\/0x3730\n[   42.372920]  ? nf_ct_expect_unregister_notifier+0x110\/0x110\n[   42.373681]  ? ip6_copy_metadata+0x7f0\/0x7f0\n[   42.374263]  ? ip6_forward+0x2e30\/0x2e30\n[   42.374803]  ip6_finish_output+0x584\/0x990\n[   42.375350]  ip6_output+0x1b7\/0x690\n[   42.375836]  ? ip6_finish_output+0x990\/0x990\n[   42.376411]  ? ip6_fragment+0x3730\/0x3730\n[   42.376968]  ip6_local_out+0x95\/0x160\n[   42.377471]  ip6_send_skb+0xa1\/0x330\n[   42.377969]  ip6_push_pending_frames+0xb3\/0xe0\n[   42.378589]  rawv6_sendmsg+0x2051\/0x2db0\n[   42.379129]  ? rawv6_bind+0x8b0\/0x8b0\n[   42.379633]  ? _copy_from_user+0x84\/0xe0\n[   42.380193]  ? debug_check_no_locks_freed+0x290\/0x290\n[   42.380878]  ? ___sys_sendmsg+0x162\/0x930\n[   42.381427]  ? rcu_read_lock_sched_held+0xa3\/0x120\n[   42.382074]  ? sock_has_perm+0x1f6\/0x290\n[   42.382614]  ? ___sys_sendmsg+0x167\/0x930\n[   42.383173]  ? lock_downgrade+0x660\/0x660\n[   42.383727]  inet_sendmsg+0x123\/0x500\n[   42.384226]  ? inet_sendmsg+0x123\/0x500\n[   42.384748]  ? inet_recvmsg+0x540\/0x540\n[   42.385263]  sock_sendmsg+0xca\/0x110\n[   42.385758]  SYSC_sendto+0x217\/0x380\n[   42.386249]  ? SYSC_connect+0x310\/0x310\n[   42.386783]  ? __might_fault+0x110\/0x1d0\n[   42.387324]  ? lock_downgrade+0x660\/0x660\n[   42.387880]  ? __fget_light+0xa1\/0x1f0\n[   42.388403]  ? __fdget+0x18\/0x20\n[   42.388851]  ? sock_common_setsockopt+0x95\/0xd0\n[   42.389472]  ? SyS_setsockopt+0x17f\/0x260\n[   42.390021]  ? entry_SYSCALL_64_fastpath+0x5\/0xbe\n[   42.390650]  SyS_sendto+0x40\/0x50\n[   42.391103]  entry_SYSCALL_64_fastpath+0x1f\/0xbe\n[   42.391731] RIP: 0033:0x7fbbb711e383\n[   42.392217] RSP: 002b:00007ffff4d34f28 EFLAGS: 00000246 ORIG_RAX: 000000000000002c\n[   42.393235] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fbbb711e383\n[   42.394195] RDX: 0000000000001000 RSI: 00007ffff4d34f60 RDI: 0000000000000003\n[   42.395145] RBP: 0000000000000046 R08: 00007ffff4d34f40 R09: 0000000000000018\n[   42.396056] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000400aad\n[   42.396598] R13: 0000000000000066 R14: 00007ffff4d34ee0 R15: 00007fbbb717af00\n[   42.397257]\n[   42.397411] Allocated by task 3789:\n[   42.397702]  save_stack_trace+0x16\/0x20\n[   42.398005]  save_stack+0x46\/0xd0\n[   42.398267]  kasan_kmalloc+0xad\/0xe0\n[   42.398548]  kasan_slab_alloc+0x12\/0x20\n[   42.398848]  __kmalloc_node_track_caller+0xcb\/0x380\n[   42.399224]  __kmalloc_reserve.isra.32+0x41\/0xe0\n[   42.399654]  __alloc_skb+0xf8\/0x580\n[   42.400003]  sock_wmalloc+0xab\/0xf0\n[   42.400346]  __ip6_append_data.isra.41+0x2472\/0x33d0\n[   42.400813]  ip6_append_data+0x1a8\/0x2f0\n[   42.401122]  rawv6_sendmsg+0x11ee\/0x2db0\n[   42.401505]  inet_sendmsg+0x123\/0x500\n[   42.401860]  sock_sendmsg+0xca\/0x110\n[   42.402209]  ___sys_sendmsg+0x7cb\/0x930\n[   42.402582]  __sys_sendmsg+0xd9\/0x190\n[   42.402941]  SyS_sendmsg+0x2d\/0x50\n[   42.403273]  entry_SYSCALL_64_fastpath+0x1f\/0xbe\n[   42.403718]\n[   42.403871] Freed by task 1794:\n[   42.404146]  save_stack_trace+0x16\/0x20\n[   42.404515]  save_stack+0x46\/0xd0\n[   42.404827]  kasan_slab_free+0x72\/0xc0\n[   42.405167]  kfree+0xe8\/0x2b0\n[   42.405462]  skb_free_head+0x74\/0xb0\n[   42.405806]  skb_release_data+0x30e\/0x3a0\n[   42.406198]  skb_release_all+0x4a\/0x60\n[   42.406563]  consume_skb+0x113\/0x2e0\n[   42.406910]  skb_free_datagram+0x1a\/0xe0\n[   42.407288]  netlink_recvmsg+0x60d\/0xe40\n[   42.407667]  sock_recvmsg+0xd7\/0x110\n[   42.408022]  ___sys_recvmsg+0x25c\/0x580\n[   42.408395]  __sys_recvmsg+0xd6\/0x190\n[   42.408753]  SyS_recvmsg+0x2d\/0x50\n[   42.409086]  entry_SYSCALL_64_fastpath+0x1f\/0xbe\n[   42.409513]\n[   42.409665] The buggy address belongs to the object at ffff88000969e780\n[   42.409665]  which belongs to the cache kmalloc-512 of size 512\n[   42.410846] The buggy address is located 24 bytes inside of\n[   42.410846]  512-byte region [ffff88000969e780, ffff88000969e980)\n[   42.411941] The buggy address belongs to the page:\n[   42.412405] page:ffffea000025a780 count:1 mapcount:0 mapping:          (null) index:0x0 compound_mapcount: 0\n[   42.413298] flags: 0x100000000008100(slab|head)\n[   42.413729] raw: 0100000000008100 0000000000000000 0000000000000000 00000001800c000c\n[   42.414387] raw: ffffea00002a9500 0000000900000007 ffff88000c401280 0000000000000000\n[   42.415074] page dumped because: kasan: bad access detected\n[   42.415604]\n[   42.415757] Memory state around the buggy address:\n[   42.416222]  ffff88000969e880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   42.416904]  ffff88000969e900: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n[   42.417591] >ffff88000969e980: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[   42.418273]                    ^\n[   42.418588]  ffff88000969ea00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[   42.419273]  ffff88000969ea80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[   42.419882] ==================================================================\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: Craig Gallek <kraig@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/ip6_offload.c |  2 ++\n net\/ipv6\/ip6_output.c  |  4 ++++\n net\/ipv6\/output_core.c | 14 ++++++++------\n net\/ipv6\/udp_offload.c |  2 ++\n 4 files changed, 16 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/ip6_offload.c b\/net\/ipv6\/ip6_offload.c\nindex 93e58a5e18374..eab36abc9f229 100644\n--- a\/net\/ipv6\/ip6_offload.c\n+++ b\/net\/ipv6\/ip6_offload.c\n@@ -117,6 +117,8 @@ static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb,\n \n \t\tif (udpfrag) {\n \t\t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n+\t\t\tif (unfrag_ip6hlen < 0)\n+\t\t\t\treturn ERR_PTR(unfrag_ip6hlen);\n \t\t\tfptr = (struct frag_hdr *)((u8 *)ipv6h + unfrag_ip6hlen);\n \t\t\tfptr->frag_off = htons(offset);\n \t\t\tif (skb->next)\ndiff --git a\/net\/ipv6\/ip6_output.c b\/net\/ipv6\/ip6_output.c\nindex 58f6288e9ba53..01deecda2f843 100644\n--- a\/net\/ipv6\/ip6_output.c\n+++ b\/net\/ipv6\/ip6_output.c\n@@ -598,6 +598,10 @@ int ip6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,\n \tu8 *prevhdr, nexthdr = 0;\n \n \thlen = ip6_find_1stfragopt(skb, &prevhdr);\n+\tif (hlen < 0) {\n+\t\terr = hlen;\n+\t\tgoto fail;\n+\t}\n \tnexthdr = *prevhdr;\n \n \tmtu = ip6_skb_dst_mtu(skb);\ndiff --git a\/net\/ipv6\/output_core.c b\/net\/ipv6\/output_core.c\nindex cd4252346a32d..e9065b8d3af85 100644\n--- a\/net\/ipv6\/output_core.c\n+++ b\/net\/ipv6\/output_core.c\n@@ -79,14 +79,13 @@ EXPORT_SYMBOL(ipv6_select_ident);\n int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n {\n \tu16 offset = sizeof(struct ipv6hdr);\n-\tstruct ipv6_opt_hdr *exthdr =\n-\t\t\t\t(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\n \tunsigned int packet_len = skb_tail_pointer(skb) -\n \t\tskb_network_header(skb);\n \tint found_rhdr = 0;\n \t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n \n-\twhile (offset + 1 <= packet_len) {\n+\twhile (offset <= packet_len) {\n+\t\tstruct ipv6_opt_hdr *exthdr;\n \n \t\tswitch (**nexthdr) {\n \n@@ -107,13 +106,16 @@ int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n \t\t\treturn offset;\n \t\t}\n \n-\t\toffset += ipv6_optlen(exthdr);\n-\t\t*nexthdr = &exthdr->nexthdr;\n+\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n+\t\t\treturn -EINVAL;\n+\n \t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n \t\t\t\t\t\t offset);\n+\t\toffset += ipv6_optlen(exthdr);\n+\t\t*nexthdr = &exthdr->nexthdr;\n \t}\n \n-\treturn offset;\n+\treturn -EINVAL;\n }\n EXPORT_SYMBOL(ip6_find_1stfragopt);\n \ndiff --git a\/net\/ipv6\/udp_offload.c b\/net\/ipv6\/udp_offload.c\nindex ac858c480f2f2..b348cff473951 100644\n--- a\/net\/ipv6\/udp_offload.c\n+++ b\/net\/ipv6\/udp_offload.c\n@@ -91,6 +91,8 @@ static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,\n \t\t * bytes to insert fragment header.\n \t\t *\/\n \t\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n+\t\tif (unfrag_ip6hlen < 0)\n+\t\t\treturn ERR_PTR(unfrag_ip6hlen);\n \t\tnexthdr = *prevhdr;\n \t\t*prevhdr = NEXTHDR_FRAGMENT;\n \t\tunfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-13295","CWE_ID":"125","category":"security","commit_id":"55e6dc49f1a381d9d511ee2f888fdc3e3c3e3953","commit_message":"From 55e6dc49f1a381d9d511ee2f888fdc3e3c3e3953 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 21 Jun 2019 16:52:14 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1608\n\n---\n magick\/threshold.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/magick\/threshold.c b\/magick\/threshold.c\nindex 763eb8552..a53e839e6 100644\n--- a\/magick\/threshold.c\n+++ b\/magick\/threshold.c\n@@ -202,6 +202,8 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,\n   threshold_image=CloneImage(image,0,0,MagickTrue,exception);\n   if (threshold_image == (Image *) NULL)\n     return((Image *) NULL);\n+  if (width == 0)\n+    return(threshold_image);\n   if (SetImageStorageClass(threshold_image,DirectClass) == MagickFalse)\n     {\n       InheritException(exception,&threshold_image->exception);\n","owner":"ImageMagick","repo":"ImageMagick6","source":"cve"},{"CVE_ID":"CVE-2017-9985","CWE_ID":"125","category":"security","commit_id":"20e2b791796bd68816fa115f12be5320de2b8021","commit_message":"From 20e2b791796bd68816fa115f12be5320de2b8021 Mon Sep 17 00:00:00 2001\nFrom: Takashi Iwai <tiwai@suse.de>\nDate: Thu, 6 Jul 2017 12:34:40 +0200\nSubject: [PATCH] ALSA: msnd: Optimize \/ harden DSP and MIDI loops\n\nThe ISA msnd drivers have loops fetching the ring-buffer head, tail\nand size values inside the loops.  Such codes are inefficient and\nfragile.\n\nThis patch optimizes it, and also adds the sanity check to avoid the\nendless loops.\n\nBugzilla: https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=196131\nBugzilla: https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=196133\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/isa\/msnd\/msnd_midi.c     | 30 +++++++++++++++---------------\n sound\/isa\/msnd\/msnd_pinnacle.c | 23 ++++++++++++-----------\n 2 files changed, 27 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/sound\/isa\/msnd\/msnd_midi.c b\/sound\/isa\/msnd\/msnd_midi.c\nindex 912b5a9ccbab5..013d8d1170fe0 100644\n--- a\/sound\/isa\/msnd\/msnd_midi.c\n+++ b\/sound\/isa\/msnd\/msnd_midi.c\n@@ -120,24 +120,24 @@ void snd_msndmidi_input_read(void *mpuv)\n \tunsigned long flags;\n \tstruct snd_msndmidi *mpu = mpuv;\n \tvoid *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;\n+\tu16 head, tail, size;\n \n \tspin_lock_irqsave(&mpu->input_lock, flags);\n-\twhile (readw(mpu->dev->MIDQ + JQS_wTail) !=\n-\t       readw(mpu->dev->MIDQ + JQS_wHead)) {\n-\t\tu16 wTmp, val;\n-\t\tval = readw(pwMIDQData + 2 * readw(mpu->dev->MIDQ + JQS_wHead));\n-\n-\t\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,\n-\t\t\t\t     &mpu->mode))\n-\t\t\t\tsnd_rawmidi_receive(mpu->substream_input,\n-\t\t\t\t\t\t    (unsigned char *)&val, 1);\n-\n-\t\twTmp = readw(mpu->dev->MIDQ + JQS_wHead) + 1;\n-\t\tif (wTmp > readw(mpu->dev->MIDQ + JQS_wSize))\n-\t\t\twritew(0,  mpu->dev->MIDQ + JQS_wHead);\n-\t\telse\n-\t\t\twritew(wTmp,  mpu->dev->MIDQ + JQS_wHead);\n+\thead = readw(mpu->dev->MIDQ + JQS_wHead);\n+\ttail = readw(mpu->dev->MIDQ + JQS_wTail);\n+\tsize = readw(mpu->dev->MIDQ + JQS_wSize);\n+\tif (head > size || tail > size)\n+\t\tgoto out;\n+\twhile (head != tail) {\n+\t\tunsigned char val = readw(pwMIDQData + 2 * head);\n+\n+\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &mpu->mode))\n+\t\t\tsnd_rawmidi_receive(mpu->substream_input, &val, 1);\n+\t\tif (++head > size)\n+\t\t\thead = 0;\n+\t\twritew(head, mpu->dev->MIDQ + JQS_wHead);\n \t}\n+ out:\n \tspin_unlock_irqrestore(&mpu->input_lock, flags);\n }\n EXPORT_SYMBOL(snd_msndmidi_input_read);\ndiff --git a\/sound\/isa\/msnd\/msnd_pinnacle.c b\/sound\/isa\/msnd\/msnd_pinnacle.c\nindex ad4897337df57..fc4fb1904aef8 100644\n--- a\/sound\/isa\/msnd\/msnd_pinnacle.c\n+++ b\/sound\/isa\/msnd\/msnd_pinnacle.c\n@@ -170,23 +170,24 @@ static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n {\n \tstruct snd_msnd *chip = dev_id;\n \tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n+\tu16 head, tail, size;\n \n \t\/* Send ack to DSP *\/\n \t\/* inb(chip->io + HP_RXL); *\/\n \n \t\/* Evaluate queued DSP messages *\/\n-\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n-\t\tu16 wTmp;\n-\n-\t\tsnd_msnd_eval_dsp_msg(chip,\n-\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n-\n-\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n-\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n-\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n-\t\telse\n-\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n+\thead = readw(chip->DSPQ + JQS_wHead);\n+\ttail = readw(chip->DSPQ + JQS_wTail);\n+\tsize = readw(chip->DSPQ + JQS_wSize);\n+\tif (head > size || tail > size)\n+\t\tgoto out;\n+\twhile (head != tail) {\n+\t\tsnd_msnd_eval_dsp_msg(chip, readw(pwDSPQData + 2 * head));\n+\t\tif (++head > size)\n+\t\t\thead = 0;\n+\t\twritew(head, chip->DSPQ + JQS_wHead);\n \t}\n+ out:\n \t\/* Send ack to DSP *\/\n \tinb(chip->io + HP_RXL);\n \treturn IRQ_HANDLED;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-14608","CWE_ID":"125","category":"security","commit_id":"d13e8f6d1e987b7491182040a188c16a395f1d21","commit_message":"From d13e8f6d1e987b7491182040a188c16a395f1d21 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Wed, 13 Sep 2017 09:31:01 +0300\nSubject: [PATCH] CVE-2017-1438 credits; fix for Kodak 65000 out of bounds\n access\n\n---\n Changelog.txt             |  6 +++++-\n dcraw\/dcraw.c             | 11 +++++++++--\n internal\/dcraw_common.cpp | 11 +++++++++--\n 3 files changed, 23 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/Changelog.txt b\/Changelog.txt\nindex 95bdc952..9b247882 100755\n--- a\/Changelog.txt\n+++ b\/Changelog.txt\n@@ -1,5 +1,9 @@\n+2017-09-13  Alex Tutubalin <lexa@lexa.ru>\n+ * Fixed possible out of bound access in Kodak 6500 loader\n+\n 2017-09-12  Alex Tutubalin <lexa@lexa.ru>\n- * Fix for possible heap overrun in Canon makernotes parser\n+ * CVE-2017-14348: Fix for possible heap overrun in Canon makernotes parser\n+   Credit: Henri Salo from Nixu Corporation\n  * LibRaw 0.18.4\n \n 2017-09-09  Alex Tutubalin <lexa@lexa.ru>\ndiff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex c4fa7896..60d87218 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -3528,8 +3528,15 @@ void CLASS kodak_65000_load_raw()\n       len = MIN (256, width-col);\n       ret = kodak_65000_decode (buf, len);\n       for (i=0; i < len; i++)\n-\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n-\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n+      {\n+\tint idx = ret ? buf[i] : (pred[i & 1] += buf[i]);\n+\tif(idx >=0 && idx <= 0xffff)\n+\t {\n+\t   if ((RAW(row,col+i) = curve[idx]) >> 12) derror();\n+         }\n+\t else\n+\t   derror();\n+      }\n     }\n   }\n }\ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex 18bcdbcb..8fb2b073 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -3240,8 +3240,15 @@ void CLASS kodak_65000_load_raw()\n       len = MIN (256, width-col);\n       ret = kodak_65000_decode (buf, len);\n       for (i=0; i < len; i++)\n-\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n-\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n+      {\n+\tint idx = ret ? buf[i] : (pred[i & 1] += buf[i]);\n+\tif(idx >=0 && idx <= 0xffff)\n+\t {\n+\t   if ((RAW(row,col+i) = curve[idx]) >> 12) derror();\n+         }\n+\t else\n+\t   derror();\n+      }\n     }\n   }\n }\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2014-9658","CWE_ID":"125","category":"security","commit_id":"f70d9342e65cd2cb44e9f26b6d7edeedf191fc6c","commit_message":"From f70d9342e65cd2cb44e9f26b6d7edeedf191fc6c Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Mon, 24 Nov 2014 09:31:32 +0100\nSubject: [sfnt] Fix Savannah bug #43672.\n\n* src\/sfnt\/ttkern.c (tt_face_load_kern): Use correct value for\nminimum table length test.\n---\n ChangeLog         | 7 +++++++\n src\/sfnt\/ttkern.c | 2 +-\n 2 files changed, 8 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex c19dbe8..432186e 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,12 @@\n 2014-11-24  Werner Lemberg  <wl@gnu.org>\n \n+\t[sfnt] Fix Savannah bug #43672.\n+\n+\t* src\/sfnt\/ttkern.c (tt_face_load_kern): Use correct value for\n+\tminimum table length test.\n+\n+2014-11-24  Werner Lemberg  <wl@gnu.org>\n+\n \t[type1, type42] Another fix for Savannah bug #43655.\n \n \t* src\/type1\/t1load.c (parse_charstrings), src\/type42\/t42parse.c\ndiff --git a\/src\/sfnt\/ttkern.c b\/src\/sfnt\/ttkern.c\nindex 32c4008..455e7b5 100644\n--- a\/src\/sfnt\/ttkern.c\n+++ b\/src\/sfnt\/ttkern.c\n@@ -99,7 +99,7 @@\n       length   = FT_NEXT_USHORT( p );\n       coverage = FT_NEXT_USHORT( p );\n \n-      if ( length <= 6 )\n+      if ( length <= 6 + 8 )\n         break;\n \n       p_next += length;\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8483","CWE_ID":"125","category":"security","commit_id":"8b5ecd226f9208af3074b33d3b7cf5e14f55b138","commit_message":"From 8b5ecd226f9208af3074b33d3b7cf5e14f55b138 Mon Sep 17 00:00:00 2001\nFrom: Manuel Nickschas <sputnick@quassel-irc.org>\nDate: Tue, 21 Oct 2014 21:20:07 +0200\nSubject: [PATCH] Check for invalid input in encrypted buffers\n\nThe ECB Blowfish decryption function assumed that encrypted input would\nalways come in blocks of 12 characters, as specified. However, buggy\nclients or annoying people may not adhere to that assumption, causing\nthe core to crash while trying to process the invalid base64 input.\n\nWith this commit we make sure that we're not overstepping the bounds of\nthe input string while decoding it; instead we bail out early and display\nthe original input. Fixes #1314.\n\nThanks to Tucos for finding that one!\n---\n src\/core\/cipher.cpp | 11 ++++++++++-\n 1 file changed, 10 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/core\/cipher.cpp b\/src\/core\/cipher.cpp\nindex 7cc75d0a5..7d1fe46a5 100644\n--- a\/src\/core\/cipher.cpp\n+++ b\/src\/core\/cipher.cpp\n@@ -364,6 +364,10 @@ QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n     }\n     else\n     {\n+        \/\/ ECB Blowfish encodes in blocks of 12 chars, so anything else is malformed input\n+        if ((temp.length() % 12) != 0)\n+            return cipherText;\n+\n         temp = b64ToByte(temp);\n         while ((temp.length() % 8) != 0) temp.append('\\0');\n     }\n@@ -376,8 +380,13 @@ QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n     if (!cipher.ok())\n         return cipherText;\n \n-    if (direction)\n+    if (direction) {\n+        \/\/ Sanity check\n+        if ((temp2.length() % 8) != 0)\n+            return cipherText;\n+\n         temp2 = byteToB64(temp2);\n+    }\n \n     return temp2;\n }\n","owner":"quassel","repo":"quassel","source":"cve"},{"CVE_ID":"CVE-2016-10028","CWE_ID":"125","category":"security","commit_id":"abd7f08b2353f43274b785db8c7224f082ef4d31","commit_message":"From abd7f08b2353f43274b785db8c7224f082ef4d31 Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Wed, 14 Dec 2016 12:31:56 +0530\nSubject: [PATCH] display: virtio-gpu-3d: check virgl capabilities max_size\n\nVirtio GPU device while processing 'VIRTIO_GPU_CMD_GET_CAPSET'\ncommand, retrieves the maximum capabilities size to fill in the\nresponse object. It continues to fill in capabilities even if\nretrieved 'max_size' is zero(0), thus resulting in OOB access.\nAdd check to avoid it.\n\nReported-by: Zhenhao Hong <zhenhaohong@gmail.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-id: 20161214070156.23368-1-ppandit@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/display\/virtio-gpu-3d.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/display\/virtio-gpu-3d.c b\/hw\/display\/virtio-gpu-3d.c\nindex 23f39de..e29f099 100644\n--- a\/hw\/display\/virtio-gpu-3d.c\n+++ b\/hw\/display\/virtio-gpu-3d.c\n@@ -371,8 +371,12 @@ static void virgl_cmd_get_capset(VirtIOGPU *g,\n \n     virgl_renderer_get_cap_set(gc.capset_id, &max_ver,\n                                &max_size);\n-    resp = g_malloc(sizeof(*resp) + max_size);\n+    if (!max_size) {\n+        cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;\n+        return;\n+    }\n \n+    resp = g_malloc(sizeof(*resp) + max_size);\n     resp->hdr.type = VIRTIO_GPU_RESP_OK_CAPSET;\n     virgl_renderer_fill_caps(gc.capset_id,\n                              gc.capset_version,\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5601","CWE_ID":"125","category":"security","commit_id":"98dcbbf0bf4854bf987557e55e55fff7abbf3ea9","commit_message":"From 98dcbbf0bf4854bf987557e55e55fff7abbf3ea9 Mon Sep 17 00:00:00 2001\nFrom: Martin Matuska <martin@matuska.org>\nDate: Thu, 19 Jan 2017 22:00:18 +0100\nSubject: [PATCH] Fail with negative lha->compsize in lha_read_file_header_1()\n Fixes a heap buffer overflow reported in Secunia SA74169\n\n---\n libarchive\/archive_read_support_format_lha.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/libarchive\/archive_read_support_format_lha.c b\/libarchive\/archive_read_support_format_lha.c\nindex 52a5531b0..d77a7c2e4 100644\n--- a\/libarchive\/archive_read_support_format_lha.c\n+++ b\/libarchive\/archive_read_support_format_lha.c\n@@ -924,6 +924,9 @@ lha_read_file_header_1(struct archive_read *a, struct lha *lha)\n \t\/* Get a real compressed file size. *\/\n \tlha->compsize -= extdsize - 2;\n \n+\tif (lha->compsize < 0)\n+\t\tgoto invalid;\t\/* Invalid compressed file size *\/\n+\n \tif (sum_calculated != headersum) {\n \t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n \t\t    \"LHa header sum error\");\n","owner":"libarchive","repo":"libarchive","source":"cve"},{"CVE_ID":"CVE-2017-15672","CWE_ID":"125","category":"security","commit_id":"c20f4fcb74da2d0432c7b54499bb98f48236b904","commit_message":"From c20f4fcb74da2d0432c7b54499bb98f48236b904 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Mon, 9 Oct 2017 11:49:28 +0200\nSubject: [PATCH] avcodec\/ffv1dec: Fix out of array read in slice counting\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nFixes: test-201710.mp4\n\nFound-by: \u00e8\u00bf\u009e\u00e4\u00b8\u0080\u00e6\u00b1\u0089 <lianyihan@360.cn> and Zhibin Hu\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/ffv1dec.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/ffv1dec.c b\/libavcodec\/ffv1dec.c\nindex d2bfee784f..5eadb6b158 100644\n--- a\/libavcodec\/ffv1dec.c\n+++ b\/libavcodec\/ffv1dec.c\n@@ -717,7 +717,7 @@ static int read_header(FFV1Context *f)\n     } else {\n         const uint8_t *p = c->bytestream_end;\n         for (f->slice_count = 0;\n-             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;\n+             f->slice_count < MAX_SLICES && 3 + 5*!!f->ec < p - c->bytestream_start;\n              f->slice_count++) {\n             int trailer = 3 + 5*!!f->ec;\n             int size = AV_RB24(p-trailer);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-6520","CWE_ID":"125","category":"security","commit_id":"76401e172ea3a55182be2b8e2aca4d07270f6da6","commit_message":"From 76401e172ea3a55182be2b8e2aca4d07270f6da6 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 1 Aug 2016 12:16:49 -0400\nSubject: [PATCH] Evaluate lazy pixel cache morphology to prevent buffer\n overflow (bug report from Ibrahim M. El-Sayed)\n\n---\n ChangeLog            | 4 ++++\n MagickCore\/enhance.c | 4 ++++\n 2 files changed, 8 insertions(+)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex bca3aee888..4cf2e838f5 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,7 @@\n+2016-07-01  7.0.2-7 Cristy  <quetzlzacatenango@image...>\n+  * Evaluate lazy pixel cache morphology to prevent buffer overflow (bug report\n+    from Ibrahim M. El-Sayed).\n+\n 2016-07-30  7.0.2-6 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 7.0.2-6, GIT revision 18651:df24175:20160729.\n \ndiff --git a\/MagickCore\/enhance.c b\/MagickCore\/enhance.c\nindex 315cb24e45..2bd1363e4d 100644\n--- a\/MagickCore\/enhance.c\n+++ b\/MagickCore\/enhance.c\n@@ -1049,6 +1049,8 @@ MagickExport MagickBooleanType ContrastStretchImage(Image *image,\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n   if (SetImageGray(image,exception) != MagickFalse)\n     (void) SetImageColorspace(image,GRAYColorspace,exception);\n+  if (SyncImagePixelCache(image,exception) == MagickFalse)\n+    return(MagickFalse);\n   black=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*black));\n   white=(double *) AcquireQuantumMemory(GetPixelChannels(image),sizeof(*white));\n   histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*\n@@ -1533,6 +1535,8 @@ MagickExport MagickBooleanType EqualizeImage(Image *image,\n #endif\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n+  if (SyncImagePixelCache(image,exception) == MagickFalse)\n+    return(MagickFalse);\n   equalize_map=(double *) AcquireQuantumMemory(MaxMap+1UL,\n     GetPixelChannels(image)*sizeof(*equalize_map));\n   histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,GetPixelChannels(image)*\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-6214","CWE_ID":"125","category":"security","commit_id":"10ef1dca63d62433fda13309b4a228782db823f7","commit_message":"From 10ef1dca63d62433fda13309b4a228782db823f7 Mon Sep 17 00:00:00 2001\nFrom: \"Christoph M. Becker\" <cmbecker69@gmx.de>\nDate: Tue, 12 Jul 2016 19:23:13 +0200\nSubject: [PATCH] Unsupported TGA bpp\/alphabit combinations should error\n gracefully\n\nCurrently, only 24bpp without alphabits and 32bpp with 8 alphabits are\nreally supported. All other combinations will be rejected with a warning.\n---\n src\/gd_tga.c             |  16 ++++++----------\n tests\/tga\/.gitignore     |   1 +\n tests\/tga\/CMakeLists.txt |   1 +\n tests\/tga\/Makemodule.am  |   4 +++-\n tests\/tga\/bug00247a.c    |  19 +++++++++++++++++++\n tests\/tga\/bug00247a.tga  | Bin 0 -> 36 bytes\n 6 files changed, 30 insertions(+), 11 deletions(-)\n create mode 100644 tests\/tga\/bug00247a.c\n create mode 100644 tests\/tga\/bug00247a.tga\n\n","diff_code":"diff --git a\/src\/gd_tga.c b\/src\/gd_tga.c\nindex 20fe2d27..b4f8fa62 100644\n--- a\/src\/gd_tga.c\n+++ b\/src\/gd_tga.c\n@@ -99,7 +99,7 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n \t\t\tif (tga->bits == TGA_BPP_24) {\n \t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n \t\t\t\tbitmap_caret += 3;\n-\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n+\t\t\t} else if (tga->bits == TGA_BPP_32 && tga->alphabits) {\n \t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n \n \t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n@@ -159,16 +159,12 @@ int read_header_tga(gdIOCtx *ctx, oTga *tga)\n \tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n #endif\n \n-\tswitch(tga->bits) {\n-\tcase 8:\n-\tcase 16:\n-\tcase 24:\n-\tcase 32:\n-\t\tbreak;\n-\tdefault:\n-\t\tgd_error(\"bps %i not supported\", tga->bits);\n+\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n+\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n+\t{\n+\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n+\t\t\ttga->bits, tga->alphabits);\n \t\treturn -1;\n-\t\tbreak;\n \t}\n \n \ttga->ident = NULL;\ndiff --git a\/tests\/tga\/.gitignore b\/tests\/tga\/.gitignore\nindex f811a246..14bf59fe 100644\n--- a\/tests\/tga\/.gitignore\n+++ b\/tests\/tga\/.gitignore\n@@ -1,3 +1,4 @@\n \/bug00084\n \/bug00247\n+\/bug00247a\n \/tga_null\ndiff --git a\/tests\/tga\/CMakeLists.txt b\/tests\/tga\/CMakeLists.txt\nindex a2553d1d..52a4223c 100644\n--- a\/tests\/tga\/CMakeLists.txt\n+++ b\/tests\/tga\/CMakeLists.txt\n@@ -2,6 +2,7 @@ LIST(APPEND TESTS_FILES\n \ttga_null\n \tbug00084\n \tbug00247\n+\tbug00247a\n )\n \n ADD_GD_TESTS()\ndiff --git a\/tests\/tga\/Makemodule.am b\/tests\/tga\/Makemodule.am\nindex 93063a33..0052a275 100644\n--- a\/tests\/tga\/Makemodule.am\n+++ b\/tests\/tga\/Makemodule.am\n@@ -1,9 +1,11 @@\n libgd_test_programs += \\\n \ttga\/bug00084 \\\n \ttga\/bug00247 \\\n+\ttag\/bug00247a \\\n \ttga\/tga_null\n \n EXTRA_DIST += \\\n \ttga\/CMakeLists.txt \\\n \ttga\/bug00084.tga \\\n-\ttga\/bug00247.tga\n+\ttga\/bug00247.tga \\\n+\ttga\/bug00247a.tga\ndiff --git a\/tests\/tga\/bug00247a.c b\/tests\/tga\/bug00247a.c\nnew file mode 100644\nindex 00000000..676efa3a\n--- \/dev\/null\n+++ b\/tests\/tga\/bug00247a.c\n@@ -0,0 +1,19 @@\n+\/*\n+We test that a 8bpp TGA file will be gracefully rejected by\n+gdImageCreateFromTga().\n+*\/\n+\n+#include <stdio.h>\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+int main(int argc, char **argv)\n+{\n+    gdImagePtr im;\n+    FILE *fp = gdTestFileOpen(\"tga\/bug00247a.tga\");\n+    im = gdImageCreateFromTga(fp);\n+    gdTestAssert(im == NULL);\n+    fclose(fp);\n+    return gdNumFailures();\n+}\ndiff --git a\/tests\/tga\/bug00247a.tga b\/tests\/tga\/bug00247a.tga\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..65e55abeae2204d745f1e2a5eb45bb64f8e0bf7c\nGIT binary patch\nliteral 36\nmcmWN@u>k-e3<5Bq75M)XKh#V)R3T^?>`yNd!8Sadk+TmJngJ#N\n\nliteral 0\nHcmV?d00001\n\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2018-20456","CWE_ID":"125","category":"security","commit_id":"9b46d38dd3c4de6048a488b655c7319f845af185","commit_message":"From 9b46d38dd3c4de6048a488b655c7319f845af185 Mon Sep 17 00:00:00 2001\nFrom: radare <pancake@nopcode.org>\nDate: Mon, 3 Dec 2018 01:46:58 +0100\nSubject: [PATCH] Fix #12372 and #12373 - Crash in x86 assembler (#12380)\n\n0 ,0,[bP-bL-bP-bL-bL-r-bL-bP-bL-bL-\nmov ,0,[ax+Bx-ax+Bx-ax+ax+Bx-ax+Bx--\nleA ,0,[bP-bL-bL-bP-bL-bP-bL-60@bL-\nleA ,0,[bP-bL-r-bP-bL-bP-bL-60@bL-\nmov ,0,[ax+Bx-ax+Bx-ax+ax+Bx-ax+Bx--\n---\n libr\/asm\/p\/asm_x86_nz.c | 11 +++++++----\n 1 file changed, 7 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libr\/asm\/p\/asm_x86_nz.c b\/libr\/asm\/p\/asm_x86_nz.c\nindex 623892b6d7..79abc9d60d 100644\n--- a\/libr\/asm\/p\/asm_x86_nz.c\n+++ b\/libr\/asm\/p\/asm_x86_nz.c\n@@ -4575,14 +4575,17 @@ static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) {\n \t\t\tif (last_type == TT_SPECIAL) {\n \t\t\t\tif (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') {\n \t\t\t\t\tif (reg != X86R_UNDEFINED) {\n-\t\t\t\t\t\top->regs[reg_index] = reg;\n-\t\t\t\t\t\top->scale[reg_index] = temp;\n+\t\t\t\t\t\tif (reg_index < 2) {\n+\t\t\t\t\t\t\top->regs[reg_index] = reg;\n+\t\t\t\t\t\t\top->scale[reg_index] = temp;\n+\t\t\t\t\t\t}\n \t\t\t\t\t\t++reg_index;\n \t\t\t\t\t} else {\n \t\t\t\t\t\top->offset += temp;\n-\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;\n+\t\t\t\t\t\tif (reg_index < 2) {\n+\t\t\t\t\t\t\top->regs[reg_index] = X86R_UNDEFINED;\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\n \t\t\t\t\ttemp = 1;\n \t\t\t\t\treg = X86R_UNDEFINED;\n \t\t\t\t} else if (str[pos] == '*') {\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2017-16910","CWE_ID":"125","category":"security","commit_id":"5563e6ddc3f7cb93d98b491194ceebdee7288d36","commit_message":"From 5563e6ddc3f7cb93d98b491194ceebdee7288d36 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Sat, 2 Dec 2017 12:28:37 +0300\nSubject: [PATCH] Secunia 76000 #2: xtrans allhex not initialized\n\n---\n dcraw\/dcraw.c             | 32 +++++++++++++++++++++++++++++++-\n internal\/dcraw_common.cpp | 32 +++++++++++++++++++++++++++++++-\n 2 files changed, 62 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 7ce50e65..54c954a1 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -7045,6 +7045,8 @@ void CLASS xtrans_interpolate(int passes)\n #endif\n \n #ifdef LIBRAW_LIBRARY_BUILD\n+  if(width < TS || height < TS)\n+\t  throw LIBRAW_EXCEPTION_IO_CORRUPT; \/\/ too small image\n \/* Check against right pattern *\/\n   for (row = 0; row < 6; row++)\n \t  for (col = 0; col < 6; col++)\n@@ -7053,6 +7055,13 @@ void CLASS xtrans_interpolate(int passes)\n   if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16\n     || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])\n \t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+ \/\/ Init allhex table to unreasonable values\n+ for(int i = 0; i < 3; i++)\n+  for(int j = 0; j < 3; j++)\n+   for(int k = 0; k < 2; k++)\n+    for(int l = 0; l < 8; l++)\n+     allhex[i][j][k][l]=32700;\n #endif\n   cielab(0, 0);\n   ndir = 4 << (passes > 1);\n@@ -7063,6 +7072,7 @@ void CLASS xtrans_interpolate(int passes)\n   drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n   homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n \n+  int minv=0,maxv=0,minh=0,maxh=0;\n   \/* Map a green hexagon around each non-green pixel and vice versa:\t*\/\n   for (row = 0; row < 3; row++)\n     for (col = 0; col < 3; col++)\n@@ -7083,11 +7093,25 @@ void CLASS xtrans_interpolate(int passes)\n           {\n             v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n             h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n+\t    minv=MIN(v,minv);\n+\t    maxv=MAX(v,maxv);\n+\t    minh=MIN(v,minh);\n+   \t    maxh=MAX(v,maxh);\n             allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n             allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n           }\n       }\n \n+#ifdef LIBRAW_LIBRARY_BUILD\n+   \/\/ Check allhex table initialization\n+  for(int i = 0; i < 3; i++)\n+    for(int j = 0; j < 3; j++)\n+      for(int k = 0; k < 2; k++)\n+        for(int l = 0; l < 8; l++)\n+\t  if(allhex[i][j][k][l]>maxh+maxv*width+1 || allhex[i][j][k][l]<minh+minv*width-1)\n+\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+  int retrycount = 0;\n+#endif\n   \/* Set green1 and green3 to the minimum and maximum allowed values:\t*\/\n   for (row = 2; row < height - 2; row++)\n     for (min = ~(max = 0), col = 2; col < width - 2; col++)\n@@ -7118,7 +7142,13 @@ void CLASS xtrans_interpolate(int passes)\n         break;\n       case 2:\n         if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n-          row--;\n+\t{\n+           row--;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+\t  if(retrycount++ > width*height)\n+\t  \tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\t}\n       }\n     }\n \ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex 56f37a30..e0fe6f40 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -5727,6 +5727,8 @@ void CLASS xtrans_interpolate(int passes)\n #endif\n \n #ifdef LIBRAW_LIBRARY_BUILD\n+  if(width < TS || height < TS)\n+\t  throw LIBRAW_EXCEPTION_IO_CORRUPT; \/\/ too small image\n \/* Check against right pattern *\/\n   for (row = 0; row < 6; row++)\n \t  for (col = 0; col < 6; col++)\n@@ -5735,6 +5737,13 @@ void CLASS xtrans_interpolate(int passes)\n   if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16\n     || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])\n \t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+ \/\/ Init allhex table to unreasonable values\n+ for(int i = 0; i < 3; i++)\n+  for(int j = 0; j < 3; j++)\n+   for(int k = 0; k < 2; k++)\n+    for(int l = 0; l < 8; l++)\n+     allhex[i][j][k][l]=32700;\n #endif\n   cielab(0, 0);\n   ndir = 4 << (passes > 1);\n@@ -5745,6 +5754,7 @@ void CLASS xtrans_interpolate(int passes)\n   drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n   homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n \n+  int minv=0,maxv=0,minh=0,maxh=0;\n   \/* Map a green hexagon around each non-green pixel and vice versa:\t*\/\n   for (row = 0; row < 3; row++)\n     for (col = 0; col < 3; col++)\n@@ -5765,11 +5775,25 @@ void CLASS xtrans_interpolate(int passes)\n           {\n             v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n             h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n+\t    minv=MIN(v,minv);\n+\t    maxv=MAX(v,maxv);\n+\t    minh=MIN(v,minh);\n+   \t    maxh=MAX(v,maxh);\n             allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n             allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n           }\n       }\n \n+#ifdef LIBRAW_LIBRARY_BUILD\n+   \/\/ Check allhex table initialization\n+  for(int i = 0; i < 3; i++)\n+    for(int j = 0; j < 3; j++)\n+      for(int k = 0; k < 2; k++)\n+        for(int l = 0; l < 8; l++)\n+\t  if(allhex[i][j][k][l]>maxh+maxv*width+1 || allhex[i][j][k][l]<minh+minv*width-1)\n+\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+  int retrycount = 0;\n+#endif\n   \/* Set green1 and green3 to the minimum and maximum allowed values:\t*\/\n   for (row = 2; row < height - 2; row++)\n     for (min = ~(max = 0), col = 2; col < width - 2; col++)\n@@ -5800,7 +5824,13 @@ void CLASS xtrans_interpolate(int passes)\n         break;\n       case 2:\n         if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n-          row--;\n+\t{\n+           row--;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+\t  if(retrycount++ > width*height)\n+\t  \tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n+#endif\n+\t}\n       }\n     }\n \n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2017-11399","CWE_ID":"125","category":"security","commit_id":"ba4beaf6149f7241c8bd85fe853318c2f6837ad0","commit_message":"From ba4beaf6149f7241c8bd85fe853318c2f6837ad0 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sun, 16 Jul 2017 14:57:20 +0200\nSubject: [PATCH] avcodec\/apedec: Fix integer overflow\n\nFixes: out of array access\nFixes: PoC.ape and others\n\nFound-by: Bingchang, Liu@VARAS of IIE\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/apedec.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/apedec.c b\/libavcodec\/apedec.c\nindex a6b14b8e247..15eb416ba4e 100644\n--- a\/libavcodec\/apedec.c\n+++ b\/libavcodec\/apedec.c\n@@ -1412,6 +1412,7 @@ static int ape_decode_frame(AVCodecContext *avctx, void *data,\n     int32_t *sample24;\n     int i, ch, ret;\n     int blockstodecode;\n+    uint64_t decoded_buffer_size;\n \n     \/* this should never be negative, but bad things will happen if it is, so\n        check it just to make sure. *\/\n@@ -1467,7 +1468,7 @@ static int ape_decode_frame(AVCodecContext *avctx, void *data,\n                 skip_bits_long(&s->gb, offset);\n         }\n \n-        if (!nblocks || nblocks > INT_MAX) {\n+        if (!nblocks || nblocks > INT_MAX \/ 2 \/ sizeof(*s->decoded_buffer) - 8) {\n             av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\n                    nblocks);\n             return AVERROR_INVALIDDATA;\n@@ -1493,8 +1494,9 @@ static int ape_decode_frame(AVCodecContext *avctx, void *data,\n         blockstodecode = s->samples;\n \n     \/* reallocate decoded sample buffer if needed *\/\n-    av_fast_malloc(&s->decoded_buffer, &s->decoded_size,\n-                   2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer));\n+    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);\n+    av_assert0(decoded_buffer_size <= INT_MAX);\n+    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);\n     if (!s->decoded_buffer)\n         return AVERROR(ENOMEM);\n     memset(s->decoded_buffer, 0, s->decoded_size);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-2633","CWE_ID":"125","category":"security","commit_id":"bea60dd7679364493a0d7f5b54316c767cf894ef","commit_message":"From bea60dd7679364493a0d7f5b54316c767cf894ef Mon Sep 17 00:00:00 2001\nFrom: Peter Lieven <pl@kamp.de>\nDate: Mon, 30 Jun 2014 10:57:51 +0200\nSubject: [PATCH] ui\/vnc: fix potential memory corruption issues\n\nthis patch makes the VNC server work correctly if the\nserver surface and the guest surface have different sizes.\n\nBasically the server surface is adjusted to not exceed VNC_MAX_WIDTH\nx VNC_MAX_HEIGHT and additionally the width is rounded up to multiple of\nVNC_DIRTY_PIXELS_PER_BIT.\n\nIf we have a resolution whose width is not dividable by VNC_DIRTY_PIXELS_PER_BIT\nwe now get a small black bar on the right of the screen.\n\nIf the surface is too big to fit the limits only the upper left area is shown.\n\nOn top of that this fixes 2 memory corruption issues:\n\nThe first was actually discovered during playing\naround with a Windows 7 vServer. During resolution\nchange in Windows 7 it happens sometimes that Windows\nchanges to an intermediate resolution where\nserver_stride % cmp_bytes != 0 (in vnc_refresh_server_surface).\nThis happens only if width % VNC_DIRTY_PIXELS_PER_BIT != 0.\n\nThe second is a theoretical issue, but is maybe exploitable\nby the guest. If for some reason the guest surface size is bigger\nthan VNC_MAX_WIDTH x VNC_MAX_HEIGHT we end up in severe corruption since\nthis limit is nowhere enforced.\n\nSigned-off-by: Peter Lieven <pl@kamp.de>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n ui\/vnc.c | 149 +++++++++++++++++++++++++++++----------------------------------\n ui\/vnc.h |  14 +++---\n 2 files changed, 77 insertions(+), 86 deletions(-)\n\n","diff_code":"diff --git a\/ui\/vnc.c b\/ui\/vnc.c\nindex 19ce988..548588a 100644\n--- a\/ui\/vnc.c\n+++ b\/ui\/vnc.c\n@@ -432,14 +432,10 @@ static void framebuffer_update_request(VncState *vs, int incremental,\n static void vnc_refresh(DisplayChangeListener *dcl);\n static int vnc_refresh_server_surface(VncDisplay *vd);\n \n-static void vnc_dpy_update(DisplayChangeListener *dcl,\n-                           int x, int y, int w, int h)\n-{\n-    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n-    struct VncSurface *s = &vd->guest;\n-    int width = surface_width(vd->ds);\n-    int height = surface_height(vd->ds);\n-\n+static void vnc_set_area_dirty(DECLARE_BITMAP(dirty[VNC_MAX_HEIGHT],\n+                               VNC_MAX_WIDTH \/ VNC_DIRTY_PIXELS_PER_BIT),\n+                               int width, int height,\n+                               int x, int y, int w, int h) {\n     \/* this is needed this to ensure we updated all affected\n      * blocks if x % VNC_DIRTY_PIXELS_PER_BIT != 0 *\/\n     w += (x % VNC_DIRTY_PIXELS_PER_BIT);\n@@ -451,11 +447,22 @@ static void vnc_dpy_update(DisplayChangeListener *dcl,\n     h = MIN(y + h, height);\n \n     for (; y < h; y++) {\n-        bitmap_set(s->dirty[y], x \/ VNC_DIRTY_PIXELS_PER_BIT,\n+        bitmap_set(dirty[y], x \/ VNC_DIRTY_PIXELS_PER_BIT,\n                    DIV_ROUND_UP(w, VNC_DIRTY_PIXELS_PER_BIT));\n     }\n }\n \n+static void vnc_dpy_update(DisplayChangeListener *dcl,\n+                           int x, int y, int w, int h)\n+{\n+    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n+    struct VncSurface *s = &vd->guest;\n+    int width = pixman_image_get_width(vd->server);\n+    int height = pixman_image_get_height(vd->server);\n+\n+    vnc_set_area_dirty(s->dirty, width, height, x, y, w, h);\n+}\n+\n void vnc_framebuffer_update(VncState *vs, int x, int y, int w, int h,\n                             int32_t encoding)\n {\n@@ -517,17 +524,15 @@ void buffer_advance(Buffer *buf, size_t len)\n \n static void vnc_desktop_resize(VncState *vs)\n {\n-    DisplaySurface *ds = vs->vd->ds;\n-\n     if (vs->csock == -1 || !vnc_has_feature(vs, VNC_FEATURE_RESIZE)) {\n         return;\n     }\n-    if (vs->client_width == surface_width(ds) &&\n-        vs->client_height == surface_height(ds)) {\n+    if (vs->client_width == pixman_image_get_width(vs->vd->server) &&\n+        vs->client_height == pixman_image_get_height(vs->vd->server)) {\n         return;\n     }\n-    vs->client_width = surface_width(ds);\n-    vs->client_height = surface_height(ds);\n+    vs->client_width = pixman_image_get_width(vs->vd->server);\n+    vs->client_height = pixman_image_get_height(vs->vd->server);\n     vnc_lock_output(vs);\n     vnc_write_u8(vs, VNC_MSG_SERVER_FRAMEBUFFER_UPDATE);\n     vnc_write_u8(vs, 0);\n@@ -571,31 +576,24 @@ void *vnc_server_fb_ptr(VncDisplay *vd, int x, int y)\n     ptr += x * VNC_SERVER_FB_BYTES;\n     return ptr;\n }\n-\/* this sets only the visible pixels of a dirty bitmap *\/\n-#define VNC_SET_VISIBLE_PIXELS_DIRTY(bitmap, w, h) {\\\n-        int y;\\\n-        memset(bitmap, 0x00, sizeof(bitmap));\\\n-        for (y = 0; y < h; y++) {\\\n-            bitmap_set(bitmap[y], 0,\\\n-                       DIV_ROUND_UP(w, VNC_DIRTY_PIXELS_PER_BIT));\\\n-        } \\\n-    }\n \n static void vnc_dpy_switch(DisplayChangeListener *dcl,\n                            DisplaySurface *surface)\n {\n     VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n     VncState *vs;\n+    int width, height;\n \n     vnc_abort_display_jobs(vd);\n \n     \/* server surface *\/\n     qemu_pixman_image_unref(vd->server);\n     vd->ds = surface;\n+    width = MIN(VNC_MAX_WIDTH, ROUND_UP(surface_width(vd->ds),\n+                                        VNC_DIRTY_PIXELS_PER_BIT));\n+    height = MIN(VNC_MAX_HEIGHT, surface_height(vd->ds));\n     vd->server = pixman_image_create_bits(VNC_SERVER_FB_FORMAT,\n-                                          surface_width(vd->ds),\n-                                          surface_height(vd->ds),\n-                                          NULL, 0);\n+                                          width, height, NULL, 0);\n \n     \/* guest surface *\/\n #if 0 \/* FIXME *\/\n@@ -605,9 +603,9 @@ static void vnc_dpy_switch(DisplayChangeListener *dcl,\n     qemu_pixman_image_unref(vd->guest.fb);\n     vd->guest.fb = pixman_image_ref(surface->image);\n     vd->guest.format = surface->format;\n-    VNC_SET_VISIBLE_PIXELS_DIRTY(vd->guest.dirty,\n-                                 surface_width(vd->ds),\n-                                 surface_height(vd->ds));\n+    memset(vd->guest.dirty, 0x00, sizeof(vd->guest.dirty));\n+    vnc_set_area_dirty(vd->guest.dirty, width, height, 0, 0,\n+                       width, height);\n \n     QTAILQ_FOREACH(vs, &vd->clients, next) {\n         vnc_colordepth(vs);\n@@ -615,9 +613,9 @@ static void vnc_dpy_switch(DisplayChangeListener *dcl,\n         if (vs->vd->cursor) {\n             vnc_cursor_define(vs);\n         }\n-        VNC_SET_VISIBLE_PIXELS_DIRTY(vs->dirty,\n-                                     surface_width(vd->ds),\n-                                     surface_height(vd->ds));\n+        memset(vs->dirty, 0x00, sizeof(vs->dirty));\n+        vnc_set_area_dirty(vs->dirty, width, height, 0, 0,\n+                           width, height);\n     }\n }\n \n@@ -911,8 +909,8 @@ static int vnc_update_client(VncState *vs, int has_dirty, bool sync)\n          *\/\n         job = vnc_job_new(vs);\n \n-        height = MIN(pixman_image_get_height(vd->server), vs->client_height);\n-        width = MIN(pixman_image_get_width(vd->server), vs->client_width);\n+        height = pixman_image_get_height(vd->server);\n+        width = pixman_image_get_width(vd->server);\n \n         y = 0;\n         for (;;) {\n@@ -1501,8 +1499,8 @@ static void check_pointer_type_change(Notifier *notifier, void *data)\n         vnc_write_u8(vs, 0);\n         vnc_write_u16(vs, 1);\n         vnc_framebuffer_update(vs, absolute, 0,\n-                               surface_width(vs->vd->ds),\n-                               surface_height(vs->vd->ds),\n+                               pixman_image_get_width(vs->vd->server),\n+                               pixman_image_get_height(vs->vd->server),\n                                VNC_ENCODING_POINTER_TYPE_CHANGE);\n         vnc_unlock_output(vs);\n         vnc_flush(vs);\n@@ -1520,8 +1518,8 @@ static void pointer_event(VncState *vs, int button_mask, int x, int y)\n         [INPUT_BUTTON_WHEEL_DOWN] = 0x10,\n     };\n     QemuConsole *con = vs->vd->dcl.con;\n-    int width = surface_width(vs->vd->ds);\n-    int height = surface_height(vs->vd->ds);\n+    int width = pixman_image_get_width(vs->vd->server);\n+    int height = pixman_image_get_height(vs->vd->server);\n \n     if (vs->last_bmask != button_mask) {\n         qemu_input_update_buttons(con, bmap, vs->last_bmask, button_mask);\n@@ -1869,29 +1867,18 @@ static void ext_key_event(VncState *vs, int down,\n }\n \n static void framebuffer_update_request(VncState *vs, int incremental,\n-                                       int x_position, int y_position,\n-                                       int w, int h)\n+                                       int x, int y, int w, int h)\n {\n-    int i;\n-    const size_t width = surface_width(vs->vd->ds) \/ VNC_DIRTY_PIXELS_PER_BIT;\n-    const size_t height = surface_height(vs->vd->ds);\n-\n-    if (y_position > height) {\n-        y_position = height;\n-    }\n-    if (y_position + h >= height) {\n-        h = height - y_position;\n-    }\n+    int width = pixman_image_get_width(vs->vd->server);\n+    int height = pixman_image_get_height(vs->vd->server);\n \n     vs->need_update = 1;\n-    if (!incremental) {\n-        vs->force_update = 1;\n-        for (i = 0; i < h; i++) {\n-            bitmap_set(vs->dirty[y_position + i], 0, width);\n-            bitmap_clear(vs->dirty[y_position + i], width,\n-                         VNC_DIRTY_BITS - width);\n-        }\n+\n+    if (incremental) {\n+        return;\n     }\n+\n+    vnc_set_area_dirty(vs->dirty, width, height, x, y, w, h);\n }\n \n static void send_ext_key_event_ack(VncState *vs)\n@@ -1901,8 +1888,8 @@ static void send_ext_key_event_ack(VncState *vs)\n     vnc_write_u8(vs, 0);\n     vnc_write_u16(vs, 1);\n     vnc_framebuffer_update(vs, 0, 0,\n-                           surface_width(vs->vd->ds),\n-                           surface_height(vs->vd->ds),\n+                           pixman_image_get_width(vs->vd->server),\n+                           pixman_image_get_height(vs->vd->server),\n                            VNC_ENCODING_EXT_KEY_EVENT);\n     vnc_unlock_output(vs);\n     vnc_flush(vs);\n@@ -1915,8 +1902,8 @@ static void send_ext_audio_ack(VncState *vs)\n     vnc_write_u8(vs, 0);\n     vnc_write_u16(vs, 1);\n     vnc_framebuffer_update(vs, 0, 0,\n-                           surface_width(vs->vd->ds),\n-                           surface_height(vs->vd->ds),\n+                           pixman_image_get_width(vs->vd->server),\n+                           pixman_image_get_height(vs->vd->server),\n                            VNC_ENCODING_AUDIO);\n     vnc_unlock_output(vs);\n     vnc_flush(vs);\n@@ -2094,8 +2081,8 @@ static void vnc_colordepth(VncState *vs)\n         vnc_write_u8(vs, 0);\n         vnc_write_u16(vs, 1); \/* number of rects *\/\n         vnc_framebuffer_update(vs, 0, 0,\n-                               surface_width(vs->vd->ds),\n-                               surface_height(vs->vd->ds),\n+                               pixman_image_get_width(vs->vd->server),\n+                               pixman_image_get_height(vs->vd->server),\n                                VNC_ENCODING_WMVi);\n         pixel_format_message(vs);\n         vnc_unlock_output(vs);\n@@ -2317,8 +2304,8 @@ static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n     }\n     vnc_set_share_mode(vs, mode);\n \n-    vs->client_width = surface_width(vs->vd->ds);\n-    vs->client_height = surface_height(vs->vd->ds);\n+    vs->client_width = pixman_image_get_width(vs->vd->server);\n+    vs->client_height = pixman_image_get_height(vs->vd->server);\n     vnc_write_u16(vs, vs->client_width);\n     vnc_write_u16(vs, vs->client_height);\n \n@@ -2685,12 +2672,12 @@ static void vnc_rect_updated(VncDisplay *vd, int x, int y, struct timeval * tv)\n \n static int vnc_refresh_server_surface(VncDisplay *vd)\n {\n-    int width = pixman_image_get_width(vd->guest.fb);\n-    int height = pixman_image_get_height(vd->guest.fb);\n-    int y;\n+    int width = MIN(pixman_image_get_width(vd->guest.fb),\n+                    pixman_image_get_width(vd->server));\n+    int height = MIN(pixman_image_get_height(vd->guest.fb),\n+                     pixman_image_get_height(vd->server));\n+    int cmp_bytes, server_stride, min_stride, guest_stride, y = 0;\n     uint8_t *guest_row0 = NULL, *server_row0;\n-    int guest_stride = 0, server_stride;\n-    int cmp_bytes;\n     VncState *vs;\n     int has_dirty = 0;\n     pixman_image_t *tmpbuf = NULL;\n@@ -2707,10 +2694,10 @@ static int vnc_refresh_server_surface(VncDisplay *vd)\n      * Check and copy modified bits from guest to server surface.\n      * Update server dirty map.\n      *\/\n-    cmp_bytes = VNC_DIRTY_PIXELS_PER_BIT * VNC_SERVER_FB_BYTES;\n-    if (cmp_bytes > vnc_server_fb_stride(vd)) {\n-        cmp_bytes = vnc_server_fb_stride(vd);\n-    }\n+    server_row0 = (uint8_t *)pixman_image_get_data(vd->server);\n+    server_stride = guest_stride = pixman_image_get_stride(vd->server);\n+    cmp_bytes = MIN(VNC_DIRTY_PIXELS_PER_BIT * VNC_SERVER_FB_BYTES,\n+                    server_stride);\n     if (vd->guest.format != VNC_SERVER_FB_FORMAT) {\n         int width = pixman_image_get_width(vd->server);\n         tmpbuf = qemu_pixman_linebuf_create(VNC_SERVER_FB_FORMAT, width);\n@@ -2718,10 +2705,8 @@ static int vnc_refresh_server_surface(VncDisplay *vd)\n         guest_row0 = (uint8_t *)pixman_image_get_data(vd->guest.fb);\n         guest_stride = pixman_image_get_stride(vd->guest.fb);\n     }\n-    server_row0 = (uint8_t *)pixman_image_get_data(vd->server);\n-    server_stride = pixman_image_get_stride(vd->server);\n+    min_stride = MIN(server_stride, guest_stride);\n \n-    y = 0;\n     for (;;) {\n         int x;\n         uint8_t *guest_ptr, *server_ptr;\n@@ -2747,13 +2732,17 @@ static int vnc_refresh_server_surface(VncDisplay *vd)\n \n         for (; x < DIV_ROUND_UP(width, VNC_DIRTY_PIXELS_PER_BIT);\n              x++, guest_ptr += cmp_bytes, server_ptr += cmp_bytes) {\n+            int _cmp_bytes = cmp_bytes;\n             if (!test_and_clear_bit(x, vd->guest.dirty[y])) {\n                 continue;\n             }\n-            if (memcmp(server_ptr, guest_ptr, cmp_bytes) == 0) {\n+            if ((x + 1) * cmp_bytes > min_stride) {\n+                _cmp_bytes = min_stride - x * cmp_bytes;\n+            }\n+            if (memcmp(server_ptr, guest_ptr, _cmp_bytes) == 0) {\n                 continue;\n             }\n-            memcpy(server_ptr, guest_ptr, cmp_bytes);\n+            memcpy(server_ptr, guest_ptr, _cmp_bytes);\n             if (!vd->non_adaptive) {\n                 vnc_rect_updated(vd, x * VNC_DIRTY_PIXELS_PER_BIT,\n                                  y, &tv);\ndiff --git a\/ui\/vnc.h b\/ui\/vnc.h\nindex 07af9f7..8f582fd 100644\n--- a\/ui\/vnc.h\n+++ b\/ui\/vnc.h\n@@ -77,14 +77,15 @@ typedef void VncSendHextileTile(VncState *vs,\n                                 void *last_fg,\n                                 int *has_bg, int *has_fg);\n \n-\/* VNC_MAX_WIDTH must be a multiple of 16. *\/\n-#define VNC_MAX_WIDTH 2560\n-#define VNC_MAX_HEIGHT 2048\n-\n \/* VNC_DIRTY_PIXELS_PER_BIT is the number of dirty pixels represented\n- * by one bit in the dirty bitmap *\/\n+ * by one bit in the dirty bitmap, should be a power of 2 *\/\n #define VNC_DIRTY_PIXELS_PER_BIT 16\n \n+\/* VNC_MAX_WIDTH must be a multiple of VNC_DIRTY_PIXELS_PER_BIT. *\/\n+\n+#define VNC_MAX_WIDTH ROUND_UP(2560, VNC_DIRTY_PIXELS_PER_BIT)\n+#define VNC_MAX_HEIGHT 2048\n+\n \/* VNC_DIRTY_BITS is the number of bits in the dirty bitmap. *\/\n #define VNC_DIRTY_BITS (VNC_MAX_WIDTH \/ VNC_DIRTY_PIXELS_PER_BIT)\n \n@@ -126,7 +127,8 @@ typedef struct VncRectStat VncRectStat;\n struct VncSurface\n {\n     struct timeval last_freq_check;\n-    DECLARE_BITMAP(dirty[VNC_MAX_HEIGHT], VNC_MAX_WIDTH \/ 16);\n+    DECLARE_BITMAP(dirty[VNC_MAX_HEIGHT],\n+                   VNC_MAX_WIDTH \/ VNC_DIRTY_PIXELS_PER_BIT);\n     VncRectStat stats[VNC_STAT_ROWS][VNC_STAT_COLS];\n     pixman_image_t *fb;\n     pixman_format_code_t format;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7915","CWE_ID":"125","category":"security","commit_id":"50220dead1650609206efe91f0cc116132d59b3f","commit_message":"From 50220dead1650609206efe91f0cc116132d59b3f Mon Sep 17 00:00:00 2001\nFrom: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nDate: Tue, 19 Jan 2016 12:34:58 +0100\nSubject: [PATCH] HID: core: prevent out-of-bound readings\n\nPlugging a Logitech DJ receiver with KASAN activated raises a bunch of\nout-of-bound readings.\n\nThe fields are allocated up to MAX_USAGE, meaning that potentially, we do\nnot have enough fields to fit the incoming values.\nAdd checks and silence KASAN.\n\nSigned-off-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>\nSigned-off-by: Jiri Kosina <jkosina@suse.cz>\n---\n drivers\/hid\/hid-core.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/hid\/hid-core.c b\/drivers\/hid\/hid-core.c\nindex 16c2c660ab5a5..3f6ac5f2862d8 100644\n--- a\/drivers\/hid\/hid-core.c\n+++ b\/drivers\/hid\/hid-core.c\n@@ -1293,6 +1293,7 @@ static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n \t\t\/* Ignore report if ErrorRollOver *\/\n \t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n \t\t    value[n] >= min && value[n] <= max &&\n+\t\t    value[n] - min < field->maxusage &&\n \t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n \t\t\tgoto exit;\n \t}\n@@ -1305,11 +1306,13 @@ static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n \t\t}\n \n \t\tif (field->value[n] >= min && field->value[n] <= max\n+\t\t\t&& field->value[n] - min < field->maxusage\n \t\t\t&& field->usage[field->value[n] - min].hid\n \t\t\t&& search(value, field->value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n \n \t\tif (value[n] >= min && value[n] <= max\n+\t\t\t&& value[n] - min < field->maxusage\n \t\t\t&& field->usage[value[n] - min].hid\n \t\t\t&& search(field->value, value[n], count))\n \t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-9583","CWE_ID":"125","category":"security","commit_id":"aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d","commit_message":"From aa0b0f79ade5eef8b0e7a214c03f5af54b36ba7d Mon Sep 17 00:00:00 2001\nFrom: Michael Adams <mdadams@ece.uvic.ca>\nDate: Sat, 26 Nov 2016 17:14:09 -0800\nSubject: [PATCH] Fixed numerous integer overflow problems in the code for\n packet iterators in the JPC decoder.\n\n---\n src\/libjasper\/include\/jasper\/jas_types.h |   4 +\n src\/libjasper\/jpc\/jpc_t2cod.c            | 130 ++++++++++++++---------\n src\/libjasper\/jpc\/jpc_t2dec.c            |  42 ++++----\n 3 files changed, 102 insertions(+), 74 deletions(-)\n\n","diff_code":"diff --git a\/src\/libjasper\/include\/jasper\/jas_types.h b\/src\/libjasper\/include\/jasper\/jas_types.h\nindex bd83ca5..0d4a196 100644\n--- a\/src\/libjasper\/include\/jasper\/jas_types.h\n+++ b\/src\/libjasper\/include\/jasper\/jas_types.h\n@@ -116,6 +116,10 @@\n #define\tJAS_CAST(t, e) \\\n \t((t) (e))\n \n+\/* The number of bits in the integeral type uint_fast32_t. *\/\n+\/* NOTE: This could underestimate the size on some exotic architectures. *\/\n+#define JAS_UINTFAST32_NUMBITS (8 * sizeof(uint_fast32_t))\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\ndiff --git a\/src\/libjasper\/jpc\/jpc_t2cod.c b\/src\/libjasper\/jpc\/jpc_t2cod.c\nindex 679516f..5e2c862 100644\n--- a\/src\/libjasper\/jpc\/jpc_t2cod.c\n+++ b\/src\/libjasper\/jpc\/jpc_t2cod.c\n@@ -198,7 +198,8 @@ static int jpc_pi_nextrlcp(register jpc_pi_t *pi)\n \t\t  JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n \t\t\tfor (pi->compno = pchg->compnostart, pi->picomp =\n \t\t\t  &pi->picomps[pi->compno]; pi->compno < pi->numcomps &&\n-\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno, ++pi->picomp) {\n+\t\t\t  pi->compno < JAS_CAST(int, pchg->compnoend); ++pi->compno,\n+\t\t\t  ++pi->picomp) {\n \t\t\t\tif (pi->rlvlno >= pi->picomp->numrlvls) {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n@@ -247,10 +248,17 @@ static int jpc_pi_nextrpcl(register jpc_pi_t *pi)\n \t\t  ++compno, ++picomp) {\n \t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n \t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n-\t\t\t\txstep = picomp->hsamp * (1 << (pirlvl->prcwidthexpn +\n-\t\t\t\t  picomp->numrlvls - rlvlno - 1));\n-\t\t\t\tystep = picomp->vsamp * (1 << (pirlvl->prcheightexpn +\n-\t\t\t\t  picomp->numrlvls - rlvlno - 1));\n+\t\t\t\t\/\/ Check for the potential for overflow problems.\n+\t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n+\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n+\t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n+\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t\txstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n+\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));\n+\t\t\t\tystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n+\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));\n \t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);\n \t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);\n \t\t\t}\n@@ -280,21 +288,24 @@ static int jpc_pi_nextrpcl(register jpc_pi_t *pi)\n \t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n \t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n \t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n-\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx)))\n-\t\t\t\t\t  || !(pi->x % (1 << rpx))) &&\n-\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy)))\n-\t\t\t\t\t  || !(pi->y % (1 << rpy)))) {\n-\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n-\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n-\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n-\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n-\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n-\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n+\t\t\t\t\tif (((pi->x == pi->xstart &&\n+\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))\n+\t\t\t\t\t  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&\n+\t\t\t\t\t  ((pi->y == pi->ystart &&\n+\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))\n+\t\t\t\t\t  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {\n+\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n+\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n+\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n+\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n+\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n+\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n \t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n \n \t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n \t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n-\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n+\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int,\n+\t\t\t\t\t\t  pchg->lyrnoend); ++pi->lyrno) {\n \t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n \t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n \t\t\t\t\t\t\t\t++(*prclyrno);\n@@ -339,16 +350,19 @@ static int jpc_pi_nextpcrl(register jpc_pi_t *pi)\n \t\t  ++compno, ++picomp) {\n \t\t\tfor (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <\n \t\t\t  picomp->numrlvls; ++rlvlno, ++pirlvl) {\n-\t\t\t\txstep = picomp->hsamp * (1 <<\n-\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls -\n-\t\t\t\t  rlvlno - 1));\n-\t\t\t\tystep = picomp->vsamp * (1 <<\n-\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls -\n-\t\t\t\t  rlvlno - 1));\n-\t\t\t\tpi->xstep = (!pi->xstep) ? xstep :\n-\t\t\t\t  JAS_MIN(pi->xstep, xstep);\n-\t\t\t\tpi->ystep = (!pi->ystep) ? ystep :\n-\t\t\t\t  JAS_MIN(pi->ystep, ystep);\n+\t\t\t\t\/\/ Check for the potential for overflow problems.\n+\t\t\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n+\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n+\t\t\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n+\t\t\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t\txstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n+\t\t\t\t  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));\n+\t\t\t\tystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n+\t\t\t\t  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));\n+\t\t\t\tpi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);\n+\t\t\t\tpi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);\n \t\t\t}\n \t\t}\n \t\tpi->prgvolfirst = 0;\n@@ -375,20 +389,23 @@ static int jpc_pi_nextpcrl(register jpc_pi_t *pi)\n \t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n \t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n \t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n-\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n+\t\t\t\t\tif (((pi->x == pi->xstart &&\n+\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||\n \t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n-\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n+\t\t\t\t\t  ((pi->y == pi->ystart &&\n+\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||\n \t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n-\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n-\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n-\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n-\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n-\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n-\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n+\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n+\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n+\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n+\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n+\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n+\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n \t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n \t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n \t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&\n-\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n+\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);\n+\t\t\t\t\t\t  ++pi->lyrno) {\n \t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n \t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n \t\t\t\t\t\t\t\t++(*prclyrno);\n@@ -426,10 +443,17 @@ static int jpc_pi_nextcprl(register jpc_pi_t *pi)\n \t\tpi->prgvolfirst = 0;\n \t}\n \n-\tfor (pi->compno = pchg->compnostart, pi->picomp =\n-\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n-\t  ++pi->picomp) {\n+\tfor (pi->compno = pchg->compnostart, pi->picomp = &pi->picomps[pi->compno];\n+\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps;\n+\t  ++pi->compno, ++pi->picomp) {\n \t\tpirlvl = pi->picomp->pirlvls;\n+\t\t\/\/ Check for the potential for overflow problems.\n+\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n+\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n+\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n+\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n+\t\t\treturn -1;\n+\t\t}\n \t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n \t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n \t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n@@ -459,23 +483,23 @@ static int jpc_pi_nextcprl(register jpc_pi_t *pi)\n \t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n \t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n \t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n-\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n+\t\t\t\t\tif (((pi->x == pi->xstart &&\n+\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||\n \t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n-\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n+\t\t\t\t\t  ((pi->y == pi->ystart &&\n+\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||\n \t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n-\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n-\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n-\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n-\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n-\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n-\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n-\t\t\t\t\t\tpi->prcno = prcvind *\n-\t\t\t\t\t\t  pi->pirlvl->numhprcs +\n-\t\t\t\t\t\t  prchind;\n-\t\t\t\t\t\tassert(pi->prcno <\n-\t\t\t\t\t\t  pi->pirlvl->numprcs);\n-\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n-\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n+\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n+\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n+\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n+\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n+\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n+\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n+\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n+\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n+\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&\n+\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);\n+\t\t\t\t\t\t  ++pi->lyrno) {\n \t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n \t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n \t\t\t\t\t\t\t\t++(*prclyrno);\ndiff --git a\/src\/libjasper\/jpc\/jpc_t2dec.c b\/src\/libjasper\/jpc\/jpc_t2dec.c\nindex 8300f9b..34d01d5 100644\n--- a\/src\/libjasper\/jpc\/jpc_t2dec.c\n+++ b\/src\/libjasper\/jpc\/jpc_t2dec.c\n@@ -423,39 +423,39 @@ int jpc_dec_decodepkts(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t\n \ttile = dec->curtile;\n \tpi = tile->pi;\n \tfor (;;) {\n-if (!tile->pkthdrstream || jas_stream_peekc(tile->pkthdrstream) == EOF) {\n-\t\tswitch (jpc_dec_lookahead(in)) {\n-\t\tcase JPC_MS_EOC:\n-\t\tcase JPC_MS_SOT:\n-\t\t\treturn 0;\n-\t\t\tbreak;\n-\t\tcase JPC_MS_SOP:\n-\t\tcase JPC_MS_EPH:\n-\t\tcase 0:\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\treturn -1;\n-\t\t\tbreak;\n+\t\tif (!tile->pkthdrstream || jas_stream_peekc(tile->pkthdrstream) == EOF) {\n+\t\t\tswitch (jpc_dec_lookahead(in)) {\n+\t\t\tcase JPC_MS_EOC:\n+\t\t\tcase JPC_MS_SOT:\n+\t\t\t\treturn 0;\n+\t\t\t\tbreak;\n+\t\t\tcase JPC_MS_SOP:\n+\t\t\tcase JPC_MS_EPH:\n+\t\t\tcase 0:\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\treturn -1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n-}\n \t\tif ((ret = jpc_pi_next(pi))) {\n \t\t\treturn ret;\n \t\t}\n-if (dec->maxpkts >= 0 && dec->numpkts >= dec->maxpkts) {\n-\tjas_eprintf(\"warning: stopping decode prematurely as requested\\n\");\n-\treturn 0;\n-}\n+\t\tif (dec->maxpkts >= 0 && dec->numpkts >= dec->maxpkts) {\n+\t\t\tjas_eprintf(\"warning: stopping decode prematurely as requested\\n\");\n+\t\t\treturn 0;\n+\t\t}\n \t\tif (jas_getdbglevel() >= 1) {\n \t\t\tjas_eprintf(\"packet offset=%08ld prg=%d cmptno=%02d \"\n \t\t\t  \"rlvlno=%02d prcno=%03d lyrno=%02d\\n\", (long)\n \t\t\t  jas_stream_getrwcount(in), jpc_pi_prg(pi), jpc_pi_cmptno(pi),\n \t\t\t  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi));\n \t\t}\n-\t\tif (jpc_dec_decodepkt(dec, pkthdrstream, in, jpc_pi_cmptno(pi), jpc_pi_rlvlno(pi),\n-\t\t  jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {\n+\t\tif (jpc_dec_decodepkt(dec, pkthdrstream, in, jpc_pi_cmptno(pi),\n+\t\t  jpc_pi_rlvlno(pi), jpc_pi_prcno(pi), jpc_pi_lyrno(pi))) {\n \t\t\treturn -1;\n \t\t}\n-++dec->numpkts;\n+\t\t++dec->numpkts;\n \t}\n \n \treturn 0;\n","owner":"mdadams","repo":"jasper","source":"cve"},{"CVE_ID":"CVE-2016-7527","CWE_ID":"125","category":"security","commit_id":"a251039393f423c7858e63cab6aa98d17b8b7a41","commit_message":"From a251039393f423c7858e63cab6aa98d17b8b7a41 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 5 Feb 2016 21:07:12 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/122\n\n---\n coders\/wpg.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/wpg.c b\/coders\/wpg.c\nindex ea987fd31a..1e898eb258 100644\n--- a\/coders\/wpg.c\n+++ b\/coders\/wpg.c\n@@ -794,7 +794,7 @@ static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n   if(exception->severity != UndefinedException) goto FINISH_UNL;\n   if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n \n-  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MaxTextExtent);\n+  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);\n \n     \/* Read nested image *\/\n   \/*FormatString(clone_info->filename,\"%s:%s\",magic_info->name,postscript_file);*\/\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-5811","CWE_ID":"125","category":"security","commit_id":"fd6330292501983ac75fe4162275794b18445bd9","commit_message":"From fd6330292501983ac75fe4162275794b18445bd9 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Tue, 24 Apr 2018 15:17:31 +0300\nSubject: [PATCH] Secunia 81800#1: samsumg_load_raw\n\nSecunia 81800#2: find_green\n\nSecunia 81800#3: rollei_load_raw\n\nremove_trailing_spaces: isspace() does not works right with signed non-latin chars\n\nSecunia 81800#5\/6: nikon_coolscan_load_raw\n\nSecunia 81800#4: rollei_load_raw\n---\n dcraw\/dcraw.c             | 157 ++++++++++++++++++++++++++------------\n internal\/dcraw_common.cpp | 156 +++++++++++++++++++++++++------------\n internal\/defines.h        |   1 +\n 3 files changed, 216 insertions(+), 98 deletions(-)\n\n","diff_code":"diff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 1c6bf662..e2b9c7d4 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -251,6 +251,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n \/\/@end DEFINES\n@@ -1511,9 +1512,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1794,7 +1800,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1810,8 +1821,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3857,6 +3871,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3875,11 +3894,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -11081,37 +11106,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -15077,7 +15133,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -15100,14 +15157,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex cfb82a27..b430d3e5 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -1228,9 +1228,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1506,7 +1511,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1522,8 +1532,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3569,6 +3582,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3587,11 +3605,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -9890,37 +9914,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -13739,7 +13794,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -13762,14 +13818,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/defines.h b\/internal\/defines.h\nindex b84e1d28..06e171ec 100644\n--- a\/internal\/defines.h\n+++ b\/internal\/defines.h\n@@ -153,6 +153,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n #define BAYER(row,col) \\\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2017-5847","CWE_ID":"125","category":"security","commit_id":"d21017b52a585f145e8d62781bcc1c5fefc7ee37","commit_message":"From d21017b52a585f145e8d62781bcc1c5fefc7ee37 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Sebastian=20Dr=C3=B6ge?= <sebastian@centricular.com>\nDate: Tue, 31 Jan 2017 13:50:21 +0200\nSubject: [PATCH] asfdemux: Check that we have enough data available before\n parsing bool\/uint extended content descriptors\n\nhttps:\/\/bugzilla.gnome.org\/show_bug.cgi?id=777955\n---\n gst\/asfdemux\/gstasfdemux.c | 14 ++++++++++++--\n 1 file changed, 12 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/gst\/asfdemux\/gstasfdemux.c b\/gst\/asfdemux\/gstasfdemux.c\nindex 255a427f..b8d48ad6 100644\n--- a\/gst\/asfdemux\/gstasfdemux.c\n+++ b\/gst\/asfdemux\/gstasfdemux.c\n@@ -3439,7 +3439,12 @@ gst_asf_demux_process_ext_content_desc (GstASFDemux * demux, guint8 * data,\n           break;\n         }\n         case ASF_DEMUX_DATA_TYPE_DWORD:{\n-          guint uint_val = GST_READ_UINT32_LE (value);\n+          guint uint_val;\n+\n+          if (value_len < 4)\n+            break;\n+\n+          uint_val = GST_READ_UINT32_LE (value);\n \n           \/* this is the track number *\/\n           g_value_init (&tag_value, G_TYPE_UINT);\n@@ -3453,7 +3458,12 @@ gst_asf_demux_process_ext_content_desc (GstASFDemux * demux, guint8 * data,\n         }\n           \/* Detect 3D *\/\n         case ASF_DEMUX_DATA_TYPE_BOOL:{\n-          gboolean bool_val = GST_READ_UINT32_LE (value);\n+          gboolean bool_val;\n+\n+          if (value_len < 4)\n+            break;\n+\n+          bool_val = GST_READ_UINT32_LE (value);\n \n           if (strncmp (\"Stereoscopic\", name_utf8, strlen (name_utf8)) == 0) {\n             if (bool_val) {\n","owner":"GStreamer","repo":"gst-plugins-ugly","source":"cve"},{"CVE_ID":"CVE-2016-10195","CWE_ID":"125","category":"security","commit_id":"96f64a022014a208105ead6c8a7066018449d86d","commit_message":"From 96f64a022014a208105ead6c8a7066018449d86d Mon Sep 17 00:00:00 2001\nFrom: Azat Khuzhin <a3at.mail@gmail.com>\nDate: Mon, 1 Feb 2016 17:32:09 +0300\nSubject: [PATCH] evdns: name_parse(): fix remote stack overread\n\n@asn-the-goblin-slayer:\n  \"the name_parse() function in libevent's DNS code is vulnerable to a buffer overread.\n\n   971         if (cp != name_out) {\n   972             if (cp + 1 >= end) return -1;\n   973             *cp++ = '.';\n   974         }\n   975         if (cp + label_len >= end) return -1;\n   976         memcpy(cp, packet + j, label_len);\n   977         cp += label_len;\n   978         j += label_len;\n   No check is made against length before the memcpy occurs.\n\n   This was found through the Tor bug bounty program and the discovery should be credited to 'Guido Vranken'.\"\n\nReproducer for gdb (https:\/\/gist.github.com\/azat\/e4fcf540e9b89ab86d02):\n  set $PROT_NONE=0x0\n  set $PROT_READ=0x1\n  set $PROT_WRITE=0x2\n  set $MAP_ANONYMOUS=0x20\n  set $MAP_SHARED=0x01\n  set $MAP_FIXED=0x10\n  set $MAP_32BIT=0x40\n\n  start\n\n  set $length=202\n  # overread\n  set $length=2\n  # allocate with mmap to have a seg fault on page boundary\n  set $l=(1<<20)*2\n  p mmap(0, $l, $PROT_READ|$PROT_WRITE, $MAP_ANONYMOUS|$MAP_SHARED|$MAP_32BIT, -1, 0)\n  set $packet=(char *)$1+$l-$length\n  # hack the packet\n  set $packet[0]=63\n  set $packet[1]='\/'\n\n  p malloc(sizeof(int))\n  set $idx=(int *)$2\n  set $idx[0]=0\n  set $name_out_len=202\n\n  p malloc($name_out_len)\n  set $name_out=$3\n\n  # have WRITE only mapping to fail on read\n  set $end=$1+$l\n  p (void *)mmap($end, 1<<12, $PROT_NONE, $MAP_ANONYMOUS|$MAP_SHARED|$MAP_FIXED|$MAP_32BIT, -1, 0)\n  set $m=$4\n\n  p name_parse($packet, $length, $idx, $name_out, $name_out_len)\n  x\/2s (char *)$name_out\n\nBefore this patch:\n$ gdb -ex 'source gdb' dns-example\n$1 = 1073741824\n$2 = (void *) 0x633010\n$3 = (void *) 0x633030\n$4 = (void *) 0x40200000\n\nProgram received signal SIGSEGV, Segmentation fault.\n__memcpy_sse2_unaligned () at memcpy-sse2-unaligned.S:33\n\nAfter this patch:\n$ gdb -ex 'source gdb' dns-example\n$1 = 1073741824\n$2 = (void *) 0x633010\n$3 = (void *) 0x633030\n$4 = (void *) 0x40200000\n$5 = -1\n0x633030:       \"\/\"\n0x633032:       \"\"\n(gdb) p $m\n$6 = (void *) 0x40200000\n(gdb) p $1\n$7 = 1073741824\n(gdb) p\/x $1\n$8 = 0x40000000\n(gdb) quit\n\nP.S. plus drop one condition duplicate.\n\nFixes: #317\n---\n evdns.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/evdns.c b\/evdns.c\nindex 0955a2898..c4112330a 100644\n--- a\/evdns.c\n+++ b\/evdns.c\n@@ -976,7 +976,6 @@ name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n \n \tfor (;;) {\n \t\tu8 label_len;\n-\t\tif (j >= length) return -1;\n \t\tGET8(label_len);\n \t\tif (!label_len) break;\n \t\tif (label_len & 0xc0) {\n@@ -997,6 +996,7 @@ name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n \t\t\t*cp++ = '.';\n \t\t}\n \t\tif (cp + label_len >= end) return -1;\n+\t\tif (j + label_len > length) return -1;\n \t\tmemcpy(cp, packet + j, label_len);\n \t\tcp += label_len;\n \t\tj += label_len;\n","owner":"libevent","repo":"libevent","source":"cve"},{"CVE_ID":"CVE-2016-6906","CWE_ID":"125","category":"security","commit_id":"58b6dde319c301b0eae27d12e2a659e067d80558","commit_message":"From 58b6dde319c301b0eae27d12e2a659e067d80558 Mon Sep 17 00:00:00 2001\nFrom: \"Christoph M. Becker\" <cmbecker69@gmx.de>\nDate: Tue, 16 Aug 2016 16:26:19 +0200\nSubject: [PATCH] Fix OOB reads of the TGA decompression buffer\n\nIt is possible to craft TGA files which will overflow the decompression\nbuffer, but not the image's bitmap. Therefore we also have to check for\npotential decompression buffer overflows.\n\nThis issue had been reported by Ibrahim El-Sayed to security@libgd.org;\na modified case exposing an off-by-one error of the first patch had been\nprovided by Konrad Beckmann.\n\nThis commit is an amendment to commit fb0e0cce, so we use CVE-2016-6906\nas well.\n---\n src\/gd_tga.c                  |   8 +++++++-\n tests\/tga\/Makemodule.am       |   3 ++-\n tests\/tga\/heap_overflow.c     |  16 ++++++++++++----\n tests\/tga\/heap_overflow_1.tga | Bin 0 -> 605 bytes\n tests\/tga\/heap_overflow_2.tga | Bin 0 -> 8746 bytes\n 5 files changed, 21 insertions(+), 6 deletions(-)\n create mode 100644 tests\/tga\/heap_overflow_1.tga\n create mode 100644 tests\/tga\/heap_overflow_2.tga\n\n","diff_code":"diff --git a\/src\/gd_tga.c b\/src\/gd_tga.c\nindex 68e4b17d..f80f0b16 100644\n--- a\/src\/gd_tga.c\n+++ b\/src\/gd_tga.c\n@@ -295,7 +295,13 @@ int read_image_tga( gdIOCtx *ctx, oTga *tga )\n \t\tbuffer_caret = 0;\n \n \t\twhile( bitmap_caret < image_block_size ) {\n-\t\t\t\n+\n+\t\t\tif (buffer_caret + pixel_block_size > rle_size) {\n+\t\t\t\tgdFree( decompression_buffer );\n+\t\t\t\tgdFree( conversion_buffer );\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\n \t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n \t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );\n \t\t\t\tbuffer_caret++;\ndiff --git a\/tests\/tga\/Makemodule.am b\/tests\/tga\/Makemodule.am\nindex 916d7073..ab08dbff 100644\n--- a\/tests\/tga\/Makemodule.am\n+++ b\/tests\/tga\/Makemodule.am\n@@ -15,7 +15,8 @@ EXTRA_DIST += \\\n \ttga\/bug00247a.tga \\\n \ttga\/bug00248.tga \\\n \ttga\/bug00248a.tga \\\n-\ttga\/heap_overflow.tga \\\n+\ttga\/heap_overflow_1.tga \\\n+\ttga\/heap_overflow_2.tga \\\n \ttga\/tga_read_rgb.png \\\n \ttga\/tga_read_rgb.tga \\\n \ttga\/tga_read_rgb_rle.tga\ndiff --git a\/tests\/tga\/heap_overflow.c b\/tests\/tga\/heap_overflow.c\nindex 0e9a2d00..ddd4b63e 100644\n--- a\/tests\/tga\/heap_overflow.c\n+++ b\/tests\/tga\/heap_overflow.c\n@@ -1,5 +1,5 @@\n \/**\n- * Test that the crafted TGA file doesn't trigger OOB reads.\n+ * Test that crafted TGA files don't trigger OOB reads.\n  *\/\n \n \n@@ -7,21 +7,29 @@\n #include \"gdtest.h\"\n \n \n+static void check_file(char *basename);\n static size_t read_test_file(char **buffer, char *basename);\n \n \n int main()\n+{\n+    check_file(\"heap_overflow_1.tga\");\n+    check_file(\"heap_overflow_2.tga\");\n+\n+    return gdNumFailures();\n+}\n+\n+\n+static void check_file(char *basename)\n {\n     gdImagePtr im;\n     char *buffer;\n     size_t size;\n \n-    size = read_test_file(&buffer, \"heap_overflow.tga\");\n+    size = read_test_file(&buffer, basename);\n     im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n     gdTestAssert(im == NULL);\n     free(buffer);\n-\n-    return gdNumFailures();\n }\n \n \ndiff --git a\/tests\/tga\/heap_overflow_1.tga b\/tests\/tga\/heap_overflow_1.tga\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..e9bc0ecb2a847ac6edba92dd0ff61167b49002cd\nGIT binary patch\nliteral 605\nzcmZQz;9`IQ9tIu;g&7<$F3o7Yg1qzyh6tefy9wZAs2d<Uh*yuz=?XwW4Qvuv#g2nS\nzp93+mT0rVR>T&8(2TGy=f_l)@gSap~$FayUFu(!|SyJIFga^{8fGj~vwq8kkVgvv>\nCavop+\n\nliteral 0\nHcmV?d00001\n\ndiff --git a\/tests\/tga\/heap_overflow_2.tga b\/tests\/tga\/heap_overflow_2.tga\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..2b681f2df8941d6823aa761be0a7fa3c02c92cbf\nGIT binary patch\nliteral 8746\nzcmeIxF$#b%6a>*<djij4?cuz+Vi5?!RIY)@*eDAQ@`zPSwQE1NTI<YQEqdQG#s5@h\nzwDFtAoIjm)CIQa|$z*q(vz}DbnPjrN&RI{Y=}a=&UFWPP)joCZ<31}ey8!(}FZZ71\nzWop>#e)AY=opmMw&j!h4cb&7IRMVMcvb)Y%PpaumGTB|{tS8lUCYkK6bJmk;IzMDC\nD4PYIN\n\nliteral 0\nHcmV?d00001\n\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2017-3731","CWE_ID":"125","category":"security","commit_id":"00d965474b22b54e4275232bc71ee0c699c5cd21","commit_message":"From 00d965474b22b54e4275232bc71ee0c699c5cd21 Mon Sep 17 00:00:00 2001\nFrom: Andy Polyakov <appro@openssl.org>\nDate: Thu, 19 Jan 2017 00:20:49 +0100\nSubject: [PATCH] crypto\/evp: harden AEAD ciphers.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nOriginally a crash in 32-bit build was reported CHACHA20-POLY1305\ncipher. The crash is triggered by truncated packet and is result\nof excessive hashing to the edge of accessible memory. Since hash\noperation is read-only it is not considered to be exploitable\nbeyond a DoS condition. Other ciphers were hardened.\n\nThanks to Robert \u015awi\u0119cki for report.\n\nCVE-2017-3731\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n---\n crypto\/evp\/e_aes.c               | 14 ++++++++++++--\n crypto\/evp\/e_chacha20_poly1305.c |  5 +++--\n 2 files changed, 15 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/evp\/e_aes.c b\/crypto\/evp\/e_aes.c\nindex ab981502866..619c6f85cb1 100644\n--- a\/crypto\/evp\/e_aes.c\n+++ b\/crypto\/evp\/e_aes.c\n@@ -1388,10 +1388,15 @@ static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\n                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8\n                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];\n             \/* Correct length for explicit IV *\/\n+            if (len < EVP_GCM_TLS_EXPLICIT_IV_LEN)\n+                return 0;\n             len -= EVP_GCM_TLS_EXPLICIT_IV_LEN;\n             \/* If decrypting correct for tag too *\/\n-            if (!EVP_CIPHER_CTX_encrypting(c))\n+            if (!EVP_CIPHER_CTX_encrypting(c)) {\n+                if (len < EVP_GCM_TLS_TAG_LEN)\n+                    return 0;\n                 len -= EVP_GCM_TLS_TAG_LEN;\n+            }\n             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;\n             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;\n         }\n@@ -1946,10 +1951,15 @@ static int aes_ccm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr)\n                 EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8\n                 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1];\n             \/* Correct length for explicit IV *\/\n+            if (len < EVP_CCM_TLS_EXPLICIT_IV_LEN)\n+                return 0;\n             len -= EVP_CCM_TLS_EXPLICIT_IV_LEN;\n             \/* If decrypting correct for tag too *\/\n-            if (!EVP_CIPHER_CTX_encrypting(c))\n+            if (!EVP_CIPHER_CTX_encrypting(c)) {\n+                if (len < cctx->M)\n+                    return 0;\n                 len -= cctx->M;\n+            }\n             EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8;\n             EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff;\n         }\ndiff --git a\/crypto\/evp\/e_chacha20_poly1305.c b\/crypto\/evp\/e_chacha20_poly1305.c\nindex befd805e35a..46bc2cb44fb 100644\n--- a\/crypto\/evp\/e_chacha20_poly1305.c\n+++ b\/crypto\/evp\/e_chacha20_poly1305.c\n@@ -398,6 +398,8 @@ static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n             len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                   aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n             if (!ctx->encrypt) {\n+                if (len < POLY1305_BLOCK_SIZE)\n+                    return 0;\n                 len -= POLY1305_BLOCK_SIZE;     \/* discount attached tag *\/\n                 memcpy(temp, aad, EVP_AEAD_TLS1_AAD_LEN - 2);\n                 aad = temp;\n@@ -407,8 +409,7 @@ static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n             actx->tls_payload_length = len;\n \n             \/*\n-             * merge record sequence number as per\n-             * draft-ietf-tls-chacha20-poly1305-03\n+             * merge record sequence number as per RFC7905\n              *\/\n             actx->key.counter[1] = actx->nonce[0];\n             actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n","owner":"openssl","repo":"openssl","source":"cve"},{"CVE_ID":"CVE-2016-6263","CWE_ID":"125","category":"security","commit_id":"1fbee57ef3c72db2206dd87e4162108b2f425555","commit_message":"From 1fbee57ef3c72db2206dd87e4162108b2f425555 Mon Sep 17 00:00:00 2001\nFrom: Simon Josefsson <simon@josefsson.org>\nDate: Thu, 14 Jan 2016 14:31:33 +0100\nSubject: stringprep_utf8_nfkc_normalize: Reject invalid UTF8 instead of\n crashing.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nAlso add regression self check.  Reported by Hanno B\u00f6ck.\n---\n .gitignore              |  2 ++\n lib\/nfkc.c              | 12 +++++++++++-\n tests\/Makefile.am       |  5 +++--\n tests\/tst_badutf8nfkc.c | 41 +++++++++++++++++++++++++++++++++++++++++\n 4 files changed, 57 insertions(+), 3 deletions(-)\n create mode 100644 tests\/tst_badutf8nfkc.c\n\n","diff_code":"diff --git a\/.gitignore b\/.gitignore\nindex ee53963..d207b3c 100644\n--- a\/.gitignore\n+++ b\/.gitignore\n@@ -619,6 +619,8 @@ tests\/Makefile.in\n tests\/libutils.a\n tests\/tst_badutf8\n tests\/tst_badutf8.o\n+tests\/tst_badutf8nfkc\n+tests\/tst_badutf8nfkc.o\n tests\/tst_idna\n tests\/tst_idna.o\n tests\/tst_idna2\ndiff --git a\/lib\/nfkc.c b\/lib\/nfkc.c\nindex 4992074..edc62c4 100644\n--- a\/lib\/nfkc.c\n+++ b\/lib\/nfkc.c\n@@ -1,5 +1,5 @@\n \/* nfkc.c --- Unicode normalization utilities.\n-   Copyright (C) 2002-2015 Simon Josefsson\n+   Copyright (C) 2002-2016 Simon Josefsson\n \n    This file is part of GNU Libidn.\n \n@@ -1086,6 +1086,16 @@ stringprep_ucs4_to_utf8 (const uint32_t * str, ssize_t len,\n char *\n stringprep_utf8_nfkc_normalize (const char *str, ssize_t len)\n {\n+  size_t n;\n+\n+  if (len < 0)\n+    n = strlen (str);\n+  else\n+    n = len;\n+\n+  if (u8_check ((const uint8_t *) str, n))\n+    return NULL;\n+\n   return g_utf8_normalize (str, len, G_NORMALIZE_NFKC);\n }\n \ndiff --git a\/tests\/Makefile.am b\/tests\/Makefile.am\nindex 9130c32..5f4cb24 100644\n--- a\/tests\/Makefile.am\n+++ b\/tests\/Makefile.am\n@@ -1,5 +1,5 @@\n ## Process this file with automake to produce Makefile.in\n-# Copyright (C) 2002-2015 Simon Josefsson\n+# Copyright (C) 2002-2016 Simon Josefsson\n #\n # This file is part of GNU Libidn.\n #\n@@ -27,7 +27,8 @@ libutils_a_SOURCES = utils.h utils.c\n \n ctests = tst_stringprep tst_punycode tst_idna tst_idna2 tst_idna3\t\\\n \ttst_idna4 tst_nfkc tst_pr29 tst_strerror tst_toutf8\t\t\\\n-\ttst_symbols tst_badutf8 tst_utf8crash tst_toascii64oob\n+\ttst_symbols tst_badutf8 tst_utf8crash tst_toascii64oob\t\t\\\n+\ttst_badutf8nfkc\n if TLD\n ctests += tst_tld\n endif\ndiff --git a\/tests\/tst_badutf8nfkc.c b\/tests\/tst_badutf8nfkc.c\nnew file mode 100644\nindex 0000000..e67076b\n--- \/dev\/null\n+++ b\/tests\/tst_badutf8nfkc.c\n@@ -0,0 +1,41 @@\n+\/* tst_badutf8nfkc.c --- Self tests for malformed UTF-8 NFKC input.\n+ * Copyright (C) 2016 Simon Josefsson\n+ *\n+ * This file is part of GNU Libidn.\n+ *\n+ * This program is free software: you can redistribute it and\/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program.  If not, see <http:\/\/www.gnu.org\/licenses\/>.\n+ *\n+ *\/\n+\n+#ifdef HAVE_CONFIG_H\n+# include \"config.h\"\n+#endif\n+\n+#include <string.h>\n+#include <stdlib.h>\n+\n+#include <stringprep.h>\n+\n+#include \"utils.h\"\n+\n+void\n+doit (void)\n+{\n+  char *badutf8 = strdup (\"\\xe4\");\n+  char *s = NULL;\n+\n+  s = stringprep_utf8_nfkc_normalize (badutf8, -1);\n+  free (s);\n+  free (badutf8);\n+}\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9205","CWE_ID":"125","category":"security","commit_id":"b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d","commit_message":"From b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d Mon Sep 17 00:00:00 2001\nFrom: Jason Summers <jason1@pobox.com>\nDate: Sun, 14 May 2017 12:37:43 -0400\nSubject: [PATCH] Fixed invalid memory access bugs when decoding JPEG Exif data\n\nFixes issues #22, #23, #24, #25\n---\n src\/imagew-jpeg.c | 38 +++++++++++++++++++++++++-------------\n 1 file changed, 25 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/src\/imagew-jpeg.c b\/src\/imagew-jpeg.c\nindex 43bf946..e810539 100644\n--- a\/src\/imagew-jpeg.c\n+++ b\/src\/imagew-jpeg.c\n@@ -58,6 +58,18 @@ struct iw_exif_state {\n \tsize_t d_len;\n };\n \n+static unsigned int get_exif_ui16(struct iw_exif_state *e, unsigned int pos)\n+{\n+\tif(e->d_len<2 || pos>e->d_len-2) return 0;\n+\treturn iw_get_ui16_e(&e->d[pos], e->endian);\n+}\n+\n+static unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)\n+{\n+\tif(e->d_len<4 || pos>e->d_len-4) return 0;\n+\treturn iw_get_ui32_e(&e->d[pos], e->endian);\n+}\n+\n \/\/ Try to read an Exif tag into an integer.\n \/\/ Returns zero on failure.\n static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n@@ -66,17 +78,17 @@ static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n \tunsigned int field_type;\n \tunsigned int value_count;\n \n-\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n-\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n+\tfield_type = get_exif_ui16(e, tag_pos+2);\n+\tvalue_count = get_exif_ui32(e, tag_pos+4);\n \n \tif(value_count!=1) return 0;\n \n \tif(field_type==3) { \/\/ SHORT (uint16)\n-\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n+\t\t*pv = get_exif_ui16(e, tag_pos+8);\n \t\treturn 1;\n \t}\n \telse if(field_type==4) { \/\/ LONG (uint32)\n-\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n+\t\t*pv = get_exif_ui32(e, tag_pos+8);\n \t\treturn 1;\n \t}\n \n@@ -93,8 +105,8 @@ static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n \tunsigned int value_pos;\n \tunsigned int numer, denom;\n \n-\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n-\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n+\tfield_type = get_exif_ui16(e, tag_pos+2);\n+\tvalue_count = get_exif_ui32(e, tag_pos+4);\n \n \tif(value_count!=1) return 0;\n \n@@ -103,12 +115,12 @@ static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n \t\/\/ A rational is 8 bytes. Since 8>4, it is stored indirectly. First, read\n \t\/\/ the location where it is stored.\n \n-\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n+\tvalue_pos = get_exif_ui32(e, tag_pos+8);\n \tif(value_pos > e->d_len-8) return 0;\n \n \t\/\/ Read the actual value.\n-\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n-\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n+\tnumer = get_exif_ui32(e, value_pos);\n+\tdenom = get_exif_ui32(e, value_pos+4);\n \tif(denom==0) return 0;\n \n \t*pv = ((double)numer)\/denom;\n@@ -125,15 +137,15 @@ static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n \tunsigned int v;\n \tdouble v_dbl;\n \n-\tif(ifd<8 || ifd>e->d_len-18) return;\n+\tif(ifd<8 || e->d_len<18 || ifd>e->d_len-18) return;\n \n-\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n+\ttag_count = get_exif_ui16(e, ifd);\n \tif(tag_count>1000) return; \/\/ Sanity check.\n \n \tfor(i=0;i<tag_count;i++) {\n \t\ttag_pos = ifd+2+i*12;\n \t\tif(tag_pos+12 > e->d_len) return; \/\/ Avoid overruns.\n-\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n+\t\ttag_id = get_exif_ui16(e, tag_pos);\n \n \t\tswitch(tag_id) {\n \t\tcase 274: \/\/ 274 = Orientation\n@@ -177,7 +189,7 @@ static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n \n \te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n \n-\tifd = iw_get_ui32_e(&d[4],e.endian);\n+\tifd = get_exif_ui32(&e, 4);\n \n \tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n }\n","owner":"jsummers","repo":"imageworsener","source":"cve"},{"CVE_ID":"CVE-2018-11382","CWE_ID":"125","category":"security","commit_id":"d04c78773f6959bcb427453f8e5b9824d5ba9eff","commit_message":"From d04c78773f6959bcb427453f8e5b9824d5ba9eff Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Tue, 15 May 2018 14:44:47 +0200\nSubject: [PATCH] Fix #10091 - crash in AVR analysis\n\n---\n libr\/anal\/p\/anal_avr.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/libr\/anal\/p\/anal_avr.c b\/libr\/anal\/p\/anal_avr.c\nindex 93d72ce52a..3b453f14a1 100644\n--- a\/libr\/anal\/p\/anal_avr.c\n+++ b\/libr\/anal\/p\/anal_avr.c\n@@ -925,6 +925,9 @@ INST_HANDLER (lds) {\t\/\/ LDS Rd, k\n }\n \n INST_HANDLER (sts) {\t\/\/ STS k, Rr\n+\tif (len < 4) {\n+\t\treturn;\n+\t}\n \tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n \tint k = (buf[3] << 8) | buf[2];\n \top->ptr = k;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2019-13391","CWE_ID":"125","category":"security","commit_id":"7c2c5ba5b8e3a0b2b82f56c71dfab74ed4006df7","commit_message":"From 7c2c5ba5b8e3a0b2b82f56c71dfab74ed4006df7 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 16 Jun 2019 12:18:01 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1588\n\n---\n MagickCore\/annotate.c |  3 +++\n MagickCore\/fourier.c  | 12 ++++++++----\n 2 files changed, 11 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/MagickCore\/annotate.c b\/MagickCore\/annotate.c\nindex 494720211e..3f3ac7fa09 100644\n--- a\/MagickCore\/annotate.c\n+++ b\/MagickCore\/annotate.c\n@@ -277,6 +277,7 @@ MagickExport MagickBooleanType AnnotateImage(Image *image,\n     {\n       annotate_info=DestroyDrawInfo(annotate_info);\n       annotate=DestroyDrawInfo(annotate);\n+      text=DestroyString(text);\n       return(MagickFalse);\n     }\n   p=text;\n@@ -311,6 +312,7 @@ MagickExport MagickBooleanType AnnotateImage(Image *image,\n       annotate_info=DestroyDrawInfo(annotate_info);\n       annotate=DestroyDrawInfo(annotate);\n       textlist=(char **) RelinquishMagickMemory(textlist);\n+      text=DestroyString(text);\n       return(MagickFalse);\n     }\n   if (IsGrayColorspace(image->colorspace) != MagickFalse)\n@@ -529,6 +531,7 @@ MagickExport MagickBooleanType AnnotateImage(Image *image,\n   annotate_info=DestroyDrawInfo(annotate_info);\n   annotate=DestroyDrawInfo(annotate);\n   textlist=(char **) RelinquishMagickMemory(textlist);\n+  text=DestroyString(text);\n   return(status);\n }\n \f\ndiff --git a\/MagickCore\/fourier.c b\/MagickCore\/fourier.c\nindex f4ad2027a3..9f6f19d3e1 100644\n--- a\/MagickCore\/fourier.c\n+++ b\/MagickCore\/fourier.c\n@@ -245,10 +245,14 @@ MagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n \n     if (status == MagickFalse)\n       continue;\n-    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Ar_image->columns,1,exception);\n-    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Ai_image->columns,1,exception);\n-    Br=GetCacheViewVirtualPixels(Br_view,0,y,Br_image->columns,1,exception);\n-    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Bi_image->columns,1,exception);\n+    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,\n+      MagickMax(Ar_image->columns,Cr_image->columns),1,exception);\n+    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,\n+      MagickMax(Ai_image->columns,Ci_image->columns),1,exception);\n+    Br=GetCacheViewVirtualPixels(Br_view,0,y,\n+      MagickMax(Br_image->columns,Cr_image->columns),1,exception);\n+    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,\n+      MagickMax(Bi_image->columns,Ci_image->columns),1,exception);\n     Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n     Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n     if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-19843","CWE_ID":"125","category":"security","commit_id":"f17bfd9f1da05f30f23a4dd05e9d2363e1406948","commit_message":"From f17bfd9f1da05f30f23a4dd05e9d2363e1406948 Mon Sep 17 00:00:00 2001\nFrom: radare <pancake@nopcode.org>\nDate: Thu, 22 Nov 2018 10:48:39 +0100\nSubject: [PATCH] Fix #12242 - Crash in x86.nz assembler (#12266)\n\n---\n libr\/asm\/p\/asm_x86_nz.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libr\/asm\/p\/asm_x86_nz.c b\/libr\/asm\/p\/asm_x86_nz.c\nindex 8d4e28941f..812d13d369 100644\n--- a\/libr\/asm\/p\/asm_x86_nz.c\n+++ b\/libr\/asm\/p\/asm_x86_nz.c\n@@ -2023,9 +2023,9 @@ static int opmov(RAsm *a, ut8 *data, const Opcode *op) {\n \t\t\tif (op->operands[1].scale[0] == 0) {\n \t\t\t\treturn -1;\n \t\t\t}\n-\t\t\tdata[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0]];\n+\t\t\tdata[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0] % 6];\n \t\t\tdata[l++] = 0x8b;\n-\t\t\tdata[l++] = op->operands[0].reg << 3 | 0x5;\n+\t\t\tdata[l++] = (((ut32)op->operands[0].reg) << 3) | 0x5;\n \t\t\tdata[l++] = offset;\n \t\t\tdata[l++] = offset >> 8;\n \t\t\tdata[l++] = offset >> 16;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2019-9721","CWE_ID":"125","category":"security","commit_id":"894995c41e0795c7a44f81adc4838dedc3932e65","commit_message":"From 894995c41e0795c7a44f81adc4838dedc3932e65 Mon Sep 17 00:00:00 2001\nFrom: Kevin Backhouse via RT <security-reports@semmle.com>\nDate: Wed, 6 Feb 2019 12:56:01 +0000\nSubject: [PATCH] avcodec\/htmlsubtitles: Fixes denial of service due to use of\n sscanf in inner loop for handling braces\n\nFixes: [Semmle Security Reports #19439]\nFixes: dos_sscanf2.mkv\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/htmlsubtitles.c | 23 +++++++++++++++++++++--\n 1 file changed, 21 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/htmlsubtitles.c b\/libavcodec\/htmlsubtitles.c\nindex c0cfccf..d9221ba 100644\n--- a\/libavcodec\/htmlsubtitles.c\n+++ b\/libavcodec\/htmlsubtitles.c\n@@ -24,6 +24,7 @@\n #include \"libavutil\/common.h\"\n #include \"libavutil\/parseutils.h\"\n #include \"htmlsubtitles.h\"\n+#include <ctype.h>\n \n static int html_color_parse(void *log_ctx, const char *str)\n {\n@@ -44,14 +45,32 @@ static void rstrip_spaces_buf(AVBPrint *buf)\n             buf->str[--buf->len] = 0;\n }\n \n+\/*\n+ * Fast code for scanning text enclosed in braces. Functionally\n+ * equivalent to this sscanf call:\n+ *\n+ * sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0\n+ *\/\n+static int scanbraces(const char* in) {\n+    if (strncmp(in, \"{\\\\an\", 4) != 0) {\n+        return 0;\n+    }\n+    if (!isdigit(in[4])) {\n+        return 0;\n+    }\n+    if (in[5] != '}') {\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n \/* skip all {\\xxx} substrings except for {\\an%d}\n    and all microdvd like styles such as {Y:xxx} *\/\n static void handle_open_brace(AVBPrint *dst, const char **inp, int *an, int *closing_brace_missing)\n {\n-    int len = 0;\n     const char *in = *inp;\n \n-    *an += sscanf(in, \"{\\\\an%*1u}%n\", &len) >= 0 && len > 0;\n+    *an += scanbraces(in);\n \n     if (!*closing_brace_missing) {\n         if (   (*an != 1 && in[1] == '\\\\')\n-- \n2.7.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-5810","CWE_ID":"125","category":"security","commit_id":"fd6330292501983ac75fe4162275794b18445bd9","commit_message":"From fd6330292501983ac75fe4162275794b18445bd9 Mon Sep 17 00:00:00 2001\nFrom: Alex Tutubalin <lexa@lexa.ru>\nDate: Tue, 24 Apr 2018 15:17:31 +0300\nSubject: [PATCH] Secunia 81800#1: samsumg_load_raw\n\nSecunia 81800#2: find_green\n\nSecunia 81800#3: rollei_load_raw\n\nremove_trailing_spaces: isspace() does not works right with signed non-latin chars\n\nSecunia 81800#5\/6: nikon_coolscan_load_raw\n\nSecunia 81800#4: rollei_load_raw\n---\n dcraw\/dcraw.c             | 157 ++++++++++++++++++++++++++------------\n internal\/dcraw_common.cpp | 156 +++++++++++++++++++++++++------------\n internal\/defines.h        |   1 +\n 3 files changed, 216 insertions(+), 98 deletions(-)\n\n","diff_code":"diff --git a\/dcraw\/dcraw.c b\/dcraw\/dcraw.c\nindex 1c6bf662..e2b9c7d4 100644\n--- a\/dcraw\/dcraw.c\n+++ b\/dcraw\/dcraw.c\n@@ -251,6 +251,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n \/\/@end DEFINES\n@@ -1511,9 +1512,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1794,7 +1800,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1810,8 +1821,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3857,6 +3871,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3875,11 +3894,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -11081,37 +11106,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -15077,7 +15133,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -15100,14 +15157,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/dcraw_common.cpp b\/internal\/dcraw_common.cpp\nindex cfb82a27..b430d3e5 100644\n--- a\/internal\/dcraw_common.cpp\n+++ b\/internal\/dcraw_common.cpp\n@@ -1228,9 +1228,14 @@ void CLASS pentax_load_raw()\n \n void CLASS nikon_coolscan_load_raw()\n {\n-  int bufsize = width*3*tiff_bps\/8;\n-  if(tiff_bps <= 8)\n-    gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,255);\n+  if(!image)\n+    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n+\n+  int bypp = tiff_bps <= 8 ? 1 : 2;\n+  int bufsize = width * 3 * bypp;\n+\n+  if (tiff_bps <= 8)\n+    gamma_curve(1.0 \/ imgdata.params.coolscan_nef_gamma, 0., 1, 255);\n   else\n     gamma_curve(1.0\/imgdata.params.coolscan_nef_gamma,0.,1,65535);\n   fseek (ifp, data_offset, SEEK_SET);\n@@ -1506,7 +1511,12 @@ void CLASS rollei_thumb()\n void CLASS rollei_load_raw()\n {\n   uchar pixel[10];\n-  unsigned iten=0, isix, i, buffer=0, todo[16];\n+  unsigned iten = 0, isix, i, buffer = 0, todo[16];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width > 32767 || raw_height > 32767)\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixel = raw_width*(raw_height+7);\n \n   isix = raw_width * raw_height * 5 \/ 8;\n   while (fread (pixel, 1, 10, ifp) == 10) {\n@@ -1522,8 +1532,11 @@ void CLASS rollei_load_raw()\n       todo[i]   = isix++;\n       todo[i+1] = buffer >> (14-i)*5;\n     }\n-    for (i=0; i < 16; i+=2)\n-      raw_image[todo[i]] = (todo[i+1] & 0x3ff);\n+    for (i = 0; i < 16; i += 2)\n+      if(todo[i] < maxpixel)\n+        raw_image[todo[i]] = (todo[i + 1] & 0x3ff);\n+      else\n+        derror();\n   }\n   maximum = 0x3ff;\n }\n@@ -3569,6 +3582,11 @@ void CLASS sony_arw2_load_raw()\n void CLASS samsung_load_raw()\n {\n   int row, col, c, i, dir, op[4], len[4];\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(raw_width> 32768 || raw_height > 32768)  \/\/ definitely too much for old samsung\n+    throw LIBRAW_EXCEPTION_IO_BADFILE;\n+#endif\n+  unsigned maxpixels = raw_width*(raw_height+7);\n \n   order = 0x4949;\n   for (row=0; row < raw_height; row++) {\n@@ -3587,11 +3605,17 @@ void CLASS samsung_load_raw()\n \tcase 2: len[c]--;\t\tbreak;\n \tcase 1: len[c]++;\n       }\n-      for (c=0; c < 16; c+=2) {\n-\ti = len[((c & 1) << 1) | (c >> 3)];\n-        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n-\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n-\tif (c == 14) c = -1;\n+      for (c = 0; c < 16; c += 2)\n+      {\n+        i = len[((c & 1) << 1) | (c >> 3)];\n+\tunsigned idest = RAWINDEX(row, col + c);\n+\tunsigned isrc = (dir ? RAWINDEX(row + (~c | -2), col + c) : col ? RAWINDEX(row, col + (c | -2)) : 0);\n+\tif(idest < maxpixels && isrc < maxpixels) \/\/ less than zero is handled by unsigned conversion\n+  \tRAW(row, col + c) = ((signed)ph1_bits(i) << (32 - i) >> (32 - i)) + \t\t\t                (dir ? RAW(row + (~c | -2), col + c) : col ? RAW(row, col + (c | -2)) : 128);\n+\telse\n+  \t  derror();\n+        if (c == 14)\n+          c = -1;\n       }\n     }\n   }\n@@ -9890,37 +9914,68 @@ void CLASS parse_exif (int base)\n        if (((make[0] == '\\0') && (!strncmp(model, \"ov5647\",6))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_OV5647\",9))) ||\n            ((!strncmp(make, \"RaspberryPi\",11)) && (!strncmp(model, \"RP_imx219\",9)))) {\n-         char mn_text[512];\n-         char* pos;\n-         char ccms[512];\n-         ushort l;\n-         float num;\n-\n-         fgets(mn_text, len, ifp);\n-         pos = strstr(mn_text, \"gain_r=\");\n-         if (pos) cam_mul[0] = atof(pos+7);\n-         pos = strstr(mn_text, \"gain_b=\");\n-         if (pos) cam_mul[2] = atof(pos+7);\n-         if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f)) cam_mul[1] = cam_mul[3] = 1.0f;\n-         else cam_mul[0] = cam_mul[2] = 0.0f;\n-\n-         pos = strstr(mn_text, \"ccm=\") + 4;\n-         l = strstr(pos, \" \") - pos;\n-         memcpy (ccms, pos, l);\n-         ccms[l] = '\\0';\n-\n-         pos = strtok (ccms, \",\");\n-         for (l=0; l<4; l++) {\n-           num = 0.0;\n-           for (c=0; c<3; c++) {\n-             imgdata.color.ccm[l][c] = (float)atoi(pos);\n-             num += imgdata.color.ccm[l][c];\n-             pos = strtok (NULL, \",\");\n-           }\n-           if (num > 0.01) FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n-         }\n+        char mn_text[512];\n+        char *pos;\n+        char ccms[512];\n+        ushort l;\n+        float num;\n+\n+\tfgets(mn_text, MIN(len,511), ifp);\n+        mn_text[511] = 0;\n+\n+        pos = strstr(mn_text, \"gain_r=\");\n+        if (pos)\n+          cam_mul[0] = atof(pos + 7);\n+        pos = strstr(mn_text, \"gain_b=\");\n+        if (pos)\n+          cam_mul[2] = atof(pos + 7);\n+        if ((cam_mul[0] > 0.001f) && (cam_mul[2] > 0.001f))\n+          cam_mul[1] = cam_mul[3] = 1.0f;\n+        else\n+          cam_mul[0] = cam_mul[2] = 0.0f;\n+\n+        pos = strstr(mn_text, \"ccm=\");\n+        if(pos)\n+        {\n+         pos +=4;\n+         char *pos2 = strstr(pos, \" \");\n+         if(pos2)\n+         {\n+           l = pos2 - pos;\n+           memcpy(ccms, pos, l);\n+           ccms[l] = '\\0';\n+#if defined WIN32 || defined(__MINGW32__)\n+           \/\/ Win32 strtok is already thread-safe\n+          pos = strtok(ccms, \",\");\n+#else\n+          char *last=0;\n+          pos = strtok_r(ccms, \",\",&last);\n+#endif\n+          if(pos)\n+          {\n+            for (l = 0; l < 4; l++)\n+            {\n+              num = 0.0;\n+              for (c = 0; c < 3; c++)\n+              {\n+                imgdata.color.ccm[l][c] = (float)atoi(pos);\n+                num += imgdata.color.ccm[l][c];\n+#if defined WIN32 || defined(__MINGW32__)\n+                pos = strtok(NULL, \",\");\n+#else\n+                pos = strtok_r(NULL, \",\",&last);\n+#endif\n+                if(!pos) goto end; \/\/ broken\n+              }\n+              if (num > 0.01)\n+                FORC3 imgdata.color.ccm[l][c] = imgdata.color.ccm[l][c] \/ num;\n+            }\n+          }\n+        }\n        }\n-       else\n+      end:;\n+      }\n+      else\n #endif\n         parse_makernote (base, 0);\n        break;\n@@ -13739,7 +13794,8 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n   UINT64 bitbuf=0;\n   int vbits, col, i, c;\n   ushort img[2][2064];\n-  double sum[]={0,0};\n+  double sum[] = {0, 0};\n+  if(width > 2064) return 0.f; \/\/ too wide\n \n   FORC(2) {\n     fseek (ifp, c ? off1:off0, SEEK_SET);\n@@ -13762,14 +13818,16 @@ float CLASS find_green (int bps, int bite, int off0, int off1)\n #ifdef LIBRAW_LIBRARY_BUILD\n static void remove_trailing_spaces(char *string, size_t len)\n {\n-  if(len<1) return; \/\/ not needed, b\/c sizeof of make\/model is 64\n-  string[len-1]=0;\n-  if(len<3) return; \/\/ also not needed\n-  len = strnlen(string,len-1);\n-  for(int i=len-1; i>=0; i--)\n+  if (len < 1)\n+    return; \/\/ not needed, b\/c sizeof of make\/model is 64\n+  string[len - 1] = 0;\n+  if (len < 3)\n+    return; \/\/ also not needed\n+  len = strnlen(string, len - 1);\n+  for (int i = len - 1; i >= 0; i--)\n   {\n-    if(isspace(string[i]))\n-      string[i]=0;\n+    if (isspace((unsigned char)string[i]))\n+      string[i] = 0;\n     else\n       break;\n   }\ndiff --git a\/internal\/defines.h b\/internal\/defines.h\nindex b84e1d28..06e171ec 100644\n--- a\/internal\/defines.h\n+++ b\/internal\/defines.h\n@@ -153,6 +153,7 @@ static float fMAX(float a, float b)\n \t3 G R G R G R\t3 B G B G B G\t3 R G R G R G\t3 G B G B G B\n  *\/\n \n+#define RAWINDEX(row, col) ((row)*raw_width + (col))\n #define RAW(row,col) \\\n \traw_image[(row)*raw_width+(col)]\n #define BAYER(row,col) \\\n","owner":"LibRaw","repo":"LibRaw","source":"cve"},{"CVE_ID":"CVE-2017-9206","CWE_ID":"125","category":"security","commit_id":"b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d","commit_message":"From b45cb1b665a14b0175b9cb1502ef7168e1fe0d5d Mon Sep 17 00:00:00 2001\nFrom: Jason Summers <jason1@pobox.com>\nDate: Sun, 14 May 2017 12:37:43 -0400\nSubject: [PATCH] Fixed invalid memory access bugs when decoding JPEG Exif data\n\nFixes issues #22, #23, #24, #25\n---\n src\/imagew-jpeg.c | 38 +++++++++++++++++++++++++-------------\n 1 file changed, 25 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/src\/imagew-jpeg.c b\/src\/imagew-jpeg.c\nindex 43bf946..e810539 100644\n--- a\/src\/imagew-jpeg.c\n+++ b\/src\/imagew-jpeg.c\n@@ -58,6 +58,18 @@ struct iw_exif_state {\n \tsize_t d_len;\n };\n \n+static unsigned int get_exif_ui16(struct iw_exif_state *e, unsigned int pos)\n+{\n+\tif(e->d_len<2 || pos>e->d_len-2) return 0;\n+\treturn iw_get_ui16_e(&e->d[pos], e->endian);\n+}\n+\n+static unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)\n+{\n+\tif(e->d_len<4 || pos>e->d_len-4) return 0;\n+\treturn iw_get_ui32_e(&e->d[pos], e->endian);\n+}\n+\n \/\/ Try to read an Exif tag into an integer.\n \/\/ Returns zero on failure.\n static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n@@ -66,17 +78,17 @@ static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n \tunsigned int field_type;\n \tunsigned int value_count;\n \n-\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n-\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n+\tfield_type = get_exif_ui16(e, tag_pos+2);\n+\tvalue_count = get_exif_ui32(e, tag_pos+4);\n \n \tif(value_count!=1) return 0;\n \n \tif(field_type==3) { \/\/ SHORT (uint16)\n-\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n+\t\t*pv = get_exif_ui16(e, tag_pos+8);\n \t\treturn 1;\n \t}\n \telse if(field_type==4) { \/\/ LONG (uint32)\n-\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n+\t\t*pv = get_exif_ui32(e, tag_pos+8);\n \t\treturn 1;\n \t}\n \n@@ -93,8 +105,8 @@ static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n \tunsigned int value_pos;\n \tunsigned int numer, denom;\n \n-\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n-\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n+\tfield_type = get_exif_ui16(e, tag_pos+2);\n+\tvalue_count = get_exif_ui32(e, tag_pos+4);\n \n \tif(value_count!=1) return 0;\n \n@@ -103,12 +115,12 @@ static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n \t\/\/ A rational is 8 bytes. Since 8>4, it is stored indirectly. First, read\n \t\/\/ the location where it is stored.\n \n-\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n+\tvalue_pos = get_exif_ui32(e, tag_pos+8);\n \tif(value_pos > e->d_len-8) return 0;\n \n \t\/\/ Read the actual value.\n-\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n-\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n+\tnumer = get_exif_ui32(e, value_pos);\n+\tdenom = get_exif_ui32(e, value_pos+4);\n \tif(denom==0) return 0;\n \n \t*pv = ((double)numer)\/denom;\n@@ -125,15 +137,15 @@ static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n \tunsigned int v;\n \tdouble v_dbl;\n \n-\tif(ifd<8 || ifd>e->d_len-18) return;\n+\tif(ifd<8 || e->d_len<18 || ifd>e->d_len-18) return;\n \n-\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n+\ttag_count = get_exif_ui16(e, ifd);\n \tif(tag_count>1000) return; \/\/ Sanity check.\n \n \tfor(i=0;i<tag_count;i++) {\n \t\ttag_pos = ifd+2+i*12;\n \t\tif(tag_pos+12 > e->d_len) return; \/\/ Avoid overruns.\n-\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n+\t\ttag_id = get_exif_ui16(e, tag_pos);\n \n \t\tswitch(tag_id) {\n \t\tcase 274: \/\/ 274 = Orientation\n@@ -177,7 +189,7 @@ static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n \n \te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n \n-\tifd = iw_get_ui32_e(&d[4],e.endian);\n+\tifd = get_exif_ui32(&e, 4);\n \n \tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n }\n","owner":"jsummers","repo":"imageworsener","source":"cve"},{"CVE_ID":"CVE-2015-8958","CWE_ID":"125","category":"security","commit_id":"1aa0c6dab6dcef4d9bc3571866ae1c1ddbec7d8f","commit_message":"From 1aa0c6dab6dcef4d9bc3571866ae1c1ddbec7d8f Mon Sep 17 00:00:00 2001\nFrom: cristy <urban-warrior@git.imagemagick.org>\nDate: Tue, 13 Jan 2015 02:23:43 +0000\nSubject: [PATCH]\n\n---\n coders\/sun.c | 43 +++++++++++++++++--------------------------\n 1 file changed, 17 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/coders\/sun.c b\/coders\/sun.c\nindex 728bffa4d3..04915bc3d0 100644\n--- a\/coders\/sun.c\n+++ b\/coders\/sun.c\n@@ -255,6 +255,7 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   size_t\n     bytes_per_line,\n     extent,\n+    height,\n     length;\n \n   ssize_t\n@@ -420,33 +421,23 @@ static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n     if (count != (ssize_t) sun_info.length)\n       ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n-    sun_pixels=sun_data;\n-    bytes_per_line=0;\n+    height=sun_info.height;\n+    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n+        ((bytes_per_line\/sun_info.depth) != sun_info.width))\n+      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    bytes_per_line+=15;\n+    bytes_per_line<<=1;\n+    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\n+      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    bytes_per_line>>=4;\n+    sun_pixels=(unsigned char *) AcquireQuantumMemory(height,\n+      bytes_per_line*sizeof(*sun_pixels));\n+    if (sun_pixels == (unsigned char *) NULL)\n+      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     if (sun_info.type == RT_ENCODED)\n-      {\n-        size_t\n-          height;\n-\n-        \/*\n-          Read run-length encoded raster pixels.\n-        *\/\n-        height=sun_info.height;\n-        if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n-            ((bytes_per_line\/sun_info.depth) != sun_info.width))\n-          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n-        bytes_per_line+=15;\n-        bytes_per_line<<=1;\n-        if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+15))\n-          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n-        bytes_per_line>>=4;\n-        sun_pixels=(unsigned char *) AcquireQuantumMemory(height,\n-          bytes_per_line*sizeof(*sun_pixels));\n-        if (sun_pixels == (unsigned char *) NULL)\n-          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n-        (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\n-          height);\n-        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n-      }\n+      (void) DecodeImage(sun_data,sun_info.length,sun_pixels,bytes_per_line*\n+        height);\n+    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n     \/*\n       Convert SUN raster image to pixel packets.\n     *\/\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-10017","CWE_ID":"125","category":"security","commit_id":"492022c7297ede682161d9c0ec2de15526424e76","commit_message":"From 492022c7297ede682161d9c0ec2de15526424e76 Mon Sep 17 00:00:00 2001\nFrom: Johannes Schultz <sagamusix@openmpt.org>\nDate: Sat, 7 Apr 2018 16:04:51 +0000\nSubject: [PATCH] [Fix] Possible out-of-bounds read when computing length of\n some IT files with pattern loops (OpenMPT: formats that are converted to IT,\n libopenmpt: IT\/ITP\/MO3), caught with afl-fuzz.\n\ngit-svn-id: https:\/\/source.openmpt.org\/svn\/openmpt\/trunk\/OpenMPT@10027 56274372-70c3-4bfc-bfc3-4c3a0b034d27\n---\n soundlib\/Snd_fx.cpp | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/soundlib\/Snd_fx.cpp b\/soundlib\/Snd_fx.cpp\nindex c623da591..29f93c1de 100644\n--- a\/soundlib\/Snd_fx.cpp\n+++ b\/soundlib\/Snd_fx.cpp\n@@ -1204,7 +1204,8 @@ std::vector<GetLengthType> CSoundFile::GetLength(enmGetLengthResetMode adjustMod\n \t\t\tif(GetType() == MOD_TYPE_IT)\n \t\t\t{\n \t\t\t\t\/\/ IT pattern loop start row update - at the end of a pattern loop, set pattern loop start to next row (for upcoming pattern loops with missing SB0)\n-\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++)\n+\t\t\t\tpChn = playState.Chn;\n+\t\t\t\tfor(CHANNELINDEX nChn = 0; nChn < GetNumChannels(); nChn++, pChn++)\n \t\t\t\t{\n \t\t\t\t\tif((pChn->rowCommand.command == CMD_S3MCMDEX && pChn->rowCommand.param >= 0xB1 && pChn->rowCommand.param <= 0xBF))\n \t\t\t\t\t{\n","owner":"OpenMPT","repo":"openmpt","source":"cve"},{"CVE_ID":"CVE-2018-17206","CWE_ID":"125","category":"security","commit_id":"9237a63c47bd314b807cda0bd2216264e82edbe8","commit_message":"From 9237a63c47bd314b807cda0bd2216264e82edbe8 Mon Sep 17 00:00:00 2001\nFrom: Ben Pfaff <blp@ovn.org>\nDate: Mon, 25 Jun 2018 13:07:43 -0700\nSubject: [PATCH] ofp-actions: Avoid buffer overread in BUNDLE action decoding.\n\nReported-at: https:\/\/bugs.chromium.org\/p\/oss-fuzz\/issues\/detail?id=9052\nSigned-off-by: Ben Pfaff <blp@ovn.org>\nAcked-by: Justin Pettit <jpettit@ovn.org>\n---\n lib\/ofp-actions.c | 13 +++++++------\n 1 file changed, 7 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/lib\/ofp-actions.c b\/lib\/ofp-actions.c\nindex 074ded1f2e..fec88b97ae 100644\n--- a\/lib\/ofp-actions.c\n+++ b\/lib\/ofp-actions.c\n@@ -1357,12 +1357,13 @@ decode_bundle(bool load, const struct nx_action_bundle *nab,\n                      load ? \"bundle_load\" : \"bundle\", slaves_size,\n                      bundle->n_slaves * sizeof(ovs_be16), bundle->n_slaves);\n         error = OFPERR_OFPBAC_BAD_LEN;\n-    }\n-\n-    for (i = 0; i < bundle->n_slaves; i++) {\n-        ofp_port_t ofp_port = u16_to_ofp(ntohs(((ovs_be16 *)(nab + 1))[i]));\n-        ofpbuf_put(ofpacts, &ofp_port, sizeof ofp_port);\n-        bundle = ofpacts->header;\n+    } else {\n+        for (i = 0; i < bundle->n_slaves; i++) {\n+            ofp_port_t ofp_port\n+                = u16_to_ofp(ntohs(((ovs_be16 *)(nab + 1))[i]));\n+            ofpbuf_put(ofpacts, &ofp_port, sizeof ofp_port);\n+            bundle = ofpacts->header;\n+        }\n     }\n \n     ofpact_finish_BUNDLE(ofpacts, &bundle);\n","owner":"openvswitch","repo":"ovs","source":"cve"},{"CVE_ID":"CVE-2018-9988","CWE_ID":"125","category":"security","commit_id":"a1098f81c252b317ad34ea978aea2bc47760b215","commit_message":"From a1098f81c252b317ad34ea978aea2bc47760b215 Mon Sep 17 00:00:00 2001\nFrom: Krzysztof Stachowiak <krzysiek.stachowiak@gmail.com>\nDate: Tue, 13 Mar 2018 11:28:49 +0100\nSubject: [PATCH] Add bounds check before signature length read\n\n---\n library\/ssl_cli.c | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\n","diff_code":"diff --git a\/library\/ssl_cli.c b\/library\/ssl_cli.c\nindex 2534346a49..279a127ba2 100644\n--- a\/library\/ssl_cli.c\n+++ b\/library\/ssl_cli.c\n@@ -2478,6 +2478,14 @@ static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl )\n         \/*\n          * Read signature\n          *\/\n+\n+        if( p > end - 2 )\n+        {\n+            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message\" ) );\n+            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n+                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n+            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n+        }\n         sig_len = ( p[0] << 8 ) | p[1];\n         p += 2;\n \n","owner":"polarssl","repo":"polarssl","source":"cve"},{"CVE_ID":"CVE-2019-13297","CWE_ID":"125","category":"security","commit_id":"604588fc35c7585abb7a9e71f69bb82e4389fefc","commit_message":"From 604588fc35c7585abb7a9e71f69bb82e4389fefc Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 21 Jun 2019 17:30:31 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1609\n\n---\n MagickCore\/threshold.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/MagickCore\/threshold.c b\/MagickCore\/threshold.c\nindex f9412bb52e..0c3a488d7e 100644\n--- a\/MagickCore\/threshold.c\n+++ b\/MagickCore\/threshold.c\n@@ -212,7 +212,7 @@ MagickExport Image *AdaptiveThresholdImage(const Image *image,\n   threshold_image=CloneImage(image,0,0,MagickTrue,exception);\n   if (threshold_image == (Image *) NULL)\n     return((Image *) NULL);\n-  if (width == 0)\n+  if ((width == 0) || (height == 0))\n     return(threshold_image);\n   status=SetImageStorageClass(threshold_image,DirectClass,exception);\n   if (status == MagickFalse)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-13305","CWE_ID":"125","category":"security","commit_id":"d08d4a8c7387e758d439b0592782e4cfa2b4d6a4","commit_message":"From d08d4a8c7387e758d439b0592782e4cfa2b4d6a4 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Thu, 28 Jun 2018 23:46:32 +0200\nSubject: [PATCH] avcodec\/vc1_block: Fix mqaunt check for negative values\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nFixes: out of array access\nFixes: ffmpeg_bof_4.avi\nFixes: ffmpeg_bof_5.avi\nFixes: ffmpeg_bof_6.avi\n\nFound-by: Thuan Pham, Marcel B\u00f6hme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nReviewed-by: Jerome Borsboom <jerome.borsboom@carpalis.nl>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/vc1_block.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/vc1_block.c b\/libavcodec\/vc1_block.c\nindex dfaaab700b7..86320db959a 100644\n--- a\/libavcodec\/vc1_block.c\n+++ b\/libavcodec\/vc1_block.c\n@@ -207,7 +207,7 @@ static void vc1_put_blocks_clamped(VC1Context *v, int put_signed)\n         if ((edges&8) &&                                       \\\n             s->mb_y == ((s->mb_height >> v->field_mode) - 1))  \\\n             mquant = -v->altpq;                                \\\n-        if (!mquant || mquant > 31) {                          \\\n+        if (!mquant || mquant > 31 || mquant < -31) {                          \\\n             av_log(v->s.avctx, AV_LOG_ERROR,                   \\\n                    \"Overriding invalid mquant %d\\n\", mquant);  \\\n             mquant = 1;                                        \\\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2018-12321","CWE_ID":"125","category":"security","commit_id":"224e6bc13fa353dd3b7f7a2334588f1c4229e58d","commit_message":"From 224e6bc13fa353dd3b7f7a2334588f1c4229e58d Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Mon, 11 Jun 2018 03:15:07 +0200\nSubject: [PATCH] Fix #10296 - Heap out of bounds read in java_switch_op()\n\n---\n libr\/anal\/p\/anal_java.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libr\/anal\/p\/anal_java.c b\/libr\/anal\/p\/anal_java.c\nindex 6bffb867c0..62f54240db 100644\n--- a\/libr\/anal\/p\/anal_java.c\n+++ b\/libr\/anal\/p\/anal_java.c\n@@ -679,11 +679,11 @@ static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data,\n \n \tif (op_byte == 0xaa) {\n \t\t\/\/ handle a table switch condition\n-\t\tif (pos + 8 > len) {\n+\t\tif (pos + 8 + 8 > len) {\n \t\t\treturn op->size;\n \t\t}\n-\t\tint min_val = (ut32)(UINT (data, pos + 4)),\n-\t\t\tmax_val = (ut32)(UINT (data, pos + 8));\n+\t\tconst int min_val = (ut32)(UINT (data, pos + 4));\n+\t\tconst int max_val = (ut32)(UINT (data, pos + 8));\n \n \t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n \t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2018-1999015","CWE_ID":"125","category":"security","commit_id":"5aba5b89d0b1d73164d3b81764828bb8b20ff32a","commit_message":"From 5aba5b89d0b1d73164d3b81764828bb8b20ff32a Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Tue, 3 Jul 2018 22:48:32 +0200\nSubject: [PATCH] avcodec\/mpeg4videodec: Check for bitstream end in\n read_quant_matrix_ext()\n\nFixes: out of array read\nFixes: asff-crash-0e53d0dc491dfdd507530b66562812fbd4c36678\n\nFound-by: Paul Ch <paulcher@icloud.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/mpeg4videodec.c | 11 ++++++++++-\n 1 file changed, 10 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/mpeg4videodec.c b\/libavcodec\/mpeg4videodec.c\nindex 2df525e03a7..24c280df465 100644\n--- a\/libavcodec\/mpeg4videodec.c\n+++ b\/libavcodec\/mpeg4videodec.c\n@@ -2867,11 +2867,13 @@ static int decode_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n     return 0;\n }\n \n-static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n+static int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n {\n     int i, j, v;\n \n     if (get_bits1(gb)) {\n+        if (get_bits_left(gb) < 64*8)\n+            return AVERROR_INVALIDDATA;\n         \/* intra_quantiser_matrix *\/\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n@@ -2882,6 +2884,8 @@ static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n     }\n \n     if (get_bits1(gb)) {\n+        if (get_bits_left(gb) < 64*8)\n+            return AVERROR_INVALIDDATA;\n         \/* non_intra_quantiser_matrix *\/\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n@@ -2889,6 +2893,8 @@ static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n     }\n \n     if (get_bits1(gb)) {\n+        if (get_bits_left(gb) < 64*8)\n+            return AVERROR_INVALIDDATA;\n         \/* chroma_intra_quantiser_matrix *\/\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n@@ -2898,6 +2904,8 @@ static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n     }\n \n     if (get_bits1(gb)) {\n+        if (get_bits_left(gb) < 64*8)\n+            return AVERROR_INVALIDDATA;\n         \/* chroma_non_intra_quantiser_matrix *\/\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n@@ -2905,6 +2913,7 @@ static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n     }\n \n     next_start_code_studio(gb);\n+    return 0;\n }\n \n static void extension_and_user_data(MpegEncContext *s, GetBitContext *gb, int id)\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2018-1999014","CWE_ID":"125","category":"security","commit_id":"bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75","commit_message":"From bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Tue, 3 Jul 2018 20:38:06 +0200\nSubject: [PATCH] avformat\/mxfdec: Fix av_log context\n\nFixes: out of array access\nFixes: mxf-crash-1c2e59bf07a34675bfb3ada5e1ec22fa9f38f923\n\nFound-by: Paul Ch <paulcher@icloud.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/mxfdec.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavformat\/mxfdec.c b\/libavformat\/mxfdec.c\nindex b76beb962f4..3a8e76e51ce 100644\n--- a\/libavformat\/mxfdec.c\n+++ b\/libavformat\/mxfdec.c\n@@ -2155,7 +2155,7 @@ static int mxf_parse_structural_metadata(MXFContext *mxf)\n                 MXFEssenceContainerData *essence_data;\n \n                 if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {\n-                    av_log(mxf, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");\n+                    av_log(mxf->fc, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");\n                     continue;\n                 }\n                 if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2016-6293","CWE_ID":"125","category":"security","commit_id":"aa82e99ed8003c01f1ef4f0940e56b85c5b032d4","commit_message":"From aa82e99ed8003c01f1ef4f0940e56b85c5b032d4 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Tue, 12 Jul 2016 22:37:36 -0700\nSubject: [PATCH] Fix bug #72533 (locale_accept_from_http out-of-bounds access)\n\n---\n ext\/intl\/locale\/locale_methods.c | 18 ++++++++++++++++++\n ext\/intl\/tests\/bug72533.phpt     | 30 ++++++++++++++++++++++++++++++\n 2 files changed, 48 insertions(+)\n create mode 100644 ext\/intl\/tests\/bug72533.phpt\n\n","diff_code":"diff --git a\/ext\/intl\/locale\/locale_methods.c b\/ext\/intl\/locale\/locale_methods.c\nindex 31f60b3..443856f 100644\n--- a\/ext\/intl\/locale\/locale_methods.c\n+++ b\/ext\/intl\/locale\/locale_methods.c\n@@ -1591,6 +1591,24 @@ PHP_FUNCTION(locale_accept_from_http)\n \t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n+\tif(http_accept_len > ULOC_FULLNAME_CAPACITY) {\n+\t\t\/* check each fragment, if any bigger than capacity, can't do it due to bug #72533 *\/\n+\t\tchar *start = http_accept;\n+\t\tchar *end;\n+\t\tsize_t len;\n+\t\tdo {\n+\t\t\tend = strchr(start, ',');\n+\t\t\tlen = end ? end-start : http_accept_len-(start-http_accept);\n+\t\t\tif(len > ULOC_FULLNAME_CAPACITY) {\n+\t\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n+\t\t\t\t\t\t\"locale_accept_from_http: locale string too long\", 0 TSRMLS_CC );\n+\t\t\t\tRETURN_FALSE;\n+\t\t\t}\n+\t\t\tif(end) {\n+\t\t\t\tstart = end+1;\n+\t\t\t}\n+\t\t} while(end != NULL);\n+\t}\n \n \tavailable = ures_openAvailableLocales(NULL, &status);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\ndiff --git a\/ext\/intl\/tests\/bug72533.phpt b\/ext\/intl\/tests\/bug72533.phpt\nnew file mode 100644\nindex 0000000..c7fcba3\n--- \/dev\/null\n+++ b\/ext\/intl\/tests\/bug72533.phpt\n@@ -0,0 +1,30 @@\n+--TEST--\n+Bug #72533 (locale_accept_from_http out-of-bounds access)\n+--SKIPIF--\n+<?php if( !extension_loaded( 'intl' ) ) print 'skip'; ?>\n+--FILE--\n+<?php\n+\n+function ut_main()\n+{\n+    $ret = var_export(ut_loc_accept_http(str_repeat('x', 256)), true);\n+    $ret .= \"\\n\";\n+\tif(intl_is_failure(intl_get_error_code())) {\n+\t\t$ret .= var_export(intl_get_error_message(), true);\n+\t}\n+    $ret .= \"\\n\";\n+    $ret .= var_export(ut_loc_accept_http(str_repeat('en,', 256)), true);\n+    $ret .= \"\\n\";\n+\tif(intl_is_failure(intl_get_error_code())) {\n+\t\t$ret .= var_export(intl_get_error_message(), true);\n+\t}\n+    return $ret;\n+}\n+\n+include_once( 'ut_common.inc' );\n+ut_run();\n+?>\n+--EXPECTF--\n+false\n+'locale_accept_from_http: locale string too long: U_ILLEGAL_ARGUMENT_ERROR'\n+'en'\n\\ No newline at end of file\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7514","CWE_ID":"125","category":"security","commit_id":"6f1879d498bcc5cce12fe0c5decb8dbc0f608e5d","commit_message":"From 6f1879d498bcc5cce12fe0c5decb8dbc0f608e5d Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Fri, 15 Jan 2016 01:13:19 +0100\nSubject: [PATCH] Fixed overflow.\n\n---\n coders\/psd.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex 907e45dd5c..5f5fba6c62 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -2363,8 +2363,8 @@ static MagickBooleanType WriteImageChannels(const PSDInfo *psd_info,\n   compact_pixels=(unsigned char *) NULL;\n   if (next_image->compression == RLECompression)\n     {\n-      compact_pixels=(unsigned char *) AcquireQuantumMemory(2*channels*\n-        next_image->columns,packet_size*sizeof(*compact_pixels));\n+      compact_pixels=(unsigned char *) AcquireQuantumMemory((2*channels*\n+        next_image->columns)+1,packet_size*sizeof(*compact_pixels));\n       if (compact_pixels == (unsigned char *) NULL)\n         ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-7730","CWE_ID":"125","category":"security","commit_id":"6cbd34025e5fd3ba47b29b602096e456507ce83b","commit_message":"From 6cbd34025e5fd3ba47b29b602096e456507ce83b Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Hubert=20Figui=C3=A8re?= <hub@figuiere.net>\nDate: Sun, 25 Feb 2018 13:28:28 -0500\nSubject: Bug 105204 - Fix a buffer overflow in PSD parser\n\n---\n XMPFiles\/source\/FormatSupport\/PSIR_FileWriter.cpp | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/XMPFiles\/source\/FormatSupport\/PSIR_FileWriter.cpp b\/XMPFiles\/source\/FormatSupport\/PSIR_FileWriter.cpp\nindex 12adc58..f8ab565 100644\n--- a\/XMPFiles\/source\/FormatSupport\/PSIR_FileWriter.cpp\n+++ b\/XMPFiles\/source\/FormatSupport\/PSIR_FileWriter.cpp\n@@ -319,6 +319,12 @@ void PSIR_FileWriter::ParseFileResources ( XMP_IO* fileRef, XMP_Uns32 length )\n \n \t\tXMP_Uns32 dataLen   = XIO::ReadUns32_BE ( fileRef );\n \t\tXMP_Uns32 dataTotal = ((dataLen + 1) & 0xFFFFFFFEUL);\t\/\/ Round up to an even total.\n+\t\t\/\/ See bug https:\/\/bugs.freedesktop.org\/show_bug.cgi?id=105204\n+\t\t\/\/ If dataLen is 0xffffffff, then dataTotal might be 0\n+\t\t\/\/ and therefor make the CheckFileSpace test pass.\n+\t\tif (dataTotal < dataLen) {\n+\t\t\tbreak;\n+\t\t}\n \t\tif ( ! XIO::CheckFileSpace ( fileRef, dataTotal ) ) break;\t\/\/ Bad image resource.\n \n \t\tXMP_Int64 thisDataPos = fileRef->Offset();\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10172","CWE_ID":"125","category":"security","commit_id":"4bc05fc490b66ef2d45b1de26abf1455b486b0dc","commit_message":"From 4bc05fc490b66ef2d45b1de26abf1455b486b0dc Mon Sep 17 00:00:00 2001\nFrom: David Bryant <david@wavpack.com>\nDate: Wed, 21 Dec 2016 22:18:36 -0800\nSubject: [PATCH] fixes for 4 fuzz failures posted to SourceForge mailing list\n\n---\n src\/open_utils.c | 6 +++++-\n src\/read_words.c | 4 ++++\n 2 files changed, 9 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/open_utils.c b\/src\/open_utils.c\nindex 7519f99..a844046 100644\n--- a\/src\/open_utils.c\n+++ b\/src\/open_utils.c\n@@ -560,7 +560,7 @@ static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n \n     \/\/ if there's any data, the first two bytes are file_format and qmode flags\n \n-    if (bytecnt) {\n+    if (bytecnt >= 2) {\n         wpc->file_format = *byteptr++;\n         wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n         bytecnt -= 2;\n@@ -593,6 +593,10 @@ static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n                         for (i = 0; i < nchans; ++i)\n                             if (bytecnt) {\n                                 wpc->channel_reordering [i] = *byteptr++;\n+\n+                                if (wpc->channel_reordering [i] >= nchans)  \/\/ make sure index is in range\n+                                    wpc->channel_reordering [i] = 0;\n+\n                                 bytecnt--;\n                             }\n                             else\ndiff --git a\/src\/read_words.c b\/src\/read_words.c\nindex 62acac3..a537bfa 100644\n--- a\/src\/read_words.c\n+++ b\/src\/read_words.c\n@@ -288,6 +288,10 @@ int32_t FASTCALL get_word (WavpackStream *wps, int chan, int32_t *correction)\n \n     low &= 0x7fffffff;\n     high &= 0x7fffffff;\n+\n+    if (low > high)         \/\/ make sure high and low make sense\n+        high = low;\n+\n     mid = (high + low + 1) >> 1;\n \n     if (!c->error_limit)\n","owner":"dbry","repo":"WavPack","source":"cve"},{"CVE_ID":"CVE-2016-6261","CWE_ID":"125","category":"security","commit_id":"f20ce1128fb7f4d33297eee307dddaf0f92ac72d","commit_message":"From f20ce1128fb7f4d33297eee307dddaf0f92ac72d Mon Sep 17 00:00:00 2001\nFrom: Simon Josefsson <simon@josefsson.org>\nDate: Thu, 14 Jan 2016 13:46:52 +0100\nSubject: =?UTF-8?q?Fix=20out-of-bounds=20stack=20read.=20=20Report=20and?=\n =?UTF-8?q?=20patch=20by=20Hanno=20B=C3=B6ck.?=\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\n---\n lib\/idna.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/lib\/idna.c b\/lib\/idna.c\nindex 5107d73..0ccd102 100644\n--- a\/lib\/idna.c\n+++ b\/lib\/idna.c\n@@ -212,6 +212,8 @@ step3:\n       }\n     if (i < 64)\n       out[i] = '\\0';\n+    else\n+      return IDNA_INVALID_LENGTH;\n     if (inasciirange)\n       goto step8;\n   }\n@@ -266,7 +268,7 @@ step3:\n \n step8:\n   free (src);\n-  if (strlen (out) < 1 || strlen (out) > 63)\n+  if (strlen (out) < 1)\n     return IDNA_INVALID_LENGTH;\n \n   return IDNA_SUCCESS;\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5545","CWE_ID":"125","category":"security","commit_id":"7391a506352c009fe044dead7baad9e22dd279ee","commit_message":"From 7391a506352c009fe044dead7baad9e22dd279ee Mon Sep 17 00:00:00 2001\nFrom: Nikias Bassen <nikias@gmx.li>\nDate: Wed, 18 Jan 2017 15:44:51 +0100\nSubject: [PATCH] plistutil: Prevent OOB heap buffer read by checking input\n size\n\nAs pointed out in #87 plistutil would do a memcmp with a heap buffer\nwithout checking the size. If the size is less than 8 it would read\nbeyond the bounds of this heap buffer. This commit prevents that.\n---\n tools\/plistutil.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/tools\/plistutil.c b\/tools\/plistutil.c\nindex 64516045..e943e766 100644\n--- a\/tools\/plistutil.c\n+++ b\/tools\/plistutil.c\n@@ -129,6 +129,12 @@ int main(int argc, char *argv[])\n     }\n \n     stat(options->in_file, &filestats);\n+\n+    if (filestats.st_size < 8) {\n+        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n+        return -1;\n+    }\n+\n     plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n     read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n     fclose(iplist);\n","owner":"libimobiledevice","repo":"libplist","source":"cve"},{"CVE_ID":"CVE-2014-9669","CWE_ID":"125","category":"security","commit_id":"602040b1112c9f94d68e200be59ea7ac3d104565","commit_message":"From 602040b1112c9f94d68e200be59ea7ac3d104565 Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Wed, 12 Nov 2014 20:51:20 +0100\nSubject: [sfnt] Fix Savannah bug #43588.\n\n* src\/sfnt\/ttcmap.c (tt_cmap8_validate, tt_cmap10_validate,\ntt_cmap12_validate, tt_cmap13_validate, tt_cmap14_validate): Protect\nagainst overflow in additions and multiplications.\n---\n ChangeLog         | 14 +++++++++++---\n src\/sfnt\/ttcmap.c | 39 ++++++++++++++++++++++++++++++---------\n 2 files changed, 41 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 7cc5f07..5db1130 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,11 @@\n+2014-11-12  Werner Lemberg  <wl@gnu.org>\n+\n+\t[sfnt] Fix Savannah bug #43588.\n+\n+\t* src\/sfnt\/ttcmap.c (tt_cmap8_validate, tt_cmap10_validate,\n+\ttt_cmap12_validate, tt_cmap13_validate, tt_cmap14_validate): Protect\n+\tagainst overflow in additions and multiplications.\n+\n 2014-11-10  Alexei Podtelezhnikov  <apodtele@gmail.com>\n \n \t[base] CORDIC improvements.\n@@ -20,7 +28,7 @@\n \n 2014-11-07  Werner Lemberg  <wl@gnu.org>\n \n-\tFix Savannah bug #43535.\n+\t[bdf] Fix Savannah bug #43535.\n \n \t* src\/bdf\/bdflib.c (_bdf_strncmp): New macro that checks one\n \tcharacter more than `strncmp'.\n@@ -28,14 +36,14 @@\n \n 2014-11-06  Werner Lemberg  <wl@gnu.org>\n \n-\tFix Savannah bug #43548.\n+\t[pcf] Fix Savannah bug #43548.\n \n \t* src\/pcf\/pcfread.c (pcf_get_encodings): Add sanity checks for row\n \tand column values.\n \n 2014-11-06  Werner Lemberg  <wl@gnu.org>\n \n-\tFix Savannah bug #43547.\n+\t[pcf] Fix Savannah bug #43547.\n \n \t* src\/pcf\/pcfread.c (pcf_read_TOC): Check `size' and `offset'\n \tvalues.\ndiff --git a\/src\/sfnt\/ttcmap.c b\/src\/sfnt\/ttcmap.c\nindex f9acf5d..712bd4f 100644\n--- a\/src\/sfnt\/ttcmap.c\n+++ b\/src\/sfnt\/ttcmap.c\n@@ -1669,7 +1669,8 @@\n     p          = is32  + 8192;          \/* skip `is32' array *\/\n     num_groups = TT_NEXT_ULONG( p );\n \n-    if ( p + num_groups * 12 > valid->limit )\n+    \/* p + num_groups * 12 > valid->limit ? *\/\n+    if ( num_groups > (FT_UInt32)( valid->limit - p ) \/ 12 )\n       FT_INVALID_TOO_SHORT;\n \n     \/* check groups, they must be in increasing order *\/\n@@ -1694,7 +1695,12 @@\n \n         if ( valid->level >= FT_VALIDATE_TIGHT )\n         {\n-          if ( start_id + end - start >= TT_VALID_GLYPH_COUNT( valid ) )\n+          FT_UInt32  d = end - start;\n+\n+\n+          \/* start_id + end - start >= TT_VALID_GLYPH_COUNT( valid ) ? *\/\n+          if ( d > TT_VALID_GLYPH_COUNT( valid )             ||\n+               start_id >= TT_VALID_GLYPH_COUNT( valid ) - d )\n             FT_INVALID_GLYPH_ID;\n \n           count = (FT_UInt32)( end - start + 1 );\n@@ -1892,7 +1898,9 @@\n     count  = TT_NEXT_ULONG( p );\n \n     if ( length > (FT_ULong)( valid->limit - table ) ||\n-         length < 20 + count * 2                     )\n+         \/* length < 20 + count * 2 ? *\/\n+         length < 20                                 ||\n+         ( length - 20 ) \/ 2 < count                 )\n       FT_INVALID_TOO_SHORT;\n \n     \/* check glyph indices *\/\n@@ -2079,7 +2087,9 @@\n     num_groups = TT_NEXT_ULONG( p );\n \n     if ( length > (FT_ULong)( valid->limit - table ) ||\n-         length < 16 + 12 * num_groups               )\n+         \/* length < 16 + 12 * num_groups ? *\/\n+         length < 16                                 ||\n+         ( length - 16 ) \/ 12 < num_groups           )\n       FT_INVALID_TOO_SHORT;\n \n     \/* check groups, they must be in increasing order *\/\n@@ -2101,7 +2111,12 @@\n \n         if ( valid->level >= FT_VALIDATE_TIGHT )\n         {\n-          if ( start_id + end - start >= TT_VALID_GLYPH_COUNT( valid ) )\n+          FT_UInt32  d = end - start;\n+\n+\n+          \/* start_id + end - start >= TT_VALID_GLYPH_COUNT( valid ) ? *\/\n+          if ( d > TT_VALID_GLYPH_COUNT( valid )             ||\n+               start_id >= TT_VALID_GLYPH_COUNT( valid ) - d )\n             FT_INVALID_GLYPH_ID;\n         }\n \n@@ -2401,7 +2416,9 @@\n     num_groups = TT_NEXT_ULONG( p );\n \n     if ( length > (FT_ULong)( valid->limit - table ) ||\n-         length < 16 + 12 * num_groups               )\n+         \/* length < 16 + 12 * num_groups ? *\/\n+         length < 16                                 ||\n+         ( length - 16 ) \/ 12 < num_groups           )\n       FT_INVALID_TOO_SHORT;\n \n     \/* check groups, they must be in increasing order *\/\n@@ -2787,7 +2804,9 @@\n     num_selectors = TT_NEXT_ULONG( p );\n \n     if ( length > (FT_ULong)( valid->limit - table ) ||\n-         length < 10 + 11 * num_selectors            )\n+         \/* length < 10 + 11 * num_selectors ? *\/\n+         length < 10                                 ||\n+         ( length - 10 ) \/ 11 < num_selectors        )\n       FT_INVALID_TOO_SHORT;\n \n     \/* check selectors, they must be in increasing order *\/\n@@ -2823,7 +2842,8 @@\n           FT_ULong  lastBase  = 0;\n \n \n-          if ( defp + numRanges * 4 > valid->limit )\n+          \/* defp + numRanges * 4 > valid->limit ? *\/\n+          if ( numRanges > (FT_ULong)( valid->limit - defp ) \/ 4 )\n             FT_INVALID_TOO_SHORT;\n \n           for ( i = 0; i < numRanges; ++i )\n@@ -2850,7 +2870,8 @@\n           FT_ULong  i, lastUni  = 0;\n \n \n-          if ( numMappings * 4 > (FT_ULong)( valid->limit - ndp ) )\n+          \/* numMappings * 4 > (FT_ULong)( valid->limit - ndp ) ? *\/\n+          if ( numMappings > ( (FT_ULong)( valid->limit - ndp ) ) \/ 4 )\n             FT_INVALID_TOO_SHORT;\n \n           for ( i = 0; i < numMappings; ++i )\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-14938","CWE_ID":"125","category":"security","commit_id":"a4e1cd14eb5ccc51ed271b65b3420f7d692c40eb","commit_message":"From a4e1cd14eb5ccc51ed271b65b3420f7d692c40eb Mon Sep 17 00:00:00 2001\nFrom: \"Simson L. Garfinkel\" <simsong@acm.org>\nDate: Thu, 2 Aug 2018 21:33:09 -0400\nSubject: [PATCH] fixed buffer overflow\n\n---\n src\/wifipcap\/wifipcap.cpp | 26 +++++++++++++++-----------\n 1 file changed, 15 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/src\/wifipcap\/wifipcap.cpp b\/src\/wifipcap\/wifipcap.cpp\nindex ef47ccf..5e45cdb 100644\n--- a\/src\/wifipcap\/wifipcap.cpp\n+++ b\/src\/wifipcap\/wifipcap.cpp\n@@ -1492,17 +1492,19 @@ void WifiPacket::handle_prism(const u_char *pc, size_t len)\n     prism2_pkthdr hdr;\n \n     \/* get the fields *\/\n-    hdr.host_time \t= EXTRACT_LE_32BITS(pc+32);\n-    hdr.mac_time \t= EXTRACT_LE_32BITS(pc+44);\n-    hdr.channel \t= EXTRACT_LE_32BITS(pc+56);\n-    hdr.rssi \t\t= EXTRACT_LE_32BITS(pc+68);\n-    hdr.sq \t\t= EXTRACT_LE_32BITS(pc+80);\n-    hdr.signal  \t= EXTRACT_LE_32BITS(pc+92);\n-    hdr.noise   \t= EXTRACT_LE_32BITS(pc+104);\n-    hdr.rate\t\t= EXTRACT_LE_32BITS(pc+116)\/2;\n-    hdr.istx\t\t= EXTRACT_LE_32BITS(pc+128);\n-    cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);\n-    handle_80211(pc+144,len-144);\n+    if (len>=144){\n+        hdr.host_time \t= EXTRACT_LE_32BITS(pc+32);\n+        hdr.mac_time \t= EXTRACT_LE_32BITS(pc+44);\n+        hdr.channel \t= EXTRACT_LE_32BITS(pc+56);\n+        hdr.rssi \t\t= EXTRACT_LE_32BITS(pc+68);\n+        hdr.sq \t\t= EXTRACT_LE_32BITS(pc+80);\n+        hdr.signal  \t= EXTRACT_LE_32BITS(pc+92);\n+        hdr.noise   \t= EXTRACT_LE_32BITS(pc+104);\n+        hdr.rate\t\t= EXTRACT_LE_32BITS(pc+116)\/2;\n+        hdr.istx\t\t= EXTRACT_LE_32BITS(pc+128);\n+        cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);\n+        handle_80211(pc+144,len-144);\n+    }\n }\n \n \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n@@ -1511,6 +1513,7 @@ void WifiPacket::handle_prism(const u_char *pc, size_t len)\n \/\/\/ handle each of the packet types\n \/\/\/\n \n+\/\/\/ 2018-08-02: slg - I'm not sure why this is commented out.\n void WifiPacket::handle_ether(const u_char *ptr, size_t len)\n {\n #if 0\n@@ -1715,6 +1718,7 @@ void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,\n         break;\n     default:\n #if 0\n+        \/\/\/ 2018-08-02: slg - I'm also not sure why this is commented out.\n \t\/\/ try handling it as default IP assuming framing is ethernet \n \t\/\/ (this is for testing)\n         pkt.handle_ip(packet,header->caplen);\n","owner":"simsong","repo":"tcpflow","source":"cve"},{"CVE_ID":"CVE-2016-10269","CWE_ID":"125","category":"security","commit_id":"1044b43637fa7f70fb19b93593777b78bd20da86","commit_message":"From 1044b43637fa7f70fb19b93593777b78bd20da86 Mon Sep 17 00:00:00 2001\nFrom: erouault <erouault>\nDate: Fri, 2 Dec 2016 23:05:51 +0000\nSubject: [PATCH] * libtiff\/tif_pixarlog.c, libtiff\/tif_luv.c: fix heap-based\n buffer overflow on generation of PixarLog \/ LUV compressed files, with\n ColorMap, TransferFunction attached and nasty plays with bitspersample. The\n fix for LUV has not been tested, but suffers from the same kind of issue of\n PixarLog. Reported by Agostino Sarubbo. Fixes\n http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2604\n\n---\n ChangeLog              | 10 ++++++++++\n libtiff\/tif_luv.c      | 18 ++++++++++++++----\n libtiff\/tif_pixarlog.c | 17 +++++++++++++++--\n 3 files changed, 39 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 0f154d66..93c01f80 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,13 @@\n+2016-12-03 Even Rouault <even.rouault at spatialys.com>\n+\n+\t* libtiff\/tif_pixarlog.c, libtiff\/tif_luv.c: fix heap-based buffer\n+\toverflow on generation of PixarLog \/ LUV compressed files, with\n+\tColorMap, TransferFunction attached and nasty plays with bitspersample.\n+\tThe fix for LUV has not been tested, but suffers from the same kind\n+\tof issue of PixarLog.\n+\tReported by Agostino Sarubbo.\n+\tFixes http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2604\n+\n 2016-12-02 Even Rouault <even.rouault at spatialys.com>\n \n \t* tools\/tiffcp.c: avoid uint32 underflow in cpDecodedStrips that \ndiff --git a\/libtiff\/tif_luv.c b\/libtiff\/tif_luv.c\nindex f68a9b13..e6783db5 100644\n--- a\/libtiff\/tif_luv.c\n+++ b\/libtiff\/tif_luv.c\n@@ -158,6 +158,7 @@\n typedef struct logLuvState LogLuvState;\n \n struct logLuvState {\n+        int                     encoder_state;  \/* 1 if encoder correctly initialized *\/\n \tint                     user_datafmt;   \/* user data format *\/\n \tint                     encode_meth;    \/* encoding method *\/\n \tint                     pixel_size;     \/* bytes per pixel *\/\n@@ -1552,6 +1553,7 @@ LogLuvSetupEncode(TIFF* tif)\n \t\t    td->td_photometric, \"must be either LogLUV or LogL\");\n \t\tbreak;\n \t}\n+\tsp->encoder_state = 1;\n \treturn (1);\n notsupported:\n \tTIFFErrorExt(tif->tif_clientdata, module,\n@@ -1563,19 +1565,27 @@ LogLuvSetupEncode(TIFF* tif)\n static void\n LogLuvClose(TIFF* tif)\n {\n+        LogLuvState* sp = (LogLuvState*) tif->tif_data;\n \tTIFFDirectory *td = &tif->tif_dir;\n \n+\tassert(sp != 0);\n \t\/*\n \t * For consistency, we always want to write out the same\n \t * bitspersample and sampleformat for our TIFF file,\n \t * regardless of the data format being used by the application.\n \t * Since this routine is called after tags have been set but\n \t * before they have been recorded in the file, we reset them here.\n+         * Note: this is really a nasty approach. See PixarLogClose\n \t *\/\n-\ttd->td_samplesperpixel =\n-\t    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n-\ttd->td_bitspersample = 16;\n-\ttd->td_sampleformat = SAMPLEFORMAT_INT;\n+        if( sp->encoder_state )\n+        {\n+            \/* See PixarLogClose. Might avoid issues with tags whose size depends\n+             * on those below, but not completely sure this is enough. *\/\n+            td->td_samplesperpixel =\n+                (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n+            td->td_bitspersample = 16;\n+            td->td_sampleformat = SAMPLEFORMAT_INT;\n+        }\n }\n \n static void\ndiff --git a\/libtiff\/tif_pixarlog.c b\/libtiff\/tif_pixarlog.c\nindex d1246c3d..aa99bc92 100644\n--- a\/libtiff\/tif_pixarlog.c\n+++ b\/libtiff\/tif_pixarlog.c\n@@ -1233,8 +1233,10 @@ PixarLogPostEncode(TIFF* tif)\n static void\n PixarLogClose(TIFF* tif)\n {\n+        PixarLogState* sp = (PixarLogState*) tif->tif_data;\n \tTIFFDirectory *td = &tif->tif_dir;\n \n+\tassert(sp != 0);\n \t\/* In a really sneaky (and really incorrect, and untruthful, and\n \t * troublesome, and error-prone) maneuver that completely goes against\n \t * the spirit of TIFF, and breaks TIFF, on close, we covertly\n@@ -1243,8 +1245,19 @@ PixarLogClose(TIFF* tif)\n \t * readers that don't know about PixarLog, or how to set\n \t * the PIXARLOGDATFMT pseudo-tag.\n \t *\/\n-\ttd->td_bitspersample = 8;\n-\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n+\n+        if (sp->state&PLSTATE_INIT) {\n+            \/* We test the state to avoid an issue such as in\n+             * http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2604\n+             * What appends in that case is that the bitspersample is 1 and\n+             * a TransferFunction is set. The size of the TransferFunction\n+             * depends on 1<<bitspersample. So if we increase it, an access\n+             * out of the buffer will happen at directory flushing.\n+             * Another option would be to clear those targs. \n+             *\/\n+            td->td_bitspersample = 8;\n+            td->td_sampleformat = SAMPLEFORMAT_UINT;\n+        }\n }\n \n static void\n","owner":"vadz","repo":"libtiff","source":"cve"},{"CVE_ID":"CVE-2015-5327","CWE_ID":"125","category":"security","commit_id":"cc25b994acfbc901429da682d0f73c190e960206","commit_message":"From cc25b994acfbc901429da682d0f73c190e960206 Mon Sep 17 00:00:00 2001\nFrom: David Howells <dhowells@redhat.com>\nDate: Thu, 12 Nov 2015 09:36:40 +0000\nSubject: X.509: Fix the time validation [ver #2]\n\nThis fixes CVE-2015-5327.  It affects kernels from 4.3-rc1 onwards.\n\nFix the X.509 time validation to use month number-1 when looking up the\nnumber of days in that month.  Also put the month number validation before\ndoing the lookup so as not to risk overrunning the array.\n\nThis can be tested by doing the following:\n\ncat <<EOF | openssl x509 -outform DER | keyctl padd asymmetric \"\" @s\n-----BEGIN CERTIFICATE-----\nMIIDbjCCAlagAwIBAgIJAN\/lUld+VR4hMA0GCSqGSIb3DQEBCwUAMCkxETAPBgNV\nBAoMCGxvY2FsLWNhMRQwEgYDVQQDDAtzaWduaW5nIGtleTAeFw0xNTA5MDEyMTMw\nMThaFw0xNjA4MzEyMTMwMThaMCkxETAPBgNVBAoMCGxvY2FsLWNhMRQwEgYDVQQD\nDAtzaWduaW5nIGtleTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANrn\ncrcMfMeG67nagX4+m02Xk9rkmsMKI5XTUxbikROe7GSUVJ27sPVPZp4mgzoWlvhh\njfK8CC\/qhEhwep8Pgg4EJZyWOjhZb7R97ckGvLIoUC6IO3FC2ZnR7WtmWDgo2Jcj\nVlXwJdHhKU1VZwulh81O61N8IBKqz2r\/kDhIWiicUCUkI\/Do\/RMRfKAoDBcSh86m\ngOeIAGfq62vbiZhVsX5dOE8Oo2TK5weAvwUIOR7OuGBl5AqwFlPnXQolewiHzKry\nTHg9e44HfzG4Mi6wUvcJxVaQT1h5SrKD779Z5+8+wf1JLaooetcEUArvWyuxCU59\nqxA4lsTjBwl4cmEki+cCAwEAAaOBmDCBlTAMBgNVHRMEBTADAQH\/MAsGA1UdDwQE\nAwIHgDAdBgNVHQ4EFgQUyND\/eKUis7ep\/hXMJ8iZMdUhI+IwWQYDVR0jBFIwUIAU\nyND\/eKUis7ep\/hXMJ8iZMdUhI+KhLaQrMCkxETAPBgNVBAoMCGxvY2FsLWNhMRQw\nEgYDVQQDDAtzaWduaW5nIGtleYIJAN\/lUld+VR4hMA0GCSqGSIb3DQEBCwUAA4IB\nAQAMqm1N1yD5pimUELLhT5eO2lRdGUfTozljRxc7e2QT3RLk2TtGhg65JFFN6eml\nXS58AEPVcAsSLDlR6WpOpOLB2giM0+fV\/eYFHHmh22yqTJl4YgkdUwyzPdCHNOZL\nhmSKeY9xliHb6PNrNWWtZwhYYvRaO2DX4GXOMR0Oa2O4vaYu6\/qGlZOZv3U6qZLY\nwwHEJSrqeBDyMuwN+eANHpoSpiBzD77S4e+7hUDJnql4j6xzJ65+nWJ89fCrQypR\n4sN5R3aGeIh3QAQUIKpHilwek0CtEaYERgc5m+jGyKSc1rezJW62hWRTaitOc+d5\nG5hh+9YpnYcxQHEKnZ7rFNKJ\n-----END CERTIFICATE-----\nEOF\n\nIf it works, it emit a key ID; if it fails, it should give a bad message\nerror.\n\nReported-by: Mimi Zohar <zohar@linux.vnet.ibm.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Mimi Zohar <zohar@linux.vnet.ibm.com>\nAcked-by: David Woodhouse <David.Woodhouse@intel.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>\n---\n crypto\/asymmetric_keys\/x509_cert_parser.c | 12 +++++++-----\n 1 file changed, 7 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/asymmetric_keys\/x509_cert_parser.c b\/crypto\/asymmetric_keys\/x509_cert_parser.c\nindex 3000ea3b6687..021d39c0ba75 100644\n--- a\/crypto\/asymmetric_keys\/x509_cert_parser.c\n+++ b\/crypto\/asymmetric_keys\/x509_cert_parser.c\n@@ -531,7 +531,11 @@ int x509_decode_time(time64_t *_t,  size_t hdrlen,\n \tif (*p != 'Z')\n \t\tgoto unsupported_time;\n \n-\tmon_len = month_lengths[mon];\n+\tif (year < 1970 ||\n+\t    mon < 1 || mon > 12)\n+\t\tgoto invalid_time;\n+\n+\tmon_len = month_lengths[mon - 1];\n \tif (mon == 2) {\n \t\tif (year % 4 == 0) {\n \t\t\tmon_len = 29;\n@@ -543,14 +547,12 @@ int x509_decode_time(time64_t *_t,  size_t hdrlen,\n \t\t}\n \t}\n \n-\tif (year < 1970 ||\n-\t    mon < 1 || mon > 12 ||\n-\t    day < 1 || day > mon_len ||\n+\tif (day < 1 || day > mon_len ||\n \t    hour > 23 ||\n \t    min > 59 ||\n \t    sec > 59)\n \t\tgoto invalid_time;\n-\t\n+\n \t*_t = mktime64(year, mon, day, hour, min, sec);\n \treturn 0;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-8831","CWE_ID":"125","category":"security","commit_id":"354dd3924a2e43806774953de536257548b5002c","commit_message":"From 354dd3924a2e43806774953de536257548b5002c Mon Sep 17 00:00:00 2001\nFrom: Steven Toth <stoth@kernellabs.com>\nDate: Tue, 6 Jun 2017 08:30:27 -0400\nSubject: [PATCH] [PATCH] saa7164: Bug - Double fetch PCIe access condition\n\nAvoid a double fetch by reusing the values from the prior transfer.\n\nOriginally reported via https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=195559\n\nThanks to Pengfei Wang <wpengfeinudt@gmail.com> for reporting.\n\nSigned-off-by: Steven Toth <stoth@kernellabs.com>\n---\n drivers\/media\/pci\/saa7164\/saa7164-bus.c | 13 +------------\n 1 file changed, 1 insertion(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/media\/pci\/saa7164\/saa7164-bus.c b\/drivers\/media\/pci\/saa7164\/saa7164-bus.c\nindex b2ff82fa7116..ecfeac5cdbed 100644\n--- a\/drivers\/media\/pci\/saa7164\/saa7164-bus.c\n+++ b\/drivers\/media\/pci\/saa7164\/saa7164-bus.c\n@@ -389,11 +389,11 @@ int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,\n \tmsg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);\n \tmsg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);\n \tmsg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);\n+\tmemcpy(msg, &msg_tmp, sizeof(*msg));\n \n \t\/* No need to update the read positions, because this was a peek *\/\n \t\/* If the caller specifically want to peek, return *\/\n \tif (peekonly) {\n-\t\tmemcpy(msg, &msg_tmp, sizeof(*msg));\n \t\tgoto peekout;\n \t}\n \n@@ -438,21 +438,15 @@ int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,\n \t\tspace_rem = bus->m_dwSizeGetRing - curr_grp;\n \n \t\tif (space_rem < sizeof(*msg)) {\n-\t\t\t\/* msg wraps around the ring *\/\n-\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, space_rem);\n-\t\t\tmemcpy_fromio((u8 *)msg + space_rem, bus->m_pdwGetRing,\n-\t\t\t\tsizeof(*msg) - space_rem);\n \t\t\tif (buf)\n \t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -\n \t\t\t\t\tspace_rem, buf_size);\n \n \t\t} else if (space_rem == sizeof(*msg)) {\n-\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));\n \t\t\tif (buf)\n \t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing, buf_size);\n \t\t} else {\n \t\t\t\/* Additional data wraps around the ring *\/\n-\t\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));\n \t\t\tif (buf) {\n \t\t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +\n \t\t\t\t\tsizeof(*msg), space_rem - sizeof(*msg));\n@@ -465,15 +459,10 @@ int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,\n \n \t} else {\n \t\t\/* No wrapping *\/\n-\t\tmemcpy_fromio(msg, bus->m_pdwGetRing + curr_grp, sizeof(*msg));\n \t\tif (buf)\n \t\t\tmemcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),\n \t\t\t\tbuf_size);\n \t}\n-\t\/* Convert from little endian to CPU *\/\n-\tmsg->size = le16_to_cpu((__force __le16)msg->size);\n-\tmsg->command = le32_to_cpu((__force __le32)msg->command);\n-\tmsg->controlselector = le16_to_cpu((__force __le16)msg->controlselector);\n \n \t\/* Update the read positions, adjusting the ring *\/\n \tsaa7164_writel(bus->m_dwGetReadPos, new_grp);\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2016-6905","CWE_ID":"125","category":"security","commit_id":"3c2b605d72e8b080dace1d98a6e50b46c1d12186","commit_message":"From 3c2b605d72e8b080dace1d98a6e50b46c1d12186 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Ond=C5=99ej=20Sur=C3=BD?= <ondrej@sury.org>\nDate: Tue, 12 Jul 2016 14:20:16 +0200\nSubject: [PATCH] bug #248, fix Out-Of-Bounds Read in read_image_tga\n\n---\n src\/gd_tga.c | 34 ++++++++++++++++++++++++++--------\n 1 file changed, 26 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/src\/gd_tga.c b\/src\/gd_tga.c\nindex b4f8fa62..6420cae6 100644\n--- a\/src\/gd_tga.c\n+++ b\/src\/gd_tga.c\n@@ -278,14 +278,23 @@ int read_image_tga( gdIOCtx *ctx, oTga *tga )\n \t\tbuffer_caret = 0;\n \n \t\twhile( bitmap_caret < image_block_size ) {\n-\n+\t\t\t\n \t\t\tif ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) {\n \t\t\t\tencoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 );\n \t\t\t\tbuffer_caret++;\n \n-\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n-\t\t\t\t\tfor (j = 0; j < pixel_block_size; j++, bitmap_caret++) {\n-\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n+\t\t\t\tif (encoded_pixels != 0) {\n+\t\t\t\t\n+\t\t\t\t\tif (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {\n+\t\t\t\t\t\tgdFree( decompression_buffer );\n+\t\t\t\t\t\tgdFree( conversion_buffer );\n+\t\t\t\t\t\treturn -1;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n+\t\t\t\t\t\tfor (j = 0; j < pixel_block_size; j++, bitmap_caret++) {\n+\t\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbuffer_caret += pixel_block_size;\n@@ -293,11 +302,20 @@ int read_image_tga( gdIOCtx *ctx, oTga *tga )\n \t\t\t\tencoded_pixels = decompression_buffer[ buffer_caret ] + 1;\n \t\t\t\tbuffer_caret++;\n \n-\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n-\t\t\t\t\tfor( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {\n-\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n+\t\t\t\tif (encoded_pixels != 0) {\n+\t\t\t\t\n+\t\t\t\t\tif (!((buffer_caret + (encoded_pixels * pixel_block_size)) < image_block_size)) {\n+\t\t\t\t\t\tgdFree( decompression_buffer );\n+\t\t\t\t\t\tgdFree( conversion_buffer );\n+\t\t\t\t\t\treturn -1;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tfor (i = 0; i < encoded_pixels; i++) {\n+\t\t\t\t\t\tfor( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) {\n+\t\t\t\t\t\t\ttga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ];\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbuffer_caret += pixel_block_size;\n \t\t\t\t\t}\n-\t\t\t\t\tbuffer_caret += pixel_block_size;\n \t\t\t\t}\n \t\t\t}\n \t\t}\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2014-9657","CWE_ID":"125","category":"security","commit_id":"eca0f067068020870a429fe91f6329e499390d55","commit_message":"From eca0f067068020870a429fe91f6329e499390d55 Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Mon, 24 Nov 2014 10:22:08 +0100\nSubject: [truetype] Fix Savannah bug #43679.\n\n* src\/truetype\/ttpload.c (tt_face_load_hdmx): Check minimum size of\n`record_size'.\n---\n ChangeLog              |  7 +++++++\n src\/truetype\/ttpload.c | 12 +++++++-----\n 2 files changed, 14 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 76ca675..f53d56b 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,10 @@\n+2014-11-24  Werner Lemberg  <wl@gnu.org>\n+\n+\t[truetype] Fix Savannah bug #43679.\n+\n+\t* src\/truetype\/ttpload.c (tt_face_load_hdmx): Check minimum size of\n+\t`record_size'.\n+\n 2014-11-24  Jarkko P\u00f6yry  <jarkko.poyry@gmail.com>\n \n \t[cff, pfr, psaux, winfonts] Fix Savannah bug #43676.\ndiff --git a\/src\/truetype\/ttpload.c b\/src\/truetype\/ttpload.c\nindex 9723a51..9991925 100644\n--- a\/src\/truetype\/ttpload.c\n+++ b\/src\/truetype\/ttpload.c\n@@ -508,9 +508,9 @@\n     record_size = FT_NEXT_ULONG( p );\n \n     \/* The maximum number of bytes in an hdmx device record is the *\/\n-    \/* maximum number of glyphs + 2; this is 0xFFFF + 2; this is   *\/\n-    \/* the reason why `record_size' is a long (which we read as    *\/\n-    \/* unsigned long for convenience).  In practice, two bytes     *\/\n+    \/* maximum number of glyphs + 2; this is 0xFFFF + 2, thus      *\/\n+    \/* explaining why `record_size' is a long (which we read as    *\/\n+    \/* unsigned long for convenience).  In practice, two bytes are *\/\n     \/* sufficient to hold the size value.                          *\/\n     \/*                                                             *\/\n     \/* There are at least two fonts, HANNOM-A and HANNOM-B version *\/\n@@ -522,8 +522,10 @@\n       record_size &= 0xFFFFU;\n \n     \/* The limit for `num_records' is a heuristic value. *\/\n-\n-    if ( version != 0 || num_records > 255 || record_size > 0x10001L )\n+    if ( version != 0           ||\n+         num_records > 255      ||\n+         record_size > 0x10001L ||\n+         record_size < 4        )\n     {\n       error = FT_THROW( Invalid_File_Format );\n       goto Fail;\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"}]