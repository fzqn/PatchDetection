[{"CVE_ID":"CVE-2016-8887","CWE_ID":"476","category":"security","commit_id":"e24bdc716c3327b067c551bc6cfb97fd2370358d","commit_message":"From e24bdc716c3327b067c551bc6cfb97fd2370358d Mon Sep 17 00:00:00 2001\nFrom: Michael Adams <mdadams@ece.uvic.ca>\nDate: Fri, 21 Oct 2016 00:00:27 -0700\nSubject: [PATCH] Fixed a bug that resulted in the destruction of JP2 box data\n that had never been constructed in the first place.\n\n---\n src\/libjasper\/jp2\/jp2_cod.c | 7 +++++++\n src\/libjasper\/jp2\/jp2_dec.c | 2 +-\n 2 files changed, 8 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/libjasper\/jp2\/jp2_cod.c b\/src\/libjasper\/jp2\/jp2_cod.c\nindex 6255fe3..dc0f66c 100644\n--- a\/src\/libjasper\/jp2\/jp2_cod.c\n+++ b\/src\/libjasper\/jp2\/jp2_cod.c\n@@ -258,6 +258,10 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n+\tJAS_DBGLOG(10, (\n+\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n+\t  '\"', boxinfo->name, '\"', box->type, box->len\n+\t  ));\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n@@ -282,6 +286,9 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n+\t\t\t\/\/ Mark the box data as never having been constructed\n+\t\t\t\/\/ so that we will not errantly attempt to destroy it later.\n+\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\ndiff --git a\/src\/libjasper\/jp2\/jp2_dec.c b\/src\/libjasper\/jp2\/jp2_dec.c\nindex 07210f1..2996393 100644\n--- a\/src\/libjasper\/jp2\/jp2_dec.c\n+++ b\/src\/libjasper\/jp2\/jp2_dec.c\n@@ -155,7 +155,7 @@ jas_image_t *jp2_decode(jas_stream_t *in, char *optstr)\n \tfound = 0;\n \twhile ((box = jp2_box_get(in))) {\n \t\tif (jas_getdbglevel() >= 1) {\n-\t\t\tjas_eprintf(\"box type %s\\n\", box->info->name);\n+\t\t\tjas_eprintf(\"got box type %s\\n\", box->info->name);\n \t\t}\n \t\tswitch (box->type) {\n \t\tcase JP2_BOX_JP2C:\n","owner":"mdadams","repo":"jasper","source":"cve"},{"CVE_ID":"CVE-2017-6210","CWE_ID":"476","category":"security","commit_id":"0a5dff15912207b83018485f83e067474e818bab","commit_message":"From 0a5dff15912207b83018485f83e067474e818bab Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Thu, 5 Jan 2017 18:02:46 -0800\nSubject: vrend: never destroy context 0 in vrend_renderer_context_destroy\n\nThere will be a crash if the guest destroy context 0. As the context 0 is\nallocate in renderer init, not destroy in vrend_renderer_context_destroy.\nThe context will be freed in renderer fini by calling vrend_decode_reset.\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n src\/vrend_decode.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/src\/vrend_decode.c b\/src\/vrend_decode.c\nindex cab3956..11ac1ed 100644\n--- a\/src\/vrend_decode.c\n+++ b\/src\/vrend_decode.c\n@@ -1093,6 +1093,11 @@ void vrend_renderer_context_destroy(uint32_t handle)\n    if (handle >= VREND_MAX_CTX)\n       return;\n \n+   \/* never destroy context 0 here, it will be destroyed in vrend_decode_reset()*\/\n+   if (handle == 0) {\n+      return;\n+   }\n+\n    ctx = dec_ctx[handle];\n    if (!ctx)\n       return;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-14640","CWE_ID":"476","category":"security","commit_id":"2f267f89f957088197f4b1fc254632d1645b415d","commit_message":"From 2f267f89f957088197f4b1fc254632d1645b415d Mon Sep 17 00:00:00 2001\nFrom: Gilles Boccon-Gibod <bok@bok.net>\nDate: Sat, 9 Sep 2017 10:42:03 -0700\nSubject: [PATCH] fix for #183\n\n---\n Source\/C++\/Core\/Ap4AtomSampleTable.cpp | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp b\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\nindex 77d11191..ec3b0806 100644\n--- a\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\n+++ b\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\n@@ -140,8 +140,10 @@ AP4_AtomSampleTable::GetSample(AP4_Ordinal index,\n     AP4_UI32 cts_offset = 0;\n     AP4_UI64 dts        = 0;\n     AP4_UI32 duration   = 0;\n-    result = m_SttsAtom->GetDts(index, dts, &duration);\n-    if (AP4_FAILED(result)) return result;\n+    if (m_SttsAtom) {\n+        result = m_SttsAtom->GetDts(index, dts, &duration);\n+        if (AP4_FAILED(result)) return result;\n+    }\n     sample.SetDuration(duration);\n     sample.SetDts(dts);\n     if (m_CttsAtom == NULL) {\n","owner":"axiomatic-systems","repo":"Bento4","source":"cve"},{"CVE_ID":"CVE-2019-12382","CWE_ID":"476","category":"security","commit_id":"9f1f1a2dab38d4ce87a13565cf4dc1b73bef3a5f","commit_message":"From 9f1f1a2dab38d4ce87a13565cf4dc1b73bef3a5f Mon Sep 17 00:00:00 2001\nFrom: Gen Zhang <blackgod016574@gmail.com>\nDate: Fri, 24 May 2019 10:32:22 +0800\nSubject: drm\/edid: Fix a missing-check bug in drm_load_edid_firmware()\n\nIn drm_load_edid_firmware(), fwstr is allocated by kstrdup(). And fwstr\nis dereferenced in the following codes. However, memory allocation\nfunctions such as kstrdup() may fail and returns NULL. Dereferencing\nthis null pointer may cause the kernel go wrong. Thus we should check\nthis kstrdup() operation.\nFurther, if kstrdup() returns NULL, we should return ERR_PTR(-ENOMEM) to\nthe caller site.\n\nSigned-off-by: Gen Zhang <blackgod016574@gmail.com>\nReviewed-by: Jani Nikula <jani.nikula@intel.com>\nSigned-off-by: Jani Nikula <jani.nikula@intel.com>\nLink: https:\/\/patchwork.freedesktop.org\/patch\/msgid\/20190524023222.GA5302@zhanggen-UX430UQ\n---\n drivers\/gpu\/drm\/drm_edid_load.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/gpu\/drm\/drm_edid_load.c b\/drivers\/gpu\/drm\/drm_edid_load.c\nindex 18d52dc..2e8d043 100644\n--- a\/drivers\/gpu\/drm\/drm_edid_load.c\n+++ b\/drivers\/gpu\/drm\/drm_edid_load.c\n@@ -293,6 +293,8 @@ struct edid *drm_load_edid_firmware(struct drm_connector *connector)\n \t * the last one found one as a fallback.\n \t *\/\n \tfwstr = kstrdup(edid_firmware, GFP_KERNEL);\n+\tif (!fwstr)\n+\t\treturn ERR_PTR(-ENOMEM);\n \tedidstr = fwstr;\n \n \twhile ((edidname = strsep(&edidstr, \",\"))) {\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-1000200","CWE_ID":"476","category":"security","commit_id":"27ae357fa82be5ab73b2ef8d39dcb8ca2563483a","commit_message":"From 27ae357fa82be5ab73b2ef8d39dcb8ca2563483a Mon Sep 17 00:00:00 2001\nFrom: David Rientjes <rientjes@google.com>\nDate: Fri, 11 May 2018 16:02:04 -0700\nSubject: mm, oom: fix concurrent munlock and oom reaper unmap, v3\n\nSince exit_mmap() is done without the protection of mm->mmap_sem, it is\npossible for the oom reaper to concurrently operate on an mm until\nMMF_OOM_SKIP is set.\n\nThis allows munlock_vma_pages_all() to concurrently run while the oom\nreaper is operating on a vma.  Since munlock_vma_pages_range() depends\non clearing VM_LOCKED from vm_flags before actually doing the munlock to\ndetermine if any other vmas are locking the same memory, the check for\nVM_LOCKED in the oom reaper is racy.\n\nThis is especially noticeable on architectures such as powerpc where\nclearing a huge pmd requires serialize_against_pte_lookup().  If the pmd\nis zapped by the oom reaper during follow_page_mask() after the check\nfor pmd_none() is bypassed, this ends up deferencing a NULL ptl or a\nkernel oops.\n\nFix this by manually freeing all possible memory from the mm before\ndoing the munlock and then setting MMF_OOM_SKIP.  The oom reaper can not\nrun on the mm anymore so the munlock is safe to do in exit_mmap().  It\nalso matches the logic that the oom reaper currently uses for\ndetermining when to set MMF_OOM_SKIP itself, so there's no new risk of\nexcessive oom killing.\n\nThis issue fixes CVE-2018-1000200.\n\nLink: http:\/\/lkml.kernel.org\/r\/alpine.DEB.2.21.1804241526320.238665@chino.kir.corp.google.com\nFixes: 212925802454 (\"mm: oom: let oom_reap_task and exit_mmap run concurrently\")\nSigned-off-by: David Rientjes <rientjes@google.com>\nSuggested-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nAcked-by: Michal Hocko <mhocko@suse.com>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\t[4.14+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n include\/linux\/oom.h |  2 ++\n mm\/mmap.c           | 44 +++++++++++++++++------------\n mm\/oom_kill.c       | 81 ++++++++++++++++++++++++++++-------------------------\n 3 files changed, 71 insertions(+), 56 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/oom.h b\/include\/linux\/oom.h\nindex 5bad038ac012..6adac113e96d 100644\n--- a\/include\/linux\/oom.h\n+++ b\/include\/linux\/oom.h\n@@ -95,6 +95,8 @@ static inline int check_stable_address_space(struct mm_struct *mm)\n \treturn 0;\n }\n \n+void __oom_reap_task_mm(struct mm_struct *mm);\n+\n extern unsigned long oom_badness(struct task_struct *p,\n \t\tstruct mem_cgroup *memcg, const nodemask_t *nodemask,\n \t\tunsigned long totalpages);\ndiff --git a\/mm\/mmap.c b\/mm\/mmap.c\nindex 9d5968d1e8e3..d6836566e4e5 100644\n--- a\/mm\/mmap.c\n+++ b\/mm\/mmap.c\n@@ -3024,6 +3024,32 @@ void exit_mmap(struct mm_struct *mm)\n \t\/* mm's last user has gone, and its about to be pulled down *\/\n \tmmu_notifier_release(mm);\n \n+\tif (unlikely(mm_is_oom_victim(mm))) {\n+\t\t\/*\n+\t\t * Manually reap the mm to free as much memory as possible.\n+\t\t * Then, as the oom reaper does, set MMF_OOM_SKIP to disregard\n+\t\t * this mm from further consideration.  Taking mm->mmap_sem for\n+\t\t * write after setting MMF_OOM_SKIP will guarantee that the oom\n+\t\t * reaper will not run on this mm again after mmap_sem is\n+\t\t * dropped.\n+\t\t *\n+\t\t * Nothing can be holding mm->mmap_sem here and the above call\n+\t\t * to mmu_notifier_release(mm) ensures mmu notifier callbacks in\n+\t\t * __oom_reap_task_mm() will not block.\n+\t\t *\n+\t\t * This needs to be done before calling munlock_vma_pages_all(),\n+\t\t * which clears VM_LOCKED, otherwise the oom reaper cannot\n+\t\t * reliably test it.\n+\t\t *\/\n+\t\tmutex_lock(&oom_lock);\n+\t\t__oom_reap_task_mm(mm);\n+\t\tmutex_unlock(&oom_lock);\n+\n+\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n+\t\tdown_write(&mm->mmap_sem);\n+\t\tup_write(&mm->mmap_sem);\n+\t}\n+\n \tif (mm->locked_vm) {\n \t\tvma = mm->mmap;\n \t\twhile (vma) {\n@@ -3045,24 +3071,6 @@ void exit_mmap(struct mm_struct *mm)\n \t\/* update_hiwater_rss(mm) here? but nobody should be looking *\/\n \t\/* Use -1 here to ensure all VMAs in the mm are unmapped *\/\n \tunmap_vmas(&tlb, vma, 0, -1);\n-\n-\tif (unlikely(mm_is_oom_victim(mm))) {\n-\t\t\/*\n-\t\t * Wait for oom_reap_task() to stop working on this\n-\t\t * mm. Because MMF_OOM_SKIP is already set before\n-\t\t * calling down_read(), oom_reap_task() will not run\n-\t\t * on this \"mm\" post up_write().\n-\t\t *\n-\t\t * mm_is_oom_victim() cannot be set from under us\n-\t\t * either because victim->mm is already set to NULL\n-\t\t * under task_lock before calling mmput and oom_mm is\n-\t\t * set not NULL by the OOM killer only if victim->mm\n-\t\t * is found not NULL while holding the task_lock.\n-\t\t *\/\n-\t\tset_bit(MMF_OOM_SKIP, &mm->flags);\n-\t\tdown_write(&mm->mmap_sem);\n-\t\tup_write(&mm->mmap_sem);\n-\t}\n \tfree_pgtables(&tlb, vma, FIRST_USER_ADDRESS, USER_PGTABLES_CEILING);\n \ttlb_finish_mmu(&tlb, 0, -1);\n \ndiff --git a\/mm\/oom_kill.c b\/mm\/oom_kill.c\nindex ff992fa8760a..8ba6cb88cf58 100644\n--- a\/mm\/oom_kill.c\n+++ b\/mm\/oom_kill.c\n@@ -469,7 +469,6 @@ bool process_shares_mm(struct task_struct *p, struct mm_struct *mm)\n \treturn false;\n }\n \n-\n #ifdef CONFIG_MMU\n \/*\n  * OOM Reaper kernel thread which tries to reap the memory used by the OOM\n@@ -480,16 +479,54 @@ static DECLARE_WAIT_QUEUE_HEAD(oom_reaper_wait);\n static struct task_struct *oom_reaper_list;\n static DEFINE_SPINLOCK(oom_reaper_lock);\n \n-static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n+void __oom_reap_task_mm(struct mm_struct *mm)\n {\n-\tstruct mmu_gather tlb;\n \tstruct vm_area_struct *vma;\n+\n+\t\/*\n+\t * Tell all users of get_user\/copy_from_user etc... that the content\n+\t * is no longer stable. No barriers really needed because unmapping\n+\t * should imply barriers already and the reader would hit a page fault\n+\t * if it stumbled over a reaped memory.\n+\t *\/\n+\tset_bit(MMF_UNSTABLE, &mm->flags);\n+\n+\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n+\t\tif (!can_madv_dontneed_vma(vma))\n+\t\t\tcontinue;\n+\n+\t\t\/*\n+\t\t * Only anonymous pages have a good chance to be dropped\n+\t\t * without additional steps which we cannot afford as we\n+\t\t * are OOM already.\n+\t\t *\n+\t\t * We do not even care about fs backed pages because all\n+\t\t * which are reclaimable have already been reclaimed and\n+\t\t * we do not want to block exit_mmap by keeping mm ref\n+\t\t * count elevated without a good reason.\n+\t\t *\/\n+\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n+\t\t\tconst unsigned long start = vma->vm_start;\n+\t\t\tconst unsigned long end = vma->vm_end;\n+\t\t\tstruct mmu_gather tlb;\n+\n+\t\t\ttlb_gather_mmu(&tlb, mm, start, end);\n+\t\t\tmmu_notifier_invalidate_range_start(mm, start, end);\n+\t\t\tunmap_page_range(&tlb, vma, start, end, NULL);\n+\t\t\tmmu_notifier_invalidate_range_end(mm, start, end);\n+\t\t\ttlb_finish_mmu(&tlb, start, end);\n+\t\t}\n+\t}\n+}\n+\n+static bool oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n+{\n \tbool ret = true;\n \n \t\/*\n \t * We have to make sure to not race with the victim exit path\n \t * and cause premature new oom victim selection:\n-\t * __oom_reap_task_mm\t\texit_mm\n+\t * oom_reap_task_mm\t\texit_mm\n \t *   mmget_not_zero\n \t *\t\t\t\t  mmput\n \t *\t\t\t\t    atomic_dec_and_test\n@@ -534,39 +571,8 @@ static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n \n \ttrace_start_task_reaping(tsk->pid);\n \n-\t\/*\n-\t * Tell all users of get_user\/copy_from_user etc... that the content\n-\t * is no longer stable. No barriers really needed because unmapping\n-\t * should imply barriers already and the reader would hit a page fault\n-\t * if it stumbled over a reaped memory.\n-\t *\/\n-\tset_bit(MMF_UNSTABLE, &mm->flags);\n-\n-\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n-\t\tif (!can_madv_dontneed_vma(vma))\n-\t\t\tcontinue;\n+\t__oom_reap_task_mm(mm);\n \n-\t\t\/*\n-\t\t * Only anonymous pages have a good chance to be dropped\n-\t\t * without additional steps which we cannot afford as we\n-\t\t * are OOM already.\n-\t\t *\n-\t\t * We do not even care about fs backed pages because all\n-\t\t * which are reclaimable have already been reclaimed and\n-\t\t * we do not want to block exit_mmap by keeping mm ref\n-\t\t * count elevated without a good reason.\n-\t\t *\/\n-\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) {\n-\t\t\tconst unsigned long start = vma->vm_start;\n-\t\t\tconst unsigned long end = vma->vm_end;\n-\n-\t\t\ttlb_gather_mmu(&tlb, mm, start, end);\n-\t\t\tmmu_notifier_invalidate_range_start(mm, start, end);\n-\t\t\tunmap_page_range(&tlb, vma, start, end, NULL);\n-\t\t\tmmu_notifier_invalidate_range_end(mm, start, end);\n-\t\t\ttlb_finish_mmu(&tlb, start, end);\n-\t\t}\n-\t}\n \tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n \t\t\ttask_pid_nr(tsk), tsk->comm,\n \t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n@@ -587,14 +593,13 @@ static void oom_reap_task(struct task_struct *tsk)\n \tstruct mm_struct *mm = tsk->signal->oom_mm;\n \n \t\/* Retry the down_read_trylock(mmap_sem) a few times *\/\n-\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !__oom_reap_task_mm(tsk, mm))\n+\twhile (attempts++ < MAX_OOM_REAP_RETRIES && !oom_reap_task_mm(tsk, mm))\n \t\tschedule_timeout_idle(HZ\/10);\n \n \tif (attempts <= MAX_OOM_REAP_RETRIES ||\n \t    test_bit(MMF_OOM_SKIP, &mm->flags))\n \t\tgoto done;\n \n-\n \tpr_info(\"oom_reaper: unable to reap pid:%d (%s)\\n\",\n \t\ttask_pid_nr(tsk), tsk->comm);\n \tdebug_show_all_locks();\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12193","CWE_ID":"476","category":"security","commit_id":"ea6789980fdaa610d7eb63602c746bf6ec70cd2b","commit_message":"From ea6789980fdaa610d7eb63602c746bf6ec70cd2b Mon Sep 17 00:00:00 2001\nFrom: David Howells <dhowells@redhat.com>\nDate: Wed, 11 Oct 2017 23:32:27 +0100\nSubject: assoc_array: Fix a buggy node-splitting case\n\nThis fixes CVE-2017-12193.\n\nFix a case in the assoc_array implementation in which a new leaf is\nadded that needs to go into a node that happens to be full, where the\nexisting leaves in that node cluster together at that level to the\nexclusion of new leaf.\n\nWhat needs to happen is that the existing leaves get moved out to a new\nnode, N1, at level + 1 and the existing node needs replacing with one,\nN0, that has pointers to the new leaf and to N1.\n\nThe code that tries to do this gets this wrong in two ways:\n\n (1) The pointer that should've pointed from N0 to N1 is set to point\n     recursively to N0 instead.\n\n (2) The backpointer from N0 needs to be set correctly in the case N0 is\n     either the root node or reached through a shortcut.\n\nFix this by removing this path and using the split_node path instead,\nwhich achieves the same end, but in a more general way (thanks to Eric\nBiggers for spotting the redundancy).\n\nThe problem manifests itself as:\n\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000010\n  IP: assoc_array_apply_edit+0x59\/0xe5\n\nFixes: 3cb989501c26 (\"Add a generic associative array implementation.\")\nReported-and-tested-by: WU Fan <u3536072@connect.hku.hk>\nSigned-off-by: David Howells <dhowells@redhat.com>\nCc: stable@vger.kernel.org [v3.13-rc1+]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n lib\/assoc_array.c | 51 +++++++++++++++++----------------------------------\n 1 file changed, 17 insertions(+), 34 deletions(-)\n\n","diff_code":"diff --git a\/lib\/assoc_array.c b\/lib\/assoc_array.c\nindex 155c55d8db5f..4e53be8bc590 100644\n--- a\/lib\/assoc_array.c\n+++ b\/lib\/assoc_array.c\n@@ -598,21 +598,31 @@ static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,\n \t\tif ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)\n \t\t\tgoto all_leaves_cluster_together;\n \n-\t\t\/* Otherwise we can just insert a new node ahead of the old\n-\t\t * one.\n+\t\t\/* Otherwise all the old leaves cluster in the same slot, but\n+\t\t * the new leaf wants to go into a different slot - so we\n+\t\t * create a new node (n0) to hold the new leaf and a pointer to\n+\t\t * a new node (n1) holding all the old leaves.\n+\t\t *\n+\t\t * This can be done by falling through to the node splitting\n+\t\t * path.\n \t\t *\/\n-\t\tgoto present_leaves_cluster_but_not_new_leaf;\n+\t\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n \t}\n \n split_node:\n \tpr_devel(\"split node\\n\");\n \n-\t\/* We need to split the current node; we know that the node doesn't\n-\t * simply contain a full set of leaves that cluster together (it\n-\t * contains meta pointers and\/or non-clustering leaves).\n+\t\/* We need to split the current node.  The node must contain anything\n+\t * from a single leaf (in the one leaf case, this leaf will cluster\n+\t * with the new leaf) and the rest meta-pointers, to all leaves, some\n+\t * of which may cluster.\n+\t *\n+\t * It won't contain the case in which all the current leaves plus the\n+\t * new leaves want to cluster in the same slot.\n \t *\n \t * We need to expel at least two leaves out of a set consisting of the\n-\t * leaves in the node and the new leaf.\n+\t * leaves in the node and the new leaf.  The current meta pointers can\n+\t * just be copied as they shouldn't cluster with any of the leaves.\n \t *\n \t * We need a new node (n0) to replace the current one and a new node to\n \t * take the expelled nodes (n1).\n@@ -717,33 +727,6 @@ found_slot_for_multiple_occupancy:\n \tpr_devel(\"<--%s() = ok [split node]\\n\", __func__);\n \treturn true;\n \n-present_leaves_cluster_but_not_new_leaf:\n-\t\/* All the old leaves cluster in the same slot, but the new leaf wants\n-\t * to go into a different slot, so we create a new node to hold the new\n-\t * leaf and a pointer to a new node holding all the old leaves.\n-\t *\/\n-\tpr_devel(\"present leaves cluster but not new leaf\\n\");\n-\n-\tnew_n0->back_pointer = node->back_pointer;\n-\tnew_n0->parent_slot = node->parent_slot;\n-\tnew_n0->nr_leaves_on_branch = node->nr_leaves_on_branch;\n-\tnew_n1->back_pointer = assoc_array_node_to_ptr(new_n0);\n-\tnew_n1->parent_slot = edit->segment_cache[0];\n-\tnew_n1->nr_leaves_on_branch = node->nr_leaves_on_branch;\n-\tedit->adjust_count_on = new_n0;\n-\n-\tfor (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++)\n-\t\tnew_n1->slots[i] = node->slots[i];\n-\n-\tnew_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0);\n-\tedit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]];\n-\n-\tedit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot];\n-\tedit->set[0].to = assoc_array_node_to_ptr(new_n0);\n-\tedit->excised_meta[0] = assoc_array_node_to_ptr(node);\n-\tpr_devel(\"<--%s() = ok [insert node before]\\n\", __func__);\n-\treturn true;\n-\n all_leaves_cluster_together:\n \t\/* All the leaves, new and old, want to cluster together in this node\n \t * in the same slot, so we have to replace this node with a shortcut to\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-10210","CWE_ID":"476","category":"security","commit_id":"3119b232c9c453c98d8fa8b6ae4e37ba18117cd4","commit_message":"From 3119b232c9c453c98d8fa8b6ae4e37ba18117cd4 Mon Sep 17 00:00:00 2001\nFrom: Hilko Bengen <hillu@users.noreply.github.com>\nDate: Tue, 17 Jan 2017 17:07:02 +0100\nSubject: [PATCH] re_lexer: Make reading escape sequences more robust (#586)\n\n* Add test for issue #503\n\n* re_lexer: Make reading escape sequences more robust\n\nThis commit fixes parsing incomplete escape sequences at the end of a\nregular expression and parsing things like \\xxy (invalid hex digits)\nwhich before were silently turned into (char)255.\n\nClose #503\n\n* Update re_lexer.c\n---\n libyara\/re_lexer.c | 40 ++++++++++++++++++++--------------------\n libyara\/re_lexer.l | 12 ++++++------\n tests\/test-rules.c |  6 ++++++\n 3 files changed, 32 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/libyara\/re_lexer.c b\/libyara\/re_lexer.c\nindex 82d48719..f0940a8b 100644\n--- a\/libyara\/re_lexer.c\n+++ b\/libyara\/re_lexer.c\n@@ -190,7 +190,7 @@ typedef size_t yy_size_t;\n \n     \/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires\n      *       access to the local variable yy_act. Since yyless() is a macro, it would break\n-     *       existing scanners that call yyless() from OUTSIDE re_yylex. \n+     *       existing scanners that call yyless() from OUTSIDE re_yylex.\n      *       One obvious solution it to make yy_act a global. I tried that, and saw\n      *       a 5% performance hit in a non-yylineno scanner, because yy_act is\n      *       normally declared as a register variable-- so it is not worth it.\n@@ -266,7 +266,7 @@ struct yy_buffer_state\n \n     int yy_bs_lineno; \/**< The line count. *\/\n     int yy_bs_column; \/**< The column count. *\/\n-    \n+\n \t\/* Whether to try to fill the input buffer when we reach the\n \t * end of it.\n \t *\/\n@@ -906,7 +906,7 @@ YY_DECL\n \t\t\tyy_size_t yyl;\n \t\t\tfor ( yyl = 0; yyl < yyleng; ++yyl )\n \t\t\t\tif ( yytext[yyl] == '\\n' )\n-\t\t\t\t\t   \n+\t\t\t\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -1125,7 +1125,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -1180,7 +1180,7 @@ YY_RULE_SETUP\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+      yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n       yyterminate();\n     }\n   }\n@@ -1292,7 +1292,7 @@ YY_RULE_SETUP\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -1763,7 +1763,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)\n \tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n \n \tif ( c == '\\n' )\n-\t\t   \n+\t\t\n     do{ yylineno++;\n         yycolumn=0;\n     }while(0)\n@@ -2018,9 +2018,9 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n \t\t\t\t\t\t\t\t, yyscanner);\n \t\tif ( ! yyg->yy_buffer_stack )\n \t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n-\t\t\t\t\t\t\t\t  \n+\n \t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n-\t\t\t\t\n+\n \t\tyyg->yy_buffer_stack_max = num_to_alloc;\n \t\tyyg->yy_buffer_stack_top = 0;\n \t\treturn;\n@@ -2049,7 +2049,7 @@ static void re_yyensure_buffer_stack (yyscan_t yyscanner)\n  * @param base the character buffer\n  * @param size the size in bytes of the character buffer\n  * @param yyscanner The scanner object.\n- * @return the newly allocated buffer state object. \n+ * @return the newly allocated buffer state object.\n  *\/\n YY_BUFFER_STATE re_yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n {\n@@ -2177,7 +2177,7 @@ YY_EXTRA_TYPE re_yyget_extra  (yyscan_t yyscanner)\n int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2190,7 +2190,7 @@ int re_yyget_lineno  (yyscan_t yyscanner)\n int re_yyget_column  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n-    \n+\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n@@ -2365,20 +2365,20 @@ int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n         errno = EINVAL;\n         return 1;\n     }\n-\t\n+\n     *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n-\t\n+\n     if (*ptr_yy_globals == NULL){\n         errno = ENOMEM;\n         return 1;\n     }\n-    \n+\n     \/* By setting to 0xAA, we expose bugs in\n     yy_init_globals. Leave at 0x00 for releases. *\/\n     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n-    \n+\n     re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n-    \n+\n     return yy_init_globals ( *ptr_yy_globals );\n }\n \n@@ -2568,19 +2568,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n \ndiff --git a\/libyara\/re_lexer.l b\/libyara\/re_lexer.l\nindex 1b3f5aa8..9e0b0054 100644\n--- a\/libyara\/re_lexer.l\n+++ b\/libyara\/re_lexer.l\n@@ -261,7 +261,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -312,7 +312,7 @@ hex_digit     [0-9a-fA-F]\n   {\n     if (!read_escaped_char(yyscanner, &end))\n     {\n-      yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+      yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n       yyterminate();\n     }\n   }\n@@ -410,7 +410,7 @@ hex_digit     [0-9a-fA-F]\n   }\n   else\n   {\n-    yyerror(yyscanner, lex_env, \"unexpected end of buffer\");\n+    yyerror(yyscanner, lex_env, \"illegal escape sequence\");\n     yyterminate();\n   }\n }\n@@ -524,19 +524,19 @@ int read_escaped_char(\n   text[0] = '\\\\';\n   text[1] = RE_YY_INPUT(yyscanner);\n \n-  if (text[1] == EOF)\n+  if (text[1] == EOF || text[1] == 0)\n     return 0;\n \n   if (text[1] == 'x')\n   {\n     text[2] = RE_YY_INPUT(yyscanner);\n \n-    if (text[2] == EOF)\n+    if (!isxdigit(text[2]))\n       return 0;\n \n     text[3] = RE_YY_INPUT(yyscanner);\n \n-    if (text[3] == EOF)\n+    if (!isxdigit(text[3]))\n       return 0;\n   }\n \ndiff --git a\/tests\/test-rules.c b\/tests\/test-rules.c\nindex 5570dbc4..556e3452 100644\n--- a\/tests\/test-rules.c\n+++ b\/tests\/test-rules.c\n@@ -1019,6 +1019,12 @@ void test_re()\n \n   \/\/ Test case for issue #324\n   assert_true_regexp(\"whatever|   x.   x\", \"   xy   x\", \"   xy   x\");\n+\n+  \/\/ test case for issue #503, \\x without two following hex-digits\n+  assert_regexp_syntax_error(\"\\\\x0\");\n+  assert_regexp_syntax_error(\"\\\\x\");\n+\n+  assert_regexp_syntax_error(\"\\\\xxy\");\n }\n \n \n","owner":"VirusTotal","repo":"yara","source":"cve"},{"CVE_ID":"CVE-2017-17439","CWE_ID":"476","category":"security","commit_id":"1a6a6e462dc2ac6111f9e02c6852ddec4849b887","commit_message":"From 1a6a6e462dc2ac6111f9e02c6852ddec4849b887 Mon Sep 17 00:00:00 2001\nFrom: Viktor Dukhovni <viktor@twosigma.com>\nDate: Tue, 5 Dec 2017 18:49:50 -0500\nSubject: [PATCH] Security: Avoid NULL structure pointer member dereference\n\nThis can happen in the error path when processing malformed AS\nrequests with a NULL client name.  Bug originally introduced on\nFri Feb 13 09:26:01 2015 +0100 in commit:\n\n    a873e21d7c06f22943a90a41dc733ae76799390d\n\n    kdc: base _kdc_fast_mk_error() on krb5_mk_error_ext()\n\nOriginal patch by Jeffrey Altman <jaltman@secure-endpoints.com>\n---\n kdc\/kerberos5.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/kdc\/kerberos5.c b\/kdc\/kerberos5.c\nindex 98989bd644..1582fee751 100644\n--- a\/kdc\/kerberos5.c\n+++ b\/kdc\/kerberos5.c\n@@ -2232,15 +2232,17 @@ _kdc_as_rep(kdc_request_t r,\n     \/*\n      * In case of a non proxy error, build an error message.\n      *\/\n-    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n+    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n \tret = _kdc_fast_mk_error(context, r,\n \t\t\t\t &error_method,\n \t\t\t\t r->armor_crypto,\n \t\t\t\t &req->req_body,\n \t\t\t\t ret, r->e_text,\n \t\t\t\t r->server_princ,\n-\t\t\t\t &r->client_princ->name,\n-\t\t\t\t &r->client_princ->realm,\n+\t\t\t\t r->client_princ ?\n+                                     &r->client_princ->name : NULL,\n+\t\t\t\t r->client_princ ?\n+                                     &r->client_princ->realm : NULL,\n \t\t\t\t NULL, NULL,\n \t\t\t\t reply);\n \tif (ret)\n","owner":"heimdal","repo":"heimdal","source":"cve"},{"CVE_ID":"CVE-2016-8675","CWE_ID":"476","category":"security","commit_id":"e5b019725f53b79159931d3a7317107cbbfd0860","commit_message":"From e5b019725f53b79159931d3a7317107cbbfd0860 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sun, 7 Sep 2014 16:39:39 +0200\nSubject: [PATCH] m4vdec: Check for non-startcode 00 00 00 sequences in probe\n\nThis makes the m4v detection less trigger-happy.\n\nBug-Id: 949\nSigned-off-by: Diego Biurrun <diego@biurrun.de>\n---\n libavformat\/m4vdec.c | 8 +++++---\n 1 file changed, 5 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libavformat\/m4vdec.c b\/libavformat\/m4vdec.c\nindex 4a0af3c037..9d69dcc042 100644\n--- a\/libavformat\/m4vdec.c\n+++ b\/libavformat\/m4vdec.c\n@@ -33,16 +33,18 @@ static int mpeg4video_probe(AVProbeData *probe_packet)\n \n     for (i = 0; i < probe_packet->buf_size; i++) {\n         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n-        if ((temp_buffer & 0xffffff00) != 0x100)\n+        if (temp_buffer & 0xfffffe00)\n+            continue;\n+        if (temp_buffer < 2)\n             continue;\n \n         if (temp_buffer == VOP_START_CODE)\n             VOP++;\n         else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n             VISO++;\n-        else if (temp_buffer < 0x120)\n+        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)\n             VO++;\n-        else if (temp_buffer < 0x130)\n+        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)\n             VOL++;\n         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n","owner":"libav","repo":"libav","source":"cve"},{"CVE_ID":"CVE-2016-7052","CWE_ID":"476","category":"security","commit_id":"6e629b5be45face20b4ca71c4fcbfed78b864a2e","commit_message":"From 6e629b5be45face20b4ca71c4fcbfed78b864a2e Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Tue, 23 Aug 2016 00:01:57 +0100\nSubject: [PATCH] Add some sanity checks when checking CRL scores\n\nNote: this was accidentally omitted from OpenSSL 1.0.2 branch.\nWithout this fix any attempt to use CRLs will crash.\n\nCVE-2016-7052\n\nThanks to Bruce Stephens and Thomas Jakobi for reporting this issue.\n\nReviewed-by: Stephen Henson <steve@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n---\n crypto\/x509\/x509_vfy.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/x509\/x509_vfy.c b\/crypto\/x509\/x509_vfy.c\nindex 8334b3fcff..b1472018ba 100644\n--- a\/crypto\/x509\/x509_vfy.c\n+++ b\/crypto\/x509\/x509_vfy.c\n@@ -1124,10 +1124,10 @@ static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,\n         crl = sk_X509_CRL_value(crls, i);\n         reasons = *preasons;\n         crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);\n-        if (crl_score < best_score)\n+        if (crl_score < best_score || crl_score == 0)\n             continue;\n         \/* If current CRL is equivalent use it if it is newer *\/\n-        if (crl_score == best_score) {\n+        if (crl_score == best_score && best_crl != NULL) {\n             int day, sec;\n             if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),\n                                X509_CRL_get_lastUpdate(crl)) == 0)\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10189","CWE_ID":"476","category":"security","commit_id":"701ab8129ba9ea64f569daedca9a8603abad740f","commit_message":"From 701ab8129ba9ea64f569daedca9a8603abad740f Mon Sep 17 00:00:00 2001\nFrom: dequis <dx@dxzone.com.ar>\nDate: Sun, 13 Nov 2016 16:52:43 -0300\nSubject: [PATCH] imcb_file_send_start: handle ft attempts from non-existing\n users\n\n---\n protocols\/bee_ft.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/protocols\/bee_ft.c b\/protocols\/bee_ft.c\nindex 27fd4eac..916b2e88 100644\n--- a\/protocols\/bee_ft.c\n+++ b\/protocols\/bee_ft.c\n@@ -30,7 +30,7 @@ file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, ch\n \tbee_t *bee = ic->bee;\n \tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n \n-\tif (bee->ui->ft_in_start) {\n+\tif (bee->ui->ft_in_start && bu) {\n \t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n \t} else {\n \t\treturn NULL;\n","owner":"bitlbee","repo":"bitlbee","source":"cve"},{"CVE_ID":"CVE-2018-15862","CWE_ID":"476","category":"security","commit_id":"4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371","commit_message":"From 4e2ee9c3f6050d773f8bbe05bc0edb17f1ff8371 Mon Sep 17 00:00:00 2001\nFrom: Daniel Stone <daniels@collabora.com>\nDate: Mon, 26 Jun 2017 17:18:16 +0100\nSubject: [PATCH] xkbcomp: Don't explode on invalid virtual modifiers\n\ntestcase: 'virtualModifiers=LevelThreC'\n\nSigned-off-by: Daniel Stone <daniels@collabora.com>\n---\n src\/xkbcomp\/expr.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/src\/xkbcomp\/expr.c b\/src\/xkbcomp\/expr.c\nindex 5d43cba..91713da 100644\n--- a\/src\/xkbcomp\/expr.c\n+++ b\/src\/xkbcomp\/expr.c\n@@ -101,6 +101,8 @@ LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n         return false;\n \n     str = xkb_atom_text(ctx, field);\n+    if (!str)\n+        return false;\n \n     if (istreq(str, \"all\")) {\n         *val_rtrn  = MOD_REAL_MASK_ALL;\n","owner":"xkbcommon","repo":"libxkbcommon","source":"cve"},{"CVE_ID":"CVE-2018-15505","CWE_ID":"476","category":"security","commit_id":"16e6979c82297d5fc4f8661e7ada975f51e4dfa9","commit_message":"From 16e6979c82297d5fc4f8661e7ada975f51e4dfa9 Mon Sep 17 00:00:00 2001\nFrom: Michael O'Brien <mob@emobrien.com>\nDate: Tue, 6 Feb 2018 12:36:36 +1100\nSubject: [PATCH] FIX: null deref with invalid IPv6 socket addresses.\n\n---\n src\/mpr\/mprLib.c | 9 +++++----\n 1 file changed, 5 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/src\/mpr\/mprLib.c b\/src\/mpr\/mprLib.c\nindex 26c01349e..8f11569e7 100644\n--- a\/src\/mpr\/mprLib.c\n+++ b\/src\/mpr\/mprLib.c\n@@ -23298,8 +23298,9 @@ PUBLIC int mprParseSocketAddress(cchar *address, char **pip, int *pport, int *ps\n \n                 \/* Set ipAddr to ipv6 address without brackets *\/\n                 ip = sclone(ip + 1);\n-                cp = strchr(ip, ']');\n-                *cp = '\\0';\n+                if ((cp = strchr(ip, ']')) != 0) {\n+                    *cp = '\\0';\n+                }\n \n             } else {\n                 \/* Handles [a:b:c:d:e:f:g:h:i] case (no port)- should not occur *\/\n@@ -27668,8 +27669,8 @@ static void validateTime(struct tm *tp, struct tm *defaults)\n     }\n     if (tp->tm_yday < 0) {\n         if (tp->tm_mon <= 11) {\n-        tp->tm_yday = (leapYear(tp->tm_year + 1900) ?\n-            leapMonthStart[tp->tm_mon] : normalMonthStart[tp->tm_mon]) + tp->tm_mday - 1;\n+            tp->tm_yday = (leapYear(tp->tm_year + 1900) ?\n+                leapMonthStart[tp->tm_mon] : normalMonthStart[tp->tm_mon]) + tp->tm_mday - 1;\n         } else {\n             tp->tm_yday = defaults->tm_yday;\n         }\n","owner":"embedthis","repo":"appweb","source":"cve"},{"CVE_ID":"CVE-2017-18079","CWE_ID":"476","category":"security","commit_id":"340d394a789518018f834ff70f7534fc463d3226","commit_message":"From 340d394a789518018f834ff70f7534fc463d3226 Mon Sep 17 00:00:00 2001\nFrom: Chen Hong <chenhong3@huawei.com>\nDate: Sun, 2 Jul 2017 15:11:10 -0700\nSubject: Input: i8042 - fix crash at boot time\n\nThe driver checks port->exists twice in i8042_interrupt(), first when\ntrying to assign temporary \"serio\" variable, and second time when deciding\nwhether it should call serio_interrupt(). The value of port->exists may\nchange between the 2 checks, and we may end up calling serio_interrupt()\nwith a NULL pointer:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000050\nIP: [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f\/0x40\nPGD 0\nOops: 0002 [#1] SMP\nlast sysfs file:\nCPU 0\nModules linked in:\n\nPid: 1, comm: swapper Not tainted 2.6.32-358.el6.x86_64 #1 QEMU Standard PC (i440FX + PIIX, 1996)\nRIP: 0010:[<ffffffff8150feaf>]  [<ffffffff8150feaf>] _spin_lock_irqsave+0x1f\/0x40\nRSP: 0018:ffff880028203cc0  EFLAGS: 00010082\nRAX: 0000000000010000 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000282 RSI: 0000000000000098 RDI: 0000000000000050\nRBP: ffff880028203cc0 R08: ffff88013e79c000 R09: ffff880028203ee0\nR10: 0000000000000298 R11: 0000000000000282 R12: 0000000000000050\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000098\nFS:  0000000000000000(0000) GS:ffff880028200000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0018 ES: 0018 CR0: 000000008005003b\nCR2: 0000000000000050 CR3: 0000000001a85000 CR4: 00000000001407f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess swapper (pid: 1, threadinfo ffff88013e79c000, task ffff88013e79b500)\nStack:\nffff880028203d00 ffffffff813de186 ffffffffffffff02 0000000000000000\n<d> 0000000000000000 0000000000000000 0000000000000000 0000000000000098\n<d> ffff880028203d70 ffffffff813e0162 ffff880028203d20 ffffffff8103b8ac\nCall Trace:\n<IRQ>\n [<ffffffff813de186>] serio_interrupt+0x36\/0xa0\n[<ffffffff813e0162>] i8042_interrupt+0x132\/0x3a0\n[<ffffffff8103b8ac>] ? kvm_clock_read+0x1c\/0x20\n[<ffffffff8103b8b9>] ? kvm_clock_get_cycles+0x9\/0x10\n[<ffffffff810e1640>] handle_IRQ_event+0x60\/0x170\n[<ffffffff8103b154>] ? kvm_guest_apic_eoi_write+0x44\/0x50\n[<ffffffff810e3d8e>] handle_edge_irq+0xde\/0x180\n[<ffffffff8100de89>] handle_irq+0x49\/0xa0\n[<ffffffff81516c8c>] do_IRQ+0x6c\/0xf0\n[<ffffffff8100b9d3>] ret_from_intr+0x0\/0x11\n[<ffffffff81076f63>] ? __do_softirq+0x73\/0x1e0\n[<ffffffff8109b75b>] ? hrtimer_interrupt+0x14b\/0x260\n[<ffffffff8100c1cc>] ? call_softirq+0x1c\/0x30\n[<ffffffff8100de05>] ? do_softirq+0x65\/0xa0\n[<ffffffff81076d95>] ? irq_exit+0x85\/0x90\n[<ffffffff81516d80>] ? smp_apic_timer_interrupt+0x70\/0x9b\n[<ffffffff8100bb93>] ? apic_timer_interrupt+0x13\/0x20\n\nTo avoid the issue let's change the second check to test whether serio is\nNULL or not.\n\nAlso, let's take i8042_lock in i8042_start() and i8042_stop() instead of\ntrying to be overly smart and using memory barriers.\n\nSigned-off-by: Chen Hong <chenhong3@huawei.com>\n[dtor: take lock in i8042_start()\/i8042_stop()]\nCc: stable@vger.kernel.org\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>\n---\n drivers\/input\/serio\/i8042.c | 12 +++++++++---\n 1 file changed, 9 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/input\/serio\/i8042.c b\/drivers\/input\/serio\/i8042.c\nindex c52da651269b..824f4c1c1f31 100644\n--- a\/drivers\/input\/serio\/i8042.c\n+++ b\/drivers\/input\/serio\/i8042.c\n@@ -436,8 +436,10 @@ static int i8042_start(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n+\tspin_lock_irq(&i8042_lock);\n \tport->exists = true;\n-\tmb();\n+\tspin_unlock_irq(&i8042_lock);\n+\n \treturn 0;\n }\n \n@@ -450,16 +452,20 @@ static void i8042_stop(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n+\tspin_lock_irq(&i8042_lock);\n \tport->exists = false;\n+\tport->serio = NULL;\n+\tspin_unlock_irq(&i8042_lock);\n \n \t\/*\n+\t * We need to make sure that interrupt handler finishes using\n+\t * our serio port before we return from this function.\n \t * We synchronize with both AUX and KBD IRQs because there is\n \t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n \t * and vice versa.\n \t *\/\n \tsynchronize_irq(I8042_AUX_IRQ);\n \tsynchronize_irq(I8042_KBD_IRQ);\n-\tport->serio = NULL;\n }\n \n \/*\n@@ -576,7 +582,7 @@ static irqreturn_t i8042_interrupt(int irq, void *dev_id)\n \n \tspin_unlock_irqrestore(&i8042_lock, flags);\n \n-\tif (likely(port->exists && !filtered))\n+\tif (likely(serio && !filtered))\n \t\tserio_interrupt(serio, data, dfl);\n \n  out:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-5333","CWE_ID":"476","category":"security","commit_id":"7d11f77f84b27cef452cee332f4e469503084737","commit_message":"From 7d11f77f84b27cef452cee332f4e469503084737 Mon Sep 17 00:00:00 2001\nFrom: Mohamed Ghannam <simo.ghannam@gmail.com>\nDate: Wed, 3 Jan 2018 21:06:06 +0000\nSubject: [PATCH] RDS: null pointer dereference in rds_atomic_free_op\n\nset rm->atomic.op_active to 0 when rds_pin_pages() fails\nor the user supplied address is invalid,\nthis prevents a NULL pointer usage in rds_atomic_free_op()\n\nSigned-off-by: Mohamed Ghannam <simo.ghannam@gmail.com>\nAcked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/rds\/rdma.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/net\/rds\/rdma.c b\/net\/rds\/rdma.c\nindex 94729d9da4372..634cfcb7bba68 100644\n--- a\/net\/rds\/rdma.c\n+++ b\/net\/rds\/rdma.c\n@@ -877,6 +877,7 @@ int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,\n err:\n \tif (page)\n \t\tput_page(page);\n+\trm->atomic.op_active = 0;\n \tkfree(rm->atomic.op_notifier);\n \n \treturn ret;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-8884","CWE_ID":"476","category":"security","commit_id":"5d66894d2313e3f3469f19066e149e08ff076698","commit_message":"From 5d66894d2313e3f3469f19066e149e08ff076698 Mon Sep 17 00:00:00 2001\nFrom: Michael Adams <mdadams@ece.uvic.ca>\nDate: Wed, 19 Oct 2016 20:13:06 -0700\nSubject: [PATCH] Fixed a problem with a null pointer dereference in the BMP\n decoder.\n\n---\n src\/libjasper\/base\/jas_seq.c |  4 +++\n src\/libjasper\/bmp\/bmp_dec.c  | 62 ++++++++++++++++++++++++++----------\n 2 files changed, 49 insertions(+), 17 deletions(-)\n\n","diff_code":"diff --git a\/src\/libjasper\/base\/jas_seq.c b\/src\/libjasper\/base\/jas_seq.c\nindex a76bbde..cac20e2 100644\n--- a\/src\/libjasper\/base\/jas_seq.c\n+++ b\/src\/libjasper\/base\/jas_seq.c\n@@ -102,6 +102,10 @@ jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n \tjas_matrix_t *matrix;\n \tint i;\n \n+\tif (numrows < 0 || numcols < 0) {\n+\t\treturn 0;\n+\t}\n+\n \tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n \t\treturn 0;\n \t}\ndiff --git a\/src\/libjasper\/bmp\/bmp_dec.c b\/src\/libjasper\/bmp\/bmp_dec.c\nindex 6e7d880..d5a903f 100644\n--- a\/src\/libjasper\/bmp\/bmp_dec.c\n+++ b\/src\/libjasper\/bmp\/bmp_dec.c\n@@ -107,6 +107,9 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \tuint_fast16_t numcmpts;\n \tlong n;\n \n+\timage = 0;\n+\tinfo = 0;\n+\n \tif (optstr) {\n \t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n \t}\n@@ -121,7 +124,8 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t\/* Read the bitmap header. *\/\n \tif (bmp_gethdr(in, &hdr)) {\n \t\tjas_eprintf(\"cannot get header\\n\");\n-\t\treturn 0;\n+\t\tgoto error;\n+\t\t\/\/return 0;\n \t}\n \tJAS_DBGLOG(1, (\n \t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n@@ -131,33 +135,46 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t\/* Read the bitmap information. *\/\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\"cannot get info\\n\");\n-\t\treturn 0;\n+\t\t\/\/return 0;\n+\t\tgoto error;\n \t}\n \tJAS_DBGLOG(1,\n-\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n-\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n-\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n-\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n-\t  info->numcolors, info->mincolors));\n+\t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"\n+\t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"\n+\t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),\n+\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n+\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n+\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n+\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n+\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n+\n+\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n+\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n+\t\tjas_eprintf(\"corrupt bit stream\\n\");\n+\t\tgoto error;\n+\t}\n \n \t\/* Ensure that we support this type of BMP file. *\/\n \tif (!bmp_issupported(&hdr, info)) {\n \t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n-\t\tbmp_info_destroy(info);\n-\t\treturn 0;\n+\t\t\/\/bmp_info_destroy(info);\n+\t\t\/\/return 0;\n+\t\tgoto error;\n \t}\n \n \t\/* Skip over any useless data between the end of the palette\n \t  and start of the bitmap data. *\/\n \tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n \t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n-\t\treturn 0;\n+\t\tgoto error;\n+\t\t\/\/return 0;\n \t}\n \tif (n > 0) {\n \t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n \t\tif (bmp_gobble(in, n)) {\n-\t\t\tbmp_info_destroy(info);\n-\t\t\treturn 0;\n+\t\t\t\/\/bmp_info_destroy(info);\n+\t\t\t\/\/return 0;\n+\t\t\tgoto error;\n \t\t}\n \t}\n \n@@ -179,8 +196,9 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t\/* Create image object. *\/\n \tif (!(image = jas_image_create(numcmpts, cmptparms,\n \t  JAS_CLRSPC_UNKNOWN))) {\n-\t\tbmp_info_destroy(info);\n-\t\treturn 0;\n+\t\t\/\/bmp_info_destroy(info);\n+\t\t\/\/return 0;\n+\t\tgoto error;\n \t}\n \n \tif (numcmpts == 3) {\n@@ -199,14 +217,24 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \n \t\/* Read the bitmap data. *\/\n \tif (bmp_getdata(in, info, image)) {\n-\t\tbmp_info_destroy(info);\n-\t\tjas_image_destroy(image);\n-\t\treturn 0;\n+\t\t\/\/bmp_info_destroy(info);\n+\t\t\/\/jas_image_destroy(image);\n+\t\t\/\/return 0;\n+\t\tgoto error;\n \t}\n \n \tbmp_info_destroy(info);\n \n \treturn image;\n+\n+error:\n+\tif (info) {\n+\t\tbmp_info_destroy(info);\n+\t}\n+\tif (image) {\n+\t\tjas_image_destroy(image);\n+\t}\n+\treturn 0;\n }\n \n int bmp_validate(jas_stream_t *in)\n","owner":"mdadams","repo":"jasper","source":"cve"},{"CVE_ID":"CVE-2016-8646","CWE_ID":"476","category":"security","commit_id":"4afa5f9617927453ac04b24b584f6c718dfb4f45","commit_message":"From 4afa5f9617927453ac04b24b584f6c718dfb4f45 Mon Sep 17 00:00:00 2001\nFrom: Herbert Xu <herbert@gondor.apana.org.au>\nDate: Sun, 1 Nov 2015 17:11:19 +0800\nSubject: [PATCH] crypto: algif_hash - Only export and import on sockets with\n data\n\nThe hash_accept call fails to work on sockets that have not received\nany data.  For some algorithm implementations it may cause crashes.\n\nThis patch fixes this by ensuring that we only export and import on\nsockets that have received data.\n\nCc: stable@vger.kernel.org\nReported-by: Harsh Jain <harshjain.prof@gmail.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nTested-by: Stephan Mueller <smueller@chronox.de>\n---\n crypto\/algif_hash.c | 12 ++++++++++--\n 1 file changed, 10 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/algif_hash.c b\/crypto\/algif_hash.c\nindex 1396ad0787fc6..b4c24fe3dcfb5 100644\n--- a\/crypto\/algif_hash.c\n+++ b\/crypto\/algif_hash.c\n@@ -181,9 +181,14 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n \tstruct sock *sk2;\n \tstruct alg_sock *ask2;\n \tstruct hash_ctx *ctx2;\n+\tbool more;\n \tint err;\n \n-\terr = crypto_ahash_export(req, state);\n+\tlock_sock(sk);\n+\tmore = ctx->more;\n+\terr = more ? crypto_ahash_export(req, state) : 0;\n+\trelease_sock(sk);\n+\n \tif (err)\n \t\treturn err;\n \n@@ -194,7 +199,10 @@ static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n \tsk2 = newsock->sk;\n \task2 = alg_sk(sk2);\n \tctx2 = ask2->private;\n-\tctx2->more = 1;\n+\tctx2->more = more;\n+\n+\tif (!more)\n+\t\treturn err;\n \n \terr = crypto_ahash_import(&ctx2->req, state);\n \tif (err) {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-7492","CWE_ID":"476","category":"security","commit_id":"f3069c6d33f6ae63a1668737bc78aaaa51bff7ca","commit_message":"From f3069c6d33f6ae63a1668737bc78aaaa51bff7ca Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?H=C3=A5kon=20Bugge?= <Haakon.Bugge@oracle.com>\nDate: Wed, 6 Dec 2017 17:18:28 +0100\nSubject: rds: Fix NULL pointer dereference in __rds_rdma_map\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThis is a fix for syzkaller719569, where memory registration was\nattempted without any underlying transport being loaded.\n\nAnalysis of the case reveals that it is the setsockopt() RDS_GET_MR\n(2) and RDS_GET_MR_FOR_DEST (7) that are vulnerable.\n\nHere is an example stack trace when the bug is hit:\n\nBUG: unable to handle kernel NULL pointer dereference at 00000000000000c0\nIP: __rds_rdma_map+0x36\/0x440 [rds]\nPGD 2f93d03067 P4D 2f93d03067 PUD 2f93d02067 PMD 0\nOops: 0000 [#1] SMP\nModules linked in: bridge stp llc tun rpcsec_gss_krb5 nfsv4\ndns_resolver nfs fscache rds binfmt_misc sb_edac intel_powerclamp\ncoretemp kvm_intel kvm irqbypass crct10dif_pclmul c rc32_pclmul\nghash_clmulni_intel pcbc aesni_intel crypto_simd glue_helper cryptd\niTCO_wdt mei_me sg iTCO_vendor_support ipmi_si mei ipmi_devintf nfsd\nshpchp pcspkr i2c_i801 ioatd ma ipmi_msghandler wmi lpc_ich mfd_core\nauth_rpcgss nfs_acl lockd grace sunrpc ip_tables ext4 mbcache jbd2\nmgag200 i2c_algo_bit drm_kms_helper ixgbe syscopyarea ahci sysfillrect\nsysimgblt libahci mdio fb_sys_fops ttm ptp libata sd_mod mlx4_core drm\ncrc32c_intel pps_core megaraid_sas i2c_core dca dm_mirror\ndm_region_hash dm_log dm_mod\nCPU: 48 PID: 45787 Comm: repro_set2 Not tainted 4.14.2-3.el7uek.x86_64 #2\nHardware name: Oracle Corporation ORACLE SERVER X5-2L\/ASM,MOBO TRAY,2U, BIOS 31110000 03\/03\/2017\ntask: ffff882f9190db00 task.stack: ffffc9002b994000\nRIP: 0010:__rds_rdma_map+0x36\/0x440 [rds]\nRSP: 0018:ffffc9002b997df0 EFLAGS: 00010202\nRAX: 0000000000000000 RBX: ffff882fa2182580 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: ffffc9002b997e40 RDI: ffff882fa2182580\nRBP: ffffc9002b997e30 R08: 0000000000000000 R09: 0000000000000002\nR10: ffff885fb29e3838 R11: 0000000000000000 R12: ffff882fa2182580\nR13: ffff882fa2182580 R14: 0000000000000002 R15: 0000000020000ffc\nFS:  00007fbffa20b700(0000) GS:ffff882fbfb80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000000000c0 CR3: 0000002f98a66006 CR4: 00000000001606e0\nCall Trace:\n rds_get_mr+0x56\/0x80 [rds]\n rds_setsockopt+0x172\/0x340 [rds]\n ? __fget_light+0x25\/0x60\n ? __fdget+0x13\/0x20\n SyS_setsockopt+0x80\/0xe0\n do_syscall_64+0x67\/0x1b0\n entry_SYSCALL64_slow_path+0x25\/0x25\nRIP: 0033:0x7fbff9b117f9\nRSP: 002b:00007fbffa20aed8 EFLAGS: 00000293 ORIG_RAX: 0000000000000036\nRAX: ffffffffffffffda RBX: 00000000000c84a4 RCX: 00007fbff9b117f9\nRDX: 0000000000000002 RSI: 0000400000000114 RDI: 000000000000109b\nRBP: 00007fbffa20af10 R08: 0000000000000020 R09: 00007fbff9dd7860\nR10: 0000000020000ffc R11: 0000000000000293 R12: 0000000000000000\nR13: 00007fbffa20b9c0 R14: 00007fbffa20b700 R15: 0000000000000021\n\nCode: 41 56 41 55 49 89 fd 41 54 53 48 83 ec 18 8b 87 f0 02 00 00 48\n89 55 d0 48 89 4d c8 85 c0 0f 84 2d 03 00 00 48 8b 87 00 03 00 00 <48>\n83 b8 c0 00 00 00 00 0f 84 25 03 00 0 0 48 8b 06 48 8b 56 08\n\nThe fix is to check the existence of an underlying transport in\n__rds_rdma_map().\n\nSigned-off-by: H\u00e5kon Bugge <haakon.bugge@oracle.com>\nReported-by: syzbot <syzkaller@googlegroups.com>\nAcked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/rds\/rdma.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/rds\/rdma.c b\/net\/rds\/rdma.c\nindex 8886f15abe90..bc2f1e0977d6 100644\n--- a\/net\/rds\/rdma.c\n+++ b\/net\/rds\/rdma.c\n@@ -183,7 +183,7 @@ static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,\n \tlong i;\n \tint ret;\n \n-\tif (rs->rs_bound_addr == 0) {\n+\tif (rs->rs_bound_addr == 0 || !rs->rs_transport) {\n \t\tret = -ENOTCONN; \/* XXX not a great errno *\/\n \t\tgoto out;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-6327","CWE_ID":"476","category":"security","commit_id":"51093254bf879bc9ce96590400a87897c7498463","commit_message":"From 51093254bf879bc9ce96590400a87897c7498463 Mon Sep 17 00:00:00 2001\nFrom: Bart Van Assche <bart.vanassche@sandisk.com>\nDate: Thu, 11 Feb 2016 11:03:09 -0800\nSubject: IB\/srpt: Simplify srpt_handle_tsk_mgmt()\n\nLet the target core check task existence instead of the SRP target\ndriver. Additionally, let the target core check the validity of the\ntask management request instead of the ib_srpt driver.\n\nThis patch fixes the following kernel crash:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000001\nIP: [<ffffffffa0565f37>] srpt_handle_new_iu+0x6d7\/0x790 [ib_srpt]\nOops: 0002 [#1] SMP\nCall Trace:\n [<ffffffffa05660ce>] srpt_process_completion+0xde\/0x570 [ib_srpt]\n [<ffffffffa056669f>] srpt_compl_thread+0x13f\/0x160 [ib_srpt]\n [<ffffffff8109726f>] kthread+0xcf\/0xe0\n [<ffffffff81613cfc>] ret_from_fork+0x7c\/0xb0\n\nSigned-off-by: Bart Van Assche <bart.vanassche@sandisk.com>\nFixes: 3e4f574857ee (\"ib_srpt: Convert TMR path to target_submit_tmr\")\nTested-by: Alex Estrin <alex.estrin@intel.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nCc: Nicholas Bellinger <nab@linux-iscsi.org>\nCc: Sagi Grimberg <sagig@mellanox.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Doug Ledford <dledford@redhat.com>\n---\n drivers\/infiniband\/ulp\/srpt\/ib_srpt.c | 59 +----------------------------------\n 1 file changed, 1 insertion(+), 58 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/infiniband\/ulp\/srpt\/ib_srpt.c b\/drivers\/infiniband\/ulp\/srpt\/ib_srpt.c\nindex 0c37fee363b1..4328679a67a7 100644\n--- a\/drivers\/infiniband\/ulp\/srpt\/ib_srpt.c\n+++ b\/drivers\/infiniband\/ulp\/srpt\/ib_srpt.c\n@@ -1670,47 +1670,6 @@ send_sense:\n \treturn -1;\n }\n \n-\/**\n- * srpt_rx_mgmt_fn_tag() - Process a task management function by tag.\n- * @ch: RDMA channel of the task management request.\n- * @fn: Task management function to perform.\n- * @req_tag: Tag of the SRP task management request.\n- * @mgmt_ioctx: I\/O context of the task management request.\n- *\n- * Returns zero if the target core will process the task management\n- * request asynchronously.\n- *\n- * Note: It is assumed that the initiator serializes tag-based task management\n- * requests.\n- *\/\n-static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n-{\n-\tstruct srpt_device *sdev;\n-\tstruct srpt_rdma_ch *ch;\n-\tstruct srpt_send_ioctx *target;\n-\tint ret, i;\n-\n-\tret = -EINVAL;\n-\tch = ioctx->ch;\n-\tBUG_ON(!ch);\n-\tBUG_ON(!ch->sport);\n-\tsdev = ch->sport->sdev;\n-\tBUG_ON(!sdev);\n-\tspin_lock_irq(&sdev->spinlock);\n-\tfor (i = 0; i < ch->rq_size; ++i) {\n-\t\ttarget = ch->ioctx_ring[i];\n-\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n-\t\t    target->cmd.tag == tag &&\n-\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n-\t\t\tret = 0;\n-\t\t\t\/* now let the target core abort &target->cmd; *\/\n-\t\t\tbreak;\n-\t\t}\n-\t}\n-\tspin_unlock_irq(&sdev->spinlock);\n-\treturn ret;\n-}\n-\n static int srp_tmr_to_tcm(int fn)\n {\n \tswitch (fn) {\n@@ -1745,7 +1704,6 @@ static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n \tstruct se_cmd *cmd;\n \tstruct se_session *sess = ch->sess;\n \tuint64_t unpacked_lun;\n-\tuint32_t tag = 0;\n \tint tcm_tmr;\n \tint rc;\n \n@@ -1761,25 +1719,10 @@ static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n \tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n \tsend_ioctx->cmd.tag = srp_tsk->tag;\n \ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n-\tif (tcm_tmr < 0) {\n-\t\tsend_ioctx->cmd.se_tmr_req->response =\n-\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n-\t\tgoto fail;\n-\t}\n \tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n \t\t\t\t       sizeof(srp_tsk->lun));\n-\n-\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n-\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n-\t\tif (rc < 0) {\n-\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n-\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n-\t\t\tgoto fail;\n-\t\t}\n-\t\ttag = srp_tsk->task_tag;\n-\t}\n \trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n-\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n+\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk->task_tag,\n \t\t\t\tTARGET_SCF_ACK_KREF);\n \tif (rc != 0) {\n \t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-10708","CWE_ID":"476","category":"security","commit_id":"28652bca29046f62c7045e933e6b931de1d16737","commit_message":"From 28652bca29046f62c7045e933e6b931de1d16737 Mon Sep 17 00:00:00 2001\nFrom: \"markus@openbsd.org\" <markus@openbsd.org>\nDate: Mon, 19 Sep 2016 19:02:19 +0000\nSubject: upstream commit\n\nmove inbound NEWKEYS handling to kex layer; otherwise\nearly NEWKEYS causes NULL deref; found by Robert Swiecki\/honggfuzz; fixed\nwith & ok djm@\n\nUpstream-ID: 9a68b882892e9f51dc7bfa9f5a423858af358b2f\n---\n kex.c    | 4 +++-\n packet.c | 6 ++----\n 2 files changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/kex.c b\/kex.c\nindex f4c130f1..8800d400 100644\n--- a\/kex.c\n+++ b\/kex.c\n@@ -1,4 +1,4 @@\n-\/* $OpenBSD: kex.c,v 1.121 2016\/09\/12 23:31:27 djm Exp $ *\/\n+\/* $OpenBSD: kex.c,v 1.122 2016\/09\/19 19:02:19 markus Exp $ *\/\n \/*\n  * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n  *\n@@ -425,6 +425,8 @@ kex_input_newkeys(int type, u_int32_t seq, void *ctxt)\n \tssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);\n \tif ((r = sshpkt_get_end(ssh)) != 0)\n \t\treturn r;\n+\tif ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)\n+\t\treturn r;\n \tkex->done = 1;\n \tsshbuf_reset(kex->peer);\n \t\/* sshbuf_reset(kex->my); *\/\ndiff --git a\/packet.c b\/packet.c\nindex 711091da..fb316acb 100644\n--- a\/packet.c\n+++ b\/packet.c\n@@ -1,4 +1,4 @@\n-\/* $OpenBSD: packet.c,v 1.237 2016\/09\/12 01:22:38 deraadt Exp $ *\/\n+\/* $OpenBSD: packet.c,v 1.238 2016\/09\/19 19:02:19 markus Exp $ *\/\n \/*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -1907,9 +1907,7 @@ ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)\n \t\t\treturn r;\n \t\treturn SSH_ERR_PROTOCOL_ERROR;\n \t}\n-\tif (*typep == SSH2_MSG_NEWKEYS)\n-\t\tr = ssh_set_newkeys(ssh, MODE_IN);\n-\telse if (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)\n+\tif (*typep == SSH2_MSG_USERAUTH_SUCCESS && !state->server_side)\n \t\tr = ssh_packet_enable_delayed_compress(ssh);\n \telse\n \t\tr = 0;\n-- \ncgit v1.2.1\n\n","owner":"openssh","repo":"openssh-portable","source":"cve"},{"CVE_ID":"CVE-2016-9559","CWE_ID":"476","category":"security","commit_id":"b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b","commit_message":"From b61d35eaccc0a7ddeff8a1c3abfcd0a43ccf210b Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Wed, 9 Nov 2016 15:57:28 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/298\n\n---\n MagickCore\/property.c |  4 ++--\n coders\/tiff.c         | 43 ++++++++++++++++++++++++++++---------------\n coders\/txt.c          |  3 +--\n 3 files changed, 31 insertions(+), 19 deletions(-)\n\n","diff_code":"diff --git a\/MagickCore\/property.c b\/MagickCore\/property.c\nindex 2a80dc2a9a..39fcb8ce7a 100644\n--- a\/MagickCore\/property.c\n+++ b\/MagickCore\/property.c\n@@ -213,7 +213,7 @@ MagickExport MagickBooleanType CloneImageProperties(Image *image,\n %\n %  DefineImageProperty() associates an assignment string of the form\n %  \"key=value\" with an artifact or options. It is equivelent to\n-%  SetImageProperty()\n+%  SetImageProperty().\n %\n %  The format of the DefineImageProperty method is:\n %\n@@ -3962,7 +3962,7 @@ MagickExport MagickBooleanType SetImageProperty(Image *image,\n     {\n       \/*\n         Do not 'set' single letter properties - read only shorthand.\n-       *\/\n+      *\/\n       (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n         \"SetReadOnlyProperty\",\"`%s'\",property);\n       return(MagickFalse);\ndiff --git a\/coders\/tiff.c b\/coders\/tiff.c\nindex feffff2774..e108920f30 100644\n--- a\/coders\/tiff.c\n+++ b\/coders\/tiff.c\n@@ -631,42 +631,54 @@ static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n   unsigned long\n     *tietz;\n \n-\n-  if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\"tiff:artist\",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\"tiff:copyright\",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\"tiff:timestamp\",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\"tiff:document\",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\"tiff:hostcomputer\",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\"comment\",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\"tiff:make\",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\"tiff:model\",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n       (void) CopyMagickString(message,text,count+1);\n       (void) SetImageProperty(image,\"tiff:image-id\",message,exception);\n     }\n-  if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\"label\",text,exception);\n-  if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1)\n+  if ((TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) &&\n+      (text != (char *) NULL))\n     (void) SetImageProperty(image,\"tiff:software\",text,exception);\n-  if (TIFFGetField(tiff,33423,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,33423,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n       (void) CopyMagickString(message,text,count+1);\n       (void) SetImageProperty(image,\"tiff:kodak-33423\",message,exception);\n     }\n-  if (TIFFGetField(tiff,36867,&count,&text) == 1)\n+  if ((TIFFGetField(tiff,36867,&count,&text) == 1) &&\n+      (text != (char *) NULL))\n     {\n       if (count >= MagickPathExtent)\n         count=MagickPathExtent-1;\n@@ -695,7 +707,8 @@ static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception)\n       default:\n         break;\n     }\n-  if (TIFFGetField(tiff,37706,&length,&tietz) == 1)\n+  if ((TIFFGetField(tiff,37706,&length,&tietz) == 1) &&\n+      (tietz != (unsigned long *) NULL))\n     {\n       (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",tietz[0]);\n       (void) SetImageProperty(image,\"tiff:tietz_offset\",message,exception);\ndiff --git a\/coders\/txt.c b\/coders\/txt.c\nindex 74d496bead..7d0dbb2e24 100644\n--- a\/coders\/txt.c\n+++ b\/coders\/txt.c\n@@ -793,8 +793,7 @@ static MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image,\n         (void) WriteBlobString(image,buffer);\n         (void) CopyMagickString(tuple,\"(\",MagickPathExtent);\n         if (pixel.colorspace == GRAYColorspace)\n-          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,\n-            tuple);\n+          ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance,tuple);\n         else\n           {\n             ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-7131","CWE_ID":"476","category":"security","commit_id":"a14fdb9746262549bbbb96abb87338bacd147e1b","commit_message":"From a14fdb9746262549bbbb96abb87338bacd147e1b Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Wed, 10 Aug 2016 23:43:56 -0700\nSubject: [PATCH] Fix for bug #72790 and bug #72799\n\n---\n ext\/wddx\/tests\/bug72790.phpt | 35 +++++++++++++++++++++++++++++++++++\n ext\/wddx\/tests\/bug72799.phpt | 28 ++++++++++++++++++++++++++++\n ext\/wddx\/wddx.c              | 14 +++++++++-----\n 3 files changed, 72 insertions(+), 5 deletions(-)\n create mode 100644 ext\/wddx\/tests\/bug72790.phpt\n create mode 100644 ext\/wddx\/tests\/bug72799.phpt\n\n","diff_code":"diff --git a\/ext\/wddx\/tests\/bug72790.phpt b\/ext\/wddx\/tests\/bug72790.phpt\nnew file mode 100644\nindex 000000000000..a60524bdaf19\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug72790.phpt\n@@ -0,0 +1,35 @@\n+--TEST--\n+Bug 72790: wddx_deserialize null dereference with invalid xml\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<< XML\n+<?xml version='1.0' ?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+        |array>\n+                <var name=\"XXXX\">\n+                        <boolean value=\"this\">\n+                        <\/boolean>\n+                <\/var>\n+                <var name=\"YYYY\">\n+                        <var name=\"UUUU\">\n+                                <var name=\"EZEZ\">\n+                                <\/var>\n+                        <\/var>\n+                <\/var>\n+        <\/array>\n+<\/wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+NULL\n\\ No newline at end of file\ndiff --git a\/ext\/wddx\/tests\/bug72799.phpt b\/ext\/wddx\/tests\/bug72799.phpt\nnew file mode 100644\nindex 000000000000..5861d5538f49\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug72799.phpt\n@@ -0,0 +1,28 @@\n+--TEST--\n+Bug #72799: wddx_deserialize null dereference in php_wddx_pop_element\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<<XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version=\"1.0\">\n+    <var name=\"XXXX\">\n+        <boolean value=\"1\">\n+            <dateTime>1998-06-12T04:32:12+00<\/dateTime>\n+        <\/boolean>\n+    <\/var>\n+<\/wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+NULL\n\\ No newline at end of file\ndiff --git a\/ext\/wddx\/wddx.c b\/ext\/wddx\/wddx.c\nindex 1b2d103af18e..d7bd295832c7 100644\n--- a\/ext\/wddx\/wddx.c\n+++ b\/ext\/wddx\/wddx.c\n@@ -946,10 +946,10 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\tif (!ent1->data) {\n \t\t\tif (stack->top > 1) {\n \t\t\t\tstack->top--;\n+\t\t\t\tefree(ent1);\n \t\t\t} else {\n \t\t\t\tstack->done = 1;\n \t\t\t}\n-\t\t\tefree(ent1);\n \t\t\treturn;\n \t\t}\n \n@@ -988,7 +988,7 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\t\twddx_stack_top(stack, (void**)&ent2);\n \n \t\t\t\/* if non-existent field *\/\n-\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n+\t\t\tif (ent2->data == NULL) {\n \t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\tefree(ent1);\n \t\t\t\treturn;\n@@ -1179,9 +1179,13 @@ int php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n \n \tif (stack.top == 1) {\n \t\twddx_stack_top(&stack, (void**)&ent);\n-\t\t*return_value = *(ent->data);\n-\t\tzval_copy_ctor(return_value);\n-\t\tretval = SUCCESS;\n+\t\tif(ent->data == NULL) {\n+\t\t\tretval = FAILURE;\n+\t\t} else {\n+\t\t\t*return_value = *(ent->data);\n+\t\t\tzval_copy_ctor(return_value);\n+\t\t\tretval = SUCCESS;\n+\t\t}\n \t} else {\n \t\tretval = FAILURE;\n \t}\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2018-10940","CWE_ID":"476","category":"security","commit_id":"9de4ee40547fd315d4a0ed1dd15a2fa3559ad707","commit_message":"From 9de4ee40547fd315d4a0ed1dd15a2fa3559ad707 Mon Sep 17 00:00:00 2001\nFrom: Dan Carpenter <dan.carpenter@oracle.com>\nDate: Wed, 18 Apr 2018 12:51:31 +0300\nSubject: cdrom: information leak in cdrom_ioctl_media_changed()\n\nThis cast is wrong.  \"cdi->capacity\" is an int and \"arg\" is an unsigned\nlong.  The way the check is written now, if one of the high 32 bits is\nset then we could read outside the info->slots[] array.\n\nThis bug is pretty old and it predates git.\n\nReviewed-by: Christoph Hellwig <hch@lst.de>\nCc: stable@vger.kernel.org\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>\n---\n drivers\/cdrom\/cdrom.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/cdrom\/cdrom.c b\/drivers\/cdrom\/cdrom.c\nindex 8327478effd0..bfc566d3f31a 100644\n--- a\/drivers\/cdrom\/cdrom.c\n+++ b\/drivers\/cdrom\/cdrom.c\n@@ -2371,7 +2371,7 @@ static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n \tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n \t\treturn media_changed(cdi, 1);\n \n-\tif ((unsigned int)arg >= cdi->capacity)\n+\tif (arg >= cdi->capacity)\n \t\treturn -EINVAL;\n \n \tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-9250","CWE_ID":"476","category":"security","commit_id":"03a8c630f015f63268639d3ed3bf82cff6fa77d8","commit_message":"From 03a8c630f015f63268639d3ed3bf82cff6fa77d8 Mon Sep 17 00:00:00 2001\nFrom: Zoltan Herczeg <zherczeg.u-szeged@partner.samsung.com>\nDate: Mon, 22 May 2017 03:47:42 -0700\nSubject: [PATCH] Do not allocate memory for zero length strings.\n\nFixes #1821.\n\nJerryScript-DCO-1.0-Signed-off-by: Zoltan Herczeg zherczeg.u-szeged@partner.samsung.com\n---\n jerry-core\/parser\/js\/js-lexer.c           |  5 +++++\n tests\/jerry\/regression-test-issue-1833.js | 16 ++++++++++++++++\n 2 files changed, 21 insertions(+)\n create mode 100644 tests\/jerry\/regression-test-issue-1833.js\n\n","diff_code":"diff --git a\/jerry-core\/parser\/js\/js-lexer.c b\/jerry-core\/parser\/js\/js-lexer.c\nindex 71db7e624..f7bd5b952 100644\n--- a\/jerry-core\/parser\/js\/js-lexer.c\n+++ b\/jerry-core\/parser\/js\/js-lexer.c\n@@ -1197,6 +1197,11 @@ lexer_process_char_literal (parser_context_t *context_p, \/**< context *\/\n     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n   }\n \n+  if (length == 0)\n+  {\n+    has_escape = false;\n+  }\n+\n   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n   literal_p->prop.length = (uint16_t) length;\n   literal_p->type = literal_type;\ndiff --git a\/tests\/jerry\/regression-test-issue-1833.js b\/tests\/jerry\/regression-test-issue-1833.js\nnew file mode 100644\nindex 000000000..7c0860168\n--- \/dev\/null\n+++ b\/tests\/jerry\/regression-test-issue-1833.js\n@@ -0,0 +1,16 @@\n+\/\/ Copyright JS Foundation and other contributors, http:\/\/js.foundation\n+\/\/\n+\/\/ Licensed under the Apache License, Version 2.0 (the \"License\");\n+\/\/ you may not use this file except in compliance with the License.\n+\/\/ You may obtain a copy of the License at\n+\/\/\n+\/\/     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+\/\/\n+\/\/ Unless required by applicable law or agreed to in writing, software\n+\/\/ distributed under the License is distributed on an \"AS IS\" BASIS\n+\/\/ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+\/\/ See the License for the specific language governing permissions and\n+\/\/ limitations under the License.\n+\n+'\\\n+'\n","owner":"zherczeg","repo":"jerryscript","source":"cve"},{"CVE_ID":"CVE-2019-12109","CWE_ID":"476","category":"security","commit_id":"86030db849260dd8fb2ed975b9890aef1b62b692","commit_message":"From 86030db849260dd8fb2ed975b9890aef1b62b692 Mon Sep 17 00:00:00 2001\nFrom: Thomas Bernard <miniupnp@free.fr>\nDate: Tue, 18 Dec 2018 23:47:54 +0100\nSubject: [PATCH] fix error from commit\n 13585f15c7f7dc28bbbba1661efb280d530d114c\n\n---\n miniupnpd\/upnpsoap.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/miniupnpd\/upnpsoap.c b\/miniupnpd\/upnpsoap.c\nindex 997b3254..acd7fedf 100644\n--- a\/miniupnpd\/upnpsoap.c\n+++ b\/miniupnpd\/upnpsoap.c\n@@ -1850,7 +1850,7 @@ GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \n-\tif (!int_port || !ext_port || !protocol)\n+\tif (!int_port || !rem_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \"Invalid Args\");\n","owner":"miniupnp","repo":"miniupnp","source":"cve"},{"CVE_ID":"CVE-2013-4119","CWE_ID":"476","category":"security","commit_id":"0773bb9303d24473fe1185d85a424dfe159aff53","commit_message":"From 0773bb9303d24473fe1185d85a424dfe159aff53 Mon Sep 17 00:00:00 2001\nFrom: Bernhard Miklautz <bmiklautz@thinstuff.at>\nDate: Mon, 1 Jul 2013 19:24:19 +0200\nSubject: [PATCH] nla: invalidate sec handle after creation\n\nIf sec pointer isn't invalidated after creation it is not possible\nto check if the upper and lower pointers are valid.\n\nThis fixes a segfault in the server part if the client disconnects before\nthe authentication was finished.\n---\n libfreerdp\/core\/nla.c       | 1 +\n libfreerdp\/core\/peer.c      | 1 +\n libfreerdp\/core\/transport.c | 2 ++\n winpr\/libwinpr\/sspi\/sspi.c  | 6 +++---\n 4 files changed, 7 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libfreerdp\/core\/nla.c b\/libfreerdp\/core\/nla.c\nindex 2b4b71992f..875c0ae735 100644\n--- a\/libfreerdp\/core\/nla.c\n+++ b\/libfreerdp\/core\/nla.c\n@@ -1245,6 +1245,7 @@ rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings*\n \t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n \t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n+\t\tSecInvalidateHandle(&credssp->context);\n \n \t\tif (credssp->server)\n \t\t{\ndiff --git a\/libfreerdp\/core\/peer.c b\/libfreerdp\/core\/peer.c\nindex 3806a736e0..eb4ad60eaa 100644\n--- a\/libfreerdp\/core\/peer.c\n+++ b\/libfreerdp\/core\/peer.c\n@@ -272,6 +272,7 @@ static int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n \t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n \t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n \t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n+\t\t\t\trdp->nego->transport->credssp = NULL;\n \t\t\t}\n \t\t\telse\n \t\t\t{\ndiff --git a\/libfreerdp\/core\/transport.c b\/libfreerdp\/core\/transport.c\nindex a9a710511e..4afec5a12d 100644\n--- a\/libfreerdp\/core\/transport.c\n+++ b\/libfreerdp\/core\/transport.c\n@@ -159,6 +159,7 @@ BOOL transport_connect_nla(rdpTransport* transport)\n \t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n \n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \n@@ -292,6 +293,7 @@ BOOL transport_accept_nla(rdpTransport* transport)\n \t{\n \t\tfprintf(stderr, \"client authentication failure\\n\");\n \t\tcredssp_free(transport->credssp);\n+\t\ttransport->credssp = NULL;\n \t\treturn FALSE;\n \t}\n \ndiff --git a\/winpr\/libwinpr\/sspi\/sspi.c b\/winpr\/libwinpr\/sspi\/sspi.c\nindex 8747e3f016..96c9599958 100644\n--- a\/winpr\/libwinpr\/sspi\/sspi.c\n+++ b\/winpr\/libwinpr\/sspi\/sspi.c\n@@ -248,7 +248,7 @@ void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n@@ -268,7 +268,7 @@ void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n-\tif (!handle)\n+\tif (!handle || !SecIsValidHandle(handle))\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwUpper);\n@@ -839,7 +839,7 @@ SECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDes\n \n SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n {\n-\tchar* Name;\n+\tchar* Name = NULL;\n \tSECURITY_STATUS status;\n \tSecurityFunctionTableA* table;\n \n","owner":"FreeRDP","repo":"FreeRDP","source":"cve"},{"CVE_ID":"CVE-2018-13095","CWE_ID":"476","category":"security","commit_id":"23fcb3340d033d9f081e21e6c12c2db7eaa541d3","commit_message":"From 23fcb3340d033d9f081e21e6c12c2db7eaa541d3 Mon Sep 17 00:00:00 2001\nFrom: Dave Chinner <dchinner@redhat.com>\nDate: Thu, 21 Jun 2018 23:25:57 -0700\nSubject: [PATCH] xfs: More robust inode extent count validation\n\nWhen the inode is in extent format, it can't have more extents that\nfit in the inode fork. We don't currenty check this, and so this\ncorruption goes unnoticed by the inode verifiers. This can lead to\ncrashes operating on invalid in-memory structures.\n\nAttempts to access such a inode will now error out in the verifier\nrather than allowing modification operations to proceed.\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Darrick J. Wong <darrick.wong@oracle.com>\n[darrick: fix a typedef, add some braces and breaks to shut up compiler warnings]\nSigned-off-by: Darrick J. Wong <darrick.wong@oracle.com>\n---\n fs\/xfs\/libxfs\/xfs_format.h    |  3 ++\n fs\/xfs\/libxfs\/xfs_inode_buf.c | 76 ++++++++++++++++++++++-------------\n 2 files changed, 50 insertions(+), 29 deletions(-)\n\n","diff_code":"diff --git a\/fs\/xfs\/libxfs\/xfs_format.h b\/fs\/xfs\/libxfs\/xfs_format.h\nindex 1c5a8aaf2bfcea..7b4a43deb83e0c 100644\n--- a\/fs\/xfs\/libxfs\/xfs_format.h\n+++ b\/fs\/xfs\/libxfs\/xfs_format.h\n@@ -962,6 +962,9 @@ typedef enum xfs_dinode_fmt {\n \t\tXFS_DFORK_DSIZE(dip, mp) : \\\n \t\tXFS_DFORK_ASIZE(dip, mp))\n \n+#define XFS_DFORK_MAXEXT(dip, mp, w) \\\n+\t(XFS_DFORK_SIZE(dip, mp, w) \/ sizeof(struct xfs_bmbt_rec))\n+\n \/*\n  * Return pointers to the data or attribute forks.\n  *\/\ndiff --git a\/fs\/xfs\/libxfs\/xfs_inode_buf.c b\/fs\/xfs\/libxfs\/xfs_inode_buf.c\nindex d38d724534c48e..33dc34655ac3dd 100644\n--- a\/fs\/xfs\/libxfs\/xfs_inode_buf.c\n+++ b\/fs\/xfs\/libxfs\/xfs_inode_buf.c\n@@ -374,6 +374,47 @@ xfs_log_dinode_to_disk(\n \t}\n }\n \n+static xfs_failaddr_t\n+xfs_dinode_verify_fork(\n+\tstruct xfs_dinode\t*dip,\n+\tstruct xfs_mount\t*mp,\n+\tint\t\t\twhichfork)\n+{\n+\tuint32_t\t\tdi_nextents = XFS_DFORK_NEXTENTS(dip, whichfork);\n+\n+\tswitch (XFS_DFORK_FORMAT(dip, whichfork)) {\n+\tcase XFS_DINODE_FMT_LOCAL:\n+\t\t\/*\n+\t\t * no local regular files yet\n+\t\t *\/\n+\t\tif (whichfork == XFS_DATA_FORK) {\n+\t\t\tif (S_ISREG(be16_to_cpu(dip->di_mode)))\n+\t\t\t\treturn __this_address;\n+\t\t\tif (be64_to_cpu(dip->di_size) >\n+\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork))\n+\t\t\t\treturn __this_address;\n+\t\t}\n+\t\tif (di_nextents)\n+\t\t\treturn __this_address;\n+\t\tbreak;\n+\tcase XFS_DINODE_FMT_EXTENTS:\n+\t\tif (di_nextents > XFS_DFORK_MAXEXT(dip, mp, whichfork))\n+\t\t\treturn __this_address;\n+\t\tbreak;\n+\tcase XFS_DINODE_FMT_BTREE:\n+\t\tif (whichfork == XFS_ATTR_FORK) {\n+\t\t\tif (di_nextents > MAXAEXTNUM)\n+\t\t\t\treturn __this_address;\n+\t\t} else if (di_nextents > MAXEXTNUM) {\n+\t\t\treturn __this_address;\n+\t\t}\n+\t\tbreak;\n+\tdefault:\n+\t\treturn __this_address;\n+\t}\n+\treturn NULL;\n+}\n+\n xfs_failaddr_t\n xfs_dinode_verify(\n \tstruct xfs_mount\t*mp,\n@@ -441,24 +482,9 @@ xfs_dinode_verify(\n \tcase S_IFREG:\n \tcase S_IFLNK:\n \tcase S_IFDIR:\n-\t\tswitch (dip->di_format) {\n-\t\tcase XFS_DINODE_FMT_LOCAL:\n-\t\t\t\/*\n-\t\t\t * no local regular files yet\n-\t\t\t *\/\n-\t\t\tif (S_ISREG(mode))\n-\t\t\t\treturn __this_address;\n-\t\t\tif (di_size > XFS_DFORK_DSIZE(dip, mp))\n-\t\t\t\treturn __this_address;\n-\t\t\tif (dip->di_nextents)\n-\t\t\t\treturn __this_address;\n-\t\t\t\/* fall through *\/\n-\t\tcase XFS_DINODE_FMT_EXTENTS:\n-\t\tcase XFS_DINODE_FMT_BTREE:\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\treturn __this_address;\n-\t\t}\n+\t\tfa = xfs_dinode_verify_fork(dip, mp, XFS_DATA_FORK);\n+\t\tif (fa)\n+\t\t\treturn fa;\n \t\tbreak;\n \tcase 0:\n \t\t\/* Uninitialized inode ok. *\/\n@@ -468,17 +494,9 @@ xfs_dinode_verify(\n \t}\n \n \tif (XFS_DFORK_Q(dip)) {\n-\t\tswitch (dip->di_aformat) {\n-\t\tcase XFS_DINODE_FMT_LOCAL:\n-\t\t\tif (dip->di_anextents)\n-\t\t\t\treturn __this_address;\n-\t\t\/* fall through *\/\n-\t\tcase XFS_DINODE_FMT_EXTENTS:\n-\t\tcase XFS_DINODE_FMT_BTREE:\n-\t\t\tbreak;\n-\t\tdefault:\n-\t\t\treturn __this_address;\n-\t\t}\n+\t\tfa = xfs_dinode_verify_fork(dip, mp, XFS_ATTR_FORK);\n+\t\tif (fa)\n+\t\t\treturn fa;\n \t} else {\n \t\t\/*\n \t\t * If there is no fork offset, this may be a freshly-made inode\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-12108","CWE_ID":"476","category":"security","commit_id":"13585f15c7f7dc28bbbba1661efb280d530d114c","commit_message":"From 13585f15c7f7dc28bbbba1661efb280d530d114c Mon Sep 17 00:00:00 2001\nFrom: Thomas Bernard <miniupnp@free.fr>\nDate: Tue, 18 Dec 2018 22:54:51 +0100\nSubject: [PATCH] GetOutboundPinholeTimeout: check args\n\n---\n miniupnpd\/upnpsoap.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/miniupnpd\/upnpsoap.c b\/miniupnpd\/upnpsoap.c\nindex e7193c0a..997b3254 100644\n--- a\/miniupnpd\/upnpsoap.c\n+++ b\/miniupnpd\/upnpsoap.c\n@@ -1850,6 +1850,13 @@ GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \n+\tif (!int_port || !ext_port || !protocol)\n+\t{\n+\t\tClearNameValueList(&data);\n+\t\tSoapError(h, 402, \"Invalid Args\");\n+\t\treturn;\n+\t}\n+\n \trport = (unsigned short)atoi(rem_port);\n \tiport = (unsigned short)atoi(int_port);\n \t\/*proto = atoi(protocol);*\/\n","owner":"miniupnp","repo":"miniupnp","source":"cve"},{"CVE_ID":"CVE-2019-11338","CWE_ID":"476","category":"security","commit_id":"54655623a82632e7624714d7b2a3e039dc5faa7e","commit_message":"From 54655623a82632e7624714d7b2a3e039dc5faa7e Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sat, 23 Mar 2019 20:55:08 +0100\nSubject: [PATCH] avcodec\/hevcdec: Avoid only partly skiping duplicate first\n slices\n\nFixes: NULL pointer dereference and out of array access\nFixes: 13871\/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5746167087890432\nFixes: 13845\/clusterfuzz-testcase-minimized-ffmpeg_AV_CODEC_ID_HEVC_fuzzer-5650370728034304\n\nThis also fixes the return code for explode mode\n\nFound-by: continuous fuzzing process https:\/\/github.com\/google\/oss-fuzz\/tree\/master\/projects\/ffmpeg\nReviewed-by: James Almer <jamrial@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/hevcdec.c | 14 ++++++++++----\n 1 file changed, 10 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/hevcdec.c b\/libavcodec\/hevcdec.c\nindex 86adab0ae12..857c10dd122 100644\n--- a\/libavcodec\/hevcdec.c\n+++ b\/libavcodec\/hevcdec.c\n@@ -488,6 +488,11 @@ static int hls_slice_header(HEVCContext *s)\n \n     \/\/ Coded parameters\n     sh->first_slice_in_pic_flag = get_bits1(gb);\n+    if (s->ref && sh->first_slice_in_pic_flag) {\n+        av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");\n+        return 1; \/\/ This slice will be skiped later, do not corrupt state\n+    }\n+\n     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {\n         s->seq_decode = (s->seq_decode + 1) & 0xff;\n         s->max_ra     = INT_MAX;\n@@ -2918,6 +2923,11 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n         ret = hls_slice_header(s);\n         if (ret < 0)\n             return ret;\n+        if (ret == 1) {\n+            ret = AVERROR_INVALIDDATA;\n+            goto fail;\n+        }\n+\n \n         if (\n             (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n@@ -2927,10 +2937,6 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)\n         }\n \n         if (s->sh.first_slice_in_pic_flag) {\n-            if (s->ref) {\n-                av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");\n-                goto fail;\n-            }\n             if (s->max_ra == INT_MAX) {\n                 if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                     s->max_ra = s->poc;\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-14638","CWE_ID":"476","category":"security","commit_id":"be7185faf7f52674028977dcf501c6039ff03aa5","commit_message":"From be7185faf7f52674028977dcf501c6039ff03aa5 Mon Sep 17 00:00:00 2001\nFrom: Gilles Boccon-Gibod <bok@bok.net>\nDate: Sat, 9 Sep 2017 10:36:28 -0700\nSubject: [PATCH] fix for #182\n\n---\n Source\/C++\/Core\/Ap4AtomFactory.cpp | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/Source\/C++\/Core\/Ap4AtomFactory.cpp b\/Source\/C++\/Core\/Ap4AtomFactory.cpp\nindex 687aab55..f5bd0696 100644\n--- a\/Source\/C++\/Core\/Ap4AtomFactory.cpp\n+++ b\/Source\/C++\/Core\/Ap4AtomFactory.cpp\n@@ -490,13 +490,17 @@ AP4_AtomFactory::CreateAtomFromStream(AP4_ByteStream& stream,\n           case AP4_ATOM_TYPE_HVCE:\n             if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n             atom = AP4_HvccAtom::Create(size_32, stream);\n-            atom->SetType(AP4_ATOM_TYPE_HVCE);\n+            if (atom) {\n+                atom->SetType(AP4_ATOM_TYPE_HVCE);\n+            }\n             break;\n \n           case AP4_ATOM_TYPE_AVCE:\n             if (atom_is_large) return AP4_ERROR_INVALID_FORMAT;\n             atom = AP4_AvccAtom::Create(size_32, stream);\n-            atom->SetType(AP4_ATOM_TYPE_AVCE);\n+            if (atom) {\n+                atom->SetType(AP4_ATOM_TYPE_AVCE);\n+            }\n             break;\n \n     #if !defined(AP4_CONFIG_MINI_BUILD)\n","owner":"axiomatic-systems","repo":"Bento4","source":"cve"},{"CVE_ID":"CVE-2016-3070","CWE_ID":"476","category":"security","commit_id":"42cb14b110a5698ccf26ce59c4441722605a3743","commit_message":"From 42cb14b110a5698ccf26ce59c4441722605a3743 Mon Sep 17 00:00:00 2001\nFrom: Hugh Dickins <hughd@google.com>\nDate: Thu, 5 Nov 2015 18:50:05 -0800\nSubject: mm: migrate dirty page without clear_page_dirty_for_io etc\n\nclear_page_dirty_for_io() has accumulated writeback and memcg subtleties\nsince v2.6.16 first introduced page migration; and the set_page_dirty()\nwhich completed its migration of PageDirty, later had to be moderated to\n__set_page_dirty_nobuffers(); then PageSwapBacked had to skip that too.\n\nNo actual problems seen with this procedure recently, but if you look into\nwhat the clear_page_dirty_for_io(page)+set_page_dirty(newpage) is actually\nachieving, it turns out to be nothing more than moving the PageDirty flag,\nand its NR_FILE_DIRTY stat from one zone to another.\n\nIt would be good to avoid a pile of irrelevant decrementations and\nincrementations, and improper event counting, and unnecessary descent of\nthe radix_tree under tree_lock (to set the PAGECACHE_TAG_DIRTY which\nradix_tree_replace_slot() left in place anyway).\n\nDo the NR_FILE_DIRTY movement, like the other stats movements, while\ninterrupts still disabled in migrate_page_move_mapping(); and don't even\nbother if the zone is the same.  Do the PageDirty movement there under\ntree_lock too, where old page is frozen and newpage not yet visible:\nbearing in mind that as soon as newpage becomes visible in radix_tree, an\nun-page-locked set_page_dirty() might interfere (or perhaps that's just\nnot possible: anything doing so should already hold an additional\nreference to the old page, preventing its migration; but play safe).\n\nBut we do still need to transfer PageDirty in migrate_page_copy(), for\nthose who don't go the mapping route through migrate_page_move_mapping().\n\nSigned-off-by: Hugh Dickins <hughd@google.com>\nCc: Christoph Lameter <cl@linux.com>\nCc: \"Kirill A. Shutemov\" <kirill.shutemov@linux.intel.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: Vlastimil Babka <vbabka@suse.cz>\nCc: Davidlohr Bueso <dave@stgolabs.net>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Sasha Levin <sasha.levin@oracle.com>\nCc: Dmitry Vyukov <dvyukov@google.com>\nCc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/migrate.c | 51 +++++++++++++++++++++++++++++++--------------------\n 1 file changed, 31 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/mm\/migrate.c b\/mm\/migrate.c\nindex 3067e40e7be9..2834faba719a 100644\n--- a\/mm\/migrate.c\n+++ b\/mm\/migrate.c\n@@ -30,6 +30,7 @@\n #include <linux\/mempolicy.h>\n #include <linux\/vmalloc.h>\n #include <linux\/security.h>\n+#include <linux\/backing-dev.h>\n #include <linux\/syscalls.h>\n #include <linux\/hugetlb.h>\n #include <linux\/hugetlb_cgroup.h>\n@@ -313,6 +314,8 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\tstruct buffer_head *head, enum migrate_mode mode,\n \t\tint extra_count)\n {\n+\tstruct zone *oldzone, *newzone;\n+\tint dirty;\n \tint expected_count = 1 + extra_count;\n \tvoid **pslot;\n \n@@ -331,6 +334,9 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\treturn MIGRATEPAGE_SUCCESS;\n \t}\n \n+\toldzone = page_zone(page);\n+\tnewzone = page_zone(newpage);\n+\n \tspin_lock_irq(&mapping->tree_lock);\n \n \tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n@@ -378,6 +384,13 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t\tset_page_private(newpage, page_private(page));\n \t}\n \n+\t\/* Move dirty while page refs frozen and newpage not yet exposed *\/\n+\tdirty = PageDirty(page);\n+\tif (dirty) {\n+\t\tClearPageDirty(page);\n+\t\tSetPageDirty(newpage);\n+\t}\n+\n \tradix_tree_replace_slot(pslot, newpage);\n \n \t\/*\n@@ -387,6 +400,9 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t *\/\n \tpage_unfreeze_refs(page, expected_count - 1);\n \n+\tspin_unlock(&mapping->tree_lock);\n+\t\/* Leave irq disabled to prevent preemption while updating stats *\/\n+\n \t\/*\n \t * If moved to a different zone then also account\n \t * the page for that zone. Other VM counters will be\n@@ -397,13 +413,19 @@ int migrate_page_move_mapping(struct address_space *mapping,\n \t * via NR_FILE_PAGES and NR_ANON_PAGES if they\n \t * are mapped to swap space.\n \t *\/\n-\t__dec_zone_page_state(page, NR_FILE_PAGES);\n-\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n-\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n-\t\t__dec_zone_page_state(page, NR_SHMEM);\n-\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n+\tif (newzone != oldzone) {\n+\t\t__dec_zone_state(oldzone, NR_FILE_PAGES);\n+\t\t__inc_zone_state(newzone, NR_FILE_PAGES);\n+\t\tif (PageSwapBacked(page) && !PageSwapCache(page)) {\n+\t\t\t__dec_zone_state(oldzone, NR_SHMEM);\n+\t\t\t__inc_zone_state(newzone, NR_SHMEM);\n+\t\t}\n+\t\tif (dirty && mapping_cap_account_dirty(mapping)) {\n+\t\t\t__dec_zone_state(oldzone, NR_FILE_DIRTY);\n+\t\t\t__inc_zone_state(newzone, NR_FILE_DIRTY);\n+\t\t}\n \t}\n-\tspin_unlock_irq(&mapping->tree_lock);\n+\tlocal_irq_enable();\n \n \treturn MIGRATEPAGE_SUCCESS;\n }\n@@ -524,20 +546,9 @@ void migrate_page_copy(struct page *newpage, struct page *page)\n \tif (PageMappedToDisk(page))\n \t\tSetPageMappedToDisk(newpage);\n \n-\tif (PageDirty(page)) {\n-\t\tclear_page_dirty_for_io(page);\n-\t\t\/*\n-\t\t * Want to mark the page and the radix tree as dirty, and\n-\t\t * redo the accounting that clear_page_dirty_for_io undid,\n-\t\t * but we can't use set_page_dirty because that function\n-\t\t * is actually a signal that all of the page has become dirty.\n-\t\t * Whereas only part of our page may be dirty.\n-\t\t *\/\n-\t\tif (PageSwapBacked(page))\n-\t\t\tSetPageDirty(newpage);\n-\t\telse\n-\t\t\t__set_page_dirty_nobuffers(newpage);\n- \t}\n+\t\/* Move dirty on pages not done by migrate_page_move_mapping() *\/\n+\tif (PageDirty(page))\n+\t\tSetPageDirty(newpage);\n \n \tif (page_is_young(page))\n \t\tset_page_young(newpage);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-6951","CWE_ID":"476","category":"security","commit_id":"f290f48a621867084884bfff87f8093c15195e6a","commit_message":"From f290f48a621867084884bfff87f8093c15195e6a Mon Sep 17 00:00:00 2001\nFrom: Andreas Gruenbacher <agruen@gnu.org>\nDate: Mon, 12 Feb 2018 16:48:24 +0100\nSubject: Fix segfault with mangled rename patch\n\nhttp:\/\/savannah.gnu.org\/bugs\/?53132\n* src\/pch.c (intuit_diff_type): Ensure that two filenames are specified\nfor renames and copies (fix the existing check).\n---\n src\/pch.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/pch.c b\/src\/pch.c\nindex ff9ed2c..bc6278c 100644\n--- a\/src\/pch.c\n+++ b\/src\/pch.c\n@@ -974,7 +974,8 @@ intuit_diff_type (bool need_header, mode_t *p_file_type)\n     if ((pch_rename () || pch_copy ())\n \t&& ! inname\n \t&& ! ((i == OLD || i == NEW) &&\n-\t      p_name[! reverse] &&\n+\t      p_name[reverse] && p_name[! reverse] &&\n+\t      name_is_valid (p_name[reverse]) &&\n \t      name_is_valid (p_name[! reverse])))\n       {\n \tsay (\"Cannot %s file without two valid file names\\n\", pch_rename () ? \"rename\" : \"copy\");\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-7731","CWE_ID":"476","category":"security","commit_id":"aabedb5e749dd59112a3fe1e8e08f2d934f56666","commit_message":"From aabedb5e749dd59112a3fe1e8e08f2d934f56666 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Hubert=20Figui=C3=A8re?= <hub@figuiere.net>\nDate: Mon, 26 Feb 2018 01:50:40 -0500\nSubject: Bug 105247 - Fix a null dereference in WEBP parser\n\n---\n XMPFiles\/source\/FormatSupport\/WEBP_Support.cpp | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/XMPFiles\/source\/FormatSupport\/WEBP_Support.cpp b\/XMPFiles\/source\/FormatSupport\/WEBP_Support.cpp\nindex a211697..ffaf220 100644\n--- a\/XMPFiles\/source\/FormatSupport\/WEBP_Support.cpp\n+++ b\/XMPFiles\/source\/FormatSupport\/WEBP_Support.cpp\n@@ -120,8 +120,10 @@ VP8XChunk::VP8XChunk(Container* parent)\n     this->data.assign(this->size, 0);\n     XMP_Uns8* bitstream =\n         (XMP_Uns8*)parent->chunks[WEBP_CHUNK_IMAGE][0]->data.data();\n-    XMP_Uns32 width = ((bitstream[7] << 8) | bitstream[6]) & 0x3fff;\n-    XMP_Uns32 height = ((bitstream[9] << 8) | bitstream[8]) & 0x3fff;\n+    \/\/ See bug https:\/\/bugs.freedesktop.org\/show_bug.cgi?id=105247\n+    \/\/ bitstream could be NULL.\n+    XMP_Uns32 width = bitstream ? ((bitstream[7] << 8) | bitstream[6]) & 0x3fff : 0;\n+    XMP_Uns32 height = bitstream ? ((bitstream[9] << 8) | bitstream[8]) & 0x3fff : 0;\n     this->width(width);\n     this->height(height);\n     parent->vp8x = this;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-16359","CWE_ID":"476","category":"security","commit_id":"fbaf24bce7ea4211e4608b3ab6c1b45702cb243d","commit_message":"From fbaf24bce7ea4211e4608b3ab6c1b45702cb243d Mon Sep 17 00:00:00 2001\nFrom: Khairul Kasmiran <kazarmy@gmail.com>\nDate: Wed, 1 Nov 2017 20:44:46 +0800\nSubject: [PATCH] Fix #8764 a 3rd time since 2nd time is UB and can be\n optimized away\n\n---\n libr\/bin\/format\/elf\/elf.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libr\/bin\/format\/elf\/elf.c b\/libr\/bin\/format\/elf\/elf.c\nindex 7ee0fd6597..0c47f22e67 100644\n--- a\/libr\/bin\/format\/elf\/elf.c\n+++ b\/libr\/bin\/format\/elf\/elf.c\n@@ -734,6 +734,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n \t\tSdb *sdb_verdef = sdb_new0 ();\n \t\tchar *vstart = ((char*)defs) + i;\n+\t\tsize_t vstart_off = i;\n \t\tchar key[32] = {0};\n \t\tElf_(Verdef) *verdef = (Elf_(Verdef)*)vstart;\n \t\tElf_(Verdaux) aux = {0};\n@@ -749,11 +750,12 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n \t\tint vdaux = verdef->vd_aux;\n-\t\tif (vdaux < 1 || vstart + vdaux < vstart) {\n+\t\tif (vdaux < 1 || shdr->sh_size - vstart_off < vdaux) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n \t\tvstart += vdaux;\n+\t\tvstart_off += vdaux;\n \t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n@@ -781,6 +783,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\t\tSdb *sdb_parent = sdb_new0 ();\n \t\t\tisum += aux.vda_next;\n \t\t\tvstart += aux.vda_next;\n+\t\t\tvstart_off += aux.vda_next;\n \t\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n \t\t\t\tsdb_free (sdb_verdef);\n \t\t\t\tsdb_free (sdb_parent);\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2016-9294","CWE_ID":"476","category":"security","commit_id":"5008105780c0b0182ea6eda83ad5598f225be3ee","commit_message":"From 5008105780c0b0182ea6eda83ad5598f225be3ee Mon Sep 17 00:00:00 2001\nFrom: Tor Andersson <tor.andersson@artifex.com>\nDate: Wed, 26 Oct 2016 14:31:53 +0200\nSubject: [PATCH] Fix 697172: degenerate labeled break\/continue statement.\n\nA labeled break statement will look for a matching label through\nits chain of parent statements. We start looking at the break statement\nthough, so if the label is attached to the break, we'll return the break\nstatement itself as a break target.\n\nStart looking for targets one level up instead.\n---\n jscompile.c | 10 +++++-----\n 1 file changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/jscompile.c b\/jscompile.c\nindex ee1d22f..e7055fc 100644\n--- a\/jscompile.c\n+++ b\/jscompile.c\n@@ -1102,11 +1102,11 @@ static void cstm(JF, js_Ast *stm)\n \n \tcase STM_BREAK:\n \t\tif (stm->a) {\n-\t\t\ttarget = breaktarget(J, F, stm, stm->a->string);\n+\t\t\ttarget = breaktarget(J, F, stm->parent, stm->a->string);\n \t\t\tif (!target)\n \t\t\t\tjsC_error(J, stm, \"break label '%s' not found\", stm->a->string);\n \t\t} else {\n-\t\t\ttarget = breaktarget(J, F, stm, NULL);\n+\t\t\ttarget = breaktarget(J, F, stm->parent, NULL);\n \t\t\tif (!target)\n \t\t\t\tjsC_error(J, stm, \"unlabelled break must be inside loop or switch\");\n \t\t}\n@@ -1116,11 +1116,11 @@ static void cstm(JF, js_Ast *stm)\n \n \tcase STM_CONTINUE:\n \t\tif (stm->a) {\n-\t\t\ttarget = continuetarget(J, F, stm, stm->a->string);\n+\t\t\ttarget = continuetarget(J, F, stm->parent, stm->a->string);\n \t\t\tif (!target)\n \t\t\t\tjsC_error(J, stm, \"continue label '%s' not found\", stm->a->string);\n \t\t} else {\n-\t\t\ttarget = continuetarget(J, F, stm, NULL);\n+\t\t\ttarget = continuetarget(J, F, stm->parent, NULL);\n \t\t\tif (!target)\n \t\t\t\tjsC_error(J, stm, \"continue must be inside loop\");\n \t\t}\n@@ -1133,7 +1133,7 @@ static void cstm(JF, js_Ast *stm)\n \t\t\tcexp(J, F, stm->a);\n \t\telse\n \t\t\temit(J, F, OP_UNDEF);\n-\t\ttarget = returntarget(J, F, stm);\n+\t\ttarget = returntarget(J, F, stm->parent);\n \t\tif (!target)\n \t\t\tjsC_error(J, stm, \"return not in function\");\n \t\tcexit(J, F, STM_RETURN, stm, target);\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9660","CWE_ID":"476","category":"security","commit_id":"af8346172a7b573715134f7a51e6c5c60fa7f2ab","commit_message":"From af8346172a7b573715134f7a51e6c5c60fa7f2ab Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Sat, 22 Nov 2014 13:29:10 +0100\nSubject: [bdf] Fix Savannah bug #43660.\n\n* src\/bdf\/bdflib.c (_bdf_parse_glyphs) <\"ENDFONT\">: Check\n`_BDF_GLYPH_BITS'.\n---\n ChangeLog        | 7 +++++++\n src\/bdf\/bdflib.c | 8 ++++++++\n 2 files changed, 15 insertions(+)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 20a79d0..aa28289 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,12 @@\n 2014-11-22  Werner Lemberg  <wl@gnu.org>\n \n+\t[bdf] Fix Savannah bug #43660.\n+\n+\t* src\/bdf\/bdflib.c (_bdf_parse_glyphs) <\"ENDFONT\">: Check\n+\t`_BDF_GLYPH_BITS'.\n+\n+2014-11-22  Werner Lemberg  <wl@gnu.org>\n+\n \t[type42] Allow only embedded TrueType fonts.\n \n \tThis is a follow-up to Savannah bug #43659.\ndiff --git a\/src\/bdf\/bdflib.c b\/src\/bdf\/bdflib.c\nindex c128526..369c111 100644\n--- a\/src\/bdf\/bdflib.c\n+++ b\/src\/bdf\/bdflib.c\n@@ -1555,6 +1555,14 @@\n     \/* Check for the ENDFONT field. *\/\n     if ( _bdf_strncmp( line, \"ENDFONT\", 7 ) == 0 )\n     {\n+      if ( p->flags & _BDF_GLYPH_BITS )\n+      {\n+        \/* Missing ENDCHAR field. *\/\n+        FT_ERROR(( \"_bdf_parse_glyphs: \" ERRMSG1, lineno, \"ENDCHAR\" ));\n+        error = FT_THROW( Corrupted_Font_Glyphs );\n+        goto Exit;\n+      }\n+\n       \/* Sort the glyphs by encoding. *\/\n       ft_qsort( (char *)font->glyphs,\n                 font->glyphs_used,\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-12249","CWE_ID":"476","category":"security","commit_id":"faa4eaf6803bd11669bc324b4c34e7162286bfa3","commit_message":"From faa4eaf6803bd11669bc324b4c34e7162286bfa3 Mon Sep 17 00:00:00 2001\nFrom: \"Yukihiro \\\"Matz\\\" Matsumoto\" <matz@ruby.or.jp>\nDate: Fri, 8 Jun 2018 14:13:06 +0900\nSubject: [PATCH] `mrb_class_real()` did not work for `BasicObject`; fix #4037\n\n---\n src\/class.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/class.c b\/src\/class.c\nindex c761f46af..a9439d7d7 100644\n--- a\/src\/class.c\n+++ b\/src\/class.c\n@@ -1763,10 +1763,10 @@ mrb_class_path(mrb_state *mrb, struct RClass *c)\n MRB_API struct RClass*\n mrb_class_real(struct RClass* cl)\n {\n-  if (cl == 0)\n-    return NULL;\n+  if (cl == 0) return NULL;\n   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n     cl = cl->super;\n+    if (cl == 0) return NULL;\n   }\n   return cl;\n }\n","owner":"mruby","repo":"mruby","source":"cve"},{"CVE_ID":"CVE-2017-9229","CWE_ID":"476","category":"security","commit_id":"b690371bbf97794b4a1d3f295d4fb9a8b05d402d","commit_message":"From b690371bbf97794b4a1d3f295d4fb9a8b05d402d Mon Sep 17 00:00:00 2001\nFrom: \"K.Kosako\" <kosako@sofnec.co.jp>\nDate: Wed, 24 May 2017 10:27:04 +0900\nSubject: [PATCH] fix #59 : access to invalid address by reg->dmax value\n\n---\n src\/regexec.c | 27 +++++++++++++++++----------\n 1 file changed, 17 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/src\/regexec.c b\/src\/regexec.c\nindex 49bcc50..c0626ef 100644\n--- a\/src\/regexec.c\n+++ b\/src\/regexec.c\n@@ -3235,18 +3235,25 @@ forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n     }\n     else {\n       if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n-        *low = p - reg->dmax;\n-        if (*low > s) {\n-          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n-                                          *low, (const UChar** )low_prev);\n-          if (low_prev && IS_NULL(*low_prev))\n-            *low_prev = onigenc_get_prev_char_head(reg->enc,\n-                                                   (pprev ? pprev : s), *low);\n+        if (p - str < reg->dmax) {\n+          *low = (UChar* )str;\n+          if (low_prev)\n+            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n         }\n         else {\n-          if (low_prev)\n-            *low_prev = onigenc_get_prev_char_head(reg->enc,\n-                                                   (pprev ? pprev : str), *low);\n+          *low = p - reg->dmax;\n+          if (*low > s) {\n+            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n+                                                 *low, (const UChar** )low_prev);\n+            if (low_prev && IS_NULL(*low_prev))\n+              *low_prev = onigenc_get_prev_char_head(reg->enc,\n+                                                     (pprev ? pprev : s), *low);\n+          }\n+          else {\n+            if (low_prev)\n+              *low_prev = onigenc_get_prev_char_head(reg->enc,\n+                                                     (pprev ? pprev : str), *low);\n+          }\n         }\n       }\n     }\n","owner":"kkos","repo":"oniguruma","source":"cve"},{"CVE_ID":"CVE-2017-9211","CWE_ID":"476","category":"security","commit_id":"9933e113c2e87a9f46a40fde8dafbf801dca1ab9","commit_message":"From 9933e113c2e87a9f46a40fde8dafbf801dca1ab9 Mon Sep 17 00:00:00 2001\nFrom: Herbert Xu <herbert@gondor.apana.org.au>\nDate: Wed, 10 May 2017 03:48:23 +0800\nSubject: [PATCH] crypto: skcipher - Add missing API setkey checks\n\nThe API setkey checks for key sizes and alignment went AWOL during the\nskcipher conversion.  This patch restores them.\n\nCc: <stable@vger.kernel.org>\nFixes: 4e6c3df4d729 (\"crypto: skcipher - Add low-level skcipher...\")\nReported-by: Baozeng <sploving1@gmail.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\n---\n crypto\/skcipher.c | 40 +++++++++++++++++++++++++++++++++++++++-\n 1 file changed, 39 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/crypto\/skcipher.c b\/crypto\/skcipher.c\nindex 014af741fc6a3..4faa0fd53b0c1 100644\n--- a\/crypto\/skcipher.c\n+++ b\/crypto\/skcipher.c\n@@ -764,6 +764,44 @@ static int crypto_init_skcipher_ops_ablkcipher(struct crypto_tfm *tfm)\n \treturn 0;\n }\n \n+static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,\n+\t\t\t\t     const u8 *key, unsigned int keylen)\n+{\n+\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n+\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n+\tu8 *buffer, *alignbuffer;\n+\tunsigned long absize;\n+\tint ret;\n+\n+\tabsize = keylen + alignmask;\n+\tbuffer = kmalloc(absize, GFP_ATOMIC);\n+\tif (!buffer)\n+\t\treturn -ENOMEM;\n+\n+\talignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\n+\tmemcpy(alignbuffer, key, keylen);\n+\tret = cipher->setkey(tfm, alignbuffer, keylen);\n+\tkzfree(buffer);\n+\treturn ret;\n+}\n+\n+static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n+\t\t\t   unsigned int keylen)\n+{\n+\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n+\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n+\n+\tif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\n+\t\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tif ((unsigned long)key & alignmask)\n+\t\treturn skcipher_setkey_unaligned(tfm, key, keylen);\n+\n+\treturn cipher->setkey(tfm, key, keylen);\n+}\n+\n static void crypto_skcipher_exit_tfm(struct crypto_tfm *tfm)\n {\n \tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n@@ -784,7 +822,7 @@ static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n \t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n \t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n \n-\tskcipher->setkey = alg->setkey;\n+\tskcipher->setkey = skcipher_setkey;\n \tskcipher->encrypt = alg->encrypt;\n \tskcipher->decrypt = alg->decrypt;\n \tskcipher->ivsize = alg->ivsize;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-10162","CWE_ID":"476","category":"security","commit_id":"8d2539fa0faf3f63e1d1e7635347c5b9e777d47b","commit_message":"From 8d2539fa0faf3f63e1d1e7635347c5b9e777d47b Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sat, 31 Dec 2016 20:14:20 -0800\nSubject: [PATCH] Fix bug #73831 - NULL Pointer Dereference while unserialize\n php object\n\n---\n ext\/wddx\/tests\/bug73831.phpt | 23 +++++++++++++++++++++++\n ext\/wddx\/wddx.c              | 36 ++++++++++++++++++++----------------\n 2 files changed, 43 insertions(+), 16 deletions(-)\n create mode 100644 ext\/wddx\/tests\/bug73831.phpt\n\n","diff_code":"diff --git a\/ext\/wddx\/tests\/bug73831.phpt b\/ext\/wddx\/tests\/bug73831.phpt\nnew file mode 100644\nindex 000000000000..0f8b8b126496\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug73831.phpt\n@@ -0,0 +1,23 @@\n+--TEST--\n+Bug #73831 (NULL Pointer Dereference while unserialize php object)\n+--SKIPIF--\n+<?php if (!extension_loaded(\"wddx\")) print \"skip\"; ?>\n+--FILE--\n+<?php\n+$xml = <<<EOF\n+<?xml version=\"1.0\" ?>\n+<wddxPacket version=\"1.0\">\n+\t<struct>\n+\t\t<var name=\"php_class_name\">\n+\t\t\t<string>Throwable<\/string>\n+                <\/var>\n+        <\/struct>\n+<\/wddxPacket>\n+EOF;\n+try {\n+\t$wddx = wddx_deserialize($xml);\n+} catch(Error $e) { echo $e->getMessage(); }\n+?>\n+--EXPECTF--\n+Warning: wddx_deserialize(): Class throwable can not be instantiated in %sbug73831.php on line %d\n+Cannot instantiate interface Throwable\ndiff --git a\/ext\/wddx\/wddx.c b\/ext\/wddx\/wddx.c\nindex d58a564593cb..70c621340725 100644\n--- a\/ext\/wddx\/wddx.c\n+++ b\/ext\/wddx\/wddx.c\n@@ -908,7 +908,7 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \n \t\tif (!strcmp((char *)name, EL_BINARY)) {\n \t\t\tzend_string *new_str = NULL;\n-\t\t\t\n+\n \t\t\tif (ZSTR_EMPTY_ALLOC() != Z_STR(ent1->data)) {\n \t\t\t\tnew_str = php_base64_decode(\n \t\t\t\t\t(unsigned char *)Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n@@ -967,22 +967,26 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Class %s can not be unserialized\", Z_STRVAL(ent1->data));\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\/* Initialize target object *\/\n-\t\t\t\t\t\t\tobject_init_ex(&obj, pce);\n-\n-\t\t\t\t\t\t\t\/* Merge current hashtable with object's default properties *\/\n-\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n-\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n-\t\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n-\n-\t\t\t\t\t\t\tif (incomplete_class) {\n-\t\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n+\t\t\t\t\t\t\tif (object_init_ex(&obj, pce) != SUCCESS || EG(exception)) {\n+\t\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n+\t\t\t\t\t\t\t\tZVAL_UNDEF(&ent2->data);\n+\t\t\t\t\t\t\t\tphp_error_docref(NULL, E_WARNING, \"Class %s can not be instantiated\", Z_STRVAL(ent1->data));\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\/* Merge current hashtable with object's default properties *\/\n+\t\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP(obj),\n+\t\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL(ent2->data),\n+\t\t\t\t\t\t\t\t\t\t\t\tzval_add_ref, 0);\n+\n+\t\t\t\t\t\t\t\tif (incomplete_class) {\n+\t\t\t\t\t\t\t\t\tphp_store_class_name(&obj, Z_STRVAL(ent1->data), Z_STRLEN(ent1->data));\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\/* Clean up old array entry *\/\n+\t\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n+\n+\t\t\t\t\t\t\t\t\/* Set stack entry to point to the newly created object *\/\n+\t\t\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n \t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\/* Clean up old array entry *\/\n-\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n-\n-\t\t\t\t\t\t\t\/* Set stack entry to point to the newly created object *\/\n-\t\t\t\t\t\t\tZVAL_COPY_VALUE(&ent2->data, &obj);\n \t\t\t\t\t\t}\n \n \t\t\t\t\t\t\/* Clean up class name var entry *\/\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2015-8750","CWE_ID":"476","category":"security","commit_id":"11750a2838e52953013e3114ef27b3c7b1780697","commit_message":"From 11750a2838e52953013e3114ef27b3c7b1780697 Mon Sep 17 00:00:00 2001\nFrom: David Anderson <davea42@earthlink.net>\nDate: Wed, 30 Dec 2015 13:40:25 -0800\nSubject: [PATCH] A DWARF related section marked SHT_NOBITS (elf section type)\n is an error in the elf object.  Now detected. dwarf_elf_access.c\n\n---\n libdwarf\/ChangeLog          |  4 ++++\n libdwarf\/dwarf_elf_access.c | 14 +++++++++++++-\n 2 files changed, 17 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libdwarf\/ChangeLog b\/libdwarf\/ChangeLog\nindex 89fcb95..57fb87a 100644\n--- a\/libdwarf\/ChangeLog\n+++ b\/libdwarf\/ChangeLog\n@@ -1,3 +1,7 @@\n+2015-12-30  David Anderson\n+     * dwarf_elf_access.c(dwarf_elf_object_access_load_section):\n+       now test for a NULL data pointer from libelf. Problem caused\n+       by DWARF related section being marked SHT_NOBITS.\n 2015-12-29  David Anderson\n      * dwarf_loc2.c: ll_dbg was not set, two places.\n        dwarf_loc_head_c_dealloc() was not iterating\ndiff --git a\/libdwarf\/dwarf_elf_access.c b\/libdwarf\/dwarf_elf_access.c\nindex a69c29c..72a139d 100644\n--- a\/libdwarf\/dwarf_elf_access.c\n+++ b\/libdwarf\/dwarf_elf_access.c\n@@ -1201,7 +1201,9 @@ dwarf_elf_object_relocate_a_section(void* obj_in,\n     return res;\n }\n \n-\/* dwarf_elf_object_access_load_section *\/\n+\/*  dwarf_elf_object_access_load_section()\n+    We are only asked to load sections that\n+    libdwarf really needs. *\/\n static int\n dwarf_elf_object_access_load_section(void* obj_in,\n     Dwarf_Half section_index,\n@@ -1235,6 +1237,16 @@ dwarf_elf_object_access_load_section(void* obj_in,\n             *error = DW_DLE_MDE;\n             return DW_DLV_ERROR;\n         }\n+        if (!data->d_buf) {\n+            \/*  If NULL it means 'the section has no data'\n+                according to libelf documentation.\n+                No DWARF-related section should ever have\n+                'no data'.  Happens if a section type is\n+                SHT_NOBITS and no section libdwarf\n+                wants to look at should be SHT_NOBITS. *\/\n+            *error = DW_DLE_MDE;\n+            return DW_DLV_ERROR;\n+        }\n         *section_data = data->d_buf;\n     }\n     return DW_DLV_OK;\n","owner":"tomhughes","repo":"libdwarf","source":"cve"},{"CVE_ID":"CVE-2016-8690","CWE_ID":"476","category":"security","commit_id":"8f62b4761711d036fd8964df256b938c809b7fca","commit_message":"From 8f62b4761711d036fd8964df256b938c809b7fca Mon Sep 17 00:00:00 2001\nFrom: Michael Adams <mdadams@ece.uvic.ca>\nDate: Sat, 15 Oct 2016 20:32:23 -0700\nSubject: [PATCH] Fixed a sanitizer failure in the BMP codec. Also, added a\n --debug-level command line option to the imginfo command for debugging\n purposes.\n\n---\n src\/appl\/imginfo.c          | 12 +++++++++++-\n src\/libjasper\/bmp\/bmp_dec.c | 13 ++++++++++++-\n 2 files changed, 23 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/appl\/imginfo.c b\/src\/appl\/imginfo.c\nindex 8af19e9..f458a97 100644\n--- a\/src\/appl\/imginfo.c\n+++ b\/src\/appl\/imginfo.c\n@@ -85,7 +85,8 @@ typedef enum {\n \tOPT_HELP,\n \tOPT_VERSION,\n \tOPT_VERBOSE,\n-\tOPT_INFILE\n+\tOPT_INFILE,\n+\tOPT_DEBUG\n } optid_t;\n \n \/******************************************************************************\\\n@@ -104,6 +105,7 @@ static jas_opt_t opts[] = {\n \t{OPT_VERSION, \"version\", 0},\n \t{OPT_VERBOSE, \"verbose\", 0},\n \t{OPT_INFILE, \"f\", JAS_OPT_HASARG},\n+\t{OPT_DEBUG, \"debug-level\", JAS_OPT_HASARG},\n \t{-1, 0, 0}\n };\n \n@@ -126,6 +128,7 @@ int main(int argc, char **argv)\n \tint numcmpts;\n \tint verbose;\n \tchar *fmtname;\n+\tint debug;\n \n \tif (jas_init()) {\n \t\tabort();\n@@ -135,6 +138,7 @@ int main(int argc, char **argv)\n \n \tinfile = 0;\n \tverbose = 0;\n+\tdebug = 0;\n \n \t\/* Parse the command line options. *\/\n \twhile ((id = jas_getopt(argc, argv, opts)) >= 0) {\n@@ -146,6 +150,9 @@ int main(int argc, char **argv)\n \t\t\tprintf(\"%s\\n\", JAS_VERSION);\n \t\t\texit(EXIT_SUCCESS);\n \t\t\tbreak;\n+\t\tcase OPT_DEBUG:\n+\t\t\tdebug = atoi(jas_optarg);\n+\t\t\tbreak;\n \t\tcase OPT_INFILE:\n \t\t\tinfile = jas_optarg;\n \t\t\tbreak;\n@@ -156,6 +163,8 @@ int main(int argc, char **argv)\n \t\t}\n \t}\n \n+\tjas_setdbglevel(debug);\n+\n \t\/* Open the image file. *\/\n \tif (infile) {\n \t\t\/* The image is to be read from a file. *\/\n@@ -177,6 +186,7 @@ int main(int argc, char **argv)\n \n \t\/* Decode the image. *\/\n \tif (!(image = jas_image_decode(instream, fmtid, 0))) {\n+\t\tjas_stream_close(instream);\n \t\tfprintf(stderr, \"cannot load image\\n\");\n \t\treturn EXIT_FAILURE;\n \t}\ndiff --git a\/src\/libjasper\/bmp\/bmp_dec.c b\/src\/libjasper\/bmp\/bmp_dec.c\nindex 7a6dcb1..6e7d880 100644\n--- a\/src\/libjasper\/bmp\/bmp_dec.c\n+++ b\/src\/libjasper\/bmp\/bmp_dec.c\n@@ -77,6 +77,7 @@\n #include \"jasper\/jas_stream.h\"\n #include \"jasper\/jas_image.h\"\n #include \"jasper\/jas_malloc.h\"\n+#include \"jasper\/jas_debug.h\"\n \n #include \"bmp_cod.h\"\n \n@@ -122,12 +123,22 @@ jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n \t\tjas_eprintf(\"cannot get header\\n\");\n \t\treturn 0;\n \t}\n+\tJAS_DBGLOG(1, (\n+\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n+\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n+\t  ));\n \n \t\/* Read the bitmap information. *\/\n \tif (!(info = bmp_getinfo(in))) {\n \t\tjas_eprintf(\"cannot get info\\n\");\n \t\treturn 0;\n \t}\n+\tJAS_DBGLOG(1,\n+\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n+\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n+\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n+\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n+\t  info->numcolors, info->mincolors));\n \n \t\/* Ensure that we support this type of BMP file. *\/\n \tif (!bmp_issupported(&hdr, info)) {\n@@ -440,7 +451,7 @@ static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n \t\tif ((c = jas_stream_getc(in)) == EOF) {\n \t\t\treturn -1;\n \t\t}\n-\t\tv |= (c << 24);\n+\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n \t\tif (--n <= 0) {\n \t\t\tbreak;\n \t\t}\n","owner":"mdadams","repo":"jasper","source":"cve"},{"CVE_ID":"CVE-2017-6415","CWE_ID":"476","category":"security","commit_id":"252afb1cff9676f3ae1f341a28448bf2c8b6e308","commit_message":"From 252afb1cff9676f3ae1f341a28448bf2c8b6e308 Mon Sep 17 00:00:00 2001\nFrom: h4ng3r <h4ng3r@users.noreply.github.com>\nDate: Wed, 1 Mar 2017 12:39:11 +0100\nSubject: [PATCH] fix #6872\n\n---\n libr\/bin\/p\/bin_dex.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/libr\/bin\/p\/bin_dex.c b\/libr\/bin\/p\/bin_dex.c\nindex 7293c389a2..13a7b45430 100644\n--- a\/libr\/bin\/p\/bin_dex.c\n+++ b\/libr\/bin\/p\/bin_dex.c\n@@ -377,6 +377,9 @@ static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin,\n \t\t--parameters_size;\n \t}\n \n+\tif (p4 <= 0) {\n+\t\treturn;\n+\t}\n \tut8 opcode = *(p4++) & 0xff;\n \twhile (keep) {\n \t\tswitch (opcode) {\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2016-10129","CWE_ID":"476","category":"security","commit_id":"2fdef641fd0dd2828bd948234ae86de75221a11a","commit_message":"From 2fdef641fd0dd2828bd948234ae86de75221a11a Mon Sep 17 00:00:00 2001\nFrom: Patrick Steinhardt <ps@pks.im>\nDate: Tue, 15 Nov 2016 11:44:51 +0100\nSubject: [PATCH] smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line \"0004\"). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.\n---\n src\/transports\/smart_pkt.c      | 10 +++++-----\n src\/transports\/smart_protocol.c | 11 -----------\n 2 files changed, 5 insertions(+), 16 deletions(-)\n\n","diff_code":"diff --git a\/src\/transports\/smart_pkt.c b\/src\/transports\/smart_pkt.c\nindex 6fe53b931e..e05196cd8a 100644\n--- a\/src\/transports\/smart_pkt.c\n+++ b\/src\/transports\/smart_pkt.c\n@@ -437,13 +437,13 @@ int git_pkt_parse_line(\n \n \tline += PKT_LEN_SIZE;\n \t\/*\n-\t * TODO: How do we deal with empty lines? Try again? with the next\n-\t * line?\n+\t * The Git protocol does not specify empty lines as part\n+\t * of the protocol. Not knowing what to do with an empty\n+\t * line, we should return an error upon hitting one.\n \t *\/\n \tif (len == PKT_LEN_SIZE) {\n-\t\t*head = NULL;\n-\t\t*out = line;\n-\t\treturn 0;\n+\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n+\t\treturn GIT_ERROR;\n \t}\n \n \tif (len == 0) { \/* Flush pkt *\/\ndiff --git a\/src\/transports\/smart_protocol.c b\/src\/transports\/smart_protocol.c\nindex 53c0b089ec..db6a8b9c8e 100644\n--- a\/src\/transports\/smart_protocol.c\n+++ b\/src\/transports\/smart_protocol.c\n@@ -763,14 +763,6 @@ static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt,\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n \n-\t\t\/* When a valid packet with no content has been\n-\t\t * read, git_pkt_parse_line does not report an\n-\t\t * error, but the pkt pointer has not been set.\n-\t\t * Handle this by skipping over empty packets.\n-\t\t *\/\n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\terror = add_push_report_pkt(push, pkt);\n \n \t\tgit_pkt_free(pkt);\n@@ -825,9 +817,6 @@ static int parse_report(transport_smart *transport, git_push *push)\n \n \t\terror = 0;\n \n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\tswitch (pkt->type) {\n \t\t\tcase GIT_PKT_DATA:\n \t\t\t\t\/* This is a sideband packet which contains other packets *\/\n","owner":"libgit2","repo":"libgit2","source":"cve"},{"CVE_ID":"CVE-2018-8043","CWE_ID":"476","category":"security","commit_id":"297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5","commit_message":"From 297a6961ffb8ff4dc66c9fbf53b924bd1dda05d5 Mon Sep 17 00:00:00 2001\nFrom: Wei Yongjun <weiyongjun1@huawei.com>\nDate: Thu, 11 Jan 2018 11:21:51 +0000\nSubject: [PATCH] net: phy: mdio-bcm-unimac: fix potential NULL dereference in\n unimac_mdio_probe()\n\nplatform_get_resource() may fail and return NULL, so we should\nbetter check it's return value to avoid a NULL pointer dereference\na bit later in the code.\n\nThis is detected by Coccinelle semantic patch.\n\n@@\nexpression pdev, res, n, t, e, e1, e2;\n@@\n\nres = platform_get_resource(pdev, t, n);\n+ if (!res)\n+   return -EINVAL;\n... when != res == NULL\ne = devm_ioremap(e1, res->start, e2);\n\nSigned-off-by: Wei Yongjun <weiyongjun1@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/phy\/mdio-bcm-unimac.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/net\/phy\/mdio-bcm-unimac.c b\/drivers\/net\/phy\/mdio-bcm-unimac.c\nindex 08e0647b85e23..8d370667fa1b3 100644\n--- a\/drivers\/net\/phy\/mdio-bcm-unimac.c\n+++ b\/drivers\/net\/phy\/mdio-bcm-unimac.c\n@@ -205,6 +205,8 @@ static int unimac_mdio_probe(struct platform_device *pdev)\n \t\treturn -ENOMEM;\n \n \tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n+\tif (!r)\n+\t\treturn -EINVAL;\n \n \t\/* Just ioremap, as this MDIO block is usually integrated into an\n \t * Ethernet MAC controller register range\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-12153","CWE_ID":"476","category":"security","commit_id":"e785fa0a164aa11001cba931367c7f94ffaff888","commit_message":"From e785fa0a164aa11001cba931367c7f94ffaff888 Mon Sep 17 00:00:00 2001\nFrom: Vladis Dronov <vdronov@redhat.com>\nDate: Wed, 13 Sep 2017 00:21:21 +0200\nSubject: nl80211: check for the required netlink attributes presence\n\nnl80211_set_rekey_data() does not check if the required attributes\nNL80211_REKEY_DATA_{REPLAY_CTR,KEK,KCK} are present when processing\nNL80211_CMD_SET_REKEY_OFFLOAD request. This request can be issued by\nusers with CAP_NET_ADMIN privilege and may result in NULL dereference\nand a system crash. Add a check for the required attributes presence.\nThis patch is based on the patch by bo Zhang.\n\nThis fixes CVE-2017-12153.\n\nReferences: https:\/\/bugzilla.redhat.com\/show_bug.cgi?id=1491046\nFixes: e5497d766ad (\"cfg80211\/nl80211: support GTK rekey offload\")\nCc: <stable@vger.kernel.org> # v3.1-rc1\nReported-by: bo Zhang <zhangbo5891001@gmail.com>\nSigned-off-by: Vladis Dronov <vdronov@redhat.com>\nSigned-off-by: Johannes Berg <johannes.berg@intel.com>\n---\n net\/wireless\/nl80211.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/net\/wireless\/nl80211.c b\/net\/wireless\/nl80211.c\nindex 0df8023f480b..fbd5593e88cb 100644\n--- a\/net\/wireless\/nl80211.c\n+++ b\/net\/wireless\/nl80211.c\n@@ -10903,6 +10903,9 @@ static int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)\n \tif (err)\n \t\treturn err;\n \n+\tif (!tb[NL80211_REKEY_DATA_REPLAY_CTR] || !tb[NL80211_REKEY_DATA_KEK] ||\n+\t    !tb[NL80211_REKEY_DATA_KCK])\n+\t\treturn -EINVAL;\n \tif (nla_len(tb[NL80211_REKEY_DATA_REPLAY_CTR]) != NL80211_REPLAY_CTR_LEN)\n \t\treturn -ERANGE;\n \tif (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-9923","CWE_ID":"476","category":"security","commit_id":"cb07844454d8cc9fb21f53ace75975f91185a120","commit_message":"From cb07844454d8cc9fb21f53ace75975f91185a120 Mon Sep 17 00:00:00 2001\nFrom: Sergey Poznyakoff <gray@gnu.org>\nDate: Mon, 14 Jan 2019 15:22:09 +0200\nSubject: Fix possible NULL dereference (savannah bug #55369)\n\n* src\/sparse.c (pax_decode_header): Check return from find_next_block.\n---\n src\/sparse.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/src\/sparse.c b\/src\/sparse.c\nindex 127364e..d642a46 100644\n--- a\/src\/sparse.c\n+++ b\/src\/sparse.c\n@@ -1267,6 +1267,8 @@ pax_decode_header (struct tar_sparse_file *file)\n \t {                                                         \\\n \t   set_next_block_after (b);                               \\\n            b = find_next_block ();                                 \\\n+           if (!b)                                                 \\\n+             FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\"))); \\\n            src = b->buffer;                                        \\\n \t   endp = b->buffer + BLOCKSIZE;                           \\\n \t }                                                         \\\n@@ -1279,6 +1281,8 @@ pax_decode_header (struct tar_sparse_file *file)\n       start = current_block_ordinal ();\n       set_next_block_after (current_header);\n       blk = find_next_block ();\n+      if (!blk)\n+        FATAL_ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n       p = blk->buffer;\n       COPY_BUF (blk,nbuf,p);\n       if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9051","CWE_ID":"476","category":"security","commit_id":"fe6eea99efac66839052af547426518efd970b24","commit_message":"From fe6eea99efac66839052af547426518efd970b24 Mon Sep 17 00:00:00 2001\nFrom: Sean McGovern <gseanmcg@gmail.com>\nDate: Fri, 24 Mar 2017 13:36:51 -0400\nSubject: [PATCH] nsvdec: don't ignore the return value of av_get_packet()\n\nFixes invalid reads with corrupted files.\n\nCC: libav-stable@libav.org\nBug-Id: 1039\n---\n libavformat\/nsvdec.c | 7 +++++--\n 1 file changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libavformat\/nsvdec.c b\/libavformat\/nsvdec.c\nindex c91d2a15dd..924c8694b1 100644\n--- a\/libavformat\/nsvdec.c\n+++ b\/libavformat\/nsvdec.c\n@@ -520,6 +520,7 @@ static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n     uint32_t vsize;\n     uint16_t asize;\n     uint16_t auxsize;\n+    int ret;\n \n     if (nsv->ahead[0].data || nsv->ahead[1].data)\n         return 0; \/\/-1; \/* hey! eat what you've in your plate first! *\/\n@@ -571,7 +572,8 @@ static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n     if (vsize && st[NSV_ST_VIDEO]) {\n         nst = st[NSV_ST_VIDEO]->priv_data;\n         pkt = &nsv->ahead[NSV_ST_VIDEO];\n-        av_get_packet(pb, pkt, vsize);\n+        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n+            return ret;\n         pkt->stream_index = st[NSV_ST_VIDEO]->index;\/\/NSV_ST_VIDEO;\n         pkt->dts = nst->frame_offset;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; \/* keyframe only likely on a sync frame *\/\n@@ -615,7 +617,8 @@ static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n                        bps, channels, samplerate);\n             }\n         }\n-        av_get_packet(pb, pkt, asize);\n+        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n+            return ret;\n         pkt->stream_index = st[NSV_ST_AUDIO]->index;\/\/NSV_ST_AUDIO;\n         pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; \/* keyframe only likely on a sync frame *\/\n         if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n","owner":"libav","repo":"libav","source":"cve"},{"CVE_ID":"CVE-2015-8898","CWE_ID":"476","category":"security","commit_id":"5b4bebaa91849c592a8448bc353ab25a54ff8c44","commit_message":"From 5b4bebaa91849c592a8448bc353ab25a54ff8c44 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 24 Sep 2015 09:36:17 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/pull\/34\n\n---\n MagickCore\/constitute.c | 10 +++++++++-\n 1 file changed, 9 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/MagickCore\/constitute.c b\/MagickCore\/constitute.c\nindex 24176f0b6a..dc6ec49c13 100644\n--- a\/MagickCore\/constitute.c\n+++ b\/MagickCore\/constitute.c\n@@ -1272,7 +1272,14 @@ MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n     (void) CopyMagickString(write_info->magick,images->magick,MagickPathExtent);\n   p=images;\n   for ( ; GetNextImageInList(p) != (Image *) NULL; p=GetNextImageInList(p))\n-    if (p->scene >= GetNextImageInList(p)->scene)\n+  {\n+    register Image\n+      *next;\n+    \n+    next=GetNextImageInList(p);\n+    if (next == (Image *) NULL)\n+      break;\n+    if (p->scene >= next->scene)\n       {\n         register ssize_t\n           i;\n@@ -1285,6 +1292,7 @@ MagickExport MagickBooleanType WriteImages(const ImageInfo *image_info,\n           p->scene=(size_t) i++;\n         break;\n       }\n+  }\n   \/*\n     Write images.\n   *\/\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-7132","CWE_ID":"476","category":"security","commit_id":"a14fdb9746262549bbbb96abb87338bacd147e1b","commit_message":"From a14fdb9746262549bbbb96abb87338bacd147e1b Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Wed, 10 Aug 2016 23:43:56 -0700\nSubject: [PATCH] Fix for bug #72790 and bug #72799\n\n---\n ext\/wddx\/tests\/bug72790.phpt | 35 +++++++++++++++++++++++++++++++++++\n ext\/wddx\/tests\/bug72799.phpt | 28 ++++++++++++++++++++++++++++\n ext\/wddx\/wddx.c              | 14 +++++++++-----\n 3 files changed, 72 insertions(+), 5 deletions(-)\n create mode 100644 ext\/wddx\/tests\/bug72790.phpt\n create mode 100644 ext\/wddx\/tests\/bug72799.phpt\n\n","diff_code":"diff --git a\/ext\/wddx\/tests\/bug72790.phpt b\/ext\/wddx\/tests\/bug72790.phpt\nnew file mode 100644\nindex 000000000000..a60524bdaf19\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug72790.phpt\n@@ -0,0 +1,35 @@\n+--TEST--\n+Bug 72790: wddx_deserialize null dereference with invalid xml\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<< XML\n+<?xml version='1.0' ?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+        |array>\n+                <var name=\"XXXX\">\n+                        <boolean value=\"this\">\n+                        <\/boolean>\n+                <\/var>\n+                <var name=\"YYYY\">\n+                        <var name=\"UUUU\">\n+                                <var name=\"EZEZ\">\n+                                <\/var>\n+                        <\/var>\n+                <\/var>\n+        <\/array>\n+<\/wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+NULL\n\\ No newline at end of file\ndiff --git a\/ext\/wddx\/tests\/bug72799.phpt b\/ext\/wddx\/tests\/bug72799.phpt\nnew file mode 100644\nindex 000000000000..5861d5538f49\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug72799.phpt\n@@ -0,0 +1,28 @@\n+--TEST--\n+Bug #72799: wddx_deserialize null dereference in php_wddx_pop_element\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<<XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version=\"1.0\">\n+    <var name=\"XXXX\">\n+        <boolean value=\"1\">\n+            <dateTime>1998-06-12T04:32:12+00<\/dateTime>\n+        <\/boolean>\n+    <\/var>\n+<\/wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+NULL\n\\ No newline at end of file\ndiff --git a\/ext\/wddx\/wddx.c b\/ext\/wddx\/wddx.c\nindex 1b2d103af18e..d7bd295832c7 100644\n--- a\/ext\/wddx\/wddx.c\n+++ b\/ext\/wddx\/wddx.c\n@@ -946,10 +946,10 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\tif (!ent1->data) {\n \t\t\tif (stack->top > 1) {\n \t\t\t\tstack->top--;\n+\t\t\t\tefree(ent1);\n \t\t\t} else {\n \t\t\t\tstack->done = 1;\n \t\t\t}\n-\t\t\tefree(ent1);\n \t\t\treturn;\n \t\t}\n \n@@ -988,7 +988,7 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\t\twddx_stack_top(stack, (void**)&ent2);\n \n \t\t\t\/* if non-existent field *\/\n-\t\t\tif (ent2->type == ST_FIELD && ent2->data == NULL) {\n+\t\t\tif (ent2->data == NULL) {\n \t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\tefree(ent1);\n \t\t\t\treturn;\n@@ -1179,9 +1179,13 @@ int php_wddx_deserialize_ex(char *value, int vallen, zval *return_value)\n \n \tif (stack.top == 1) {\n \t\twddx_stack_top(&stack, (void**)&ent);\n-\t\t*return_value = *(ent->data);\n-\t\tzval_copy_ctor(return_value);\n-\t\tretval = SUCCESS;\n+\t\tif(ent->data == NULL) {\n+\t\t\tretval = FAILURE;\n+\t\t} else {\n+\t\t\t*return_value = *(ent->data);\n+\t\t\tzval_copy_ctor(return_value);\n+\t\t\tretval = SUCCESS;\n+\t\t}\n \t} else {\n \t\tretval = FAILURE;\n \t}\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2014-0146","CWE_ID":"476","category":"security","commit_id":"11b128f4062dd7f89b14abc8877ff20d41b28be9","commit_message":"From 11b128f4062dd7f89b14abc8877ff20d41b28be9 Mon Sep 17 00:00:00 2001\nFrom: Kevin Wolf <kwolf@redhat.com>\nDate: Wed, 26 Mar 2014 13:06:04 +0100\nSubject: [PATCH] qcow2: Fix NULL dereference in qcow2_open() error path\n (CVE-2014-0146)\n\nThe qcow2 code assumes that s->snapshots is non-NULL if s->nb_snapshots\n!= 0. By having the initialisation of both fields separated in\nqcow2_open(), any error occuring in between would cause the error path\nto dereference NULL in qcow2_free_snapshots() if the image had any\nsnapshots.\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\n---\n block\/qcow2.c              | 7 ++++---\n tests\/qemu-iotests\/080     | 7 +++++++\n tests\/qemu-iotests\/080.out | 4 ++++\n 3 files changed, 15 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/block\/qcow2.c b\/block\/qcow2.c\nindex b64564d..be48a27 100644\n--- a\/block\/qcow2.c\n+++ b\/block\/qcow2.c\n@@ -637,9 +637,6 @@ static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,\n         goto fail;\n     }\n \n-    s->snapshots_offset = header.snapshots_offset;\n-    s->nb_snapshots = header.nb_snapshots;\n-\n     \/* read the level 1 table *\/\n     if (header.l1_size > 0x2000000) {\n         \/* 32 MB L1 table is enough for 2 PB images at 64k cluster size\n@@ -734,6 +731,10 @@ static int qcow2_open(BlockDriverState *bs, QDict *options, int flags,\n         bs->backing_file[len] = '\\0';\n     }\n \n+    \/* Internal snapshots *\/\n+    s->snapshots_offset = header.snapshots_offset;\n+    s->nb_snapshots = header.nb_snapshots;\n+\n     ret = qcow2_read_snapshots(bs);\n     if (ret < 0) {\n         error_setg_errno(errp, -ret, \"Could not read snapshots\");\ndiff --git a\/tests\/qemu-iotests\/080 b\/tests\/qemu-iotests\/080\nindex 56f8903..59e7a44 100755\n--- a\/tests\/qemu-iotests\/080\n+++ b\/tests\/qemu-iotests\/080\n@@ -139,6 +139,13 @@ poke_file \"$TEST_IMG\" \"$offset_l1_size\" \"\\x00\\x00\\x00\\x01\"\n { $QEMU_IO -c \"read 0 512\" $TEST_IMG; } 2>&1 | _filter_qemu_io | _filter_testdir\n \n echo\n+echo \"== Invalid L1 table (with internal snapshot in the image) ==\"\n+_make_test_img 64M\n+{ $QEMU_IMG snapshot -c foo $TEST_IMG; } 2>&1 | _filter_qemu_io | _filter_testdir\n+poke_file \"$TEST_IMG\" \"$offset_l1_size\" \"\\x00\\x00\\x00\\x00\"\n+_img_info\n+\n+echo\n echo \"== Invalid backing file size ==\"\n _make_test_img 64M\n poke_file \"$TEST_IMG\" \"$offset_backing_file_offset\" \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\"\ndiff --git a\/tests\/qemu-iotests\/080.out b\/tests\/qemu-iotests\/080.out\nindex 303d6c3..4d84fbf 100644\n--- a\/tests\/qemu-iotests\/080.out\n+++ b\/tests\/qemu-iotests\/080.out\n@@ -59,6 +59,10 @@ no file open, try 'help open'\n qemu-io: can't open device TEST_DIR\/t.qcow2: Invalid L1 table offset\n no file open, try 'help open'\n \n+== Invalid L1 table (with internal snapshot in the image) ==\n+Formatting 'TEST_DIR\/t.IMGFMT', fmt=IMGFMT size=67108864 \n+qemu-img: Could not open 'TEST_DIR\/t.IMGFMT': L1 table is too small\n+\n == Invalid backing file size ==\n Formatting 'TEST_DIR\/t.IMGFMT', fmt=IMGFMT size=67108864 \n qemu-io: can't open device TEST_DIR\/t.qcow2: Backing file name too long\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9608","CWE_ID":"476","category":"security","commit_id":"611b35627488a8d0763e75c25ee0875c5b7987dd","commit_message":"From 611b35627488a8d0763e75c25ee0875c5b7987dd Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Wed, 14 Jun 2017 16:58:20 +0200\nSubject: [PATCH] avcodec\/dnxhd_parser: Do not return invalid value from\n dnxhd_find_frame_end() on error\n\nFixes: Null pointer dereference\n\nFixes: CVE-2017-9608\nFound-by: Yihan Lian\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/dnxhd_parser.c | 12 +++++++-----\n 1 file changed, 7 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/dnxhd_parser.c b\/libavcodec\/dnxhd_parser.c\nindex d9914121a06..79ca1d67188 100644\n--- a\/libavcodec\/dnxhd_parser.c\n+++ b\/libavcodec\/dnxhd_parser.c\n@@ -68,16 +68,18 @@ static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n+                int remaining;\n \n                 if (cid <= 0)\n                     continue;\n \n-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n-                if (dctx->remaining <= 0) {\n-                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n-                    if (dctx->remaining <= 0)\n-                        return dctx->remaining;\n+                remaining = avpriv_dnxhd_get_frame_size(cid);\n+                if (remaining <= 0) {\n+                    remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n+                    if (remaining <= 0)\n+                        continue;\n                 }\n+                dctx->remaining = remaining;\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n \n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2016-10129","CWE_ID":"476","category":"security","commit_id":"84d30d569ada986f3eef527cbdb932643c2dd037","commit_message":"From 84d30d569ada986f3eef527cbdb932643c2dd037 Mon Sep 17 00:00:00 2001\nFrom: Patrick Steinhardt <ps@pks.im>\nDate: Tue, 15 Nov 2016 11:44:51 +0100\nSubject: [PATCH] smart_pkt: treat empty packet lines as error\n\nThe Git protocol does not specify what should happen in the case\nof an empty packet line (that is a packet line \"0004\"). We\ncurrently indicate success, but do not return a packet in the\ncase where we hit an empty line. The smart protocol was not\nprepared to handle such packets in all cases, though, resulting\nin a `NULL` pointer dereference.\n\nFix the issue by returning an error instead. As such kind of\npackets is not even specified by upstream, this is the right\nthing to do.\n---\n src\/transports\/smart_pkt.c      | 10 +++++-----\n src\/transports\/smart_protocol.c | 11 -----------\n 2 files changed, 5 insertions(+), 16 deletions(-)\n\n","diff_code":"diff --git a\/src\/transports\/smart_pkt.c b\/src\/transports\/smart_pkt.c\nindex 6fe53b931e..e05196cd8a 100644\n--- a\/src\/transports\/smart_pkt.c\n+++ b\/src\/transports\/smart_pkt.c\n@@ -437,13 +437,13 @@ int git_pkt_parse_line(\n \n \tline += PKT_LEN_SIZE;\n \t\/*\n-\t * TODO: How do we deal with empty lines? Try again? with the next\n-\t * line?\n+\t * The Git protocol does not specify empty lines as part\n+\t * of the protocol. Not knowing what to do with an empty\n+\t * line, we should return an error upon hitting one.\n \t *\/\n \tif (len == PKT_LEN_SIZE) {\n-\t\t*head = NULL;\n-\t\t*out = line;\n-\t\treturn 0;\n+\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n+\t\treturn GIT_ERROR;\n \t}\n \n \tif (len == 0) { \/* Flush pkt *\/\ndiff --git a\/src\/transports\/smart_protocol.c b\/src\/transports\/smart_protocol.c\nindex 3448fa7fbe..02e1ecf747 100644\n--- a\/src\/transports\/smart_protocol.c\n+++ b\/src\/transports\/smart_protocol.c\n@@ -759,14 +759,6 @@ static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt,\n \t\tline_len -= (line_end - line);\n \t\tline = line_end;\n \n-\t\t\/* When a valid packet with no content has been\n-\t\t * read, git_pkt_parse_line does not report an\n-\t\t * error, but the pkt pointer has not been set.\n-\t\t * Handle this by skipping over empty packets.\n-\t\t *\/\n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\terror = add_push_report_pkt(push, pkt);\n \n \t\tgit_pkt_free(pkt);\n@@ -821,9 +813,6 @@ static int parse_report(transport_smart *transport, git_push *push)\n \n \t\terror = 0;\n \n-\t\tif (pkt == NULL)\n-\t\t\tcontinue;\n-\n \t\tswitch (pkt->type) {\n \t\t\tcase GIT_PKT_DATA:\n \t\t\t\t\/* This is a sideband packet which contains other packets *\/\n","owner":"libgit2","repo":"libgit2","source":"cve"},{"CVE_ID":"CVE-2019-12378","CWE_ID":"476","category":"security","commit_id":"95baa60a0da80a0143e3ddd4d3725758b4513825","commit_message":"From 95baa60a0da80a0143e3ddd4d3725758b4513825 Mon Sep 17 00:00:00 2001\nFrom: Gen Zhang <blackgod016574@gmail.com>\nDate: Fri, 24 May 2019 11:19:46 +0800\nSubject: ipv6_sockglue: Fix a missing-check bug in ip6_ra_control()\n\nIn function ip6_ra_control(), the pointer new_ra is allocated a memory\nspace via kmalloc(). And it is used in the following codes. However,\nwhen there is a memory allocation error, kmalloc() fails. Thus null\npointer dereference may happen. And it will cause the kernel to crash.\nTherefore, we should check the return value and handle the error.\n\nSigned-off-by: Gen Zhang <blackgod016574@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/ipv6_sockglue.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/net\/ipv6\/ipv6_sockglue.c b\/net\/ipv6\/ipv6_sockglue.c\nindex 40f21fef25ff..0a3d035feb61 100644\n--- a\/net\/ipv6\/ipv6_sockglue.c\n+++ b\/net\/ipv6\/ipv6_sockglue.c\n@@ -68,6 +68,8 @@ int ip6_ra_control(struct sock *sk, int sel)\n \t\treturn -ENOPROTOOPT;\n \n \tnew_ra = (sel >= 0) ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n+\tif (sel >= 0 && !new_ra)\n+\t\treturn -ENOMEM;\n \n \twrite_lock_bh(&ip6_ra_lock);\n \tfor (rap = &ip6_ra_chain; (ra = *rap) != NULL; rap = &ra->next) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8970","CWE_ID":"476","category":"security","commit_id":"dd504589577d8e8e70f51f997ad487a4cb6c026f","commit_message":"From dd504589577d8e8e70f51f997ad487a4cb6c026f Mon Sep 17 00:00:00 2001\nFrom: Herbert Xu <herbert@gondor.apana.org.au>\nDate: Fri, 25 Dec 2015 15:40:05 +0800\nSubject: [PATCH] crypto: algif_skcipher - Require setkey before accept(2)\n\nSome cipher implementations will crash if you try to use them\nwithout calling setkey first.  This patch adds a check so that\nthe accept(2) call will fail with -ENOKEY if setkey hasn't been\ndone on the socket yet.\n\nCc: stable@vger.kernel.org\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\n---\n crypto\/algif_skcipher.c | 48 +++++++++++++++++++++++++++++++++++------\n 1 file changed, 41 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/algif_skcipher.c b\/crypto\/algif_skcipher.c\nindex 5c756b30e79b1..f4431bc1ce430 100644\n--- a\/crypto\/algif_skcipher.c\n+++ b\/crypto\/algif_skcipher.c\n@@ -31,6 +31,11 @@ struct skcipher_sg_list {\n \tstruct scatterlist sg[0];\n };\n \n+struct skcipher_tfm {\n+\tstruct crypto_skcipher *skcipher;\n+\tbool has_key;\n+};\n+\n struct skcipher_ctx {\n \tstruct list_head tsgl;\n \tstruct af_alg_sgl rsgl;\n@@ -750,17 +755,41 @@ static struct proto_ops algif_skcipher_ops = {\n \n static void *skcipher_bind(const char *name, u32 type, u32 mask)\n {\n-\treturn crypto_alloc_skcipher(name, type, mask);\n+\tstruct skcipher_tfm *tfm;\n+\tstruct crypto_skcipher *skcipher;\n+\n+\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n+\tif (!tfm)\n+\t\treturn ERR_PTR(-ENOMEM);\n+\n+\tskcipher = crypto_alloc_skcipher(name, type, mask);\n+\tif (IS_ERR(skcipher)) {\n+\t\tkfree(tfm);\n+\t\treturn ERR_CAST(skcipher);\n+\t}\n+\n+\ttfm->skcipher = skcipher;\n+\n+\treturn tfm;\n }\n \n static void skcipher_release(void *private)\n {\n-\tcrypto_free_skcipher(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\n+\tcrypto_free_skcipher(tfm->skcipher);\n+\tkfree(tfm);\n }\n \n static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n {\n-\treturn crypto_skcipher_setkey(private, key, keylen);\n+\tstruct skcipher_tfm *tfm = private;\n+\tint err;\n+\n+\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\n+\ttfm->has_key = !err;\n+\n+\treturn err;\n }\n \n static void skcipher_wait(struct sock *sk)\n@@ -792,20 +821,25 @@ static int skcipher_accept_parent(void *private, struct sock *sk)\n {\n \tstruct skcipher_ctx *ctx;\n \tstruct alg_sock *ask = alg_sk(sk);\n-\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n+\tstruct skcipher_tfm *tfm = private;\n+\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n+\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n+\n+\tif (!tfm->has_key)\n+\t\treturn -ENOKEY;\n \n \tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n \tif (!ctx)\n \t\treturn -ENOMEM;\n \n-\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n+\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n \t\t\t       GFP_KERNEL);\n \tif (!ctx->iv) {\n \t\tsock_kfree_s(sk, ctx, len);\n \t\treturn -ENOMEM;\n \t}\n \n-\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n+\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n \n \tINIT_LIST_HEAD(&ctx->tsgl);\n \tctx->len = len;\n@@ -818,7 +852,7 @@ static int skcipher_accept_parent(void *private, struct sock *sk)\n \n \task->private = ctx;\n \n-\tskcipher_request_set_tfm(&ctx->req, private);\n+\tskcipher_request_set_tfm(&ctx->req, skcipher);\n \tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n \t\t\t\t      af_alg_complete, &ctx->completion);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0006","CWE_ID":"476","category":"security","commit_id":"2570a4f5428bcdb1077622342181755741e7fa60","commit_message":"From 2570a4f5428bcdb1077622342181755741e7fa60 Mon Sep 17 00:00:00 2001\nFrom: \"David S. Miller\" <davem@davemloft.net>\nDate: Wed, 13 Jan 2010 17:27:37 -0800\nSubject: ipv6: skb_dst() can be NULL in ipv6_hop_jumbo().\n\nThis fixes CERT-FI FICORA #341748\n\nDiscovered by Olli Jarva and Tuomo Untinen from the CROSS\nproject at Codenomicon Ltd.\n\nJust like in CVE-2007-4567, we can't rely upon skb_dst() being\nnon-NULL at this point.  We fixed that in commit\ne76b2b2567b83448c2ee85a896433b96150c92e6 (\"[IPV6]: Do no rely on\nskb->dst before it is assigned.\")\n\nHowever commit 483a47d2fe794328d29950fe00ce26dd405d9437 (\"ipv6: added\nnet argument to IP6_INC_STATS_BH\") put a new version of the same bug\ninto this function.\n\nComplicating analysis further, this bug can only trigger when network\nnamespaces are enabled in the build.  When namespaces are turned off,\nthe dev_net() does not evaluate it's argument, so the dereference\nwould not occur.\n\nSo, for a long time, namespaces couldn't be turned on unless SYSFS was\ndisabled.  Therefore, this code has largely been disabled except by\npeople turning it on explicitly for namespace development.\n\nWith help from Eugene Teo <eugene@redhat.com>\n\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/exthdrs.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/exthdrs.c b\/net\/ipv6\/exthdrs.c\nindex df159fffe4bc..4bac362b1335 100644\n--- a\/net\/ipv6\/exthdrs.c\n+++ b\/net\/ipv6\/exthdrs.c\n@@ -559,6 +559,11 @@ static inline struct inet6_dev *ipv6_skb_idev(struct sk_buff *skb)\n \treturn skb_dst(skb) ? ip6_dst_idev(skb_dst(skb)) : __in6_dev_get(skb->dev);\n }\n \n+static inline struct net *ipv6_skb_net(struct sk_buff *skb)\n+{\n+\treturn skb_dst(skb) ? dev_net(skb_dst(skb)->dev) : dev_net(skb->dev);\n+}\n+\n \/* Router Alert as of RFC 2711 *\/\n \n static int ipv6_hop_ra(struct sk_buff *skb, int optoff)\n@@ -580,8 +585,8 @@ static int ipv6_hop_ra(struct sk_buff *skb, int optoff)\n static int ipv6_hop_jumbo(struct sk_buff *skb, int optoff)\n {\n \tconst unsigned char *nh = skb_network_header(skb);\n+\tstruct net *net = ipv6_skb_net(skb);\n \tu32 pkt_len;\n-\tstruct net *net = dev_net(skb_dst(skb)->dev);\n \n \tif (nh[optoff + 1] != 4 || (optoff & 3) != 2) {\n \t\tLIMIT_NETDEBUG(KERN_DEBUG \"ipv6_hop_jumbo: wrong jumbo opt length\/alignment %d\\n\",\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-16749","CWE_ID":"476","category":"security","commit_id":"1007b98f8795ad4bea6bc5f68a32d83e982fdae4","commit_message":"From 1007b98f8795ad4bea6bc5f68a32d83e982fdae4 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 1 May 2018 19:13:48 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1119\n\n---\n coders\/png.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/png.c b\/coders\/png.c\nindex 31c0b8450..3d6eb7db2 100644\n--- a\/coders\/png.c\n+++ b\/coders\/png.c\n@@ -4584,7 +4584,7 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Copying JDAT chunk data to color_blob.\");\n \n-        if (length != 0)\n+        if ((length != 0) && (color_image != (Image *) NULL))\n           {\n             (void) WriteBlob(color_image,length,chunk);\n             chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n","owner":"ImageMagick","repo":"ImageMagick6","source":"cve"},{"CVE_ID":"CVE-2019-13225","CWE_ID":"476","category":"security","commit_id":"c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c","commit_message":"From c509265c5f6ae7264f7b8a8aae1cfa5fc59d108c Mon Sep 17 00:00:00 2001\nFrom: \"K.Kosako\" <kosako@sofnec.co.jp>\nDate: Thu, 27 Jun 2019 14:11:55 +0900\nSubject: [PATCH] Fix CVE-2019-13225: problem in converting if-then-else\n pattern to bytecode.\n\n---\n src\/regcomp.c | 25 +++++++++++++++++--------\n 1 file changed, 17 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/src\/regcomp.c b\/src\/regcomp.c\nindex c2c04a4..ff3431f 100644\n--- a\/src\/regcomp.c\n+++ b\/src\/regcomp.c\n@@ -1307,8 +1307,9 @@ compile_length_bag_node(BagNode* node, regex_t* reg)\n         len += tlen;\n       }\n \n+      len += SIZE_OP_JUMP + SIZE_OP_ATOMIC_END;\n+\n       if (IS_NOT_NULL(Else)) {\n-        len += SIZE_OP_JUMP;\n         tlen = compile_length_tree(Else, reg);\n         if (tlen < 0) return tlen;\n         len += tlen;\n@@ -1455,7 +1456,7 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n \n   case BAG_IF_ELSE:\n     {\n-      int cond_len, then_len, jump_len;\n+      int cond_len, then_len, else_len, jump_len;\n       Node* cond = NODE_BAG_BODY(node);\n       Node* Then = node->te.Then;\n       Node* Else = node->te.Else;\n@@ -1472,8 +1473,7 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n       else\n         then_len = 0;\n \n-      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;\n-      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;\n+      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END + SIZE_OP_JUMP;\n \n       r = add_op(reg, OP_PUSH);\n       if (r != 0) return r;\n@@ -1490,11 +1490,20 @@ compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)\n       }\n \n       if (IS_NOT_NULL(Else)) {\n-        int else_len = compile_length_tree(Else, reg);\n-        r = add_op(reg, OP_JUMP);\n-        if (r != 0) return r;\n-        COP(reg)->jump.addr = else_len + SIZE_INC_OP;\n+        else_len = compile_length_tree(Else, reg);\n+        if (else_len < 0) return else_len;\n+      }\n+      else\n+        else_len = 0;\n \n+      r = add_op(reg, OP_JUMP);\n+      if (r != 0) return r;\n+      COP(reg)->jump.addr = SIZE_OP_ATOMIC_END + else_len + SIZE_INC_OP;\n+\n+      r = add_op(reg, OP_ATOMIC_END);\n+      if (r != 0) return r;\n+\n+      if (IS_NOT_NULL(Else)) {\n         r = compile_tree(Else, reg, env);\n       }\n     }\n","owner":"kkos","repo":"oniguruma","source":"cve"},{"CVE_ID":"CVE-2017-15116","CWE_ID":"476","category":"security","commit_id":"94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6","commit_message":"From 94f1bb15bed84ad6c893916b7e7b9db6f1d7eec6 Mon Sep 17 00:00:00 2001\nFrom: Herbert Xu <herbert@gondor.apana.org.au>\nDate: Tue, 21 Apr 2015 10:46:46 +0800\nSubject: crypto: rng - Remove old low-level rng interface\n\nNow that all rng implementations have switched over to the new\ninterface, we can remove the old low-level interface.\n\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\n---\n crypto\/rng.c                  | 57 +++----------------------------------------\n include\/crypto\/internal\/rng.h |  3 +--\n include\/crypto\/rng.h          | 10 +++-----\n include\/linux\/crypto.h        | 30 -----------------------\n 4 files changed, 8 insertions(+), 92 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/rng.c b\/crypto\/rng.c\nindex e98ce1ca527d..055e276427b1 100644\n--- a\/crypto\/rng.c\n+++ b\/crypto\/rng.c\n@@ -4,6 +4,7 @@\n  * RNG operations.\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and\/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -36,39 +37,6 @@ static inline struct crypto_rng *__crypto_rng_cast(struct crypto_tfm *tfm)\n \treturn container_of(tfm, struct crypto_rng, base);\n }\n \n-static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n-{\n-\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n-}\n-\n-static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n-\t\t    u8 *dst, unsigned int dlen)\n-{\n-\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n-}\n-\n-static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n-\t\t\tunsigned int slen)\n-{\n-\tu8 *buf = NULL;\n-\tu8 *src = (u8 *)seed;\n-\tint err;\n-\n-\tif (slen) {\n-\t\tbuf = kmalloc(slen, GFP_KERNEL);\n-\t\tif (!buf)\n-\t\t\treturn -ENOMEM;\n-\n-\t\tmemcpy(buf, seed, slen);\n-\t\tsrc = buf;\n-\t}\n-\n-\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n-\n-\tkzfree(buf);\n-\treturn err;\n-}\n-\n int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n {\n \tu8 *buf = NULL;\n@@ -83,7 +51,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n \t\tseed = buf;\n \t}\n \n-\terr = tfm->seed(tfm, seed, slen);\n+\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n \n \tkfree(buf);\n \treturn err;\n@@ -92,21 +60,6 @@ EXPORT_SYMBOL_GPL(crypto_rng_reset);\n \n static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n {\n-\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n-\tstruct rng_alg *alg = crypto_rng_alg(rng);\n-\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n-\n-\tif (oalg->rng_make_random) {\n-\t\trng->generate = generate;\n-\t\trng->seed = rngapi_reset;\n-\t\trng->seedsize = oalg->seedsize;\n-\t\treturn 0;\n-\t}\n-\n-\trng->generate = alg->generate;\n-\trng->seed = alg->seed;\n-\trng->seedsize = alg->seedsize;\n-\n \treturn 0;\n }\n \n@@ -114,8 +67,7 @@ static unsigned int seedsize(struct crypto_alg *alg)\n {\n \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n \n-\treturn alg->cra_rng.rng_make_random ?\n-\t       alg->cra_rng.seedsize : ralg->seedsize;\n+\treturn ralg->seedsize;\n }\n \n #ifdef CONFIG_NET\n@@ -150,7 +102,7 @@ static void crypto_rng_show(struct seq_file *m, struct crypto_alg *alg)\n \tseq_printf(m, \"seedsize     : %u\\n\", seedsize(alg));\n }\n \n-const struct crypto_type crypto_rng_type = {\n+static const struct crypto_type crypto_rng_type = {\n \t.extsize = crypto_alg_extsize,\n \t.init_tfm = crypto_rng_init_tfm,\n #ifdef CONFIG_PROC_FS\n@@ -162,7 +114,6 @@ const struct crypto_type crypto_rng_type = {\n \t.type = CRYPTO_ALG_TYPE_RNG,\n \t.tfmsize = offsetof(struct crypto_rng, base),\n };\n-EXPORT_SYMBOL_GPL(crypto_rng_type);\n \n struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)\n {\ndiff --git a\/include\/crypto\/internal\/rng.h b\/include\/crypto\/internal\/rng.h\nindex 2c9a865c66e2..263f1a5eebc7 100644\n--- a\/include\/crypto\/internal\/rng.h\n+++ b\/include\/crypto\/internal\/rng.h\n@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and\/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -16,8 +17,6 @@\n #include <crypto\/algapi.h>\n #include <crypto\/rng.h>\n \n-extern const struct crypto_type crypto_rng_type;\n-\n int crypto_register_rng(struct rng_alg *alg);\n void crypto_unregister_rng(struct rng_alg *alg);\n int crypto_register_rngs(struct rng_alg *algs, int count);\ndiff --git a\/include\/crypto\/rng.h b\/include\/crypto\/rng.h\nindex cc22e52a129a..c5d4684429f5 100644\n--- a\/include\/crypto\/rng.h\n+++ b\/include\/crypto\/rng.h\n@@ -2,6 +2,7 @@\n  * RNG: Random Number Generator  algorithms under the crypto API\n  *\n  * Copyright (c) 2008 Neil Horman <nhorman@tuxdriver.com>\n+ * Copyright (c) 2015 Herbert Xu <herbert@gondor.apana.org.au>\n  *\n  * This program is free software; you can redistribute it and\/or modify it\n  * under the terms of the GNU General Public License as published by the Free\n@@ -56,11 +57,6 @@ struct rng_alg {\n };\n \n struct crypto_rng {\n-\tint (*generate)(struct crypto_rng *tfm,\n-\t\t\tconst u8 *src, unsigned int slen,\n-\t\t\tu8 *dst, unsigned int dlen);\n-\tint (*seed)(struct crypto_rng *tfm, const u8 *seed, unsigned int slen);\n-\tunsigned int seedsize;\n \tstruct crypto_tfm base;\n };\n \n@@ -144,7 +140,7 @@ static inline int crypto_rng_generate(struct crypto_rng *tfm,\n \t\t\t\t      const u8 *src, unsigned int slen,\n \t\t\t\t      u8 *dst, unsigned int dlen)\n {\n-\treturn tfm->generate(tfm, src, slen, dst, dlen);\n+\treturn crypto_rng_alg(tfm)->generate(tfm, src, slen, dst, dlen);\n }\n \n \/**\n@@ -198,7 +194,7 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed,\n  *\/\n static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n {\n-\treturn tfm->seedsize;\n+\treturn crypto_rng_alg(tfm)->seedsize;\n }\n \n #endif\ndiff --git a\/include\/linux\/crypto.h b\/include\/linux\/crypto.h\nindex 2fa9b05360f7..ee14140f8893 100644\n--- a\/include\/linux\/crypto.h\n+++ b\/include\/linux\/crypto.h\n@@ -138,7 +138,6 @@ struct crypto_async_request;\n struct crypto_aead;\n struct crypto_blkcipher;\n struct crypto_hash;\n-struct crypto_rng;\n struct crypto_tfm;\n struct crypto_type;\n struct aead_givcrypt_request;\n@@ -426,40 +425,12 @@ struct compress_alg {\n \t\t\t      unsigned int slen, u8 *dst, unsigned int *dlen);\n };\n \n-\/**\n- * struct old_rng_alg - random number generator definition\n- * @rng_make_random: The function defined by this variable obtains a random\n- *\t\t     number. The random number generator transform must generate\n- *\t\t     the random number out of the context provided with this\n- *\t\t     call.\n- * @rng_reset: Reset of the random number generator by clearing the entire state.\n- *\t       With the invocation of this function call, the random number\n- *             generator shall completely reinitialize its state. If the random\n- *\t       number generator requires a seed for setting up a new state,\n- *\t       the seed must be provided by the consumer while invoking this\n- *\t       function. The required size of the seed is defined with\n- *\t       @seedsize .\n- * @seedsize: The seed size required for a random number generator\n- *\t      initialization defined with this variable. Some random number\n- *\t      generators like the SP800-90A DRBG does not require a seed as the\n- *\t      seeding is implemented internally without the need of support by\n- *\t      the consumer. In this case, the seed size is set to zero.\n- *\/\n-struct old_rng_alg {\n-\tint (*rng_make_random)(struct crypto_rng *tfm, u8 *rdata,\n-\t\t\t       unsigned int dlen);\n-\tint (*rng_reset)(struct crypto_rng *tfm, u8 *seed, unsigned int slen);\n-\n-\tunsigned int seedsize;\n-};\n-\n \n #define cra_ablkcipher\tcra_u.ablkcipher\n #define cra_aead\tcra_u.aead\n #define cra_blkcipher\tcra_u.blkcipher\n #define cra_cipher\tcra_u.cipher\n #define cra_compress\tcra_u.compress\n-#define cra_rng\t\tcra_u.rng\n \n \/**\n  * struct crypto_alg - definition of a cryptograpic cipher algorithm\n@@ -559,7 +530,6 @@ struct crypto_alg {\n \t\tstruct blkcipher_alg blkcipher;\n \t\tstruct cipher_alg cipher;\n \t\tstruct compress_alg compress;\n-\t\tstruct old_rng_alg rng;\n \t} cra_u;\n \n \tint (*cra_init)(struct crypto_tfm *tfm);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8956","CWE_ID":"476","category":"security","commit_id":"951b6a0717db97ce420547222647bcc40bf1eacd","commit_message":"From 951b6a0717db97ce420547222647bcc40bf1eacd Mon Sep 17 00:00:00 2001\nFrom: Jaganath Kanakkassery <jaganath.k@samsung.com>\nDate: Thu, 14 May 2015 12:58:08 +0530\nSubject: Bluetooth: Fix potential NULL dereference in RFCOMM bind callback\n\naddr can be NULL and it should not be dereferenced before NULL checking.\n\nSigned-off-by: Jaganath Kanakkassery <jaganath.k@samsung.com>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>\n---\n net\/bluetooth\/rfcomm\/sock.c | 20 ++++++++++++--------\n 1 file changed, 12 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/net\/bluetooth\/rfcomm\/sock.c b\/net\/bluetooth\/rfcomm\/sock.c\nindex b2338e971b33..7511df72347f 100644\n--- a\/net\/bluetooth\/rfcomm\/sock.c\n+++ b\/net\/bluetooth\/rfcomm\/sock.c\n@@ -334,16 +334,19 @@ static int rfcomm_sock_create(struct net *net, struct socket *sock,\n \n static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n {\n-\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n+\tstruct sockaddr_rc sa;\n \tstruct sock *sk = sock->sk;\n-\tint chan = sa->rc_channel;\n-\tint err = 0;\n-\n-\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n+\tint len, err = 0;\n \n \tif (!addr || addr->sa_family != AF_BLUETOOTH)\n \t\treturn -EINVAL;\n \n+\tmemset(&sa, 0, sizeof(sa));\n+\tlen = min_t(unsigned int, sizeof(sa), addr_len);\n+\tmemcpy(&sa, addr, len);\n+\n+\tBT_DBG(\"sk %p %pMR\", sk, &sa.rc_bdaddr);\n+\n \tlock_sock(sk);\n \n \tif (sk->sk_state != BT_OPEN) {\n@@ -358,12 +361,13 @@ static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr\n \n \twrite_lock(&rfcomm_sk_list.lock);\n \n-\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n+\tif (sa.rc_channel &&\n+\t    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {\n \t\terr = -EADDRINUSE;\n \t} else {\n \t\t\/* Save source address *\/\n-\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n-\t\trfcomm_pi(sk)->channel = chan;\n+\t\tbacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);\n+\t\trfcomm_pi(sk)->channel = sa.rc_channel;\n \t\tsk->sk_state = BT_BOUND;\n \t}\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-9608","CWE_ID":"476","category":"security","commit_id":"0a709e2a10b8288a0cc383547924ecfe285cef89","commit_message":"From 0a709e2a10b8288a0cc383547924ecfe285cef89 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Wed, 14 Jun 2017 16:58:20 +0200\nSubject: [PATCH] avcodec\/dnxhd_parser: Do not return invalid value from\n dnxhd_find_frame_end() on error\n\nFixes: Null pointer dereference\n\nFixes: CVE-2017-9608\nFound-by: Yihan Lian\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 611b35627488a8d0763e75c25ee0875c5b7987dd)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/dnxhd_parser.c | 12 +++++++-----\n 1 file changed, 7 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/dnxhd_parser.c b\/libavcodec\/dnxhd_parser.c\nindex a1f632a620e..f1166be1007 100644\n--- a\/libavcodec\/dnxhd_parser.c\n+++ b\/libavcodec\/dnxhd_parser.c\n@@ -81,16 +81,18 @@ static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n+                int remaining;\n \n                 if (cid <= 0)\n                     continue;\n \n-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n-                if (dctx->remaining <= 0) {\n-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n-                    if (dctx->remaining <= 0)\n-                        return dctx->remaining;\n+                remaining = avpriv_dnxhd_get_frame_size(cid);\n+                if (remaining <= 0) {\n+                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n+                    if (remaining <= 0)\n+                        continue;\n                 }\n+                dctx->remaining = remaining;\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n \n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2019-9213","CWE_ID":"476","category":"security","commit_id":"0a1d52994d440e21def1c2174932410b4f2a98a1","commit_message":"From 0a1d52994d440e21def1c2174932410b4f2a98a1 Mon Sep 17 00:00:00 2001\nFrom: Jann Horn <jannh@google.com>\nDate: Wed, 27 Feb 2019 21:29:52 +0100\nSubject: mm: enforce min addr even if capable() in expand_downwards()\n\nsecurity_mmap_addr() does a capability check with current_cred(), but\nwe can reach this code from contexts like a VFS write handler where\ncurrent_cred() must not be used.\n\nThis can be abused on systems without SMAP to make NULL pointer\ndereferences exploitable again.\n\nFixes: 8869477a49c3 (\"security: protect from stack expansion into low vm addresses\")\nCc: stable@kernel.org\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/mmap.c | 7 +++----\n 1 file changed, 3 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mmap.c b\/mm\/mmap.c\nindex f901065c4c64..fc1809b1bed6 100644\n--- a\/mm\/mmap.c\n+++ b\/mm\/mmap.c\n@@ -2426,12 +2426,11 @@ int expand_downwards(struct vm_area_struct *vma,\n {\n \tstruct mm_struct *mm = vma->vm_mm;\n \tstruct vm_area_struct *prev;\n-\tint error;\n+\tint error = 0;\n \n \taddress &= PAGE_MASK;\n-\terror = security_mmap_addr(address);\n-\tif (error)\n-\t\treturn error;\n+\tif (address < mmap_min_addr)\n+\t\treturn -EPERM;\n \n \t\/* Enforce stack_guard_gap *\/\n \tprev = vma->vm_prev;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-19200","CWE_ID":"476","category":"security","commit_id":"f58c25069cf4a986fe17a80c5b38687e31feb539","commit_message":"From f58c25069cf4a986fe17a80c5b38687e31feb539 Mon Sep 17 00:00:00 2001\nFrom: Sebastian Pipping <sebastian@pipping.org>\nDate: Wed, 10 Oct 2018 14:49:51 +0200\nSubject: [PATCH] ResetUri: Protect against NULL\n\n---\n src\/UriCommon.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/src\/UriCommon.c b\/src\/UriCommon.c\nindex 3775306..039beda 100644\n--- a\/src\/UriCommon.c\n+++ b\/src\/UriCommon.c\n@@ -75,6 +75,9 @@\n \n \n void URI_FUNC(ResetUri)(URI_TYPE(Uri) * uri) {\n+\tif (uri == NULL) {\n+\t\treturn;\n+\t}\n \tmemset(uri, 0, sizeof(URI_TYPE(Uri)));\n }\n \n","owner":"uriparser","repo":"uriparser","source":"cve"},{"CVE_ID":"CVE-2017-16914","CWE_ID":"476","category":"security","commit_id":"be6123df1ea8f01ee2f896a16c2b7be3e4557a5a","commit_message":"From be6123df1ea8f01ee2f896a16c2b7be3e4557a5a Mon Sep 17 00:00:00 2001\nFrom: Shuah Khan <shuahkh@osg.samsung.com>\nDate: Thu, 7 Dec 2017 14:16:50 -0700\nSubject: usbip: fix stub_send_ret_submit() vulnerability to null\n transfer_buffer\n\nstub_send_ret_submit() handles urb with a potential null transfer_buffer,\nwhen it replays a packet with potential malicious data that could contain\na null buffer. Add a check for the condition when actual_length > 0 and\ntransfer_buffer is null.\n\nReported-by: Secunia Research <vuln@secunia.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Shuah Khan <shuahkh@osg.samsung.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/usb\/usbip\/stub_tx.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n(limited to 'drivers\/usb\/usbip')\n\n","diff_code":"diff --git a\/drivers\/usb\/usbip\/stub_tx.c b\/drivers\/usb\/usbip\/stub_tx.c\nindex b18bce96c212..53172b1f6257 100644\n--- a\/drivers\/usb\/usbip\/stub_tx.c\n+++ b\/drivers\/usb\/usbip\/stub_tx.c\n@@ -167,6 +167,13 @@ static int stub_send_ret_submit(struct stub_device *sdev)\n \t\tmemset(&pdu_header, 0, sizeof(pdu_header));\n \t\tmemset(&msg, 0, sizeof(msg));\n \n+\t\tif (urb->actual_length > 0 && !urb->transfer_buffer) {\n+\t\t\tdev_err(&sdev->udev->dev,\n+\t\t\t\t\"urb: actual_length %d transfer_buffer null\\n\",\n+\t\t\t\turb->actual_length);\n+\t\t\treturn -1;\n+\t\t}\n+\n \t\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)\n \t\t\tiovnum = 2 + urb->number_of_packets;\n \t\telse\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6497","CWE_ID":"476","category":"security","commit_id":"7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94","commit_message":"From 7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94 Mon Sep 17 00:00:00 2001\nFrom: Dirk Lemstra <dirk@git.imagemagick.org>\nDate: Sat, 11 Feb 2017 10:31:39 +0100\nSubject: [PATCH] Added missing null check.\n\n---\n coders\/psd.c | 7 +++++--\n 1 file changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/coders\/psd.c b\/coders\/psd.c\nindex 14e375b9ed..fb93c57dd1 100644\n--- a\/coders\/psd.c\n+++ b\/coders\/psd.c\n@@ -1284,8 +1284,11 @@ static MagickBooleanType ReadPSDChannel(Image *image,\n       }\n       mask=CloneImage(image,layer_info->mask.page.width,\n         layer_info->mask.page.height,MagickFalse,exception);\n-      mask->matte=MagickFalse;\n-      channel_image=mask;\n+      if (mask != (Image *) NULL)\n+        {\n+          mask->matte=MagickFalse;\n+          channel_image=mask;\n+        }\n     }\n \n   offset=TellBlob(image);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-18585","CWE_ID":"476","category":"security","commit_id":"8759da8db6ec9e866cb8eb143313f397f925bb4f","commit_message":"From 8759da8db6ec9e866cb8eb143313f397f925bb4f Mon Sep 17 00:00:00 2001\nFrom: Stuart Caie <kyzer@cabextract.org.uk>\nDate: Wed, 17 Oct 2018 11:29:03 +0100\nSubject: [PATCH] Avoid returning CHM file entries that are \"blank\" because\n they have embedded null bytes\n\n---\n libmspack\/ChangeLog     | 6 ++++++\n libmspack\/mspack\/chmd.c | 6 +++---\n 2 files changed, 9 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libmspack\/ChangeLog b\/libmspack\/ChangeLog\nindex cce7f2f..a5873b6 100644\n--- a\/libmspack\/ChangeLog\n+++ b\/libmspack\/ChangeLog\n@@ -1,3 +1,9 @@\n+2018-10-17  Stuart Caie <kyzer@cabextract.org.uk>\n+  \n+        * chmd_read_headers(): again reject files with blank filenames, this\n+        time because their 1st or 2nd byte is null, not because their length\n+        is zero.  Thanks again to Hanno B\u00f6ck for finding the issue.\n+\n 2018-10-16  Stuart Caie <kyzer@cabextract.org.uk>\n \n \t* Makefile.am: using automake _DEPENDENCIES for chmd_test appears to\ndiff --git a\/libmspack\/mspack\/chmd.c b\/libmspack\/mspack\/chmd.c\nindex b3f7fee..1d198bf 100644\n--- a\/libmspack\/mspack\/chmd.c\n+++ b\/libmspack\/mspack\/chmd.c\n@@ -447,14 +447,14 @@ static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh,\n     while (num_entries--) {\n       READ_ENCINT(name_len);\n       if (name_len > (unsigned int) (end - p)) goto chunk_end;\n-      \/* consider blank filenames to be an error *\/\n-      if (name_len == 0) goto chunk_end;\n       name = p; p += name_len;\n-\n       READ_ENCINT(section);\n       READ_ENCINT(offset);\n       READ_ENCINT(length);\n \n+      \/* ignore blank or one-char (e.g. \"\/\") filenames we'd return as blank *\/\n+      if (name_len < 2 || !name[0] || !name[1]) continue;\n+\n       \/* empty files and directory names are stored as a file entry at\n        * offset 0 with length 0. We want to keep empty files, but not\n        * directory names, which end with a \"\/\" *\/\n","owner":"kyz","repo":"libmspack","source":"cve"},{"CVE_ID":"CVE-2017-15306","CWE_ID":"476","category":"security","commit_id":"ac64115a66c18c01745bbd3c47a36b124e5fd8c0","commit_message":"From ac64115a66c18c01745bbd3c47a36b124e5fd8c0 Mon Sep 17 00:00:00 2001\nFrom: Greg Kurz <groug@kaod.org>\nDate: Thu, 14 Sep 2017 23:56:25 +0200\nSubject: [PATCH] KVM: PPC: Fix oops when checking KVM_CAP_PPC_HTM\n\nThe following program causes a kernel oops:\n\n#include <sys\/types.h>\n#include <sys\/stat.h>\n#include <fcntl.h>\n#include <sys\/ioctl.h>\n#include <linux\/kvm.h>\n\nmain()\n{\n    int fd = open(\"\/dev\/kvm\", O_RDWR);\n    ioctl(fd, KVM_CHECK_EXTENSION, KVM_CAP_PPC_HTM);\n}\n\nThis happens because when using the global KVM fd with\nKVM_CHECK_EXTENSION, kvm_vm_ioctl_check_extension() gets\ncalled with a NULL kvm argument, which gets dereferenced\nin is_kvmppc_hv_enabled(). Spotted while reading the code.\n\nLet's use the hv_enabled fallback variable, like everywhere\nelse in this function.\n\nFixes: 23528bb21ee2 (\"KVM: PPC: Introduce KVM_CAP_PPC_HTM\")\nCc: stable@vger.kernel.org # v4.7+\nSigned-off-by: Greg Kurz <groug@kaod.org>\nReviewed-by: David Gibson <david@gibson.dropbear.id.au>\nReviewed-by: Thomas Huth <thuth@redhat.com>\nSigned-off-by: Paul Mackerras <paulus@ozlabs.org>\n---\n arch\/powerpc\/kvm\/powerpc.c | 3 +--\n 1 file changed, 1 insertion(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/powerpc\/kvm\/powerpc.c b\/arch\/powerpc\/kvm\/powerpc.c\nindex 3480faaf1ef88..ee279c7f48021 100644\n--- a\/arch\/powerpc\/kvm\/powerpc.c\n+++ b\/arch\/powerpc\/kvm\/powerpc.c\n@@ -644,8 +644,7 @@ int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)\n \t\tbreak;\n #endif\n \tcase KVM_CAP_PPC_HTM:\n-\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) &&\n-\t\t    is_kvmppc_hv_enabled(kvm);\n+\t\tr = cpu_has_feature(CPU_FTR_TM_COMP) && hv_enabled;\n \t\tbreak;\n \tdefault:\n \t\tr = 0;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-15861","CWE_ID":"476","category":"security","commit_id":"38e1766bc6e20108948aec8a0b222a4bad0254e9","commit_message":"From 38e1766bc6e20108948aec8a0b222a4bad0254e9 Mon Sep 17 00:00:00 2001\nFrom: Daniel Stone <daniels@collabora.com>\nDate: Mon, 26 Jun 2017 17:21:45 +0100\nSubject: [PATCH] xkbcomp: Don't falsely promise from ExprResolveLhs\n\nEvery user of ExprReturnLhs goes on to unconditionally dereference the\nfield return, which can be NULL if xkb_intern_atom fails. Return false\nif this is the case, so we fail safely.\n\ntestcase: splice geometry data into interp\n\nSigned-off-by: Daniel Stone <daniels@collabora.com>\n---\n src\/xkbcomp\/expr.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/xkbcomp\/expr.c b\/src\/xkbcomp\/expr.c\nindex 91713da..b5ab717 100644\n--- a\/src\/xkbcomp\/expr.c\n+++ b\/src\/xkbcomp\/expr.c\n@@ -42,7 +42,7 @@ ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n         *elem_rtrn = NULL;\n         *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n         *index_rtrn = NULL;\n-        return true;\n+        return (*field_rtrn != NULL);\n     case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n","owner":"xkbcommon","repo":"libxkbcommon","source":"cve"},{"CVE_ID":"CVE-2017-18216","CWE_ID":"476","category":"security","commit_id":"853bc26a7ea39e354b9f8889ae7ad1492ffa28d2","commit_message":"From 853bc26a7ea39e354b9f8889ae7ad1492ffa28d2 Mon Sep 17 00:00:00 2001\nFrom: alex chen <alex.chen@huawei.com>\nDate: Wed, 15 Nov 2017 17:31:48 -0800\nSubject: [PATCH] ocfs2: subsystem.su_mutex is required while accessing the\n item->ci_parent\n\nThe subsystem.su_mutex is required while accessing the item->ci_parent,\notherwise, NULL pointer dereference to the item->ci_parent will be\ntriggered in the following situation:\n\nadd node                     delete node\nsys_write\n vfs_write\n  configfs_write_file\n   o2nm_node_store\n    o2nm_node_local_write\n                             do_rmdir\n                              vfs_rmdir\n                               configfs_rmdir\n                                mutex_lock(&subsys->su_mutex);\n                                unlink_obj\n                                 item->ci_group = NULL;\n                                 item->ci_parent = NULL;\n\t to_o2nm_cluster_from_node\n\t  node->nd_item.ci_parent->ci_parent\n\t  BUG since of NULL pointer dereference to nd_item.ci_parent\n\nMoreover, the o2nm_cluster also should be protected by the\nsubsystem.su_mutex.\n\n[alex.chen@huawei.com: v2]\n  Link: http:\/\/lkml.kernel.org\/r\/59EEAA69.9080703@huawei.com\nLink: http:\/\/lkml.kernel.org\/r\/59E9B36A.10700@huawei.com\nSigned-off-by: Alex Chen <alex.chen@huawei.com>\nReviewed-by: Jun Piao <piaojun@huawei.com>\nReviewed-by: Joseph Qi <jiangqi903@gmail.com>\nCc: Mark Fasheh <mfasheh@versity.com>\nCc: Joel Becker <jlbec@evilplan.org>\nCc: Junxiao Bi <junxiao.bi@oracle.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/ocfs2\/cluster\/nodemanager.c | 63 +++++++++++++++++++++++++++++-----\n 1 file changed, 55 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ocfs2\/cluster\/nodemanager.c b\/fs\/ocfs2\/cluster\/nodemanager.c\nindex a51200ece93df..da64c3a20eebd 100644\n--- a\/fs\/ocfs2\/cluster\/nodemanager.c\n+++ b\/fs\/ocfs2\/cluster\/nodemanager.c\n@@ -40,6 +40,9 @@ char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n \t\t\"panic\",\t\/* O2NM_FENCE_PANIC *\/\n };\n \n+static inline void o2nm_lock_subsystem(void);\n+static inline void o2nm_unlock_subsystem(void);\n+\n struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n {\n \tstruct o2nm_node *node = NULL;\n@@ -181,7 +184,10 @@ static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n {\n \t\/* through the first node_set .parent\n \t * mycluster\/nodes\/mynode == o2nm_cluster->o2nm_node_group->o2nm_node *\/\n-\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\tif (node->nd_item.ci_parent)\n+\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n+\telse\n+\t\treturn NULL;\n }\n \n enum {\n@@ -194,7 +200,7 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\t\t\t   size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tint ret = 0;\n@@ -214,6 +220,13 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; \/* XXX *\/\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\to2nm_unlock_subsystem();\n+\t\treturn -EINVAL;\n+\t}\n+\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (cluster->cl_nodes[tmp])\n \t\tret = -EEXIST;\n@@ -226,6 +239,8 @@ static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n \t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n+\to2nm_unlock_subsystem();\n+\n \tif (ret)\n \t\treturn ret;\n \n@@ -269,7 +284,7 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\t\t\t\t    size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tint ret, i;\n \tstruct rb_node **p, *parent;\n \tunsigned int octets[4];\n@@ -286,6 +301,13 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n \t}\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\to2nm_unlock_subsystem();\n+\t\treturn -EINVAL;\n+\t}\n+\n \tret = 0;\n \twrite_lock(&cluster->cl_nodes_lock);\n \tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n@@ -298,6 +320,8 @@ static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n \t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n \t}\n \twrite_unlock(&cluster->cl_nodes_lock);\n+\to2nm_unlock_subsystem();\n+\n \tif (ret)\n \t\treturn ret;\n \n@@ -315,7 +339,7 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\t\t\t     size_t count)\n {\n \tstruct o2nm_node *node = to_o2nm_node(item);\n-\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n+\tstruct o2nm_cluster *cluster;\n \tunsigned long tmp;\n \tchar *p = (char *)page;\n \tssize_t ret;\n@@ -333,17 +357,26 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n \t\treturn -EINVAL; \/* XXX *\/\n \n+\to2nm_lock_subsystem();\n+\tcluster = to_o2nm_cluster_from_node(node);\n+\tif (!cluster) {\n+\t\tret = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\n \t\/* the only failure case is trying to set a new local node\n \t * when a different one is already set *\/\n \tif (tmp && tmp == cluster->cl_has_local &&\n-\t    cluster->cl_local_node != node->nd_num)\n-\t\treturn -EBUSY;\n+\t    cluster->cl_local_node != node->nd_num) {\n+\t\tret = -EBUSY;\n+\t\tgoto out;\n+\t}\n \n \t\/* bring up the rx thread if we're setting the new local node. *\/\n \tif (tmp && !cluster->cl_has_local) {\n \t\tret = o2net_start_listening(node);\n \t\tif (ret)\n-\t\t\treturn ret;\n+\t\t\tgoto out;\n \t}\n \n \tif (!tmp && cluster->cl_has_local &&\n@@ -358,7 +391,11 @@ static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n \t\tcluster->cl_local_node = node->nd_num;\n \t}\n \n-\treturn count;\n+\tret = count;\n+\n+out:\n+\to2nm_unlock_subsystem();\n+\treturn ret;\n }\n \n CONFIGFS_ATTR(o2nm_node_, num);\n@@ -738,6 +775,16 @@ static struct o2nm_cluster_group o2nm_cluster_group = {\n \t},\n };\n \n+static inline void o2nm_lock_subsystem(void)\n+{\n+\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n+}\n+\n+static inline void o2nm_unlock_subsystem(void)\n+{\n+\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n+}\n+\n int o2nm_depend_item(struct config_item *item)\n {\n \treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-14225","CWE_ID":"476","category":"security","commit_id":"837cb4325b712ff1aab531bf41668933f61d75d2","commit_message":"From 837cb4325b712ff1aab531bf41668933f61d75d2 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Tue, 22 Aug 2017 11:02:38 +0200\nSubject: [PATCH] ffprobe: Fix null pointer dereference with color primaries\n\nFound-by: AD-lab of venustech\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n ffprobe.c | 20 ++++++++++++--------\n 1 file changed, 12 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/ffprobe.c b\/ffprobe.c\nindex 50d7c1a777c..d4bdd9c0993 100644\n--- a\/ffprobe.c\n+++ b\/ffprobe.c\n@@ -1925,6 +1925,16 @@ static void print_pkt_side_data(WriterContext *w,\n     writer_print_section_footer(w);\n }\n \n+static void print_primaries(WriterContext *w, enum AVColorPrimaries color_primaries)\n+{\n+    const char *val = av_color_primaries_name(color_primaries);\n+    if (!val || color_primaries == AVCOL_PRI_UNSPECIFIED) {\n+        print_str_opt(\"color_primaries\", \"unknown\");\n+    } else {\n+        print_str(\"color_primaries\", val);\n+    }\n+}\n+\n static void clear_log(int need_lock)\n {\n     int i;\n@@ -2116,10 +2126,7 @@ static void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,\n         else\n             print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n \n-        if (frame->color_primaries != AVCOL_PRI_UNSPECIFIED)\n-            print_str(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n-        else\n-            print_str_opt(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n+        print_primaries(w, frame->color_primaries);\n \n         if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n             print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n@@ -2516,10 +2523,7 @@ static int show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_id\n         else\n             print_str_opt(\"color_transfer\", av_color_transfer_name(par->color_trc));\n \n-        if (par->color_primaries != AVCOL_PRI_UNSPECIFIED)\n-            print_str(\"color_primaries\", av_color_primaries_name(par->color_primaries));\n-        else\n-            print_str_opt(\"color_primaries\", av_color_primaries_name(par->color_primaries));\n+        print_primaries(w, par->color_primaries);\n \n         if (par->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n             print_str(\"chroma_location\", av_chroma_location_name(par->chroma_location));\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-8825","CWE_ID":"476","category":"security","commit_id":"1fe8fbc032ccda1db9af66d93016b49c16c1f22d","commit_message":"From 1fe8fbc032ccda1db9af66d93016b49c16c1f22d Mon Sep 17 00:00:00 2001\nFrom: Viet Hoa Dinh <dvh@fb.com>\nDate: Sun, 7 May 2017 15:58:41 -0700\nSubject: [PATCH] Fixed crash #274\n\n---\n src\/low-level\/imf\/mailimf.c | 12 ++++++++++++\n 1 file changed, 12 insertions(+)\n\n","diff_code":"diff --git a\/src\/low-level\/imf\/mailimf.c b\/src\/low-level\/imf\/mailimf.c\nindex 4554f1ce..b557070d 100644\n--- a\/src\/low-level\/imf\/mailimf.c\n+++ b\/src\/low-level\/imf\/mailimf.c\n@@ -3083,6 +3083,7 @@ static int mailimf_group_parse(const char * message, size_t length,\n   struct mailimf_group * group;\n   int r;\n   int res;\n+  clist * list;\n \n   cur_token = * indx;\n \n@@ -3110,6 +3111,17 @@ static int mailimf_group_parse(const char * message, size_t length,\n       res = r;\n       goto free_display_name;\n     }\n+    list = clist_new();\n+    if (list == NULL) {\n+      res = MAILIMF_ERROR_MEMORY;\n+      goto free_display_name;\n+    }\n+    mailbox_list = mailimf_mailbox_list_new(list);\n+    if (mailbox_list == NULL) {\n+      res = MAILIMF_ERROR_MEMORY;\n+      clist_free(list);\n+      goto free_display_name;\n+    }\n     break;\n   default:\n     res = r;\n","owner":"dinhviethoa","repo":"libetpan","source":"cve"},{"CVE_ID":"CVE-2016-5354","CWE_ID":"476","category":"security","commit_id":"2cb5985bf47bdc8bea78d28483ed224abdd33dc6","commit_message":"From 2cb5985bf47bdc8bea78d28483ed224abdd33dc6 Mon Sep 17 00:00:00 2001\nFrom: Michael Mann <mmann78@netscape.net>\nDate: Sun, 1 May 2016 12:55:23 -0400\nSubject: [PATCH] Make class \"type\" for USB conversations.\n\nUSB dissectors can't assume that only their class type has been passed around in the conversation.  Make explicit check that class type expected matches the dissector and stop\/prevent dissection if there isn't a match.\n\nBug: 12356\nChange-Id: Ib23973a4ebd0fbb51952ffc118daf95e3389a209\nReviewed-on: https:\/\/code.wireshark.org\/review\/15212\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nReviewed-by: Martin Kaiser <wireshark@kaiser.cx>\nPetri-Dish: Martin Kaiser <wireshark@kaiser.cx>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n---\n epan\/dissectors\/packet-u3v.c            | 4 ++++\n epan\/dissectors\/packet-usb-audio.c      | 4 ++++\n epan\/dissectors\/packet-usb-masstorage.c | 5 ++++-\n epan\/dissectors\/packet-usb-video.c      | 4 ++++\n epan\/dissectors\/packet-usb.h            | 5 ++++-\n 5 files changed, 20 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/epan\/dissectors\/packet-u3v.c b\/epan\/dissectors\/packet-u3v.c\nindex 3359766a74..8e1a979edd 100644\n--- a\/epan\/dissectors\/packet-u3v.c\n+++ b\/epan\/dissectors\/packet-u3v.c\n@@ -1683,6 +1683,10 @@ dissect_u3v(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n     if (!u3v_conv_info) {\n         u3v_conv_info = wmem_new0(wmem_file_scope(), u3v_conv_info_t);\n         usb_conv_info->class_data = u3v_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_U3V;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_U3V) {\n+        \/* Don't dissect if another USB type is in the conversation *\/\n+        return 0;\n     }\n \n     prefix = tvb_get_letohl(tvb, 0);\ndiff --git a\/epan\/dissectors\/packet-usb-audio.c b\/epan\/dissectors\/packet-usb-audio.c\nindex 90c8e74aa3..df6e9ef7df 100644\n--- a\/epan\/dissectors\/packet-usb-audio.c\n+++ b\/epan\/dissectors\/packet-usb-audio.c\n@@ -435,8 +435,12 @@ dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n     if(!audio_conv_info) {\n         audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n         usb_conv_info->class_data = audio_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n         \/* XXX - set reasonable default values for all components\n            that are not filled in by this function *\/\n+    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n+        \/* Don't dissect if another USB type is in the conversation *\/\n+        return 0;\n     }\n     audio_conv_info->ver_major = ver_major;\n     offset += 2;\ndiff --git a\/epan\/dissectors\/packet-usb-masstorage.c b\/epan\/dissectors\/packet-usb-masstorage.c\nindex 743775be72..919f7ef364 100644\n--- a\/epan\/dissectors\/packet-usb-masstorage.c\n+++ b\/epan\/dissectors\/packet-usb-masstorage.c\n@@ -199,9 +199,12 @@ dissect_usb_ms_bulk(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree,\n         usb_ms_conv_info->itl=wmem_tree_new(wmem_file_scope());\n         usb_ms_conv_info->itlq=wmem_tree_new(wmem_file_scope());\n         usb_conv_info->class_data=usb_ms_conv_info;\n+        usb_conv_info->class_data_type = USB_CONV_MASS_STORAGE;\n+    } else if (usb_conv_info->class_data_type != USB_CONV_MASS_STORAGE) {\n+        \/* Don't dissect if another USB type is in the conversation *\/\n+        return 0;\n     }\n \n-\n     is_request=(pinfo->srcport==NO_ENDPOINT);\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"USBMS\");\ndiff --git a\/epan\/dissectors\/packet-usb-video.c b\/epan\/dissectors\/packet-usb-video.c\nindex 0bc292000f..3bf08f6156 100644\n--- a\/epan\/dissectors\/packet-usb-video.c\n+++ b\/epan\/dissectors\/packet-usb-video.c\n@@ -1035,6 +1035,10 @@ dissect_usb_video_control_interface_descriptor(proto_tree *parent_tree, tvbuff_t\n             video_conv_info = wmem_new(wmem_file_scope(), video_conv_info_t);\n             video_conv_info->entities = wmem_tree_new(wmem_file_scope());\n             usb_conv_info->class_data = video_conv_info;\n+            usb_conv_info->class_data_type = USB_CONV_VIDEO;\n+        } else if (usb_conv_info->class_data_type != USB_CONV_VIDEO) {\n+            \/* Stop dissection if another USB type is in the conversation *\/\n+            return descriptor_len;\n         }\n \n         entity = (video_entity_t*) wmem_tree_lookup32(video_conv_info->entities, entity_id);\ndiff --git a\/epan\/dissectors\/packet-usb.h b\/epan\/dissectors\/packet-usb.h\nindex 20ecc80b04..261592db5d 100644\n--- a\/epan\/dissectors\/packet-usb.h\n+++ b\/epan\/dissectors\/packet-usb.h\n@@ -90,6 +90,8 @@ typedef struct _usb_trans_info_t {\n     guint64 usb_id;\n } usb_trans_info_t;\n \n+enum usb_conv_class_data_type {USB_CONV_UNKNOWN = 0, USB_CONV_U3V, USB_CONV_AUDIO, USB_CONV_VIDEO, USB_CONV_MASS_STORAGE};\n+\n \/* Conversation Structure\n  * there is one such structure for each device\/endpoint conversation *\/\n struct _usb_conv_info_t {\n@@ -113,7 +115,8 @@ struct _usb_conv_info_t {\n     wmem_tree_t *transactions;\n     usb_trans_info_t *usb_trans_info; \/* pointer to the current transaction *\/\n \n-    void *class_data;\t\/* private class\/id decode data *\/\n+    void *class_data;           \/* private class\/id decode data *\/\n+    enum usb_conv_class_data_type class_data_type;\n \n     wmem_array_t *alt_settings;\n };\n","owner":"wireshark","repo":"wireshark","source":"cve"},{"CVE_ID":"CVE-2017-1000471","CWE_ID":"476","category":"security","commit_id":"5e6be61e42448f503e75e287dc332b1ecbf2a665","commit_message":"From 5e6be61e42448f503e75e287dc332b1ecbf2a665 Mon Sep 17 00:00:00 2001\nFrom: \"K. Reid Wightman\" <wightman@digitalbond.com>\nDate: Tue, 17 Oct 2017 22:03:49 -0400\nSubject: [PATCH] Fix a null pointer dereference, if initial walloc() fails or\n wrealloc() fails\n\n---\n src\/cgi.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/cgi.c b\/src\/cgi.c\nindex 85b0cfc0..ee4e213e 100644\n--- a\/src\/cgi.c\n+++ b\/src\/cgi.c\n@@ -137,7 +137,7 @@ PUBLIC bool cgiHandler(Webs *wp)\n     if (strchr(wp->query, '=') == NULL) {\n         query = sclone(wp->query);\n         websDecodeUrl(query, query, strlen(query));\n-        for (cp = stok(query, \" \", &tok); cp != NULL; ) {\n+        for (cp = stok(query, \" \", &tok); cp != NULL && argp != NULL; ) {\n             *(argp+n) = cp;\n             trace(5, \"ARG[%d] %s\", n, argp[n-1]);\n             n++;\n","owner":"embedthis","repo":"goahead","source":"cve"},{"CVE_ID":"CVE-2018-13093","CWE_ID":"476","category":"security","commit_id":"afca6c5b2595fc44383919fba740c194b0b76aff","commit_message":"From afca6c5b2595fc44383919fba740c194b0b76aff Mon Sep 17 00:00:00 2001\nFrom: Dave Chinner <dchinner@redhat.com>\nDate: Tue, 17 Apr 2018 17:17:34 -0700\nSubject: [PATCH] xfs: validate cached inodes are free when allocated\n\nA recent fuzzed filesystem image cached random dcache corruption\nwhen the reproducer was run. This often showed up as panics in\nlookup_slow() on a null inode->i_ops pointer when doing pathwalks.\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000000\n....\nCall Trace:\n lookup_slow+0x44\/0x60\n walk_component+0x3dd\/0x9f0\n link_path_walk+0x4a7\/0x830\n path_lookupat+0xc1\/0x470\n filename_lookup+0x129\/0x270\n user_path_at_empty+0x36\/0x40\n path_listxattr+0x98\/0x110\n SyS_listxattr+0x13\/0x20\n do_syscall_64+0xf5\/0x280\n entry_SYSCALL_64_after_hwframe+0x42\/0xb7\n\nbut had many different failure modes including deadlocks trying to\nlock the inode that was just allocated or KASAN reports of\nuse-after-free violations.\n\nThe cause of the problem was a corrupt INOBT on a v4 fs where the\nroot inode was marked as free in the inobt record. Hence when we\nallocated an inode, it chose the root inode to allocate, found it in\nthe cache and re-initialised it.\n\nWe recently fixed a similar inode allocation issue caused by inobt\nrecord corruption problem in xfs_iget_cache_miss() in commit\nee457001ed6c (\"xfs: catch inode allocation state mismatch\ncorruption\"). This change adds similar checks to the cache-hit path\nto catch it, and turns the reproducer into a corruption shutdown\nsituation.\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-Off-By: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Carlos Maiolino <cmaiolino@redhat.com>\nReviewed-by: Darrick J. Wong <darrick.wong@oracle.com>\n[darrick: fix typos in comment]\nSigned-off-by: Darrick J. Wong <darrick.wong@oracle.com>\n---\n fs\/xfs\/xfs_icache.c | 73 +++++++++++++++++++++++++++++----------------\n 1 file changed, 48 insertions(+), 25 deletions(-)\n\n","diff_code":"diff --git a\/fs\/xfs\/xfs_icache.c b\/fs\/xfs\/xfs_icache.c\nindex 9a18f69f6e96c..817899961f48a 100644\n--- a\/fs\/xfs\/xfs_icache.c\n+++ b\/fs\/xfs\/xfs_icache.c\n@@ -308,6 +308,46 @@ xfs_reinit_inode(\n \treturn error;\n }\n \n+\/*\n+ * If we are allocating a new inode, then check what was returned is\n+ * actually a free, empty inode. If we are not allocating an inode,\n+ * then check we didn't find a free inode.\n+ *\n+ * Returns:\n+ *\t0\t\tif the inode free state matches the lookup context\n+ *\t-ENOENT\t\tif the inode is free and we are not allocating\n+ *\t-EFSCORRUPTED\tif there is any state mismatch at all\n+ *\/\n+static int\n+xfs_iget_check_free_state(\n+\tstruct xfs_inode\t*ip,\n+\tint\t\t\tflags)\n+{\n+\tif (flags & XFS_IGET_CREATE) {\n+\t\t\/* should be a free inode *\/\n+\t\tif (VFS_I(ip)->i_mode != 0) {\n+\t\t\txfs_warn(ip->i_mount,\n+\"Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)\",\n+\t\t\t\tip->i_ino, VFS_I(ip)->i_mode);\n+\t\t\treturn -EFSCORRUPTED;\n+\t\t}\n+\n+\t\tif (ip->i_d.di_nblocks != 0) {\n+\t\t\txfs_warn(ip->i_mount,\n+\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n+\t\t\t\tip->i_ino);\n+\t\t\treturn -EFSCORRUPTED;\n+\t\t}\n+\t\treturn 0;\n+\t}\n+\n+\t\/* should be an allocated inode *\/\n+\tif (VFS_I(ip)->i_mode == 0)\n+\t\treturn -ENOENT;\n+\n+\treturn 0;\n+}\n+\n \/*\n  * Check the validity of the inode we just found it the cache\n  *\/\n@@ -357,12 +397,12 @@ xfs_iget_cache_hit(\n \t}\n \n \t\/*\n-\t * If lookup is racing with unlink return an error immediately.\n+\t * Check the inode free state is valid. This also detects lookup\n+\t * racing with unlinks.\n \t *\/\n-\tif (VFS_I(ip)->i_mode == 0 && !(flags & XFS_IGET_CREATE)) {\n-\t\terror = -ENOENT;\n+\terror = xfs_iget_check_free_state(ip, flags);\n+\tif (error)\n \t\tgoto out_error;\n-\t}\n \n \t\/*\n \t * If IRECLAIMABLE is set, we've torn down the VFS inode already.\n@@ -485,29 +525,12 @@ xfs_iget_cache_miss(\n \n \n \t\/*\n-\t * If we are allocating a new inode, then check what was returned is\n-\t * actually a free, empty inode. If we are not allocating an inode,\n-\t * the check we didn't find a free inode.\n+\t * Check the inode free state is valid. This also detects lookup\n+\t * racing with unlinks.\n \t *\/\n-\tif (flags & XFS_IGET_CREATE) {\n-\t\tif (VFS_I(ip)->i_mode != 0) {\n-\t\t\txfs_warn(mp,\n-\"Corruption detected! Free inode 0x%llx not marked free on disk\",\n-\t\t\t\tino);\n-\t\t\terror = -EFSCORRUPTED;\n-\t\t\tgoto out_destroy;\n-\t\t}\n-\t\tif (ip->i_d.di_nblocks != 0) {\n-\t\t\txfs_warn(mp,\n-\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n-\t\t\t\tino);\n-\t\t\terror = -EFSCORRUPTED;\n-\t\t\tgoto out_destroy;\n-\t\t}\n-\t} else if (VFS_I(ip)->i_mode == 0) {\n-\t\terror = -ENOENT;\n+\terror = xfs_iget_check_free_state(ip, flags);\n+\tif (error)\n \t\tgoto out_destroy;\n-\t}\n \n \t\/*\n \t * Preload the radix tree so we can insert safely under the\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-1092","CWE_ID":"476","category":"security","commit_id":"8e4b5eae5decd9dfe5a4ee369c22028f90ab4c44","commit_message":"From 8e4b5eae5decd9dfe5a4ee369c22028f90ab4c44 Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Thu, 29 Mar 2018 21:56:09 -0400\nSubject: ext4: fail ext4_iget for root directory if unallocated\n\nIf the root directory has an i_links_count of zero, then when the file\nsystem is mounted, then when ext4_fill_super() notices the problem and\ntries to call iput() the root directory in the error return path,\next4_evict_inode() will try to free the inode on disk, before all of\nthe file system structures are set up, and this will result in an OOPS\ncaused by a NULL pointer dereference.\n\nThis issue has been assigned CVE-2018-1092.\n\nhttps:\/\/bugzilla.kernel.org\/show_bug.cgi?id=199179\nhttps:\/\/bugzilla.redhat.com\/show_bug.cgi?id=1560777\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@vger.kernel.org\n---\n fs\/ext4\/inode.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/fs\/ext4\/inode.c b\/fs\/ext4\/inode.c\nindex 435965598cb8..18aa2ef963ad 100644\n--- a\/fs\/ext4\/inode.c\n+++ b\/fs\/ext4\/inode.c\n@@ -4732,6 +4732,12 @@ struct inode *ext4_iget(struct super_block *sb, unsigned long ino)\n \t\tgoto bad_inode;\n \traw_inode = ext4_raw_inode(&iloc);\n \n+\tif ((ino == EXT4_ROOT_INO) && (raw_inode->i_links_count == 0)) {\n+\t\tEXT4_ERROR_INODE(inode, \"root inode unallocated\");\n+\t\tret = -EFSCORRUPTED;\n+\t\tgoto bad_inode;\n+\t}\n+\n \tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n \t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n \t\tif (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10147","CWE_ID":"476","category":"security","commit_id":"48a992727d82cb7db076fa15d372178743b1f4cd","commit_message":"From 48a992727d82cb7db076fa15d372178743b1f4cd Mon Sep 17 00:00:00 2001\nFrom: tim <tim.c.chen@linux.intel.com>\nDate: Mon, 5 Dec 2016 11:46:31 -0800\nSubject: [PATCH] crypto: mcryptd - Check mcryptd algorithm compatibility\n\nAlgorithms not compatible with mcryptd could be spawned by mcryptd\nwith a direct crypto_alloc_tfm invocation using a \"mcryptd(alg)\" name\nconstruct.  This causes mcryptd to crash the kernel if an arbitrary\n\"alg\" is incompatible and not intended to be used with mcryptd.  It is\nan issue if AF_ALG tries to spawn mcryptd(alg) to expose it externally.\nBut such algorithms must be used internally and not be exposed.\n\nWe added a check to enforce that only internal algorithms are allowed\nwith mcryptd at the time mcryptd is spawning an algorithm.\n\nLink: http:\/\/marc.info\/?l=linux-crypto-vger&m=148063683310477&w=2\nCc: stable@vger.kernel.org\nReported-by: Mikulas Patocka <mpatocka@redhat.com>\nSigned-off-by: Tim Chen <tim.c.chen@linux.intel.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\n---\n crypto\/mcryptd.c | 19 ++++++++++++-------\n 1 file changed, 12 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/mcryptd.c b\/crypto\/mcryptd.c\nindex 94ee44acd4656..c207458d62993 100644\n--- a\/crypto\/mcryptd.c\n+++ b\/crypto\/mcryptd.c\n@@ -254,18 +254,22 @@ static void *mcryptd_alloc_instance(struct crypto_alg *alg, unsigned int head,\n \tgoto out;\n }\n \n-static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,\n+static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,\n \t\t\t\t\t  u32 *mask)\n {\n \tstruct crypto_attr_type *algt;\n \n \talgt = crypto_get_attr_type(tb);\n \tif (IS_ERR(algt))\n-\t\treturn;\n-\tif ((algt->type & CRYPTO_ALG_INTERNAL))\n-\t\t*type |= CRYPTO_ALG_INTERNAL;\n-\tif ((algt->mask & CRYPTO_ALG_INTERNAL))\n-\t\t*mask |= CRYPTO_ALG_INTERNAL;\n+\t\treturn false;\n+\n+\t*type |= algt->type & CRYPTO_ALG_INTERNAL;\n+\t*mask |= algt->mask & CRYPTO_ALG_INTERNAL;\n+\n+\tif (*type & *mask & CRYPTO_ALG_INTERNAL)\n+\t\treturn true;\n+\telse\n+\t\treturn false;\n }\n \n static int mcryptd_hash_init_tfm(struct crypto_tfm *tfm)\n@@ -492,7 +496,8 @@ static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n \tu32 mask = 0;\n \tint err;\n \n-\tmcryptd_check_internal(tb, &type, &mask);\n+\tif (!mcryptd_check_internal(tb, &type, &mask))\n+\t\treturn -EINVAL;\n \n \thalg = ahash_attr_alg(tb[1], type, mask);\n \tif (IS_ERR(halg))\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-1094","CWE_ID":"476","category":"security","commit_id":"18db4b4e6fc31eda838dd1c1296d67dbcb3dc957","commit_message":"From 18db4b4e6fc31eda838dd1c1296d67dbcb3dc957 Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Thu, 29 Mar 2018 22:10:35 -0400\nSubject: ext4: don't allow r\/w mounts if metadata blocks overlap the\n superblock\n\nIf some metadata block, such as an allocation bitmap, overlaps the\nsuperblock, it's very likely that if the file system is mounted\nread\/write, the results will not be pretty.  So disallow r\/w mounts\nfor file systems corrupted in this particular way.\n\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@vger.kernel.org\n---\n fs\/ext4\/super.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/fs\/ext4\/super.c b\/fs\/ext4\/super.c\nindex 7cd022c344d1..edcfe6956eba 100644\n--- a\/fs\/ext4\/super.c\n+++ b\/fs\/ext4\/super.c\n@@ -2335,6 +2335,8 @@ static int ext4_check_descriptors(struct super_block *sb,\n \t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n \t\t\t\t \"Block bitmap for group %u overlaps \"\n \t\t\t\t \"superblock\", i);\n+\t\t\tif (!sb_rdonly(sb))\n+\t\t\t\treturn 0;\n \t\t}\n \t\tif (block_bitmap < first_block || block_bitmap > last_block) {\n \t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n@@ -2347,6 +2349,8 @@ static int ext4_check_descriptors(struct super_block *sb,\n \t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n \t\t\t\t \"Inode bitmap for group %u overlaps \"\n \t\t\t\t \"superblock\", i);\n+\t\t\tif (!sb_rdonly(sb))\n+\t\t\t\treturn 0;\n \t\t}\n \t\tif (inode_bitmap < first_block || inode_bitmap > last_block) {\n \t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n@@ -2359,6 +2363,8 @@ static int ext4_check_descriptors(struct super_block *sb,\n \t\t\text4_msg(sb, KERN_ERR, \"ext4_check_descriptors: \"\n \t\t\t\t \"Inode table for group %u overlaps \"\n \t\t\t\t \"superblock\", i);\n+\t\t\tif (!sb_rdonly(sb))\n+\t\t\t\treturn 0;\n \t\t}\n \t\tif (inode_table < first_block ||\n \t\t    inode_table + sbi->s_itb_per_group - 1 > last_block) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-6561","CWE_ID":"476","category":"security","commit_id":"6d1c73b5858fefc6161c7d686345f0dc887ea799","commit_message":"From 6d1c73b5858fefc6161c7d686345f0dc887ea799 Mon Sep 17 00:00:00 2001\nFrom: Dan Vatca <dan.vatca@gmail.com>\nDate: Thu, 20 Oct 2016 22:43:14 +0300\nSubject: [PATCH] 7483 SMB flush on pipe triggers NULL pointer dereference in\n module smbsrv Reviewed by: Gordon Ross <gwr@nexenta.com> Reviewed by: Matt\n Barden <matt.barden@nexenta.com> Reviewed by: Evan Layton\n <evan.layton@nexenta.com> Reviewed by: Dan McDonald <danmcd@omniti.com>\n Approved by: Gordon Ross <gwr@nexenta.com>\n\n---\n usr\/src\/uts\/common\/fs\/smbsrv\/smb2_flush.c | 10 ++-------\n usr\/src\/uts\/common\/fs\/smbsrv\/smb_flush.c  | 25 ++++-------------------\n usr\/src\/uts\/common\/fs\/smbsrv\/smb_ofile.c  | 22 ++++++++++++++++++++\n usr\/src\/uts\/common\/smbsrv\/smb_kproto.h    |  2 ++\n 4 files changed, 30 insertions(+), 29 deletions(-)\n\n","diff_code":"diff --git a\/usr\/src\/uts\/common\/fs\/smbsrv\/smb2_flush.c b\/usr\/src\/uts\/common\/fs\/smbsrv\/smb2_flush.c\nindex ecdf2fdcb87..82263d59366 100644\n--- a\/usr\/src\/uts\/common\/fs\/smbsrv\/smb2_flush.c\n+++ b\/usr\/src\/uts\/common\/fs\/smbsrv\/smb2_flush.c\n@@ -11,6 +11,7 @@\n \n \/*\n  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  *\/\n \n \/*\n@@ -23,7 +24,6 @@\n smb_sdrc_t\n smb2_flush(smb_request_t *sr)\n {\n-\tsmb_ofile_t *of = NULL;\n \tuint16_t StructSize;\n \tuint16_t reserved1;\n \tuint32_t reserved2;\n@@ -51,14 +51,8 @@ smb2_flush(smb_request_t *sr)\n \t\tsmb2sr_put_error(sr, status);\n \t\treturn (SDRC_SUCCESS);\n \t}\n-\tof = sr->fid_ofile;\n \n-\t\/*\n-\t * XXX - todo:\n-\t * Flush named pipe should drain writes.\n-\t *\/\n-\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n-\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n+\tsmb_ofile_flush(sr, sr->fid_ofile);\n \n \t\/*\n \t * SMB2 Flush reply\ndiff --git a\/usr\/src\/uts\/common\/fs\/smbsrv\/smb_flush.c b\/usr\/src\/uts\/common\/fs\/smbsrv\/smb_flush.c\nindex 5de347b6b55..1d210c3d899 100644\n--- a\/usr\/src\/uts\/common\/fs\/smbsrv\/smb_flush.c\n+++ b\/usr\/src\/uts\/common\/fs\/smbsrv\/smb_flush.c\n@@ -21,6 +21,8 @@\n \/*\n  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.\n  * Use is subject to license terms.\n+ *\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  *\/\n \n \/*\n@@ -40,8 +42,6 @@\n #include <smbsrv\/smb_fsops.h>\n \n \n-static void smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile);\n-\n \/*\n  * smb_com_flush\n  *\n@@ -90,15 +90,14 @@ smb_com_flush(smb_request_t *sr)\n \t\t\t    ERRDOS, ERRbadfid);\n \t\t\treturn (SDRC_ERROR);\n \t\t}\n-\n-\t\tsmb_flush_file(sr, sr->fid_ofile);\n+\t\tsmb_ofile_flush(sr, sr->fid_ofile);\n \t} else {\n \t\tflist = &sr->tid_tree->t_ofile_list;\n \t\tsmb_llist_enter(flist, RW_READER);\n \t\tfile = smb_llist_head(flist);\n \t\twhile (file) {\n \t\t\tmutex_enter(&file->f_mutex);\n-\t\t\tsmb_flush_file(sr, file);\n+\t\t\tsmb_ofile_flush(sr, file);\n \t\t\tmutex_exit(&file->f_mutex);\n \t\t\tfile = smb_llist_next(flist, file);\n \t\t}\n@@ -108,19 +107,3 @@ smb_com_flush(smb_request_t *sr)\n \trc = smbsr_encode_empty_result(sr);\n \treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n }\n-\n-\n-\/*\n- * smb_flush_file\n- *\n- * If writes on this file are not synchronous, flush it using the NFSv3\n- * commit interface.\n- *\/\n-static void\n-smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n-{\n-\tsr->user_cr = smb_ofile_getcred(ofile);\n-\n-\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n-\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n-}\ndiff --git a\/usr\/src\/uts\/common\/fs\/smbsrv\/smb_ofile.c b\/usr\/src\/uts\/common\/fs\/smbsrv\/smb_ofile.c\nindex 34ef5dc5261..582091d1dd6 100644\n--- a\/usr\/src\/uts\/common\/fs\/smbsrv\/smb_ofile.c\n+++ b\/usr\/src\/uts\/common\/fs\/smbsrv\/smb_ofile.c\n@@ -21,6 +21,7 @@\n \/*\n  * Copyright (c) 2007, 2010, Oracle and\/or its affiliates. All rights reserved.\n  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L. All rights reserved.\n  *\/\n \n \/*\n@@ -836,6 +837,27 @@ smb_ofile_seek(\n \treturn (rc);\n }\n \n+\/*\n+ * smb_ofile_flush\n+ *\n+ * If writes on this file are not synchronous, flush it using the NFSv3\n+ * commit interface.\n+ *\n+ * XXX - todo: Flush named pipe should drain writes.\n+ *\/\n+void\n+smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n+{\n+\tswitch (of->f_ftype) {\n+\tcase SMB_FTYPE_DISK:\n+\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n+\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n+\t\tbreak;\n+\tdefault:\n+\t\tbreak;\n+\t}\n+}\n+\n \/*\n  * smb_ofile_is_open\n  *\/\ndiff --git a\/usr\/src\/uts\/common\/smbsrv\/smb_kproto.h b\/usr\/src\/uts\/common\/smbsrv\/smb_kproto.h\nindex f394773c0ab..2dd8787aebf 100644\n--- a\/usr\/src\/uts\/common\/smbsrv\/smb_kproto.h\n+++ b\/usr\/src\/uts\/common\/smbsrv\/smb_kproto.h\n@@ -22,6 +22,7 @@\n \/*\n  * Copyright (c) 2007, 2010, Oracle and\/or its affiliates. All rights reserved.\n  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.\n+ * Copyright 2016 Syneto S.R.L.  All rights reserved.\n  *\/\n \n \/*\n@@ -673,6 +674,7 @@ void smb_ofile_close(smb_ofile_t *, int32_t);\n void smb_ofile_delete(void *);\n uint32_t smb_ofile_access(smb_ofile_t *, cred_t *, uint32_t);\n int smb_ofile_seek(smb_ofile_t *, ushort_t, int32_t, uint32_t *);\n+void smb_ofile_flush(smb_request_t *, smb_ofile_t *);\n boolean_t smb_ofile_hold(smb_ofile_t *);\n void smb_ofile_release(smb_ofile_t *);\n void smb_ofile_request_complete(smb_ofile_t *);\n","owner":"illumos","repo":"illumos-gate","source":"cve"},{"CVE_ID":"CVE-2017-16359","CWE_ID":"476","category":"security","commit_id":"62e39f34b2705131a2d08aff0c2e542c6a52cf0e","commit_message":"From 62e39f34b2705131a2d08aff0c2e542c6a52cf0e Mon Sep 17 00:00:00 2001\nFrom: Khairul Kasmiran <kazarmy@gmail.com>\nDate: Tue, 31 Oct 2017 23:35:41 +0800\nSubject: [PATCH] Fix #8764 - huge vd_aux caused pointer wraparound\n\n---\n libr\/bin\/format\/elf\/elf.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libr\/bin\/format\/elf\/elf.c b\/libr\/bin\/format\/elf\/elf.c\nindex b466c312cb..ba3d1d5404 100644\n--- a\/libr\/bin\/format\/elf\/elf.c\n+++ b\/libr\/bin\/format\/elf\/elf.c\n@@ -731,7 +731,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \tsdb_num_set (sdb, \"link\", shdr->sh_link, 0);\n \tsdb_set (sdb, \"link_section_name\", link_section_name, 0);\n \n-\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) {\n+\tfor (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && (end - (char *)defs > i); ++cnt) {\n \t\tSdb *sdb_verdef = sdb_new0 ();\n \t\tchar *vstart = ((char*)defs) + i;\n \t\tchar key[32] = {0};\n@@ -749,12 +749,12 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n \t\tint vdaux = verdef->vd_aux;\n-\t\tif (vdaux < 1) {\n+\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n \t\tvstart += vdaux;\n-\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n+\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n@@ -781,7 +781,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\t\tSdb *sdb_parent = sdb_new0 ();\n \t\t\tisum += aux.vda_next;\n \t\t\tvstart += aux.vda_next;\n-\t\t\tif (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) {\n+\t\t\tif (vstart > end || end - vstart < sizeof (Elf_(Verdaux))) {\n \t\t\t\tsdb_free (sdb_verdef);\n \t\t\t\tsdb_free (sdb_parent);\n \t\t\t\tgoto out_error;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2017-14641","CWE_ID":"476","category":"security","commit_id":"41cad602709436628f07b4c4f64e9ff7a611f687","commit_message":"From 41cad602709436628f07b4c4f64e9ff7a611f687 Mon Sep 17 00:00:00 2001\nFrom: Gilles Boccon-Gibod <bok@bok.net>\nDate: Sat, 9 Sep 2017 10:47:31 -0700\nSubject: [PATCH] fix for #184\n\n---\n Source\/C++\/MetaData\/Ap4MetaData.cpp | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/Source\/C++\/MetaData\/Ap4MetaData.cpp b\/Source\/C++\/MetaData\/Ap4MetaData.cpp\nindex 040bcacc..d2a9fbdb 100644\n--- a\/Source\/C++\/MetaData\/Ap4MetaData.cpp\n+++ b\/Source\/C++\/MetaData\/Ap4MetaData.cpp\n@@ -1258,7 +1258,8 @@ AP4_AtomMetaDataValue::ToInteger() const\n +---------------------------------------------------------------------*\/\n AP4_DataAtom::AP4_DataAtom(const AP4_MetaData::Value& value) :\n     AP4_Atom(AP4_ATOM_TYPE_DATA, AP4_ATOM_HEADER_SIZE),\n-    m_DataType(DATA_TYPE_BINARY)\n+    m_DataType(DATA_TYPE_BINARY),\n+    m_Source(NULL)\n {\n     AP4_MemoryByteStream* memory = new AP4_MemoryByteStream();\n     AP4_Size payload_size = 8;\n@@ -1334,7 +1335,8 @@ AP4_DataAtom::AP4_DataAtom(const AP4_MetaData::Value& value) :\n |   AP4_DataAtom::AP4_DataAtom\n +---------------------------------------------------------------------*\/\n AP4_DataAtom::AP4_DataAtom(AP4_UI32 size, AP4_ByteStream& stream) :\n-    AP4_Atom(AP4_ATOM_TYPE_DATA, size)\n+    AP4_Atom(AP4_ATOM_TYPE_DATA, size),\n+    m_Source(NULL)\n {\n     if (size < AP4_ATOM_HEADER_SIZE+8) return;\n \n","owner":"axiomatic-systems","repo":"Bento4","source":"cve"},{"CVE_ID":"CVE-2016-7130","CWE_ID":"476","category":"security","commit_id":"698a691724c0a949295991e5df091ce16f899e02","commit_message":"From 698a691724c0a949295991e5df091ce16f899e02 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 7 Aug 2016 16:26:52 -0700\nSubject: [PATCH] Fix bug #72750: wddx_deserialize null dereference\n\n---\n ext\/wddx\/tests\/bug72750.phpt | 34 ++++++++++++++++++++++++++++++++++\n ext\/wddx\/wddx.c              |  8 ++++++--\n 2 files changed, 40 insertions(+), 2 deletions(-)\n create mode 100644 ext\/wddx\/tests\/bug72750.phpt\n\n","diff_code":"diff --git a\/ext\/wddx\/tests\/bug72750.phpt b\/ext\/wddx\/tests\/bug72750.phpt\nnew file mode 100644\nindex 000000000000..3a6794df2803\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug72750.phpt\n@@ -0,0 +1,34 @@\n+--TEST--\n+Bug #72750: wddx_deserialize null dereference\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+\n+$xml = <<< XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+<header\/>\n+        <data>\n+                <struct>\n+                     <var name='aBinary'>\n+                         <binary length='11'>\\\\tYmluYXJRhdGE=<\/binary>\n+                     <\/var>\n+                 <\/struct>\n+        <\/data>\n+<\/wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+array(1) {\n+  [\"aBinary\"]=>\n+  string(0) \"\"\n+}\ndiff --git a\/ext\/wddx\/wddx.c b\/ext\/wddx\/wddx.c\nindex faadbfe1dfe3..1b2d103af18e 100644\n--- a\/ext\/wddx\/wddx.c\n+++ b\/ext\/wddx\/wddx.c\n@@ -959,8 +959,12 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \n \t\t\tnew_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);\n \t\t\tSTR_FREE(Z_STRVAL_P(ent1->data));\n-\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n-\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n+\t\t\tif (new_str) {\n+\t\t\t\tZ_STRVAL_P(ent1->data) = new_str;\n+\t\t\t\tZ_STRLEN_P(ent1->data) = new_len;\n+\t\t\t} else {\n+\t\t\t\tZVAL_EMPTY_STRING(ent1->data);\n+\t\t\t}\n \t\t}\n \n \t\t\/* Call __wakeup() method on the object. *\/\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2016-10218","CWE_ID":"476","category":"security","commit_id":"d621292fb2c8157d9899dcd83fd04dd250e30fe4","commit_message":"From d621292fb2c8157d9899dcd83fd04dd250e30fe4 Mon Sep 17 00:00:00 2001\nFrom: Michael Vrhel <michael.vrhel@artifex.com>\nDate: Thu, 29 Dec 2016 12:00:40 -0800\nSubject: [PATCH] Bug 697444 Unmatched transparency group pop\n\nThis issue can only occur if there is an unmatched group pop.\nIf the interpreter is doing that, then the interpreter is\nbroken.  With this bug the user is intentionally doing it.\nWe now throw and error when it occurs.\n---\n base\/gdevp14.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/base\/gdevp14.c b\/base\/gdevp14.c\nindex bec5a07..fd56ec9 100644\n--- a\/base\/gdevp14.c\n+++ b\/base\/gdevp14.c\n@@ -1066,6 +1066,9 @@ pdf14_pop_transparency_group(gs_gstate *pgs, pdf14_ctx *ctx,\n     gx_color_index drawn_comps = pdev->drawn_comps;\n     bool nonicc_conversion = true;\n \n+    if (nos == NULL)\n+        return_error(gs_error_unknownerror);  \/* Unmatched group pop *\/\n+\n     nos_num_color_comp = nos->parent_color_info_procs->num_components - nos->num_spots;\n     tos_num_color_comp = tos_num_color_comp - tos->num_spots;\n \n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7422","CWE_ID":"476","category":"security","commit_id":"973e7170dddefb491a48df5cba33b2ae151013a0","commit_message":"From 973e7170dddefb491a48df5cba33b2ae151013a0 Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Mon, 19 Sep 2016 23:55:45 +0530\nSubject: [PATCH] virtio: add check for descriptor's mapped address\n\nvirtio back end uses set of buffers to facilitate I\/O operations.\nIf its size is too large, 'cpu_physical_memory_map' could return\na null address. This would result in a null dereference while\nun-mapping descriptors. Add check to avoid it.\n\nReported-by: Qinghao Tang <luodalongde@gmail.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nReviewed-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Laszlo Ersek <lersek@redhat.com>\n---\n hw\/virtio\/virtio.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/hw\/virtio\/virtio.c b\/hw\/virtio\/virtio.c\nindex fcf3358..bb656b1 100644\n--- a\/hw\/virtio\/virtio.c\n+++ b\/hw\/virtio\/virtio.c\n@@ -495,6 +495,11 @@ static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iove\n         }\n \n         iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n+        if (!iov[num_sg].iov_base) {\n+            error_report(\"virtio: bogus descriptor or out of resources\");\n+            exit(1);\n+        }\n+\n         iov[num_sg].iov_len = len;\n         addr[num_sg] = pa;\n \n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-4054","CWE_ID":"476","category":"security","commit_id":"74d6e5f7de5ec736f71204b7b422af7380c19ac5","commit_message":"From 74d6e5f7de5ec736f71204b7b422af7380c19ac5 Mon Sep 17 00:00:00 2001\nFrom: Marko Kreen <markokr@gmail.com>\nDate: Wed, 8 Apr 2015 13:44:07 +0300\nSubject: [PATCH] Check if auth_user is set.\n\nFixes a crash if password packet appears before startup packet (#42).\n---\n src\/client.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/src\/client.c b\/src\/client.c\nindex 056fb969..7c4f1c76 100644\n--- a\/src\/client.c\n+++ b\/src\/client.c\n@@ -262,6 +262,12 @@ static bool handle_client_startup(PgSocket *client, PktHdr *pkt)\n \t\t}\n \t\tbreak;\n \tcase 'p':\t\t\/* PasswordMessage *\/\n+\t\t\/* too early *\/\n+\t\tif (!client->auth_user) {\n+\t\t\tdisconnect_client(client, true, \"client password pkt before startup packet\");\n+\t\t\treturn false;\n+\t\t}\n+\n \t\t\/* haven't requested it *\/\n \t\tif (cf_auth_type <= AUTH_TRUST) {\n \t\t\tdisconnect_client(client, true, \"unrequested passwd pkt\");\n","owner":"pgbouncer","repo":"pgbouncer","source":"cve"},{"CVE_ID":"CVE-2017-6197","CWE_ID":"476","category":"security","commit_id":"1ea23bd6040441a21fbcfba69dce9a01af03f989","commit_message":"From 1ea23bd6040441a21fbcfba69dce9a01af03f989 Mon Sep 17 00:00:00 2001\nFrom: pancake <pancake@nopcode.org>\nDate: Mon, 20 Feb 2017 12:08:06 +0100\nSubject: [PATCH] Fix #6816 - null deref in r_read_*\n\n---\n doc\/uncrustify.cfg      |  2 +-\n libr\/bin\/p\/bin_dex.c    |  2 +-\n libr\/include\/r_endian.h | 19 +++++++++++++++++++\n 3 files changed, 21 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/doc\/uncrustify.cfg b\/doc\/uncrustify.cfg\nindex df31ff1f09..42810ad098 100644\n--- a\/doc\/uncrustify.cfg\n+++ b\/doc\/uncrustify.cfg\n@@ -483,7 +483,7 @@ nl_before_block_comment         = 0\n nl_before_c_comment             = 0\n nl_before_cpp_comment           = 0\n nl_after_multiline_comment      = false\n-nl_after_label_colon            = force\n+nl_after_label_colon            = true\n nl_after_struct                 = 0\n nl_before_class                 = 0\n nl_after_class                  = 0\ndiff --git a\/libr\/bin\/p\/bin_dex.c b\/libr\/bin\/p\/bin_dex.c\nindex 2923ba7328..601b28a5d7 100644\n--- a\/libr\/bin\/p\/bin_dex.c\n+++ b\/libr\/bin\/p\/bin_dex.c\n@@ -1322,7 +1322,7 @@ static void parse_class(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c,\n \t    c->interfaces_offset <\n \t\t    bin->header.data_offset + bin->header.data_size) {\n \t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n-\t\tint types_list_size = r_read_le32(p);\n+\t\tint types_list_size = r_read_le32 (p);\n \t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n \t\t\treturn;\n \t\t}\ndiff --git a\/libr\/include\/r_endian.h b\/libr\/include\/r_endian.h\nindex 855f9e0dcd..1a2afc603a 100644\n--- a\/libr\/include\/r_endian.h\n+++ b\/libr\/include\/r_endian.h\n@@ -8,6 +8,9 @@ extern \"C\" {\n \/* Endian agnostic functions working on single byte. *\/\n \n static inline ut8 r_read_ble8(const void *src) {\n+\tif (!src) {\n+\t\treturn UT8_MAX;\n+\t}\n \treturn *(ut8 *)src;\n }\n \n@@ -114,6 +117,9 @@ static inline void r_write_at_be64(void *dest, ut64 val, size_t offset) {\n \/* Little Endian functions. *\/\n \n static inline ut8 r_read_le8(const void *src) {\n+\tif (!src) {\n+\t\treturn UT8_MAX;\n+\t}\n \treturn r_read_ble8 (src);\n }\n \n@@ -130,11 +136,17 @@ static inline void r_write_at_le8(void *dest, ut8 val, size_t offset) {\n }\n \n static inline ut16 r_read_le16(const void *src) {\n+\tif (!src) {\n+\t\treturn UT16_MAX;\n+\t}\n \tconst ut8 *s = (const ut8*)src;\n \treturn (((ut16)s[1]) << 8) | (((ut16)s[0]) << 0);\n }\n \n static inline ut16 r_read_at_le16(const void *src, size_t offset) {\n+\tif (!src) {\n+\t\treturn UT16_MAX;\n+\t}\n \tconst ut8 *s = (const ut8*)src + offset;\n \treturn r_read_le16 (s);\n }\n@@ -157,12 +169,18 @@ static inline void r_write_le24(void *_dest, ut32 val) {\n }\n \n static inline ut32 r_read_le32(const void *src) {\n+\tif (!src) {\n+\t\treturn UT32_MAX;\n+\t}\n \tconst ut8 *s = (const ut8*)src;\n \treturn (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |\n \t\t(((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);\n }\n \n static inline ut32 r_read_at_le32(const void *src, size_t offset) {\n+\tif (!src) {\n+\t\treturn UT32_MAX;\n+\t}\n \tconst ut8 *s = (const ut8*)src + offset;\n \treturn r_read_le32 (s);\n }\n@@ -426,6 +444,7 @@ static inline int UT8_SUB(ut8 *r, ut8 a, ut8 b) {\n \t}\n \treturn 1;\n }\n+\n #ifdef __cplusplus\n }\n #endif\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2018-13301","CWE_ID":"476","category":"security","commit_id":"2aa9047486dbff12d9e040f917e5f799ed2fd78b","commit_message":"From 2aa9047486dbff12d9e040f917e5f799ed2fd78b Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Wed, 27 Jun 2018 19:37:09 +0200\nSubject: [PATCH] avcodec\/mpeg4videodec: Check read profile before setting it\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nFixes: null pointer dereference\nFixes: ffmpeg_crash_7.avi\n\nFound-by: Thuan Pham, Marcel B\u00f6hme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/mpeg4videodec.c | 23 +++++++++++++++--------\n 1 file changed, 15 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/mpeg4videodec.c b\/libavcodec\/mpeg4videodec.c\nindex d0ebaac6e8e..54a84962444 100644\n--- a\/libavcodec\/mpeg4videodec.c\n+++ b\/libavcodec\/mpeg4videodec.c\n@@ -1980,15 +1980,15 @@ static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n     return 0;\n }\n \n-static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)\n+static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)\n {\n \n-    s->avctx->profile = get_bits(gb, 4);\n-    s->avctx->level   = get_bits(gb, 4);\n+    *profile = get_bits(gb, 4);\n+    *level   = get_bits(gb, 4);\n \n     \/\/ for Simple profile, level 0\n-    if (s->avctx->profile == 0 && s->avctx->level == 8) {\n-        s->avctx->level = 0;\n+    if (*profile == 0 && *level == 8) {\n+        *level = 0;\n     }\n \n     return 0;\n@@ -3211,13 +3211,19 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n         } else if (startcode == GOP_STARTCODE) {\n             mpeg4_decode_gop_header(s, gb);\n         } else if (startcode == VOS_STARTCODE) {\n-            mpeg4_decode_profile_level(s, gb);\n-            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n-                (s->avctx->level > 0 && s->avctx->level < 9)) {\n+            int profile, level;\n+            mpeg4_decode_profile_level(s, gb, &profile, &level);\n+            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n+                (level > 0 && level < 9)) {\n                 s->studio_profile = 1;\n                 next_start_code_studio(gb);\n                 extension_and_user_data(s, gb, 0);\n+            } else if (s->studio_profile) {\n+                avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\n+                return AVERROR_PATCHWELCOME;\n             }\n+            s->avctx->profile = profile;\n+            s->avctx->level   = level;\n         } else if (startcode == VISUAL_OBJ_STARTCODE) {\n             if (s->studio_profile) {\n                 if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n@@ -3238,6 +3244,7 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n     s->avctx->has_b_frames = !s->low_delay;\n \n     if (s->studio_profile) {\n+        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n         if (!s->avctx->bits_per_raw_sample) {\n             av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n             return AVERROR_INVALIDDATA;\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-14642","CWE_ID":"476","category":"security","commit_id":"22192de5367fa0cee985917f092be4060b7c00b0","commit_message":"From 22192de5367fa0cee985917f092be4060b7c00b0 Mon Sep 17 00:00:00 2001\nFrom: Gilles Boccon-Gibod <bok@bok.net>\nDate: Sat, 9 Sep 2017 10:56:33 -0700\nSubject: [PATCH] fix for #185\n\n---\n Source\/C++\/Core\/Ap4HdlrAtom.cpp | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/Source\/C++\/Core\/Ap4HdlrAtom.cpp b\/Source\/C++\/Core\/Ap4HdlrAtom.cpp\nindex 34aefca9..42c117c5 100644\n--- a\/Source\/C++\/Core\/Ap4HdlrAtom.cpp\n+++ b\/Source\/C++\/Core\/Ap4HdlrAtom.cpp\n@@ -80,9 +80,10 @@ AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size,\n     stream.ReadUI32(m_Reserved[2]);\n     \n     \/\/ read the name unless it is empty\n-    int name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n-    if (name_size == 0) return;\n+    if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;\n+    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n     char* name = new char[name_size+1];\n+    if (name == NULL) return;\n     stream.Read(name, name_size);\n     name[name_size] = '\\0'; \/\/ force a null termination\n     \/\/ handle a special case: the Quicktime files have a pascal\n","owner":"axiomatic-systems","repo":"Bento4","source":"cve"},{"CVE_ID":"CVE-2018-1094","CWE_ID":"476","category":"security","commit_id":"a45403b51582a87872927a3e0fc0a389c26867f1","commit_message":"From a45403b51582a87872927a3e0fc0a389c26867f1 Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Thu, 29 Mar 2018 22:10:31 -0400\nSubject: ext4: always initialize the crc32c checksum driver\n\nThe extended attribute code now uses the crc32c checksum for hashing\npurposes, so we should just always always initialize it.  We also want\nto prevent NULL pointer dereferences if one of the metadata checksum\nfeatures is enabled after the file sytsem is originally mounted.\n\nThis issue has been assigned CVE-2018-1094.\n\nhttps:\/\/bugzilla.kernel.org\/show_bug.cgi?id=199183\nhttps:\/\/bugzilla.redhat.com\/show_bug.cgi?id=1560788\n\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@vger.kernel.org\n---\n fs\/ext4\/super.c | 15 ++++++---------\n 1 file changed, 6 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/super.c b\/fs\/ext4\/super.c\nindex 9d1da40c1f62..7cd022c344d1 100644\n--- a\/fs\/ext4\/super.c\n+++ b\/fs\/ext4\/super.c\n@@ -3492,15 +3492,12 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n \t}\n \n \t\/* Load the checksum driver *\/\n-\tif (ext4_has_feature_metadata_csum(sb) ||\n-\t    ext4_has_feature_ea_inode(sb)) {\n-\t\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n-\t\tif (IS_ERR(sbi->s_chksum_driver)) {\n-\t\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n-\t\t\tret = PTR_ERR(sbi->s_chksum_driver);\n-\t\t\tsbi->s_chksum_driver = NULL;\n-\t\t\tgoto failed_mount;\n-\t\t}\n+\tsbi->s_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n+\tif (IS_ERR(sbi->s_chksum_driver)) {\n+\t\text4_msg(sb, KERN_ERR, \"Cannot load crc32c driver.\");\n+\t\tret = PTR_ERR(sbi->s_chksum_driver);\n+\t\tsbi->s_chksum_driver = NULL;\n+\t\tgoto failed_mount;\n \t}\n \n \t\/* Check superblock checksum *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10248","CWE_ID":"476","category":"security","commit_id":"2e82fa00466ae525339754bb3ab0a0474a31d4bd","commit_message":"From 2e82fa00466ae525339754bb3ab0a0474a31d4bd Mon Sep 17 00:00:00 2001\nFrom: Michael Adams <mdadams@ece.uvic.ca>\nDate: Wed, 19 Oct 2016 17:57:40 -0700\nSubject: [PATCH] Fixed an integral type promotion problem by adding a\n JAS_CAST. Modified the jpc_tsfb_synthesize function so that it will be a noop\n for an empty sequence (in order to avoid dereferencing a null pointer).\n\n---\n src\/libjasper\/include\/jasper\/jas_math.h | 18 ++++++++++++++++++\n src\/libjasper\/include\/jasper\/jas_seq.h  |  5 +++++\n src\/libjasper\/jpc\/jpc_dec.c             |  9 ++++++++-\n src\/libjasper\/jpc\/jpc_tsfb.c            |  3 ++-\n 4 files changed, 33 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/libjasper\/include\/jasper\/jas_math.h b\/src\/libjasper\/include\/jasper\/jas_math.h\nindex 3f1a933..91efc60 100644\n--- a\/src\/libjasper\/include\/jasper\/jas_math.h\n+++ b\/src\/libjasper\/include\/jasper\/jas_math.h\n@@ -112,6 +112,24 @@ extern \"C\" {\n #define\tJAS_ONES(n) \\\n   ((1 << (n)) - 1)\n \n+\/******************************************************************************\\\n+*\n+\\******************************************************************************\/\n+\n+__attribute__((no_sanitize(\"undefined\")))\n+inline static jas_int_asr(int x, int n)\n+{\n+\tassert(n >= 0);\n+\treturn x >> n;\n+}\n+\n+__attribute__((no_sanitize(\"undefined\")))\n+inline static jas_int_asl(int x, int n)\n+{\n+\tassert(n >= 0);\n+\treturn x << n;\n+}\n+\n \/******************************************************************************\\\n * Safe integer arithmetic (i.e., with overflow checking).\n \\******************************************************************************\/\ndiff --git a\/src\/libjasper\/include\/jasper\/jas_seq.h b\/src\/libjasper\/include\/jasper\/jas_seq.h\nindex e96548e..f470c84 100644\n--- a\/src\/libjasper\/include\/jasper\/jas_seq.h\n+++ b\/src\/libjasper\/include\/jasper\/jas_seq.h\n@@ -154,6 +154,9 @@ typedef jas_matrix_t jas_seq_t;\n #define jas_matrix_numcols(matrix) \\\n \t((matrix)->numcols_)\n \n+#define jas_matrix_size(matrix) \\\n+\t(jas_matrix_width(matrix) * jas_matrix_height(matrix))\n+\n \/* Get a matrix element. *\/\n #define jas_matrix_get(matrix, i, j) \\\n \t((matrix)->rows_[i][j])\n@@ -269,6 +272,8 @@ jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend);\n \t((s)->xstart_ = (x), (s)->ystart_ = (y), \\\n \t  (s)->xend_ = (s)->xstart_ + (s)->numcols_, \\\n \t  (s)->yend_ = (s)->ystart_ + (s)->numrows_)\n+#define jas_seq2d_size(s) \\\n+\t(jas_seq2d_width(s) * jas_seq2d_height(s))\n \n void jas_seq2d_bindsub(jas_matrix_t *s, jas_matrix_t *s1, int xstart,\n   int ystart, int xend, int yend);\ndiff --git a\/src\/libjasper\/jpc\/jpc_dec.c b\/src\/libjasper\/jpc\/jpc_dec.c\nindex 0d38c62..755c1c6 100644\n--- a\/src\/libjasper\/jpc\/jpc_dec.c\n+++ b\/src\/libjasper\/jpc\/jpc_dec.c\n@@ -1838,6 +1838,13 @@ static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n \tbool warn;\n \tuint_fast32_t mask;\n \n+\tif (roishift < 0) {\n+\t\t\/* We could instead return an error here. *\/\n+\t\t\/* I do not think it matters much. *\/\n+\t\tjas_eprintf(\"warning: forcing negative ROI shift to zero \"\n+\t\t  \"(bitstream is probably corrupt)\\n\");\n+\t\troishift = 0;\n+\t}\n \tif (roishift == 0 && bgshift == 0) {\n \t\treturn;\n \t}\n@@ -1856,7 +1863,7 @@ static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n \t\t\t} else {\n \t\t\t\t\/* We are dealing with non-ROI (i.e., background) data. *\/\n \t\t\t\tmag <<= bgshift;\n-\t\t\t\tmask = (1 << numbps) - 1;\n+\t\t\t\tmask = (JAS_CAST(uint_fast32_t, 1) << numbps) - 1;\n \t\t\t\t\/* Perform a basic sanity check on the sample value. *\/\n \t\t\t\t\/* Some implementations write garbage in the unused\n \t\t\t\t  most-significant bit planes introduced by ROI shifting.\ndiff --git a\/src\/libjasper\/jpc\/jpc_tsfb.c b\/src\/libjasper\/jpc\/jpc_tsfb.c\nindex 7aa293f..b51b747 100644\n--- a\/src\/libjasper\/jpc\/jpc_tsfb.c\n+++ b\/src\/libjasper\/jpc\/jpc_tsfb.c\n@@ -148,7 +148,8 @@ int jpc_tsfb_analyze2(jpc_tsfb_t *tsfb, int *a, int xstart, int ystart,\n \n int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n {\n-\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n+\treturn (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?\n+\t  jpc_tsfb_synthesize2(tsfb,\n \t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n \t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n \t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n","owner":"mdadams","repo":"jasper","source":"cve"},{"CVE_ID":"CVE-2017-18241","CWE_ID":"476","category":"security","commit_id":"d4fdf8ba0e5808ba9ad6b44337783bd9935e0982","commit_message":"From d4fdf8ba0e5808ba9ad6b44337783bd9935e0982 Mon Sep 17 00:00:00 2001\nFrom: Yunlei He <heyunlei@huawei.com>\nDate: Thu, 1 Jun 2017 16:43:51 +0800\nSubject: f2fs: fix a panic caused by NULL flush_cmd_control\n\nMount fs with option noflush_merge, boot failed for illegal address\nfcc in function f2fs_issue_flush:\n\n        if (!test_opt(sbi, FLUSH_MERGE)) {\n                ret = submit_flush_wait(sbi);\n                atomic_inc(&fcc->issued_flush);   ->  Here, fcc illegal\n                return ret;\n        }\n\nSigned-off-by: Yunlei He <heyunlei@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>\n---\n fs\/f2fs\/segment.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/f2fs\/segment.c b\/fs\/f2fs\/segment.c\nindex de6738b82745..c1026b78cdfc 100644\n--- a\/fs\/f2fs\/segment.c\n+++ b\/fs\/f2fs\/segment.c\n@@ -566,6 +566,9 @@ int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n \tinit_waitqueue_head(&fcc->flush_wait_queue);\n \tinit_llist_head(&fcc->issue_list);\n \tSM_I(sbi)->fcc_info = fcc;\n+\tif (!test_opt(sbi, FLUSH_MERGE))\n+\t\treturn err;\n+\n init_thread:\n \tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n \t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n@@ -3240,7 +3243,7 @@ int build_segment_manager(struct f2fs_sb_info *sbi)\n \n \tINIT_LIST_HEAD(&sm_info->sit_entry_set);\n \n-\tif (test_opt(sbi, FLUSH_MERGE) && !f2fs_readonly(sbi->sb)) {\n+\tif (!f2fs_readonly(sbi->sb)) {\n \t\terr = create_flush_cmd_control(sbi);\n \t\tif (err)\n \t\t\treturn err;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-11591","CWE_ID":"476","category":"security","commit_id":"b6d362f6a1f2de0b3e7604848116efb509196bf4","commit_message":"From b6d362f6a1f2de0b3e7604848116efb509196bf4 Mon Sep 17 00:00:00 2001\nFrom: Gordon Williams <gw@pur3.co.uk>\nDate: Fri, 18 May 2018 10:05:57 +0100\nSubject: [PATCH] Add sanity check for debug trace print statement (fix #1420)\n\n---\n ChangeLog   | 1 +\n src\/jsvar.c | 2 +-\n 2 files changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex fcadd4b6d..793ab99a2 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -22,6 +22,7 @@\n             Move default I2C bitrate to 100kbit\/sec\n             Linux: don't create a espruino.flash file if we're not writing to flash\n             Add height check for Graphics.createArrayBuffer(...vertical_byte:true) (fix #1421)\n+            Add sanity check for debug trace print statement (fix #1420)\n \n      1v97 : nRF52: fix NRF.on('connect',...) issue\n             STM32: Fix setDeviceClockCmd error for USB.setConsole()\ndiff --git a\/src\/jsvar.c b\/src\/jsvar.c\nindex fd6e18ff3..8edb27b6e 100644\n--- a\/src\/jsvar.c\n+++ b\/src\/jsvar.c\n@@ -3314,7 +3314,7 @@ void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) {\n   else if (jsvIsFloat(var)) jsiConsolePrintf(\"Double %f\", jsvGetFloat(var));\n   else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(\"Param %q \", var);\n   else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(\"ArrayBufferName[%d] \", jsvGetInteger(var));\n-  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s \", jswGetBasicObjectName(var)); \/\/ way to get nice name\n+  else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(\"%s \", jswGetBasicObjectName(var)?jswGetBasicObjectName(var):\"unknown ArrayBuffer\"); \/\/ way to get nice name\n   else if (jsvIsString(var)) {\n     size_t blocks = 1;\n     if (jsvGetLastChild(var)) {\n","owner":"espruino","repo":"Espruino","source":"cve"},{"CVE_ID":"CVE-2017-12475","CWE_ID":"476","category":"security","commit_id":"4d3f0bebd5f8518fd775f671c12bea58c68e814e","commit_message":"From 4d3f0bebd5f8518fd775f671c12bea58c68e814e Mon Sep 17 00:00:00 2001\nFrom: Gilles Boccon-Gibod <bok@bok.net>\nDate: Sun, 30 Jul 2017 15:29:24 -0700\nSubject: [PATCH] fixed possible crashes on malformed inputs.\n\n---\n Source\/C++\/Core\/Ap4AtomSampleTable.cpp | 5 +++++\n Source\/C++\/Core\/Ap4AvccAtom.cpp        | 2 +-\n Source\/C++\/Core\/Ap4Processor.cpp       | 1 +\n Source\/C++\/Core\/Ap4Version.h           | 4 ++--\n 4 files changed, 9 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp b\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\nindex 19e05dad..77d11191 100644\n--- a\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\n+++ b\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\n@@ -87,6 +87,11 @@ AP4_AtomSampleTable::GetSample(AP4_Ordinal index,\n {\n     AP4_Result result;\n \n+    \/\/ check that we have an stsc atom\n+    if (!m_StscAtom) {\n+        return AP4_ERROR_INVALID_FORMAT;\n+    }\n+    \n     \/\/ check that we have a chunk offset table\n     if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n         return AP4_ERROR_INVALID_FORMAT;\ndiff --git a\/Source\/C++\/Core\/Ap4AvccAtom.cpp b\/Source\/C++\/Core\/Ap4AvccAtom.cpp\nindex a1167d0d..d14f9a6a 100644\n--- a\/Source\/C++\/Core\/Ap4AvccAtom.cpp\n+++ b\/Source\/C++\/Core\/Ap4AvccAtom.cpp\n@@ -270,7 +270,7 @@ AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n     for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n         inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n     }\n-    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n+    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n         inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n     }\n     return AP4_SUCCESS;\ndiff --git a\/Source\/C++\/Core\/Ap4Processor.cpp b\/Source\/C++\/Core\/Ap4Processor.cpp\nindex ae6eb7df..9c1a7ec5 100644\n--- a\/Source\/C++\/Core\/Ap4Processor.cpp\n+++ b\/Source\/C++\/Core\/Ap4Processor.cpp\n@@ -554,6 +554,7 @@ AP4_Processor::Process(AP4_ByteStream&   input,\n             int cursor = -1;\n             for (unsigned int i=0; i<track_count; i++) {\n                 if (!cursors[i].m_EndReached &&\n+                    cursors[i].m_Locator.m_SampleTable &&\n                     cursors[i].m_Locator.m_Sample.GetOffset() <= min_offset) {\n                     min_offset = cursors[i].m_Locator.m_Sample.GetOffset();\n                     cursor = i;\ndiff --git a\/Source\/C++\/Core\/Ap4Version.h b\/Source\/C++\/Core\/Ap4Version.h\nindex 60620afe..5ffb7f69 100644\n--- a\/Source\/C++\/Core\/Ap4Version.h\n+++ b\/Source\/C++\/Core\/Ap4Version.h\n@@ -37,7 +37,7 @@\n \/**\n  * Version number of the SDK\n  *\/\n-#define AP4_VERSION        0x01050000\n-#define AP4_VERSION_STRING \"1.5.0.0\"\n+#define AP4_VERSION        0x01050001\n+#define AP4_VERSION_STRING \"1.5.0.1\"\n \n #endif \/\/ _AP4_VERSION_H_\n","owner":"axiomatic-systems","repo":"Bento4","source":"cve"},{"CVE_ID":"CVE-2019-11596","CWE_ID":"476","category":"security","commit_id":"d35334f368817a77a6bd1f33c6a5676b2c402c02","commit_message":"From d35334f368817a77a6bd1f33c6a5676b2c402c02 Mon Sep 17 00:00:00 2001\nFrom: dormando <dormando@rydia.net>\nDate: Sat, 27 Apr 2019 01:17:57 -0700\nSubject: [PATCH] fix segfault in \"lru\" command\n\nfixes #474 - off by one in token count.\n---\n memcached.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/memcached.c b\/memcached.c\nindex d64a83816..7fd3e40e1 100644\n--- a\/memcached.c\n+++ b\/memcached.c\n@@ -4632,7 +4632,7 @@ static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens)\n                 out_string(c, \"OK\");\n             }\n         }\n-    } else if (strcmp(tokens[1].value, \"mode\") == 0 && ntokens >= 3 &&\n+    } else if (strcmp(tokens[1].value, \"mode\") == 0 && ntokens >= 4 &&\n                settings.lru_maintainer_thread) {\n         if (strcmp(tokens[2].value, \"flat\") == 0) {\n             settings.lru_segmented = false;\n@@ -4643,7 +4643,7 @@ static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens)\n         } else {\n             out_string(c, \"ERROR\");\n         }\n-    } else if (strcmp(tokens[1].value, \"temp_ttl\") == 0 && ntokens >= 3 &&\n+    } else if (strcmp(tokens[1].value, \"temp_ttl\") == 0 && ntokens >= 4 &&\n                settings.lru_maintainer_thread) {\n         if (!safe_strtol(tokens[2].value, &ttl)) {\n             out_string(c, \"ERROR\");\n","owner":"memcached","repo":"memcached","source":"cve"},{"CVE_ID":"CVE-2016-9888","CWE_ID":"476","category":"security","commit_id":"95a8351a75758cf10b3bf6abae0b6b461f90d9e5","commit_message":"From 95a8351a75758cf10b3bf6abae0b6b461f90d9e5 Mon Sep 17 00:00:00 2001\nFrom: Morten Welinder <terra@gnome.org>\nDate: Fri, 2 Dec 2016 22:19:54 -0500\nSubject: [PATCH] tar: fix crash on broken tar file.\n\n---\n ChangeLog            | 7 +++++++\n NEWS                 | 3 +++\n gsf\/gsf-infile-tar.c | 4 +++-\n 3 files changed, 13 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex c891943c..18508ece 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,10 @@\n+2016-11-30  Morten Welinder  <terra@gnome.org>\n+\n+\t* gsf\/gsf-infile-tar.c (tar_directory_for_file): Handle the case\n+\twhere what we expected to be a directory is a file.  (That implies\n+\ta corrupted tar file.)  Thanks to Behzad Najjarpour Jabbari,\n+\tSecunia Research at Flexera Software for discovering this.\n+\n 2016-08-20  Morten Welinder <terra@gnome.org>\n \n \t* configure.ac: Post-release bump.\ndiff --git a\/NEWS b\/NEWS\nindex 01cc67a9..cfc1e43a 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -1,5 +1,8 @@\n libgsf 1.14.41\n \n+Morten:\n+\t* Fix corrupted-tar-file crash.\n+\n --------------------------------------------------------------------------\n libgsf 1.14.40\n \ndiff --git a\/gsf\/gsf-infile-tar.c b\/gsf\/gsf-infile-tar.c\nindex 271595da..17513fe6 100644\n--- a\/gsf\/gsf-infile-tar.c\n+++ b\/gsf\/gsf-infile-tar.c\n@@ -181,9 +181,11 @@ tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n \t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n \t\t\t\t\t\t\t  dirname);\n \t\t\tif (subdir) {\n+\t\t\t\tdir = GSF_IS_INFILE_TAR (subdir)\n+\t\t\t\t\t? GSF_INFILE_TAR (subdir)\n+\t\t\t\t\t: dir;\n \t\t\t\t\/* Undo the ref. *\/\n \t\t\t\tg_object_unref (subdir);\n-\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n \t\t\t} else\n \t\t\t\tdir = tar_create_dir (dir, dirname);\n \t\t}\n","owner":"GNOME","repo":"libgsf","source":"cve"},{"CVE_ID":"CVE-2016-6292","CWE_ID":"476","category":"security","commit_id":"41131cd41d2fd2e0c2f332a27988df75659c42e4","commit_message":"From 41131cd41d2fd2e0c2f332a27988df75659c42e4 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Mon, 18 Jul 2016 23:21:51 -0700\nSubject: [PATCH] Fix bug #72618: NULL Pointer Dereference in\n exif_process_user_comment\n\n---\n ext\/exif\/exif.c              |  17 +++++++++++------\n ext\/exif\/tests\/bug72618.jpg  | Bin 0 -> 3711 bytes\n ext\/exif\/tests\/bug72618.phpt |  11 +++++++++++\n 3 files changed, 22 insertions(+), 6 deletions(-)\n create mode 100644 ext\/exif\/tests\/bug72618.jpg\n create mode 100644 ext\/exif\/tests\/bug72618.phpt\n\n","diff_code":"diff --git a\/ext\/exif\/exif.c b\/ext\/exif\/exif.c\nindex 760e746..74b652b 100644\n--- a\/ext\/exif\/exif.c\n+++ b\/ext\/exif\/exif.c\n@@ -2623,6 +2623,7 @@ static int exif_process_user_comment(image_info_type *ImageInfo, char **pszInfoP\n \t*pszEncoding = NULL;\n \t\/* Copy the comment *\/\n \tif (ByteCount>=8) {\n+\t\tconst zend_encoding *from, *to;\n \t\tif (!memcmp(szValuePtr, \"UNICODE\\0\", 8)) {\n \t\t\t*pszEncoding = estrdup((const char*)szValuePtr);\n \t\t\tszValuePtr = szValuePtr+8;\n@@ -2643,14 +2644,16 @@ static int exif_process_user_comment(image_info_type *ImageInfo, char **pszInfoP\n \t\t\t} else {\n \t\t\t\tdecode = ImageInfo->decode_unicode_le;\n \t\t\t}\n+\t\t\tto = zend_multibyte_fetch_encoding(ImageInfo->encode_unicode TSRMLS_CC);\n+\t\t\tfrom = zend_multibyte_fetch_encoding(decode TSRMLS_CC);\n \t\t\t\/* XXX this will fail again if encoding_converter returns on error something different than SIZE_MAX   *\/\n-\t\t\tif (zend_multibyte_encoding_converter(\n+\t\t\tif (!to || !from || zend_multibyte_encoding_converter(\n \t\t\t\t\t(unsigned char**)pszInfoPtr,\n \t\t\t\t\t&len,\n \t\t\t\t\t(unsigned char*)szValuePtr,\n \t\t\t\t\tByteCount,\n-\t\t\t\t\tzend_multibyte_fetch_encoding(ImageInfo->encode_unicode TSRMLS_CC),\n-\t\t\t\t\tzend_multibyte_fetch_encoding(decode TSRMLS_CC)\n+\t\t\t\t\tto,\n+\t\t\t\t\tfrom\n \t\t\t\t\tTSRMLS_CC) == (size_t)-1) {\n \t\t\t\tlen = exif_process_string_raw(pszInfoPtr, szValuePtr, ByteCount);\n \t\t\t}\n@@ -2665,13 +2668,15 @@ static int exif_process_user_comment(image_info_type *ImageInfo, char **pszInfoP\n \t\t\tszValuePtr = szValuePtr+8;\n \t\t\tByteCount -= 8;\n \t\t\t\/* XXX this will fail again if encoding_converter returns on error something different than SIZE_MAX   *\/\n-\t\t\tif (zend_multibyte_encoding_converter(\n+\t\t\tto = zend_multibyte_fetch_encoding(ImageInfo->encode_jis TSRMLS_CC);\n+\t\t\tfrom = zend_multibyte_fetch_encoding(ImageInfo->motorola_intel ? ImageInfo->decode_jis_be : ImageInfo->decode_jis_le TSRMLS_CC);\n+\t\t\tif (!to || !from || zend_multibyte_encoding_converter(\n \t\t\t\t\t(unsigned char**)pszInfoPtr,\n \t\t\t\t\t&len,\n \t\t\t\t\t(unsigned char*)szValuePtr,\n \t\t\t\t\tByteCount,\n-\t\t\t\t\tzend_multibyte_fetch_encoding(ImageInfo->encode_jis TSRMLS_CC),\n-\t\t\t\t\tzend_multibyte_fetch_encoding(ImageInfo->motorola_intel ? ImageInfo->decode_jis_be : ImageInfo->decode_jis_le TSRMLS_CC)\n+\t\t\t\t\tto,\n+\t\t\t\t\tfrom\n \t\t\t\t\tTSRMLS_CC) == (size_t)-1) {\n \t\t\t\tlen = exif_process_string_raw(pszInfoPtr, szValuePtr, ByteCount);\n \t\t\t}\ndiff --git a\/ext\/exif\/tests\/bug72618.jpg b\/ext\/exif\/tests\/bug72618.jpg\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..0a61ae2e020aec43da98b9fdf55afb67d71c4991\nGIT binary patch\nliteral 3711\nzcmeH~&k6xi6o-HJm=WbqSz21kOJJx`EbszKN{OvxA&ISKC9#!9!p<vL+8k%bEUYZ0\nz=KSi`ckaF2bMLpieBrx&s7;3hz;%mA03hUz4I=~#7;db93sT0hU%ppzvT_XB5ng+Q\nzv+Ovff!&f&5^iOHtRdLKGvT>sAtgMLK}Zn!$7B0sPKGQc+CR!edP#p13tqR7%7nb~\nznclDVFHa%&W!?{8_=Z9A2kC0mfEtLb0lxChqKZZhsDa2DC~MS!8i=d`zBb%W@bmb0\nP1@+Is`I>5PJQ=?Lo6++x\n\nliteral 0\nHcmV?d00001\n\ndiff --git a\/ext\/exif\/tests\/bug72618.phpt b\/ext\/exif\/tests\/bug72618.phpt\nnew file mode 100644\nindex 0000000..424c0ec\n--- \/dev\/null\n+++ b\/ext\/exif\/tests\/bug72618.phpt\n@@ -0,0 +1,11 @@\n+--TEST--\n+Bug 72618 (NULL Pointer Dereference in exif_process_user_comment)\n+--SKIPIF--\n+<?php if (!extension_loaded('exif')) print 'skip exif extension not available';?>\n+--FILE--\n+<?php\n+var_dump(count(exif_read_data(dirname(__FILE__) . \"\/bug72618.jpg\")));\n+?>\n+--EXPECTF--\n+Warning: exif_read_data(bug72618.jpg): IFD data bad offset: 0x058E length 0x0030 in %s\/bug72618.php on line %d\n+int(13)\n\\ No newline at end of file\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-7999","CWE_ID":"476","category":"security","commit_id":"db132b4731a9b4c9534144ba3a18e65b390e9ff6","commit_message":"From db132b4731a9b4c9534144ba3a18e65b390e9ff6 Mon Sep 17 00:00:00 2001\nFrom: Martin Hosken <martin_hosken@sil.org>\nDate: Tue, 6 Mar 2018 12:42:16 +0700\nSubject: [PATCH] Deprecate and make ineffective gr_face_dumbRendering\n\n---\n include\/graphite2\/Font.h            |  2 +-\n src\/GlyphCache.cpp                  | 91 ++++++++++++++---------------\n src\/gr_face.cpp                     |  5 +-\n tests\/featuremap\/CMakeLists.txt     |  2 +-\n tests\/featuremap\/featuremaptest.cpp |  7 +--\n tests\/vm\/CMakeLists.txt             |  4 +-\n 6 files changed, 53 insertions(+), 58 deletions(-)\n\n","diff_code":"diff --git a\/include\/graphite2\/Font.h b\/include\/graphite2\/Font.h\nindex efe2af9f..a4e35243 100644\n--- a\/include\/graphite2\/Font.h\n+++ b\/include\/graphite2\/Font.h\n@@ -56,7 +56,7 @@ GR2_API void gr_engine_version(int *nMajor, int *nMinor, int *nBugFix);\n enum gr_face_options {\n     \/** No preload, no cmap caching, fail if the graphite tables are invalid *\/\n     gr_face_default = 0,\n-    \/** Dumb rendering will be enabled if the graphite tables are invalid *\/\n+    \/** Dumb rendering will be enabled if the graphite tables are invalid. DEPRECATED. *\/\n     gr_face_dumbRendering = 1,\n     \/** preload glyphs at construction time *\/\n     gr_face_preloadGlyphs = 2,\ndiff --git a\/src\/GlyphCache.cpp b\/src\/GlyphCache.cpp\nindex c4ab807b..1acf7f98 100644\n--- a\/src\/GlyphCache.cpp\n+++ b\/src\/GlyphCache.cpp\n@@ -84,7 +84,7 @@ const SlantBox SlantBox::empty = {0,0,0,0};\n class GlyphCache::Loader\n {\n public:\n-    Loader(const Face & face, const bool dumb_font);    \/\/return result indicates success. Do not use if failed.\n+    Loader(const Face & face);    \/\/return result indicates success. Do not use if failed.\n \n     operator bool () const throw();\n     unsigned short int units_per_em() const throw();\n@@ -115,7 +115,7 @@ class GlyphCache::Loader\n \n \n GlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n-: _glyph_loader(new Loader(face, bool(face_options & gr_face_dumbRendering))),\n+: _glyph_loader(new Loader(face)),\n   _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n         ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n   _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n@@ -239,7 +239,7 @@ const GlyphFace *GlyphCache::glyph(unsigned short glyphid) const      \/\/result m\n \n \n \n-GlyphCache::Loader::Loader(const Face & face, const bool dumb_font)\n+GlyphCache::Loader::Loader(const Face & face)\n : _head(face, Tag::head),\n   _hhea(face, Tag::hhea),\n   _hmtx(face, Tag::hmtx),\n@@ -265,52 +265,49 @@ GlyphCache::Loader::Loader(const Face & face, const bool dumb_font)\n         return;\n     }\n \n-    if (!dumb_font)\n+    if ((m_pGlat = Face::Table(face, Tag::Glat, 0x00030000)) == NULL\n+        || (m_pGloc = Face::Table(face, Tag::Gloc)) == NULL\n+        || m_pGloc.size() < 8)\n     {\n-        if ((m_pGlat = Face::Table(face, Tag::Glat, 0x00030000)) == NULL\n-            || (m_pGloc = Face::Table(face, Tag::Gloc)) == NULL\n-            || m_pGloc.size() < 8)\n-        {\n-            _head = Face::Table();\n-            return;\n-        }\n-        const byte    * p = m_pGloc;\n-        int       version = be::read<uint32>(p);\n-        const uint16    flags = be::read<uint16>(p);\n-        _num_attrs = be::read<uint16>(p);\n-        \/\/ We can accurately calculate the number of attributed glyphs by\n-        \/\/  subtracting the length of the attribids array (numAttribs long if present)\n-        \/\/  and dividing by either 2 or 4 depending on shor or lonf format\n-        _long_fmt              = flags & 1;\n-        int tmpnumgattrs       = (m_pGloc.size()\n-                                   - (p - m_pGloc)\n-                                   - sizeof(uint16)*(flags & 0x2 ? _num_attrs : 0))\n-                                       \/ (_long_fmt ? sizeof(uint32) : sizeof(uint16)) - 1;\n-\n-        if (version >= 0x00020000 || tmpnumgattrs < 0 || tmpnumgattrs > 65535\n-            || _num_attrs == 0 || _num_attrs > 0x3000  \/\/ is this hard limit appropriate?\n-            || _num_glyphs_graphics > tmpnumgattrs\n-            || m_pGlat.size() < 4)\n-        {\n-            _head = Face::Table();\n-            return;\n-        }\n+        _head = Face::Table();\n+        return;\n+    }\n+    const byte    * p = m_pGloc;\n+    int       version = be::read<uint32>(p);\n+    const uint16    flags = be::read<uint16>(p);\n+    _num_attrs = be::read<uint16>(p);\n+    \/\/ We can accurately calculate the number of attributed glyphs by\n+    \/\/  subtracting the length of the attribids array (numAttribs long if present)\n+    \/\/  and dividing by either 2 or 4 depending on shor or lonf format\n+    _long_fmt              = flags & 1;\n+    int tmpnumgattrs       = (m_pGloc.size()\n+                               - (p - m_pGloc)\n+                               - sizeof(uint16)*(flags & 0x2 ? _num_attrs : 0))\n+                                   \/ (_long_fmt ? sizeof(uint32) : sizeof(uint16)) - 1;\n+\n+    if (version >= 0x00020000 || tmpnumgattrs < 0 || tmpnumgattrs > 65535\n+        || _num_attrs == 0 || _num_attrs > 0x3000  \/\/ is this hard limit appropriate?\n+        || _num_glyphs_graphics > tmpnumgattrs\n+        || m_pGlat.size() < 4)\n+    {\n+        _head = Face::Table();\n+        return;\n+    }\n \n-        _num_glyphs_attributes = static_cast<unsigned short>(tmpnumgattrs);\n-        p = m_pGlat;\n-        version = be::read<uint32>(p);\n-        if (version >= 0x00040000 || (version >= 0x00030000 && m_pGlat.size() < 8))       \/\/ reject Glat tables that are too new\n-        {\n-            _head = Face::Table();\n-            return;\n-        }\n-        else if (version >= 0x00030000)\n-        {\n-            unsigned int glatflags = be::read<uint32>(p);\n-            _has_boxes = glatflags & 1;\n-            \/\/ delete this once the compiler is fixed\n-            _has_boxes = true;\n-        }\n+    _num_glyphs_attributes = static_cast<unsigned short>(tmpnumgattrs);\n+    p = m_pGlat;\n+    version = be::read<uint32>(p);\n+    if (version >= 0x00040000 || (version >= 0x00030000 && m_pGlat.size() < 8))       \/\/ reject Glat tables that are too new\n+    {\n+        _head = Face::Table();\n+        return;\n+    }\n+    else if (version >= 0x00030000)\n+    {\n+        unsigned int glatflags = be::read<uint32>(p);\n+        _has_boxes = glatflags & 1;\n+        \/\/ delete this once the compiler is fixed\n+        _has_boxes = true;\n     }\n }\n \ndiff --git a\/src\/gr_face.cpp b\/src\/gr_face.cpp\nindex 65a4b117..e69c7fbe 100644\n--- a\/src\/gr_face.cpp\n+++ b\/src\/gr_face.cpp\n@@ -47,8 +47,7 @@ namespace\n         telemetry::category _misc_cat(face.tele.misc);\n #endif\n         Face::Table silf(face, Tag::Silf, 0x00050000);\n-        if (silf)   options &= ~gr_face_dumbRendering;\n-        else if (!(options &  gr_face_dumbRendering))\n+        if (!silf)\n             return false;\n \n         if (!face.readGlyphs(options))\n@@ -74,7 +73,7 @@ namespace\n                 return true;\n         }\n         else\n-            return options & gr_face_dumbRendering;\n+            return false;\n     }\n }\n \ndiff --git a\/tests\/featuremap\/CMakeLists.txt b\/tests\/featuremap\/CMakeLists.txt\nindex fc57f96c..a438f66c 100644\n--- a\/tests\/featuremap\/CMakeLists.txt\n+++ b\/tests\/featuremap\/CMakeLists.txt\n@@ -20,7 +20,7 @@ if (GRAPHITE2_ASAN)\n endif (GRAPHITE2_ASAN)\n target_link_libraries(featuremaptest graphite2 graphite2-base graphite2-segcache graphite2-base)\n \n-add_test(NAME featuremaptest COMMAND $<TARGET_FILE:featuremaptest> ${testing_SOURCE_DIR}\/fonts\/tiny.ttf)\n+add_test(NAME featuremaptest COMMAND $<TARGET_FILE:featuremaptest> ${testing_SOURCE_DIR}\/fonts\/small.ttf)\n set_tests_properties(featuremaptest PROPERTIES TIMEOUT 3)\n if (GRAPHITE2_ASAN)\n     set_property(TEST featuremaptest APPEND PROPERTY ENVIRONMENT \"ASAN_SYMBOLIZER_PATH=${ASAN_SYMBOLIZER}\")\ndiff --git a\/tests\/featuremap\/featuremaptest.cpp b\/tests\/featuremap\/featuremaptest.cpp\nindex fcd9b873..a9aa497f 100644\n--- a\/tests\/featuremap\/featuremaptest.cpp\n+++ b\/tests\/featuremap\/featuremaptest.cpp\n@@ -243,7 +243,7 @@ template <class T> void testFeatTable(const T & table, const char * testName)\n {\n     FeatureMap testFeatureMap;\n     dummyFace.replace_table(TtfUtil::Tag::Feat, &table, sizeof(T));\n-    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n+    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, 0);\n     if (!face) throw std::runtime_error(\"failed to load font\");\n     bool readStatus = testFeatureMap.readFeats(*face);\n     testAssert(\"readFeats\", readStatus);\n@@ -285,9 +285,8 @@ int main(int argc, char * argv[])\n \t\t\/\/ test a bad settings offset stradling the end of the table\n \t\tFeatureMap testFeatureMap;\n \t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n-\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n-\t\tbool readStatus = testFeatureMap.readFeats(*face);\n-\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n+\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, 0);\n+\t\ttestAssert(\"fail gracefully on bad table\", !face);\n \t}\n \tcatch (std::exception & e)\n \t{\ndiff --git a\/tests\/vm\/CMakeLists.txt b\/tests\/vm\/CMakeLists.txt\nindex 4a0b8231..24fbd3b8 100644\n--- a\/tests\/vm\/CMakeLists.txt\n+++ b\/tests\/vm\/CMakeLists.txt\n@@ -41,7 +41,7 @@ if  (${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n \tendif (\"${CMAKE_BUILD_TYPE}\" STREQUAL \"Release\")\n endif  (${CMAKE_SYSTEM_NAME} STREQUAL \"Linux\")\n \n-add_test(vm-test-call-threading vm-test-call ${testing_SOURCE_DIR}\/fonts\/tiny.ttf 1)\n+add_test(vm-test-call-threading vm-test-call ${testing_SOURCE_DIR}\/fonts\/small.ttf 1)\n set_tests_properties(vm-test-call-threading PROPERTIES\n         PASS_REGULAR_EXPRESSION \"simple program size:    14 bytes.*result of program: 42\"\n         FAIL_REGULAR_EXPRESSION \"program terminated early;stack not empty\")\n@@ -51,7 +51,7 @@ if (GRAPHITE2_ASAN)\n endif (GRAPHITE2_ASAN)\n \n if  (${CMAKE_COMPILER_IS_GNUCXX})\n-\tadd_test(vm-test-direct-threading vm-test-direct ${testing_SOURCE_DIR}\/fonts\/tiny.ttf 1)\n+\tadd_test(vm-test-direct-threading vm-test-direct ${testing_SOURCE_DIR}\/fonts\/small.ttf 1)\n \tset_tests_properties(vm-test-direct-threading PROPERTIES\n \t\t\tPASS_REGULAR_EXPRESSION \"simple program size:    14 bytes.*result of program: 42\"\n \t\t\tFAIL_REGULAR_EXPRESSION \"program terminated early;stack not empty\")\n","owner":"silnrsi","repo":"graphite","source":"cve"},{"CVE_ID":"CVE-2018-15504","CWE_ID":"476","category":"security","commit_id":"66067ae6d1fa08b37a270e7dc1821df52ed2daef","commit_message":"From 66067ae6d1fa08b37a270e7dc1821df52ed2daef Mon Sep 17 00:00:00 2001\nFrom: Michael O'Brien <mob@emobrien.com>\nDate: Tue, 6 Feb 2018 12:36:27 +1100\nSubject: [PATCH] FIX: array ref out of bounds with invalid time spec.\n\n---\n src\/mpr\/mprLib.c | 33 ++++++++++++++++++++++++++++++++-\n 1 file changed, 32 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/mpr\/mprLib.c b\/src\/mpr\/mprLib.c\nindex 660837675..26c01349e 100644\n--- a\/src\/mpr\/mprLib.c\n+++ b\/src\/mpr\/mprLib.c\n@@ -27583,13 +27583,40 @@ static void validateTime(struct tm *tp, struct tm *defaults)\n         swapDayMonth(tp);\n     }\n \n+    \/*\n+        Check for overflow. Underflow validated below.\n+     *\/\n+    if (tp->tm_sec > 60) {\n+        tp->tm_sec = -1;\n+    }\n+    if (tp->tm_min > 60) {\n+        tp->tm_sec = -1;\n+    }\n+    if (tp->tm_hour > 24) {\n+        tp->tm_sec = -1;\n+    }\n+    if (tp->tm_mday > 31) {\n+        tp->tm_sec = -1;\n+    }\n+    if (tp->tm_mon > 11) {\n+        tp->tm_sec = -1;\n+    }\n+    if (tp->tm_wday > 6) {\n+        tp->tm_sec = -1;\n+    }\n+    if (tp->tm_yday > 366) {\n+        tp->tm_sec = -1;\n+    }\n+\n+#if UNUSED\n     if (tp->tm_year != -MAXINT && tp->tm_mon >= 0 && tp->tm_mday >= 0 && tp->tm_hour >= 0) {\n         \/*  Everything defined *\/\n         return;\n     }\n+#endif\n \n     \/*\n-        Use empty time if missing\n+        Use empty time if defaults missing\n      *\/\n     if (defaults == NULL) {\n         memset(&empty, 0, sizeof(empty));\n@@ -27640,8 +27667,12 @@ static void validateTime(struct tm *tp, struct tm *defaults)\n         tp->tm_mday = defaults->tm_mday;\n     }\n     if (tp->tm_yday < 0) {\n+        if (tp->tm_mon <= 11) {\n         tp->tm_yday = (leapYear(tp->tm_year + 1900) ?\n             leapMonthStart[tp->tm_mon] : normalMonthStart[tp->tm_mon]) + tp->tm_mday - 1;\n+        } else {\n+            tp->tm_yday = defaults->tm_yday;\n+        }\n     }\n     if (tp->tm_hour < 0) {\n         tp->tm_hour = defaults->tm_hour;\n","owner":"embedthis","repo":"appweb","source":"cve"},{"CVE_ID":"CVE-2015-9261","CWE_ID":"476","category":"security","commit_id":"1de25a6e87e0e627aa34298105a3d17c60a1f44e","commit_message":"From 1de25a6e87e0e627aa34298105a3d17c60a1f44e Mon Sep 17 00:00:00 2001\nFrom: Denys Vlasenko <vda.linux@googlemail.com>\nDate: Mon, 26 Oct 2015 19:33:05 +0100\nSubject: unzip: test for bad archive SEGVing\n\nfunction                                             old     new   delta\nhuft_build                                          1296    1300      +4\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>\n---\n archival\/libarchive\/decompress_gunzip.c | 11 +++++++----\n testsuite\/unzip.tests                   | 23 ++++++++++++++++++++++-\n 2 files changed, 29 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/archival\/libarchive\/decompress_gunzip.c b\/archival\/libarchive\/decompress_gunzip.c\nindex 7b6f45934..30bf45154 100644\n--- a\/archival\/libarchive\/decompress_gunzip.c\n+++ b\/archival\/libarchive\/decompress_gunzip.c\n@@ -305,11 +305,12 @@ static int huft_build(const unsigned *b, const unsigned n,\n \tunsigned i;             \/* counter, current code *\/\n \tunsigned j;             \/* counter *\/\n \tint k;                  \/* number of bits in current code *\/\n-\tunsigned *p;            \/* pointer into c[], b[], or v[] *\/\n+\tconst unsigned *p;      \/* pointer into c[], b[], or v[] *\/\n \thuft_t *q;              \/* points to current table *\/\n \thuft_t r;               \/* table entry for structure assignment *\/\n \thuft_t *u[BMAX];        \/* table stack *\/\n \tunsigned v[N_MAX];      \/* values in order of bit length *\/\n+\tunsigned v_end;\n \tint ws[BMAX + 1];       \/* bits decoded stack *\/\n \tint w;                  \/* bits decoded *\/\n \tunsigned x[BMAX + 1];   \/* bit offsets, then code stack *\/\n@@ -324,7 +325,7 @@ static int huft_build(const unsigned *b, const unsigned n,\n \n \t\/* Generate counts for each bit length *\/\n \tmemset(c, 0, sizeof(c));\n-\tp = (unsigned *) b; \/* cast allows us to reuse p for pointing to b *\/\n+\tp = b;\n \ti = n;\n \tdo {\n \t\tc[*p]++; \/* assume all entries <= BMAX *\/\n@@ -365,12 +366,14 @@ static int huft_build(const unsigned *b, const unsigned n,\n \t}\n \n \t\/* Make a table of values in order of bit lengths *\/\n-\tp = (unsigned *) b;\n+\tp = b;\n \ti = 0;\n+\tv_end = 0;\n \tdo {\n \t\tj = *p++;\n \t\tif (j != 0) {\n \t\t\tv[x[j]++] = i;\n+\t\t\tv_end = x[j];\n \t\t}\n \t} while (++i < n);\n \n@@ -432,7 +435,7 @@ static int huft_build(const unsigned *b, const unsigned n,\n \n \t\t\t\/* set up table entry in r *\/\n \t\t\tr.b = (unsigned char) (k - w);\n-\t\t\tif (p >= v + n) {\n+\t\t\tif (p >= v + v_end) { \/\/ Was \"if (p >= v + n)\" but v[] can be shorter!\n \t\t\t\tr.e = 99; \/* out of values--invalid code *\/\n \t\t\t} else if (*p < s) {\n \t\t\t\tr.e = (unsigned char) (*p < 256 ? 16 : 15);\t\/* 256 is EOB code *\/\ndiff --git a\/testsuite\/unzip.tests b\/testsuite\/unzip.tests\nindex 8677a0306..ca0a45800 100755\n--- a\/testsuite\/unzip.tests\n+++ b\/testsuite\/unzip.tests\n@@ -7,7 +7,7 @@\n \n . .\/testing.sh\n \n-# testing \"test name\" \"options\" \"expected result\" \"file input\" \"stdin\"\n+# testing \"test name\" \"commands\" \"expected result\" \"file input\" \"stdin\"\n #   file input will be file called \"input\"\n #   test can create a file \"actual\" instead of writing to stdout\n \n@@ -30,6 +30,27 @@ testing \"unzip (subdir only)\" \"unzip -q foo.zip foo\/ && test -d foo && test ! -f\n rmdir foo\n rm foo.zip\n \n+# File containing some damaged encrypted stream\n+testing \"unzip (bad archive)\" \"uudecode; unzip bad.zip 2>&1; echo \\$?\" \\\n+\"Archive:  bad.zip\n+  inflating: ]3j\u00bdr\u00abI\u001b\u0012K-%Ix\n+unzip: inflate error\n+1\n+\" \\\n+\"\" \"\\\n+begin-base64 644 bad.zip\n+UEsDBBQAAgkIAAAAIQA5AAAANwAAADwAAAAQAAcAXTNqwr1ywqtJGxJLLSVJ\n+eCkBD0AdKBk8JzQsIj01JC0\/ORJQSwMEFAECCAAAAAAhADoAAAAPAAAANgAA\n+AAwAAQASw73Ct1DCokohPXQiNjoUNTUiHRwgLT4WHlBLAQIQABQAAggIAAAA\n+oQA5AAAANwAAADwAAAAQQAcADAAAACwAMgCAAAAAAABdM2rCvXLCq0kbEkst\n+JUl4KQEPQB0oGSY4Cz4QNgEnJSYIPVBLAQIAABQAAggAAAAAIQAqAAAADwAA\n+BDYAAAAMAAEADQAAADIADQAAAEEAAAASw73Ct1DKokohPXQiNzA+FAI1HCcW\n+NzITNFBLBQUKAC4JAA04Cw0EOhZQSwUGAQAABAIAAgCZAAAAeQAAAAIALhM=\n+====\n+\"\n+\n+rm *\n+\n # Clean up scratch directory.\n \n cd ..\n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-15855","CWE_ID":"476","category":"security","commit_id":"917636b1d0d70205a13f89062b95e3a0fc31d4ff","commit_message":"From 917636b1d0d70205a13f89062b95e3a0fc31d4ff Mon Sep 17 00:00:00 2001\nFrom: Ran Benita <ran234@gmail.com>\nDate: Sun, 11 Mar 2018 17:07:06 +0200\nSubject: [PATCH] xkbcomp: fix crash when parsing an xkb_geometry section\n\nxkb_geometry sections are ignored; previously the had done so by\nreturning NULL for the section's XkbFile, however some sections of the\ncode do not expect this. Instead, create an XkbFile for it, it will\nnever be processes and discarded later.\n\nCaught with the afl fuzzer.\n\nSigned-off-by: Ran Benita <ran234@gmail.com>\n---\n src\/xkbcomp\/keymap.c | 9 +++++++--\n src\/xkbcomp\/parser.y | 9 +--------\n 2 files changed, 8 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/src\/xkbcomp\/keymap.c b\/src\/xkbcomp\/keymap.c\nindex 45098c2..e95e50c 100644\n--- a\/src\/xkbcomp\/keymap.c\n+++ b\/src\/xkbcomp\/keymap.c\n@@ -241,8 +241,13 @@ CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n          file = (XkbFile *) file->common.next) {\n         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n             file->file_type > LAST_KEYMAP_FILE_TYPE) {\n-            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n-                    xkb_file_type_to_string(file->file_type));\n+            if (file->file_type == FILE_TYPE_GEOMETRY) {\n+                log_vrb(ctx, 1,\n+                        \"Geometry sections are not supported; ignoring\\n\");\n+            } else {\n+                log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n+                        xkb_file_type_to_string(file->file_type));\n+            }\n             continue;\n         }\n \ndiff --git a\/src\/xkbcomp\/parser.y b\/src\/xkbcomp\/parser.y\nindex d15d24b..b555bc2 100644\n--- a\/src\/xkbcomp\/parser.y\n+++ b\/src\/xkbcomp\/parser.y\n@@ -273,14 +273,7 @@ XkbMapConfig    :       OptFlags FileType OptMapName OBRACE\n                             DeclList\n                         CBRACE SEMI\n                         {\n-                            if ($2 == FILE_TYPE_GEOMETRY) {\n-                                free($3);\n-                                FreeStmt($5);\n-                                $$ = NULL;\n-                            }\n-                            else {\n-                                $$ = XkbFileCreate($2, $3, $5, $1);\n-                            }\n+                            $$ = XkbFileCreate($2, $3, $5, $1);\n                         }\n                 ;\n \n","owner":"xkbcommon","repo":"libxkbcommon","source":"cve"},{"CVE_ID":"CVE-2019-12110","CWE_ID":"476","category":"security","commit_id":"f321c2066b96d18afa5158dfa2d2873a2957ef38","commit_message":"From f321c2066b96d18afa5158dfa2d2873a2957ef38 Mon Sep 17 00:00:00 2001\nFrom: Thomas Bernard <miniupnp@free.fr>\nDate: Tue, 18 Dec 2018 22:59:18 +0100\nSubject: [PATCH] upnp_redirect(): accept NULL desc argument\n\n---\n miniupnpd\/upnpredirect.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/miniupnpd\/upnpredirect.c b\/miniupnpd\/upnpredirect.c\nindex 7c179b62..74926f08 100644\n--- a\/miniupnpd\/upnpredirect.c\n+++ b\/miniupnpd\/upnpredirect.c\n@@ -356,6 +356,10 @@ upnp_redirect(const char * rhost, unsigned short eport,\n \t\t                 \"%hu->%s:%hu %s\", eport, iaddr, iport, protocol);\n \t\treturn -3;\n \t}\n+\n+\tif (desc == NULL)\n+\t\tdesc = \"\";\t\/* assume empty description *\/\n+\n \t\/* IGDv1 (WANIPConnection:1 Service Template Version 1.01 \/ Nov 12, 2001)\n \t * - 2.2.20.PortMappingDescription :\n \t *  Overwriting Previous \/ Existing Port Mappings:\n","owner":"miniupnp","repo":"miniupnp","source":"cve"},{"CVE_ID":"CVE-2018-1095","CWE_ID":"476","category":"security","commit_id":"ce3fd194fcc6fbdc00ce095a852f22df97baa401","commit_message":"From ce3fd194fcc6fbdc00ce095a852f22df97baa401 Mon Sep 17 00:00:00 2001\nFrom: Eric Biggers <ebiggers@google.com>\nDate: Thu, 29 Mar 2018 14:31:42 -0400\nSubject: ext4: limit xattr size to INT_MAX\n\next4 isn't validating the sizes of xattrs where the value of the xattr\nis stored in an external inode.  This is problematic because\n->e_value_size is a u32, but ext4_xattr_get() returns an int.  A very\nlarge size is misinterpreted as an error code, which ext4_get_acl()\ntranslates into a bogus ERR_PTR() for which IS_ERR() returns false,\ncausing a crash.\n\nFix this by validating that all xattrs are <= INT_MAX bytes.\n\nThis issue has been assigned CVE-2018-1095.\n\nhttps:\/\/bugzilla.kernel.org\/show_bug.cgi?id=199185\nhttps:\/\/bugzilla.redhat.com\/show_bug.cgi?id=1560793\n\nReported-by: Wen Xu <wen.xu@gatech.edu>\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@vger.kernel.org\nFixes: e50e5129f384 (\"ext4: xattr-in-inode support\")\n---\n fs\/ext4\/xattr.c | 9 ++++++---\n 1 file changed, 6 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/xattr.c b\/fs\/ext4\/xattr.c\nindex 63656dbafdc4..2077d87b09f2 100644\n--- a\/fs\/ext4\/xattr.c\n+++ b\/fs\/ext4\/xattr.c\n@@ -195,10 +195,13 @@ ext4_xattr_check_entries(struct ext4_xattr_entry *entry, void *end,\n \n \t\/* Check the values *\/\n \twhile (!IS_LAST_ENTRY(entry)) {\n-\t\tif (entry->e_value_size != 0 &&\n-\t\t    entry->e_value_inum == 0) {\n+\t\tu32 size = le32_to_cpu(entry->e_value_size);\n+\n+\t\tif (size > INT_MAX)\n+\t\t\treturn -EFSCORRUPTED;\n+\n+\t\tif (size != 0 && entry->e_value_inum == 0) {\n \t\t\tu16 offs = le16_to_cpu(entry->e_value_offs);\n-\t\t\tu32 size = le32_to_cpu(entry->e_value_size);\n \t\t\tvoid *value;\n \n \t\t\t\/*\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-7191","CWE_ID":"476","category":"security","commit_id":"5c25f65fd1e42685f7ccd80e0621829c105785d9","commit_message":"From 5c25f65fd1e42685f7ccd80e0621829c105785d9 Mon Sep 17 00:00:00 2001\nFrom: Julien Gomes <julien@arista.com>\nDate: Wed, 25 Oct 2017 11:50:50 -0700\nSubject: tun: allow positive return values on dev_get_valid_name() call\n\nIf the name argument of dev_get_valid_name() contains \"%d\", it will try\nto assign it a unit number in __dev__alloc_name() and return either the\nunit number (>= 0) or an error code (< 0).\nConsidering positive values as error values prevent tun device creations\nrelying this mechanism, therefor we should only consider negative values\nas errors here.\n\nSigned-off-by: Julien Gomes <julien@arista.com>\nAcked-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/tun.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/net\/tun.c b\/drivers\/net\/tun.c\nindex e21bf90b819f..b9973fb868b7 100644\n--- a\/drivers\/net\/tun.c\n+++ b\/drivers\/net\/tun.c\n@@ -2028,7 +2028,7 @@ static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n \t\terr = dev_get_valid_name(net, dev, name);\n-\t\tif (err)\n+\t\tif (err < 0)\n \t\t\tgoto err_free_dev;\n \n \t\tdev_net_set(dev, net);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-15274","CWE_ID":"476","category":"security","commit_id":"5649645d725c73df4302428ee4e02c869248b4c5","commit_message":"From 5649645d725c73df4302428ee4e02c869248b4c5 Mon Sep 17 00:00:00 2001\nFrom: Eric Biggers <ebiggers@google.com>\nDate: Thu, 8 Jun 2017 14:48:40 +0100\nSubject: [PATCH] KEYS: fix dereferencing NULL payload with nonzero length\n\nsys_add_key() and the KEYCTL_UPDATE operation of sys_keyctl() allowed a\nNULL payload with nonzero length to be passed to the key type's\n->preparse(), ->instantiate(), and\/or ->update() methods.  Various key\ntypes including asymmetric, cifs.idmap, cifs.spnego, and pkcs7_test did\nnot handle this case, allowing an unprivileged user to trivially cause a\nNULL pointer dereference (kernel oops) if one of these key types was\npresent.  Fix it by doing the copy_from_user() when 'plen' is nonzero\nrather than when '_payload' is non-NULL, causing the syscall to fail\nwith EFAULT as expected when an invalid buffer is specified.\n\nCc: stable@vger.kernel.org # 2.6.10+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nSigned-off-by: James Morris <james.l.morris@oracle.com>\n---\n security\/keys\/keyctl.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/security\/keys\/keyctl.c b\/security\/keys\/keyctl.c\nindex 447a7d5cee0f5..94c2790f82839 100644\n--- a\/security\/keys\/keyctl.c\n+++ b\/security\/keys\/keyctl.c\n@@ -99,7 +99,7 @@ SYSCALL_DEFINE5(add_key, const char __user *, _type,\n \t\/* pull the payload in if one was supplied *\/\n \tpayload = NULL;\n \n-\tif (_payload) {\n+\tif (plen) {\n \t\tret = -ENOMEM;\n \t\tpayload = kvmalloc(plen, GFP_KERNEL);\n \t\tif (!payload)\n@@ -324,7 +324,7 @@ long keyctl_update_key(key_serial_t id,\n \n \t\/* pull the payload in if one was supplied *\/\n \tpayload = NULL;\n-\tif (_payload) {\n+\tif (plen) {\n \t\tret = -ENOMEM;\n \t\tpayload = kmalloc(plen, GFP_KERNEL);\n \t\tif (!payload)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-16359","CWE_ID":"476","category":"security","commit_id":"d21e91f075a7a7a8ed23baa5c1bb1fac48313882","commit_message":"From d21e91f075a7a7a8ed23baa5c1bb1fac48313882 Mon Sep 17 00:00:00 2001\nFrom: Khairul Kasmiran <kazarmy@gmail.com>\nDate: Wed, 1 Nov 2017 01:52:54 +0800\nSubject: [PATCH] Fix #8764 differently since ptr diff might not fit in\n ptrdiff_t\n\n---\n libr\/bin\/format\/elf\/elf.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libr\/bin\/format\/elf\/elf.c b\/libr\/bin\/format\/elf\/elf.c\nindex ba3d1d5404..eb0ebe0ed2 100644\n--- a\/libr\/bin\/format\/elf\/elf.c\n+++ b\/libr\/bin\/format\/elf\/elf.c\n@@ -749,7 +749,7 @@ static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz)\n \t\tverdef->vd_aux = READ32 (dfs, j)\n \t\tverdef->vd_next = READ32 (dfs, j)\n \t\tint vdaux = verdef->vd_aux;\n-\t\tif (vdaux < 1 || (char *)UINTPTR_MAX - vstart < vdaux) {\n+\t\tif (vdaux < 1 || vstart + vdaux < vstart) {\n \t\t\tsdb_free (sdb_verdef);\n \t\t\tgoto out_error;\n \t\t}\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2018-10074","CWE_ID":"476","category":"security","commit_id":"9903e41ae1f5d50c93f268ca3304d4d7c64b9311","commit_message":"From 9903e41ae1f5d50c93f268ca3304d4d7c64b9311 Mon Sep 17 00:00:00 2001\nFrom: Wei Yongjun <weiyongjun1@huawei.com>\nDate: Thu, 4 Jan 2018 06:36:34 +0000\nSubject: =?UTF-8?q?clk:=20hisilicon:=20hi3660=EF=BC=9AFix=20potential=20NU?=\n =?UTF-8?q?LL=20dereference=20in=20hi3660=5Fstub=5Fclk=5Fprobe()?=\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nplatform_get_resource() may return NULL, add proper check to\navoid potential NULL dereferencing.\n\nThis is detected by Coccinelle semantic patch.\n\n@@\nexpression pdev, res, n, t, e, e1, e2;\n@@\n\nres = platform_get_resource(pdev, t, n);\n+ if (!res)\n+   return -EINVAL;\n... when != res == NULL\ne = devm_ioremap(e1, res->start, e2);\n\nFixes: 4f16f7ff3bc0 (\"clk: hisilicon: Add support for Hi3660 stub clocks\")\nSigned-off-by: Wei Yongjun <weiyongjun1@huawei.com>\nSigned-off-by: Stephen Boyd <sboyd@kernel.org>\n---\n drivers\/clk\/hisilicon\/clk-hi3660-stub.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/clk\/hisilicon\/clk-hi3660-stub.c b\/drivers\/clk\/hisilicon\/clk-hi3660-stub.c\nindex 9b6c72bbddf9..e8b2c43b1bb8 100644\n--- a\/drivers\/clk\/hisilicon\/clk-hi3660-stub.c\n+++ b\/drivers\/clk\/hisilicon\/clk-hi3660-stub.c\n@@ -149,6 +149,8 @@ static int hi3660_stub_clk_probe(struct platform_device *pdev)\n \t\treturn PTR_ERR(stub_clk_chan.mbox);\n \n \tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n+\tif (!res)\n+\t\treturn -EINVAL;\n \tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n \tif (!freq_reg)\n \t\treturn -ENOMEM;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-7549","CWE_ID":"476","category":"security","commit_id":"43b11a91dd861a946b231b89b7542856ade23d1b","commit_message":"From 43b11a91dd861a946b231b89b7542856ade23d1b Mon Sep 17 00:00:00 2001\nFrom: =?utf8?q?Marc-Andr=C3=A9=20Lureau?= <marcandre.lureau@redhat.com>\nDate: Fri, 26 Jun 2015 14:25:29 +0200\nSubject: [PATCH] msix: implement pba write (but read-only)\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nqpci_msix_pending() writes on pba region, causing qemu to SEGV:\n\n  Program received signal SIGSEGV, Segmentation fault.\n  [Switching to Thread 0x7ffff7fba8c0 (LWP 25882)]\n  0x0000000000000000 in ?? ()\n  (gdb) bt\n  #0  0x0000000000000000 in  ()\n  #1  0x00005555556556c5 in memory_region_oldmmio_write_accessor (mr=0x5555579f3f80, addr=0, value=0x7fffffffbf68, size=4, shift=0, mask=4294967295, attrs=...) at \/home\/elmarco\/src\/qemu\/memory.c:434\n  #2  0x00005555556558e1 in access_with_adjusted_size (addr=0, value=0x7fffffffbf68, size=4, access_size_min=1, access_size_max=4, access=0x55555565563e <memory_region_oldmmio_write_accessor>, mr=0x5555579f3f80, attrs=...) at \/home\/elmarco\/src\/qemu\/memory.c:506\n  #3  0x00005555556581eb in memory_region_dispatch_write (mr=0x5555579f3f80, addr=0, data=0, size=4, attrs=...) at \/home\/elmarco\/src\/qemu\/memory.c:1176\n  #4  0x000055555560b6f9 in address_space_rw (as=0x555555eff4e0 <address_space_memory>, addr=3759147008, attrs=..., buf=0x7fffffffc1b0 \"\", len=4, is_write=true) at \/home\/elmarco\/src\/qemu\/exec.c:2439\n  #5  0x000055555560baa2 in cpu_physical_memory_rw (addr=3759147008, buf=0x7fffffffc1b0 \"\", len=4, is_write=1) at \/home\/elmarco\/src\/qemu\/exec.c:2534\n  #6  0x000055555564c005 in cpu_physical_memory_write (addr=3759147008, buf=0x7fffffffc1b0, len=4) at \/home\/elmarco\/src\/qemu\/include\/exec\/cpu-common.h:80\n  #7  0x000055555564cd9c in qtest_process_command (chr=0x55555642b890, words=0x5555578de4b0) at \/home\/elmarco\/src\/qemu\/qtest.c:378\n  #8  0x000055555564db77 in qtest_process_inbuf (chr=0x55555642b890, inbuf=0x55555641b340) at \/home\/elmarco\/src\/qemu\/qtest.c:569\n  #9  0x000055555564dc07 in qtest_read (opaque=0x55555642b890, buf=0x7fffffffc2e0 \"writel 0xe0100800 0x0\\n\", size=22) at \/home\/elmarco\/src\/qemu\/qtest.c:581\n  #10 0x000055555574ce3e in qemu_chr_be_write (s=0x55555642b890, buf=0x7fffffffc2e0 \"writel 0xe0100800 0x0\\n\", len=22) at qemu-char.c:306\n  #11 0x0000555555751263 in tcp_chr_read (chan=0x55555642bcf0, cond=G_IO_IN, opaque=0x55555642b890) at qemu-char.c:2876\n  #12 0x00007ffff64c9a8a in g_main_context_dispatch (context=0x55555641c400) at gmain.c:3122\n\n(without this patch, this can be reproduced with the ivshmem qtest)\n\nImplement an empty mmio write to avoid the crash.\n\nSigned-off-by: Marc-Andr\u00c3\u00a9 Lureau <marcandre.lureau@redhat.com>\nReviewed-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n hw\/pci\/msix.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/hw\/pci\/msix.c b\/hw\/pci\/msix.c\nindex 2fdada4..64c93d8 100644\n--- a\/hw\/pci\/msix.c\n+++ b\/hw\/pci\/msix.c\n@@ -200,8 +200,14 @@ static uint64_t msix_pba_mmio_read(void *opaque, hwaddr addr,\n     return pci_get_long(dev->msix_pba + addr);\n }\n \n+static void msix_pba_mmio_write(void *opaque, hwaddr addr,\n+                                uint64_t val, unsigned size)\n+{\n+}\n+\n static const MemoryRegionOps msix_pba_mmio_ops = {\n     .read = msix_pba_mmio_read,\n+    .write = msix_pba_mmio_write,\n     .endianness = DEVICE_LITTLE_ENDIAN,\n     .valid = {\n         .min_access_size = 4,\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9250","CWE_ID":"476","category":"security","commit_id":"e58f2880df608652aff7fd35c45b242467ec0e79","commit_message":"From e58f2880df608652aff7fd35c45b242467ec0e79 Mon Sep 17 00:00:00 2001\nFrom: Zoltan Herczeg <zherczeg.u-szeged@partner.samsung.com>\nDate: Mon, 22 May 2017 13:17:08 +0200\nSubject: [PATCH] Do not allocate memory for zero length strings. (#1844)\n\nFixes #1821.\n\nJerryScript-DCO-1.0-Signed-off-by: Zoltan Herczeg zherczeg.u-szeged@partner.samsung.com\n---\n jerry-core\/parser\/js\/js-lexer.c           |  5 +++++\n tests\/jerry\/regression-test-issue-1833.js | 16 ++++++++++++++++\n 2 files changed, 21 insertions(+)\n create mode 100644 tests\/jerry\/regression-test-issue-1833.js\n\n","diff_code":"diff --git a\/jerry-core\/parser\/js\/js-lexer.c b\/jerry-core\/parser\/js\/js-lexer.c\nindex 71db7e624..f7bd5b952 100644\n--- a\/jerry-core\/parser\/js\/js-lexer.c\n+++ b\/jerry-core\/parser\/js\/js-lexer.c\n@@ -1197,6 +1197,11 @@ lexer_process_char_literal (parser_context_t *context_p, \/**< context *\/\n     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);\n   }\n \n+  if (length == 0)\n+  {\n+    has_escape = false;\n+  }\n+\n   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);\n   literal_p->prop.length = (uint16_t) length;\n   literal_p->type = literal_type;\ndiff --git a\/tests\/jerry\/regression-test-issue-1833.js b\/tests\/jerry\/regression-test-issue-1833.js\nnew file mode 100644\nindex 000000000..7c0860168\n--- \/dev\/null\n+++ b\/tests\/jerry\/regression-test-issue-1833.js\n@@ -0,0 +1,16 @@\n+\/\/ Copyright JS Foundation and other contributors, http:\/\/js.foundation\n+\/\/\n+\/\/ Licensed under the Apache License, Version 2.0 (the \"License\");\n+\/\/ you may not use this file except in compliance with the License.\n+\/\/ You may obtain a copy of the License at\n+\/\/\n+\/\/     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+\/\/\n+\/\/ Unless required by applicable law or agreed to in writing, software\n+\/\/ distributed under the License is distributed on an \"AS IS\" BASIS\n+\/\/ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+\/\/ See the License for the specific language governing permissions and\n+\/\/ limitations under the License.\n+\n+'\\\n+'\n","owner":"jerryscript-project","repo":"jerryscript","source":"cve"},{"CVE_ID":"CVE-2017-11522","CWE_ID":"476","category":"security","commit_id":"816ecab6c532ae086ff4186b3eaf4aa7092d536f","commit_message":"From 816ecab6c532ae086ff4186b3eaf4aa7092d536f Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 18 Jul 2017 18:12:58 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/58\n\n---\n coders\/png.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/png.c b\/coders\/png.c\nindex f6ddf6d7c3..c61b6874e7 100644\n--- a\/coders\/png.c\n+++ b\/coders\/png.c\n@@ -8270,9 +8270,11 @@ static MagickBooleanType WriteOnePNGImage(MngInfo *mng_info,\n     \"  Enter WriteOnePNGImage()\");\n \n   image = CloneImage(IMimage,0,0,MagickFalse,exception);\n+  if (image == (Image *) NULL)\n+    return(MagickFalse);\n   image_info=(ImageInfo *) CloneImageInfo(IMimage_info);\n   if (image_info == (ImageInfo *) NULL)\n-     ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n+    ThrowWriterException(ResourceLimitError, \"MemoryAllocationFailed\");\n \n   \/* Define these outside of the following \"if logging()\" block so they will\n    * show in debuggers.\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2019-12614","CWE_ID":"476","category":"security","commit_id":"efa9ace68e487ddd29c2b4d6dd23242158f1f607","commit_message":"From efa9ace68e487ddd29c2b4d6dd23242158f1f607 Mon Sep 17 00:00:00 2001\nFrom: Gen Zhang <blackgod016574@gmail.com>\nDate: Sun, 26 May 2019 10:42:40 +0800\nSubject: powerpc\/pseries\/dlpar: Fix a missing check in\n dlpar_parse_cc_property()\n\nIn dlpar_parse_cc_property(), 'prop->name' is allocated by kstrdup().\nkstrdup() may return NULL, so it should be checked and handle error.\nAnd prop should be freed if 'prop->name' is NULL.\n\nSigned-off-by: Gen Zhang <blackgod016574@gmail.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\n---\n arch\/powerpc\/platforms\/pseries\/dlpar.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/arch\/powerpc\/platforms\/pseries\/dlpar.c b\/arch\/powerpc\/platforms\/pseries\/dlpar.c\nindex 17958043e7f7..c852024044bb 100644\n--- a\/arch\/powerpc\/platforms\/pseries\/dlpar.c\n+++ b\/arch\/powerpc\/platforms\/pseries\/dlpar.c\n@@ -61,6 +61,10 @@ static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\n \n \tname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\n \tprop->name = kstrdup(name, GFP_KERNEL);\n+\tif (!prop->name) {\n+\t\tdlpar_free_cc_property(prop);\n+\t\treturn NULL;\n+\t}\n \n \tprop->length = be32_to_cpu(ccwa->prop_length);\n \tvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-20786","CWE_ID":"476","category":"security","commit_id":"cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8","commit_message":"From cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8 Mon Sep 17 00:00:00 2001\nFrom: Bram Moolenaar <Bram@vim.org>\nDate: Mon, 24 Dec 2018 21:38:45 +0100\nSubject: [PATCH] patch 8.1.0633: crash when out of memory while opening a\n terminal window\n\nProblem:    Crash when out of memory while opening a terminal window.\nSolution:   Handle out-of-memory more gracefully.\n---\n src\/libvterm\/src\/state.c      |  8 ++++++++\n src\/libvterm\/src\/termscreen.c | 28 ++++++++++++++++------------\n src\/libvterm\/src\/vterm.c      | 20 +++++++++++++++++++-\n src\/terminal.c                | 32 +++++++++++++++++++++++++-------\n src\/version.c                 |  2 ++\n 5 files changed, 70 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/src\/libvterm\/src\/state.c b\/src\/libvterm\/src\/state.c\nindex d977ecac60..8b02093bb9 100644\n--- a\/src\/libvterm\/src\/state.c\n+++ b\/src\/libvterm\/src\/state.c\n@@ -53,6 +53,8 @@ static VTermState *vterm_state_new(VTerm *vt)\n {\n   VTermState *state = vterm_allocator_malloc(vt, sizeof(VTermState));\n \n+  if (state == NULL)\n+    return NULL;\n   state->vt = vt;\n \n   state->rows = vt->rows;\n@@ -1693,6 +1695,10 @@ static const VTermParserCallbacks parser_callbacks = {\n   on_resize \/* resize *\/\n };\n \n+\/*\n+ * Return the existing state or create a new one.\n+ * Returns NULL when out of memory.\n+ *\/\n VTermState *vterm_obtain_state(VTerm *vt)\n {\n   VTermState *state;\n@@ -1700,6 +1706,8 @@ VTermState *vterm_obtain_state(VTerm *vt)\n     return vt->state;\n \n   state = vterm_state_new(vt);\n+  if (state == NULL)\n+    return NULL;\n   vt->state = state;\n \n   state->combine_chars_size = 16;\ndiff --git a\/src\/libvterm\/src\/termscreen.c b\/src\/libvterm\/src\/termscreen.c\nindex cfae088ba7..0cd31cedfe 100644\n--- a\/src\/libvterm\/src\/termscreen.c\n+++ b\/src\/libvterm\/src\/termscreen.c\n@@ -1,5 +1,6 @@\n #include \"vterm_internal.h\"\n \n+\/* vim: set sw=2 : *\/\n #include <stdio.h>\n #include <string.h>\n \n@@ -95,8 +96,7 @@ static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int n\n     }\n   }\n \n-  if(buffer)\n-    vterm_allocator_free(screen->vt, buffer);\n+  vterm_allocator_free(screen->vt, buffer);\n \n   return new_buffer;\n }\n@@ -518,8 +518,7 @@ static int resize(int new_rows, int new_cols, VTermPos *delta, void *user)\n   screen->rows = new_rows;\n   screen->cols = new_cols;\n \n-  if(screen->sb_buffer)\n-    vterm_allocator_free(screen->vt, screen->sb_buffer);\n+  vterm_allocator_free(screen->vt, screen->sb_buffer);\n \n   screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * new_cols);\n \n@@ -619,16 +618,21 @@ static VTermStateCallbacks state_cbs = {\n   &setlineinfo \/* setlineinfo *\/\n };\n \n+\/*\n+ * Allocate a new screen and return it.\n+ * Return NULL when out of memory.\n+ *\/\n static VTermScreen *screen_new(VTerm *vt)\n {\n   VTermState *state = vterm_obtain_state(vt);\n   VTermScreen *screen;\n   int rows, cols;\n \n-  if(!state)\n+  if (state == NULL)\n     return NULL;\n-\n   screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));\n+  if (screen == NULL)\n+    return NULL;\n \n   vterm_get_size(vt, &rows, &cols);\n \n@@ -646,10 +650,13 @@ static VTermScreen *screen_new(VTerm *vt)\n   screen->cbdata    = NULL;\n \n   screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);\n-\n   screen->buffer = screen->buffers[0];\n-\n   screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);\n+  if (screen->buffer == NULL || screen->sb_buffer == NULL)\n+  {\n+    vterm_screen_free(screen);\n+    return NULL;\n+  }\n \n   vterm_state_set_callbacks(screen->state, &state_cbs, screen);\n \n@@ -659,11 +666,8 @@ static VTermScreen *screen_new(VTerm *vt)\n INTERNAL void vterm_screen_free(VTermScreen *screen)\n {\n   vterm_allocator_free(screen->vt, screen->buffers[0]);\n-  if(screen->buffers[1])\n-    vterm_allocator_free(screen->vt, screen->buffers[1]);\n-\n+  vterm_allocator_free(screen->vt, screen->buffers[1]);\n   vterm_allocator_free(screen->vt, screen->sb_buffer);\n-\n   vterm_allocator_free(screen->vt, screen);\n }\n \ndiff --git a\/src\/libvterm\/src\/vterm.c b\/src\/libvterm\/src\/vterm.c\nindex 9025da4449..5e4722ce3a 100644\n--- a\/src\/libvterm\/src\/vterm.c\n+++ b\/src\/libvterm\/src\/vterm.c\n@@ -1,5 +1,6 @@\n #define DEFINE_INLINES\n \n+\/* vim: set sw=2 : *\/\n #include \"vterm_internal.h\"\n \n #include <stdio.h>\n@@ -41,6 +42,8 @@ VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *fun\n   \/* Need to bootstrap using the allocator function directly *\/\n   VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);\n \n+  if (vt == NULL)\n+    return NULL;\n   vt->allocator = funcs;\n   vt->allocdata = allocdata;\n \n@@ -55,10 +58,21 @@ VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *fun\n   vt->parser.strbuffer_len = 500; \/* should be able to hold an OSC string *\/\n   vt->parser.strbuffer_cur = 0;\n   vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);\n+  if (vt->parser.strbuffer == NULL)\n+  {\n+    vterm_allocator_free(vt, vt);\n+    return NULL;\n+  }\n \n   vt->outbuffer_len = 200;\n   vt->outbuffer_cur = 0;\n   vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);\n+  if (vt->outbuffer == NULL)\n+  {\n+    vterm_allocator_free(vt, vt->parser.strbuffer);\n+    vterm_allocator_free(vt, vt);\n+    return NULL;\n+  }\n \n   return vt;\n }\n@@ -82,9 +96,13 @@ INTERNAL void *vterm_allocator_malloc(VTerm *vt, size_t size)\n   return (*vt->allocator->malloc)(size, vt->allocdata);\n }\n \n+\/*\n+ * Free \"ptr\" unless it is NULL.\n+ *\/\n INTERNAL void vterm_allocator_free(VTerm *vt, void *ptr)\n {\n-  (*vt->allocator->free)(ptr, vt->allocdata);\n+  if (ptr)\n+    (*vt->allocator->free)(ptr, vt->allocdata);\n }\n \n void vterm_get_size(const VTerm *vt, int *rowsp, int *colsp)\ndiff --git a\/src\/terminal.c b\/src\/terminal.c\nindex 06d470c560..1875cc3e34 100644\n--- a\/src\/terminal.c\n+++ b\/src\/terminal.c\n@@ -3430,6 +3430,7 @@ set_vterm_palette(VTerm *vterm, long_u *rgb)\n {\n     int\t\tindex = 0;\n     VTermState\t*state = vterm_obtain_state(vterm);\n+\n     for (; index < 16; index++)\n     {\n \tVTermColor\tcolor;\n@@ -3703,8 +3704,9 @@ static VTermAllocatorFunctions vterm_allocator = {\n \n \/*\n  * Create a new vterm and initialize it.\n+ * Return FAIL when out of memory.\n  *\/\n-    static void\n+    static int\n create_vterm(term_T *term, int rows, int cols)\n {\n     VTerm\t    *vterm;\n@@ -3714,7 +3716,18 @@ create_vterm(term_T *term, int rows, int cols)\n \n     vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n     term->tl_vterm = vterm;\n+    if (vterm == NULL)\n+\treturn FAIL;\n+\n+    \/\/ Allocate screen and state here, so we can bail out if that fails.\n+    state = vterm_obtain_state(vterm);\n     screen = vterm_obtain_screen(vterm);\n+    if (state == NULL || screen == NULL)\n+    {\n+\tvterm_free(vterm);\n+\treturn FAIL;\n+    }\n+\n     vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n     \/* TODO: depends on 'encoding'. *\/\n     vterm_set_utf8(vterm, 1);\n@@ -3722,7 +3735,7 @@ create_vterm(term_T *term, int rows, int cols)\n     init_default_colors(term);\n \n     vterm_state_set_default_colors(\n-\t    vterm_obtain_state(vterm),\n+\t    state,\n \t    &term->tl_default_color.fg,\n \t    &term->tl_default_color.bg);\n \n@@ -3746,9 +3759,10 @@ create_vterm(term_T *term, int rows, int cols)\n #else\n     value.boolean = 0;\n #endif\n-    state = vterm_obtain_state(vterm);\n     vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n     vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n+\n+    return OK;\n }\n \n \/*\n@@ -5629,7 +5643,8 @@ term_and_job_init(\n     vim_free(cwd_wchar);\n     vim_free(env_wchar);\n \n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\tgoto failed;\n \n #if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n     if (opt->jo_set2 & JO2_ANSI_COLORS)\n@@ -5710,7 +5725,8 @@ create_pty_only(term_T *term, jobopt_T *options)\n     char\t    in_name[80], out_name[80];\n     channel_T\t    *channel = NULL;\n \n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\treturn FAIL;\n \n     vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n \t    GetCurrentProcessId(),\n@@ -5822,7 +5838,8 @@ term_and_job_init(\n \tjobopt_T    *opt,\n \tjobopt_T    *orig_opt UNUSED)\n {\n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\treturn FAIL;\n \n #if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n     if (opt->jo_set2 & JO2_ANSI_COLORS)\n@@ -5844,7 +5861,8 @@ term_and_job_init(\n     static int\n create_pty_only(term_T *term, jobopt_T *opt)\n {\n-    create_vterm(term, term->tl_rows, term->tl_cols);\n+    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n+\treturn FAIL;\n \n     term->tl_job = job_alloc();\n     if (term->tl_job == NULL)\ndiff --git a\/src\/version.c b\/src\/version.c\nindex 2452ae0463..6956225c32 100644\n--- a\/src\/version.c\n+++ b\/src\/version.c\n@@ -799,6 +799,8 @@ static char *(features[]) =\n \n static int included_patches[] =\n {   \/* Add new patch number below this line *\/\n+\/**\/\n+    633,\n \/**\/\n     632,\n \/**\/\n","owner":"vim","repo":"vim","source":"cve"},{"CVE_ID":"CVE-2017-15102","CWE_ID":"476","category":"security","commit_id":"2fae9e5a7babada041e2e161699ade2447a01989","commit_message":"From 2fae9e5a7babada041e2e161699ade2447a01989 Mon Sep 17 00:00:00 2001\nFrom: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nDate: Mon, 19 Sep 2016 19:09:51 +0100\nSubject: [PATCH] usb: misc: legousbtower: Fix NULL pointer deference\n\nThis patch fixes a NULL pointer dereference caused by a race codition in\nthe probe function of the legousbtower driver. It re-structures the\nprobe function to only register the interface after successfully reading\nthe board's firmware ID.\n\nThe probe function does not deregister the usb interface after an error\nreceiving the devices firmware ID. The device file registered\n(\/dev\/usb\/legousbtower%d) may be read\/written globally before the probe\nfunction returns. When tower_delete is called in the probe function\n(after an r\/w has been initiated), core dev structures are deleted while\nthe file operation functions are still running. If the 0 address is\nmappable on the machine, this vulnerability can be used to create a\nLocal Priviege Escalation exploit via a write-what-where condition by\nremapping dev->interrupt_out_buffer in tower_write. A forged USB device\nand local program execution would be required for LPE. The USB device\nwould have to delay the control message in tower_probe and accept\nthe control urb in tower_open whilst guest code initiated a write to the\ndevice file as tower_delete is called from the error in tower_probe.\n\nThis bug has existed since 2003. Patch tested by emulated device.\n\nReported-by: James Patrick-Evans <james@jmp-e.com>\nTested-by: James Patrick-Evans <james@jmp-e.com>\nSigned-off-by: James Patrick-Evans <james@jmp-e.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/usb\/misc\/legousbtower.c | 35 ++++++++++++++++-----------------\n 1 file changed, 17 insertions(+), 18 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/usb\/misc\/legousbtower.c b\/drivers\/usb\/misc\/legousbtower.c\nindex ece9b3c1eaac2..c8fbe7b739a0b 100644\n--- a\/drivers\/usb\/misc\/legousbtower.c\n+++ b\/drivers\/usb\/misc\/legousbtower.c\n@@ -886,24 +886,6 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device\n \tdev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\n \tdev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\n \n-\t\/* we can register the device now, as it is ready *\/\n-\tusb_set_intfdata (interface, dev);\n-\n-\tretval = usb_register_dev (interface, &tower_class);\n-\n-\tif (retval) {\n-\t\t\/* something prevented us from registering this driver *\/\n-\t\tdev_err(idev, \"Not able to get a minor for this device.\\n\");\n-\t\tusb_set_intfdata (interface, NULL);\n-\t\tgoto error;\n-\t}\n-\tdev->minor = interface->minor;\n-\n-\t\/* let the user know what node this device is now attached to *\/\n-\tdev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n-\t\t \"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n-\t\t USB_MAJOR, dev->minor);\n-\n \t\/* get the firmware version and log it *\/\n \tresult = usb_control_msg (udev,\n \t\t\t\t  usb_rcvctrlpipe(udev, 0),\n@@ -924,6 +906,23 @@ static int tower_probe (struct usb_interface *interface, const struct usb_device\n \t\t get_version_reply.minor,\n \t\t le16_to_cpu(get_version_reply.build_no));\n \n+\t\/* we can register the device now, as it is ready *\/\n+\tusb_set_intfdata (interface, dev);\n+\n+\tretval = usb_register_dev (interface, &tower_class);\n+\n+\tif (retval) {\n+\t\t\/* something prevented us from registering this driver *\/\n+\t\tdev_err(idev, \"Not able to get a minor for this device.\\n\");\n+\t\tusb_set_intfdata (interface, NULL);\n+\t\tgoto error;\n+\t}\n+\tdev->minor = interface->minor;\n+\n+\t\/* let the user know what node this device is now attached to *\/\n+\tdev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n+\t\t \"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n+\t\t USB_MAJOR, dev->minor);\n \n exit:\n \treturn retval;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-15854","CWE_ID":"476","category":"security","commit_id":"e3cacae7b1bfda0d839c280494f23284a1187adf","commit_message":"From e3cacae7b1bfda0d839c280494f23284a1187adf Mon Sep 17 00:00:00 2001\nFrom: Ran Benita <ran234@gmail.com>\nDate: Sat, 10 Mar 2018 23:32:12 +0200\nSubject: [PATCH] xkbcomp: fix crashes in the parser when geometry tokens\n appear\n\nIn the XKB format, floats and various keywords can only be used in the\nxkb_geometry section. xkbcommon removed support xkb_geometry, but still\nparses it for backward compatibility. As part of ignoring it, the float\nAST node and various keywords were removed, and instead NULL was\nreturned by their parsing actions. However, the rest of the code does\nnot handle NULLs, and so when they appear crashes usually ensue.\n\nTo fix this, restore the float AST node and the ignored keywords. None\nof the evaluating code expects them, so nice error are displayed.\n\nCaught with the afl fuzzer.\n\nSigned-off-by: Ran Benita <ran234@gmail.com>\n---\n src\/xkbcomp\/ast-build.c |  8 ++++++++\n src\/xkbcomp\/ast-build.h |  3 +++\n src\/xkbcomp\/ast.h       |  7 +++++++\n src\/xkbcomp\/parser.y    | 10 +++++-----\n 4 files changed, 23 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/xkbcomp\/ast-build.c b\/src\/xkbcomp\/ast-build.c\nindex 58f97f9..9c6ccd4 100644\n--- a\/src\/xkbcomp\/ast-build.c\n+++ b\/src\/xkbcomp\/ast-build.c\n@@ -105,6 +105,13 @@ ExprCreateInteger(int ival)\n     return expr;\n }\n \n+ExprDef *\n+ExprCreateFloat(void)\n+{\n+    EXPR_CREATE(ExprFloat, expr, EXPR_VALUE, EXPR_TYPE_FLOAT);\n+    return expr;\n+}\n+\n ExprDef *\n ExprCreateBoolean(bool set)\n {\n@@ -783,6 +790,7 @@ static const char *expr_value_type_strings[_EXPR_TYPE_NUM_VALUES] = {\n     [EXPR_TYPE_UNKNOWN] = \"unknown\",\n     [EXPR_TYPE_BOOLEAN] = \"boolean\",\n     [EXPR_TYPE_INT] = \"int\",\n+    [EXPR_TYPE_FLOAT] = \"float\",\n     [EXPR_TYPE_STRING] = \"string\",\n     [EXPR_TYPE_ACTION] = \"action\",\n     [EXPR_TYPE_KEYNAME] = \"keyname\",\ndiff --git a\/src\/xkbcomp\/ast-build.h b\/src\/xkbcomp\/ast-build.h\nindex b57e4cd..6c76f38 100644\n--- a\/src\/xkbcomp\/ast-build.h\n+++ b\/src\/xkbcomp\/ast-build.h\n@@ -36,6 +36,9 @@ ExprCreateString(xkb_atom_t str);\n ExprDef *\n ExprCreateInteger(int ival);\n \n+ExprDef *\n+ExprCreateFloat(void);\n+\n ExprDef *\n ExprCreateBoolean(bool set);\n \ndiff --git a\/src\/xkbcomp\/ast.h b\/src\/xkbcomp\/ast.h\nindex 9778884..49c5ada 100644\n--- a\/src\/xkbcomp\/ast.h\n+++ b\/src\/xkbcomp\/ast.h\n@@ -95,6 +95,7 @@ enum expr_value_type {\n     EXPR_TYPE_UNKNOWN = 0,\n     EXPR_TYPE_BOOLEAN,\n     EXPR_TYPE_INT,\n+    EXPR_TYPE_FLOAT,\n     EXPR_TYPE_STRING,\n     EXPR_TYPE_ACTION,\n     EXPR_TYPE_KEYNAME,\n@@ -186,6 +187,12 @@ typedef struct {\n     int ival;\n } ExprInteger;\n \n+typedef struct {\n+    ExprCommon expr;\n+    \/* We don't support floats, but we still represnt them in the AST, in\n+     * order to provide proper error messages. *\/\n+} ExprFloat;\n+\n typedef struct {\n     ExprCommon expr;\n     xkb_atom_t key_name;\ndiff --git a\/src\/xkbcomp\/parser.y b\/src\/xkbcomp\/parser.y\nindex ead2016..d15d24b 100644\n--- a\/src\/xkbcomp\/parser.y\n+++ b\/src\/xkbcomp\/parser.y\n@@ -591,13 +591,13 @@ Element         :       ACTION_TOK\n                 |       INDICATOR\n                         { $$ = xkb_atom_intern_literal(param->ctx, \"indicator\"); }\n                 |       SHAPE\n-                        { $$ = XKB_ATOM_NONE; }\n+                        { $$ = xkb_atom_intern_literal(param->ctx, \"shape\"); }\n                 |       ROW\n-                        { $$ = XKB_ATOM_NONE; }\n+                        { $$ = xkb_atom_intern_literal(param->ctx, \"row\"); }\n                 |       SECTION\n-                        { $$ = XKB_ATOM_NONE; }\n+                        { $$ = xkb_atom_intern_literal(param->ctx, \"section\"); }\n                 |       TEXT\n-                        { $$ = XKB_ATOM_NONE; }\n+                        { $$ = xkb_atom_intern_literal(param->ctx, \"text\"); }\n                 ;\n \n OptMergeMode    :       MergeMode       { $$ = $1; }\n@@ -687,7 +687,7 @@ Terminal        :       String\n                 |       Integer\n                         { $$ = ExprCreateInteger($1); }\n                 |       Float\n-                        { $$ = NULL; }\n+                        { $$ = ExprCreateFloat(\/* Discard $1 *\/); }\n                 |       KEYNAME\n                         { $$ = ExprCreateKeyName($1); }\n                 ;\n","owner":"xkbcommon","repo":"libxkbcommon","source":"cve"},{"CVE_ID":"CVE-2019-11810","CWE_ID":"476","category":"security","commit_id":"bcf3b67d16a4c8ffae0aa79de5853435e683945c","commit_message":"From bcf3b67d16a4c8ffae0aa79de5853435e683945c Mon Sep 17 00:00:00 2001\nFrom: Jason Yan <yanaijie@huawei.com>\nDate: Fri, 15 Feb 2019 19:50:27 +0800\nSubject: scsi: megaraid_sas: return error when create DMA pool failed\n\nwhen create DMA pool for cmd frames failed, we should return -ENOMEM,\ninstead of 0.\nIn some case in:\n\n    megasas_init_adapter_fusion()\n\n    -->megasas_alloc_cmds()\n       -->megasas_create_frame_pool\n          create DMA pool failed,\n        --> megasas_free_cmds() [1]\n\n    -->megasas_alloc_cmds_fusion()\n       failed, then goto fail_alloc_cmds.\n    -->megasas_free_cmds() [2]\n\nwe will call megasas_free_cmds twice, [1] will kfree cmd_list,\n[2] will use cmd_list.it will cause a problem:\n\nUnable to handle kernel NULL pointer dereference at virtual address\n00000000\npgd = ffffffc000f70000\n[00000000] *pgd=0000001fbf893003, *pud=0000001fbf893003,\n*pmd=0000001fbf894003, *pte=006000006d000707\nInternal error: Oops: 96000005 [#1] SMP\n Modules linked in:\n CPU: 18 PID: 1 Comm: swapper\/0 Not tainted\n task: ffffffdfb9290000 ti: ffffffdfb923c000 task.ti: ffffffdfb923c000\n PC is at megasas_free_cmds+0x30\/0x70\n LR is at megasas_free_cmds+0x24\/0x70\n ...\n Call trace:\n [<ffffffc0005b779c>] megasas_free_cmds+0x30\/0x70\n [<ffffffc0005bca74>] megasas_init_adapter_fusion+0x2f4\/0x4d8\n [<ffffffc0005b926c>] megasas_init_fw+0x2dc\/0x760\n [<ffffffc0005b9ab0>] megasas_probe_one+0x3c0\/0xcd8\n [<ffffffc0004a5abc>] local_pci_probe+0x4c\/0xb4\n [<ffffffc0004a5c40>] pci_device_probe+0x11c\/0x14c\n [<ffffffc00053a5e4>] driver_probe_device+0x1ec\/0x430\n [<ffffffc00053a92c>] __driver_attach+0xa8\/0xb0\n [<ffffffc000538178>] bus_for_each_dev+0x74\/0xc8\n  [<ffffffc000539e88>] driver_attach+0x28\/0x34\n [<ffffffc000539a18>] bus_add_driver+0x16c\/0x248\n [<ffffffc00053b234>] driver_register+0x6c\/0x138\n [<ffffffc0004a5350>] __pci_register_driver+0x5c\/0x6c\n [<ffffffc000ce3868>] megasas_init+0xc0\/0x1a8\n [<ffffffc000082a58>] do_one_initcall+0xe8\/0x1ec\n [<ffffffc000ca7be8>] kernel_init_freeable+0x1c8\/0x284\n [<ffffffc0008d90b8>] kernel_init+0x1c\/0xe4\n\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nAcked-by: Sumit Saxena <sumit.saxena@broadcom.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>\n---\n drivers\/scsi\/megaraid\/megaraid_sas_base.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/drivers\/scsi\/megaraid\/megaraid_sas_base.c b\/drivers\/scsi\/megaraid\/megaraid_sas_base.c\nindex ed730d054052..8a2ee4cf26b0 100644\n--- a\/drivers\/scsi\/megaraid\/megaraid_sas_base.c\n+++ b\/drivers\/scsi\/megaraid\/megaraid_sas_base.c\n@@ -4188,6 +4188,7 @@ int megasas_alloc_cmds(struct megasas_instance *instance)\n \tif (megasas_create_frame_pool(instance)) {\n \t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n \t\tmegasas_free_cmds(instance);\n+\t\treturn -ENOMEM;\n \t}\n \n \treturn 0;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-15863","CWE_ID":"476","category":"security","commit_id":"96df3106d49438e442510c59acad306e94f3db4d","commit_message":"From 96df3106d49438e442510c59acad306e94f3db4d Mon Sep 17 00:00:00 2001\nFrom: Daniel Stone <daniels@collabora.com>\nDate: Mon, 26 Jun 2017 17:12:29 +0100\nSubject: [PATCH] xkbcomp: Don't crash on no-op modmask expressions\n\nIf we have an expression of the form 'l1' in an interp section, we\nunconditionally try to dereference its args, even if it has none.\n\nSigned-off-by: Daniel Stone <daniels@collabora.com>\n---\n src\/xkbcomp\/compat.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/xkbcomp\/compat.c b\/src\/xkbcomp\/compat.c\nindex 9ae26cd..bd587c8 100644\n--- a\/src\/xkbcomp\/compat.c\n+++ b\/src\/xkbcomp\/compat.c\n@@ -264,7 +264,8 @@ ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n     *pred_rtrn = MATCH_EXACTLY;\n     if (expr->expr.op == EXPR_ACTION_DECL) {\n         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n-        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n+        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn) ||\n+            !expr->action.args) {\n             log_err(info->ctx,\n                     \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n             return false;\n","owner":"xkbcommon","repo":"libxkbcommon","source":"cve"},{"CVE_ID":"CVE-2016-9934","CWE_ID":"476","category":"security","commit_id":"6045de69c7dedcba3eadf7c4bba424b19c81d00d","commit_message":"From 6045de69c7dedcba3eadf7c4bba424b19c81d00d Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 23 Oct 2016 20:07:47 -0700\nSubject: [PATCH] Fix bug #73331 - do not try to serialize\/unserialize objects\n wddx can not handle\n\nProper soltion would be to call serialize\/unserialize and deal with the result,\nbut this requires more work that should be done by wddx maintainer (not me).\n---\n ext\/pdo\/pdo_stmt.c           |  1 +\n ext\/wddx\/tests\/bug45901.phpt |  4 ++-\n ext\/wddx\/tests\/bug72790.phpt |  2 +-\n ext\/wddx\/tests\/bug73331.phpt | 15 ++++++++\n ext\/wddx\/wddx.c              | 67 +++++++++++++++++++-----------------\n 5 files changed, 55 insertions(+), 34 deletions(-)\n create mode 100644 ext\/wddx\/tests\/bug73331.phpt\n\n","diff_code":"diff --git a\/ext\/pdo\/pdo_stmt.c b\/ext\/pdo\/pdo_stmt.c\nindex f5c295c26c37..9f9ada9be3bf 100644\n--- a\/ext\/pdo\/pdo_stmt.c\n+++ b\/ext\/pdo\/pdo_stmt.c\n@@ -2338,6 +2338,7 @@ void pdo_stmt_init(TSRMLS_D)\n \tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; \/* when removing this a lot of handlers need to be redone *\/\n \tpdo_row_ce->create_object = pdo_row_new;\n \tpdo_row_ce->serialize = pdo_row_serialize;\n+\tpdo_row_ce->unserialize = zend_class_unserialize_deny;\n }\n \n static void free_statement(pdo_stmt_t *stmt TSRMLS_DC)\ndiff --git a\/ext\/wddx\/tests\/bug45901.phpt b\/ext\/wddx\/tests\/bug45901.phpt\nindex 4084ccbf202b..e76e47eab725 100644\n--- a\/ext\/wddx\/tests\/bug45901.phpt\n+++ b\/ext\/wddx\/tests\/bug45901.phpt\n@@ -14,5 +14,7 @@ echo wddx_serialize_value($xml, 'Variables') . \"\\n\";\n echo \"DONE\";\n ?>\n --EXPECTF--\n-<wddxPacket version='1.0'><header><comment>Variables<\/comment><\/header><data><struct><var name='php_class_name'><string>SimpleXMLElement<\/string><\/var><var name='test'><struct><var name='php_class_name'><string>SimpleXMLElement<\/string><\/var><\/struct><\/var><\/struct><\/data><\/wddxPacket>\n+\n+Warning: wddx_serialize_value(): Class SimpleXMLElement can not be serialized in %sbug45901.php on line %d\n+<wddxPacket version='1.0'><header><comment>Variables<\/comment><\/header><data><\/data><\/wddxPacket>\n DONE\n\\ No newline at end of file\ndiff --git a\/ext\/wddx\/tests\/bug72790.phpt b\/ext\/wddx\/tests\/bug72790.phpt\nindex a60524bdaf19..3b08e58cc680 100644\n--- a\/ext\/wddx\/tests\/bug72790.phpt\n+++ b\/ext\/wddx\/tests\/bug72790.phpt\n@@ -1,5 +1,5 @@\n --TEST--\n-Bug 72790: wddx_deserialize null dereference with invalid xml\n+Bug #72790: wddx_deserialize null dereference with invalid xml\n --SKIPIF--\n <?php\n if (!extension_loaded('wddx')) {\ndiff --git a\/ext\/wddx\/tests\/bug73331.phpt b\/ext\/wddx\/tests\/bug73331.phpt\nnew file mode 100644\nindex 000000000000..7e4cda1ea116\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug73331.phpt\n@@ -0,0 +1,15 @@\n+--TEST--\n+Bug #73331 (NULL Pointer Dereference in WDDX Packet Deserialization with PDORow)\n+--SKIPIF--\n+<?php if (!extension_loaded(\"wddx\") || !extension_loaded(\"pdo\")) print \"skip\"; ?>\n+--FILE--\n+<?php\n+\n+$wddx = \"<wddxPacket version='1.0'><header\/><data><struct><var name='php_class_name'><string>PDORow<\/string><\/var><\/struct><\/data><\/wddxPacket>\";\n+var_dump(wddx_deserialize($wddx));\n+?>\n+--EXPECTF--\n+\n+Warning: wddx_deserialize(): Class pdorow can not be unserialized in %s73331.php on line %d\n+NULL\n+\ndiff --git a\/ext\/wddx\/wddx.c b\/ext\/wddx\/wddx.c\nindex 0e77826ce847..59cc8ddda8a9 100644\n--- a\/ext\/wddx\/wddx.c\n+++ b\/ext\/wddx\/wddx.c\n@@ -471,21 +471,26 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \tulong idx;\n \tchar tmp_buf[WDDX_BUF_LEN];\n \tHashTable *objhash, *sleephash;\n+\tzend_class_entry *ce;\n+\tPHP_CLASS_ATTRIBUTES;\n \tTSRMLS_FETCH();\n \n+\tPHP_SET_CLASS_ATTRIBUTES(obj);\n+\tce = Z_OBJCE_P(obj);\n+\tif (!ce || ce->serialize || ce->unserialize) {\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Class %s can not be serialized\", class_name);\n+\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n+\t\treturn;\n+\t}\n+\n \tMAKE_STD_ZVAL(fname);\n \tZVAL_STRING(fname, \"__sleep\", 1);\n-\n \t\/*\n \t * We try to call __sleep() method on object. It's supposed to return an\n \t * array of property names to be serialized.\n \t *\/\n \tif (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) {\n \t\tif (retval && (sleephash = HASH_OF(retval))) {\n-\t\t\tPHP_CLASS_ATTRIBUTES;\n-\n-\t\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n-\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\t\tphp_wddx_add_chunk(packet, tmp_buf);\n@@ -494,8 +499,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n-\t\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n-\n \t\t\tobjhash = HASH_OF(obj);\n \n \t\t\tfor (zend_hash_internal_pointer_reset(sleephash);\n@@ -516,10 +519,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t} else {\n \t\tuint key_len;\n \n-\t\tPHP_CLASS_ATTRIBUTES;\n-\n-\t\tPHP_SET_CLASS_ATTRIBUTES(obj);\n-\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n \t\tsnprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR);\n \t\tphp_wddx_add_chunk(packet, tmp_buf);\n@@ -528,8 +527,6 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRING_E);\n \t\tphp_wddx_add_chunk_static(packet, WDDX_VAR_E);\n \n-\t\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n-\n \t\tobjhash = HASH_OF(obj);\n \t\tfor (zend_hash_internal_pointer_reset(objhash);\n \t\t\t zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS;\n@@ -551,6 +548,8 @@ static void php_wddx_serialize_object(wddx_packet *packet, zval *obj)\n \t\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n \t}\n \n+\tPHP_CLEANUP_CLASS_ATTRIBUTES();\n+\n \tzval_dtor(fname);\n \tFREE_ZVAL(fname);\n \n@@ -1012,26 +1011,30 @@ static void php_wddx_pop_element(void *user_data, const XML_Char *name)\n \t\t\t\t\t\t\tpce = &PHP_IC_ENTRY;\n \t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\/* Initialize target object *\/\n-\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n-\t\t\t\t\t\tobject_init_ex(obj, *pce);\n-\n-\t\t\t\t\t\t\/* Merge current hashtable with object's default properties *\/\n-\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n-\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n-\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n-\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n-\n-\t\t\t\t\t\tif (incomplete_class) {\n-\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n+\t\t\t\t\t\tif (pce != &PHP_IC_ENTRY && ((*pce)->serialize || (*pce)->unserialize)) {\n+\t\t\t\t\t\t\tent2->data = NULL;\n+\t\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Class %s can not be unserialized\", Z_STRVAL_P(ent1->data));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\/* Initialize target object *\/\n+\t\t\t\t\t\t\tMAKE_STD_ZVAL(obj);\n+\t\t\t\t\t\t\tobject_init_ex(obj, *pce);\n+\n+\t\t\t\t\t\t\t\/* Merge current hashtable with object's default properties *\/\n+\t\t\t\t\t\t\tzend_hash_merge(Z_OBJPROP_P(obj),\n+\t\t\t\t\t\t\t\t\t\t\tZ_ARRVAL_P(ent2->data),\n+\t\t\t\t\t\t\t\t\t\t\t(void (*)(void *)) zval_add_ref,\n+\t\t\t\t\t\t\t\t\t\t\t(void *) &tmp, sizeof(zval *), 0);\n+\n+\t\t\t\t\t\t\tif (incomplete_class) {\n+\t\t\t\t\t\t\t\tphp_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\/* Clean up old array entry *\/\n+\t\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n+\n+\t\t\t\t\t\t\t\/* Set stack entry to point to the newly created object *\/\n+\t\t\t\t\t\t\tent2->data = obj;\n \t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\/* Clean up old array entry *\/\n-\t\t\t\t\t\tzval_ptr_dtor(&ent2->data);\n-\n-\t\t\t\t\t\t\/* Set stack entry to point to the newly created object *\/\n-\t\t\t\t\t\tent2->data = obj;\n-\n \t\t\t\t\t\t\/* Clean up class name var entry *\/\n \t\t\t\t\t\tzval_ptr_dtor(&ent1->data);\n \t\t\t\t\t} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2018-1065","CWE_ID":"476","category":"security","commit_id":"57ebd808a97d7c5b1e1afb937c2db22beba3c1f8","commit_message":"From 57ebd808a97d7c5b1e1afb937c2db22beba3c1f8 Mon Sep 17 00:00:00 2001\nFrom: Florian Westphal <fw@strlen.de>\nDate: Wed, 7 Feb 2018 13:46:25 +0100\nSubject: [PATCH] netfilter: add back stackpointer size checks\n\nThe rationale for removing the check is only correct for rulesets\ngenerated by ip(6)tables.\n\nIn iptables, a jump can only occur to a user-defined chain, i.e.\nbecause we size the stack based on number of user-defined chains we\ncannot exceed stack size.\n\nHowever, the underlying binary format has no such restriction,\nand the validation step only ensures that the jump target is a\nvalid rule start point.\n\nIOW, its possible to build a rule blob that has no user-defined\nchains but does contain a jump.\n\nIf this happens, no jump stack gets allocated and crash occurs\nbecause no jumpstack was allocated.\n\nFixes: 7814b6ec6d0d6 (\"netfilter: xtables: don't save\/restore jumpstack offset\")\nReported-by: syzbot+e783f671527912cd9403@syzkaller.appspotmail.com\nSigned-off-by: Florian Westphal <fw@strlen.de>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>\n---\n net\/ipv4\/netfilter\/arp_tables.c | 4 ++++\n net\/ipv4\/netfilter\/ip_tables.c  | 7 ++++++-\n net\/ipv6\/netfilter\/ip6_tables.c | 4 ++++\n 3 files changed, 14 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/netfilter\/arp_tables.c b\/net\/ipv4\/netfilter\/arp_tables.c\nindex 4ffe302f9b820..e3e420f3ba7b2 100644\n--- a\/net\/ipv4\/netfilter\/arp_tables.c\n+++ b\/net\/ipv4\/netfilter\/arp_tables.c\n@@ -252,6 +252,10 @@ unsigned int arpt_do_table(struct sk_buff *skb,\n \t\t\t}\n \t\t\tif (table_base + v\n \t\t\t    != arpt_next_entry(e)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n \ndiff --git a\/net\/ipv4\/netfilter\/ip_tables.c b\/net\/ipv4\/netfilter\/ip_tables.c\nindex 9a71f31495070..e38395a8dcf28 100644\n--- a\/net\/ipv4\/netfilter\/ip_tables.c\n+++ b\/net\/ipv4\/netfilter\/ip_tables.c\n@@ -330,8 +330,13 @@ ipt_do_table(struct sk_buff *skb,\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif (table_base + v != ipt_next_entry(e) &&\n-\t\t\t    !(e->ip.flags & IPT_F_GOTO))\n+\t\t\t    !(e->ip.flags & IPT_F_GOTO)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n+\t\t\t}\n \n \t\t\te = get_entry(table_base, v);\n \t\t\tcontinue;\ndiff --git a\/net\/ipv6\/netfilter\/ip6_tables.c b\/net\/ipv6\/netfilter\/ip6_tables.c\nindex af4c917e08369..62358b93bbac5 100644\n--- a\/net\/ipv6\/netfilter\/ip6_tables.c\n+++ b\/net\/ipv6\/netfilter\/ip6_tables.c\n@@ -352,6 +352,10 @@ ip6t_do_table(struct sk_buff *skb,\n \t\t\t}\n \t\t\tif (table_base + v != ip6t_next_entry(e) &&\n \t\t\t    !(e->ipv6.flags & IP6T_F_GOTO)) {\n+\t\t\t\tif (unlikely(stackidx >= private->stacksize)) {\n+\t\t\t\t\tverdict = NF_DROP;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tjumpstack[stackidx++] = e;\n \t\t\t}\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-12108","CWE_ID":"476","category":"security","commit_id":"86030db849260dd8fb2ed975b9890aef1b62b692","commit_message":"From 86030db849260dd8fb2ed975b9890aef1b62b692 Mon Sep 17 00:00:00 2001\nFrom: Thomas Bernard <miniupnp@free.fr>\nDate: Tue, 18 Dec 2018 23:47:54 +0100\nSubject: [PATCH] fix error from commit\n 13585f15c7f7dc28bbbba1661efb280d530d114c\n\n---\n miniupnpd\/upnpsoap.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/miniupnpd\/upnpsoap.c b\/miniupnpd\/upnpsoap.c\nindex 997b3254..acd7fedf 100644\n--- a\/miniupnpd\/upnpsoap.c\n+++ b\/miniupnpd\/upnpsoap.c\n@@ -1850,7 +1850,7 @@ GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \n-\tif (!int_port || !ext_port || !protocol)\n+\tif (!int_port || !rem_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \"Invalid Args\");\n","owner":"miniupnp","repo":"miniupnp","source":"cve"},{"CVE_ID":"CVE-2017-9608","CWE_ID":"476","category":"security","commit_id":"31c1c0b46a7021802c3d1d18039fca30dba5a14e","commit_message":"From 31c1c0b46a7021802c3d1d18039fca30dba5a14e Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Wed, 14 Jun 2017 16:58:20 +0200\nSubject: [PATCH] avcodec\/dnxhd_parser: Do not return invalid value from\n dnxhd_find_frame_end() on error\n\nFixes: Null pointer dereference\n\nFixes: CVE-2017-9608\nFound-by: Yihan Lian\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 611b35627488a8d0763e75c25ee0875c5b7987dd)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/dnxhd_parser.c | 12 +++++++-----\n 1 file changed, 7 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/dnxhd_parser.c b\/libavcodec\/dnxhd_parser.c\nindex 4f9bbceeeb5..2519cf23c3c 100644\n--- a\/libavcodec\/dnxhd_parser.c\n+++ b\/libavcodec\/dnxhd_parser.c\n@@ -87,16 +87,18 @@ static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n+                int remaining;\n \n                 if (cid <= 0)\n                     continue;\n \n-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n-                if (dctx->remaining <= 0) {\n-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n-                    if (dctx->remaining <= 0)\n-                        return dctx->remaining;\n+                remaining = avpriv_dnxhd_get_frame_size(cid);\n+                if (remaining <= 0) {\n+                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n+                    if (remaining <= 0)\n+                        continue;\n                 }\n+                dctx->remaining = remaining;\n                 if (buf_size - i >= dctx->remaining && (!dctx->interlaced || dctx->cur_field)) {\n                     int remaining = dctx->remaining;\n \n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2018-12247","CWE_ID":"476","category":"security","commit_id":"55edae0226409de25e59922807cb09acb45731a2","commit_message":"From 55edae0226409de25e59922807cb09acb45731a2 Mon Sep 17 00:00:00 2001\nFrom: \"Yukihiro \\\"Matz\\\" Matsumoto\" <matz@ruby.or.jp>\nDate: Thu, 7 Jun 2018 16:17:00 +0900\nSubject: [PATCH] Allow `Object#clone` to copy frozen status only; fix #4036\n\nCopying all flags from the original object may overwrite the clone's\nflags e.g. the embedded flag.\n---\n src\/kernel.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/kernel.c b\/src\/kernel.c\nindex f378004cb..bbe6e8bb7 100644\n--- a\/src\/kernel.c\n+++ b\/src\/kernel.c\n@@ -348,7 +348,7 @@ mrb_obj_clone(mrb_state *mrb, mrb_value self)\n   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n   clone = mrb_obj_value(p);\n   init_copy(mrb, clone, self);\n-  p->flags = mrb_obj_ptr(self)->flags;\n+  p->flags |= mrb_obj_ptr(self)->flags & MRB_FLAG_IS_FROZEN;\n \n   return clone;\n }\n","owner":"mruby","repo":"mruby","source":"cve"},{"CVE_ID":"CVE-2019-12109","CWE_ID":"476","category":"security","commit_id":"13585f15c7f7dc28bbbba1661efb280d530d114c","commit_message":"From 13585f15c7f7dc28bbbba1661efb280d530d114c Mon Sep 17 00:00:00 2001\nFrom: Thomas Bernard <miniupnp@free.fr>\nDate: Tue, 18 Dec 2018 22:54:51 +0100\nSubject: [PATCH] GetOutboundPinholeTimeout: check args\n\n---\n miniupnpd\/upnpsoap.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/miniupnpd\/upnpsoap.c b\/miniupnpd\/upnpsoap.c\nindex e7193c0a..997b3254 100644\n--- a\/miniupnpd\/upnpsoap.c\n+++ b\/miniupnpd\/upnpsoap.c\n@@ -1850,6 +1850,13 @@ GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char *\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \n+\tif (!int_port || !ext_port || !protocol)\n+\t{\n+\t\tClearNameValueList(&data);\n+\t\tSoapError(h, 402, \"Invalid Args\");\n+\t\treturn;\n+\t}\n+\n \trport = (unsigned short)atoi(rem_port);\n \tiport = (unsigned short)atoi(int_port);\n \t\/*proto = atoi(protocol);*\/\n","owner":"miniupnp","repo":"miniupnp","source":"cve"},{"CVE_ID":"CVE-2018-12460","CWE_ID":"476","category":"security","commit_id":"b3332a182f8ba33a34542e4a0370f38b914ccf7d","commit_message":"From b3332a182f8ba33a34542e4a0370f38b914ccf7d Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Mon, 28 May 2018 21:19:08 +0200\nSubject: [PATCH] avcodec\/idctdsp: Transmit studio_profile to init instead of\n using AVCodecContext profile\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThese 2 fields are not always the same, it is simpler to always use the same field\nfor detecting studio profile\n\nFixes: null pointer dereference\nFixes: ffmpeg_crash_3.avi\n\nFound-by: Thuan Pham <thuanpv@comp.nus.edu.sg>, Marcel B\u00f6hme, Andrew Santosa and Alexandru RazvanCaciulescu with AFLSmart\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/idctdsp.c   | 2 +-\n libavcodec\/idctdsp.h   | 2 ++\n libavcodec\/mpegvideo.c | 2 ++\n 3 files changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/idctdsp.c b\/libavcodec\/idctdsp.c\nindex 662033bd780..954066a5e3c 100644\n--- a\/libavcodec\/idctdsp.c\n+++ b\/libavcodec\/idctdsp.c\n@@ -258,7 +258,7 @@ av_cold void ff_idctdsp_init(IDCTDSPContext *c, AVCodecContext *avctx)\n         if (avctx->bits_per_raw_sample == 10 || avctx->bits_per_raw_sample == 9) {\n             \/* 10-bit MPEG-4 Simple Studio Profile requires a higher precision IDCT\n                However, it only uses idct_put *\/\n-            if (avctx->codec_id == AV_CODEC_ID_MPEG4 && avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO)\n+            if (c->mpeg4_studio_profile)\n                 c->idct_put              = ff_simple_idct_put_int32_10bit;\n             else {\n                 c->idct_put              = ff_simple_idct_put_int16_10bit;\ndiff --git a\/libavcodec\/idctdsp.h b\/libavcodec\/idctdsp.h\nindex 26221f6a9de..ca21a31a028 100644\n--- a\/libavcodec\/idctdsp.h\n+++ b\/libavcodec\/idctdsp.h\n@@ -95,6 +95,8 @@ typedef struct IDCTDSPContext {\n      *\/\n     uint8_t idct_permutation[64];\n     enum idct_permutation_type perm_type;\n+\n+    int mpeg4_studio_profile;\n } IDCTDSPContext;\n \n void ff_put_pixels_clamped_c(const int16_t *block, uint8_t *av_restrict pixels,\ndiff --git a\/libavcodec\/mpegvideo.c b\/libavcodec\/mpegvideo.c\nindex 45ea0f09e9c..f75c0fd9b36 100644\n--- a\/libavcodec\/mpegvideo.c\n+++ b\/libavcodec\/mpegvideo.c\n@@ -329,6 +329,8 @@ static av_cold int dct_init(MpegEncContext *s)\n \n av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n+    if (s->codec_id == AV_CODEC_ID_MPEG4)\n+        s->idsp.mpeg4_studio_profile = s->studio_profile;\n     ff_idctdsp_init(&s->idsp, s->avctx);\n \n     \/* load & permutate scantables\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2018-1130","CWE_ID":"476","category":"security","commit_id":"67f93df79aeefc3add4e4b31a752600f834236e2","commit_message":"From 67f93df79aeefc3add4e4b31a752600f834236e2 Mon Sep 17 00:00:00 2001\nFrom: Alexey Kodanev <alexey.kodanev@oracle.com>\nDate: Tue, 6 Mar 2018 22:57:01 +0300\nSubject: dccp: check sk for closed state in dccp_sendmsg()\n\ndccp_disconnect() sets 'dp->dccps_hc_tx_ccid' tx handler to NULL,\ntherefore if DCCP socket is disconnected and dccp_sendmsg() is\ncalled after it, it will cause a NULL pointer dereference in\ndccp_write_xmit().\n\nThis crash and the reproducer was reported by syzbot. Looks like\nit is reproduced if commit 69c64866ce07 (\"dccp: CVE-2017-8824:\nuse-after-free in DCCP code\") is applied.\n\nReported-by: syzbot+f99ab3887ab65d70f816@syzkaller.appspotmail.com\nSigned-off-by: Alexey Kodanev <alexey.kodanev@oracle.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/dccp\/proto.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/net\/dccp\/proto.c b\/net\/dccp\/proto.c\nindex 15bdc002d90c..84cd4e3fd01b 100644\n--- a\/net\/dccp\/proto.c\n+++ b\/net\/dccp\/proto.c\n@@ -794,6 +794,11 @@ int dccp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n \tif (skb == NULL)\n \t\tgoto out_release;\n \n+\tif (sk->sk_state == DCCP_CLOSED) {\n+\t\trc = -ENOTCONN;\n+\t\tgoto out_discard;\n+\t}\n+\n \tskb_reserve(skb, sk->sk_prot->max_header);\n \trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n \tif (rc != 0)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-4054","CWE_ID":"476","category":"security","commit_id":"edab5be6665b9e8de66c25ba527509b229468573","commit_message":"From edab5be6665b9e8de66c25ba527509b229468573 Mon Sep 17 00:00:00 2001\nFrom: Marko Kreen <markokr@gmail.com>\nDate: Wed, 8 Apr 2015 09:22:55 +0300\nSubject: [PATCH] Check if auth_user is set.\n\nFixes a crash if password packet appears before startup packet (#42).\n---\n src\/client.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/src\/client.c b\/src\/client.c\nindex 275fd1aa..49b26244 100644\n--- a\/src\/client.c\n+++ b\/src\/client.c\n@@ -39,6 +39,12 @@ static bool check_client_passwd(PgSocket *client, const char *passwd)\n \tconst char *correct;\n \tPgUser *user = client->auth_user;\n \n+\t\/* auth_user may be missing *\/\n+\tif (!user) {\n+\t\tslog_error(client, \"Password packet before auth packet?\");\n+\t\treturn false;\n+\t}\n+\n \t\/* disallow empty passwords *\/\n \tif (!*passwd || !*user->passwd)\n \t\treturn false;\n","owner":"pgbouncer","repo":"pgbouncer","source":"cve"},{"CVE_ID":"CVE-2017-12474","CWE_ID":"476","category":"security","commit_id":"4d3f0bebd5f8518fd775f671c12bea58c68e814e","commit_message":"From 4d3f0bebd5f8518fd775f671c12bea58c68e814e Mon Sep 17 00:00:00 2001\nFrom: Gilles Boccon-Gibod <bok@bok.net>\nDate: Sun, 30 Jul 2017 15:29:24 -0700\nSubject: [PATCH] fixed possible crashes on malformed inputs.\n\n---\n Source\/C++\/Core\/Ap4AtomSampleTable.cpp | 5 +++++\n Source\/C++\/Core\/Ap4AvccAtom.cpp        | 2 +-\n Source\/C++\/Core\/Ap4Processor.cpp       | 1 +\n Source\/C++\/Core\/Ap4Version.h           | 4 ++--\n 4 files changed, 9 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp b\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\nindex 19e05dad..77d11191 100644\n--- a\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\n+++ b\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\n@@ -87,6 +87,11 @@ AP4_AtomSampleTable::GetSample(AP4_Ordinal index,\n {\n     AP4_Result result;\n \n+    \/\/ check that we have an stsc atom\n+    if (!m_StscAtom) {\n+        return AP4_ERROR_INVALID_FORMAT;\n+    }\n+    \n     \/\/ check that we have a chunk offset table\n     if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n         return AP4_ERROR_INVALID_FORMAT;\ndiff --git a\/Source\/C++\/Core\/Ap4AvccAtom.cpp b\/Source\/C++\/Core\/Ap4AvccAtom.cpp\nindex a1167d0d..d14f9a6a 100644\n--- a\/Source\/C++\/Core\/Ap4AvccAtom.cpp\n+++ b\/Source\/C++\/Core\/Ap4AvccAtom.cpp\n@@ -270,7 +270,7 @@ AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n     for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n         inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n     }\n-    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n+    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n         inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n     }\n     return AP4_SUCCESS;\ndiff --git a\/Source\/C++\/Core\/Ap4Processor.cpp b\/Source\/C++\/Core\/Ap4Processor.cpp\nindex ae6eb7df..9c1a7ec5 100644\n--- a\/Source\/C++\/Core\/Ap4Processor.cpp\n+++ b\/Source\/C++\/Core\/Ap4Processor.cpp\n@@ -554,6 +554,7 @@ AP4_Processor::Process(AP4_ByteStream&   input,\n             int cursor = -1;\n             for (unsigned int i=0; i<track_count; i++) {\n                 if (!cursors[i].m_EndReached &&\n+                    cursors[i].m_Locator.m_SampleTable &&\n                     cursors[i].m_Locator.m_Sample.GetOffset() <= min_offset) {\n                     min_offset = cursors[i].m_Locator.m_Sample.GetOffset();\n                     cursor = i;\ndiff --git a\/Source\/C++\/Core\/Ap4Version.h b\/Source\/C++\/Core\/Ap4Version.h\nindex 60620afe..5ffb7f69 100644\n--- a\/Source\/C++\/Core\/Ap4Version.h\n+++ b\/Source\/C++\/Core\/Ap4Version.h\n@@ -37,7 +37,7 @@\n \/**\n  * Version number of the SDK\n  *\/\n-#define AP4_VERSION        0x01050000\n-#define AP4_VERSION_STRING \"1.5.0.0\"\n+#define AP4_VERSION        0x01050001\n+#define AP4_VERSION_STRING \"1.5.0.1\"\n \n #endif \/\/ _AP4_VERSION_H_\n","owner":"axiomatic-systems","repo":"Bento4","source":"cve"},{"CVE_ID":"CVE-2017-16532","CWE_ID":"476","category":"security","commit_id":"7c80f9e4a588f1925b07134bb2e3689335f6c6d8","commit_message":"From 7c80f9e4a588f1925b07134bb2e3689335f6c6d8 Mon Sep 17 00:00:00 2001\nFrom: Alan Stern <stern@rowland.harvard.edu>\nDate: Fri, 29 Sep 2017 10:54:24 -0400\nSubject: [PATCH] usb: usbtest: fix NULL pointer dereference\n\nIf the usbtest driver encounters a device with an IN bulk endpoint but\nno OUT bulk endpoint, it will try to dereference a NULL pointer\n(out->desc.bEndpointAddress).  The problem can be solved by adding a\nmissing test.\n\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>\n---\n drivers\/usb\/misc\/usbtest.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/usb\/misc\/usbtest.c b\/drivers\/usb\/misc\/usbtest.c\nindex 113e38bfe0ef9..b3fc602b2e247 100644\n--- a\/drivers\/usb\/misc\/usbtest.c\n+++ b\/drivers\/usb\/misc\/usbtest.c\n@@ -202,12 +202,13 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n \t\t\treturn tmp;\n \t}\n \n-\tif (in) {\n+\tif (in)\n \t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n \t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n+\tif (out)\n \t\tdev->out_pipe = usb_sndbulkpipe(udev,\n \t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n-\t}\n+\n \tif (iso_in) {\n \t\tdev->iso_in = &iso_in->desc;\n \t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-12111","CWE_ID":"476","category":"security","commit_id":"cb8a02af7a5677cf608e86d57ab04241cf34e24f","commit_message":"From cb8a02af7a5677cf608e86d57ab04241cf34e24f Mon Sep 17 00:00:00 2001\nFrom: Thomas Bernard <miniupnp@free.fr>\nDate: Tue, 18 Dec 2018 23:04:14 +0100\nSubject: [PATCH] pcpserver.c: copyIPv6IfDifferent() check for NULL src\n argument\n\n---\n miniupnpd\/pcpserver.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/miniupnpd\/pcpserver.c b\/miniupnpd\/pcpserver.c\nindex 9acfb44f..a964aa9f 100644\n--- a\/miniupnpd\/pcpserver.c\n+++ b\/miniupnpd\/pcpserver.c\n@@ -177,7 +177,7 @@ static const char * getPCPOpCodeStr(uint8_t opcode)\n  * buffers are same *\/\n static void copyIPv6IfDifferent(void * dest, const void * src)\n {\n-\tif(dest != src) {\n+\tif(dest != src && src != NULL) {\n \t\tmemcpy(dest, src, sizeof(struct in6_addr));\n \t}\n }\n","owner":"miniupnp","repo":"miniupnp","source":"cve"},{"CVE_ID":"CVE-2018-14646","CWE_ID":"476","category":"security","commit_id":"f428fe4a04cc339166c8bbd489789760de3a0cee","commit_message":"From f428fe4a04cc339166c8bbd489789760de3a0cee Mon Sep 17 00:00:00 2001\nFrom: Andrei Vagin <avagin@openvz.org>\nDate: Tue, 2 Jan 2018 23:27:33 -0800\nSubject: rtnetlink: give a user socket to get_target_net()\n\nThis function is used from two places: rtnl_dump_ifinfo and\nrtnl_getlink. In rtnl_getlink(), we give a request skb into\nget_target_net(), but in rtnl_dump_ifinfo, we give a response skb\ninto get_target_net().\nThe problem here is that NETLINK_CB() isn't initialized for the response\nskb. In both cases we can get a user socket and give it instead of skb\ninto get_target_net().\n\nThis bug was found by syzkaller with this call-trace:\n\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN\nModules linked in:\nCPU: 1 PID: 3149 Comm: syzkaller140561 Not tainted 4.15.0-rc4-mm1+ #47\nHardware name: Google Google Compute Engine\/Google Compute Engine, BIOS\nGoogle 01\/01\/2011\nRIP: 0010:__netlink_ns_capable+0x8b\/0x120 net\/netlink\/af_netlink.c:868\nRSP: 0018:ffff8801c880f348 EFLAGS: 00010206\nRAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff8443f900\nRDX: 000000000000007b RSI: ffffffff86510f40 RDI: 00000000000003d8\nRBP: ffff8801c880f360 R08: 0000000000000000 R09: 1ffff10039101e4f\nR10: 0000000000000000 R11: 0000000000000001 R12: ffffffff86510f40\nR13: 000000000000000c R14: 0000000000000004 R15: 0000000000000011\nFS:  0000000001a1a880(0000) GS:ffff8801db300000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020151000 CR3: 00000001c9511005 CR4: 00000000001606e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n  netlink_ns_capable+0x26\/0x30 net\/netlink\/af_netlink.c:886\n  get_target_net+0x9d\/0x120 net\/core\/rtnetlink.c:1765\n  rtnl_dump_ifinfo+0x2e5\/0xee0 net\/core\/rtnetlink.c:1806\n  netlink_dump+0x48c\/0xce0 net\/netlink\/af_netlink.c:2222\n  __netlink_dump_start+0x4f0\/0x6d0 net\/netlink\/af_netlink.c:2319\n  netlink_dump_start include\/linux\/netlink.h:214 [inline]\n  rtnetlink_rcv_msg+0x7f0\/0xb10 net\/core\/rtnetlink.c:4485\n  netlink_rcv_skb+0x21e\/0x460 net\/netlink\/af_netlink.c:2441\n  rtnetlink_rcv+0x1c\/0x20 net\/core\/rtnetlink.c:4540\n  netlink_unicast_kernel net\/netlink\/af_netlink.c:1308 [inline]\n  netlink_unicast+0x4be\/0x6a0 net\/netlink\/af_netlink.c:1334\n  netlink_sendmsg+0xa4a\/0xe60 net\/netlink\/af_netlink.c:1897\n\nCc: Jiri Benc <jbenc@redhat.com>\nFixes: 79e1ad148c84 (\"rtnetlink: use netnsid to query interface\")\nSigned-off-by: Andrei Vagin <avagin@openvz.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/rtnetlink.c | 10 +++++-----\n 1 file changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/net\/core\/rtnetlink.c b\/net\/core\/rtnetlink.c\nindex dabba2a91fc8..778d7f03404a 100644\n--- a\/net\/core\/rtnetlink.c\n+++ b\/net\/core\/rtnetlink.c\n@@ -1681,18 +1681,18 @@ static bool link_dump_filtered(struct net_device *dev,\n \treturn false;\n }\n \n-static struct net *get_target_net(struct sk_buff *skb, int netnsid)\n+static struct net *get_target_net(struct sock *sk, int netnsid)\n {\n \tstruct net *net;\n \n-\tnet = get_net_ns_by_id(sock_net(skb->sk), netnsid);\n+\tnet = get_net_ns_by_id(sock_net(sk), netnsid);\n \tif (!net)\n \t\treturn ERR_PTR(-EINVAL);\n \n \t\/* For now, the caller is required to have CAP_NET_ADMIN in\n \t * the user namespace owning the target net ns.\n \t *\/\n-\tif (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN)) {\n+\tif (!sk_ns_capable(sk, net->user_ns, CAP_NET_ADMIN)) {\n \t\tput_net(net);\n \t\treturn ERR_PTR(-EACCES);\n \t}\n@@ -1733,7 +1733,7 @@ static int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)\n \t\t\tifla_policy, NULL) >= 0) {\n \t\tif (tb[IFLA_IF_NETNSID]) {\n \t\t\tnetnsid = nla_get_s32(tb[IFLA_IF_NETNSID]);\n-\t\t\ttgt_net = get_target_net(skb, netnsid);\n+\t\t\ttgt_net = get_target_net(skb->sk, netnsid);\n \t\t\tif (IS_ERR(tgt_net)) {\n \t\t\t\ttgt_net = net;\n \t\t\t\tnetnsid = -1;\n@@ -2883,7 +2883,7 @@ static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr *nlh,\n \n \tif (tb[IFLA_IF_NETNSID]) {\n \t\tnetnsid = nla_get_s32(tb[IFLA_IF_NETNSID]);\n-\t\ttgt_net = get_target_net(skb, netnsid);\n+\t\ttgt_net = get_target_net(NETLINK_CB(skb).sk, netnsid);\n \t\tif (IS_ERR(tgt_net))\n \t\t\treturn PTR_ERR(tgt_net);\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-12381","CWE_ID":"476","category":"security","commit_id":"425aa0e1d01513437668fa3d4a971168bbaa8515","commit_message":"From 425aa0e1d01513437668fa3d4a971168bbaa8515 Mon Sep 17 00:00:00 2001\nFrom: Gen Zhang <blackgod016574@gmail.com>\nDate: Fri, 24 May 2019 11:24:26 +0800\nSubject: ip_sockglue: Fix missing-check bug in ip_ra_control()\n\nIn function ip_ra_control(), the pointer new_ra is allocated a memory\nspace via kmalloc(). And it is used in the following codes. However,\nwhen  there is a memory allocation error, kmalloc() fails. Thus null\npointer dereference may happen. And it will cause the kernel to crash.\nTherefore, we should check the return value and handle the error.\n\nSigned-off-by: Gen Zhang <blackgod016574@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/ip_sockglue.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/net\/ipv4\/ip_sockglue.c b\/net\/ipv4\/ip_sockglue.c\nindex 82f341e84fae..aa3fd61818c4 100644\n--- a\/net\/ipv4\/ip_sockglue.c\n+++ b\/net\/ipv4\/ip_sockglue.c\n@@ -343,6 +343,8 @@ int ip_ra_control(struct sock *sk, unsigned char on,\n \t\treturn -EINVAL;\n \n \tnew_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n+\tif (on && !new_ra)\n+\t\treturn -ENOMEM;\n \n \tmutex_lock(&net->ipv4.ra_mutex);\n \tfor (rap = &net->ipv4.ra_chain;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5668","CWE_ID":"476","category":"security","commit_id":"30d598ce7cd3f136ee9d7097f39fa9818a272441","commit_message":"From 30d598ce7cd3f136ee9d7097f39fa9818a272441 Mon Sep 17 00:00:00 2001\nFrom: dequis <dx@dxzone.com.ar>\nDate: Sun, 29 Jan 2017 19:40:09 -0300\nSubject: [PATCH] purple: Fix crash on ft requests from unknown contacts\n\nFollowup to 701ab81 (included in 3.5) which was a partial fix which only\nimproved things for non-libpurple file transfers (that is, just jabber)\n---\n protocols\/purple\/ft.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/protocols\/purple\/ft.c b\/protocols\/purple\/ft.c\nindex 81fee8d0..79476ebc 100644\n--- a\/protocols\/purple\/ft.c\n+++ b\/protocols\/purple\/ft.c\n@@ -145,6 +145,10 @@ static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_conditio\n \t\/* TODO(wilmer): After spreading some more const goodness in BitlBee,\n \t   remove the evil cast below. *\/\n \tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n+\n+\tif (!px->ft) {\n+\t\treturn FALSE;\n+\t}\n \tpx->ft->data = px;\n \n \tpx->ft->accept = prpl_xfer_accept;\n","owner":"bitlbee","repo":"bitlbee","source":"cve"},{"CVE_ID":"CVE-2018-1066","CWE_ID":"476","category":"security","commit_id":"cabfb3680f78981d26c078a26e5c748531257ebb","commit_message":"From cabfb3680f78981d26c078a26e5c748531257ebb Mon Sep 17 00:00:00 2001\nFrom: Pavel Shilovsky <pshilov@microsoft.com>\nDate: Mon, 7 Nov 2016 18:20:50 -0800\nSubject: CIFS: Enable encryption during session setup phase\n\nIn order to allow encryption on SMB connection we need to exchange\na session key and generate encryption and decryption keys.\n\nSigned-off-by: Pavel Shilovsky <pshilov@microsoft.com>\n---\n fs\/cifs\/sess.c    | 22 ++++++++++------------\n fs\/cifs\/smb2pdu.c | 12 ++----------\n 2 files changed, 12 insertions(+), 22 deletions(-)\n\n","diff_code":"diff --git a\/fs\/cifs\/sess.c b\/fs\/cifs\/sess.c\nindex a1118e30e7c7..dcbcc927399a 100644\n--- a\/fs\/cifs\/sess.c\n+++ b\/fs\/cifs\/sess.c\n@@ -344,13 +344,12 @@ void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n \t\/* BB is NTLMV2 session security format easier to use here? *\/\n \tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n \t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n-\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n-\tif (ses->server->sign) {\n+\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n+\t\tNTLMSSP_NEGOTIATE_SEAL;\n+\tif (ses->server->sign)\n \t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n-\t\tif (!ses->server->session_estab ||\n-\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n-\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n-\t}\n+\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n+\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n \n \tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n \n@@ -407,13 +406,12 @@ int build_ntlmssp_auth_blob(unsigned char **pbuffer,\n \tflags = NTLMSSP_NEGOTIATE_56 |\n \t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n \t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n-\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n-\tif (ses->server->sign) {\n+\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n+\t\tNTLMSSP_NEGOTIATE_SEAL;\n+\tif (ses->server->sign)\n \t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n-\t\tif (!ses->server->session_estab ||\n-\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n-\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n-\t}\n+\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n+\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n \n \ttmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n \tsec_blob->NegotiateFlags = cpu_to_le32(flags);\ndiff --git a\/fs\/cifs\/smb2pdu.c b\/fs\/cifs\/smb2pdu.c\nindex bf5b693412f0..b088c5027111 100644\n--- a\/fs\/cifs\/smb2pdu.c\n+++ b\/fs\/cifs\/smb2pdu.c\n@@ -756,15 +756,13 @@ SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n \tstruct cifs_ses *ses = sess_data->ses;\n \n \tmutex_lock(&ses->server->srv_mutex);\n-\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n+\tif (ses->server->ops->generate_signingkey) {\n \t\trc = ses->server->ops->generate_signingkey(ses);\n-\t\tkfree(ses->auth_key.response);\n-\t\tses->auth_key.response = NULL;\n \t\tif (rc) {\n \t\t\tcifs_dbg(FYI,\n \t\t\t\t\"SMB3 session key generation failed\\n\");\n \t\t\tmutex_unlock(&ses->server->srv_mutex);\n-\t\t\tgoto keygen_exit;\n+\t\t\treturn rc;\n \t\t}\n \t}\n \tif (!ses->server->session_estab) {\n@@ -778,12 +776,6 @@ SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n \tses->status = CifsGood;\n \tses->need_reconnect = false;\n \tspin_unlock(&GlobalMid_Lock);\n-\n-keygen_exit:\n-\tif (!ses->server->sign) {\n-\t\tkfree(ses->auth_key.response);\n-\t\tses->auth_key.response = NULL;\n-\t}\n \treturn rc;\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7424","CWE_ID":"476","category":"security","commit_id":"136f55207521f0b03194ef5b55ba70f1635d6aee","commit_message":"From 136f55207521f0b03194ef5b55ba70f1635d6aee Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 12 Nov 2013 16:11:42 +0100\nSubject: [PATCH] mpegvideo_motion: Handle edge emulation even without\n unrestricted_mv\n\nFix out of bounds read.\n\nBug-Id: 962\nFound by: F4B3CD@STARLAB and Agostino Sarubbo\nSigned-off-by: Vittorio Giovara <vittorio.giovara@gmail.com>\n---\n libavcodec\/mpegvideo_motion.c | 19 ++++++++-----------\n 1 file changed, 8 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/mpegvideo_motion.c b\/libavcodec\/mpegvideo_motion.c\nindex 8074dba..f6d9613 100644\n--- a\/libavcodec\/mpegvideo_motion.c\n+++ b\/libavcodec\/mpegvideo_motion.c\n@@ -210,17 +210,14 @@ static inline int hpel_motion(MpegEncContext *s,\n         dxy |= (motion_y & 1) << 1;\n     src += src_y * s->linesize + src_x;\n \n-    if (s->unrestricted_mv) {\n-        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||\n-            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {\n-            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n-                                     s->linesize, s->linesize,\n-                                     9, 9,\n-                                     src_x, src_y, s->h_edge_pos,\n-                                     s->v_edge_pos);\n-            src = s->sc.edge_emu_buffer;\n-            emu = 1;\n-        }\n+    if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||\n+        (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {\n+        s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n+                                 s->linesize, s->linesize,\n+                                 9, 9, src_x, src_y,\n+                                 s->h_edge_pos, s->v_edge_pos);\n+        src = s->sc.edge_emu_buffer;\n+        emu = 1;\n     }\n     pix_op[dxy](dest, src, s->linesize, 8);\n     return emu;\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-6942","CWE_ID":"476","category":"security","commit_id":"29c759284e305ec428703c9a5831d0b1fc3497ef","commit_message":"From 29c759284e305ec428703c9a5831d0b1fc3497ef Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Sat, 27 Jan 2018 14:43:43 +0100\nSubject: * src\/truetype\/ttinterp.c (Ins_GETVARIATION): Avoid NULL reference.\n\nReported as\n\n  https:\/\/bugs.chromium.org\/p\/oss-fuzz\/issues\/detail?id=5736\n---\n ChangeLog               |  8 ++++++++\n src\/truetype\/ttinterp.c | 12 ++++++++++--\n 2 files changed, 18 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 15ef4ae..fff4a41 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,13 @@\n 2018-01-27  Werner Lemberg  <wl@gnu.org>\n \n+\t* src\/truetype\/ttinterp.c (Ins_GETVARIATION): Avoid NULL reference.\n+\n+\tReported as\n+\n+\t  https:\/\/bugs.chromium.org\/p\/oss-fuzz\/issues\/detail?id=5736\n+\n+2018-01-27  Werner Lemberg  <wl@gnu.org>\n+\n \t* src\/truetype\/ttgxvar.c (tt_set_mm_blend): Minor.\n \n 2018-01-27  Werner Lemberg  <wl@gnu.org>\ndiff --git a\/src\/truetype\/ttinterp.c b\/src\/truetype\/ttinterp.c\nindex d855aaa..551f14a 100644\n--- a\/src\/truetype\/ttinterp.c\n+++ b\/src\/truetype\/ttinterp.c\n@@ -7532,8 +7532,16 @@\n       return;\n     }\n \n-    for ( i = 0; i < num_axes; i++ )\n-      args[i] = coords[i] >> 2; \/* convert 16.16 to 2.14 format *\/\n+    if ( coords )\n+    {\n+      for ( i = 0; i < num_axes; i++ )\n+        args[i] = coords[i] >> 2; \/* convert 16.16 to 2.14 format *\/\n+    }\n+    else\n+    {\n+      for ( i = 0; i < num_axes; i++ )\n+        args[i] = 0;\n+    }\n   }\n \n \n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12476","CWE_ID":"476","category":"security","commit_id":"4d3f0bebd5f8518fd775f671c12bea58c68e814e","commit_message":"From 4d3f0bebd5f8518fd775f671c12bea58c68e814e Mon Sep 17 00:00:00 2001\nFrom: Gilles Boccon-Gibod <bok@bok.net>\nDate: Sun, 30 Jul 2017 15:29:24 -0700\nSubject: [PATCH] fixed possible crashes on malformed inputs.\n\n---\n Source\/C++\/Core\/Ap4AtomSampleTable.cpp | 5 +++++\n Source\/C++\/Core\/Ap4AvccAtom.cpp        | 2 +-\n Source\/C++\/Core\/Ap4Processor.cpp       | 1 +\n Source\/C++\/Core\/Ap4Version.h           | 4 ++--\n 4 files changed, 9 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp b\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\nindex 19e05dad..77d11191 100644\n--- a\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\n+++ b\/Source\/C++\/Core\/Ap4AtomSampleTable.cpp\n@@ -87,6 +87,11 @@ AP4_AtomSampleTable::GetSample(AP4_Ordinal index,\n {\n     AP4_Result result;\n \n+    \/\/ check that we have an stsc atom\n+    if (!m_StscAtom) {\n+        return AP4_ERROR_INVALID_FORMAT;\n+    }\n+    \n     \/\/ check that we have a chunk offset table\n     if (m_StcoAtom == NULL && m_Co64Atom == NULL) {\n         return AP4_ERROR_INVALID_FORMAT;\ndiff --git a\/Source\/C++\/Core\/Ap4AvccAtom.cpp b\/Source\/C++\/Core\/Ap4AvccAtom.cpp\nindex a1167d0d..d14f9a6a 100644\n--- a\/Source\/C++\/Core\/Ap4AvccAtom.cpp\n+++ b\/Source\/C++\/Core\/Ap4AvccAtom.cpp\n@@ -270,7 +270,7 @@ AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n     for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n         inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n     }\n-    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n+    for (unsigned int i=0; i<m_PictureParameters.ItemCount(); i++) {\n         inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n     }\n     return AP4_SUCCESS;\ndiff --git a\/Source\/C++\/Core\/Ap4Processor.cpp b\/Source\/C++\/Core\/Ap4Processor.cpp\nindex ae6eb7df..9c1a7ec5 100644\n--- a\/Source\/C++\/Core\/Ap4Processor.cpp\n+++ b\/Source\/C++\/Core\/Ap4Processor.cpp\n@@ -554,6 +554,7 @@ AP4_Processor::Process(AP4_ByteStream&   input,\n             int cursor = -1;\n             for (unsigned int i=0; i<track_count; i++) {\n                 if (!cursors[i].m_EndReached &&\n+                    cursors[i].m_Locator.m_SampleTable &&\n                     cursors[i].m_Locator.m_Sample.GetOffset() <= min_offset) {\n                     min_offset = cursors[i].m_Locator.m_Sample.GetOffset();\n                     cursor = i;\ndiff --git a\/Source\/C++\/Core\/Ap4Version.h b\/Source\/C++\/Core\/Ap4Version.h\nindex 60620afe..5ffb7f69 100644\n--- a\/Source\/C++\/Core\/Ap4Version.h\n+++ b\/Source\/C++\/Core\/Ap4Version.h\n@@ -37,7 +37,7 @@\n \/**\n  * Version number of the SDK\n  *\/\n-#define AP4_VERSION        0x01050000\n-#define AP4_VERSION_STRING \"1.5.0.0\"\n+#define AP4_VERSION        0x01050001\n+#define AP4_VERSION_STRING \"1.5.0.1\"\n \n #endif \/\/ _AP4_VERSION_H_\n","owner":"axiomatic-systems","repo":"Bento4","source":"cve"},{"CVE_ID":"CVE-2016-6866","CWE_ID":"476","category":"security","commit_id":"d8bec0f6fdc8a246d78cb488a0068954b46fcb29","commit_message":"commit d8bec0f6fdc8a246d78cb488a0068954b46fcb29\nparent b87bfa234378bcfc1b13273c5089f07902de1725\nAuthor: Markus Teich <markus.teich@stusta.mhn.de>\nDate:   Wed, 31 Aug 2016 00:59:06 +0200\n\nfix CVE-2016-6866\n\nDiffstat:\nM\tslock.c\t|\t10\t++++++++--\n1 file changed, 8 insertions(+), 2 deletions(-)\n","diff_code":"diff --git a\/slock.c b\/slock.c\n@@ -123,7 +123,7 @@ readpw(Display *dpy)\n readpw(Display *dpy, const char *pws)\n #endif\n {\n-\tchar buf[32], passwd[256];\n+\tchar buf[32], passwd[256], *encrypted;\n \tint num, screen;\n \tunsigned int len, color;\n \tKeySym ksym;\n@@ -159,7 +159,11 @@ readpw(Display *dpy, const char *pws)\n #ifdef HAVE_BSD_AUTH\n \t\t\t\trunning = !auth_userokay(getlogin(), NULL, \"auth-slock\", passwd);\n #else\n-\t\t\t\trunning = !!strcmp(crypt(passwd, pws), pws);\n+\t\t\t\terrno = 0;\n+\t\t\t\tif (!(encrypted = crypt(passwd, pws)))\n+\t\t\t\t\tfprintf(stderr, \"slock: crypt: %s\\n\", strerror(errno));\n+\t\t\t\telse\n+\t\t\t\t\trunning = !!strcmp(encrypted, pws);\n #endif\n \t\t\t\tif (running) {\n \t\t\t\t\tXBell(dpy, 100);\n@@ -312,6 +316,8 @@ main(int argc, char **argv) {\n \n #ifndef HAVE_BSD_AUTH\n \tpws = getpw();\n+\tif (strlen(pws) < 2)\n+\t\tdie(\"slock: failed to get user password hash.\\n\");\n #endif\n \n \tif (!(dpy = XOpenDisplay(NULL)))","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-4344","CWE_ID":"476","category":"security","commit_id":"524688ce87a15fc75f87efc8c039ba4c7d5c197b","commit_message":"From 524688ce87a15fc75f87efc8c039ba4c7d5c197b Mon Sep 17 00:00:00 2001\nFrom: Greg Hudson <ghudson@mit.edu>\nDate: Tue, 15 Jul 2014 12:56:01 -0400\nSubject: [PATCH] Fix null deref in SPNEGO acceptor [CVE-2014-4344]\n\nWhen processing a continuation token, acc_ctx_cont was dereferencing\nthe initial byte of the token without checking the length.  This could\nresult in a null dereference.\n\nCVE-2014-4344:\n\nIn MIT krb5 1.5 and newer, an unauthenticated or partially\nauthenticated remote attacker can cause a NULL dereference and\napplication crash during a SPNEGO negotiation by sending an empty\ntoken as the second or later context token from initiator to acceptor.\nThe attacker must provide at least one valid context token in the\nsecurity context negotiation before sending the empty token.  This can\nbe done by an unauthenticated attacker by forcing SPNEGO to\nrenegotiate the underlying mechanism, or by using IAKERB to wrap an\nunauthenticated AS-REQ as the first token.\n\n    CVSSv2 Vector: AV:N\/AC:L\/Au:N\/C:N\/I:N\/A:C\/E:POC\/RL:OF\/RC:C\n\n[kaduk@mit.edu: CVE summary, CVSSv2 vector]\n\nticket: 7970 (new)\nsubject: NULL dereference in SPNEGO acceptor for continuation tokens [CVE-2014-4344]\ntarget_version: 1.12.2\ntags: pullup\n---\n src\/lib\/gssapi\/spnego\/spnego_mech.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/lib\/gssapi\/spnego\/spnego_mech.c b\/src\/lib\/gssapi\/spnego\/spnego_mech.c\nindex 8f829d8c59..2aa6810a9c 100644\n--- a\/src\/lib\/gssapi\/spnego\/spnego_mech.c\n+++ b\/src\/lib\/gssapi\/spnego\/spnego_mech.c\n@@ -1468,7 +1468,7 @@ acc_ctx_cont(OM_uint32 *minstat,\n \n \tptr = bufstart = buf->value;\n #define REMAIN (buf->length - (ptr - bufstart))\n-\tif (REMAIN > INT_MAX)\n+\tif (REMAIN == 0 || REMAIN > INT_MAX)\n \t\treturn GSS_S_DEFECTIVE_TOKEN;\n \n \t\/*\n","owner":"krb5","repo":"krb5","source":"cve"},{"CVE_ID":"CVE-2016-3120","CWE_ID":"476","category":"security","commit_id":"93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7","commit_message":"From 93b4a6306a0026cf1cc31ac4bd8a49ba5d034ba7 Mon Sep 17 00:00:00 2001\nFrom: Greg Hudson <ghudson@mit.edu>\nDate: Tue, 19 Jul 2016 11:00:28 -0400\nSubject: [PATCH] Fix S4U2Self KDC crash when anon is restricted\n\nIn validate_as_request(), when enforcing restrict_anonymous_to_tgt,\nuse client.princ instead of request->client; the latter is NULL when\nvalidating S4U2Self requests.\n\nCVE-2016-3120:\n\nIn MIT krb5 1.9 and later, an authenticated attacker can cause krb5kdc\nto dereference a null pointer if the restrict_anonymous_to_tgt option\nis set to true, by making an S4U2Self request.\n\n  CVSSv2 Vector: AV:N\/AC:H\/Au:S\/C:N\/I:N\/A:C\/E:H\/RL:OF\/RC:C\n\nticket: 8458 (new)\ntarget_version: 1.14-next\ntarget_version: 1.13-next\n---\n src\/kdc\/kdc_util.c    | 2 +-\n src\/tests\/t_pkinit.py | 5 +++++\n 2 files changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/kdc\/kdc_util.c b\/src\/kdc\/kdc_util.c\nindex 776e130e55..29f9dbbf07 100644\n--- a\/src\/kdc\/kdc_util.c\n+++ b\/src\/kdc\/kdc_util.c\n@@ -739,7 +739,7 @@ validate_as_request(kdc_realm_t *kdc_active_realm,\n         return(KDC_ERR_MUST_USE_USER2USER);\n     }\n \n-    if (check_anon(kdc_active_realm, request->client, request->server) != 0) {\n+    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {\n         *status = \"ANONYMOUS NOT ALLOWED\";\n         return(KDC_ERR_POLICY);\n     }\ndiff --git a\/src\/tests\/t_pkinit.py b\/src\/tests\/t_pkinit.py\nindex b66c458dff..f0214b6529 100755\n--- a\/src\/tests\/t_pkinit.py\n+++ b\/src\/tests\/t_pkinit.py\n@@ -93,6 +93,11 @@\n if 'KDC policy rejects request' not in out:\n     fail('Wrong error for restricted anonymous PKINIT')\n \n+# Regression test for #8458: S4U2Self requests crash the KDC if\n+# anonymous is restricted.\n+realm.kinit(realm.host_princ, flags=['-k'])\n+realm.run([kvno, '-U', 'user', realm.host_princ])\n+\n # Go back to a normal KDC and disable anonymous PKINIT.\n realm.stop_kdc()\n realm.start_kdc()\n","owner":"krb5","repo":"krb5","source":"cve"},{"CVE_ID":"CVE-2017-6850","CWE_ID":"476","category":"security","commit_id":"e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d","commit_message":"From e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d Mon Sep 17 00:00:00 2001\nFrom: Michael Adams <mdadams@ece.uvic.ca>\nDate: Sat, 4 Mar 2017 14:43:24 -0800\nSubject: [PATCH] Fixed bugs due to uninitialized data in the JP2 decoder.\n Also, added some comments marking I\/O stream interfaces that probably need to\n be changed (in the long term) to fix integer overflow problems.\n\n---\n src\/libjasper\/base\/jas_stream.c | 18 ++++++++++++++\n src\/libjasper\/jp2\/jp2_cod.c     | 44 ++++++++++++++++++++++-----------\n 2 files changed, 48 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/src\/libjasper\/base\/jas_stream.c b\/src\/libjasper\/base\/jas_stream.c\nindex 327ee57..d70408f 100644\n--- a\/src\/libjasper\/base\/jas_stream.c\n+++ b\/src\/libjasper\/base\/jas_stream.c\n@@ -664,6 +664,7 @@ int jas_stream_ungetc(jas_stream_t *stream, int c)\n \treturn 0;\n }\n \n+\/* FIXME integral type *\/\n int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n {\n \tint n;\n@@ -690,6 +691,7 @@ int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n \treturn n;\n }\n \n+\/* FIXME integral type *\/\n int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n {\n \tint n;\n@@ -742,6 +744,7 @@ int jas_stream_puts(jas_stream_t *stream, const char *s)\n \treturn 0;\n }\n \n+\/* FIXME integral type *\/\n char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n {\n \tint c;\n@@ -765,6 +768,7 @@ char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n \treturn buf;\n }\n \n+\/* FIXME integral type *\/\n int jas_stream_gobble(jas_stream_t *stream, int n)\n {\n \tint m;\n@@ -783,6 +787,7 @@ int jas_stream_gobble(jas_stream_t *stream, int n)\n \treturn n;\n }\n \n+\/* FIXME integral type *\/\n int jas_stream_pad(jas_stream_t *stream, int n, int c)\n {\n \tint m;\n@@ -885,6 +890,7 @@ long jas_stream_tell(jas_stream_t *stream)\n * Buffer initialization code.\n \\******************************************************************************\/\n \n+\/* FIXME integral type *\/\n static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n   int bufsize)\n {\n@@ -1060,6 +1066,7 @@ static int jas_strtoopenmode(const char *s)\n \treturn openmode;\n }\n \n+\/* FIXME integral type *\/\n int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n {\n \tint all;\n@@ -1085,6 +1092,7 @@ int jas_stream_copy(jas_stream_t *out, jas_stream_t *in, int n)\n \treturn 0;\n }\n \n+\/* FIXME integral type *\/\n long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n {\n \tint old;\n@@ -1094,6 +1102,7 @@ long jas_stream_setrwcount(jas_stream_t *stream, long rwcnt)\n \treturn old;\n }\n \n+\/* FIXME integral type *\/\n int jas_stream_display(jas_stream_t *stream, FILE *fp, int n)\n {\n \tunsigned char buf[16];\n@@ -1168,6 +1177,7 @@ long jas_stream_length(jas_stream_t *stream)\n * Memory stream object.\n \\******************************************************************************\/\n \n+\/* FIXME integral type *\/\n static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tssize_t n;\n@@ -1209,6 +1219,7 @@ static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n \treturn 0;\n }\n \n+\/* FIXME integral type *\/\n static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tsize_t n;\n@@ -1264,6 +1275,7 @@ static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn ret;\n }\n \n+\/* FIXME integral type *\/\n static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n@@ -1310,6 +1322,7 @@ static int mem_close(jas_stream_obj_t *obj)\n * File stream object.\n \\******************************************************************************\/\n \n+\/* FIXME integral type *\/\n static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1318,6 +1331,7 @@ static int file_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn read(fileobj->fd, buf, cnt);\n }\n \n+\/* FIXME integral type *\/\n static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1326,6 +1340,7 @@ static int file_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn write(fileobj->fd, buf, cnt);\n }\n \n+\/* FIXME integral type *\/\n static long file_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tjas_stream_fileobj_t *fileobj;\n@@ -1352,6 +1367,7 @@ static int file_close(jas_stream_obj_t *obj)\n * Stdio file stream object.\n \\******************************************************************************\/\n \n+\/* FIXME integral type *\/\n static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1367,6 +1383,7 @@ static int sfile_read(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn result;\n }\n \n+\/* FIXME integral type *\/\n static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n {\n \tFILE *fp;\n@@ -1377,6 +1394,7 @@ static int sfile_write(jas_stream_obj_t *obj, char *buf, int cnt)\n \treturn (n != JAS_CAST(size_t, cnt)) ? (-1) : cnt;\n }\n \n+\/* FIXME integral type *\/\n static long sfile_seek(jas_stream_obj_t *obj, long offset, int origin)\n {\n \tFILE *fp;\ndiff --git a\/src\/libjasper\/jp2\/jp2_cod.c b\/src\/libjasper\/jp2\/jp2_cod.c\nindex 7f3608a..8d98a2c 100644\n--- a\/src\/libjasper\/jp2\/jp2_cod.c\n+++ b\/src\/libjasper\/jp2\/jp2_cod.c\n@@ -183,15 +183,28 @@ jp2_boxinfo_t jp2_boxinfo_unk = {\n * Box constructor.\n \\******************************************************************************\/\n \n-jp2_box_t *jp2_box_create(int type)\n+jp2_box_t *jp2_box_create0()\n {\n \tjp2_box_t *box;\n-\tjp2_boxinfo_t *boxinfo;\n-\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\treturn 0;\n \t}\n \tmemset(box, 0, sizeof(jp2_box_t));\n+\tbox->type = 0;\n+\tbox->len = 0;\n+\t\/\/ Mark the box data as never having been constructed\n+\t\/\/ so that we will not errantly attempt to destroy it later.\n+\tbox->ops = &jp2_boxinfo_unk.ops;\n+\treturn box;\n+}\n+\n+jp2_box_t *jp2_box_create(int type)\n+{\n+\tjp2_box_t *box;\n+\tjp2_boxinfo_t *boxinfo;\n+\tif (!(box = jp2_box_create0())) {\n+\t\treturn 0;\n+\t}\n \tbox->type = type;\n \tbox->len = 0;\n \tif (!(boxinfo = jp2_boxinfolookup(type))) {\n@@ -248,14 +261,9 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox = 0;\n \ttmpstream = 0;\n \n-\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n+\tif (!(box = jp2_box_create0())) {\n \t\tgoto error;\n \t}\n-\n-\t\/\/ Mark the box data as never having been constructed\n-\t\/\/ so that we will not errantly attempt to destroy it later.\n-\tbox->ops = &jp2_boxinfo_unk.ops;\n-\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n@@ -263,10 +271,12 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tbox->info = boxinfo;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n-\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n+\t  \"preliminary processing of JP2 box: \"\n+\t  \"type=%c%s%c (0x%08x); length=%\"PRIuFAST32\"\\n\",\n \t  '\"', boxinfo->name, '\"', box->type, box->len\n \t  ));\n \tif (box->len == 1) {\n+\t\tJAS_DBGLOG(10, (\"big length\\n\"));\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n \t\t}\n@@ -382,6 +392,7 @@ static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n {\n \tjp2_bpcc_t *bpcc = &box->data.bpcc;\n \tunsigned int i;\n+\tbpcc->bpcs = 0;\n \tbpcc->numcmpts = box->datalen;\n \tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n \t\treturn -1;\n@@ -462,6 +473,7 @@ static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cdef_t *cdef = &box->data.cdef;\n \tjp2_cdefchan_t *chan;\n \tunsigned int channo;\n+\tcdef->ents = 0;\n \tif (jp2_getuint16(in, &cdef->numchans)) {\n \t\treturn -1;\n \t}\n@@ -518,7 +530,9 @@ int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n \t}\n \n \tif (dataflag) {\n-\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n+\t\tif (jas_stream_copy(out, tmpstream, box->len -\n+\t\t  JP2_BOX_HDRLEN(false))) {\n+\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_close(tmpstream);\n@@ -777,6 +791,7 @@ static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n \tjp2_cmap_t *cmap = &box->data.cmap;\n \tjp2_cmapent_t *ent;\n \tunsigned int i;\n+\tcmap->ents = 0;\n \n \tcmap->numchans = (box->datalen) \/ 4;\n \tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n@@ -835,6 +850,7 @@ static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n \tint_fast32_t x;\n \n \tpclr->lutdata = 0;\n+\tpclr->bpc = 0;\n \n \tif (jp2_getuint16(in, &pclr->numlutents) ||\n \t  jp2_getuint8(in, &pclr->numchans)) {\n@@ -869,9 +885,9 @@ static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n #if 0\n \tjp2_pclr_t *pclr = &box->data.pclr;\n #endif\n-\/* Eliminate warning about unused variable. *\/\n-box = 0;\n-out = 0;\n+\t\/* Eliminate warning about unused variable. *\/\n+\tbox = 0;\n+\tout = 0;\n \treturn -1;\n }\n \n","owner":"mdadams","repo":"jasper","source":"cve"},{"CVE_ID":"CVE-2017-13686","CWE_ID":"476","category":"security","commit_id":"bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205","commit_message":"From bc3aae2bbac46dd894c89db5d5e98f7f0ef9e205 Mon Sep 17 00:00:00 2001\nFrom: Roopa Prabhu <roopa@cumulusnetworks.com>\nDate: Wed, 16 Aug 2017 12:38:52 -0700\nSubject: [PATCH] net: check and errout if res->fi is NULL when RTM_F_FIB_MATCH\n is set\n\nSyzkaller hit 'general protection fault in fib_dump_info' bug on\ncommit 4.13-rc5..\n\nGuilty file: net\/ipv4\/fib_semantics.c\n\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN\nModules linked in:\nCPU: 0 PID: 2808 Comm: syz-executor0 Not tainted 4.13.0-rc5 #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\nUbuntu-1.8.2-1ubuntu1 04\/01\/2014\ntask: ffff880078562700 task.stack: ffff880078110000\nRIP: 0010:fib_dump_info+0x388\/0x1170 net\/ipv4\/fib_semantics.c:1314\nRSP: 0018:ffff880078117010 EFLAGS: 00010206\nRAX: dffffc0000000000 RBX: 00000000000000fe RCX: 0000000000000002\nRDX: 0000000000000006 RSI: ffff880078117084 RDI: 0000000000000030\nRBP: ffff880078117268 R08: 000000000000000c R09: ffff8800780d80c8\nR10: 0000000058d629b4 R11: 0000000067fce681 R12: 0000000000000000\nR13: ffff8800784bd540 R14: ffff8800780d80b5 R15: ffff8800780d80a4\nFS:  00000000022fa940(0000) GS:ffff88007fc00000(0000)\nknlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00000000004387d0 CR3: 0000000079135000 CR4: 00000000000006f0\nCall Trace:\n  inet_rtm_getroute+0xc89\/0x1f50 net\/ipv4\/route.c:2766\n  rtnetlink_rcv_msg+0x288\/0x680 net\/core\/rtnetlink.c:4217\n  netlink_rcv_skb+0x340\/0x470 net\/netlink\/af_netlink.c:2397\n  rtnetlink_rcv+0x28\/0x30 net\/core\/rtnetlink.c:4223\n  netlink_unicast_kernel net\/netlink\/af_netlink.c:1265 [inline]\n  netlink_unicast+0x4c4\/0x6e0 net\/netlink\/af_netlink.c:1291\n  netlink_sendmsg+0x8c4\/0xca0 net\/netlink\/af_netlink.c:1854\n  sock_sendmsg_nosec net\/socket.c:633 [inline]\n  sock_sendmsg+0xca\/0x110 net\/socket.c:643\n  ___sys_sendmsg+0x779\/0x8d0 net\/socket.c:2035\n  __sys_sendmsg+0xd1\/0x170 net\/socket.c:2069\n  SYSC_sendmsg net\/socket.c:2080 [inline]\n  SyS_sendmsg+0x2d\/0x50 net\/socket.c:2076\n  entry_SYSCALL_64_fastpath+0x1a\/0xa5\n  RIP: 0033:0x4512e9\n  RSP: 002b:00007ffc75584cc8 EFLAGS: 00000216 ORIG_RAX:\n  000000000000002e\n  RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 00000000004512e9\n  RDX: 0000000000000000 RSI: 0000000020f2cfc8 RDI: 0000000000000003\n  RBP: 000000000000000e R08: 0000000000000000 R09: 0000000000000000\n  R10: 0000000000000000 R11: 0000000000000216 R12: fffffffffffffffe\n  R13: 0000000000718000 R14: 0000000020c44ff0 R15: 0000000000000000\n  Code: 00 0f b6 8d ec fd ff ff 48 8b 85 f0 fd ff ff 88 48 17 48 8b 45\n  28 48 8d 78 30 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03\n  <0f>\n  b6 04 02 84 c0 74 08 3c 03 0f 8e cb 0c 00 00 48 8b 45 28 44\n  RIP: fib_dump_info+0x388\/0x1170 net\/ipv4\/fib_semantics.c:1314 RSP:\n  ffff880078117010\n---[ end trace 254a7af28348f88b ]---\n\nThis patch adds a res->fi NULL check.\n\nexample run:\n$ip route get 0.0.0.0 iif virt1-0\nbroadcast 0.0.0.0 dev lo\n    cache <local,brd> iif virt1-0\n\n$ip route get 0.0.0.0 iif virt1-0 fibmatch\nRTNETLINK answers: No route to host\n\nReported-by: idaifish <idaifish@gmail.com>\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nFixes: b61798130f1b (\"net: ipv4: RTM_GETROUTE: return matched fib result when requested\")\nSigned-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/route.c | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/route.c b\/net\/ipv4\/route.c\nindex fe877a4a72b1e..2331de20ca505 100644\n--- a\/net\/ipv4\/route.c\n+++ b\/net\/ipv4\/route.c\n@@ -2763,14 +2763,21 @@ static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,\n \tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n \t\ttable_id = rt->rt_table_id;\n \n-\tif (rtm->rtm_flags & RTM_F_FIB_MATCH)\n+\tif (rtm->rtm_flags & RTM_F_FIB_MATCH) {\n+\t\tif (!res.fi) {\n+\t\t\terr = fib_props[res.type].error;\n+\t\t\tif (!err)\n+\t\t\t\terr = -EHOSTUNREACH;\n+\t\t\tgoto errout_free;\n+\t\t}\n \t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n \t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n \t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n \t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n-\telse\n+\t} else {\n \t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n \t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n+\t}\n \tif (err < 0)\n \t\tgoto errout_free;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-17293","CWE_ID":"476","category":"security","commit_id":"31d670b6489e6d708c3b04b911cdf14ac43d846d","commit_message":"From 31d670b6489e6d708c3b04b911cdf14ac43d846d Mon Sep 17 00:00:00 2001\nFrom: Andrew Scheidecker <andrew@scheidecker.net>\nDate: Sun, 16 Sep 2018 09:55:34 -0400\nSubject: [PATCH] Fix dereferencing null pointer when running wavm with\n WebAssembly main function that takes command-line arguments but no Emscripten\n memory to write them to\n\n---\n Programs\/wavm\/wavm.cpp | 18 ++++++++++--------\n 1 file changed, 10 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/Programs\/wavm\/wavm.cpp b\/Programs\/wavm\/wavm.cpp\nindex a8d46968..b21e4103 100644\n--- a\/Programs\/wavm\/wavm.cpp\n+++ b\/Programs\/wavm\/wavm.cpp\n@@ -250,21 +250,23 @@ static int run(const CommandLineOptions& options)\n \t{\n \t\tif(functionType.params().size() == 2)\n \t\t{\n-\t\t\tMemoryInstance* defaultMemory = Runtime::getDefaultMemory(moduleInstance);\n-\t\t\tif(!defaultMemory)\n+\t\t\tif(!emscriptenInstance)\n \t\t\t{\n \t\t\t\tLog::printf(\n \t\t\t\t\tLog::error,\n \t\t\t\t\t\"Module does not declare a default memory object to put arguments in.\\n\");\n \t\t\t\treturn EXIT_FAILURE;\n \t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tstd::vector<const char*> argStrings;\n+\t\t\t\targStrings.push_back(options.filename);\n+\t\t\t\tchar** args = options.args;\n+\t\t\t\twhile(*args) { argStrings.push_back(*args++); };\n \n-\t\t\tstd::vector<const char*> argStrings;\n-\t\t\targStrings.push_back(options.filename);\n-\t\t\tchar** args = options.args;\n-\t\t\twhile(*args) { argStrings.push_back(*args++); };\n-\n-\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n+\t\t\t\twavmAssert(emscriptenInstance);\n+\t\t\t\tEmscripten::injectCommandArgs(emscriptenInstance, argStrings, invokeArgs);\n+\t\t\t}\n \t\t}\n \t\telse if(functionType.params().size() > 0)\n \t\t{\n","owner":"WAVM","repo":"WAVM","source":"cve"},{"CVE_ID":"CVE-2018-6197","CWE_ID":"476","category":"security","commit_id":"7fdc83b0364005a0b5ed869230dd81752ba022e8","commit_message":"From 7fdc83b0364005a0b5ed869230dd81752ba022e8 Mon Sep 17 00:00:00 2001\nFrom: Tatsuya Kinoshita <tats@debian.org>\nDate: Wed, 27 Dec 2017 06:43:52 +0900\nSubject: [PATCH] Prevent invalid columnPos() call in formUpdateBuffer()\n\nBug-Debian: https:\/\/github.com\/tats\/w3m\/issues\/89\n---\n form.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/form.c b\/form.c\nindex cc5e3d2..bc14d39 100644\n--- a\/form.c\n+++ b\/form.c\n@@ -482,6 +482,8 @@ formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form)\n \trows = form->rows ? form->rows : 1;\n \tcol = COLPOS(l, a->start.pos);\n \tfor (c_rows = 0; c_rows < rows; c_rows++, l = l->next) {\n+\t    if (l == NULL)\n+\t\tbreak;\n \t    if (rows > 1) {\n \t\tpos = columnPos(l, col);\n \t\ta = retrieveAnchor(buf->formitem, l->linenumber, pos);\n","owner":"tats","repo":"w3m","source":"cve"},{"CVE_ID":"CVE-2017-6501","CWE_ID":"476","category":"security","commit_id":"d31fec57e9dfb0516deead2053a856e3c71e9751","commit_message":"From d31fec57e9dfb0516deead2053a856e3c71e9751 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 9 Feb 2017 18:13:47 -0500\nSubject: [PATCH] =?UTF-8?q?Check=20for=20image=20list=20before=20we=20dest?=\n =?UTF-8?q?roy=20the=20last=20image=20in=20XCF=20coder=20(patch=20sent=20p?=\n =?UTF-8?q?rivately=20by=20=D0=90=D0=BD=D0=B4=D1=80=D0=B5=D0=B9=20=D0=A7?=\n =?UTF-8?q?=D0=B5=D1=80=D0=BD=D1=8B=D0=B9)?=\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\n---\n coders\/xcf.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/xcf.c b\/coders\/xcf.c\nindex 083f217ca0..2feef82ff1 100644\n--- a\/coders\/xcf.c\n+++ b\/coders\/xcf.c\n@@ -1445,7 +1445,8 @@ static Image *ReadXCFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   }\n \n   (void) CloseBlob(image);\n-  DestroyImage(RemoveFirstImageFromList(&image));\n+  if (GetNextImageInList(image) != (Image *) NULL)\n+    DestroyImage(RemoveFirstImageFromList(&image));\n   if (image_type == GIMP_GRAY)\n     image->type=GrayscaleType;\n   return(GetFirstImageInList(image));\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-15858","CWE_ID":"476","category":"security","commit_id":"badb428e63387140720f22486b3acbd3d738859f","commit_message":"From badb428e63387140720f22486b3acbd3d738859f Mon Sep 17 00:00:00 2001\nFrom: Peter Hutterer <peter.hutterer@who-t.net>\nDate: Mon, 23 Jul 2018 11:48:35 +1000\nSubject: [PATCH] keycodes: don't try to copy zero key aliases\n\nMove the aliases copy to within the (num_key_aliases > 0) block.\n\nPassing info->aliases into this fuction with invalid aliases will\ncause log messages but num_key_aliases stays on 0. The key_aliases array\nis never allocated and remains NULL. We then loop through the aliases, causing\na null-pointer dereference.\n\nSigned-off-by: Peter Hutterer <peter.hutterer@who-t.net>\n---\n src\/xkbcomp\/keycodes.c | 14 +++++++-------\n 1 file changed, 7 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/src\/xkbcomp\/keycodes.c b\/src\/xkbcomp\/keycodes.c\nindex 7f5955e..491da51 100644\n--- a\/src\/xkbcomp\/keycodes.c\n+++ b\/src\/xkbcomp\/keycodes.c\n@@ -596,14 +596,14 @@ CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n-    }\n \n-    i = 0;\n-    darray_foreach(alias, info->aliases) {\n-        if (alias->real != XKB_ATOM_NONE) {\n-            key_aliases[i].alias = alias->alias;\n-            key_aliases[i].real = alias->real;\n-            i++;\n+        i = 0;\n+        darray_foreach(alias, info->aliases) {\n+            if (alias->real != XKB_ATOM_NONE) {\n+                key_aliases[i].alias = alias->alias;\n+                key_aliases[i].real = alias->real;\n+                i++;\n+            }\n         }\n     }\n \n","owner":"xkbcommon","repo":"libxkbcommon","source":"cve"},{"CVE_ID":"CVE-2017-18237","CWE_ID":"476","category":"security","commit_id":"f19d0107fbae1fb41836cd110d4425e407e64048","commit_message":"From f19d0107fbae1fb41836cd110d4425e407e64048 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Hubert=20Figui=C3=A8re?= <hub@figuiere.net>\nDate: Thu, 3 Aug 2017 21:53:04 -0400\nSubject: Bug 101914 - Fix crash on corrupt file\n\n- Don't go past the end iterator\n- Don't subcript an empty string\n---\n XMPFiles\/source\/FormatSupport\/PostScript_Support.cpp | 12 ++++++++++--\n 1 file changed, 10 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/XMPFiles\/source\/FormatSupport\/PostScript_Support.cpp b\/XMPFiles\/source\/FormatSupport\/PostScript_Support.cpp\nindex fec55fb..029ff0c 100644\n--- a\/XMPFiles\/source\/FormatSupport\/PostScript_Support.cpp\n+++ b\/XMPFiles\/source\/FormatSupport\/PostScript_Support.cpp\n@@ -814,7 +814,8 @@ std::string PostScript_Support::ConvertToDate(const char* inString)\n \tstd::vector<PostScript_Support::DateTimeTokens>:: const_iterator itr=tokenzs.begin();\n \tfor(;itr!=tokenzs.end();itr++)\n \t{\n-\t\tif(itr->token[0]=='+' ||itr->token[0]=='-')\n+\t\t\/\/ token[0] is invalid on an empty string. -- Hub\n+\t\tif(!itr->token.empty() && (itr->token[0]=='+' ||itr->token[0]=='-'))\n \t\t{\n \t\t\tconst char *str=itr->token.c_str();\n \t\t\tdate.offsetSign=*(str++);\n@@ -1013,7 +1014,14 @@ std::string PostScript_Support::ConvertToDate(const char* inString)\n \t\t\t\t\tif(itr!=tokenzs.end())\n \t\t\t\t\t{\n \t\t\t\t\t\t++itr;\n-\t\t\t\t\t\tif (itr!=tokenzs.end()&&itr->noOfDelimiter==0 && IsNumeric(itr->token[0]) )\n+\t\t\t\t\t\tif (itr == tokenzs.end())\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\/\/ bug 101914 - corrupt file make us\n+\t\t\t\t\t\t\t\/\/ reach the end. -- Hub\n+\t\t\t\t\t\t\t\/\/ https:\/\/bugs.freedesktop.org\/show_bug.cgi?id=101914\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (itr->noOfDelimiter==0 && IsNumeric(itr->token[0]) )\n \t\t\t\t\t\t{\n \t\t\t\t\t\t\tconst char * str=itr->token.c_str();\n \t\t\t\t\t\t\tshort day= GetNumber(&str);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-4344","CWE_ID":"476","category":"security","commit_id":"a7886f0ed1277c69142b14a2c6629175a6331edc","commit_message":"From a7886f0ed1277c69142b14a2c6629175a6331edc Mon Sep 17 00:00:00 2001\nFrom: Greg Hudson <ghudson@mit.edu>\nDate: Tue, 15 Jul 2014 12:56:01 -0400\nSubject: [PATCH] Fix null deref in SPNEGO acceptor [CVE-2014-4344]\n\nWhen processing a continuation token, acc_ctx_cont was dereferencing\nthe initial byte of the token without checking the length.  This could\nresult in a null dereference.\n\nCVE-2014-4344:\n\nIn MIT krb5 1.5 and newer, an unauthenticated or partially\nauthenticated remote attacker can cause a NULL dereference and\napplication crash during a SPNEGO negotiation by sending an empty\ntoken as the second or later context token from initiator to acceptor.\nThe attacker must provide at least one valid context token in the\nsecurity context negotiation before sending the empty token.  This can\nbe done by an unauthenticated attacker by forcing SPNEGO to\nrenegotiate the underlying mechanism, or by using IAKERB to wrap an\nunauthenticated AS-REQ as the first token.\n\n    CVSSv2 Vector: AV:N\/AC:L\/Au:N\/C:N\/I:N\/A:C\/E:POC\/RL:OF\/RC:C\n\n[kaduk@mit.edu: CVE summary, CVSSv2 vector]\n\n(cherry picked from commit 524688ce87a15fc75f87efc8c039ba4c7d5c197b)\n\nticket: 7970\nversion_fixed: 1.12.2\nstatus: resolved\n---\n src\/lib\/gssapi\/spnego\/spnego_mech.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/lib\/gssapi\/spnego\/spnego_mech.c b\/src\/lib\/gssapi\/spnego\/spnego_mech.c\nindex a01f154078..65e1306cdb 100644\n--- a\/src\/lib\/gssapi\/spnego\/spnego_mech.c\n+++ b\/src\/lib\/gssapi\/spnego\/spnego_mech.c\n@@ -1442,7 +1442,7 @@ acc_ctx_cont(OM_uint32 *minstat,\n \n \tptr = bufstart = buf->value;\n #define REMAIN (buf->length - (ptr - bufstart))\n-\tif (REMAIN > INT_MAX)\n+\tif (REMAIN == 0 || REMAIN > INT_MAX)\n \t\treturn GSS_S_DEFECTIVE_TOKEN;\n \n \t\/*\n","owner":"krb5","repo":"krb5","source":"cve"},{"CVE_ID":"CVE-2018-15859","CWE_ID":"476","category":"security","commit_id":"bb4909d2d8fa6b08155e449986a478101e2b2634","commit_message":"From bb4909d2d8fa6b08155e449986a478101e2b2634 Mon Sep 17 00:00:00 2001\nFrom: Daniel Stone <daniels@collabora.com>\nDate: Mon, 30 Oct 2017 11:21:55 +0000\nSubject: [PATCH] Fail expression lookup on invalid atoms\n\nIf we fail atom lookup, then we should not claim that we successfully\nlooked up the expression.\n\nSigned-off-by: Daniel Stone <daniels@collabora.com>\n---\n src\/xkbcomp\/expr.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/xkbcomp\/expr.c b\/src\/xkbcomp\/expr.c\nindex b5ab717..b2567de 100644\n--- a\/src\/xkbcomp\/expr.c\n+++ b\/src\/xkbcomp\/expr.c\n@@ -47,11 +47,15 @@ ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n         *index_rtrn = NULL;\n-        return true;\n+        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n     case EXPR_ARRAY_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n         *index_rtrn = expr->array_ref.entry;\n+\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n+\t\treturn false;\n+\tif (*field_rtrn == NULL)\n+\t\treturn false;\n         return true;\n     default:\n         break;\n","owner":"xkbcommon","repo":"libxkbcommon","source":"cve"},{"CVE_ID":"CVE-2018-13303","CWE_ID":"476","category":"security","commit_id":"00e8181bd97c834fe60751b0c511d4bb97875f78","commit_message":"From 00e8181bd97c834fe60751b0c511d4bb97875f78 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Wed, 27 Jun 2018 16:59:13 +0200\nSubject: [PATCH] avcodec\/ac3_parser: Check init_get_bits8() for failure\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nFixes: null pointer dereference\nFixes: ffmpeg_crash_6.avi\n\nFound-by: Thuan Pham, Marcel B\u00f6hme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nReviewed-by: Paul B Mahol <onemda@gmail.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/ac3_parser.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/ac3_parser.c b\/libavcodec\/ac3_parser.c\nindex f4618bf215e..1e203ae6ac2 100644\n--- a\/libavcodec\/ac3_parser.c\n+++ b\/libavcodec\/ac3_parser.c\n@@ -162,7 +162,9 @@ int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n         return AVERROR(ENOMEM);\n     hdr = *phdr;\n \n-    init_get_bits8(&gb, buf, size);\n+    err = init_get_bits8(&gb, buf, size);\n+    if (err < 0)\n+        return AVERROR_INVALIDDATA;\n     err = ff_ac3_parse_header(&gb, hdr);\n     if (err < 0)\n         return AVERROR_INVALIDDATA;\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-7274","CWE_ID":"476","category":"security","commit_id":"7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf","commit_message":"From 7ab66cca5bbdf6cb2d69339ef4f513d95e532dbf Mon Sep 17 00:00:00 2001\nFrom: Giovanni <wargio@libero.it>\nDate: Mon, 27 Mar 2017 12:55:16 +0200\nSubject: [PATCH] Fix #7152 - Null deref in cms\n\n---\n libr\/util\/r_pkcs7.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libr\/util\/r_pkcs7.c b\/libr\/util\/r_pkcs7.c\nindex 765fe6f0e2..467f58fa72 100644\n--- a\/libr\/util\/r_pkcs7.c\n+++ b\/libr\/util\/r_pkcs7.c\n@@ -284,7 +284,9 @@ RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n \t\treturn NULL;\n \t}\n \tobject = r_asn1_create_object (buffer, length);\n-\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n+\tif (!object || object->list.length != 2 || !object->list.objects ||\n+\t\t!object->list.objects[0] || !object->list.objects[1] ||\n+\t\tobject->list.objects[1]->list.length != 1) {\n \t\tr_asn1_free_object (object);\n \t\tfree (container);\n \t\treturn NULL;\n","owner":"radare","repo":"radare2","source":"cve"},{"CVE_ID":"CVE-2016-10250","CWE_ID":"476","category":"security","commit_id":"bdfe95a6e81ffb4b2fad31a76b57943695beed20","commit_message":"From bdfe95a6e81ffb4b2fad31a76b57943695beed20 Mon Sep 17 00:00:00 2001\nFrom: Michael Adams <mdadams@ece.uvic.ca>\nDate: Sun, 23 Oct 2016 03:52:29 -0700\nSubject: [PATCH] Fixed another problem with incorrect cleanup of JP2 box data\n upon error.\n\n---\n src\/libjasper\/jp2\/jp2_cod.c | 16 ++++++++++------\n 1 file changed, 10 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/src\/libjasper\/jp2\/jp2_cod.c b\/src\/libjasper\/jp2\/jp2_cod.c\nindex 2f14234..7f3608a 100644\n--- a\/src\/libjasper\/jp2\/jp2_cod.c\n+++ b\/src\/libjasper\/jp2\/jp2_cod.c\n@@ -251,13 +251,16 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n \t\tgoto error;\n \t}\n+\n+\t\/\/ Mark the box data as never having been constructed\n+\t\/\/ so that we will not errantly attempt to destroy it later.\n \tbox->ops = &jp2_boxinfo_unk.ops;\n+\n \tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n \t\tgoto error;\n \t}\n \tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n-\tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tJAS_DBGLOG(10, (\n \t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n@@ -287,14 +290,15 @@ jp2_box_t *jp2_box_get(jas_stream_t *in)\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n-\t\t\t\/\/ Mark the box data as never having been constructed\n-\t\t\t\/\/ so that we will not errantly attempt to destroy it later.\n-\t\t\tbox->ops = &jp2_boxinfo_unk.ops;\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n \t\tjas_stream_rewind(tmpstream);\n \n+\t\t\/\/ From here onwards, the box data will need to be destroyed.\n+\t\t\/\/ So, initialize the box operations.\n+\t\tbox->ops = &boxinfo->ops;\n+\n \t\tif (box->ops->getdata) {\n \t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n \t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n@@ -327,8 +331,8 @@ void jp2_box_dump(jp2_box_t *box, FILE *out)\n \tassert(boxinfo);\n \n \tfprintf(out, \"JP2 box: \");\n-\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,\n-\t  '\"', box->type, box->len);\n+\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"',\n+\t  boxinfo->name, '\"', box->type, box->len);\n \tif (box->ops->dumpdata) {\n \t\t(*box->ops->dumpdata)(box, out);\n \t}\n","owner":"mdadams","repo":"jasper","source":"cve"},{"CVE_ID":"CVE-2018-13094","CWE_ID":"476","category":"security","commit_id":"bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a","commit_message":"From bb3d48dcf86a97dc25fe9fc2c11938e19cb4399a Mon Sep 17 00:00:00 2001\nFrom: Eric Sandeen <sandeen@sandeen.net>\nDate: Fri, 8 Jun 2018 09:53:49 -0700\nSubject: [PATCH] xfs: don't call xfs_da_shrink_inode with NULL bp\n\nxfs_attr3_leaf_create may have errored out before instantiating a buffer,\nfor example if the blkno is out of range.  In that case there is no work\nto do to remove it, and in fact xfs_da_shrink_inode will lead to an oops\nif we try.\n\nThis also seems to fix a flaw where the original error from\nxfs_attr3_leaf_create gets overwritten in the cleanup case, and it\nremoves a pointless assignment to bp which isn't used after this.\n\nBugzilla: https:\/\/bugzilla.kernel.org\/show_bug.cgi?id=199969\nReported-by: Xu, Wen <wen.xu@gatech.edu>\nTested-by: Xu, Wen <wen.xu@gatech.edu>\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nReviewed-by: Darrick J. Wong <darrick.wong@oracle.com>\nSigned-off-by: Darrick J. Wong <darrick.wong@oracle.com>\n---\n fs\/xfs\/libxfs\/xfs_attr_leaf.c | 5 ++---\n 1 file changed, 2 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/fs\/xfs\/libxfs\/xfs_attr_leaf.c b\/fs\/xfs\/libxfs\/xfs_attr_leaf.c\nindex 99e0f5749dba9..76e90046731ca 100644\n--- a\/fs\/xfs\/libxfs\/xfs_attr_leaf.c\n+++ b\/fs\/xfs\/libxfs\/xfs_attr_leaf.c\n@@ -791,9 +791,8 @@ xfs_attr_shortform_to_leaf(\n \tASSERT(blkno == 0);\n \terror = xfs_attr3_leaf_create(args, blkno, &bp);\n \tif (error) {\n-\t\terror = xfs_da_shrink_inode(args, 0, bp);\n-\t\tbp = NULL;\n-\t\tif (error)\n+\t\t\/* xfs_attr3_leaf_create may not have instantiated a block *\/\n+\t\tif (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))\n \t\t\tgoto out;\n \t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t\/* try to put *\/\n \t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t\/* it back *\/\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-14340","CWE_ID":"476","category":"security","commit_id":"b31ff3cdf540110da4572e3e29bd172087af65cc","commit_message":"From b31ff3cdf540110da4572e3e29bd172087af65cc Mon Sep 17 00:00:00 2001\nFrom: Richard Wareing <rwareing@fb.com>\nDate: Wed, 13 Sep 2017 09:09:35 +1000\nSubject: [PATCH] xfs: XFS_IS_REALTIME_INODE() should be false if no rt device\n present\n\nIf using a kernel with CONFIG_XFS_RT=y and we set the RHINHERIT flag on\na directory in a filesystem that does not have a realtime device and\ncreate a new file in that directory, it gets marked as a real time file.\nWhen data is written and a fsync is issued, the filesystem attempts to\nflush a non-existent rt device during the fsync process.\n\nThis results in a crash dereferencing a null buftarg pointer in\nxfs_blkdev_issue_flush():\n\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000008\n  IP: xfs_blkdev_issue_flush+0xd\/0x20\n  .....\n  Call Trace:\n    xfs_file_fsync+0x188\/0x1c0\n    vfs_fsync_range+0x3b\/0xa0\n    do_fsync+0x3d\/0x70\n    SyS_fsync+0x10\/0x20\n    do_syscall_64+0x4d\/0xb0\n    entry_SYSCALL64_slow_path+0x25\/0x25\n\nSetting RT inode flags does not require special privileges so any\nunprivileged user can cause this oops to occur.  To reproduce, confirm\nkernel is compiled with CONFIG_XFS_RT=y and run:\n\n  # mkfs.xfs -f \/dev\/pmem0\n  # mount \/dev\/pmem0 \/mnt\/test\n  # mkdir \/mnt\/test\/foo\n  # xfs_io -c 'chattr +t' \/mnt\/test\/foo\n  # xfs_io -f -c 'pwrite 0 5m' -c fsync \/mnt\/test\/foo\/bar\n\nOr just run xfstests with MKFS_OPTIONS=\"-d rtinherit=1\" and wait.\n\nKernels built with CONFIG_XFS_RT=n are not exposed to this bug.\n\nFixes: f538d4da8d52 (\"[XFS] write barrier support\")\nCc: <stable@vger.kernel.org>\nSigned-off-by: Richard Wareing <rwareing@fb.com>\nSigned-off-by: Dave Chinner <david@fromorbit.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/xfs\/xfs_linux.h | 9 ++++++++-\n 1 file changed, 8 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/xfs\/xfs_linux.h b\/fs\/xfs\/xfs_linux.h\nindex 9301c5a6060b68..dcd1292664b340 100644\n--- a\/fs\/xfs\/xfs_linux.h\n+++ b\/fs\/xfs\/xfs_linux.h\n@@ -270,7 +270,14 @@ static inline uint64_t howmany_64(uint64_t x, uint32_t y)\n #endif \/* DEBUG *\/\n \n #ifdef CONFIG_XFS_RT\n-#define XFS_IS_REALTIME_INODE(ip) ((ip)->i_d.di_flags & XFS_DIFLAG_REALTIME)\n+\n+\/*\n+ * make sure we ignore the inode flag if the filesystem doesn't have a\n+ * configured realtime device.\n+ *\/\n+#define XFS_IS_REALTIME_INODE(ip)\t\t\t\\\n+\t(((ip)->i_d.di_flags & XFS_DIFLAG_REALTIME) &&\t\\\n+\t (ip)->i_mount->m_rtdev_targp)\n #else\n #define XFS_IS_REALTIME_INODE(ip) (0)\n #endif\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-12818","CWE_ID":"476","category":"security","commit_id":"58bdd544e2933a21a51eecf17c3f5f94038261b5","commit_message":"From 58bdd544e2933a21a51eecf17c3f5f94038261b5 Mon Sep 17 00:00:00 2001\nFrom: YueHaibing <yuehaibing@huawei.com>\nDate: Fri, 22 Feb 2019 15:37:58 +0800\nSubject: net: nfc: Fix NULL dereference on nfc_llcp_build_tlv fails\n\nKASAN report this:\n\nBUG: KASAN: null-ptr-deref in nfc_llcp_build_gb+0x37f\/0x540 [nfc]\nRead of size 3 at addr 0000000000000000 by task syz-executor.0\/5401\n\nCPU: 0 PID: 5401 Comm: syz-executor.0 Not tainted 5.0.0-rc7+ #45\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04\/01\/2014\nCall Trace:\n __dump_stack lib\/dump_stack.c:77 [inline]\n dump_stack+0xfa\/0x1ce lib\/dump_stack.c:113\n kasan_report+0x171\/0x18d mm\/kasan\/report.c:321\n memcpy+0x1f\/0x50 mm\/kasan\/common.c:130\n nfc_llcp_build_gb+0x37f\/0x540 [nfc]\n nfc_llcp_register_device+0x6eb\/0xb50 [nfc]\n nfc_register_device+0x50\/0x1d0 [nfc]\n nfcsim_device_new+0x394\/0x67d [nfcsim]\n ? 0xffffffffc1080000\n nfcsim_init+0x6b\/0x1000 [nfcsim]\n do_one_initcall+0xfa\/0x5ca init\/main.c:887\n do_init_module+0x204\/0x5f6 kernel\/module.c:3460\n load_module+0x66b2\/0x8570 kernel\/module.c:3808\n __do_sys_finit_module+0x238\/0x2a0 kernel\/module.c:3902\n do_syscall_64+0x147\/0x600 arch\/x86\/entry\/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49\/0xbe\nRIP: 0033:0x462e99\nCode: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f9cb79dcc58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139\nRAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99\nRDX: 0000000000000000 RSI: 0000000020000280 RDI: 0000000000000003\nRBP: 00007f9cb79dcc70 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007f9cb79dd6bc\nR13: 00000000004bcefb R14: 00000000006f7030 R15: 0000000000000004\n\nnfc_llcp_build_tlv will return NULL on fails, caller should check it,\notherwise will trigger a NULL dereference.\n\nReported-by: Hulk Robot <hulkci@huawei.com>\nFixes: eda21f16a5ed (\"NFC: Set MIU and RW values from CONNECT and CC LLCP frames\")\nFixes: d646960f7986 (\"NFC: Initial LLCP support\")\nSigned-off-by: YueHaibing <yuehaibing@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/nfc\/llcp_commands.c | 20 ++++++++++++++++++++\n net\/nfc\/llcp_core.c     | 24 ++++++++++++++++++++----\n 2 files changed, 40 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/net\/nfc\/llcp_commands.c b\/net\/nfc\/llcp_commands.c\nindex 6a196e438b6c..d1fc019e932e 100644\n--- a\/net\/nfc\/llcp_commands.c\n+++ b\/net\/nfc\/llcp_commands.c\n@@ -419,6 +419,10 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n \t\t\t\t\t\t      sock->service_name,\n \t\t\t\t\t\t      sock->service_name_len,\n \t\t\t\t\t\t      &service_name_tlv_length);\n+\t\tif (!service_name_tlv) {\n+\t\t\terr = -ENOMEM;\n+\t\t\tgoto error_tlv;\n+\t\t}\n \t\tsize += service_name_tlv_length;\n \t}\n \n@@ -429,9 +433,17 @@ int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n+\tif (!miux_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n+\tif (!rw_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += rw_tlv_length;\n \n \tpr_debug(\"SKB size %d SN length %zu\\n\", size, sock->service_name_len);\n@@ -484,9 +496,17 @@ int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n \t\t\t\t      &miux_tlv_length);\n+\tif (!miux_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += miux_tlv_length;\n \n \trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n+\tif (!rw_tlv) {\n+\t\terr = -ENOMEM;\n+\t\tgoto error_tlv;\n+\t}\n \tsize += rw_tlv_length;\n \n \tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\ndiff --git a\/net\/nfc\/llcp_core.c b\/net\/nfc\/llcp_core.c\nindex ef4026a23e80..4fa015208aab 100644\n--- a\/net\/nfc\/llcp_core.c\n+++ b\/net\/nfc\/llcp_core.c\n@@ -532,10 +532,10 @@ static u8 nfc_llcp_reserve_sdp_ssap(struct nfc_llcp_local *local)\n \n static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n {\n-\tu8 *gb_cur, *version_tlv, version, version_length;\n-\tu8 *lto_tlv, lto_length;\n-\tu8 *wks_tlv, wks_length;\n-\tu8 *miux_tlv, miux_length;\n+\tu8 *gb_cur, version, version_length;\n+\tu8 lto_length, wks_length, miux_length;\n+\tu8 *version_tlv = NULL, *lto_tlv = NULL,\n+\t   *wks_tlv = NULL, *miux_tlv = NULL;\n \t__be16 wks = cpu_to_be16(local->local_wks);\n \tu8 gb_len = 0;\n \tint ret = 0;\n@@ -543,17 +543,33 @@ static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n \tversion = LLCP_VERSION_11;\n \tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n \t\t\t\t\t 1, &version_length);\n+\tif (!version_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += version_length;\n \n \tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n+\tif (!lto_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += lto_length;\n \n \tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n \twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n+\tif (!wks_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += wks_length;\n \n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n \t\t\t\t      &miux_length);\n+\tif (!miux_tlv) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n \tgb_len += miux_length;\n \n \tgb_len += ARRAY_SIZE(llcp_magic);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-4118","CWE_ID":"476","category":"security","commit_id":"7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7","commit_message":"From 7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7 Mon Sep 17 00:00:00 2001\nFrom: Vic Lee <llyzs@163.com>\nDate: Tue, 5 Mar 2013 15:08:03 +0800\nSubject: [PATCH] security: add a NULL pointer check to fix a server crash.\n\n---\n libfreerdp\/core\/rdp.c      | 3 ++-\n libfreerdp\/core\/security.c | 2 ++\n 2 files changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libfreerdp\/core\/rdp.c b\/libfreerdp\/core\/rdp.c\nindex 544a9dd9e8..7eecc68805 100644\n--- a\/libfreerdp\/core\/rdp.c\n+++ b\/libfreerdp\/core\/rdp.c\n@@ -717,7 +717,8 @@ BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n \n \tstream_read(s, wmac, sizeof(wmac));\n \tlength -= sizeof(wmac);\n-\tsecurity_decrypt(s->p, length, rdp);\n+\tif (!security_decrypt(s->p, length, rdp))\n+\t\treturn FALSE;\n \n \tif (securityFlags & SEC_SECURE_CHECKSUM)\n \t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\ndiff --git a\/libfreerdp\/core\/security.c b\/libfreerdp\/core\/security.c\nindex 8511d8d0ab..83298fdd1b 100644\n--- a\/libfreerdp\/core\/security.c\n+++ b\/libfreerdp\/core\/security.c\n@@ -492,6 +492,8 @@ BOOL security_encrypt(BYTE* data, int length, rdpRdp* rdp)\n \n BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n {\n+\tif (rdp->rc4_decrypt_key == NULL)\n+\t\treturn FALSE;\n \tif (rdp->decrypt_use_count >= 4096)\n \t{\n \t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);\n","owner":"FreeRDP","repo":"FreeRDP","source":"cve"},{"CVE_ID":"CVE-2017-12192","CWE_ID":"476","category":"security","commit_id":"37863c43b2c6464f252862bf2e9768264e961678","commit_message":"From 37863c43b2c6464f252862bf2e9768264e961678 Mon Sep 17 00:00:00 2001\nFrom: Eric Biggers <ebiggers@google.com>\nDate: Mon, 18 Sep 2017 11:37:23 -0700\nSubject: KEYS: prevent KEYCTL_READ on negative key\n\nBecause keyctl_read_key() looks up the key with no permissions\nrequested, it may find a negatively instantiated key.  If the key is\nalso possessed, we went ahead and called ->read() on the key.  But the\nkey payload will actually contain the ->reject_error rather than the\nnormal payload.  Thus, the kernel oopses trying to read the\nuser_key_payload from memory address (int)-ENOKEY = 0x00000000ffffff82.\n\nFortunately the payload data is stored inline, so it shouldn't be\npossible to abuse this as an arbitrary memory read primitive...\n\nReproducer:\n    keyctl new_session\n    keyctl request2 user desc '' @s\n    keyctl read $(keyctl show | awk '\/user: desc\/ {print $1}')\n\nIt causes a crash like the following:\n     BUG: unable to handle kernel paging request at 00000000ffffff92\n     IP: user_read+0x33\/0xa0\n     PGD 36a54067 P4D 36a54067 PUD 0\n     Oops: 0000 [#1] SMP\n     CPU: 0 PID: 211 Comm: keyctl Not tainted 4.14.0-rc1 #337\n     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-20170228_101828-anatol 04\/01\/2014\n     task: ffff90aa3b74c3c0 task.stack: ffff9878c0478000\n     RIP: 0010:user_read+0x33\/0xa0\n     RSP: 0018:ffff9878c047bee8 EFLAGS: 00010246\n     RAX: 0000000000000001 RBX: ffff90aa3d7da340 RCX: 0000000000000017\n     RDX: 0000000000000000 RSI: 00000000ffffff82 RDI: ffff90aa3d7da340\n     RBP: ffff9878c047bf00 R08: 00000024f95da94f R09: 0000000000000000\n     R10: 0000000000000001 R11: 0000000000000000 R12: 0000000000000000\n     R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n     FS:  00007f58ece69740(0000) GS:ffff90aa3e200000(0000) knlGS:0000000000000000\n     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n     CR2: 00000000ffffff92 CR3: 0000000036adc001 CR4: 00000000003606f0\n     Call Trace:\n      keyctl_read_key+0xac\/0xe0\n      SyS_keyctl+0x99\/0x120\n      entry_SYSCALL_64_fastpath+0x1f\/0xbe\n     RIP: 0033:0x7f58ec787bb9\n     RSP: 002b:00007ffc8d401678 EFLAGS: 00000206 ORIG_RAX: 00000000000000fa\n     RAX: ffffffffffffffda RBX: 00007ffc8d402800 RCX: 00007f58ec787bb9\n     RDX: 0000000000000000 RSI: 00000000174a63ac RDI: 000000000000000b\n     RBP: 0000000000000004 R08: 00007ffc8d402809 R09: 0000000000000020\n     R10: 0000000000000000 R11: 0000000000000206 R12: 00007ffc8d402800\n     R13: 00007ffc8d4016e0 R14: 0000000000000000 R15: 0000000000000000\n     Code: e5 41 55 49 89 f5 41 54 49 89 d4 53 48 89 fb e8 a4 b4 ad ff 85 c0 74 09 80 3d b9 4c 96 00 00 74 43 48 8b b3 20 01 00 00 4d 85 ed <0f> b7 5e 10 74 29 4d 85 e4 74 24 4c 39 e3 4c 89 e2 4c 89 ef 48\n     RIP: user_read+0x33\/0xa0 RSP: ffff9878c047bee8\n     CR2: 00000000ffffff92\n\nFixes: 61ea0c0ba904 (\"KEYS: Skip key state checks when checking for possession\")\nCc: <stable@vger.kernel.org>\t[v3.13+]\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\n---\n security\/keys\/keyctl.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/security\/keys\/keyctl.c b\/security\/keys\/keyctl.c\nindex aa1d11a29136..365ff85d7e27 100644\n--- a\/security\/keys\/keyctl.c\n+++ b\/security\/keys\/keyctl.c\n@@ -766,6 +766,11 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n \n \tkey = key_ref_to_ptr(key_ref);\n \n+\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n+\t\tret = -ENOKEY;\n+\t\tgoto error2;\n+\t}\n+\n \t\/* see if we can read it directly *\/\n \tret = key_permission(key_ref, KEY_NEED_READ);\n \tif (ret == 0)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-9313","CWE_ID":"476","category":"security","commit_id":"7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb","commit_message":"From 7df3e59c3d1df4f87fe874c7956ef7a3d2f4d5fb Mon Sep 17 00:00:00 2001\nFrom: David Howells <dhowells@redhat.com>\nDate: Wed, 26 Oct 2016 15:02:01 +0100\nSubject: [PATCH] KEYS: Sort out big_key initialisation\n\nbig_key has two separate initialisation functions, one that registers the\nkey type and one that registers the crypto.  If the key type fails to\nregister, there's no problem if the crypto registers successfully because\nthere's no way to reach the crypto except through the key type.\n\nHowever, if the key type registers successfully but the crypto does not,\nbig_key_rng and big_key_blkcipher may end up set to NULL - but the code\nneither checks for this nor unregisters the big key key type.\n\nFurthermore, since the key type is registered before the crypto, it is\ntheoretically possible for the kernel to try adding a big_key before the\ncrypto is set up, leading to the same effect.\n\nFix this by merging big_key_crypto_init() and big_key_init() and calling\nthe resulting function late.  If they're going to be encrypted, we\nshouldn't be creating big_keys before we have the facilities to do the\nencryption available.  The key type registration is also moved after the\ncrypto initialisation.\n\nThe fix also includes message printing on failure.\n\nIf the big_key type isn't correctly set up, simply doing:\n\n\tdd if=\/dev\/zero bs=4096 count=1 | keyctl padd big_key a @s\n\nought to cause an oops.\n\nFixes: 13100a72f40f5748a04017e0ab3df4cf27c809ef ('Security: Keys: Big keys stored encrypted')\nSigned-off-by: David Howells <dhowells@redhat.com>\ncc: Peter Hlavaty <zer0mem@yahoo.com>\ncc: Kirill Marinushkin <k.marinushkin@gmail.com>\ncc: Artem Savkov <asavkov@redhat.com>\ncc: stable@vger.kernel.org\nSigned-off-by: James Morris <james.l.morris@oracle.com>\n---\n security\/keys\/big_key.c | 59 ++++++++++++++++++++++-------------------\n 1 file changed, 32 insertions(+), 27 deletions(-)\n\n","diff_code":"diff --git a\/security\/keys\/big_key.c b\/security\/keys\/big_key.c\nindex c0b3030b56348..835c1ab30d01e 100644\n--- a\/security\/keys\/big_key.c\n+++ b\/security\/keys\/big_key.c\n@@ -9,6 +9,7 @@\n  * 2 of the Licence, or (at your option) any later version.\n  *\/\n \n+#define pr_fmt(fmt) \"big_key: \"fmt\n #include <linux\/init.h>\n #include <linux\/seq_file.h>\n #include <linux\/file.h>\n@@ -341,44 +342,48 @@ long big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n  *\/\n static int __init big_key_init(void)\n {\n-\treturn register_key_type(&key_type_big_key);\n-}\n-\n-\/*\n- * Initialize big_key crypto and RNG algorithms\n- *\/\n-static int __init big_key_crypto_init(void)\n-{\n-\tint ret = -EINVAL;\n+\tstruct crypto_skcipher *cipher;\n+\tstruct crypto_rng *rng;\n+\tint ret;\n \n-\t\/* init RNG *\/\n-\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n-\tif (IS_ERR(big_key_rng)) {\n-\t\tbig_key_rng = NULL;\n-\t\treturn -EFAULT;\n+\trng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n+\tif (IS_ERR(rng)) {\n+\t\tpr_err(\"Can't alloc rng: %ld\\n\", PTR_ERR(rng));\n+\t\treturn PTR_ERR(rng);\n \t}\n \n+\tbig_key_rng = rng;\n+\n \t\/* seed RNG *\/\n-\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n-\tif (ret)\n-\t\tgoto error;\n+\tret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));\n+\tif (ret) {\n+\t\tpr_err(\"Can't reset rng: %d\\n\", ret);\n+\t\tgoto error_rng;\n+\t}\n \n \t\/* init block cipher *\/\n-\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n-\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n-\tif (IS_ERR(big_key_skcipher)) {\n-\t\tbig_key_skcipher = NULL;\n-\t\tret = -EFAULT;\n-\t\tgoto error;\n+\tcipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);\n+\tif (IS_ERR(cipher)) {\n+\t\tret = PTR_ERR(cipher);\n+\t\tpr_err(\"Can't alloc crypto: %d\\n\", ret);\n+\t\tgoto error_rng;\n+\t}\n+\n+\tbig_key_skcipher = cipher;\n+\n+\tret = register_key_type(&key_type_big_key);\n+\tif (ret < 0) {\n+\t\tpr_err(\"Can't register type: %d\\n\", ret);\n+\t\tgoto error_cipher;\n \t}\n \n \treturn 0;\n \n-error:\n+error_cipher:\n+\tcrypto_free_skcipher(big_key_skcipher);\n+error_rng:\n \tcrypto_free_rng(big_key_rng);\n-\tbig_key_rng = NULL;\n \treturn ret;\n }\n \n-device_initcall(big_key_init);\n-late_initcall(big_key_crypto_init);\n+late_initcall(big_key_init);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-5937","CWE_ID":"476","category":"security","commit_id":"48f67f60967f963b698ec8df57ec6912a43d6282","commit_message":"From 48f67f60967f963b698ec8df57ec6912a43d6282 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Thu, 29 Dec 2016 05:57:40 -0500\nSubject: renderer: fix NULL pointer deref in vrend_clear\n\nIn vrend clear dispatch function, the 'buffers' is read from\nguest. A malicious guest can specify a bad 'buffers' to make\na the function call util_format_is_pure_uint() even the\n'ctx->sub->surf[i]' is NULL. This can cause a NULL pointer deref.\nMake a sanity check to avoid this.\n\n[airlied: use a define]\n\nSigned-off-by: Li Qiang <liq3ea@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n src\/vrend_renderer.c | 8 ++++----\n src\/vrend_renderer.h | 2 +-\n 2 files changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/vrend_renderer.c b\/src\/vrend_renderer.c\nindex 0af91ae..1bca7ad 100644\n--- a\/src\/vrend_renderer.c\n+++ b\/src\/vrend_renderer.c\n@@ -325,7 +325,7 @@ struct vrend_sub_context {\n    uint32_t fb_id;\n    int nr_cbufs, old_nr_cbufs;\n    struct vrend_surface *zsurf;\n-   struct vrend_surface *surf[8];\n+   struct vrend_surface *surf[PIPE_MAX_COLOR_BUFS];\n \n    struct vrend_viewport vps[PIPE_MAX_VIEWPORTS];\n    float depth_transform, depth_scale;\n@@ -1482,7 +1482,7 @@ static void vrend_hw_emit_framebuffer_state(struct vrend_context *ctx)\n }\n \n void vrend_set_framebuffer_state(struct vrend_context *ctx,\n-                                 uint32_t nr_cbufs, uint32_t surf_handle[8],\n+                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],\n                                  uint32_t zsurf_handle)\n {\n    struct vrend_surface *surf, *zsurf;\n@@ -2367,10 +2367,10 @@ void vrend_clear(struct vrend_context *ctx,\n          mask = buffers >> 2;\n          while (mask) {\n             i = u_bit_scan(&mask);\n-            if (util_format_is_pure_uint(ctx->sub->surf[i]->format))\n+            if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_uint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))\n                glClearBufferuiv(GL_COLOR,\n                                 i, (GLuint *)color);\n-            else if (util_format_is_pure_sint(ctx->sub->surf[i]->format))\n+            else if (i < PIPE_MAX_COLOR_BUFS && ctx->sub->surf[i] && util_format_is_pure_sint(ctx->sub->surf[i] && ctx->sub->surf[i]->format))\n                glClearBufferiv(GL_COLOR,\n                                 i, (GLint *)color);\n             else\ndiff --git a\/src\/vrend_renderer.h b\/src\/vrend_renderer.h\nindex dde7d75..b9eeb71 100644\n--- a\/src\/vrend_renderer.h\n+++ b\/src\/vrend_renderer.h\n@@ -127,7 +127,7 @@ void vrend_draw_vbo(struct vrend_context *ctx,\n                     uint32_t cso);\n \n void vrend_set_framebuffer_state(struct vrend_context *ctx,\n-                                 uint32_t nr_cbufs, uint32_t surf_handle[8],\n+                                 uint32_t nr_cbufs, uint32_t surf_handle[PIPE_MAX_COLOR_BUFS],\n                                  uint32_t zsurf_handle);\n \n struct vrend_context *vrend_create_context(int id, uint32_t nlen, const char *debug_name);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-2647","CWE_ID":"476","category":"security","commit_id":"c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81","commit_message":"From c06cfb08b88dfbe13be44a69ae2fdc3a7c902d81 Mon Sep 17 00:00:00 2001\nFrom: David Howells <dhowells@redhat.com>\nDate: Tue, 16 Sep 2014 17:36:06 +0100\nSubject: [PATCH] KEYS: Remove key_type::match in favour of overriding default\n by match_preparse\n\nA previous patch added a ->match_preparse() method to the key type.  This is\nallowed to override the function called by the iteration algorithm.\nTherefore, we can just set a default that simply checks for an exact match of\nthe key description with the original criterion data and allow match_preparse\nto override it as needed.\n\nThe key_type::match op is then redundant and can be removed, as can the\nuser_match() function.\n\nSigned-off-by: David Howells <dhowells@redhat.com>\nAcked-by: Vivek Goyal <vgoyal@redhat.com>\n---\n crypto\/asymmetric_keys\/asymmetric_type.c |  6 +++---\n crypto\/asymmetric_keys\/pkcs7_key_type.c  |  1 -\n fs\/cifs\/cifs_spnego.c                    |  1 -\n fs\/cifs\/cifsacl.c                        |  1 -\n fs\/nfs\/idmap.c                           |  2 --\n include\/keys\/user-type.h                 |  3 ---\n include\/linux\/key-type.h                 |  4 ----\n net\/ceph\/crypto.c                        |  1 -\n net\/dns_resolver\/dns_key.c               | 17 +++++++++++++----\n net\/rxrpc\/ar-key.c                       |  2 --\n security\/keys\/big_key.c                  |  1 -\n security\/keys\/encrypted-keys\/encrypted.c |  1 -\n security\/keys\/internal.h                 |  2 ++\n security\/keys\/key.c                      |  2 +-\n security\/keys\/keyring.c                  | 15 ++++++++++-----\n security\/keys\/request_key.c              |  2 +-\n security\/keys\/request_key_auth.c         |  2 +-\n security\/keys\/trusted.c                  |  1 -\n security\/keys\/user_defined.c             | 12 ------------\n 19 files changed, 31 insertions(+), 45 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/asymmetric_keys\/asymmetric_type.c b\/crypto\/asymmetric_keys\/asymmetric_type.c\nindex 9d78ad7754d9a..7c04989689757 100644\n--- a\/crypto\/asymmetric_keys\/asymmetric_type.c\n+++ b\/crypto\/asymmetric_keys\/asymmetric_type.c\n@@ -59,8 +59,8 @@ EXPORT_SYMBOL_GPL(asymmetric_keyid_match);\n  *\t\"id:<id>\"\t- request a key matching the ID\n  *\t\"<subtype>:<id>\" - request a key of a subtype\n  *\/\n-static int asymmetric_key_match(const struct key *key,\n-\t\t\t\tconst struct key_match_data *match_data)\n+static int asymmetric_key_cmp(const struct key *key,\n+\t\t\t      const struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n@@ -110,6 +110,7 @@ static int asymmetric_key_match(const struct key *key,\n static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }\n \n@@ -224,7 +225,6 @@ struct key_type key_type_asymmetric = {\n \t.free_preparse\t= asymmetric_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n \t.match_preparse\t= asymmetric_key_match_preparse,\n-\t.match\t\t= asymmetric_key_match,\n \t.match_free\t= asymmetric_key_match_free,\n \t.destroy\t= asymmetric_key_destroy,\n \t.describe\t= asymmetric_key_describe,\ndiff --git a\/crypto\/asymmetric_keys\/pkcs7_key_type.c b\/crypto\/asymmetric_keys\/pkcs7_key_type.c\nindex d1faa1df1decd..751f8fd7335db 100644\n--- a\/crypto\/asymmetric_keys\/pkcs7_key_type.c\n+++ b\/crypto\/asymmetric_keys\/pkcs7_key_type.c\n@@ -75,7 +75,6 @@ static struct key_type key_type_pkcs7 = {\n \t.preparse\t\t= pkcs7_preparse,\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\ndiff --git a\/fs\/cifs\/cifs_spnego.c b\/fs\/cifs\/cifs_spnego.c\nindex a3e932547617e..f4cf200b3c767 100644\n--- a\/fs\/cifs\/cifs_spnego.c\n+++ b\/fs\/cifs\/cifs_spnego.c\n@@ -62,7 +62,6 @@ cifs_spnego_key_destroy(struct key *key)\n struct key_type cifs_spnego_key_type = {\n \t.name\t\t= \"cifs.spnego\",\n \t.instantiate\t= cifs_spnego_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= cifs_spnego_key_destroy,\n \t.describe\t= user_describe,\n };\ndiff --git a\/fs\/cifs\/cifsacl.c b\/fs\/cifs\/cifsacl.c\nindex 7ff866dbb89eb..6d00c419cbae0 100644\n--- a\/fs\/cifs\/cifsacl.c\n+++ b\/fs\/cifs\/cifsacl.c\n@@ -84,7 +84,6 @@ static struct key_type cifs_idmap_key_type = {\n \t.instantiate = cifs_idmap_key_instantiate,\n \t.destroy     = cifs_idmap_key_destroy,\n \t.describe    = user_describe,\n-\t.match       = user_match,\n };\n \n static char *\ndiff --git a\/fs\/nfs\/idmap.c b\/fs\/nfs\/idmap.c\nindex 7dd55b745c4d9..2f5db844c1725 100644\n--- a\/fs\/nfs\/idmap.c\n+++ b\/fs\/nfs\/idmap.c\n@@ -177,7 +177,6 @@ static struct key_type key_type_id_resolver = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,\n@@ -401,7 +400,6 @@ static struct key_type key_type_id_resolver_legacy = {\n \t.preparse\t= user_preparse,\n \t.free_preparse\t= user_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= user_describe,\ndiff --git a\/include\/keys\/user-type.h b\/include\/keys\/user-type.h\nindex 66d92af30e7c0..cebefb069c44a 100644\n--- a\/include\/keys\/user-type.h\n+++ b\/include\/keys\/user-type.h\n@@ -36,13 +36,10 @@ extern struct key_type key_type_user;\n extern struct key_type key_type_logon;\n \n struct key_preparsed_payload;\n-struct key_match_data;\n \n extern int user_preparse(struct key_preparsed_payload *prep);\n extern void user_free_preparse(struct key_preparsed_payload *prep);\n extern int user_update(struct key *key, struct key_preparsed_payload *prep);\n-extern int user_match(const struct key *key,\n-\t\t      const struct key_match_data *match_data);\n extern void user_revoke(struct key *key);\n extern void user_destroy(struct key *key);\n extern void user_describe(const struct key *user, struct seq_file *m);\ndiff --git a\/include\/linux\/key-type.h b\/include\/linux\/key-type.h\nindex bf93ea6092738..c14816bd3b44f 100644\n--- a\/include\/linux\/key-type.h\n+++ b\/include\/linux\/key-type.h\n@@ -113,10 +113,6 @@ struct key_type {\n \t *\/\n \tint (*match_preparse)(struct key_match_data *match_data);\n \n-\t\/* match a key against a description *\/\n-\tint (*match)(const struct key *key,\n-\t\t     const struct key_match_data *match_data);\n-\n \t\/* Free preparsed match data (optional).  This should be supplied it\n \t * ->match_preparse() is supplied. *\/\n \tvoid (*match_free)(struct key_match_data *match_data);\ndiff --git a\/net\/ceph\/crypto.c b\/net\/ceph\/crypto.c\nindex ffeba8f9dda92..62fc5e7a9acf7 100644\n--- a\/net\/ceph\/crypto.c\n+++ b\/net\/ceph\/crypto.c\n@@ -476,7 +476,6 @@ struct key_type key_type_ceph = {\n \t.preparse\t= ceph_key_preparse,\n \t.free_preparse\t= ceph_key_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= ceph_key_destroy,\n };\n \ndiff --git a\/net\/dns_resolver\/dns_key.c b\/net\/dns_resolver\/dns_key.c\nindex 92df6e508ae7d..a07b9ba7e0b7b 100644\n--- a\/net\/dns_resolver\/dns_key.c\n+++ b\/net\/dns_resolver\/dns_key.c\n@@ -176,9 +176,8 @@ static void dns_resolver_free_preparse(struct key_preparsed_payload *prep)\n  * The domain name may be a simple name or an absolute domain name (which\n  * should end with a period).  The domain name is case-independent.\n  *\/\n-static int\n-dns_resolver_match(const struct key *key,\n-\t\t   const struct key_match_data *match_data)\n+static int dns_resolver_cmp(const struct key *key,\n+\t\t\t    const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n@@ -209,6 +208,16 @@ dns_resolver_match(const struct key *key,\n \treturn ret;\n }\n \n+\/*\n+ * Preparse the match criterion.\n+ *\/\n+static int dns_resolver_match_preparse(struct key_match_data *match_data)\n+{\n+\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n+\tmatch_data->cmp = dns_resolver_cmp;\n+\treturn 0;\n+}\n+\n \/*\n  * Describe a DNS key\n  *\/\n@@ -243,7 +252,7 @@ struct key_type key_type_dns_resolver = {\n \t.preparse\t= dns_resolver_preparse,\n \t.free_preparse\t= dns_resolver_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= dns_resolver_match,\n+\t.match_preparse\t= dns_resolver_match_preparse,\n \t.revoke\t\t= user_revoke,\n \t.destroy\t= user_destroy,\n \t.describe\t= dns_resolver_describe,\ndiff --git a\/net\/rxrpc\/ar-key.c b\/net\/rxrpc\/ar-key.c\nindex 3907add75932d..10c6cb694b434 100644\n--- a\/net\/rxrpc\/ar-key.c\n+++ b\/net\/rxrpc\/ar-key.c\n@@ -44,7 +44,6 @@ struct key_type key_type_rxrpc = {\n \t.preparse\t= rxrpc_preparse,\n \t.free_preparse\t= rxrpc_free_preparse,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy,\n \t.describe\t= rxrpc_describe,\n \t.read\t\t= rxrpc_read,\n@@ -61,7 +60,6 @@ struct key_type key_type_rxrpc_s = {\n \t.preparse\t= rxrpc_preparse_s,\n \t.free_preparse\t= rxrpc_free_preparse_s,\n \t.instantiate\t= generic_key_instantiate,\n-\t.match\t\t= user_match,\n \t.destroy\t= rxrpc_destroy_s,\n \t.describe\t= rxrpc_describe,\n };\ndiff --git a\/security\/keys\/big_key.c b\/security\/keys\/big_key.c\nindex 4045c13a761a9..b6adb94f6d525 100644\n--- a\/security\/keys\/big_key.c\n+++ b\/security\/keys\/big_key.c\n@@ -36,7 +36,6 @@ struct key_type key_type_big_key = {\n \t.preparse\t\t= big_key_preparse,\n \t.free_preparse\t\t= big_key_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= big_key_revoke,\n \t.destroy\t\t= big_key_destroy,\n \t.describe\t\t= big_key_describe,\ndiff --git a\/security\/keys\/encrypted-keys\/encrypted.c b\/security\/keys\/encrypted-keys\/encrypted.c\nindex 5fe443d120afe..db9675db10262 100644\n--- a\/security\/keys\/encrypted-keys\/encrypted.c\n+++ b\/security\/keys\/encrypted-keys\/encrypted.c\n@@ -970,7 +970,6 @@ struct key_type key_type_encrypted = {\n \t.name = \"encrypted\",\n \t.instantiate = encrypted_instantiate,\n \t.update = encrypted_update,\n-\t.match = user_match,\n \t.destroy = encrypted_destroy,\n \t.describe = user_describe,\n \t.read = encrypted_read,\ndiff --git a\/security\/keys\/internal.h b\/security\/keys\/internal.h\nindex b47cc532be1e3..e66a16cb63e1c 100644\n--- a\/security\/keys\/internal.h\n+++ b\/security\/keys\/internal.h\n@@ -127,6 +127,8 @@ struct keyring_search_context {\n \tstruct timespec\t\tnow;\n };\n \n+extern int key_default_cmp(const struct key *key,\n+\t\t\t   const struct key_match_data *match_data);\n extern key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n \t\t\t\t    struct keyring_search_context *ctx);\n \ndiff --git a\/security\/keys\/key.c b\/security\/keys\/key.c\nindex b90a68c4e2c42..8c0092ca04430 100644\n--- a\/security\/keys\/key.c\n+++ b\/security\/keys\/key.c\n@@ -799,7 +799,7 @@ key_ref_t key_create_or_update(key_ref_t keyring_ref,\n \t}\n \n \tkey_ref = ERR_PTR(-EINVAL);\n-\tif (!index_key.type->match || !index_key.type->instantiate ||\n+\tif (!index_key.type->instantiate ||\n \t    (!index_key.description && !index_key.type->preparse))\n \t\tgoto error_put_type;\n \ndiff --git a\/security\/keys\/keyring.c b\/security\/keys\/keyring.c\nindex 10f0a5f2d3620..253c9a0eb092e 100644\n--- a\/security\/keys\/keyring.c\n+++ b\/security\/keys\/keyring.c\n@@ -89,7 +89,6 @@ struct key_type key_type_keyring = {\n \t.preparse\t= keyring_preparse,\n \t.free_preparse\t= keyring_free_preparse,\n \t.instantiate\t= keyring_instantiate,\n-\t.match\t\t= user_match,\n \t.revoke\t\t= keyring_revoke,\n \t.destroy\t= keyring_destroy,\n \t.describe\t= keyring_describe,\n@@ -511,6 +510,15 @@ struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n }\n EXPORT_SYMBOL(keyring_alloc);\n \n+\/*\n+ * By default, we keys found by getting an exact match on their descriptions.\n+ *\/\n+int key_default_cmp(const struct key *key,\n+\t\t    const struct key_match_data *match_data)\n+{\n+\treturn strcmp(key->description, match_data->raw_data) == 0;\n+}\n+\n \/*\n  * Iteration function to consider each key found.\n  *\/\n@@ -884,7 +892,7 @@ key_ref_t keyring_search(key_ref_t keyring,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n@@ -892,9 +900,6 @@ key_ref_t keyring_search(key_ref_t keyring,\n \tkey_ref_t key;\n \tint ret;\n \n-\tif (!ctx.match_data.cmp)\n-\t\treturn ERR_PTR(-ENOKEY);\n-\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)\ndiff --git a\/security\/keys\/request_key.c b\/security\/keys\/request_key.c\nindex 408523e5e2e2e..dc6ed32b7844c 100644\n--- a\/security\/keys\/request_key.c\n+++ b\/security\/keys\/request_key.c\n@@ -531,7 +531,7 @@ struct key *request_key_and_link(struct key_type *type,\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= type->match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};\ndiff --git a\/security\/keys\/request_key_auth.c b\/security\/keys\/request_key_auth.c\nindex 9ae02819cc064..6639e2cb88532 100644\n--- a\/security\/keys\/request_key_auth.c\n+++ b\/security\/keys\/request_key_auth.c\n@@ -246,7 +246,7 @@ struct key *key_get_instantiation_authkey(key_serial_t target_id)\n \t\t.index_key.type\t\t= &key_type_request_key_auth,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n-\t\t.match_data.cmp\t\t= user_match,\n+\t\t.match_data.cmp\t\t= key_default_cmp,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t};\ndiff --git a\/security\/keys\/trusted.c b\/security\/keys\/trusted.c\nindex 6b804aa4529a1..c0594cb07adab 100644\n--- a\/security\/keys\/trusted.c\n+++ b\/security\/keys\/trusted.c\n@@ -1096,7 +1096,6 @@ struct key_type key_type_trusted = {\n \t.name = \"trusted\",\n \t.instantiate = trusted_instantiate,\n \t.update = trusted_update,\n-\t.match = user_match,\n \t.destroy = trusted_destroy,\n \t.describe = user_describe,\n \t.read = trusted_read,\ndiff --git a\/security\/keys\/user_defined.c b\/security\/keys\/user_defined.c\nindex cd7e726e8646a..36b47bbd3d8cc 100644\n--- a\/security\/keys\/user_defined.c\n+++ b\/security\/keys\/user_defined.c\n@@ -30,7 +30,6 @@ struct key_type key_type_user = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -51,7 +50,6 @@ struct key_type key_type_logon = {\n \t.free_preparse\t\t= user_free_preparse,\n \t.instantiate\t\t= generic_key_instantiate,\n \t.update\t\t\t= user_update,\n-\t.match\t\t\t= user_match,\n \t.revoke\t\t\t= user_revoke,\n \t.destroy\t\t= user_destroy,\n \t.describe\t\t= user_describe,\n@@ -136,16 +134,6 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n EXPORT_SYMBOL_GPL(user_update);\n \n-\/*\n- * match users on their name\n- *\/\n-int user_match(const struct key *key, const struct key_match_data *match_data)\n-{\n-\treturn strcmp(key->description, match_data->raw_data) == 0;\n-}\n-\n-EXPORT_SYMBOL_GPL(user_match);\n-\n \/*\n  * dispose of the links from a revoked keyring\n  * - called with the key sem write-locked\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-3730","CWE_ID":"476","category":"security","commit_id":"efbe126e3ebb9123ac9d058aa2bb044261342aaa","commit_message":"From efbe126e3ebb9123ac9d058aa2bb044261342aaa Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Wed, 23 Nov 2016 22:12:40 +0000\nSubject: [PATCH] Fix missing NULL checks in CKE processing\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n---\n ssl\/statem\/statem_clnt.c | 9 +++++++++\n 1 file changed, 9 insertions(+)\n\n","diff_code":"diff --git a\/ssl\/statem\/statem_clnt.c b\/ssl\/statem\/statem_clnt.c\nindex e90a63cc87f..5ea0919e4ac 100644\n--- a\/ssl\/statem\/statem_clnt.c\n+++ b\/ssl\/statem\/statem_clnt.c\n@@ -2258,6 +2258,11 @@ static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)\n         return 0;\n     }\n     ckey = ssl_generate_pkey(skey);\n+    if (ckey == NULL) {\n+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n+        return 0;\n+    }\n+\n     dh_clnt = EVP_PKEY_get0_DH(ckey);\n \n     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {\n@@ -2296,6 +2301,10 @@ static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n     }\n \n     ckey = ssl_generate_pkey(skey);\n+    if (ckey == NULL) {\n+        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n+        goto err;\n+    }\n \n     if (ssl_derive(s, ckey, skey) == 0) {\n         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n","owner":"openssl","repo":"openssl","source":"cve"},{"CVE_ID":"CVE-2017-7458","CWE_ID":"476","category":"security","commit_id":"01f47e04fd7c8d54399c9e465f823f0017069f8f","commit_message":"From 01f47e04fd7c8d54399c9e465f823f0017069f8f Mon Sep 17 00:00:00 2001\nFrom: Simone Mainardi <mainardi@ntop.org>\nDate: Mon, 13 Feb 2017 23:47:02 +0100\nSubject: [PATCH] Security fix: prevents empty host from being used\n\n---\n src\/Lua.cpp              | 3 ++-\n src\/NetworkInterface.cpp | 2 ++\n 2 files changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/Lua.cpp b\/src\/Lua.cpp\nindex 33ef71e7e..b12d79df2 100644\n--- a\/src\/Lua.cpp\n+++ b\/src\/Lua.cpp\n@@ -6018,7 +6018,8 @@ void Lua::setParamsTable(lua_State* vm, const char* table_name,\n       char *_equal;\n \n       if(strncmp(tok, \"csrf\", strlen(\"csrf\")) \/* Do not put csrf into the params table *\/\n-\t && (_equal = strchr(tok, '='))) {\n+\t && (_equal = strchr(tok, '='))\n+\t && (strlen(_equal) > 1)) {\n \tchar *decoded_buf;\n         int len;\n \ndiff --git a\/src\/NetworkInterface.cpp b\/src\/NetworkInterface.cpp\nindex c35b595b0..7b92cd4dc 100644\n--- a\/src\/NetworkInterface.cpp\n+++ b\/src\/NetworkInterface.cpp\n@@ -2200,6 +2200,8 @@ Host* NetworkInterface::getHost(char *host_ip, u_int16_t vlan_id) {\n   struct in6_addr a6;\n   Host *h = NULL;\n \n+  if(!host_ip) return(NULL);\n+\n   \/* Check if address is invalid *\/\n   if((inet_pton(AF_INET, (const char*)host_ip, &a4) == 0)\n      && (inet_pton(AF_INET6, (const char*)host_ip, &a6) == 0)) {\n","owner":"ntop","repo":"ntopng","source":"cve"},{"CVE_ID":"CVE-2018-7191","CWE_ID":"476","category":"security","commit_id":"0ad646c81b2182f7fa67ec0c8c825e0ee165696d","commit_message":"From 0ad646c81b2182f7fa67ec0c8c825e0ee165696d Mon Sep 17 00:00:00 2001\nFrom: Cong Wang <xiyou.wangcong@gmail.com>\nDate: Fri, 13 Oct 2017 11:58:53 -0700\nSubject: [PATCH] tun: call dev_get_valid_name() before register_netdevice()\n\nregister_netdevice() could fail early when we have an invalid\ndev name, in which case ->ndo_uninit() is not called. For tun\ndevice, this is a problem because a timer etc. are already\ninitialized and it expects ->ndo_uninit() to clean them up.\n\nWe could move these initializations into a ->ndo_init() so\nthat register_netdevice() knows better, however this is still\ncomplicated due to the logic in tun_detach().\n\nTherefore, I choose to just call dev_get_valid_name() before\nregister_netdevice(), which is quicker and much easier to audit.\nAnd for this specific case, it is already enough.\n\nFixes: 96442e42429e (\"tuntap: choose the txq based on rxq\")\nReported-by: Dmitry Alexeev <avekceeb@gmail.com>\nCc: Jason Wang <jasowang@redhat.com>\nCc: \"Michael S. Tsirkin\" <mst@redhat.com>\nSigned-off-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/tun.c         | 3 +++\n include\/linux\/netdevice.h | 3 +++\n net\/core\/dev.c            | 6 +++---\n 3 files changed, 9 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/tun.c b\/drivers\/net\/tun.c\nindex 5ce580f413b93..e21bf90b819f8 100644\n--- a\/drivers\/net\/tun.c\n+++ b\/drivers\/net\/tun.c\n@@ -2027,6 +2027,9 @@ static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n \n \t\tif (!dev)\n \t\t\treturn -ENOMEM;\n+\t\terr = dev_get_valid_name(net, dev, name);\n+\t\tif (err)\n+\t\t\tgoto err_free_dev;\n \n \t\tdev_net_set(dev, net);\n \t\tdev->rtnl_link_ops = &tun_link_ops;\ndiff --git a\/include\/linux\/netdevice.h b\/include\/linux\/netdevice.h\nindex f535779d9dc1d..2eaac7d75af4f 100644\n--- a\/include\/linux\/netdevice.h\n+++ b\/include\/linux\/netdevice.h\n@@ -3694,6 +3694,9 @@ struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,\n \t\t\t\t    unsigned char name_assign_type,\n \t\t\t\t    void (*setup)(struct net_device *),\n \t\t\t\t    unsigned int txqs, unsigned int rxqs);\n+int dev_get_valid_name(struct net *net, struct net_device *dev,\n+\t\t       const char *name);\n+\n #define alloc_netdev(sizeof_priv, name, name_assign_type, setup) \\\n \talloc_netdev_mqs(sizeof_priv, name, name_assign_type, setup, 1, 1)\n \ndiff --git a\/net\/core\/dev.c b\/net\/core\/dev.c\nindex 588b473194a8a..11596a302a265 100644\n--- a\/net\/core\/dev.c\n+++ b\/net\/core\/dev.c\n@@ -1147,9 +1147,8 @@ static int dev_alloc_name_ns(struct net *net,\n \treturn ret;\n }\n \n-static int dev_get_valid_name(struct net *net,\n-\t\t\t      struct net_device *dev,\n-\t\t\t      const char *name)\n+int dev_get_valid_name(struct net *net, struct net_device *dev,\n+\t\t       const char *name)\n {\n \tBUG_ON(!net);\n \n@@ -1165,6 +1164,7 @@ static int dev_get_valid_name(struct net *net,\n \n \treturn 0;\n }\n+EXPORT_SYMBOL(dev_get_valid_name);\n \n \/**\n  *\tdev_change_name - change name of a device\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-12615","CWE_ID":"476","category":"security","commit_id":"80caf43549e7e41a695c6d1e11066286538b336f","commit_message":"From 80caf43549e7e41a695c6d1e11066286538b336f Mon Sep 17 00:00:00 2001\nFrom: Gen Zhang <blackgod016574@gmail.com>\nDate: Fri, 31 May 2019 09:24:18 +0800\nSubject: mdesc: fix a missing-check bug in get_vdev_port_node_info()\n\nIn get_vdev_port_node_info(), 'node_info->vdev_port.name' is allcoated\nby kstrdup_const(), and it returns NULL when fails. So\n'node_info->vdev_port.name' should be checked.\n\nSigned-off-by: Gen Zhang <blackgod016574@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n arch\/sparc\/kernel\/mdesc.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/arch\/sparc\/kernel\/mdesc.c b\/arch\/sparc\/kernel\/mdesc.c\nindex 9a26b442f820..8e645ddac58e 100644\n--- a\/arch\/sparc\/kernel\/mdesc.c\n+++ b\/arch\/sparc\/kernel\/mdesc.c\n@@ -356,6 +356,8 @@ static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node,\n \n \tnode_info->vdev_port.id = *idp;\n \tnode_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL);\n+\tif (!node_info->vdev_port.name)\n+\t\treturn -1;\n \tnode_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp;\n \n \treturn 0;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-12984","CWE_ID":"476","category":"security","commit_id":"385097a3675749cbc9e97c085c0e5dfe4269ca51","commit_message":"From 385097a3675749cbc9e97c085c0e5dfe4269ca51 Mon Sep 17 00:00:00 2001\nFrom: Young Xiao <92siuyang@gmail.com>\nDate: Fri, 14 Jun 2019 15:13:02 +0800\nSubject: [PATCH] nfc: Ensure presence of required attributes in the\n deactivate_target handler\n\nCheck that the NFC_ATTR_TARGET_INDEX attributes (in addition to\nNFC_ATTR_DEVICE_INDEX) are provided by the netlink client prior to\naccessing them. This prevents potential unhandled NULL pointer dereference\nexceptions which can be triggered by malicious user-mode programs,\nif they omit one or both of these attributes.\n\nSigned-off-by: Young Xiao <92siuyang@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/nfc\/netlink.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/nfc\/netlink.c b\/net\/nfc\/netlink.c\nindex 1180b3e58a0ab..ea64c90b14e8c 100644\n--- a\/net\/nfc\/netlink.c\n+++ b\/net\/nfc\/netlink.c\n@@ -911,7 +911,8 @@ static int nfc_genl_deactivate_target(struct sk_buff *skb,\n \tu32 device_idx, target_idx;\n \tint rc;\n \n-\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n+\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n+\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n \t\treturn -EINVAL;\n \n \tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n","owner":"torvalds","repo":"linux","source":"cve"}]