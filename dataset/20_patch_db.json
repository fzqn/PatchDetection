[{"CVE_ID":"CVE-2010-2937","CWE_ID":"20","category":"security","commit_id":"24918843e57c7962e28fcb01845adce82bed6516","commit_message":"From 24918843e57c7962e28fcb01845adce82bed6516 Mon Sep 17 00:00:00 2001\nFrom: =?utf8?q?Luk=C3=A1=C5=A1=20Lalinsk=C3=BD?= <lalinsky@gmail.com>\nDate: Wed, 11 Aug 2010 22:02:30 +0300\nSubject: [PATCH] taglib: fix NULL deferences after dynamic cast\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nReported-by: FortiGuard Lab\nSigned-off-by: R\u00c3\u00a9mi Denis-Courmont <remi@remlab.net>\n(cherry picked from commit 0a3d05b4058fe683e2ef49da8ece9214ade01870)\n---\n modules\/meta_engine\/taglib.cpp | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/modules\/meta_engine\/taglib.cpp b\/modules\/meta_engine\/taglib.cpp\nindex 9ddb26e331..e92714807c 100644\n--- a\/modules\/meta_engine\/taglib.cpp\n+++ b\/modules\/meta_engine\/taglib.cpp\n@@ -131,6 +131,8 @@ static void ReadMetaFromId3v2( ID3v2::Tag* tag, demux_t* p_demux, demux_meta_t*\n     {\n         ID3v2::UniqueFileIdentifierFrame* p_ufid =\n                 dynamic_cast<ID3v2::UniqueFileIdentifierFrame*>(*iter);\n+        if( !p_ufid )\n+            continue;\n         const char *owner = p_ufid->owner().toCString();\n         if (!strcmp( owner, \"http:\/\/musicbrainz.org\" ))\n         {\n@@ -151,6 +153,8 @@ static void ReadMetaFromId3v2( ID3v2::Tag* tag, demux_t* p_demux, demux_meta_t*\n     {\n         ID3v2::UserTextIdentificationFrame* p_txxx =\n                 dynamic_cast<ID3v2::UserTextIdentificationFrame*>(*iter);\n+        if( !p_txxx )\n+            continue;\n         vlc_meta_AddExtra( p_meta, p_txxx->description().toCString( true ),\n                            p_txxx->fieldList().toString().toCString( true ) );\n     }\n@@ -207,6 +211,8 @@ static void ReadMetaFromId3v2( ID3v2::Tag* tag, demux_t* p_demux, demux_meta_t*\n     {\n         ID3v2::AttachedPictureFrame* p_apic =\n             dynamic_cast<ID3v2::AttachedPictureFrame*>(*iter);\n+        if( !p_apic )\n+            continue;\n         input_attachment_t *p_attachment;\n \n         const char *psz_mime;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-13135","CWE_ID":"20","category":"security","commit_id":"1e59b29e520d2beab73e8c78aacd5f1c0d76196d","commit_message":"From 1e59b29e520d2beab73e8c78aacd5f1c0d76196d Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 18 Jun 2019 11:45:11 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1599\n\n---\n coders\/cut.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/coders\/cut.c b\/coders\/cut.c\nindex 2ef35f4c4..070136f22 100644\n--- a\/coders\/cut.c\n+++ b\/coders\/cut.c\n@@ -568,6 +568,7 @@ static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n     sizeof(*BImgBuff));  \/*Ldblk was set in the check phase*\/\n   if(BImgBuff==NULL) goto NoMemory;\n+  (void) memset(BImgBuff,0,(size_t) ldblk*sizeof(*BImgBuff));\n \n   offset=SeekBlob(image,6 \/*sizeof(Header)*\/,SEEK_SET);\n   if (offset < 0)\n","owner":"ImageMagick","repo":"ImageMagick6","source":"cve"},{"CVE_ID":"CVE-2019-7443","CWE_ID":"20","category":"security","commit_id":"fc70fb0161c1b9144d26389434d34dd135cd3f4a","commit_message":"From fc70fb0161c1b9144d26389434d34dd135cd3f4a Mon Sep 17 00:00:00 2001\nFrom: Albert Astals Cid <aacid@kde.org>\nDate: Sat, 2 Feb 2019 14:35:25 +0100\nSubject: Remove support for passing gui QVariants to KAuth helpers\n\nSupporting gui variants is very dangerous since they can end up triggering\nimage loading plugins which are one of the biggest vectors for crashes, which\nfor very smart people mean possible code execution, which is very dangerous\nin code that is executed as root.\n\nWe've checked all the KAuth helpers inside KDE git and none seems to be using\ngui variants, so we're not actually limiting anything that people wanted to do.\n\nReviewed by security@kde.org and Aleix Pol\n\nIssue reported by Fabian Vogt\n---\n src\/backends\/dbus\/DBusHelperProxy.cpp | 9 +++++++++\n src\/kauthaction.h                     | 2 ++\n 2 files changed, 11 insertions(+)\n\n","diff_code":"diff --git a\/src\/backends\/dbus\/DBusHelperProxy.cpp b\/src\/backends\/dbus\/DBusHelperProxy.cpp\nindex 10c14c6..8f0d336 100644\n--- a\/src\/backends\/dbus\/DBusHelperProxy.cpp\n+++ b\/src\/backends\/dbus\/DBusHelperProxy.cpp\n@@ -31,6 +31,8 @@\n #include \"kf5authadaptor.h\"\n #include \"kauthdebug.h\"\n \n+extern Q_CORE_EXPORT const QMetaTypeInterface *qMetaTypeGuiHelper;\n+\n namespace KAuth\n {\n \n@@ -229,10 +231,17 @@ QByteArray DBusHelperProxy::performAction(const QString &action, const QByteArra\n         return ActionReply::HelperBusyReply().serialized();\n     }\n \n+    \/\/ Make sure we don't try restoring gui variants, in particular QImage\/QPixmap\/QIcon are super dangerous\n+    \/\/ since they end up calling the image loaders and thus are a vector for crashing \u2192 executing code\n+    auto origMetaTypeGuiHelper = qMetaTypeGuiHelper;\n+    qMetaTypeGuiHelper = nullptr;\n+\n     QVariantMap args;\n     QDataStream s(&arguments, QIODevice::ReadOnly);\n     s >> args;\n \n+    qMetaTypeGuiHelper = origMetaTypeGuiHelper;\n+\n     m_currentAction = action;\n     emit remoteSignal(ActionStarted, action, QByteArray());\n     QEventLoop e;\ndiff --git a\/src\/kauthaction.h b\/src\/kauthaction.h\nindex c67a70a..01f3ba1 100644\n--- a\/src\/kauthaction.h\n+++ b\/src\/kauthaction.h\n@@ -298,6 +298,8 @@ public:\n      * This method sets the variant map that the application\n      * can use to pass arbitrary data to the helper when executing the action.\n      *\n+     * Only non-gui variants are supported.\n+     *\n      * @param arguments The new arguments map\n      *\/\n     void setArguments(const QVariantMap &arguments);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9142","CWE_ID":"20","category":"security","commit_id":"72f5c8632bff2daf3c95005f9b4cf2982786b52a","commit_message":"From 72f5c8632bff2daf3c95005f9b4cf2982786b52a Mon Sep 17 00:00:00 2001\nFrom: Dirk Lemstra <dirk@git.imagemagick.org>\nDate: Mon, 15 May 2017 21:17:59 +0200\nSubject: [PATCH] Fixed incorrect call to WriteBlob reported in #490.\n\n---\n coders\/png.c | 7 ++++---\n 1 file changed, 4 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/coders\/png.c b\/coders\/png.c\nindex c7b9fcbd83..5f6f409096 100644\n--- a\/coders\/png.c\n+++ b\/coders\/png.c\n@@ -4477,10 +4477,11 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Copying JDAT chunk data to color_blob.\");\n \n-        (void) WriteBlob(color_image,length,chunk);\n-\n         if (length != 0)\n-          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n+          {\n+            (void) WriteBlob(color_image,length,chunk);\n+            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n+          }\n \n         continue;\n       }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2014-9907","CWE_ID":"20","category":"security","commit_id":"21eae25a8db5fdcd112dbcfcd9e5c37e32d32e2f","commit_message":"From 21eae25a8db5fdcd112dbcfcd9e5c37e32d32e2f Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Mon, 29 Dec 2014 22:23:41 +0000\nSubject: [PATCH] Moved EOF check.\n\n---\n coders\/dds.c | 24 ++++++++++++------------\n 1 file changed, 12 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/coders\/dds.c b\/coders\/dds.c\nindex c5016b2d0e..2145736427 100644\n--- a\/coders\/dds.c\n+++ b\/coders\/dds.c\n@@ -2369,16 +2369,16 @@ static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n   \/*\n     Only skip mipmaps for textures and cube maps\n   *\/\n+  if (EOFBlob(image) != MagickFalse)\n+    {\n+      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n+        image->filename);\n+      return(MagickFalse);\n+    }\n   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n     {\n-      if (EOFBlob(image) != MagickFalse)\n-        {\n-          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n-            image->filename);\n-          return(MagickFalse);\n-        }\n       w = DIV2(dds_info->width);\n       h = DIV2(dds_info->height);\n \n@@ -2416,16 +2416,16 @@ static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n   \/*\n     Only skip mipmaps for textures and cube maps\n   *\/\n+  if (EOFBlob(image) != MagickFalse)\n+    {\n+      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n+        image->filename);\n+      return(MagickFalse);\n+    }\n   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n     {\n-      if (EOFBlob(image) != MagickFalse)\n-        {\n-          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n-            image->filename);\n-          return(MagickFalse);\n-        }\n       w = DIV2(dds_info->width);\n       h = DIV2(dds_info->height);\n \n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2011-2518","CWE_ID":"20","category":"security","commit_id":"4e78c724d47e2342aa8fde61f6b8536f662f795f","commit_message":"From 4e78c724d47e2342aa8fde61f6b8536f662f795f Mon Sep 17 00:00:00 2001\nFrom: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nDate: Mon, 13 Jun 2011 13:49:11 +0900\nSubject: [PATCH] TOMOYO: Fix oops in tomoyo_mount_acl().\n\nIn tomoyo_mount_acl() since 2.6.36, kern_path() was called without checking\ndev_name != NULL. As a result, an unprivileged user can trigger oops by issuing\nmount(NULL, \"\/\", \"ext3\", 0, NULL) request.\nFix this by checking dev_name != NULL before calling kern_path(dev_name).\n\nSigned-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCc: stable@kernel.org\nSigned-off-by: James Morris <jmorris@namei.org>\n---\n security\/tomoyo\/mount.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/security\/tomoyo\/mount.c b\/security\/tomoyo\/mount.c\nindex 162a864dba24f..9fc2e15841c96 100644\n--- a\/security\/tomoyo\/mount.c\n+++ b\/security\/tomoyo\/mount.c\n@@ -138,7 +138,7 @@ static int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,\n \t}\n \tif (need_dev) {\n \t\t\/* Get mount point or device file. *\/\n-\t\tif (kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n+\t\tif (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {\n \t\t\terror = -ENOENT;\n \t\t\tgoto out;\n \t\t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-12184","CWE_ID":"20","category":"security","commit_id":"cad5a1050b7184d828aef9c1dd151c3ab649d37e","commit_message":"From cad5a1050b7184d828aef9c1dd151c3ab649d37e Mon Sep 17 00:00:00 2001\nFrom: Nathan Kidd <nkidd@opentext.com>\nDate: Fri, 9 Jan 2015 09:57:23 -0500\nSubject: Unvalidated lengths\n\nv2: Add overflow check and remove unnecessary check (Julien Cristau)\n\nThis addresses:\nCVE-2017-12184 in XINERAMA\nCVE-2017-12185 in MIT-SCREEN-SAVER\nCVE-2017-12186 in X-Resource\nCVE-2017-12187 in RENDER\n\nReviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Nathan Kidd <nkidd@opentext.com>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n Xext\/panoramiX.c          | 3 ++-\n Xext\/saver.c              | 2 ++\n Xext\/xres.c               | 4 +++-\n Xext\/xvdisp.c             | 4 +++-\n hw\/dmx\/dmxpict.c          | 2 ++\n pseudoramiX\/pseudoramiX.c | 3 ++-\n render\/render.c           | 3 +++\n 7 files changed, 17 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/Xext\/panoramiX.c b\/Xext\/panoramiX.c\nindex 209df29..844ea49 100644\n--- a\/Xext\/panoramiX.c\n+++ b\/Xext\/panoramiX.c\n@@ -988,10 +988,11 @@ ProcPanoramiXGetScreenSize(ClientPtr client)\n     xPanoramiXGetScreenSizeReply rep;\n     int rc;\n \n+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n+\n     if (stuff->screen >= PanoramiXNumScreens)\n         return BadMatch;\n \n-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n     rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n     if (rc != Success)\n         return rc;\ndiff --git a\/Xext\/saver.c b\/Xext\/saver.c\nindex 0949761..f6090d8 100644\n--- a\/Xext\/saver.c\n+++ b\/Xext\/saver.c\n@@ -1186,6 +1186,8 @@ ProcScreenSaverUnsetAttributes(ClientPtr client)\n         PanoramiXRes *draw;\n         int rc, i;\n \n+        REQUEST_SIZE_MATCH(xScreenSaverUnsetAttributesReq);\n+\n         rc = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n         if (rc != Success)\ndiff --git a\/Xext\/xres.c b\/Xext\/xres.c\nindex 21239f5..0242158 100644\n--- a\/Xext\/xres.c\n+++ b\/Xext\/xres.c\n@@ -947,6 +947,8 @@ ProcXResQueryResourceBytes (ClientPtr client)\n     ConstructResourceBytesCtx    ctx;\n \n     REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);\n+    if (stuff->numSpecs > UINT32_MAX \/ sizeof(ctx.specs[0]))\n+        return BadLength;\n     REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,\n                        stuff->numSpecs * sizeof(ctx.specs[0]));\n \n@@ -1052,8 +1054,8 @@ SProcXResQueryResourceBytes (ClientPtr client)\n     int c;\n     xXResResourceIdSpec *specs = (void*) ((char*) stuff + sizeof(*stuff));\n \n-    swapl(&stuff->numSpecs);\n     REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);\n+    swapl(&stuff->numSpecs);\n     REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,\n                        stuff->numSpecs * sizeof(specs[0]));\n \ndiff --git a\/Xext\/xvdisp.c b\/Xext\/xvdisp.c\nindex d99d3d4..5232b37 100644\n--- a\/Xext\/xvdisp.c\n+++ b\/Xext\/xvdisp.c\n@@ -1493,12 +1493,14 @@ XineramaXvShmPutImage(ClientPtr client)\n {\n     REQUEST(xvShmPutImageReq);\n     PanoramiXRes *draw, *gc, *port;\n-    Bool send_event = stuff->send_event;\n+    Bool send_event;\n     Bool isRoot;\n     int result, i, x, y;\n \n     REQUEST_SIZE_MATCH(xvShmPutImageReq);\n \n+    send_event = stuff->send_event;\n+\n     result = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n     if (result != Success)\ndiff --git a\/hw\/dmx\/dmxpict.c b\/hw\/dmx\/dmxpict.c\nindex 1f1022e..63caec9 100644\n--- a\/hw\/dmx\/dmxpict.c\n+++ b\/hw\/dmx\/dmxpict.c\n@@ -716,6 +716,8 @@ dmxProcRenderSetPictureFilter(ClientPtr client)\n         filter = (char *) (stuff + 1);\n         params = (XFixed *) (filter + ((stuff->nbytes + 3) & ~3));\n         nparams = ((XFixed *) stuff + client->req_len) - params;\n+        if (nparams < 0)\n+            return BadLength;\n \n         XRenderSetPictureFilter(dmxScreen->beDisplay,\n                                 pPictPriv->pict, filter, params, nparams);\ndiff --git a\/pseudoramiX\/pseudoramiX.c b\/pseudoramiX\/pseudoramiX.c\nindex d8b2593..95f6e10 100644\n--- a\/pseudoramiX\/pseudoramiX.c\n+++ b\/pseudoramiX\/pseudoramiX.c\n@@ -297,10 +297,11 @@ ProcPseudoramiXGetScreenSize(ClientPtr client)\n \n     TRACE;\n \n+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n+\n     if (stuff->screen >= pseudoramiXNumScreens)\n       return BadMatch;\n \n-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n     rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n     if (rc != Success)\n         return rc;\ndiff --git a\/render\/render.c b\/render\/render.c\nindex ccae49a..7d94bd5 100644\n--- a\/render\/render.c\n+++ b\/render\/render.c\n@@ -1757,6 +1757,9 @@ ProcRenderSetPictureFilter(ClientPtr client)\n     name = (char *) (stuff + 1);\n     params = (xFixed *) (name + pad_to_int32(stuff->nbytes));\n     nparams = ((xFixed *) stuff + client->req_len) - params;\n+    if (nparams < 0)\n+\treturn BadLength;\n+\n     result = SetPictureFilter(pPicture, name, stuff->nbytes, params, nparams);\n     return result;\n }\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-18235","CWE_ID":"20","category":"security","commit_id":"9e76a7782a54a242f18d609e7ba32bf1c430a5e4","commit_message":"From 9e76a7782a54a242f18d609e7ba32bf1c430a5e4 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Hubert=20Figui=C3=A8re?= <hub@figuiere.net>\nDate: Wed, 2 Aug 2017 23:16:10 -0400\nSubject: Bug 101913 - Prevent an assert from being reached with a corrupt file\n\n- In VPXChunk::width() and VPXChunk::height() ensure val isn't 0.\n---\n XMPFiles\/source\/FormatSupport\/WEBP_Support.cpp | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/XMPFiles\/source\/FormatSupport\/WEBP_Support.cpp b\/XMPFiles\/source\/FormatSupport\/WEBP_Support.cpp\nindex 2b007de..a211697 100644\n--- a\/XMPFiles\/source\/FormatSupport\/WEBP_Support.cpp\n+++ b\/XMPFiles\/source\/FormatSupport\/WEBP_Support.cpp\n@@ -141,7 +141,7 @@ XMP_Uns32 VP8XChunk::width()\n }\n void VP8XChunk::width(XMP_Uns32 val)\n {\n-    PutLE24(&this->data[4], val - 1);\n+    PutLE24(&this->data[4], val > 0 ? val - 1 : 0);\n }\n XMP_Uns32 VP8XChunk::height()\n {\n@@ -149,7 +149,7 @@ XMP_Uns32 VP8XChunk::height()\n }\n void VP8XChunk::height(XMP_Uns32 val)\n {\n-    PutLE24(&this->data[7], val - 1);\n+    PutLE24(&this->data[7], val > 0 ? val - 1 : 0);\n }\n bool VP8XChunk::xmp()\n {\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-0101","CWE_ID":"20","category":"security","commit_id":"ec0223ec48a90cb605244b45f7c62de856403729","commit_message":"From ec0223ec48a90cb605244b45f7c62de856403729 Mon Sep 17 00:00:00 2001\nFrom: Daniel Borkmann <dborkman@redhat.com>\nDate: Mon, 3 Mar 2014 17:23:04 +0100\nSubject: [PATCH] net: sctp: fix sctp_sf_do_5_1D_ce to verify if we\/peer is\n AUTH capable\n\nRFC4895 introduced AUTH chunks for SCTP; during the SCTP\nhandshake RANDOM; CHUNKS; HMAC-ALGO are negotiated (CHUNKS\nbeing optional though):\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  -------------------- COOKIE-ECHO -------------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nA special case is when an endpoint requires COOKIE-ECHO\nchunks to be authenticated:\n\n  ---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n  <------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n  ------------------ AUTH; COOKIE-ECHO ---------------->\n  <-------------------- COOKIE-ACK ---------------------\n\nRFC4895, section 6.3. Receiving Authenticated Chunks says:\n\n  The receiver MUST use the HMAC algorithm indicated in\n  the HMAC Identifier field. If this algorithm was not\n  specified by the receiver in the HMAC-ALGO parameter in\n  the INIT or INIT-ACK chunk during association setup, the\n  AUTH chunk and all the chunks after it MUST be discarded\n  and an ERROR chunk SHOULD be sent with the error cause\n  defined in Section 4.1. [...] If no endpoint pair shared\n  key has been configured for that Shared Key Identifier,\n  all authenticated chunks MUST be silently discarded. [...]\n\n  When an endpoint requires COOKIE-ECHO chunks to be\n  authenticated, some special procedures have to be followed\n  because the reception of a COOKIE-ECHO chunk might result\n  in the creation of an SCTP association. If a packet arrives\n  containing an AUTH chunk as a first chunk, a COOKIE-ECHO\n  chunk as the second chunk, and possibly more chunks after\n  them, and the receiver does not have an STCB for that\n  packet, then authentication is based on the contents of\n  the COOKIE-ECHO chunk. In this situation, the receiver MUST\n  authenticate the chunks in the packet by using the RANDOM\n  parameters, CHUNKS parameters and HMAC_ALGO parameters\n  obtained from the COOKIE-ECHO chunk, and possibly a local\n  shared secret as inputs to the authentication procedure\n  specified in Section 6.3. If authentication fails, then\n  the packet is discarded. If the authentication is successful,\n  the COOKIE-ECHO and all the chunks after the COOKIE-ECHO\n  MUST be processed. If the receiver has an STCB, it MUST\n  process the AUTH chunk as described above using the STCB\n  from the existing association to authenticate the\n  COOKIE-ECHO chunk and all the chunks after it. [...]\n\nCommit bbd0d59809f9 introduced the possibility to receive\nand verification of AUTH chunk, including the edge case for\nauthenticated COOKIE-ECHO. On reception of COOKIE-ECHO,\nthe function sctp_sf_do_5_1D_ce() handles processing,\nunpacks and creates a new association if it passed sanity\nchecks and also tests for authentication chunks being\npresent. After a new association has been processed, it\ninvokes sctp_process_init() on the new association and\nwalks through the parameter list it received from the INIT\nchunk. It checks SCTP_PARAM_RANDOM, SCTP_PARAM_HMAC_ALGO\nand SCTP_PARAM_CHUNKS, and copies them into asoc->peer\nmeta data (peer_random, peer_hmacs, peer_chunks) in case\nsysctl -w net.sctp.auth_enable=1 is set. If in INIT's\nSCTP_PARAM_SUPPORTED_EXT parameter SCTP_CID_AUTH is set,\npeer_random != NULL and peer_hmacs != NULL the peer is to be\nassumed asoc->peer.auth_capable=1, in any other case\nasoc->peer.auth_capable=0.\n\nNow, if in sctp_sf_do_5_1D_ce() chunk->auth_chunk is\navailable, we set up a fake auth chunk and pass that on to\nsctp_sf_authenticate(), which at latest in\nsctp_auth_calculate_hmac() reliably dereferences a NULL pointer\nat position 0..0008 when setting up the crypto key in\ncrypto_hash_setkey() by using asoc->asoc_shared_key that is\nNULL as condition key_id == asoc->active_key_id is true if\nthe AUTH chunk was injected correctly from remote. This\nhappens no matter what net.sctp.auth_enable sysctl says.\n\nThe fix is to check for net->sctp.auth_enable and for\nasoc->peer.auth_capable before doing any operations like\nsctp_sf_authenticate() as no key is activated in\nsctp_auth_asoc_init_active_key() for each case.\n\nNow as RFC4895 section 6.3 states that if the used HMAC-ALGO\npassed from the INIT chunk was not used in the AUTH chunk, we\nSHOULD send an error; however in this case it would be better\nto just silently discard such a maliciously prepared handshake\nas we didn't even receive a parameter at all. Also, as our\nendpoint has no shared key configured, section 6.3 says that\nMUST silently discard, which we are doing from now onwards.\n\nBefore calling sctp_sf_pdiscard(), we need not only to free\nthe association, but also the chunk->auth_chunk skb, as\ncommit bbd0d59809f9 created a skb clone in that case.\n\nI have tested this locally by using netfilter's nfqueue and\nre-injecting packets into the local stack after maliciously\nmodifying the INIT chunk (removing RANDOM; HMAC-ALGO param)\nand the SCTP packet containing the COOKIE_ECHO (injecting\nAUTH chunk before COOKIE_ECHO). Fixed with this patch applied.\n\nFixes: bbd0d59809f9 (\"[SCTP]: Implement the receive and verification of AUTH chunk\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nCc: Vlad Yasevich <yasevich@gmail.com>\nCc: Neil Horman <nhorman@tuxdriver.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/sctp\/sm_statefuns.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/net\/sctp\/sm_statefuns.c b\/net\/sctp\/sm_statefuns.c\nindex 591b44d3b7de6..ae65b6b5973a9 100644\n--- a\/net\/sctp\/sm_statefuns.c\n+++ b\/net\/sctp\/sm_statefuns.c\n@@ -758,6 +758,13 @@ sctp_disposition_t sctp_sf_do_5_1D_ce(struct net *net,\n \t\tstruct sctp_chunk auth;\n \t\tsctp_ierror_t ret;\n \n+\t\t\/* Make sure that we and the peer are AUTH capable *\/\n+\t\tif (!net->sctp.auth_enable || !new_asoc->peer.auth_capable) {\n+\t\t\tkfree_skb(chunk->auth_chunk);\n+\t\t\tsctp_association_free(new_asoc);\n+\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n+\t\t}\n+\n \t\t\/* set-up our fake chunk so that we can process it *\/\n \t\tauth.skb = chunk->auth_chunk;\n \t\tauth.asoc = chunk->asoc;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-5296","CWE_ID":"20","category":"security","commit_id":"a819d2b440aafa3138d95ff6e8b824da885a70e9","commit_message":"From a819d2b440aafa3138d95ff6e8b824da885a70e9 Mon Sep 17 00:00:00 2001\nFrom: Stefan Metzmacher <metze@samba.org>\nDate: Wed, 30 Sep 2015 21:23:25 +0200\nSubject: [PATCH] CVE-2015-5296: libcli\/smb: make sure we require signing when\n we demand encryption on a session\n\nBUG: https:\/\/bugzilla.samba.org\/show_bug.cgi?id=11536\n\nSigned-off-by: Stefan Metzmacher <metze@samba.org>\nReviewed-by: Jeremy Allison <jra@samba.org>\n---\n libcli\/smb\/smbXcli_base.c | 11 +++++++++++\n 1 file changed, 11 insertions(+)\n\n","diff_code":"diff --git a\/libcli\/smb\/smbXcli_base.c b\/libcli\/smb\/smbXcli_base.c\nindex 6fe4816c3b5..505d40dd4f5 100644\n--- a\/libcli\/smb\/smbXcli_base.c\n+++ b\/libcli\/smb\/smbXcli_base.c\n@@ -5446,6 +5446,9 @@ uint8_t smb2cli_session_security_mode(struct smbXcli_session *session)\n \tif (conn->mandatory_signing) {\n \t\tsecurity_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n \t}\n+\tif (session->smb2->should_sign) {\n+\t\tsecurity_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n+\t}\n \n \treturn security_mode;\n }\n@@ -5877,6 +5880,14 @@ NTSTATUS smb2cli_session_set_channel_key(struct smbXcli_session *session,\n \n NTSTATUS smb2cli_session_encryption_on(struct smbXcli_session *session)\n {\n+\tif (!session->smb2->should_sign) {\n+\t\t\/*\n+\t\t * We need required signing on the session\n+\t\t * in order to prevent man in the middle attacks.\n+\t\t *\/\n+\t\treturn NT_STATUS_INVALID_PARAMETER_MIX;\n+\t}\n+\n \tif (session->smb2->should_encrypt) {\n \t\treturn NT_STATUS_OK;\n \t}\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-20217","CWE_ID":"20","category":"security","commit_id":"5e6d1796106df8ba6bc1973ee0917c170d929086","commit_message":"From 5e6d1796106df8ba6bc1973ee0917c170d929086 Mon Sep 17 00:00:00 2001\nFrom: Isaac Boukris <iboukris@gmail.com>\nDate: Mon, 3 Dec 2018 02:33:07 +0200\nSubject: [PATCH] Ignore password attributes for S4U2Self requests\n\nFor consistency with Windows KDCs, allow protocol transition to work\neven if the password has expired or needs changing.\n\nAlso, when looking up an enterprise principal with an AS request,\ntreat ERR_KEY_EXP as confirmation that the client is present in the\nrealm.\n\n[ghudson@mit.edu: added comment in kdc_process_s4u2self_req(); edited\ncommit message]\n\nticket: 8763 (new)\ntags: pullup\ntarget_version: 1.17\n---\n src\/kdc\/kdc_util.c           | 5 +++++\n src\/lib\/krb5\/krb\/s4u_creds.c | 2 +-\n src\/tests\/gssapi\/t_s4u.py    | 8 ++++++++\n 3 files changed, 14 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/kdc\/kdc_util.c b\/src\/kdc\/kdc_util.c\nindex 6d53173fb0..6517a213cd 100644\n--- a\/src\/kdc\/kdc_util.c\n+++ b\/src\/kdc\/kdc_util.c\n@@ -1607,6 +1607,11 @@ kdc_process_s4u2self_req(kdc_realm_t *kdc_active_realm,\n \n         memset(&no_server, 0, sizeof(no_server));\n \n+        \/* Ignore password expiration and needchange attributes (as Windows\n+         * does), since S4U2Self is not password authentication. *\/\n+        princ->pw_expiration = 0;\n+        clear(princ->attributes, KRB5_KDB_REQUIRES_PWCHANGE);\n+\n         code = validate_as_request(kdc_active_realm, request, *princ,\n                                    no_server, kdc_time, status, &e_data);\n         if (code) {\ndiff --git a\/src\/lib\/krb5\/krb\/s4u_creds.c b\/src\/lib\/krb5\/krb\/s4u_creds.c\nindex d2fdcb3f16..614ed41908 100644\n--- a\/src\/lib\/krb5\/krb\/s4u_creds.c\n+++ b\/src\/lib\/krb5\/krb\/s4u_creds.c\n@@ -116,7 +116,7 @@ s4u_identify_user(krb5_context context,\n     code = k5_get_init_creds(context, &creds, &client, NULL, NULL, 0, NULL,\n                              opts, krb5_get_as_key_noop, &userid, &use_master,\n                              NULL);\n-    if (code == 0 || code == KRB5_PREAUTH_FAILED) {\n+    if (!code || code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP) {\n         *canon_user = userid.user;\n         userid.user = NULL;\n         code = 0;\ndiff --git a\/src\/tests\/gssapi\/t_s4u.py b\/src\/tests\/gssapi\/t_s4u.py\nindex fd29e1a270..84f3fbd752 100755\n--- a\/src\/tests\/gssapi\/t_s4u.py\n+++ b\/src\/tests\/gssapi\/t_s4u.py\n@@ -19,6 +19,14 @@\n # Get forwardable creds for service1 in the default cache.\n realm.kinit(service1, None, ['-f', '-k'])\n \n+# Try S4U2Self for user with a restricted password.\n+realm.run([kadminl, 'modprinc', '+needchange', realm.user_princ])\n+realm.run(['.\/t_s4u', 'e:user', '-'])\n+realm.run([kadminl, 'modprinc', '-needchange',\n+          '-pwexpire', '1\/1\/2000', realm.user_princ])\n+realm.run(['.\/t_s4u', 'e:user', '-'])\n+realm.run([kadminl, 'modprinc', '-pwexpire', 'never', realm.user_princ])\n+\n # Try krb5 -> S4U2Proxy with forwardable user creds.  This should fail\n # at the S4U2Proxy step since the DB2 back end currently has no\n # support for allowing it.\n","owner":"krb5","repo":"krb5","source":"cve"},{"CVE_ID":"CVE-2016-6128","CWE_ID":"20","category":"security","commit_id":"6ff72ae40c7c20ece939afb362d98cc37f4a1c96","commit_message":"From 6ff72ae40c7c20ece939afb362d98cc37f4a1c96 Mon Sep 17 00:00:00 2001\nFrom: Pierre Joye <pierre.php@gmail.com>\nDate: Mon, 27 Jun 2016 11:25:40 +0700\nSubject: [PATCH] fix php 72494, invalid color index not handled, can lead to\n crash\n\n---\n tests\/gdimagecrop\/php_bug_72494.c | 23 +++++++++++++++++++++++\n 1 file changed, 23 insertions(+)\n create mode 100644 tests\/gdimagecrop\/php_bug_72494.c\n\n","diff_code":"diff --git a\/tests\/gdimagecrop\/php_bug_72494.c b\/tests\/gdimagecrop\/php_bug_72494.c\nnew file mode 100644\nindex 00000000..adaa379f\n--- \/dev\/null\n+++ b\/tests\/gdimagecrop\/php_bug_72494.c\n@@ -0,0 +1,23 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include \"gd.h\"\n+\n+#include \"gdtest.h\"\n+\n+int main()\n+{\n+\tgdImagePtr im, exp;\n+\tint error = 0;\n+\n+\tim = gdImageCreate(50, 50);\n+\n+\tif (!im) {\n+\t\tgdTestErrorMsg(\"gdImageCreate failed.\\n\");\n+\t\treturn 1;\n+\t}\n+\n+\tgdImageCropThreshold(im, 1337, 0);\n+\tgdImageDestroy(im);\n+\t\/* this bug tests a crash, it never reaches this point if the bug exists*\/\n+\treturn 0;\n+}\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2018-16644","CWE_ID":"20","category":"security","commit_id":"16916c8979c32765c542e216b31cee2671b7afe7","commit_message":"From 16916c8979c32765c542e216b31cee2671b7afe7 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 27 Aug 2018 19:29:51 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1269\n\n---\n coders\/dcm.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/coders\/dcm.c b\/coders\/dcm.c\nindex d44cf80d0a..49a058a2d4 100644\n--- a\/coders\/dcm.c\n+++ b\/coders\/dcm.c\n@@ -3853,6 +3853,8 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           tag=((unsigned int) ReadBlobLSBShort(image) << 16) |\n             ReadBlobLSBShort(image);\n           length=(size_t) ReadBlobLSBLong(image);\n+          if (length > (size_t) GetBlobSize(image))\n+            ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n           if (tag == 0xFFFEE0DD)\n             break; \/* sequence delimiter tag *\/\n           if (tag != 0xFFFEE000)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2014-3567","CWE_ID":"20","category":"security","commit_id":"7fd4ce6a997be5f5c9e744ac527725c2850de203","commit_message":"From 7fd4ce6a997be5f5c9e744ac527725c2850de203 Mon Sep 17 00:00:00 2001\nFrom: \"Dr. Stephen Henson\" <steve@openssl.org>\nDate: Wed, 15 Oct 2014 01:53:55 +0100\nSubject: [PATCH] Fix for session tickets memory leak.\n\nCVE-2014-3567\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(cherry picked from commit 5dc6070a03779cd524f0e67f76c945cb0ac38320)\n---\n ssl\/t1_lib.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/ssl\/t1_lib.c b\/ssl\/t1_lib.c\nindex 12ee3c9a10..d6aff4b682 100644\n--- a\/ssl\/t1_lib.c\n+++ b\/ssl\/t1_lib.c\n@@ -2348,7 +2348,10 @@ static int tls_decrypt_ticket(SSL *s, const unsigned char *etick, int eticklen,\n \tHMAC_Final(&hctx, tick_hmac, NULL);\n \tHMAC_CTX_cleanup(&hctx);\n \tif (CRYPTO_memcmp(tick_hmac, etick + eticklen, mlen))\n+\t\t{\n+\t\tEVP_CIPHER_CTX_cleanup(&ctx);\n \t\treturn 2;\n+\t\t}\n \t\/* Attempt to decrypt session data *\/\n \t\/* Move p after IV to start of encrypted ticket, update length *\/\n \tp = etick + 16 + EVP_CIPHER_CTX_iv_length(&ctx);\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9351","CWE_ID":"20","category":"security","commit_id":"a766cb44bcffcdb0b88e776d01c5ee1323d44f85","commit_message":"From a766cb44bcffcdb0b88e776d01c5ee1323d44f85 Mon Sep 17 00:00:00 2001\nFrom: oy <Tom_Adams@web.de>\nDate: Thu, 20 Nov 2014 18:13:54 +0100\nSubject: [PATCH] fixed a server crash\n\n---\n src\/engine\/server\/server.cpp | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/engine\/server\/server.cpp b\/src\/engine\/server\/server.cpp\nindex 581c7e6736..ab0f312250 100644\n--- a\/src\/engine\/server\/server.cpp\n+++ b\/src\/engine\/server\/server.cpp\n@@ -845,8 +845,8 @@ void CServer::ProcessClientPacket(CNetChunk *pPacket)\n \t\t\t\treturn;\n \n \t\t\tint Chunk = Unpacker.GetInt();\n-\t\t\tint ChunkSize = 1024-128;\n-\t\t\tint Offset = Chunk * ChunkSize;\n+\t\t\tunsigned int ChunkSize = 1024-128;\n+\t\t\tunsigned int Offset = Chunk * ChunkSize;\n \t\t\tint Last = 0;\n \n \t\t\t\/\/ drop faulty map data requests\n","owner":"teeworlds","repo":"teeworlds","source":"cve"},{"CVE_ID":"CVE-2014-8544","CWE_ID":"20","category":"security","commit_id":"e1c0cfaa419aa5d320540d5a1b3f8fd9b82ab7e5","commit_message":"From e1c0cfaa419aa5d320540d5a1b3f8fd9b82ab7e5 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 3 Oct 2014 16:08:32 +0200\nSubject: [PATCH] avcodec\/tiff: more completely check bpp\/bppcount\n\nFixes pixel format selection\nFixes out of array accesses\nFixes: asan_heap-oob_1766029_6_asan_heap-oob_20aa045_332_cov_1823216757_m2-d1d366d7965db766c19a66c7a2ccbb6b.tif\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/tiff.c | 13 ++++++++++---\n 1 file changed, 10 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/tiff.c b\/libavcodec\/tiff.c\nindex 6e2096fd69..0870e31817 100644\n--- a\/libavcodec\/tiff.c\n+++ b\/libavcodec\/tiff.c\n@@ -814,13 +814,13 @@ static int tiff_decode_tag(TiffContext *s, AVFrame *frame)\n         s->height = value;\n         break;\n     case TIFF_BPP:\n-        s->bppcount = count;\n-        if (count > 4) {\n+        if (count > 4U) {\n             av_log(s->avctx, AV_LOG_ERROR,\n                    \"This format is not supported (bpp=%d, %d components)\\n\",\n-                   s->bpp, count);\n+                   value, count);\n             return AVERROR_INVALIDDATA;\n         }\n+        s->bppcount = count;\n         if (count == 1)\n             s->bpp = value;\n         else {\n@@ -838,6 +838,13 @@ static int tiff_decode_tag(TiffContext *s, AVFrame *frame)\n                 s->bpp = -1;\n             }\n         }\n+        if (s->bpp > 64U) {\n+            av_log(s->avctx, AV_LOG_ERROR,\n+                   \"This format is not supported (bpp=%d, %d components)\\n\",\n+                   s->bpp, count);\n+            s->bpp = 0;\n+            return AVERROR_INVALIDDATA;\n+        }\n         break;\n     case TIFF_SAMPLES_PER_PIXEL:\n         if (count != 1) {\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-4537","CWE_ID":"20","category":"security","commit_id":"d650063a0457aec56364e4005a636dc6c401f9cd","commit_message":"From d650063a0457aec56364e4005a636dc6c401f9cd Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 24 Apr 2016 18:33:32 -0700\nSubject: [PATCH] Fix bug #72093: bcpowmod accepts negative scale and corrupts\n _one_ definition\n\nWe can not modify result since it can be copy of _zero_ or _one_, etc. and\n\"copy\" in bcmath is just bumping the refcount.\n---\n ext\/bcmath\/bcmath.c            | 60 +++++++++++++++++++++++++++++-------------\n ext\/bcmath\/tests\/bug72093.phpt | 13 +++++++++\n main\/php_version.h             |  6 ++---\n 3 files changed, 57 insertions(+), 22 deletions(-)\n create mode 100644 ext\/bcmath\/tests\/bug72093.phpt\n\n","diff_code":"diff --git a\/ext\/bcmath\/bcmath.c b\/ext\/bcmath\/bcmath.c\nindex 02177e4..dd691159 100644\n--- a\/ext\/bcmath\/bcmath.c\n+++ b\/ext\/bcmath\/bcmath.c\n@@ -201,6 +201,21 @@ static void php_str2num(bc_num *num, char *str TSRMLS_DC)\n }\n \/* }}} *\/\n \n+\/* {{{ split_bc_num\n+   Convert to bc_num detecting scale *\/\n+static bc_num split_bc_num(bc_num num) {\n+\tbc_num newnum;\n+\tif (num->n_refs >= 1) {\n+\t\treturn num;\n+\t}\n+\tnewnum = _bc_new_num_ex(0, 0, 0);\n+\t*newnum = *num;\n+\tnewnum->n_refs = 1;\n+\tnum->n_refs--;\n+\treturn newnum;\n+}\n+\/* }}} *\/\n+\n \/* {{{ proto string bcadd(string left_operand, string right_operand [, int scale])\n    Returns the sum of two arbitrary precision numbers *\/\n PHP_FUNCTION(bcadd)\n@@ -214,7 +229,7 @@ PHP_FUNCTION(bcadd)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n@@ -225,11 +240,12 @@ PHP_FUNCTION(bcadd)\n \tphp_str2num(&first, left TSRMLS_CC);\n \tphp_str2num(&second, right TSRMLS_CC);\n \tbc_add (first, second, &result, scale);\n-\t\n+\n \tif (result->n_scale > scale) {\n+\t\tresult = split_bc_num(result);\n \t\tresult->n_scale = scale;\n \t}\n-\t\n+\n \tZ_STRVAL_P(return_value) = bc_num2str(result);\n \tZ_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));\n \tZ_TYPE_P(return_value) = IS_STRING;\n@@ -253,7 +269,7 @@ PHP_FUNCTION(bcsub)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n@@ -266,6 +282,7 @@ PHP_FUNCTION(bcsub)\n \tbc_sub (first, second, &result, scale);\n \n \tif (result->n_scale > scale) {\n+\t\tresult = split_bc_num(result);\n \t\tresult->n_scale = scale;\n \t}\n \n@@ -292,11 +309,11 @@ PHP_FUNCTION(bcmul)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n-\t\n+\n \tbc_init_num(&first TSRMLS_CC);\n \tbc_init_num(&second TSRMLS_CC);\n \tbc_init_num(&result TSRMLS_CC);\n@@ -305,6 +322,7 @@ PHP_FUNCTION(bcmul)\n \tbc_multiply (first, second, &result, scale TSRMLS_CC);\n \n \tif (result->n_scale > scale) {\n+\t\tresult = split_bc_num(result);\n \t\tresult->n_scale = scale;\n \t}\n \n@@ -331,11 +349,11 @@ PHP_FUNCTION(bcdiv)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n-\t\n+\n \tbc_init_num(&first TSRMLS_CC);\n \tbc_init_num(&second TSRMLS_CC);\n \tbc_init_num(&result TSRMLS_CC);\n@@ -345,6 +363,7 @@ PHP_FUNCTION(bcdiv)\n \tswitch (bc_divide(first, second, &result, scale TSRMLS_CC)) {\n \t\tcase 0: \/* OK *\/\n \t\t\tif (result->n_scale > scale) {\n+\t\t\t\tresult = split_bc_num(result);\n \t\t\t\tresult->n_scale = scale;\n \t\t\t}\n \t\t\tZ_STRVAL_P(return_value) = bc_num2str(result);\n@@ -374,13 +393,13 @@ PHP_FUNCTION(bcmod)\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &left, &left_len, &right, &right_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tbc_init_num(&first TSRMLS_CC);\n \tbc_init_num(&second TSRMLS_CC);\n \tbc_init_num(&result TSRMLS_CC);\n \tbc_str2num(&first, left, 0 TSRMLS_CC);\n \tbc_str2num(&second, right, 0 TSRMLS_CC);\n-\t\n+\n \tswitch (bc_modulo(first, second, &result, 0 TSRMLS_CC)) {\n \t\tcase 0:\n \t\t\tZ_STRVAL_P(return_value) = bc_num2str(result);\n@@ -391,7 +410,7 @@ PHP_FUNCTION(bcmod)\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Division by zero\");\n \t\t\tbreak;\n \t}\n-\t\n+\n \tbc_free_num(&first);\n \tbc_free_num(&second);\n \tbc_free_num(&result);\n@@ -424,8 +443,9 @@ PHP_FUNCTION(bcpowmod)\n \tscale_int = (int) ((int)scale < 0) ? 0 : scale;\n \n \tif (bc_raisemod(first, second, mod, &result, scale_int TSRMLS_CC) != -1) {\n-\t\tif (result->n_scale > scale) {\n-\t\t\tresult->n_scale = scale;\n+\t\tif (result->n_scale > scale_int) {\n+\t\t\tresult = split_bc_num(result);\n+\t\t\tresult->n_scale = scale_int;\n \t\t}\n \t\tZ_STRVAL_P(return_value) = bc_num2str(result);\n \t\tZ_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));\n@@ -433,7 +453,7 @@ PHP_FUNCTION(bcpowmod)\n \t} else {\n \t\tRETVAL_FALSE;\n \t}\n-\t\n+\n \tbc_free_num(&first);\n \tbc_free_num(&second);\n \tbc_free_num(&mod);\n@@ -455,7 +475,7 @@ PHP_FUNCTION(bcpow)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n@@ -468,6 +488,7 @@ PHP_FUNCTION(bcpow)\n \tbc_raise (first, second, &result, scale TSRMLS_CC);\n \n \tif (result->n_scale > scale) {\n+\t\tresult = split_bc_num(result);\n \t\tresult->n_scale = scale;\n \t}\n \n@@ -494,16 +515,17 @@ PHP_FUNCTION(bcsqrt)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"s|l\", &left, &left_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 2) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n \n \tbc_init_num(&result TSRMLS_CC);\n \tphp_str2num(&result, left TSRMLS_CC);\n-\t\n+\n \tif (bc_sqrt (&result, scale TSRMLS_CC) != 0) {\n \t\tif (result->n_scale > scale) {\n+\t\t\tresult = split_bc_num(result);\n \t\t\tresult->n_scale = scale;\n \t\t}\n \t\tZ_STRVAL_P(return_value) = bc_num2str(result);\n@@ -531,7 +553,7 @@ PHP_FUNCTION(bccomp)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n@@ -555,7 +577,7 @@ PHP_FUNCTION(bccomp)\n PHP_FUNCTION(bcscale)\n {\n \tlong new_scale;\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &new_scale) == FAILURE) {\n \t\treturn;\n \t}\ndiff --git a\/ext\/bcmath\/tests\/bug72093.phpt b\/ext\/bcmath\/tests\/bug72093.phpt\nnew file mode 100644\nindex 0000000..be664b8\n--- \/dev\/null\n+++ b\/ext\/bcmath\/tests\/bug72093.phpt\n@@ -0,0 +1,13 @@\n+--TEST--\n+Bug 72093: bcpowmod accepts negative scale and corrupts _one_ definition\n+--SKIPIF--\n+<?php if(!extension_loaded(\"bcmath\")) print \"skip\"; ?>\n+--FILE--\n+<?php\n+var_dump(bcpowmod(1, \"A\", 128, -200));\n+var_dump(bcpowmod(1, 1.2, 1, 1));\n+?>\n+--EXPECTF--\n+string(1) \"1\"\n+bc math warning: non-zero scale in exponent\n+string(3) \"0.0\"\ndiff --git a\/main\/php_version.h b\/main\/php_version.h\nindex f87cc38..4ebff7f 100644\n--- a\/main\/php_version.h\n+++ b\/main\/php_version.h\n@@ -2,7 +2,7 @@\n \/* edit configure.in to change version number *\/\n #define PHP_MAJOR_VERSION 5\n #define PHP_MINOR_VERSION 5\n-#define PHP_RELEASE_VERSION 35\n+#define PHP_RELEASE_VERSION 27\n #define PHP_EXTRA_VERSION \"-dev\"\n-#define PHP_VERSION \"5.5.35-dev\"\n-#define PHP_VERSION_ID 50535\n+#define PHP_VERSION \"5.5.27-dev\"\n+#define PHP_VERSION_ID 50527\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-0465","CWE_ID":"20","category":"security","commit_id":"1027d5df07398c1507fb1fe3a9981aa6b4bc3a56","commit_message":"From 1027d5df07398c1507fb1fe3a9981aa6b4bc3a56 Mon Sep 17 00:00:00 2001\nFrom: Matthias Hopf <mhopf@suse.de>\nDate: Tue, 1 Mar 2011 19:37:34 +0100\nSubject: Create shell-escape-safe cpp options in the non-pathetic-cpp case.\n\nFixes CVE-2011-0465.\n\nSigned-off-by: Matthias Hopf <mhopf@suse.de>\nReviewed-by: Adam Jackson <ajax@redhat.com>\n---\n xrdb.c | 79 ++++++++++++++++++++++++++++++++++++++++++++++++++++--------------\n 1 file changed, 63 insertions(+), 16 deletions(-)\n\n","diff_code":"diff --git a\/xrdb.c b\/xrdb.c\nindex c3ef0fd..ea698b9 100644\n--- a\/xrdb.c\n+++ b\/xrdb.c\n@@ -142,6 +142,8 @@ static Entries newDB;\n \n static void fatal(char *, ...);\n static void addstring ( String *arg, const char *s );\n+static void addescapedstring ( String *arg, const char *s );\n+static void addtokstring ( String *arg, const char *s );\n static void FormatEntries ( Buffer *buffer, Entries *entries );\n static void StoreProperty ( Display *dpy, Window root, Atom res_prop );\n static void Process ( int scrno, Bool doScreen, Bool execute );\n@@ -433,14 +435,20 @@ AddDef(String *buff, char *title, char *value)\n \t    addstring(buff, \" -D\");\n     } else\n \taddstring(buff, \"-D\");\n-    addstring(buff, title);\n+    addtokstring(buff, title);\n     if (value && (value[0] != '\\0')) {\n \taddstring(buff, \"=\");\n-\taddstring(buff, value);\n+\taddescapedstring(buff, value);\n     }\n }\n \n static void\n+AddSimpleDef(String *buff, char *title)\n+{\n+    AddDef(buff, title, (char *)NULL);\n+}\n+\n+static void\n AddDefQ(String *buff, char *title, char *value)\n {\n #ifdef PATHETICCPP\n@@ -449,8 +457,9 @@ AddDefQ(String *buff, char *title, char *value)\n     else\n #endif\n     if (value && (value[0] != '\\0')) {\n-\tAddDef(buff, title, \"\\\"\");\n-\taddstring(buff, value);\n+\tAddSimpleDef(buff, title);\n+\taddstring(buff, \"=\\\"\");\n+\taddescapedstring(buff, value);\n \taddstring(buff, \"\\\"\");\n     } else\n \tAddDef(buff, title, NULL);\n@@ -465,24 +474,28 @@ AddNum(String *buff, char *title, int value)\n }\n \n static void\n-AddSimpleDef(String *buff, char *title)\n+AddDefTok(String *buff, char *prefix, char *title)\n {\n-    AddDef(buff, title, (char *)NULL);\n+    char name[512];\n+\n+    snprintf(name, sizeof(name), \"%s%s\", prefix, title);\n+    AddSimpleDef(buff, name);\n }\n \n static void\n-AddDefTok(String *buff, char *prefix, char *title)\n+AddDefHostname(String *buff, char *title, char *value)\n {\n     char *s;\n     char name[512];\n     char c;\n \n-    snprintf(name, sizeof(name), \"%s%s\", prefix, title);\n+    strncpy (name, value, sizeof(name)-1);\n+    name[sizeof(name)-1] = '\\0';\n     for (s = name; (c = *s); s++) {\n-\tif (!isalpha(c) && !isdigit(c) && c != '_')\n+\tif (!isalpha(c) && !isdigit(c) && c != '_' && c != '.' && c != ':' && c != '-')\n \t    *s = '_';\n     }\n-    AddSimpleDef(buff, name);\n+    AddDef(buff, title, name);\n }\n \n static void\n@@ -502,7 +515,7 @@ AddUndef(String *buff, char *title)\n \t    addstring(buff, \" -U\");\n     } else\n \taddstring(buff, \"-U\");\n-    addstring(buff, title);\n+    addtokstring(buff, title);\n }\n \n static void \n@@ -565,11 +578,11 @@ DoDisplayDefines(Display *display, String *defs, char *host)\n     }\n     if (!*server || !strcmp(server, \"unix\") || !strcmp(server, \"localhost\"))\n \tstrcpy(server, client);\n-    AddDef(defs, \"HOST\", server); \/* R3 compatibility *\/\n-    AddDef(defs, \"SERVERHOST\", server);\n+    AddDefHostname(defs, \"HOST\", server); \/* R3 compatibility *\/\n+    AddDefHostname(defs, \"SERVERHOST\", server);\n     AddDefTok(defs, \"SRVR_\", server);\n     AddNum(defs, \"DISPLAY_NUM\", n);\n-    AddDef(defs, \"CLIENTHOST\", client);\n+    AddDefHostname(defs, \"CLIENTHOST\", client);\n     AddDefTok(defs, \"CLNT_\", client);\n     AddNum(defs, \"VERSION\", ProtocolVersion(display));\n     AddNum(defs, \"REVISION\", ProtocolRevision(display));\n@@ -612,7 +625,7 @@ DoScreenDefines(Display *display, int scrno, String *defs)\n     AddNum(defs, \"Y_RESOLUTION\", Resolution(screen->height,screen->mheight));\n     AddNum(defs, \"PLANES\", DisplayPlanes(display, scrno));\n     AddNum(defs, \"BITS_PER_RGB\", visual->bits_per_rgb);\n-    AddDef(defs, \"CLASS\", ClassNames[visual->class]);\n+    AddDefQ(defs, \"CLASS\", ClassNames[visual->class]);\n     snprintf(name, sizeof(name), \"CLASS_%s\", ClassNames[visual->class]);\n     AddNum(defs, name, (int)visual->visualid);\n     switch(visual->class) {\n@@ -780,6 +793,40 @@ addstring(String *arg, const char *s)\n     arg->used += strlen(s);\n }   \n \n+static void\n+addescapedstring(String *arg, const char *s)\n+{\n+    char copy[512], *c;\n+\n+    for (c = copy; *s && c < &copy[sizeof(copy)-1]; s++) {\n+\tswitch (*s) {\n+\tcase '\"':       case '\\'':      case '`':\n+\tcase '$':       case '\\\\':\n+\t    *c++ = '_';\n+\t    break;\n+\tdefault:\n+\t    *c++ = *s;\n+\t}\n+    }\n+    *c = 0;\n+    addstring (arg, copy);\n+}\n+\n+static void\n+addtokstring(String *arg, const char *s)\n+{\n+    char copy[512], *c;\n+\n+    for (c = copy; *s && c < &copy[sizeof(copy)-1]; s++) {\n+\tif (!isalpha(*s) && !isdigit(*s) && *s != '_')\n+\t    *c++ = '_';\n+\telse\n+\t    *c++ = *s;\n+    }\n+    *c = 0;\n+    addstring (arg, copy);\n+}\n+\n \n int\n main(int argc, char *argv[])\n@@ -892,7 +939,7 @@ main(int argc, char *argv[])\n \t\tcontinue;\n \t    } else if (arg[1] == 'I') {\n \t\taddstring(&includes, \" \");\n-\t\taddstring(&includes, arg);\n+\t\taddescapedstring(&includes, arg);\n \t\tcontinue;\n \t    } else if (arg[1] == 'U' || arg[1] == 'D') {\n \t\tif (num_cmd_defines < MAX_CMD_DEFINES) {\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2008-2372","CWE_ID":"20","category":"security","commit_id":"89f5b7da2a6bad2e84670422ab8192382a5aeb9f","commit_message":"From 89f5b7da2a6bad2e84670422ab8192382a5aeb9f Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Fri, 20 Jun 2008 11:18:25 -0700\nSubject: Reinstate ZERO_PAGE optimization in 'get_user_pages()' and fix XIP\n\nKAMEZAWA Hiroyuki and Oleg Nesterov point out that since the commit\n557ed1fa2620dc119adb86b34c614e152a629a80 (\"remove ZERO_PAGE\") removed\nthe ZERO_PAGE from the VM mappings, any users of get_user_pages() will\ngenerally now populate the VM with real empty pages needlessly.\n\nWe used to get the ZERO_PAGE when we did the \"handle_mm_fault()\", but\nsince fault handling no longer uses ZERO_PAGE for new anonymous pages,\nwe now need to handle that special case in follow_page() instead.\n\nIn particular, the removal of ZERO_PAGE effectively removed the core\nfile writing optimization where we would skip writing pages that had not\nbeen populated at all, and increased memory pressure a lot by allocating\nall those useless newly zeroed pages.\n\nThis reinstates the optimization by making the unmapped PTE case the\nsame as for a non-existent page table, which already did this correctly.\n\nWhile at it, this also fixes the XIP case for follow_page(), where the\ncaller could not differentiate between the case of a page that simply\ncould not be used (because it had no \"struct page\" associated with it)\nand a page that just wasn't mapped.\n\nWe do that by simply returning an error pointer for pages that could not\nbe turned into a \"struct page *\".  The error is arbitrarily picked to be\nEFAULT, since that was what get_user_pages() already used for the\nequivalent IO-mapped page case.\n\n[ Also removed an impossible test for pte_offset_map_lock() failing:\n  that's not how that function works ]\n\nAcked-by: Oleg Nesterov <oleg@tv-sign.ru>\nAcked-by: Nick Piggin <npiggin@suse.de>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/powerpc\/kernel\/vdso.c |  2 +-\n mm\/memory.c                | 17 +++++++++++++----\n mm\/migrate.c               | 10 ++++++++++\n 3 files changed, 24 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/arch\/powerpc\/kernel\/vdso.c b\/arch\/powerpc\/kernel\/vdso.c\nindex c21a626af676..ce245a850db2 100644\n--- a\/arch\/powerpc\/kernel\/vdso.c\n+++ b\/arch\/powerpc\/kernel\/vdso.c\n@@ -142,7 +142,7 @@ static void dump_one_vdso_page(struct page *pg, struct page *upg)\n \tprintk(\"kpg: %p (c:%d,f:%08lx)\", __va(page_to_pfn(pg) << PAGE_SHIFT),\n \t       page_count(pg),\n \t       pg->flags);\n-\tif (upg\/* && pg != upg*\/) {\n+\tif (upg && !IS_ERR(upg) \/* && pg != upg*\/) {\n \t\tprintk(\" upg: %p (c:%d,f:%08lx)\", __va(page_to_pfn(upg)\n \t\t\t\t\t\t       << PAGE_SHIFT),\n \t\t       page_count(upg),\ndiff --git a\/mm\/memory.c b\/mm\/memory.c\nindex 19e0ae9beecb..9aefaae46858 100644\n--- a\/mm\/memory.c\n+++ b\/mm\/memory.c\n@@ -999,17 +999,15 @@ struct page *follow_page(struct vm_area_struct *vma, unsigned long address,\n \t\tgoto no_page_table;\n \n \tptep = pte_offset_map_lock(mm, pmd, address, &ptl);\n-\tif (!ptep)\n-\t\tgoto out;\n \n \tpte = *ptep;\n \tif (!pte_present(pte))\n-\t\tgoto unlock;\n+\t\tgoto no_page;\n \tif ((flags & FOLL_WRITE) && !pte_write(pte))\n \t\tgoto unlock;\n \tpage = vm_normal_page(vma, address, pte);\n \tif (unlikely(!page))\n-\t\tgoto unlock;\n+\t\tgoto bad_page;\n \n \tif (flags & FOLL_GET)\n \t\tget_page(page);\n@@ -1024,6 +1022,15 @@ unlock:\n out:\n \treturn page;\n \n+bad_page:\n+\tpte_unmap_unlock(ptep, ptl);\n+\treturn ERR_PTR(-EFAULT);\n+\n+no_page:\n+\tpte_unmap_unlock(ptep, ptl);\n+\tif (!pte_none(pte))\n+\t\treturn page;\n+\t\/* Fall through to ZERO_PAGE handling *\/\n no_page_table:\n \t\/*\n \t * When core dumping an enormous anonymous area that nobody\n@@ -1159,6 +1166,8 @@ int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,\n \n \t\t\t\tcond_resched();\n \t\t\t}\n+\t\t\tif (IS_ERR(page))\n+\t\t\t\treturn i ? i : PTR_ERR(page);\n \t\t\tif (pages) {\n \t\t\t\tpages[i] = page;\n \ndiff --git a\/mm\/migrate.c b\/mm\/migrate.c\nindex 449d77d409f5..112bcaeaa104 100644\n--- a\/mm\/migrate.c\n+++ b\/mm\/migrate.c\n@@ -865,6 +865,11 @@ static int do_move_pages(struct mm_struct *mm, struct page_to_node *pm,\n \t\t\tgoto set_status;\n \n \t\tpage = follow_page(vma, pp->addr, FOLL_GET);\n+\n+\t\terr = PTR_ERR(page);\n+\t\tif (IS_ERR(page))\n+\t\t\tgoto set_status;\n+\n \t\terr = -ENOENT;\n \t\tif (!page)\n \t\t\tgoto set_status;\n@@ -928,6 +933,11 @@ static int do_pages_stat(struct mm_struct *mm, struct page_to_node *pm)\n \t\t\tgoto set_status;\n \n \t\tpage = follow_page(vma, pm->addr, 0);\n+\n+\t\terr = PTR_ERR(page);\n+\t\tif (IS_ERR(page))\n+\t\t\tgoto set_status;\n+\n \t\terr = -ENOENT;\n \t\t\/* Use PageReserved to check for zero page *\/\n \t\tif (!page || PageReserved(page))\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2016-10712","CWE_ID":"20","category":"security","commit_id":"6297a117d77fa3a0df2e21ca926a92c231819cd5","commit_message":"From 6297a117d77fa3a0df2e21ca926a92c231819cd5 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sat, 16 Jan 2016 22:10:54 -0800\nSubject: [PATCH] Fixed bug #71323 - Output of stream_get_meta_data can be\n falsified by its input\n\n---\n ext\/standard\/streamsfuncs.c                        |  20 ++--\n ext\/standard\/tests\/streams\/bug71323.phpt           |  31 ++++++\n ...\/streams\/stream_get_meta_data_dir_basic.phpt    |  16 ++--\n ...\/streams\/stream_get_meta_data_file_basic.phpt   |  12 +--\n ...\/stream_get_meta_data_file_variation1.phpt      | 104 ++++++++++-----------\n ...\/stream_get_meta_data_file_variation2.phpt      |  46 ++++-----\n ...\/stream_get_meta_data_file_variation4.phpt      |  20 ++--\n ...\/stream_get_meta_data_file_variation5.phpt      |  24 ++---\n ...\/stream_get_meta_data_process_basic.phpt        |  12 +--\n ...\/streams\/stream_get_meta_data_socket_basic.phpt |  12 +--\n ...\/stream_get_meta_data_socket_variation1.phpt    |  44 ++++-----\n ...\/stream_get_meta_data_socket_variation2.phpt    |  46 ++++-----\n ...\/stream_get_meta_data_socket_variation3.phpt    |  36 +++----\n ...\/stream_get_meta_data_socket_variation4.phpt    |  34 +++----\n main\/streams\/memory.c                              |  30 +++---\n 15 files changed, 260 insertions(+), 227 deletions(-)\n create mode 100644 ext\/standard\/tests\/streams\/bug71323.phpt\n\n","diff_code":"diff --git a\/ext\/standard\/streamsfuncs.c b\/ext\/standard\/streamsfuncs.c\nindex 4c2837e..d11f111 100644\n--- a\/ext\/standard\/streamsfuncs.c\n+++ b\/ext\/standard\/streamsfuncs.c\n@@ -496,6 +496,12 @@ PHP_FUNCTION(stream_get_meta_data)\n \n \tarray_init(return_value);\n \n+\tif (!php_stream_populate_meta_data(stream, return_value)) {\n+\t\tadd_assoc_bool(return_value, \"timed_out\", 0);\n+\t\tadd_assoc_bool(return_value, \"blocked\", 1);\n+\t\tadd_assoc_bool(return_value, \"eof\", php_stream_eof(stream));\n+\t}\n+\n \tif (stream->wrapperdata) {\n \t\tMAKE_STD_ZVAL(newval);\n \t\tMAKE_COPY_ZVAL(&stream->wrapperdata, newval);\n@@ -531,12 +537,6 @@ PHP_FUNCTION(stream_get_meta_data)\n \t\tadd_assoc_string(return_value, \"uri\", stream->orig_path, 1);\n \t}\n \n-\tif (!php_stream_populate_meta_data(stream, return_value)) {\n-\t\tadd_assoc_bool(return_value, \"timed_out\", 0);\n-\t\tadd_assoc_bool(return_value, \"blocked\", 1);\n-\t\tadd_assoc_bool(return_value, \"eof\", php_stream_eof(stream));\n-\t}\n-\n }\n \/* }}} *\/\n \n@@ -696,7 +696,7 @@ static int stream_array_from_fd_set(zval *stream_array, fd_set *fds TSRMLS_DC)\n \t\t\t\t} else { \/* HASH_KEY_IS_STRING *\/\n \t\t\t\t\tzend_hash_update(new_hash, key, key_len, (void *)elem, sizeof(zval *), (void **)&dest_elem);\n \t\t\t\t}\n-\t\t\t\t\n+\n \t\t\t\tif (dest_elem) {\n \t\t\t\t\tzval_add_ref(dest_elem);\n \t\t\t\t}\n@@ -1453,7 +1453,7 @@ PHP_FUNCTION(stream_set_chunk_size)\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The chunk size must be a positive integer, given %ld\", csize);\n \t\tRETURN_FALSE;\n \t}\n-\t\/* stream.chunk_size is actually a size_t, but php_stream_set_option \n+\t\/* stream.chunk_size is actually a size_t, but php_stream_set_option\n \t * can only use an int to accept the new value and return the old one.\n \t * In any case, values larger than INT_MAX for a chunk size make no sense.\n \t *\/\n@@ -1461,11 +1461,11 @@ PHP_FUNCTION(stream_set_chunk_size)\n \t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The chunk size cannot be larger than %d\", INT_MAX);\n \t\tRETURN_FALSE;\n \t}\n-\t\n+\n \tphp_stream_from_zval(stream, &zstream);\n \n \tret = php_stream_set_option(stream, PHP_STREAM_OPTION_SET_CHUNK_SIZE, (int)csize, NULL);\n-\t\n+\n \tRETURN_LONG(ret > 0 ? (long)ret : (long)EOF);\n }\n \/* }}} *\/\ndiff --git a\/ext\/standard\/tests\/streams\/bug71323.phpt b\/ext\/standard\/tests\/streams\/bug71323.phpt\nnew file mode 100644\nindex 0000000..dfe0bd8\n--- \/dev\/null\n+++ b\/ext\/standard\/tests\/streams\/bug71323.phpt\n@@ -0,0 +1,31 @@\n+--TEST--\n+Bug #71323: Output of stream_get_meta_data can be falsified by its input\n+--FILE--\n+<?php\n+$file = 'data:text\/plain;z=y;uri=eviluri;mediatype=wut?;mediatype2=hello,somedata';\n+$meta = stream_get_meta_data(fopen($file, \"r\"));\n+var_dump($meta);\n+?>\n+--EXPECTF--\n+array(10) {\n+  [\"mediatype\"]=>\n+  string(10) \"text\/plain\"\n+  [\"z\"]=>\n+  string(1) \"y\"\n+  [\"uri\"]=>\n+  string(72) \"data:text\/plain;z=y;uri=eviluri;mediatype=wut?;mediatype2=hello,somedata\"\n+  [\"mediatype2\"]=>\n+  string(5) \"hello\"\n+  [\"base64\"]=>\n+  bool(false)\n+  [\"wrapper_type\"]=>\n+  string(7) \"RFC2397\"\n+  [\"stream_type\"]=>\n+  string(7) \"RFC2397\"\n+  [\"mode\"]=>\n+  string(1) \"r\"\n+  [\"unread_bytes\"]=>\n+  int(0)\n+  [\"seekable\"]=>\n+  bool(true)\n+}\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_dir_basic.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_dir_basic.phpt\nindex f46c8fd..6658d69 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_dir_basic.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_dir_basic.phpt\n@@ -13,6 +13,12 @@ var_dump(stream_get_meta_data($dirObject->handle));\n ?>\n --EXPECT--\n array(8) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -23,14 +29,14 @@ array(8) {\n   int(0)\n   [\"seekable\"]=>\n   bool(true)\n+}\n+array(8) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(8) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -41,10 +47,4 @@ array(8) {\n   int(0)\n   [\"seekable\"]=>\n   bool(true)\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_basic.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_basic.phpt\nindex 4758c75..bad5987 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_basic.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_basic.phpt\n@@ -12,6 +12,12 @@ fclose($fp);\n ?>\n --EXPECTF--\n array(9) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -24,10 +30,4 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%sstream_get_meta_data_file_basic.php\"\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation1.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation1.phpt\nindex 572653e..d54eb04 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation1.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation1.phpt\n@@ -29,6 +29,12 @@ unlink($filename);\n ?>\n --EXPECTF--\n array(9) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -41,14 +47,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -61,14 +67,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -81,14 +87,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -101,14 +107,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -121,14 +127,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -141,14 +147,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -161,14 +167,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -181,14 +187,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -201,14 +207,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -221,14 +227,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -241,14 +247,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -261,14 +267,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -281,14 +287,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -301,14 +307,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -321,14 +327,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -341,14 +347,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -361,14 +367,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -381,14 +387,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -401,14 +407,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -421,14 +427,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -441,14 +447,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -461,14 +467,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -481,14 +487,14 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -501,10 +507,4 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation2.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation2.phpt\nindex d186cb7..6b3fde2 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation2.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation2.phpt\n@@ -43,6 +43,12 @@ unlink($filename);\n --EXPECTF--\n Write some data to the file:\n array(9) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -55,12 +61,6 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\n \n \n@@ -68,6 +68,12 @@ Read a line of the file, causing data to be buffered:\n string(15) \"a line of data\n \"\n array(9) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -80,17 +86,17 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n+}\n+\n+\n+Read 20 bytes from the file:\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-\n-\n-Read 20 bytes from the file:\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -103,17 +109,17 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\n \n \n Read entire file:\n array(9) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(true)\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -126,10 +132,4 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s.tmp\"\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(true)\n }\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation4.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation4.phpt\nindex c51d9bd..46a5ba5 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation4.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation4.phpt\n@@ -28,6 +28,12 @@ unlink($filename);\n --EXPECTF--\n Create a file:\n array(9) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -40,16 +46,16 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"File:\/\/%sstream_get_meta_data_file_variation4.php.tmp\"\n+}\n+\n+Change to file's directory and open with a relative path:\n+array(9) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-\n-Change to file's directory and open with a relative path:\n-array(9) {\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -62,10 +68,4 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"stream_get_meta_data_file_variation4.php.tmp\"\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation5.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation5.phpt\nindex 386b92f..22fcee4 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation5.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_file_variation5.phpt\n@@ -33,6 +33,12 @@ unlink($filename);\n --EXPECTF--\n Write some data to the file:\n array(9) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -45,17 +51,17 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s\"\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\n \n \n Read entire file:\n array(9) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(true)\n   [\"wrapper_type\"]=>\n   string(9) \"plainfile\"\n   [\"stream_type\"]=>\n@@ -68,10 +74,4 @@ array(9) {\n   bool(true)\n   [\"uri\"]=>\n   string(%i) \"%s\"\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(true)\n }\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_process_basic.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_process_basic.phpt\nindex 3f4dfbc..b7ab37c 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_process_basic.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_process_basic.phpt\n@@ -18,6 +18,12 @@ echo \"Done\";\n ?>\n --EXPECT--\n array(7) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"stream_type\"]=>\n   string(5) \"STDIO\"\n   [\"mode\"]=>\n@@ -26,11 +32,5 @@ array(7) {\n   int(0)\n   [\"seekable\"]=>\n   bool(false)\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\n Done\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_basic.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_basic.phpt\nindex 8605611..c5136ab 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_basic.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_basic.phpt\n@@ -10,6 +10,12 @@ fclose($tcp_socket);\n ?>\n --EXPECTF--\n array(7) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -18,10 +24,4 @@ array(7) {\n   int(0)\n   [\"seekable\"]=>\n   bool(false)\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation1.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation1.phpt\nindex 16b38d9..18d6a4a 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation1.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation1.phpt\n@@ -39,6 +39,12 @@ var_dump(stream_get_meta_data($client));\n --EXPECTF--\n Write some data:\n array(7) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -47,17 +53,17 @@ array(7) {\n   int(0)\n   [\"seekable\"]=>\n   bool(false)\n+}\n+\n+\n+Read a line from the client, causing data to be buffered:\n+array(7) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-\n-\n-Read a line from the client, causing data to be buffered:\n-array(7) {\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -66,17 +72,17 @@ array(7) {\n   int(15)\n   [\"seekable\"]=>\n   bool(false)\n+}\n+\n+\n+Read 3 bytes of data from the client:\n+array(7) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-\n-\n-Read 3 bytes of data from the client:\n-array(7) {\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -85,17 +91,17 @@ array(7) {\n   int(12)\n   [\"seekable\"]=>\n   bool(false)\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\n \n \n Close the server side socket and read the remaining data from the client:\n array(7) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(true)\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -104,10 +110,4 @@ array(7) {\n   int(0)\n   [\"seekable\"]=>\n   bool(false)\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(true)\n }\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation2.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation2.phpt\nindex d30fec7..712a661 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation2.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation2.phpt\n@@ -37,25 +37,12 @@ fclose($server);\n ?>\n --EXPECTF--\n array(7) {\n-  [\"stream_type\"]=>\n-  string(%d) \"tcp_socke%s\"\n-  [\"mode\"]=>\n-  string(2) \"r+\"\n-  [\"unread_bytes\"]=>\n-  int(0)\n-  [\"seekable\"]=>\n-  bool(false)\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-\n-\n-Set a timeout on the client and attempt a read:\n-array(7) {\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -64,17 +51,17 @@ array(7) {\n   int(0)\n   [\"seekable\"]=>\n   bool(false)\n+}\n+\n+\n+Set a timeout on the client and attempt a read:\n+array(7) {\n   [\"timed_out\"]=>\n   bool(true)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-\n-\n-Write some data from the server:\n-array(7) {\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -83,17 +70,17 @@ array(7) {\n   int(0)\n   [\"seekable\"]=>\n   bool(false)\n+}\n+\n+\n+Write some data from the server:\n+array(7) {\n   [\"timed_out\"]=>\n   bool(true)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-\n-\n-Read some data from the client:\n-array(7) {\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -102,10 +89,23 @@ array(7) {\n   int(0)\n   [\"seekable\"]=>\n   bool(false)\n+}\n+\n+\n+Read some data from the client:\n+array(7) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n+  [\"stream_type\"]=>\n+  string(%d) \"tcp_socke%s\"\n+  [\"mode\"]=>\n+  string(2) \"r+\"\n+  [\"unread_bytes\"]=>\n+  int(0)\n+  [\"seekable\"]=>\n+  bool(false)\n }\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation3.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation3.phpt\nindex 0b079cc..4198973 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation3.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation3.phpt\n@@ -32,6 +32,12 @@ fclose($server);\n ?>\n --EXPECTF--\n array(7) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -40,18 +46,18 @@ array(7) {\n   int(0)\n   [\"seekable\"]=>\n   bool(false)\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\n \n \n Set blocking to false:\n bool(true)\n array(7) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(false)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -60,18 +66,18 @@ array(7) {\n   int(0)\n   [\"seekable\"]=>\n   bool(false)\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(false)\n-  [\"eof\"]=>\n-  bool(false)\n }\n \n \n Set blocking to true:\n bool(true)\n array(7) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -80,10 +86,4 @@ array(7) {\n   int(0)\n   [\"seekable\"]=>\n   bool(false)\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\ndiff --git a\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation4.phpt b\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation4.phpt\nindex f9ef747..50d7ddf 100644\n--- a\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation4.phpt\n+++ b\/ext\/standard\/tests\/streams\/stream_get_meta_data_socket_variation4.phpt\n@@ -37,6 +37,12 @@ fclose($client);\n --EXPECTF--\n Write some data:\n array(7) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(false)\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -45,17 +51,17 @@ array(7) {\n   int(%i)\n   [\"seekable\"]=>\n   bool(false)\n+}\n+\n+\n+Read a line from the client:\n+array(7) {\n   [\"timed_out\"]=>\n   bool(false)\n   [\"blocked\"]=>\n   bool(true)\n   [\"eof\"]=>\n   bool(false)\n-}\n-\n-\n-Read a line from the client:\n-array(7) {\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -64,17 +70,17 @@ array(7) {\n   int(%i)\n   [\"seekable\"]=>\n   bool(false)\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(false)\n }\n \n \n Close the server side socket and read the remaining data from the client:\n array(7) {\n+  [\"timed_out\"]=>\n+  bool(false)\n+  [\"blocked\"]=>\n+  bool(true)\n+  [\"eof\"]=>\n+  bool(true)\n   [\"stream_type\"]=>\n   string(%d) \"tcp_socke%s\"\n   [\"mode\"]=>\n@@ -83,10 +89,4 @@ array(7) {\n   int(%i)\n   [\"seekable\"]=>\n   bool(false)\n-  [\"timed_out\"]=>\n-  bool(false)\n-  [\"blocked\"]=>\n-  bool(true)\n-  [\"eof\"]=>\n-  bool(true)\n }\ndiff --git a\/main\/streams\/memory.c b\/main\/streams\/memory.c\nindex d0f2511..eb31db3 100644\n--- a\/main\/streams\/memory.c\n+++ b\/main\/streams\/memory.c\n@@ -209,7 +209,7 @@ static int php_stream_memory_stat(php_stream *stream, php_stream_statbuf *ssb TS\n \n \tmemset(ssb, 0, sizeof(php_stream_statbuf));\n \t\/* read-only across the board *\/\n-\t\n+\n \tssb->sb.st_mode = ms->mode & TEMP_STREAM_READONLY ? 0444 : 0666;\n \n \tssb->sb.st_size = ms->fsize;\n@@ -248,7 +248,7 @@ static int php_stream_memory_set_option(php_stream *stream, int option, int valu\n {\n \tphp_stream_memory_data *ms = (php_stream_memory_data*)stream->abstract;\n \tsize_t newsize;\n-\t\n+\n \tswitch(option) {\n \t\tcase PHP_STREAM_OPTION_TRUNCATE_API:\n \t\t\tswitch (value) {\n@@ -277,7 +277,7 @@ static int php_stream_memory_set_option(php_stream *stream, int option, int valu\n \t}\n }\n \/* }}} *\/\n-\t\n+\n PHPAPI php_stream_ops\tphp_stream_memory_ops = {\n \tphp_stream_memory_write, php_stream_memory_read,\n \tphp_stream_memory_close, php_stream_memory_flush,\n@@ -301,7 +301,7 @@ PHPAPI php_stream *_php_stream_memory_create(int mode STREAMS_DC TSRMLS_DC)\n \tself->fsize = 0;\n \tself->smax = ~0u;\n \tself->mode = mode;\n-\t\n+\n \tstream = php_stream_alloc_rel(&php_stream_memory_ops, self, 0, mode & TEMP_STREAM_READONLY ? \"rb\" : \"w+b\");\n \tstream->flags |= PHP_STREAM_FLAG_NO_BUFFER;\n \treturn stream;\n@@ -317,7 +317,7 @@ PHPAPI php_stream *_php_stream_memory_open(int mode, char *buf, size_t length ST\n \n \tif ((stream = php_stream_memory_create_rel(mode)) != NULL) {\n \t\tms = (php_stream_memory_data*)stream->abstract;\n-\t\t\n+\n \t\tif (mode == TEMP_STREAM_READONLY || mode == TEMP_STREAM_TAKE_BUFFER) {\n \t\t\t\/* use the buffer directly *\/\n \t\t\tms->data = buf;\n@@ -400,11 +400,11 @@ static size_t php_stream_temp_read(php_stream *stream, char *buf, size_t count T\n \tif (!ts->innerstream) {\n \t\treturn -1;\n \t}\n-\t\n+\n \tgot = php_stream_read(ts->innerstream, buf, count);\n-\t\n+\n \tstream->eof = ts->innerstream->eof;\n-\t\n+\n \treturn got;\n }\n \/* }}} *\/\n@@ -423,7 +423,7 @@ static int php_stream_temp_close(php_stream *stream, int close_handle TSRMLS_DC)\n \t} else {\n \t\tret = 0;\n \t}\n-\t\n+\n \tif (ts->meta) {\n \t\tzval_ptr_dtor(&ts->meta);\n \t}\n@@ -461,7 +461,7 @@ static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, of\n \tret = php_stream_seek(ts->innerstream, offset, whence);\n \t*newoffs = php_stream_tell(ts->innerstream);\n \tstream->eof = ts->innerstream->eof;\n-\t\n+\n \treturn ret;\n }\n \/* }}} *\/\n@@ -503,7 +503,7 @@ static int php_stream_temp_cast(php_stream *stream, int castas, void **ret TSRML\n \tfile = php_stream_fopen_tmpfile();\n \tphp_stream_write(file, membuf, memsize);\n \tpos = php_stream_tell(ts->innerstream);\n-\t\n+\n \tphp_stream_free_enclosed(ts->innerstream, PHP_STREAM_FREE_CLOSE);\n \tts->innerstream = file;\n \tphp_stream_encloses(stream, ts->innerstream);\n@@ -527,7 +527,7 @@ static int php_stream_temp_stat(php_stream *stream, php_stream_statbuf *ssb TSRM\n static int php_stream_temp_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC) \/* {{{ *\/\n {\n \tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n-\t\n+\n \tswitch(option) {\n \t\tcase PHP_STREAM_OPTION_META_DATA_API:\n \t\t\tif (ts->meta) {\n@@ -639,7 +639,7 @@ static php_stream * php_stream_url_wrap_rfc2397(php_stream_wrapper *wrapper, cha\n \t\tdlen -= mlen;\n \t\tsemi = memchr(path, ';', mlen);\n \t\tsep = memchr(path, '\/', mlen);\n-\t\t\n+\n \t\tif (!semi && !sep) {\n \t\t\tphp_stream_wrapper_log_error(wrapper, options TSRMLS_CC, \"rfc2397: illegal media type\");\n \t\t\treturn NULL;\n@@ -682,7 +682,9 @@ static php_stream * php_stream_url_wrap_rfc2397(php_stream_wrapper *wrapper, cha\n \t\t\tplen = sep - path;\n \t\t\tvlen = (semi ? semi - sep : mlen - plen) - 1 \/* '=' *\/;\n \t\t\tkey = estrndup(path, plen);\n-\t\t\tadd_assoc_stringl_ex(meta, key, plen + 1, sep + 1, vlen, 1);\n+\t\t\tif (plen != sizeof(\"mediatype\")-1 || memcmp(key, \"mediatype\", sizeof(\"mediatype\")-1)) {\n+\t\t\t\tadd_assoc_stringl_ex(meta, key, plen + 1, sep + 1, vlen, 1);\n+\t\t\t}\n \t\t\tefree(key);\n \t\t\tplen += vlen + 1;\n \t\t\tmlen -= plen;\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2007-3731","CWE_ID":"20","category":"security","commit_id":"29eb51101c02df517ca64ec472d7501127ad1da8","commit_message":"From 29eb51101c02df517ca64ec472d7501127ad1da8 Mon Sep 17 00:00:00 2001\nFrom: Roland McGrath <roland@redhat.com>\nDate: Mon, 16 Jul 2007 01:03:16 -0700\nSubject: Handle bogus %cs selector in single-step instruction decoding\n\nThe code for LDT segment selectors was not robust in the face of a bogus\nselector set in %cs via ptrace before the single-step was done.\n\nSigned-off-by: Roland McGrath <roland@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/i386\/kernel\/ptrace.c   | 22 +++++++++++++++-------\n arch\/x86_64\/kernel\/ptrace.c | 23 ++++++++++++++++-------\n 2 files changed, 31 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/arch\/i386\/kernel\/ptrace.c b\/arch\/i386\/kernel\/ptrace.c\nindex 1c075f58d1f9..0c8f00e69c4d 100644\n--- a\/arch\/i386\/kernel\/ptrace.c\n+++ b\/arch\/i386\/kernel\/ptrace.c\n@@ -164,14 +164,22 @@ static unsigned long convert_eip_to_linear(struct task_struct *child, struct pt_\n \t\tu32 *desc;\n \t\tunsigned long base;\n \n-\t\tdown(&child->mm->context.sem);\n-\t\tdesc = child->mm->context.ldt + (seg & ~7);\n-\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n+\t\tseg &= ~7UL;\n \n-\t\t\/* 16-bit code segment? *\/\n-\t\tif (!((desc[1] >> 22) & 1))\n-\t\t\taddr &= 0xffff;\n-\t\taddr += base;\n+\t\tdown(&child->mm->context.sem);\n+\t\tif (unlikely((seg >> 3) >= child->mm->context.size))\n+\t\t\taddr = -1L; \/* bogus selector, access would fault *\/\n+\t\telse {\n+\t\t\tdesc = child->mm->context.ldt + seg;\n+\t\t\tbase = ((desc[0] >> 16) |\n+\t\t\t\t((desc[1] & 0xff) << 16) |\n+\t\t\t\t(desc[1] & 0xff000000));\n+\n+\t\t\t\/* 16-bit code segment? *\/\n+\t\t\tif (!((desc[1] >> 22) & 1))\n+\t\t\t\taddr &= 0xffff;\n+\t\t\taddr += base;\n+\t\t}\n \t\tup(&child->mm->context.sem);\n \t}\n \treturn addr;\ndiff --git a\/arch\/x86_64\/kernel\/ptrace.c b\/arch\/x86_64\/kernel\/ptrace.c\nindex fa6775ef729f..e83cc67155ac 100644\n--- a\/arch\/x86_64\/kernel\/ptrace.c\n+++ b\/arch\/x86_64\/kernel\/ptrace.c\n@@ -102,16 +102,25 @@ unsigned long convert_rip_to_linear(struct task_struct *child, struct pt_regs *r\n \t\tu32 *desc;\n \t\tunsigned long base;\n \n-\t\tdown(&child->mm->context.sem);\n-\t\tdesc = child->mm->context.ldt + (seg & ~7);\n-\t\tbase = (desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000);\n+\t\tseg &= ~7UL;\n \n-\t\t\/* 16-bit code segment? *\/\n-\t\tif (!((desc[1] >> 22) & 1))\n-\t\t\taddr &= 0xffff;\n-\t\taddr += base;\n+\t\tdown(&child->mm->context.sem);\n+\t\tif (unlikely((seg >> 3) >= child->mm->context.size))\n+\t\t\taddr = -1L; \/* bogus selector, access would fault *\/\n+\t\telse {\n+\t\t\tdesc = child->mm->context.ldt + seg;\n+\t\t\tbase = ((desc[0] >> 16) |\n+\t\t\t\t((desc[1] & 0xff) << 16) |\n+\t\t\t\t(desc[1] & 0xff000000));\n+\n+\t\t\t\/* 16-bit code segment? *\/\n+\t\t\tif (!((desc[1] >> 22) & 1))\n+\t\t\t\taddr &= 0xffff;\n+\t\t\taddr += base;\n+\t\t}\n \t\tup(&child->mm->context.sem);\n \t}\n+\n \treturn addr;\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-7557","CWE_ID":"20","category":"security","commit_id":"40af93e6eb1c94b90c3b9a0b87e0840e126bb8df","commit_message":"From 40af93e6eb1c94b90c3b9a0b87e0840e126bb8df Mon Sep 17 00:00:00 2001\nFrom: Federico Mena Quintero <federico@gnome.org>\nDate: Thu, 5 Feb 2015 18:08:25 -0600\nSubject: [PATCH] bgo#738050 - Handle the case where a list of coordinate pairs\n has an odd number of elements\n\nLists of points come in coordinate pairs, but we didn't have any checking for that.\nIt was possible to try to fetch the 'last' coordinate in a list, i.e. the y coordinate\nof an x,y pair, that was in fact missing, leading to an out-of-bounds array read.\n\nIn that case, we now reuse the last-known y coordinate.\n\nFixes https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=738050\n\nSigned-off-by: Federico Mena Quintero <federico@gnome.org>\n---\n rsvg-shapes.c | 14 +++++++++++++-\n 1 file changed, 13 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/rsvg-shapes.c b\/rsvg-shapes.c\nindex c13b90cb..e4a705de 100644\n--- a\/rsvg-shapes.c\n+++ b\/rsvg-shapes.c\n@@ -169,10 +169,22 @@ _rsvg_node_poly_build_path (const char *value,\n \n     \/* \"L %f %f \" *\/\n     for (i = 2; i < pointlist_len; i += 2) {\n+        double p;\n+\n         g_string_append (d, \" L \");\n         g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), pointlist[i]));\n         g_string_append_c (d, ' ');\n-        g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), pointlist[i + 1]));\n+\n+        \/* We expect points to come in coordinate pairs.  But if there is a\n+         * missing part of one pair in a corrupt SVG, we'll have an incomplete\n+         * list.  In that case, we reuse the last-known Y coordinate.\n+         *\/\n+        if (i + 1 < pointlist_len)\n+            p = pointlist[i + 1];\n+        else\n+            p = pointlist[i - 1];\n+\n+        g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), p));\n     }\n \n     if (close_path)\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-2381","CWE_ID":"20","category":"security","commit_id":"ae37b791a73a9e78dedb89fb2429d2628cf58076","commit_message":"From ae37b791a73a9e78dedb89fb2429d2628cf58076 Mon Sep 17 00:00:00 2001\nFrom: Tony Cook <tony@develop-help.com>\nDate: Wed, 27 Jan 2016 11:52:15 +1100\nSubject: [PATCH] remove duplicate environment variables from environ\n\nIf we see duplicate environment variables while iterating over\nenviron[]:\n\na) make sure we use the same value in %ENV that getenv() returns.\n\nPreviously on a duplicate, %ENV would have the last entry for the name\nfrom environ[], but a typical getenv() would return the first entry.\n\nRather than assuming all getenv() implementations return the first entry\nexplicitly call getenv() to ensure they agree.\n\nb) remove duplicate entries from environ\n\nPreviously if there was a duplicate definition for a name in environ[]\nsetting that name in %ENV could result in an unsafe value being passed\nto a child process, so ensure environ[] has no duplicates.\n\nCVE-2016-2381\n---\n perl.c | 51 +++++++++++++++++++++++++++++++++++++++++++++++++--\n 1 file changed, 49 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/perl.c b\/perl.c\nindex 4a324c612f..5c71fd0c39 100644\n--- a\/perl.c\n+++ b\/perl.c\n@@ -4329,23 +4329,70 @@ S_init_postdump_symbols(pTHX_ int argc, char **argv, char **env)\n \t}\n \tif (env) {\n \t  char *s, *old_var;\n+          STRLEN nlen;\n \t  SV *sv;\n+          HV *dups = newHV();\n+\n \t  for (; *env; env++) {\n \t    old_var = *env;\n \n \t    if (!(s = strchr(old_var,'=')) || s == old_var)\n \t\tcontinue;\n+            nlen = s - old_var;\n \n #if defined(MSDOS) && !defined(DJGPP)\n \t    *s = '\\0';\n \t    (void)strupr(old_var);\n \t    *s = '=';\n #endif\n-\t    sv = newSVpv(s+1, 0);\n-\t    (void)hv_store(hv, old_var, s - old_var, sv, 0);\n+            if (hv_exists(hv, old_var, nlen)) {\n+                const char *name = savepvn(old_var, nlen);\n+\n+                \/* make sure we use the same value as getenv(), otherwise code that\n+                   uses getenv() (like setlocale()) might see a different value to %ENV\n+                 *\/\n+                sv = newSVpv(PerlEnv_getenv(name), 0);\n+\n+                \/* keep a count of the dups of this name so we can de-dup environ later *\/\n+                if (hv_exists(dups, name, nlen))\n+                    ++SvIVX(*hv_fetch(dups, name, nlen, 0));\n+                else\n+                    (void)hv_store(dups, name, nlen, newSViv(1), 0);\n+\n+                Safefree(name);\n+            }\n+            else {\n+                sv = newSVpv(s+1, 0);\n+            }\n+\t    (void)hv_store(hv, old_var, nlen, sv, 0);\n \t    if (env_is_not_environ)\n \t        mg_set(sv);\n \t  }\n+          if (HvKEYS(dups)) {\n+              \/* environ has some duplicate definitions, remove them *\/\n+              HE *entry;\n+              hv_iterinit(dups);\n+              while ((entry = hv_iternext_flags(dups, 0))) {\n+                  STRLEN nlen;\n+                  const char *name = HePV(entry, nlen);\n+                  IV count = SvIV(HeVAL(entry));\n+                  IV i;\n+                  SV **valp = hv_fetch(hv, name, nlen, 0);\n+\n+                  assert(valp);\n+\n+                  \/* try to remove any duplicate names, depending on the\n+                   * implementation used in my_setenv() the iteration might\n+                   * not be necessary, but let's be safe.\n+                   *\/\n+                  for (i = 0; i < count; ++i)\n+                      my_setenv(name, 0);\n+\n+                  \/* and set it back to the value we set $ENV{name} to *\/\n+                  my_setenv(name, SvPV_nolen(*valp));\n+              }\n+          }\n+          SvREFCNT_dec_NN(dups);\n       }\n #endif \/* USE_ENVIRON_ARRAY *\/\n #endif \/* !PERL_MICRO *\/\n-- \n2.15.1-424-g9478a660812\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12186","CWE_ID":"20","category":"security","commit_id":"cad5a1050b7184d828aef9c1dd151c3ab649d37e","commit_message":"From cad5a1050b7184d828aef9c1dd151c3ab649d37e Mon Sep 17 00:00:00 2001\nFrom: Nathan Kidd <nkidd@opentext.com>\nDate: Fri, 9 Jan 2015 09:57:23 -0500\nSubject: Unvalidated lengths\n\nv2: Add overflow check and remove unnecessary check (Julien Cristau)\n\nThis addresses:\nCVE-2017-12184 in XINERAMA\nCVE-2017-12185 in MIT-SCREEN-SAVER\nCVE-2017-12186 in X-Resource\nCVE-2017-12187 in RENDER\n\nReviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Nathan Kidd <nkidd@opentext.com>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n Xext\/panoramiX.c          | 3 ++-\n Xext\/saver.c              | 2 ++\n Xext\/xres.c               | 4 +++-\n Xext\/xvdisp.c             | 4 +++-\n hw\/dmx\/dmxpict.c          | 2 ++\n pseudoramiX\/pseudoramiX.c | 3 ++-\n render\/render.c           | 3 +++\n 7 files changed, 17 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/Xext\/panoramiX.c b\/Xext\/panoramiX.c\nindex 209df29..844ea49 100644\n--- a\/Xext\/panoramiX.c\n+++ b\/Xext\/panoramiX.c\n@@ -988,10 +988,11 @@ ProcPanoramiXGetScreenSize(ClientPtr client)\n     xPanoramiXGetScreenSizeReply rep;\n     int rc;\n \n+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n+\n     if (stuff->screen >= PanoramiXNumScreens)\n         return BadMatch;\n \n-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n     rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n     if (rc != Success)\n         return rc;\ndiff --git a\/Xext\/saver.c b\/Xext\/saver.c\nindex 0949761..f6090d8 100644\n--- a\/Xext\/saver.c\n+++ b\/Xext\/saver.c\n@@ -1186,6 +1186,8 @@ ProcScreenSaverUnsetAttributes(ClientPtr client)\n         PanoramiXRes *draw;\n         int rc, i;\n \n+        REQUEST_SIZE_MATCH(xScreenSaverUnsetAttributesReq);\n+\n         rc = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n         if (rc != Success)\ndiff --git a\/Xext\/xres.c b\/Xext\/xres.c\nindex 21239f5..0242158 100644\n--- a\/Xext\/xres.c\n+++ b\/Xext\/xres.c\n@@ -947,6 +947,8 @@ ProcXResQueryResourceBytes (ClientPtr client)\n     ConstructResourceBytesCtx    ctx;\n \n     REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);\n+    if (stuff->numSpecs > UINT32_MAX \/ sizeof(ctx.specs[0]))\n+        return BadLength;\n     REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,\n                        stuff->numSpecs * sizeof(ctx.specs[0]));\n \n@@ -1052,8 +1054,8 @@ SProcXResQueryResourceBytes (ClientPtr client)\n     int c;\n     xXResResourceIdSpec *specs = (void*) ((char*) stuff + sizeof(*stuff));\n \n-    swapl(&stuff->numSpecs);\n     REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);\n+    swapl(&stuff->numSpecs);\n     REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,\n                        stuff->numSpecs * sizeof(specs[0]));\n \ndiff --git a\/Xext\/xvdisp.c b\/Xext\/xvdisp.c\nindex d99d3d4..5232b37 100644\n--- a\/Xext\/xvdisp.c\n+++ b\/Xext\/xvdisp.c\n@@ -1493,12 +1493,14 @@ XineramaXvShmPutImage(ClientPtr client)\n {\n     REQUEST(xvShmPutImageReq);\n     PanoramiXRes *draw, *gc, *port;\n-    Bool send_event = stuff->send_event;\n+    Bool send_event;\n     Bool isRoot;\n     int result, i, x, y;\n \n     REQUEST_SIZE_MATCH(xvShmPutImageReq);\n \n+    send_event = stuff->send_event;\n+\n     result = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n     if (result != Success)\ndiff --git a\/hw\/dmx\/dmxpict.c b\/hw\/dmx\/dmxpict.c\nindex 1f1022e..63caec9 100644\n--- a\/hw\/dmx\/dmxpict.c\n+++ b\/hw\/dmx\/dmxpict.c\n@@ -716,6 +716,8 @@ dmxProcRenderSetPictureFilter(ClientPtr client)\n         filter = (char *) (stuff + 1);\n         params = (XFixed *) (filter + ((stuff->nbytes + 3) & ~3));\n         nparams = ((XFixed *) stuff + client->req_len) - params;\n+        if (nparams < 0)\n+            return BadLength;\n \n         XRenderSetPictureFilter(dmxScreen->beDisplay,\n                                 pPictPriv->pict, filter, params, nparams);\ndiff --git a\/pseudoramiX\/pseudoramiX.c b\/pseudoramiX\/pseudoramiX.c\nindex d8b2593..95f6e10 100644\n--- a\/pseudoramiX\/pseudoramiX.c\n+++ b\/pseudoramiX\/pseudoramiX.c\n@@ -297,10 +297,11 @@ ProcPseudoramiXGetScreenSize(ClientPtr client)\n \n     TRACE;\n \n+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n+\n     if (stuff->screen >= pseudoramiXNumScreens)\n       return BadMatch;\n \n-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n     rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n     if (rc != Success)\n         return rc;\ndiff --git a\/render\/render.c b\/render\/render.c\nindex ccae49a..7d94bd5 100644\n--- a\/render\/render.c\n+++ b\/render\/render.c\n@@ -1757,6 +1757,9 @@ ProcRenderSetPictureFilter(ClientPtr client)\n     name = (char *) (stuff + 1);\n     params = (xFixed *) (name + pad_to_int32(stuff->nbytes));\n     nparams = ((xFixed *) stuff + client->req_len) - params;\n+    if (nparams < 0)\n+\treturn BadLength;\n+\n     result = SetPictureFilter(pPicture, name, stuff->nbytes, params, nparams);\n     return result;\n }\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-5296","CWE_ID":"20","category":"security","commit_id":"1ba49b8f389eda3414b14410c7fbcb4041ca06b1","commit_message":"From 1ba49b8f389eda3414b14410c7fbcb4041ca06b1 Mon Sep 17 00:00:00 2001\nFrom: Stefan Metzmacher <metze@samba.org>\nDate: Wed, 30 Sep 2015 21:17:02 +0200\nSubject: [PATCH] CVE-2015-5296: s3:libsmb: force signing when requiring\n encryption in SMBC_server_internal()\n\nBUG: https:\/\/bugzilla.samba.org\/show_bug.cgi?id=11536\n\nSigned-off-by: Stefan Metzmacher <metze@samba.org>\nReviewed-by: Jeremy Allison <jra@samba.org>\n---\n source3\/libsmb\/libsmb_server.c | 15 ++++++++++++---\n 1 file changed, 12 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/source3\/libsmb\/libsmb_server.c b\/source3\/libsmb\/libsmb_server.c\nindex 07d51ea00cb..2abd37e12f0 100644\n--- a\/source3\/libsmb\/libsmb_server.c\n+++ b\/source3\/libsmb\/libsmb_server.c\n@@ -273,6 +273,7 @@ SMBC_server_internal(TALLOC_CTX *ctx,\n \tchar *newserver, *newshare;\n \tint flags = 0;\n \tstruct smbXcli_tcon *tcon = NULL;\n+\tint signing_state = SMB_SIGNING_DEFAULT;\n \n \tZERO_STRUCT(c);\n \t*in_cache = false;\n@@ -439,6 +440,10 @@ SMBC_server_internal(TALLOC_CTX *ctx,\n \t\tflags |= CLI_FULL_CONNECTION_USE_NT_HASH;\n \t}\n \n+\tif (context->internal->smb_encryption_level != SMBC_ENCRYPTLEVEL_NONE) {\n+\t\tsigning_state = SMB_SIGNING_REQUIRED;\n+\t}\n+\n \tif (port == 0) {\n \t        if (share == NULL || *share == '\\0' || is_ipc) {\n \t\t\t\/*\n@@ -446,7 +451,7 @@ SMBC_server_internal(TALLOC_CTX *ctx,\n \t\t\t *\/\n \t\t\tstatus = cli_connect_nb(server_n, NULL, NBT_SMB_PORT, 0x20,\n \t\t\t\t\tsmbc_getNetbiosName(context),\n-\t\t\t\t\tSMB_SIGNING_DEFAULT, flags, &c);\n+\t\t\t\t\tsigning_state, flags, &c);\n \t\t}\n \t}\n \n@@ -456,7 +461,7 @@ SMBC_server_internal(TALLOC_CTX *ctx,\n \t\t *\/\n \t\tstatus = cli_connect_nb(server_n, NULL, port, 0x20,\n \t\t\t\t\tsmbc_getNetbiosName(context),\n-\t\t\t\t\tSMB_SIGNING_DEFAULT, flags, &c);\n+\t\t\t\t\tsigning_state, flags, &c);\n \t}\n \n \tif (!NT_STATUS_IS_OK(status)) {\n@@ -737,6 +742,7 @@ SMBC_attr_server(TALLOC_CTX *ctx,\n         ipc_srv = SMBC_find_server(ctx, context, server, \"*IPC$\",\n                                    pp_workgroup, pp_username, pp_password);\n         if (!ipc_srv) {\n+\t\tint signing_state = SMB_SIGNING_DEFAULT;\n \n                 \/* We didn't find a cached connection.  Get the password *\/\n \t\tif (!*pp_password || (*pp_password)[0] == '\\0') {\n@@ -758,6 +764,9 @@ SMBC_attr_server(TALLOC_CTX *ctx,\n                 if (smbc_getOptionUseCCache(context)) {\n                         flags |= CLI_FULL_CONNECTION_USE_CCACHE;\n                 }\n+\t\tif (context->internal->smb_encryption_level != SMBC_ENCRYPTLEVEL_NONE) {\n+\t\t\tsigning_state = SMB_SIGNING_REQUIRED;\n+\t\t}\n \n                 nt_status = cli_full_connection(&ipc_cli,\n \t\t\t\t\t\tlp_netbios_name(), server,\n@@ -766,7 +775,7 @@ SMBC_attr_server(TALLOC_CTX *ctx,\n \t\t\t\t\t\t*pp_workgroup,\n \t\t\t\t\t\t*pp_password,\n \t\t\t\t\t\tflags,\n-\t\t\t\t\t\tSMB_SIGNING_DEFAULT);\n+\t\t\t\t\t\tsigning_state);\n                 if (! NT_STATUS_IS_OK(nt_status)) {\n                         DEBUG(1,(\"cli_full_connection failed! (%s)\\n\",\n                                  nt_errstr(nt_status)));\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-17562","CWE_ID":"20","category":"security","commit_id":"6f786c123196eb622625a920d54048629a7caa74","commit_message":"From 6f786c123196eb622625a920d54048629a7caa74 Mon Sep 17 00:00:00 2001\nFrom: Michael O'Brien <mob@emobrien.com>\nDate: Thu, 8 Jun 2017 13:43:42 -0700\nSubject: [PATCH] DEV: add CGI prefixes\n\n---\n doc\/partials\/menu.html.exp    |  2 +-\n doc\/partials\/sidebar.html.exp |  2 +-\n main.me                       | 20 ++++++++++++--------\n src\/cgi.c                     | 15 +++++++++++----\n src\/goahead.h                 | 14 ++++++++++++--\n src\/runtime.c                 | 14 +++++++++++++-\n 6 files changed, 50 insertions(+), 17 deletions(-)\n\n","diff_code":"diff --git a\/doc\/partials\/menu.html.exp b\/doc\/partials\/menu.html.exp\nindex ec826fa0..6cd8d378 100644\n--- a\/doc\/partials\/menu.html.exp\n+++ b\/doc\/partials\/menu.html.exp\n@@ -5,5 +5,5 @@\n                         <a class=\"item\" href=\"http:\/\/goo.gl\/9bL9rM\">GoAhead News<\/a>\n                         <a class=\"item\" href=\"https:\/\/github.com\/embedthis\/goahead\">Repository<\/a>\n                         <a class=\"item\" href=\"https:\/\/embedthis.com\/blog\/\">Blog<\/a>\n-                        <a class=\"item\" href=\"https:\/\/twitter.com\/mobstream\">Twitter<\/a>\n+                        <a class=\"item\" href=\"https:\/\/twitter.com\/embedthat\">Twitter<\/a>\n                     <\/span>\ndiff --git a\/doc\/partials\/sidebar.html.exp b\/doc\/partials\/sidebar.html.exp\nindex 7195a036..41243bc0 100644\n--- a\/doc\/partials\/sidebar.html.exp\n+++ b\/doc\/partials\/sidebar.html.exp\n@@ -81,7 +81,7 @@\n                 <div class=\"menu\">\n                     <a class=\"item\" href=\"https:\/\/embedthis.com\/\">Embedthis Web Site<\/a>\n                     <a class=\"item\" href=\"https:\/\/embedthis.com\/blog\/\">Embedthis Blog<\/a>\n-                    <a class=\"item\" href=\"http:\/\/twitter.com\/mobstream\">Twitter<\/a>\n+                    <a class=\"item\" href=\"http:\/\/twitter.com\/embedthat\">Twitter<\/a>\n                 <\/div>\n             <\/div>\n         <\/div>\ndiff --git a\/main.me b\/main.me\nindex d70418a2..b603eb07 100644\n--- a\/main.me\n+++ b\/main.me\n@@ -2,7 +2,7 @@\n     main.me -- Main MakeMe file for GoAhead\n \n     This file contains the rules for targets to build and default settings for configuration.\n-    The MakeMe utility (https:\/\/embedthis.com\/me) may be used to build GoAhead instead of make. \n+    The MakeMe utility (https:\/\/embedthis.com\/me) may be used to build GoAhead instead of make.\n     MakeMe provides for configured builds and generates projects files.\n \n     Alternatively, build using the 'make' utility in which case this file is not used.\n@@ -53,7 +53,7 @@ Me.load({\n             accessLog: false,\n \n             \/*\n-                User authentication \n+                User authentication\n              *\/\n             auth: true,\n \n@@ -76,6 +76,11 @@ Me.load({\n              *\/\n             cgi: true,\n \n+            \/*\n+                Prefix for CGI environment variables\n+             *\/\n+            cgiPrefix: \"CGI_\"\n+\n             \/*\n                 Build with support for digest authentication\n              *\/\n@@ -235,9 +240,9 @@ Me.load({\n     },\n \n     customize: [\n-        \/* \n+        \/*\n             The optional custom.me file is loaded after main.me is fully processed. It can\n-            thus override any setting. Feel free to create and customize. \n+            thus override any setting. Feel free to create and customize.\n          *\/\n         'custom.me',\n     ],\n@@ -261,7 +266,7 @@ Me.load({\n                 prebuild: `\n                     if (me.settings.compiler.hasPam && me.settings.goahead.pam) {\n                         me.target.libraries.push('pam')\n-                    }                                                                                      \n+                    }\n                 `\n             },\n         },\n@@ -275,10 +280,10 @@ Me.load({\n                 prebuild: `\n                     if (me.settings.compiler.hasPam) {\n                         me.target.libraries.push('pam')\n-                    }                                                                                      \n+                    }\n                     cp(['${BIN}\/self.key', '${BIN}\/self.crt'], 'src')\n                     cp(['${BIN}\/self.key', '${BIN}\/self.crt'], 'test')\n-                `,  \n+                `,\n             },\n         },\n \n@@ -353,4 +358,3 @@ Me.load({\n         }\n     },\n })\n-\ndiff --git a\/src\/cgi.c b\/src\/cgi.c\nindex 899ec97b..18d9b45b 100644\n--- a\/src\/cgi.c\n+++ b\/src\/cgi.c\n@@ -160,10 +160,17 @@ PUBLIC bool cgiHandler(Webs *wp)\n     envpsize = 64;\n     envp = walloc(envpsize * sizeof(char*));\n     for (n = 0, s = hashFirst(wp->vars); s != NULL; s = hashNext(wp->vars, s)) {\n-        if (s->content.valid && s->content.type == string &&\n-            strcmp(s->name.value.string, \"REMOTE_HOST\") != 0 &&\n-            strcmp(s->name.value.string, \"HTTP_AUTHORIZATION\") != 0) {\n-            envp[n++] = sfmt(\"%s=%s\", s->name.value.string, s->content.value.string);\n+        if (s->content.valid && s->content.type == string) {\n+            if (smatch(s->name.value.string, \"REMOTE_HOST\") ||\n+                smatch(s->name.value.string, \"HTTP_AUTHORIZATION\") ||\n+                smatch(s->name.value.string, \"IFS\") ||\n+                smatch(s->name.value.string, \"CDPATH\") ||\n+                smatch(s->name.value.string, \"PATH\") ||\n+                sstarts(s->name.value.string, \"LD_\")) {\n+                continue;\n+            }\n+            envp[n++] = sfmt(\"%s%s=%s\", ME_GOAHEAD_CGI_PREFIX,\n+                s->name.value.string, s->content.value.string);\n             trace(5, \"Env[%d] %s\", n, envp[n-1]);\n             if (n >= envpsize) {\n                 envpsize *= 2;\ndiff --git a\/src\/goahead.h b\/src\/goahead.h\nindex ea5f8270..f58b8d10 100644\n--- a\/src\/goahead.h\n+++ b\/src\/goahead.h\n@@ -1391,7 +1391,7 @@ PUBLIC WebsSocket *socketPtr(int sid);\n         help prevent buffer overflows and other potential security traps.\n     @defgroup WebsRuntime WebsRuntime\n     @see fmt wallocHandle wallocObject wfreeHandle hextoi itosbuf scaselesscmp scaselessmatch\n-        sclone scmp scopy sfmt sfmtv slen slower smatch sncaselesscmp sncmp sncopy stok strim supper\n+        sclone scmp scopy sfmt sfmtv slen slower smatch sstarts sncaselesscmp sncmp sncopy stok strim supper\n     @stability Stable\n  *\/\n \n@@ -1575,7 +1575,7 @@ PUBLIC char *sfmtv(char *format, va_list args);\n     @ingroup WebsRuntime\n     @stability Stable\n  *\/\n-PUBLIC ssize slen(char *str);\n+PUBLIC ssize slen(cchar *str);\n \n \/**\n     Convert a string to lower case.\n@@ -1667,6 +1667,16 @@ PUBLIC bool snumber(cchar *s);\n  *\/\n PUBLIC char *ssplit(char *str, cchar *delim, char **last);\n \n+\/**\n+    Test if the string starts with a given pattern.\n+    @param str String to examine\n+    @param prefix Pattern to search for\n+    @return Returns TRUE if the pattern was found. Otherwise returns zero.\n+    @ingroup MprString\n+    @stability Stable\n+ *\/\n+PUBLIC bool sstarts(cchar *str, cchar *prefix);\n+\n \/**\n     Tokenize a string\n     @description Split a string into tokens.\ndiff --git a\/src\/runtime.c b\/src\/runtime.c\nindex 59e0949b..95848095 100644\n--- a\/src\/runtime.c\n+++ b\/src\/runtime.c\n@@ -2495,6 +2495,18 @@ PUBLIC bool smatch(char *s1, char *s2)\n }\n \n \n+PUBLIC bool sstarts(cchar *str, cchar *prefix)\n+{\n+    if (str == 0 || prefix == 0) {\n+        return 0;\n+    }\n+    if (strncmp(str, prefix, slen(prefix)) == 0) {\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+\n PUBLIC int scmp(char *s1, char *s2)\n {\n     if (s1 == s2) {\n@@ -2508,7 +2520,7 @@ PUBLIC int scmp(char *s1, char *s2)\n }\n \n \n-PUBLIC ssize slen(char *s)\n+PUBLIC ssize slen(cchar *s)\n {\n     return s ? strlen(s) : 0;\n }\n","owner":"embedthis","repo":"goahead","source":"cve"},{"CVE_ID":"CVE-2014-3971","CWE_ID":"20","category":"security","commit_id":"c151e0660b9736fe66b224f1129a16871165251b","commit_message":"From c151e0660b9736fe66b224f1129a16871165251b Mon Sep 17 00:00:00 2001\nFrom: Andreas Nilsson <andreas.nilsson@10gen.com>\nDate: Tue, 29 Apr 2014 13:04:51 -0400\nSubject: [PATCH] SERVER-13573 Fix x.509 auth exception\n\n---\n src\/mongo\/db\/commands\/authentication_commands.cpp | 12 ++++++++----\n 1 file changed, 8 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/src\/mongo\/db\/commands\/authentication_commands.cpp b\/src\/mongo\/db\/commands\/authentication_commands.cpp\nindex be1ddf2ec84..2bfbe96cba0 100644\n--- a\/src\/mongo\/db\/commands\/authentication_commands.cpp\n+++ b\/src\/mongo\/db\/commands\/authentication_commands.cpp\n@@ -303,14 +303,18 @@ namespace mongo {\n         }\n         else {\n             std::string srvSubjectName = getSSLManager()->getServerSubjectName();\n-            std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find(\",OU=\"));\n-            std::string peerClusterId = subjectName.substr(subjectName.find(\",OU=\"));\n+            \n+            size_t srvClusterIdPos = srvSubjectName.find(\",OU=\");\n+            size_t peerClusterIdPos = subjectName.find(\",OU=\");\n \n-            fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);\n+            std::string srvClusterId = srvClusterIdPos != std::string::npos ? \n+                srvSubjectName.substr(srvClusterIdPos) : \"\";\n+            std::string peerClusterId = peerClusterIdPos != std::string::npos ? \n+                subjectName.substr(peerClusterIdPos) : \"\";\n \n             \/\/ Handle internal cluster member auth, only applies to server-server connections\n             int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); \n-            if (srvClusterId == peerClusterId) {\n+            if (srvClusterId == peerClusterId && !srvClusterId.empty()) {\n                 if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||\n                     clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {\n                     return Status(ErrorCodes::AuthenticationFailed, \"The provided certificate \" \n","owner":"mongodb","repo":"mongo","source":"cve"},{"CVE_ID":"CVE-2017-13673","CWE_ID":"20","category":"security","commit_id":"bfc56535f793c557aa754c50213fc5f882e6482d","commit_message":"From bfc56535f793c557aa754c50213fc5f882e6482d Mon Sep 17 00:00:00 2001\nFrom: Gerd Hoffmann <kraxel@redhat.com>\nDate: Tue, 9 May 2017 12:48:39 +0200\nSubject: [PATCH] vga: fix display update region calculation\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nvga display update mis-calculated the region for the dirty bitmap\nsnapshot in case the scanlines are padded.  This can triggere an\nassert in cpu_physical_memory_snapshot_get_dirty().\n\nFixes: fec5e8c92becad223df9d972770522f64aafdb72\nReported-by: Kevin Wolf <kwolf@redhat.com>\nReported-by: \u00e6\u009d\u008e\u00e5\u00bc\u00ba <liqiang6-s@360.cn>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nMessage-id: 20170509104839.19415-1-kraxel@redhat.com\n---\n hw\/display\/vga.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/display\/vga.c b\/hw\/display\/vga.c\nindex b2516c8..dcc95f8 100644\n--- a\/hw\/display\/vga.c\n+++ b\/hw\/display\/vga.c\n@@ -1630,7 +1630,7 @@ static void vga_draw_graphic(VGACommonState *s, int full_update)\n     if (!full_update) {\n         vga_sync_dirty_bitmap(s);\n         snap = memory_region_snapshot_and_clear_dirty(&s->vram, addr1,\n-                                                      bwidth * height,\n+                                                      line_offset * height,\n                                                       DIRTY_MEMORY_VGA);\n     }\n \n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-4348","CWE_ID":"20","category":"security","commit_id":"d1c9191949747f6dcfd207831d15dd4ba00e31f2","commit_message":"From d1c9191949747f6dcfd207831d15dd4ba00e31f2 Mon Sep 17 00:00:00 2001\nFrom: Benjamin Otte <otte@redhat.com>\nDate: Wed, 7 Oct 2015 05:31:08 +0200\nSubject: [PATCH] state: Store mask as reference\n\nInstead of immediately looking up the mask, store the reference and look\nit up on use.\n---\n rsvg-cairo-draw.c |  6 +++++-\n rsvg-mask.c       | 17 -----------------\n rsvg-mask.h       |  2 --\n rsvg-styles.c     | 12 ++++++++----\n rsvg-styles.h     |  2 +-\n 5 files changed, 14 insertions(+), 25 deletions(-)\n\n","diff_code":"diff --git a\/rsvg-cairo-draw.c b\/rsvg-cairo-draw.c\nindex 61378a76..187ee4ef 100644\n--- a\/rsvg-cairo-draw.c\n+++ b\/rsvg-cairo-draw.c\n@@ -834,7 +834,11 @@ rsvg_cairo_pop_render_stack (RsvgDrawingCtx * ctx)\n     cairo_set_operator (render->cr, state->comp_op);\n \n     if (state->mask) {\n-        rsvg_cairo_generate_mask (render->cr, state->mask, ctx, &render->bbox);\n+        RsvgNode *mask;\n+\n+        mask = rsvg_defs_lookup (ctx->defs, state->mask);\n+        if (mask && RSVG_NODE_TYPE (mask) == RSVG_NODE_TYPE_MASK)\n+          rsvg_cairo_generate_mask (render->cr, (RsvgMask *) mask, ctx, &render->bbox);\n     } else if (state->opacity != 0xFF)\n         cairo_paint_with_alpha (render->cr, (double) state->opacity \/ 255.0);\n     else\ndiff --git a\/rsvg-mask.c b\/rsvg-mask.c\nindex 8e3cba31..959ffa07 100644\n--- a\/rsvg-mask.c\n+++ b\/rsvg-mask.c\n@@ -102,23 +102,6 @@ rsvg_get_url_string (const char *str)\n     return NULL;\n }\n \n-RsvgNode *\n-rsvg_mask_parse (const RsvgDefs * defs, const char *str)\n-{\n-    char *name;\n-\n-    name = rsvg_get_url_string (str);\n-    if (name) {\n-        RsvgNode *val;\n-        val = rsvg_defs_lookup (defs, name);\n-        g_free (name);\n-\n-        if (val && RSVG_NODE_TYPE (val) == RSVG_NODE_TYPE_MASK)\n-            return val;\n-    }\n-    return NULL;\n-}\n-\n RsvgNode *\n rsvg_clip_path_parse (const RsvgDefs * defs, const char *str)\n {\ndiff --git a\/rsvg-mask.h b\/rsvg-mask.h\nindex ffadbd5a..48bb7f0b 100644\n--- a\/rsvg-mask.h\n+++ b\/rsvg-mask.h\n@@ -48,8 +48,6 @@ struct _RsvgMask {\n \n G_GNUC_INTERNAL\n RsvgNode *rsvg_new_mask\t    (void);\n-G_GNUC_INTERNAL\n-RsvgNode *rsvg_mask_parse   (const RsvgDefs * defs, const char *str);\n \n typedef struct _RsvgClipPath RsvgClipPath;\n \ndiff --git a\/rsvg-styles.c b\/rsvg-styles.c\nindex 0b7baf51..1db34f4a 100644\n--- a\/rsvg-styles.c\n+++ b\/rsvg-styles.c\n@@ -221,6 +221,7 @@ rsvg_state_clone (RsvgState * dst, const RsvgState * src)\n \n     *dst = *src;\n     dst->parent = parent;\n+    dst->mask = g_strdup (src->mask);\n     dst->font_family = g_strdup (src->font_family);\n     dst->lang = g_strdup (src->lang);\n     rsvg_paint_server_ref (dst->fill);\n@@ -356,7 +357,8 @@ rsvg_state_inherit_run (RsvgState * dst, const RsvgState * src,\n \n     if (inherituninheritables) {\n         dst->clip_path_ref = src->clip_path_ref;\n-        dst->mask = src->mask;\n+        g_free (dst->mask);\n+        dst->mask = g_strdup (src->mask);\n         dst->enable_background = src->enable_background;\n         dst->adobe_blend = src->adobe_blend;\n         dst->opacity = src->opacity;\n@@ -444,6 +446,7 @@ rsvg_state_inherit (RsvgState * dst, const RsvgState * src)\n void\n rsvg_state_finalize (RsvgState * state)\n {\n+    g_free (state->mask);\n     g_free (state->font_family);\n     g_free (state->lang);\n     rsvg_paint_server_unref (state->fill);\n@@ -517,9 +520,10 @@ rsvg_parse_style_pair (RsvgHandle * ctx,\n             state->adobe_blend = 11;\n         else\n             state->adobe_blend = 0;\n-    } else if (g_str_equal (name, \"mask\"))\n-        state->mask = rsvg_mask_parse (ctx->priv->defs, value);\n-    else if (g_str_equal (name, \"clip-path\")) {\n+    } else if (g_str_equal (name, \"mask\")) {\n+        g_free (state->mask);\n+        state->mask = rsvg_get_url_string (value);\n+    } else if (g_str_equal (name, \"clip-path\")) {\n         state->clip_path_ref = rsvg_clip_path_parse (ctx->priv->defs, value);\n     } else if (g_str_equal (name, \"overflow\")) {\n         if (!g_str_equal (value, \"inherit\")) {\ndiff --git a\/rsvg-styles.h b\/rsvg-styles.h\nindex e5ae5d23..472a6c0b 100644\n--- a\/rsvg-styles.h\n+++ b\/rsvg-styles.h\n@@ -80,7 +80,7 @@ struct _RsvgState {\n     cairo_matrix_t personal_affine;\n \n     RsvgFilter *filter;\n-    void *mask;\n+    char *mask;\n     void *clip_path_ref;\n     guint8 adobe_blend;         \/* 0..11 *\/\n     guint8 opacity;             \/* 0..255 *\/\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1428","CWE_ID":"20","category":"security","commit_id":"c265cad1c95b84abfd4e8d861f25926ef13b5d91","commit_message":"From c265cad1c95b84abfd4e8d861f25926ef13b5d91 Mon Sep 17 00:00:00 2001\nFrom: Gu1ll4um3r0m41n <aeroxteam@gmail.com>\nDate: Wed, 2 Mar 2011 15:20:36 +0100\nSubject: [PATCH] Fix verification of SSL certificates by calling gnutls verify\n callback (patch #7459)\n\n---\n ChangeLog                    |   4 +-\n src\/core\/wee-hook.c          |  38 ++++-\n src\/core\/wee-hook.h          |   4 +-\n src\/core\/wee-network.c       |   2 +\n src\/plugins\/irc\/irc-server.c | 334 ++++++++++++++++++++++---------------------\n src\/plugins\/weechat-plugin.h |   6 +-\n 6 files changed, 219 insertions(+), 169 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 51f7306..c020549 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,12 +1,14 @@\n WeeChat ChangeLog\n =================\n S\u00c3\u00a9bastien Helleu <flashcode@flashtux.org>\n-v0.3.5-dev, 2011-03-01\n+v0.3.5-dev, 2011-03-02\n \n \n Version 0.3.5 (under dev!)\n --------------------------\n \n+* core: fix verification of SSL certificates by calling gnutls verify callback\n+  (patch #7459)\n * core: remember scroll position for all buffers in windows (bug #25555)\n * core: fix crash when using column filling in bars with some empty items\n   (bug #32565)\ndiff --git a\/src\/core\/wee-hook.c b\/src\/core\/wee-hook.c\nindex 8794206..606c878 100644\n--- a\/src\/core\/wee-hook.c\n+++ b\/src\/core\/wee-hook.c\n@@ -1700,7 +1700,40 @@ hook_connect (struct t_weechat_plugin *plugin, const char *proxy, const char *ad\n }\n \n \/*\n- * hook_connect_gnutls_set_certificates: set gnutls\n+ * hook_connect_gnutls_verify_certificates: verify certificates\n+ *\/\n+\n+#ifdef HAVE_GNUTLS\n+int\n+hook_connect_gnutls_verify_certificates (gnutls_session_t tls_session)\n+{\n+    struct t_hook *ptr_hook;\n+    int rc;\n+    \n+    rc = -1;\n+    ptr_hook = weechat_hooks[HOOK_TYPE_CONNECT];\n+    while (ptr_hook)\n+    {\n+        \/* looking for the right hook using to the gnutls session pointer *\/\n+        if (!ptr_hook->deleted\n+            && HOOK_CONNECT(ptr_hook, gnutls_sess)\n+            && (*(HOOK_CONNECT(ptr_hook, gnutls_sess)) == tls_session))\n+        {\n+            rc = (int) (HOOK_CONNECT(ptr_hook, gnutls_cb))\n+                (ptr_hook->callback_data, tls_session, NULL, 0,\n+                 NULL, 0, NULL,\n+                 WEECHAT_HOOK_CONNECT_GNUTLS_CB_VERIFY_CERT);\n+            break;\n+        }\n+        ptr_hook = ptr_hook->next_hook;\n+    }\n+    \n+    return rc;\n+}\n+#endif\n+\n+\/*\n+ * hook_connect_gnutls_set_certificates: set certificates\n  *\/\n \n #ifdef HAVE_GNUTLS\n@@ -1725,7 +1758,8 @@ hook_connect_gnutls_set_certificates (gnutls_session_t tls_session,\n         {\n             rc = (int) (HOOK_CONNECT(ptr_hook, gnutls_cb))\n                 (ptr_hook->callback_data, tls_session, req_ca, nreq,\n-                 pk_algos, pk_algos_len, answer);\n+                 pk_algos, pk_algos_len, answer,\n+                 WEECHAT_HOOK_CONNECT_GNUTLS_CB_SET_CERT);\n             break;\n         }\n         ptr_hook = ptr_hook->next_hook;\ndiff --git a\/src\/core\/wee-hook.h b\/src\/core\/wee-hook.h\nindex a3ae429..4575187 100644\n--- a\/src\/core\/wee-hook.h\n+++ b\/src\/core\/wee-hook.h\n@@ -205,7 +205,8 @@ typedef int (t_hook_callback_connect)(void *data, int status,\n typedef int (gnutls_callback_t)(void *data, gnutls_session_t tls_session,\n                                 const gnutls_datum_t *req_ca, int nreq,\n                                 const gnutls_pk_algorithm_t *pk_algos,\n-                                int pk_algos_len, gnutls_retr_st *answer);\n+                                int pk_algos_len, gnutls_retr_st *answer,\n+                                int action);\n #endif\n \n struct t_hook_connect\n@@ -411,6 +412,7 @@ extern struct t_hook *hook_connect (struct t_weechat_plugin *plugin,\n                                     t_hook_callback_connect *callback,\n                                     void *callback_data);\n #ifdef HAVE_GNUTLS\n+extern int hook_connect_gnutls_verify_certificates (gnutls_session_t tls_session);\n extern int hook_connect_gnutls_set_certificates (gnutls_session_t tls_session,\n                                                  const gnutls_datum_t *req_ca, int nreq,\n                                                  const gnutls_pk_algorithm_t *pk_algos,\ndiff --git a\/src\/core\/wee-network.c b\/src\/core\/wee-network.c\nindex f74a90b..08fa691 100644\n--- a\/src\/core\/wee-network.c\n+++ b\/src\/core\/wee-network.c\n@@ -94,6 +94,8 @@ network_init ()\n         }\n         free (ca_path);\n     }\n+    gnutls_certificate_set_verify_function (gnutls_xcred,\n+                                            &hook_connect_gnutls_verify_certificates);\n     gnutls_certificate_client_set_retrieve_function (gnutls_xcred,\n                                                      &hook_connect_gnutls_set_certificates);\n     network_init_ok = 1;\ndiff --git a\/src\/plugins\/irc\/irc-server.c b\/src\/plugins\/irc\/irc-server.c\nindex acbc1ca..d39a0cf 100644\n--- a\/src\/plugins\/irc\/irc-server.c\n+++ b\/src\/plugins\/irc\/irc-server.c\n@@ -2805,7 +2805,8 @@ int\n irc_server_gnutls_callback (void *data, gnutls_session_t tls_session,\n                             const gnutls_datum_t *req_ca, int nreq,\n                             const gnutls_pk_algorithm_t *pk_algos,\n-                            int pk_algos_len, gnutls_retr_st *answer)\n+                            int pk_algos_len, gnutls_retr_st *answer,\n+                            int action)\n {\n     struct t_irc_server *server;\n     gnutls_retr_st tls_struct;\n@@ -2837,207 +2838,212 @@ irc_server_gnutls_callback (void *data, gnutls_session_t tls_session,\n     hostname = server->current_address;\n     hostname_match = 0;\n     \n-    weechat_printf (server->buffer,\n-                    _(\"gnutls: connected using %d-bit Diffie-Hellman shared \"\n-                      \"secret exchange\"),\n-                    IRC_SERVER_OPTION_INTEGER (server,\n-                                               IRC_SERVER_OPTION_SSL_DHKEY_SIZE));\n-    if (gnutls_certificate_verify_peers2 (tls_session, &status) < 0)\n+    if (action == WEECHAT_HOOK_CONNECT_GNUTLS_CB_VERIFY_CERT)\n     {\n         weechat_printf (server->buffer,\n-                        _(\"%sgnutls: error while checking peer's certificate\"),\n-                        weechat_prefix (\"error\"));\n-        rc = -1;\n-    }\n-    else\n-    {\n-        \/* some checks *\/\n-        if (status & GNUTLS_CERT_INVALID)\n+                        _(\"gnutls: connected using %d-bit Diffie-Hellman shared \"\n+                          \"secret exchange\"),\n+                        IRC_SERVER_OPTION_INTEGER (server,\n+                                                   IRC_SERVER_OPTION_SSL_DHKEY_SIZE));\n+        if (gnutls_certificate_verify_peers2 (tls_session, &status) < 0)\n         {\n             weechat_printf (server->buffer,\n-                            _(\"%sgnutls: peer's certificate is NOT trusted\"),\n+                            _(\"%sgnutls: error while checking peer's certificate\"),\n                             weechat_prefix (\"error\"));\n             rc = -1;\n         }\n         else\n         {\n-            weechat_printf (server->buffer,\n-                            _(\"gnutls: peer's certificate is trusted\"));\n-        }\n-        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n-        {\n-            weechat_printf (server->buffer,\n-                            _(\"%sgnutls: peer's certificate issuer is unknown\"),\n-                            weechat_prefix (\"error\"));\n-            rc = -1;\n-        }\n-        if (status & GNUTLS_CERT_REVOKED)\n-        {\n-            weechat_printf (server->buffer,\n-                            _(\"%sgnutls: the certificate has been revoked\"),\n-                            weechat_prefix (\"error\"));\n-            rc = -1;\n-        }\n-        \n-        \/* check certificates *\/\n-        if (gnutls_x509_crt_init (&cert_temp) >= 0)\n-        {\n-            cert_list = gnutls_certificate_get_peers (tls_session, &cert_list_len);\n-            if (cert_list)\n+            \/* some checks *\/\n+            if (status & GNUTLS_CERT_INVALID)\n+            {\n+                weechat_printf (server->buffer,\n+                                _(\"%sgnutls: peer's certificate is NOT trusted\"),\n+                                weechat_prefix (\"error\"));\n+                rc = -1;\n+            }\n+            else\n+            {\n+                weechat_printf (server->buffer,\n+                                _(\"gnutls: peer's certificate is trusted\"));\n+            }\n+            if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n             {\n                 weechat_printf (server->buffer,\n-                                NG_(\"gnutls: receiving %d certificate\",\n-                                    \"gnutls: receiving %d certificates\",\n-                                    cert_list_len),\n-                                cert_list_len);\n-                for (i = 0, j = (int) cert_list_len; i < j; i++)\n+                                _(\"%sgnutls: peer's certificate issuer is unknown\"),\n+                                weechat_prefix (\"error\"));\n+                rc = -1;\n+            }\n+            if (status & GNUTLS_CERT_REVOKED)\n+            {\n+                weechat_printf (server->buffer,\n+                                _(\"%sgnutls: the certificate has been revoked\"),\n+                                weechat_prefix (\"error\"));\n+                rc = -1;\n+            }\n+            \n+            \/* check certificates *\/\n+            if (gnutls_x509_crt_init (&cert_temp) >= 0)\n+            {\n+                cert_list = gnutls_certificate_get_peers (tls_session, &cert_list_len);\n+                if (cert_list)\n                 {\n-                    if (gnutls_x509_crt_import (cert_temp, &cert_list[i], GNUTLS_X509_FMT_DER) >= 0)\n+                    weechat_printf (server->buffer,\n+                                    NG_(\"gnutls: receiving %d certificate\",\n+                                        \"gnutls: receiving %d certificates\",\n+                                        cert_list_len),\n+                                    cert_list_len);\n+                    for (i = 0, j = (int) cert_list_len; i < j; i++)\n                     {\n-                        \/* checking if hostname matches in the first certificate *\/\n-                        if (i == 0 && gnutls_x509_crt_check_hostname (cert_temp, hostname) != 0)\n+                        if (gnutls_x509_crt_import (cert_temp, &cert_list[i], GNUTLS_X509_FMT_DER) >= 0)\n                         {\n-                            hostname_match = 1;\n-                        }\n+                            \/* checking if hostname matches in the first certificate *\/\n+                            if ((i == 0) && (gnutls_x509_crt_check_hostname (cert_temp, hostname) != 0))\n+                            {\n+                                hostname_match = 1;\n+                            }\n #if LIBGNUTLS_VERSION_NUMBER >= 0x010706\n-                        \/* displaying infos about certificate *\/\n+                            \/* displaying infos about certificate *\/\n #if LIBGNUTLS_VERSION_NUMBER < 0x020400\n-                        rinfo = gnutls_x509_crt_print (cert_temp, GNUTLS_X509_CRT_ONELINE, &cinfo);\n+                            rinfo = gnutls_x509_crt_print (cert_temp, GNUTLS_X509_CRT_ONELINE, &cinfo);\n #else\n-                        rinfo = gnutls_x509_crt_print (cert_temp, GNUTLS_CRT_PRINT_ONELINE, &cinfo);\n+                            rinfo = gnutls_x509_crt_print (cert_temp, GNUTLS_CRT_PRINT_ONELINE, &cinfo);\n #endif\n-                        if (rinfo == 0)\n-                        {\n-                            weechat_printf (server->buffer,\n-                                            _(\" - certificate[%d] info:\"), i + 1);\n-                            weechat_printf (server->buffer,\n-                                            \"   - %s\", cinfo.data);\n-                            gnutls_free (cinfo.data);\n-                        }\n+                            if (rinfo == 0)\n+                            {\n+                                weechat_printf (server->buffer,\n+                                                _(\" - certificate[%d] info:\"), i + 1);\n+                                weechat_printf (server->buffer,\n+                                                \"   - %s\", cinfo.data);\n+                                gnutls_free (cinfo.data);\n+                            }\n #endif\n-                        \/* check expiration date *\/\n-                        cert_time = gnutls_x509_crt_get_expiration_time (cert_temp);\n-                        if (cert_time < time(NULL))\n-                        {\n-                            weechat_printf (server->buffer,\n-                                            _(\"%sgnutls: certificate has expired\"),\n-                                            weechat_prefix (\"error\"));\n-                            rc = -1;\n-                        }\n-                        \/* check expiration date *\/\n-                        cert_time = gnutls_x509_crt_get_activation_time (cert_temp);\n-                        if (cert_time > time(NULL))\n-                        {\n-                            weechat_printf (server->buffer,\n-                                            _(\"%sgnutls: certificate is not yet activated\"),\n-                                            weechat_prefix (\"error\"));\n-                            rc = -1;\n+                            \/* check expiration date *\/\n+                            cert_time = gnutls_x509_crt_get_expiration_time (cert_temp);\n+                            if (cert_time < time (NULL))\n+                            {\n+                                weechat_printf (server->buffer,\n+                                                _(\"%sgnutls: certificate has expired\"),\n+                                                weechat_prefix (\"error\"));\n+                                rc = -1;\n+                            }\n+                            \/* check activation date *\/\n+                            cert_time = gnutls_x509_crt_get_activation_time (cert_temp);\n+                            if (cert_time > time (NULL))\n+                            {\n+                                weechat_printf (server->buffer,\n+                                                _(\"%sgnutls: certificate is not yet activated\"),\n+                                                weechat_prefix (\"error\"));\n+                                rc = -1;\n+                            }\n                         }\n                     }\n-                }\n-                if (hostname_match == 0)\n-                {\n-                    weechat_printf (server->buffer,\n-                                    _(\"%sgnutls: the hostname in the \"\n-                                      \"certificate does NOT match \\\"%s\\\"\"),\n-                                    weechat_prefix (\"error\"), hostname);\n-                    rc = -1;\n+                    if (hostname_match == 0)\n+                    {\n+                        weechat_printf (server->buffer,\n+                                        _(\"%sgnutls: the hostname in the \"\n+                                          \"certificate does NOT match \\\"%s\\\"\"),\n+                                        weechat_prefix (\"error\"), hostname);\n+                        rc = -1;\n+                    }\n                 }\n             }\n         }\n     }\n-    \n-    \/* using client certificate if it exists *\/\n-    cert_path0 = (char *) IRC_SERVER_OPTION_STRING(server,\n-                                                   IRC_SERVER_OPTION_SSL_CERT);\n-    if (cert_path0 && cert_path0[0])\n+    else if (action == WEECHAT_HOOK_CONNECT_GNUTLS_CB_SET_CERT)\n     {\n-        weechat_dir = weechat_info_get (\"weechat_dir\", \"\");\n-        cert_path1 = weechat_string_replace (cert_path0, \"%h\", weechat_dir);\n-        cert_path2 = (cert_path1) ?\n-            weechat_string_expand_home (cert_path1) : NULL;\n-        \n-        if (cert_path2)\n+        \/* using client certificate if it exists *\/\n+        cert_path0 = (char *) IRC_SERVER_OPTION_STRING(server,\n+                                                       IRC_SERVER_OPTION_SSL_CERT);\n+        if (cert_path0 && cert_path0[0])\n         {\n-            cert_str = weechat_file_get_content (cert_path2);\n-            if (cert_str)\n+            weechat_dir = weechat_info_get (\"weechat_dir\", \"\");\n+            cert_path1 = weechat_string_replace (cert_path0, \"%h\", weechat_dir);\n+            cert_path2 = (cert_path1) ?\n+                weechat_string_expand_home (cert_path1) : NULL;\n+            \n+            if (cert_path2)\n             {\n-                weechat_printf (server->buffer,\n-                                _(\"gnutls: sending one certificate\"));\n-                \n-                filedatum.data = (unsigned char *) cert_str;\n-                filedatum.size = strlen (cert_str);\n-                \n-                \/* certificate *\/\n-                gnutls_x509_crt_init (&server->tls_cert);\n-                gnutls_x509_crt_import (server->tls_cert, &filedatum,\n-                                        GNUTLS_X509_FMT_PEM);\n-                \n-                \/* key *\/\n-                gnutls_x509_privkey_init (&server->tls_cert_key);\n-                ret = gnutls_x509_privkey_import (server->tls_cert_key,\n-                                                  &filedatum,\n-                                                  GNUTLS_X509_FMT_PEM);\n-                if (ret < 0)\n-                {\n-                    ret = gnutls_x509_privkey_import_pkcs8 (server->tls_cert_key,\n-                                                            &filedatum,\n-                                                            GNUTLS_X509_FMT_PEM,\n-                                                            NULL,\n-                                                            GNUTLS_PKCS_PLAIN);\n-                }\n-                if (ret < 0)\n+                cert_str = weechat_file_get_content (cert_path2);\n+                if (cert_str)\n                 {\n                     weechat_printf (server->buffer,\n-                                    _(\"%sgnutls: invalid certificate \\\"%s\\\", \"\n-                                      \"error: %s\"),\n-                                    weechat_prefix (\"error\"), cert_path2,\n-                                    gnutls_strerror (ret));\n-                    rc = -1;\n-                }\n-                else\n-                {\n-                    tls_struct.type = GNUTLS_CRT_X509;\n-                    tls_struct.ncerts = 1;\n-                    tls_struct.deinit_all = 0;\n-                    tls_struct.cert.x509 = &server->tls_cert;\n-                    tls_struct.key.x509 = server->tls_cert_key;\n+                                    _(\"gnutls: sending one certificate\"));\n+                    \n+                    filedatum.data = (unsigned char *) cert_str;\n+                    filedatum.size = strlen (cert_str);\n+                    \n+                    \/* certificate *\/\n+                    gnutls_x509_crt_init (&server->tls_cert);\n+                    gnutls_x509_crt_import (server->tls_cert, &filedatum,\n+                                            GNUTLS_X509_FMT_PEM);\n+                    \n+                    \/* key *\/\n+                    gnutls_x509_privkey_init (&server->tls_cert_key);\n+                    ret = gnutls_x509_privkey_import (server->tls_cert_key,\n+                                                      &filedatum,\n+                                                      GNUTLS_X509_FMT_PEM);\n+                    if (ret < 0)\n+                    {\n+                        ret = gnutls_x509_privkey_import_pkcs8 (server->tls_cert_key,\n+                                                                &filedatum,\n+                                                                GNUTLS_X509_FMT_PEM,\n+                                                                NULL,\n+                                                                GNUTLS_PKCS_PLAIN);\n+                    }\n+                    if (ret < 0)\n+                    {\n+                        weechat_printf (server->buffer,\n+                                        _(\"%sgnutls: invalid certificate \\\"%s\\\", \"\n+                                          \"error: %s\"),\n+                                        weechat_prefix (\"error\"), cert_path2,\n+                                        gnutls_strerror (ret));\n+                        rc = -1;\n+                    }\n+                    else\n+                    {\n+                        tls_struct.type = GNUTLS_CRT_X509;\n+                        tls_struct.ncerts = 1;\n+                        tls_struct.deinit_all = 0;\n+                        tls_struct.cert.x509 = &server->tls_cert;\n+                        tls_struct.key.x509 = server->tls_cert_key;\n #if LIBGNUTLS_VERSION_NUMBER >= 0x010706\n-                    \/* client certificate info *\/\n+                        \/* client certificate info *\/\n #if LIBGNUTLS_VERSION_NUMBER < 0x020400\n-                    rinfo = gnutls_x509_crt_print (server->tls_cert,\n-                                                   GNUTLS_X509_CRT_ONELINE,\n-                                                   &cinfo);\n+                        rinfo = gnutls_x509_crt_print (server->tls_cert,\n+                                                       GNUTLS_X509_CRT_ONELINE,\n+                                                       &cinfo);\n #else\n-                    rinfo = gnutls_x509_crt_print (server->tls_cert,\n-                                                   GNUTLS_CRT_PRINT_ONELINE,\n-                                                   &cinfo);\n+                        rinfo = gnutls_x509_crt_print (server->tls_cert,\n+                                                       GNUTLS_CRT_PRINT_ONELINE,\n+                                                       &cinfo);\n #endif\n-                    if (rinfo == 0)\n-                    {\n-                        weechat_printf (server->buffer,\n-                                        _(\" - client certificate info (%s):\"),\n-                                        cert_path2);\n-                        weechat_printf (server->buffer, \"  - %s\", cinfo.data);\n-                        gnutls_free (cinfo.data);\n-                    }\n+                        if (rinfo == 0)\n+                        {\n+                            weechat_printf (server->buffer,\n+                                            _(\" - client certificate info (%s):\"),\n+                                            cert_path2);\n+                            weechat_printf (server->buffer, \"  - %s\", cinfo.data);\n+                            gnutls_free (cinfo.data);\n+                        }\n #endif\n-                    memcpy (answer, &tls_struct, sizeof (gnutls_retr_st));\n-                    free (cert_str);\n+                        memcpy (answer, &tls_struct, sizeof (gnutls_retr_st));\n+                        free (cert_str);\n+                    }\n+                }\n+                else\n+                {\n+                    weechat_printf (server->buffer,\n+                                    _(\"%sgnutls: unable to read certifcate \\\"%s\\\"\"),\n+                                    weechat_prefix (\"error\"), cert_path2);\n                 }\n             }\n-            else\n-            {\n-                weechat_printf (server->buffer,\n-                                _(\"%sgnutls: unable to read certifcate \\\"%s\\\"\"),\n-                                weechat_prefix (\"error\"), cert_path2);\n-            }\n+            \n+            if (cert_path1)\n+                free (cert_path1);\n+            if (cert_path2)\n+                free (cert_path2);\n         }\n-        \n-        if (cert_path1)\n-            free (cert_path1);\n-        if (cert_path2)\n-            free (cert_path2);\n     }\n     \n     \/* an error should stop the handshake unless the user doesn't care *\/\ndiff --git a\/src\/plugins\/weechat-plugin.h b\/src\/plugins\/weechat-plugin.h\nindex 8f45504..c5a8433 100644\n--- a\/src\/plugins\/weechat-plugin.h\n+++ b\/src\/plugins\/weechat-plugin.h\n@@ -45,7 +45,7 @@ struct timeval;\n  *\/\n \n \/* API version (used to check that plugin has same API and can be loaded) *\/\n-#define WEECHAT_PLUGIN_API_VERSION \"20110102-01\"\n+#define WEECHAT_PLUGIN_API_VERSION \"20110302-01\"\n \n \/* macros for defining plugin infos *\/\n #define WEECHAT_PLUGIN_NAME(__name)                                     \\\n@@ -127,6 +127,10 @@ struct timeval;\n #define WEECHAT_HOOK_CONNECT_GNUTLS_HANDSHAKE_ERROR 7\n #define WEECHAT_HOOK_CONNECT_MEMORY_ERROR           8\n \n+\/* action for gnutls callback: verify or set certificate *\/\n+#define WEECHAT_HOOK_CONNECT_GNUTLS_CB_VERIFY_CERT  0\n+#define WEECHAT_HOOK_CONNECT_GNUTLS_CB_SET_CERT     1\n+\n \/* type of data for signal hooked *\/\n #define WEECHAT_HOOK_SIGNAL_STRING                  \"string\"\n #define WEECHAT_HOOK_SIGNAL_INT                     \"int\"\n-- \n1.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-3215","CWE_ID":"20","category":"security","commit_id":"723416fa4210b7464b28eab89cc76252e6193ac1","commit_message":"From 723416fa4210b7464b28eab89cc76252e6193ac1 Mon Sep 17 00:00:00 2001\nFrom: Joseph Hindin <yhindin@rehat.com>\nDate: Mon, 15 Dec 2014 23:38:21 +0200\nSubject: [PATCH] NetKVM: BZ#1169718: Checking the length only on read\n\nSigned-off-by: Joseph Hindin <yhindin@rehat.com>\n---\n NetKVM\/Common\/ParaNdis-Common.cpp |  6 ++++--\n NetKVM\/Common\/ParaNdis-TX.cpp     |  5 +++--\n NetKVM\/Common\/ndis56common.h      |  9 ++++++---\n NetKVM\/Common\/sw-offload.cpp      | 18 ++++++++++--------\n NetKVM\/wlh\/ParaNdis6-Impl.cpp     |  2 +-\n 5 files changed, 24 insertions(+), 16 deletions(-)\n\n","diff_code":"diff --git a\/NetKVM\/Common\/ParaNdis-Common.cpp b\/NetKVM\/Common\/ParaNdis-Common.cpp\nindex 799fb91..9024ba6 100644\n--- a\/NetKVM\/Common\/ParaNdis-Common.cpp\n+++ b\/NetKVM\/Common\/ParaNdis-Common.cpp\n@@ -2219,7 +2219,8 @@ tChecksumCheckResult ParaNdis_CheckRxChecksum(\n                                             ULONG virtioFlags,\n                                             tCompletePhysicalAddress *pPacketPages,\n                                             ULONG ulPacketLength,\n-                                            ULONG ulDataOffset)\n+                                            ULONG ulDataOffset,\n+                                            BOOLEAN verifyLength)\n {\n     tOffloadSettingsFlags f = pContext->Offload.flags;\n     tChecksumCheckResult res;\n@@ -2247,7 +2248,8 @@ tChecksumCheckResult ParaNdis_CheckRxChecksum(\n         }\n     }\n \n-    ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);\n+    ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate,\n+        verifyLength, __FUNCTION__);\n \n     if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)\n     {\ndiff --git a\/NetKVM\/Common\/ParaNdis-TX.cpp b\/NetKVM\/Common\/ParaNdis-TX.cpp\nindex ad265bb..2820db2 100644\n--- a\/NetKVM\/Common\/ParaNdis-TX.cpp\n+++ b\/NetKVM\/Common\/ParaNdis-TX.cpp\n@@ -649,6 +649,7 @@ void CNB::SetupLSO(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG Eth\n     tTcpIpPacketParsingResult packetReview;\n     packetReview = ParaNdis_CheckSumVerifyFlat(reinterpret_cast<IPv4Header*>(IpHeader), EthPayloadLength,\n                                                pcrIpChecksum | pcrFixIPChecksum | pcrTcpChecksum | pcrFixPHChecksum,\n+                                               FALSE,\n                                                __FUNCTION__);\n \n     if (packetReview.xxpCheckSum == ppresPCSOK || packetReview.fixedXxpCS)\n@@ -670,7 +671,7 @@ USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n {\n     USHORT Res;\n     auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n-                                       GetDataLength(), __FUNCTION__);\n+                                       GetDataLength(), FALSE, __FUNCTION__);\n     if (ppr.ipStatus != ppresNotIP)\n     {\n         Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n@@ -696,7 +697,7 @@ void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const\n {\n     ParaNdis_CheckSumVerifyFlat(IpHeader,\n                                 EthPayloadLength,\n-                                pcrIpChecksum | pcrFixIPChecksum,\n+                                pcrIpChecksum | pcrFixIPChecksum, FALSE,\n                                 __FUNCTION__);\n }\n \ndiff --git a\/NetKVM\/Common\/ndis56common.h b\/NetKVM\/Common\/ndis56common.h\nindex e660d82..e61e021 100644\n--- a\/NetKVM\/Common\/ndis56common.h\n+++ b\/NetKVM\/Common\/ndis56common.h\n@@ -744,7 +744,8 @@ tChecksumCheckResult ParaNdis_CheckRxChecksum(\n                                             ULONG virtioFlags,\n                                             tCompletePhysicalAddress *pPacketPages,\n                                             ULONG ulPacketLength,\n-                                            ULONG ulDataOffset);\n+                                            ULONG ulDataOffset,\n+                                            BOOLEAN verifyLength);\n \n void ParaNdis_CallOnBugCheck(PARANDIS_ADAPTER *pContext);\n \n@@ -917,6 +918,7 @@ tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                 ULONG ulDataLength,\n                                                 ULONG ulStartOffset,\n                                                 ULONG flags,\n+                                                BOOLEAN verifyLength,\n                                                 LPCSTR caller);\n \n static __inline\n@@ -924,15 +926,16 @@ tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                 PVOID pBuffer,\n                                                 ULONG ulDataLength,\n                                                 ULONG flags,\n+                                                BOOLEAN verifyLength,\n                                                 LPCSTR caller)\n {\n     tCompletePhysicalAddress SGBuffer;\n     SGBuffer.Virtual = pBuffer;\n     SGBuffer.size = ulDataLength;\n-    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n+    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, verifyLength, caller);\n }\n \n-tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller);\n+tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, BOOLEAN verityLength, LPCSTR caller);\n \n BOOLEAN ParaNdis_AnalyzeReceivedPacket(PVOID headersBuffer, ULONG dataLength, PNET_PACKET_INFO packetInfo);\n ULONG ParaNdis_StripVlanHeaderMoveHead(PNET_PACKET_INFO packetInfo);\ndiff --git a\/NetKVM\/Common\/sw-offload.cpp b\/NetKVM\/Common\/sw-offload.cpp\nindex 2be3d80..f212945 100644\n--- a\/NetKVM\/Common\/sw-offload.cpp\n+++ b\/NetKVM\/Common\/sw-offload.cpp\n@@ -200,7 +200,7 @@ ProcessUDPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USH\n }\n \n static __inline tTcpIpPacketParsingResult\n-QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n+QualifyIpPacket(IPHeader *pIpHeader, ULONG len, BOOLEAN verifyLength)\n {\n     tTcpIpPacketParsingResult res;\n     res.value = 0;\n@@ -235,10 +235,10 @@ QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n             return res;\n         }\n \n-        if (ipHeaderSize >= fullLength || len < fullLength)\n+        if (ipHeaderSize >= fullLength || ( verifyLength && len < fullLength))\n         {\n-            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\", __FUNCTION__,\n-                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n+            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d, verify = %s\\n\", __FUNCTION__,\n+                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len, (verifyLength ? \"true\" : \"false\")));\n             res.ipCheckSum = ppresIPTooShort;\n             return res;\n         }\n@@ -258,7 +258,8 @@ QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n         res.ipCheckSum = ppresCSOK;\n         fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n         fullLength += ipHeaderSize;\n-        if (len < fullLength)\n+\n+        if (verifyLength && (len < fullLength))\n         {\n             res.ipStatus = ppresNotIP;\n             return res;\n@@ -648,11 +649,12 @@ tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                 ULONG ulDataLength,\n                                                 ULONG ulStartOffset,\n                                                 ULONG flags,\n+                                                BOOLEAN verifyLength,\n                                                 LPCSTR caller)\n {\n     IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n \n-    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);\n+    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength, verifyLength);\n     if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)\n         return res;\n \n@@ -702,9 +704,9 @@ tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n     return res;\n }\n \n-tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n+tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, BOOLEAN verifyLength, LPCSTR caller)\n {\n-    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n+    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size, verifyLength);\n     PrintOutParsingResult(res, 1, caller);\n     return res;\n }\ndiff --git a\/NetKVM\/wlh\/ParaNdis6-Impl.cpp b\/NetKVM\/wlh\/ParaNdis6-Impl.cpp\nindex 8b207d5..f7cfd62 100644\n--- a\/NetKVM\/wlh\/ParaNdis6-Impl.cpp\n+++ b\/NetKVM\/wlh\/ParaNdis6-Impl.cpp\n@@ -866,7 +866,7 @@ tPacketIndicationType ParaNdis_PrepareReceivedPacket(\n                     pHeader->flags,\n                     &pBuffersDesc->PhysicalPages[PARANDIS_FIRST_RX_DATA_PAGE],\n                     pPacketInfo->dataLength,\n-                    nBytesStripped);\n+                    nBytesStripped, TRUE);\n                 if (csRes.value)\n                 {\n                     NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;\n","owner":"YanVugenfirer","repo":"kvm-guest-drivers-windows","source":"cve"},{"CVE_ID":"CVE-2007-4567","CWE_ID":"20","category":"security","commit_id":"e76b2b2567b83448c2ee85a896433b96150c92e6","commit_message":"From e76b2b2567b83448c2ee85a896433b96150c92e6 Mon Sep 17 00:00:00 2001\nFrom: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\nDate: Wed, 9 May 2007 14:01:59 -0700\nSubject: [IPV6]: Do no rely on skb->dst before it is assigned.\n\nBecause skb->dst is assigned in ip6_route_input(), it is really\nbad to use it in hop-by-hop option handler(s).\n\nCloses: Bug #8450 (Eric Sesterhenn <snakebyte@gmx.de>)\nSigned-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/exthdrs.c | 16 ++++++++++++----\n 1 file changed, 12 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/exthdrs.c b\/net\/ipv6\/exthdrs.c\nindex 6d8e4ac7bdad..14be0b9b77a5 100644\n--- a\/net\/ipv6\/exthdrs.c\n+++ b\/net\/ipv6\/exthdrs.c\n@@ -660,6 +660,14 @@ EXPORT_SYMBOL_GPL(ipv6_invert_rthdr);\n   Hop-by-hop options.\n  **********************************\/\n \n+\/*\n+ * Note: we cannot rely on skb->dst before we assign it in ip6_route_input().\n+ *\/\n+static inline struct inet6_dev *ipv6_skb_idev(struct sk_buff *skb)\n+{\n+\treturn skb->dst ? ip6_dst_idev(skb->dst) : __in6_dev_get(skb->dev);\n+}\n+\n \/* Router Alert as of RFC 2711 *\/\n \n static int ipv6_hop_ra(struct sk_buff **skbp, int optoff)\n@@ -688,25 +696,25 @@ static int ipv6_hop_jumbo(struct sk_buff **skbp, int optoff)\n \tif (nh[optoff + 1] != 4 || (optoff & 3) != 2) {\n \t\tLIMIT_NETDEBUG(KERN_DEBUG \"ipv6_hop_jumbo: wrong jumbo opt length\/alignment %d\\n\",\n \t\t\t       nh[optoff+1]);\n-\t\tIP6_INC_STATS_BH(ip6_dst_idev(skb->dst),\n+\t\tIP6_INC_STATS_BH(ipv6_skb_idev(skb),\n \t\t\t\t IPSTATS_MIB_INHDRERRORS);\n \t\tgoto drop;\n \t}\n \n \tpkt_len = ntohl(*(__be32 *)(nh + optoff + 2));\n \tif (pkt_len <= IPV6_MAXPLEN) {\n-\t\tIP6_INC_STATS_BH(ip6_dst_idev(skb->dst), IPSTATS_MIB_INHDRERRORS);\n+\t\tIP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);\n \t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff+2);\n \t\treturn 0;\n \t}\n \tif (ipv6_hdr(skb)->payload_len) {\n-\t\tIP6_INC_STATS_BH(ip6_dst_idev(skb->dst), IPSTATS_MIB_INHDRERRORS);\n+\t\tIP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);\n \t\ticmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff);\n \t\treturn 0;\n \t}\n \n \tif (pkt_len > skb->len - sizeof(struct ipv6hdr)) {\n-\t\tIP6_INC_STATS_BH(ip6_dst_idev(skb->dst), IPSTATS_MIB_INTRUNCATEDPKTS);\n+\t\tIP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INTRUNCATEDPKTS);\n \t\tgoto drop;\n \t}\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4544","CWE_ID":"20","category":"security","commit_id":"3c99afc779c2c78718a565ad8c5e98de7c2c7484","commit_message":"From 3c99afc779c2c78718a565ad8c5e98de7c2c7484 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Fleytman <dmitry@daynix.com>\nDate: Fri, 4 Apr 2014 12:45:21 +0300\nSubject: [PATCH] vmxnet3: validate interrupt indices read on migration\n\nCVE-2013-4544\n\nSigned-off-by: Dmitry Fleytman <dmitry@daynix.com>\nReported-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Dr. David Alan Gilbert <dgilbert@redhat.com>\nMessage-id: 1396604722-11902-4-git-send-email-dmitry@daynix.com\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>\n---\n hw\/net\/vmxnet3.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/hw\/net\/vmxnet3.c b\/hw\/net\/vmxnet3.c\nindex 4fefc7b..a0723c0 100644\n--- a\/hw\/net\/vmxnet3.c\n+++ b\/hw\/net\/vmxnet3.c\n@@ -2391,6 +2391,8 @@ static int vmxnet3_post_load(void *opaque, int version_id)\n         }\n     }\n \n+    vmxnet3_validate_interrupts(s);\n+\n     return 0;\n }\n \n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-4818","CWE_ID":"20","category":"security","commit_id":"6c69235a9dfc52e4b4e47630ff4bab1a820eb543","commit_message":"From 6c69235a9dfc52e4b4e47630ff4bab1a820eb543 Mon Sep 17 00:00:00 2001\nFrom: Julien Cristau <jcristau@debian.org>\nDate: Sun, 22 Aug 2010 00:50:05 +0100\nSubject: glx: check request length before swapping\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nReviewed-by: Kristian H\u00f8gsberg <krh@bitplanet.net>\nReviewed-by: Daniel Stone <daniel@fooishbar.org>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n glx\/glxcmdsswap.c | 135 ++++++++++++++++++++++++++++++++++++++++++++++++++++--\n 1 file changed, 130 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/glx\/glxcmdsswap.c b\/glx\/glxcmdsswap.c\nindex ce4d69a..9276e2f 100644\n--- a\/glx\/glxcmdsswap.c\n+++ b\/glx\/glxcmdsswap.c\n@@ -60,9 +60,12 @@\n \n int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateContextReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->visual);\n@@ -74,9 +77,12 @@ int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_CreateNewContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateNewContextReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->fbconfig);\n@@ -89,10 +95,13 @@ int __glXDispSwap_CreateNewContext(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_CreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateContextWithConfigSGIXReq *req =\n \t(xGLXCreateContextWithConfigSGIXReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateContextWithConfigSGIXReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->fbconfig);\n@@ -105,9 +114,12 @@ int __glXDispSwap_CreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_DestroyContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyContextReq *req = (xGLXDestroyContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyContextReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n \n@@ -116,9 +128,12 @@ int __glXDispSwap_DestroyContext(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_MakeCurrent(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXMakeCurrentReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->drawable);\n     __GLX_SWAP_INT(&req->context);\n@@ -129,9 +144,12 @@ int __glXDispSwap_MakeCurrent(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_MakeContextCurrent(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXMakeContextCurrentReq *req = (xGLXMakeContextCurrentReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXMakeContextCurrentReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->drawable);\n     __GLX_SWAP_INT(&req->readdrawable);\n@@ -143,9 +161,12 @@ int __glXDispSwap_MakeContextCurrent(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_MakeCurrentReadSGI(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXMakeCurrentReadSGIReq *req = (xGLXMakeCurrentReadSGIReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXMakeCurrentReadSGIReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->drawable);\n     __GLX_SWAP_INT(&req->readable);\n@@ -157,9 +178,12 @@ int __glXDispSwap_MakeCurrentReadSGI(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_IsDirect(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXIsDirectReq *req = (xGLXIsDirectReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXIsDirectReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n \n@@ -168,9 +192,12 @@ int __glXDispSwap_IsDirect(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_QueryVersion(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXQueryVersionReq *req = (xGLXQueryVersionReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryVersionReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->majorVersion);\n     __GLX_SWAP_INT(&req->minorVersion);\n@@ -180,9 +207,12 @@ int __glXDispSwap_QueryVersion(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_WaitGL(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXWaitGLReq *req = (xGLXWaitGLReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXWaitGLReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->contextTag);\n \n@@ -191,9 +221,12 @@ int __glXDispSwap_WaitGL(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_WaitX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXWaitXReq *req = (xGLXWaitXReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXWaitXReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->contextTag);\n \n@@ -202,9 +235,12 @@ int __glXDispSwap_WaitX(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_CopyContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCopyContextReq *req = (xGLXCopyContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXCopyContextReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->source);\n     __GLX_SWAP_INT(&req->dest);\n@@ -215,36 +251,48 @@ int __glXDispSwap_CopyContext(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_GetVisualConfigs(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetVisualConfigsReq *req = (xGLXGetVisualConfigsReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXGetVisualConfigsReq);\n+\n     __GLX_SWAP_INT(&req->screen);\n     return __glXDisp_GetVisualConfigs(cl, pc);\n }\n \n int __glXDispSwap_GetFBConfigs(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetFBConfigsReq *req = (xGLXGetFBConfigsReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXGetFBConfigsReq);\n+\n     __GLX_SWAP_INT(&req->screen);\n     return __glXDisp_GetFBConfigs(cl, pc);\n }\n \n int __glXDispSwap_GetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXGetFBConfigsSGIXReq);\n+\n     __GLX_SWAP_INT(&req->screen);\n     return __glXDisp_GetFBConfigsSGIX(cl, pc);\n }\n \n int __glXDispSwap_CreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateGLXPixmapReq *req = (xGLXCreateGLXPixmapReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateGLXPixmapReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->screen);\n     __GLX_SWAP_INT(&req->visual);\n@@ -256,17 +304,22 @@ int __glXDispSwap_CreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_CreatePixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreatePixmapReq *req = (xGLXCreatePixmapReq *) pc;\n     CARD32 *attribs;\n     __GLX_DECLARE_SWAP_VARIABLES;\n     __GLX_DECLARE_SWAP_ARRAY_VARIABLES;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXCreatePixmapReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->screen);\n     __GLX_SWAP_INT(&req->fbconfig);\n     __GLX_SWAP_INT(&req->pixmap);\n     __GLX_SWAP_INT(&req->glxpixmap);\n     __GLX_SWAP_INT(&req->numAttribs);\n+\n+    REQUEST_FIXED_SIZE(xGLXCreatePixmapReq, req->numAttribs << 3);\n     attribs = (CARD32*)(req + 1);\n     __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs);\n \n@@ -275,10 +328,13 @@ int __glXDispSwap_CreatePixmap(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_CreateGLXPixmapWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateGLXPixmapWithConfigSGIXReq *req = \n \t(xGLXCreateGLXPixmapWithConfigSGIXReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateGLXPixmapWithConfigSGIXReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->screen);\n     __GLX_SWAP_INT(&req->fbconfig);\n@@ -290,9 +346,12 @@ int __glXDispSwap_CreateGLXPixmapWithConfigSGIX(__GLXclientState *cl, GLbyte *pc\n \n int __glXDispSwap_DestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyGLXPixmapReq *req = (xGLXDestroyGLXPixmapReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyGLXPixmapReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->glxpixmap);\n \n@@ -301,9 +360,12 @@ int __glXDispSwap_DestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_DestroyPixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyGLXPixmapReq *req = (xGLXDestroyGLXPixmapReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyGLXPixmapReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->glxpixmap);\n \n@@ -312,9 +374,12 @@ int __glXDispSwap_DestroyPixmap(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_QueryContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXQueryContextReq *req = (xGLXQueryContextReq *) pc;    \n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryContextReq);\n+\n     __GLX_SWAP_INT(&req->context);\n \n     return __glXDisp_QueryContext(cl, pc);\n@@ -322,15 +387,20 @@ int __glXDispSwap_QueryContext(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_CreatePbuffer(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreatePbufferReq *req = (xGLXCreatePbufferReq *) pc;    \n     __GLX_DECLARE_SWAP_VARIABLES;\n     __GLX_DECLARE_SWAP_ARRAY_VARIABLES;\n     CARD32 *attribs;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXCreatePbufferReq);\n+\n     __GLX_SWAP_INT(&req->screen);\n     __GLX_SWAP_INT(&req->fbconfig);\n     __GLX_SWAP_INT(&req->pbuffer);\n     __GLX_SWAP_INT(&req->numAttribs);\n+\n+    REQUEST_FIXED_SIZE(xGLXCreatePbufferReq, req->numAttribs << 3);\n     attribs = (CARD32*)(req + 1);\n     __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs);\n \n@@ -339,9 +409,12 @@ int __glXDispSwap_CreatePbuffer(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_CreateGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateGLXPbufferSGIXReq *req = (xGLXCreateGLXPbufferSGIXReq *) pc;    \n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateGLXPbufferSGIXReq);\n+\n     __GLX_SWAP_INT(&req->screen);\n     __GLX_SWAP_INT(&req->fbconfig);\n     __GLX_SWAP_INT(&req->pbuffer);\n@@ -353,9 +426,12 @@ int __glXDispSwap_CreateGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_DestroyPbuffer(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyPbufferReq);\n+\n     __GLX_SWAP_INT(&req->pbuffer);\n \n     return __glXDisp_DestroyPbuffer(cl, pc);\n@@ -363,9 +439,12 @@ int __glXDispSwap_DestroyPbuffer(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_DestroyGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyGLXPbufferSGIXReq *req = (xGLXDestroyGLXPbufferSGIXReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyGLXPbufferSGIXReq);\n+\n     __GLX_SWAP_INT(&req->pbuffer);\n \n     return __glXDisp_DestroyGLXPbufferSGIX(cl, pc);\n@@ -373,14 +452,19 @@ int __glXDispSwap_DestroyGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_ChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXChangeDrawableAttributesReq *req =\n \t(xGLXChangeDrawableAttributesReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n     __GLX_DECLARE_SWAP_ARRAY_VARIABLES;\n     CARD32 *attribs;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXChangeDrawableAttributesReq);\n+\n     __GLX_SWAP_INT(&req->drawable);\n     __GLX_SWAP_INT(&req->numAttribs);\n+\n+    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesReq, req->numAttribs << 3);\n     attribs = (CARD32*)(req + 1);\n     __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs);\n \n@@ -390,14 +474,19 @@ int __glXDispSwap_ChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)\n int __glXDispSwap_ChangeDrawableAttributesSGIX(__GLXclientState *cl,\n \t\t\t\t\t       GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXChangeDrawableAttributesSGIXReq *req =\n \t(xGLXChangeDrawableAttributesSGIXReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n     __GLX_DECLARE_SWAP_ARRAY_VARIABLES;\n     CARD32 *attribs;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXChangeDrawableAttributesSGIXReq);\n+\n     __GLX_SWAP_INT(&req->drawable);\n     __GLX_SWAP_INT(&req->numAttribs);\n+\n+    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesSGIXReq, req->numAttribs << 3);\n     attribs = (CARD32*)(req + 1);\n     __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs);\n \n@@ -406,16 +495,21 @@ int __glXDispSwap_ChangeDrawableAttributesSGIX(__GLXclientState *cl,\n \n int __glXDispSwap_CreateWindow(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateWindowReq *req = (xGLXCreateWindowReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n     __GLX_DECLARE_SWAP_ARRAY_VARIABLES;\n     CARD32 *attribs;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXCreateWindowReq);\n+\n     __GLX_SWAP_INT(&req->screen);\n     __GLX_SWAP_INT(&req->fbconfig);\n     __GLX_SWAP_INT(&req->window);\n     __GLX_SWAP_INT(&req->glxwindow);\n     __GLX_SWAP_INT(&req->numAttribs);\n+\n+    REQUEST_FIXED_SIZE(xGLXCreateWindowReq, req->numAttribs << 3);\n     attribs = (CARD32*)(req + 1);\n     __GLX_SWAP_INT_ARRAY(attribs, req->numAttribs);\n \n@@ -424,9 +518,12 @@ int __glXDispSwap_CreateWindow(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_DestroyWindow(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyWindowReq *req = (xGLXDestroyWindowReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyWindowReq);\n+\n     __GLX_SWAP_INT(&req->glxwindow);\n \n     return __glXDisp_DestroyWindow(cl, pc);\n@@ -434,9 +531,12 @@ int __glXDispSwap_DestroyWindow(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_SwapBuffers(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXSwapBuffersReq *req = (xGLXSwapBuffersReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXSwapBuffersReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->contextTag);\n     __GLX_SWAP_INT(&req->drawable);\n@@ -446,9 +546,12 @@ int __glXDispSwap_SwapBuffers(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_UseXFont(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXUseXFontReq *req = (xGLXUseXFontReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXUseXFontReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->contextTag);\n     __GLX_SWAP_INT(&req->font);\n@@ -462,9 +565,12 @@ int __glXDispSwap_UseXFont(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_QueryExtensionsString(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXQueryExtensionsStringReq *req = (xGLXQueryExtensionsStringReq *)pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryExtensionsStringReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->screen);\n \n@@ -473,9 +579,12 @@ int __glXDispSwap_QueryExtensionsString(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_QueryServerString(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXQueryServerStringReq *req = (xGLXQueryServerStringReq *)pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryServerStringReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->screen);\n     __GLX_SWAP_INT(&req->name);\n@@ -485,9 +594,12 @@ int __glXDispSwap_QueryServerString(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_ClientInfo(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXClientInfoReq *req = (xGLXClientInfoReq *)pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXClientInfoReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->major);\n     __GLX_SWAP_INT(&req->minor);\n@@ -498,9 +610,12 @@ int __glXDispSwap_ClientInfo(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_QueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXQueryContextInfoEXTReq *req = (xGLXQueryContextInfoEXTReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryContextInfoEXTReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n \n@@ -509,12 +624,14 @@ int __glXDispSwap_QueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_BindTexImageEXT(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;\n     GLXDrawable\t\t *drawId;\n     int\t\t\t *buffer;\n-    \n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 8);\n+\n     pc += __GLX_VENDPRIV_HDR_SIZE;\n \n     drawId = ((GLXDrawable *) (pc));\n@@ -530,12 +647,14 @@ int __glXDispSwap_BindTexImageEXT(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_ReleaseTexImageEXT(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;\n     GLXDrawable\t\t *drawId;\n     int\t\t\t *buffer;\n-    \n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 8);\n+\n     pc += __GLX_VENDPRIV_HDR_SIZE;\n \n     drawId = ((GLXDrawable *) (pc));\n@@ -551,12 +670,14 @@ int __glXDispSwap_ReleaseTexImageEXT(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_CopySubBufferMESA(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;\n     GLXDrawable\t\t *drawId;\n     int\t\t\t *buffer;\n-\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 20);\n+\n     (void) drawId;\n     (void) buffer;\n \n@@ -576,11 +697,13 @@ int __glXDispSwap_CopySubBufferMESA(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_GetDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXVendorPrivateWithReplyReq *req = (xGLXVendorPrivateWithReplyReq *)pc;\n     CARD32 *data;\n-    \n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXGetDrawableAttributesSGIXReq);\n+\n     data = (CARD32 *) (req + 1);\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->contextTag);\n@@ -591,10 +714,12 @@ int __glXDispSwap_GetDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDispSwap_GetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *)pc;\n-    \n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXGetDrawableAttributesReq);\n+\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->drawable);\n \n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-17183","CWE_ID":"20","category":"security","commit_id":"fb713b3818b52d8a6cf62c951eba2e1795ff9624","commit_message":"From fb713b3818b52d8a6cf62c951eba2e1795ff9624 Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Thu, 6 Sep 2018 09:16:22 +0100\nSubject: [PATCH] Bug 699708 (part 1): 'Hide' non-replaceable error handlers\n for SAFER\n\nWe already had a 'private' dictionary for non-standard errors: gserrordict.\n\nThis now includes all the default error handlers, the dictionary is made\nnoaccess and all the prodedures are bound and executeonly.\n\nWhen running with -dSAFER, in the event of a Postscript error, instead of\npulling the handler from errordict, we'll pull it from gserrordict - thus\nmalicious input cannot trigger problems by the use of custom error handlers.\n\nerrordict remains open and writeable, so files such as the Quality Logic tests\nthat install their own handlers will still 'work', with the exception that the\ncustom error handlers will not be called.\n\nThis is a 'first pass', 'sledgehammer' approach: a nice addition would to allow\nan integrator to specify a list of errors that are not to be replaced (for\nexample, embedded applications would probably want to ensure that VMerror is\nalways handled as they intend).\n---\n Resource\/Init\/gs_init.ps | 29 ++++++++++++++++++-----------\n psi\/interp.c             | 30 +++++++++++++++++++++---------\n 2 files changed, 39 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/Resource\/Init\/gs_init.ps b\/Resource\/Init\/gs_init.ps\nindex 071c392..bc8b795 100644\n--- a\/Resource\/Init\/gs_init.ps\n+++ b\/Resource\/Init\/gs_init.ps\n@@ -881,7 +881,7 @@ userdict \/.currentresourcefile \/\/null put\n        { not exch pop exit } { pop } ifelse\n     }\n    for exch pop .quit\n- } bind def\n+ } bind executeonly def\n \/.errorhandler\t\t% <command> <errorname> .errorhandler -\n   {\t\t% Detect an internal 'stopped'.\n     1 .instopped { \/\/null eq { pop pop stop } if } if\n@@ -926,7 +926,7 @@ userdict \/.currentresourcefile \/\/null put\n     $error \/globalmode get $error \/.nosetlocal get and .setglobal\n     $error \/.inerror \/\/false put\n     stop\n-  } bind def\n+  } bind executeonly def\n % Define the standard handleerror.  We break out the printing procedure\n % (.printerror) so that it can be extended for binary output\n % if the Level 2 facilities are present.\n@@ -976,7 +976,7 @@ userdict \/.currentresourcefile \/\/null put\n      ifelse\t% newerror\n      end\n      flush\n-    } bind def\n+    } bind executeonly def\n   \/.printerror_long\t\t\t% long error printout,\n                                         % $error is on the dict stack\n    {\t% Push the (anonymous) stack printing procedure.\n@@ -1053,14 +1053,14 @@ userdict \/.currentresourcefile \/\/null put\n         { (Current file position is ) print position = }\n        if\n \n-   } bind def\n+   } bind executeonly def\n % Define a procedure for clearing the error indication.\n \/.clearerror\n  { $error \/newerror \/\/false put\n    $error \/errorname \/\/null put\n    $error \/errorinfo \/\/null put\n    0 .setoserrno\n- } bind def\n+ } bind executeonly def\n \n % Define $error.  This must be in local VM.\n .currentglobal \/\/false .setglobal\n@@ -1086,11 +1086,15 @@ end\n \/errordict ErrorNames length 3 add dict\n .forcedef\t\t% errordict is local, systemdict is global\n .setglobal\t\t% back to global VM\n-% For greater Adobe compatibility, we put all non-standard errors in a\n-%   separate dictionary, gserrordict.  It does not need to be in local VM,\n-%   because PostScript programs do not access it.\n+%  gserrordict contains all the default error handling methods, but unlike\n+%  errordict it is noaccess after creation (also it is in global VM).\n+%  When running 'SAFER', we'll ignore the contents of errordict, which\n+%  may have been tampered with by the running job, and always use gserrordict\n+%  gserrordict also contains any non-standard errors, for better compatibility\n+%  with Adobe.\n+%\n %   NOTE: the name gserrordict is known to the interpreter.\n-\/gserrordict 5 dict def\n+\/gserrordict ErrorNames length 3 add dict def\n % Register an error in errordict.  We make this a procedure because we only\n % register the Level 1 errors here: the rest are registered by \"feature\"\n % files.  However, ErrorNames contains all of the error names regardless of\n@@ -1119,8 +1123,11 @@ errordict begin\n  } bind def\n end\t\t% errordict\n \n-% Put non-standard errors in gserrordict.\n-gserrordict \/unknownerror errordict \/unknownerror get put\n+% Put all the default handlers in gserrordict\n+gserrordict\n+errordict {2 index 3 1 roll put} forall\n+noaccess pop\n+% remove the non-standard errors from errordict\n errordict \/unknownerror .undef\n % Define a stable private copy of handleerror that we will always use under\n % JOBSERVER mode.\ndiff --git a\/psi\/interp.c b\/psi\/interp.c\nindex c27b70d..d41a9d3 100644\n--- a\/psi\/interp.c\n+++ b\/psi\/interp.c\n@@ -661,16 +661,28 @@ again:\n         return code;\n     if (gs_errorname(i_ctx_p, code, &error_name) < 0)\n         return code;            \/* out-of-range error code! *\/\n-    \/*\n-     * For greater Adobe compatibility, only the standard PostScript errors\n-     * are defined in errordict; the rest are in gserrordict.\n+\n+    \/*  If LockFilePermissions is true, we only refer to gserrordict, which\n+     *  is not accessible to Postcript jobs\n      *\/\n-    if (dict_find_string(systemdict, \"errordict\", &perrordict) <= 0 ||\n-        (dict_find(perrordict, &error_name, &epref) <= 0 &&\n-         (dict_find_string(systemdict, \"gserrordict\", &perrordict) <= 0 ||\n-          dict_find(perrordict, &error_name, &epref) <= 0))\n-        )\n-        return code;            \/* error name not in errordict??? *\/\n+    if (i_ctx_p->LockFilePermissions) {\n+        if (((dict_find_string(systemdict, \"gserrordict\", &perrordict) <= 0 ||\n+              dict_find(perrordict, &error_name, &epref) <= 0))\n+            )\n+            return code;            \/* error name not in errordict??? *\/\n+    }\n+    else {\n+        \/*\n+         * For greater Adobe compatibility, only the standard PostScript errors\n+         * are defined in errordict; the rest are in gserrordict.\n+         *\/\n+        if (dict_find_string(systemdict, \"errordict\", &perrordict) <= 0 ||\n+            (dict_find(perrordict, &error_name, &epref) <= 0 &&\n+             (dict_find_string(systemdict, \"gserrordict\", &perrordict) <= 0 ||\n+              dict_find(perrordict, &error_name, &epref) <= 0))\n+            )\n+            return code;            \/* error name not in errordict??? *\/\n+    }\n     doref = *epref;\n     epref = &doref;\n     \/* Push the error object on the operand stack if appropriate. *\/\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-4132","CWE_ID":"20","category":"security","commit_id":"8762202dd0d6e46854f786bdb6fb3780a1625efe","commit_message":"From 8762202dd0d6e46854f786bdb6fb3780a1625efe Mon Sep 17 00:00:00 2001\nFrom: Eryu Guan <guaneryu@gmail.com>\nDate: Tue, 1 Nov 2011 19:04:59 -0400\nSubject: jbd\/jbd2: validate sb->s_first in journal_get_superblock()\n\nI hit a J_ASSERT(blocknr != 0) failure in cleanup_journal_tail() when\nmounting a fsfuzzed ext3 image. It turns out that the corrupted ext3\nimage has s_first = 0 in journal superblock, and the 0 is passed to\njournal->j_head in journal_reset(), then to blocknr in\ncleanup_journal_tail(), in the end the J_ASSERT failed.\n\nSo validate s_first after reading journal superblock from disk in\njournal_get_superblock() to ensure s_first is valid.\n\nThe following script could reproduce it:\n\nfstype=ext3\nblocksize=1024\nimg=$fstype.img\noffset=0\nfound=0\nmagic=\"c0 3b 39 98\"\n\ndd if=\/dev\/zero of=$img bs=1M count=8\nmkfs -t $fstype -b $blocksize -F $img\nfilesize=`stat -c %s $img`\nwhile [ $offset -lt $filesize ]\ndo\n        if od -j $offset -N 4 -t x1 $img | grep -i \"$magic\";then\n                echo \"Found journal: $offset\"\n                found=1\n                break\n        fi\n        offset=`echo \"$offset+$blocksize\" | bc`\ndone\n\nif [ $found -ne 1 ];then\n        echo \"Magic \\\"$magic\\\" not found\"\n        exit 1\nfi\n\ndd if=\/dev\/zero of=$img seek=$(($offset+23)) conv=notrunc bs=1 count=1\n\nmkdir -p .\/mnt\nmount -o loop $img .\/mnt\n\nCc: Jan Kara <jack@suse.cz>\nSigned-off-by: Eryu Guan <guaneryu@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\n---\n fs\/jbd\/journal.c  | 8 ++++++++\n fs\/jbd2\/journal.c | 8 ++++++++\n 2 files changed, 16 insertions(+)\n\n","diff_code":"diff --git a\/fs\/jbd\/journal.c b\/fs\/jbd\/journal.c\nindex 9fe061fb8779..fea8dd661d2b 100644\n--- a\/fs\/jbd\/journal.c\n+++ b\/fs\/jbd\/journal.c\n@@ -1135,6 +1135,14 @@ static int journal_get_superblock(journal_t *journal)\n \t\tgoto out;\n \t}\n \n+\tif (be32_to_cpu(sb->s_first) == 0 ||\n+\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n+\t\tprintk(KERN_WARNING\n+\t\t\t\"JBD: Invalid start block of journal: %u\\n\",\n+\t\t\tbe32_to_cpu(sb->s_first));\n+\t\tgoto out;\n+\t}\n+\n \treturn 0;\n \n out:\ndiff --git a\/fs\/jbd2\/journal.c b\/fs\/jbd2\/journal.c\nindex f24df13adc4e..d6e93d00833e 100644\n--- a\/fs\/jbd2\/journal.c\n+++ b\/fs\/jbd2\/journal.c\n@@ -1251,6 +1251,14 @@ static int journal_get_superblock(journal_t *journal)\n \t\tgoto out;\n \t}\n \n+\tif (be32_to_cpu(sb->s_first) == 0 ||\n+\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n+\t\tprintk(KERN_WARNING\n+\t\t\t\"JBD2: Invalid start block of journal: %u\\n\",\n+\t\t\tbe32_to_cpu(sb->s_first));\n+\t\tgoto out;\n+\t}\n+\n \treturn 0;\n \n out:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-14349","CWE_ID":"20","category":"security","commit_id":"36a29280448097f34ce9c94606195f2ac643fed1","commit_message":"From 36a29280448097f34ce9c94606195f2ac643fed1 Mon Sep 17 00:00:00 2001\nFrom: JerikoOne <jeriko.one@gmx.us>\nDate: Sat, 7 Jul 2018 14:15:56 -0500\nSubject: [PATCH] Handle NO response without message properly\n\n---\n imap\/command.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/imap\/command.c b\/imap\/command.c\nindex 859f98727..74d12df18 100644\n--- a\/imap\/command.c\n+++ b\/imap\/command.c\n@@ -892,7 +892,7 @@ static int cmd_handle_untagged(struct ImapData *idata)\n     mutt_debug(2, \"Handling untagged NO\\n\");\n \n     \/* Display the warning message from the server *\/\n-    mutt_error(\"%s\", s + 3);\n+    mutt_error(\"%s\", s + 2);\n   }\n \n   return 0;\n","owner":"neomutt","repo":"neomutt","source":"cve"},{"CVE_ID":"CVE-2013-3674","CWE_ID":"20","category":"security","commit_id":"ad002e1a13a8df934bd6cb2c84175a4780ab8942","commit_message":"From ad002e1a13a8df934bd6cb2c84175a4780ab8942 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 7 May 2013 21:04:33 +0200\nSubject: [PATCH] avcodec\/cdgraphics: check buffer size before use\n\nFixes out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/cdgraphics.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/cdgraphics.c b\/libavcodec\/cdgraphics.c\nindex d22e9f6e73..ed2edfe450 100644\n--- a\/libavcodec\/cdgraphics.c\n+++ b\/libavcodec\/cdgraphics.c\n@@ -289,7 +289,9 @@ static int cdg_decode_frame(AVCodecContext *avctx,\n     inst    = bytestream_get_byte(&buf);\n     inst    &= CDG_MASK;\n     buf += 2;  \/\/\/ skipping 2 unneeded bytes\n-    bytestream_get_buffer(&buf, cdg_data, buf_size - CDG_HEADER_SIZE);\n+\n+    if (buf_size > CDG_HEADER_SIZE)\n+        bytestream_get_buffer(&buf, cdg_data, buf_size - CDG_HEADER_SIZE);\n \n     if ((command & CDG_MASK) == CDG_COMMAND) {\n         switch (inst) {\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-14351","CWE_ID":"20","category":"security","commit_id":"3c49c44be9b459d9c616bcaef6eb5d51298c1741","commit_message":"From 3c49c44be9b459d9c616bcaef6eb5d51298c1741 Mon Sep 17 00:00:00 2001\nFrom: JerikoOne <jeriko.one@gmx.us>\nDate: Sat, 7 Jul 2018 15:19:58 -0500\nSubject: [PATCH] Ensure litlen isn't larger than our mailbox\n\n---\n imap\/command.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/imap\/command.c b\/imap\/command.c\nindex 74d12df18..13be77a79 100644\n--- a\/imap\/command.c\n+++ b\/imap\/command.c\n@@ -635,6 +635,13 @@ static void cmd_parse_status(struct ImapData *idata, char *s)\n       idata->status = IMAP_FATAL;\n       return;\n     }\n+\n+    if (strlen(idata->buf) < litlen)\n+    {\n+      mutt_debug(1, \"Error parsing STATUS mailbox\\n\");\n+      return;\n+    }\n+\n     mailbox = idata->buf;\n     s = mailbox + litlen;\n     *s = '\\0';\n","owner":"neomutt","repo":"neomutt","source":"cve"},{"CVE_ID":"CVE-2018-13304","CWE_ID":"20","category":"security","commit_id":"bd27a9364ca274ca97f1df6d984e88a0700fb235","commit_message":"From bd27a9364ca274ca97f1df6d984e88a0700fb235 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Tue, 3 Jul 2018 00:27:04 +0200\nSubject: [PATCH] avcodec\/mpeg4videodec: Remove use of\n FF_PROFILE_MPEG4_SIMPLE_STUDIO as indicator of studio profile\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe profile field is changed by code inside and outside the decoder,\nits not a reliable indicator of the internal codec state.\nMaintaining it consistency with studio_profile is messy.\nIts easier to just avoid it and use only studio_profile\n\nFixes: assertion failure\nFixes: ffmpeg_crash_9.avi\n\nFound-by: Thuan Pham, Marcel B\u00f6hme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/error_resilience.c | 3 +--\n libavcodec\/h263dec.c          | 6 ++++--\n libavcodec\/mpeg4videodec.c    | 1 -\n 3 files changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/error_resilience.c b\/libavcodec\/error_resilience.c\nindex 339042e2069..1abae53f41d 100644\n--- a\/libavcodec\/error_resilience.c\n+++ b\/libavcodec\/error_resilience.c\n@@ -814,8 +814,7 @@ static int er_supported(ERContext *s)\n {\n     if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n        !s->cur_pic.f                                                  ||\n-       s->cur_pic.field_picture                                       ||\n-       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n+       s->cur_pic.field_picture\n     )\n         return 0;\n     return 1;\ndiff --git a\/libavcodec\/h263dec.c b\/libavcodec\/h263dec.c\nindex f8a38083f23..5967fca2858 100644\n--- a\/libavcodec\/h263dec.c\n+++ b\/libavcodec\/h263dec.c\n@@ -47,9 +47,10 @@\n \n static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n {\n+    MpegEncContext *s = avctx->priv_data;\n     \/* MPEG-4 Studio Profile only, not supported by hardware *\/\n     if (avctx->bits_per_raw_sample > 8) {\n-        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n+        av_assert1(s->studio_profile);\n         return avctx->pix_fmt;\n     }\n \n@@ -670,7 +671,8 @@ int ff_h263_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n \n     av_assert1(s->bitstream_buffer_size == 0);\n frame_end:\n-    ff_er_frame_end(&s->er);\n+    if (!s->studio_profile)\n+        ff_er_frame_end(&s->er);\n \n     if (avctx->hwaccel) {\n         ret = avctx->hwaccel->end_frame(avctx);\ndiff --git a\/libavcodec\/mpeg4videodec.c b\/libavcodec\/mpeg4videodec.c\nindex 54a84962444..2df525e03a7 100644\n--- a\/libavcodec\/mpeg4videodec.c\n+++ b\/libavcodec\/mpeg4videodec.c\n@@ -3244,7 +3244,6 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n     s->avctx->has_b_frames = !s->low_delay;\n \n     if (s->studio_profile) {\n-        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n         if (!s->avctx->bits_per_raw_sample) {\n             av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n             return AVERROR_INVALIDDATA;\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2018-18955","CWE_ID":"20","category":"security","commit_id":"d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd","commit_message":"From d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd Mon Sep 17 00:00:00 2001\nFrom: Jann Horn <jannh@google.com>\nDate: Mon, 5 Nov 2018 20:55:09 +0100\nSubject: userns: also map extents in the reverse map to kernel IDs\n\nThe current logic first clones the extent array and sorts both copies, then\nmaps the lower IDs of the forward mapping into the lower namespace, but\ndoesn't map the lower IDs of the reverse mapping.\n\nThis means that code in a nested user namespace with >5 extents will see\nincorrect IDs. It also breaks some access checks, like\ninode_owner_or_capable() and privileged_wrt_inode_uidgid(), so a process\ncan incorrectly appear to be capable relative to an inode.\n\nTo fix it, we have to make sure that the \"lower_first\" members of extents\nin both arrays are translated; and we have to make sure that the reverse\nmap is sorted *after* the translation (since otherwise the translation can\nbreak the sorting).\n\nThis is CVE-2018-18955.\n\nFixes: 6397fac4915a (\"userns: bump idmap limits to 340\")\nCc: stable@vger.kernel.org\nSigned-off-by: Jann Horn <jannh@google.com>\nTested-by: Eric W. Biederman <ebiederm@xmission.com>\nReviewed-by: Eric W. Biederman <ebiederm@xmission.com>\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>\n---\n kernel\/user_namespace.c | 12 ++++++++----\n 1 file changed, 8 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/user_namespace.c b\/kernel\/user_namespace.c\nindex e5222b5fb4fe..923414a246e9 100644\n--- a\/kernel\/user_namespace.c\n+++ b\/kernel\/user_namespace.c\n@@ -974,10 +974,6 @@ static ssize_t map_write(struct file *file, const char __user *buf,\n \tif (!new_idmap_permitted(file, ns, cap_setid, &new_map))\n \t\tgoto out;\n \n-\tret = sort_idmaps(&new_map);\n-\tif (ret < 0)\n-\t\tgoto out;\n-\n \tret = -EPERM;\n \t\/* Map the lower ids from the parent user namespace to the\n \t * kernel global id space.\n@@ -1004,6 +1000,14 @@ static ssize_t map_write(struct file *file, const char __user *buf,\n \t\te->lower_first = lower_first;\n \t}\n \n+\t\/*\n+\t * If we want to use binary search for lookup, this clones the extent\n+\t * array and sorts both copies.\n+\t *\/\n+\tret = sort_idmaps(&new_map);\n+\tif (ret < 0)\n+\t\tgoto out;\n+\n \t\/* Install the map *\/\n \tif (new_map.nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS) {\n \t\tmemcpy(map->extent, new_map.extent,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-0857","CWE_ID":"20","category":"security","commit_id":"2fbb37b51bbea891392ad357baf8f3dff00bac05","commit_message":"From 2fbb37b51bbea891392ad357baf8f3dff00bac05 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 9 Nov 2012 20:58:57 +0100\nSubject: [PATCH] iff\/ilbm: check remaining buffer size.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/iff.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/iff.c b\/libavcodec\/iff.c\nindex d5c1457de1..9184015d50 100644\n--- a\/libavcodec\/iff.c\n+++ b\/libavcodec\/iff.c\n@@ -575,13 +575,13 @@ static int decode_frame_ilbm(AVCodecContext *avctx,\n         }\n     } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { \/\/ IFF-PBM\n         if (avctx->pix_fmt == AV_PIX_FMT_PAL8 || avctx->pix_fmt == AV_PIX_FMT_GRAY8) {\n-            for(y = 0; y < avctx->height; y++ ) {\n+            for(y = 0; y < avctx->height && buf_end > buf; y++ ) {\n                 uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n                 memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));\n                 buf += avctx->width + (avctx->width % 2); \/\/ padding if odd\n             }\n         } else if (s->ham) { \/\/ IFF-PBM: HAM to AV_PIX_FMT_BGR32\n-            for (y = 0; y < avctx->height; y++) {\n+            for (y = 0; y < avctx->height && buf_end > buf; y++) {\n                 uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n                 memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));\n                 buf += avctx->width + (avctx->width & 1); \/\/ padding if odd\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-4818","CWE_ID":"20","category":"security","commit_id":"ec9c97c6bf70b523bc500bd3adf62176f1bb33a4","commit_message":"From ec9c97c6bf70b523bc500bd3adf62176f1bb33a4 Mon Sep 17 00:00:00 2001\nFrom: Julien Cristau <jcristau@debian.org>\nDate: Sat, 3 Jul 2010 19:47:55 +0100\nSubject: glx: validate request lengths\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nReviewed-by: Adam Jackson <ajax@redhat.com>\nReviewed-by: Kristian H\u00f8gsberg <krh@bitplanet.net>\nReviewed-by: Daniel Stone <daniel@fooishbar.org>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n glx\/glxcmds.c | 142 ++++++++++++++++++++++++++++++++++++++++++++++++++++++----\n glx\/xfont.c   |   2 +\n 2 files changed, 135 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/glx\/glxcmds.c b\/glx\/glxcmds.c\nindex 419cc46..566dbbe 100644\n--- a\/glx\/glxcmds.c\n+++ b\/glx\/glxcmds.c\n@@ -314,11 +314,14 @@ DoCreateContext(__GLXclientState *cl, GLXContextID gcId,\n \n int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateContextReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n@@ -330,11 +333,14 @@ int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_CreateNewContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateNewContextReq *req = (xGLXCreateNewContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateNewContextReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))\n@@ -346,12 +352,15 @@ int __glXDisp_CreateNewContext(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_CreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateContextWithConfigSGIXReq *req = \n \t(xGLXCreateContextWithConfigSGIXReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateContextWithConfigSGIXReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))\n@@ -362,10 +371,13 @@ int __glXDisp_CreateContextWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)\n }\n int __glXDisp_DestroyContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyContextReq *req = (xGLXDestroyContextReq *) pc;\n     __GLXcontext *glxc;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyContextReq);\n+\n     if (!validGlxContext(cl->client, req->context, DixDestroyAccess,\n \t\t\t &glxc, &err))\n \t    return err;\n@@ -685,24 +697,33 @@ DoMakeCurrent(__GLXclientState *cl,\n \n int __glXDisp_MakeCurrent(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXMakeCurrentReq *req = (xGLXMakeCurrentReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXMakeCurrentReq);\n+\n     return DoMakeCurrent( cl, req->drawable, req->drawable,\n \t\t\t  req->context, req->oldContextTag );\n }\n \n int __glXDisp_MakeContextCurrent(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXMakeContextCurrentReq *req = (xGLXMakeContextCurrentReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXMakeContextCurrentReq);\n+\n     return DoMakeCurrent( cl, req->drawable, req->readdrawable,\n \t\t\t  req->context, req->oldContextTag );\n }\n \n int __glXDisp_MakeCurrentReadSGI(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXMakeCurrentReadSGIReq *req = (xGLXMakeCurrentReadSGIReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXMakeCurrentReadSGIReq);\n+\n     return DoMakeCurrent( cl, req->drawable, req->readable,\n \t\t\t  req->context, req->oldContextTag );\n }\n@@ -715,6 +736,8 @@ int __glXDisp_IsDirect(__GLXclientState *cl, GLbyte *pc)\n     __GLXcontext *glxc;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXIsDirectReq);\n+\n     if (!validGlxContext(cl->client, req->context, DixReadAccess, &glxc, &err))\n \treturn err;\n \n@@ -739,6 +762,8 @@ int __glXDisp_QueryVersion(__GLXclientState *cl, GLbyte *pc)\n     xGLXQueryVersionReply reply;\n     GLuint major, minor;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryVersionReq);\n+\n     major = req->majorVersion;\n     minor = req->minorVersion;\n     (void)major;\n@@ -765,11 +790,15 @@ int __glXDisp_QueryVersion(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_WaitGL(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXWaitGLReq *req = (xGLXWaitGLReq *)pc;\n-    GLXContextTag tag = req->contextTag;\n+    GLXContextTag tag;\n     __GLXcontext *glxc = NULL;\n     int error;\n \n+    REQUEST_SIZE_MATCH(xGLXWaitGLReq);\n+\n+    tag = req->contextTag;\n     if (tag) {\n \tglxc = __glXLookupContextByTag(cl, tag);\n \tif (!glxc)\n@@ -789,11 +818,15 @@ int __glXDisp_WaitGL(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_WaitX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXWaitXReq *req = (xGLXWaitXReq *)pc;\n-    GLXContextTag tag = req->contextTag;\n+    GLXContextTag tag;\n     __GLXcontext *glxc = NULL;\n     int error;\n \n+    REQUEST_SIZE_MATCH(xGLXWaitXReq);\n+\n+    tag = req->contextTag;\n     if (tag) {\n \tglxc = __glXLookupContextByTag(cl, tag);\n \tif (!glxc)\n@@ -813,13 +846,19 @@ int __glXDisp_CopyContext(__GLXclientState *cl, GLbyte *pc)\n {\n     ClientPtr client = cl->client;\n     xGLXCopyContextReq *req = (xGLXCopyContextReq *) pc;\n-    GLXContextID source = req->source;\n-    GLXContextID dest = req->dest;\n-    GLXContextTag tag = req->contextTag;\n-    unsigned long mask = req->mask;\n+    GLXContextID source;\n+    GLXContextID dest;\n+    GLXContextTag tag;\n+    unsigned long mask;\n     __GLXcontext *src, *dst;\n     int error;\n \n+    REQUEST_SIZE_MATCH(xGLXCopyContextReq);\n+\n+    source = req->source;\n+    dest = req->dest;\n+    tag = req->contextTag;\n+    mask = req->mask;\n     if (!validGlxContext(cl->client, source, DixReadAccess, &src, &error))\n \treturn error;\n     if (!validGlxContext(cl->client, dest, DixWriteAccess, &dst, &error))\n@@ -902,6 +941,8 @@ int __glXDisp_GetVisualConfigs(__GLXclientState *cl, GLbyte *pc)\n     __GLX_DECLARE_SWAP_VARIABLES;\n     __GLX_DECLARE_SWAP_ARRAY_VARIABLES;\n \n+    REQUEST_SIZE_MATCH(xGLXGetVisualConfigsReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n \n@@ -1081,13 +1122,17 @@ DoGetFBConfigs(__GLXclientState *cl, unsigned screen)\n \n int __glXDisp_GetFBConfigs(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetFBConfigsReq *req = (xGLXGetFBConfigsReq *) pc;\n+    REQUEST_SIZE_MATCH(xGLXGetFBConfigsReq);\n     return DoGetFBConfigs(cl, req->screen);\n }\n \n int __glXDisp_GetFBConfigsSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetFBConfigsSGIXReq *req = (xGLXGetFBConfigsSGIXReq *) pc;\n+    REQUEST_SIZE_MATCH(xGLXGetFBConfigsSGIXReq);\n     return DoGetFBConfigs(cl, req->screen);\n }\n \n@@ -1213,11 +1258,14 @@ determineTextureTarget(ClientPtr client, XID glxDrawableID,\n \n int __glXDisp_CreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateGLXPixmapReq *req = (xGLXCreateGLXPixmapReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateGLXPixmapReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n@@ -1229,11 +1277,14 @@ int __glXDisp_CreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_CreatePixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreatePixmapReq *req = (xGLXCreatePixmapReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_FIXED_SIZE(xGLXCreatePixmapReq, req->numAttribs << 3);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))\n@@ -1252,12 +1303,15 @@ int __glXDisp_CreatePixmap(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_CreateGLXPixmapWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateGLXPixmapWithConfigSGIXReq *req = \n \t(xGLXCreateGLXPixmapWithConfigSGIXReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateGLXPixmapWithConfigSGIXReq);\n+\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxFBConfig(cl->client, pGlxScreen, req->fbconfig, &config, &err))\n@@ -1284,15 +1338,21 @@ static int DoDestroyDrawable(__GLXclientState *cl, XID glxdrawable, int type)\n \n int __glXDisp_DestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyGLXPixmapReq *req = (xGLXDestroyGLXPixmapReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyGLXPixmapReq);\n+\n     return DoDestroyDrawable(cl, req->glxpixmap, GLX_DRAWABLE_PIXMAP);\n }\n \n int __glXDisp_DestroyPixmap(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyPixmapReq *req = (xGLXDestroyPixmapReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyPixmapReq);\n+\n     return DoDestroyDrawable(cl, req->glxpixmap, GLX_DRAWABLE_PIXMAP);\n }\n \n@@ -1331,10 +1391,13 @@ DoCreatePbuffer(ClientPtr client, int screenNum, XID fbconfigId,\n \n int __glXDisp_CreatePbuffer(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreatePbufferReq\t*req = (xGLXCreatePbufferReq *) pc;\n     CARD32\t\t\t*attrs;\n     int\t\t\t\t width, height, i;\n \n+    REQUEST_FIXED_SIZE(xGLXCreatePbufferReq, req->numAttribs << 3);\n+\n     attrs = (CARD32 *) (req + 1);\n     width = 0;\n     height = 0;\n@@ -1360,23 +1423,32 @@ int __glXDisp_CreatePbuffer(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_CreateGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXCreateGLXPbufferSGIXReq *req = (xGLXCreateGLXPbufferSGIXReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXCreateGLXPbufferSGIXReq);\n+\n     return DoCreatePbuffer(cl->client, req->screen, req->fbconfig,\n \t\t\t   req->width, req->height, req->pbuffer);\n }\n \n int __glXDisp_DestroyPbuffer(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyPbufferReq *req = (xGLXDestroyPbufferReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyPbufferReq);\n+\n     return DoDestroyDrawable(cl, req->pbuffer, GLX_DRAWABLE_PBUFFER);\n }\n \n int __glXDisp_DestroyGLXPbufferSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyGLXPbufferSGIXReq *req = (xGLXDestroyGLXPbufferSGIXReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyGLXPbufferSGIXReq);\n+\n     return DoDestroyDrawable(cl, req->pbuffer, GLX_DRAWABLE_PBUFFER);\n }\n \n@@ -1407,18 +1479,24 @@ DoChangeDrawableAttributes(ClientPtr client, XID glxdrawable,\n \n int __glXDisp_ChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXChangeDrawableAttributesReq *req =\n \t(xGLXChangeDrawableAttributesReq *) pc;\n \n+    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesReq, req->numAttribs << 3);\n+\n     return DoChangeDrawableAttributes(cl->client, req->drawable,\n \t\t\t\t      req->numAttribs, (CARD32 *) (req + 1));\n }\n \n int __glXDisp_ChangeDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXChangeDrawableAttributesSGIXReq *req =\n \t(xGLXChangeDrawableAttributesSGIXReq *)pc;\n \n+    REQUEST_FIXED_SIZE(xGLXChangeDrawableAttributesSGIXReq, req->numAttribs << 3);\n+\n     return DoChangeDrawableAttributes(cl->client, req->drawable,\n \t\t\t\t      req->numAttribs, (CARD32 *) (req + 1));\n }\n@@ -1432,6 +1510,8 @@ int __glXDisp_CreateWindow(__GLXclientState *cl, GLbyte *pc)\n     DrawablePtr\t\t pDraw;\n     int\t\t\t err;\n \n+    REQUEST_FIXED_SIZE(xGLXCreateWindowReq, req->numAttribs << 3);\n+\n     LEGAL_NEW_RESOURCE(req->glxwindow, client);\n \n     if (!validGlxScreen(client, req->screen, &pGlxScreen, &err))\n@@ -1455,8 +1535,11 @@ int __glXDisp_CreateWindow(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_DestroyWindow(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXDestroyWindowReq *req = (xGLXDestroyWindowReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXDestroyWindowReq);\n+\n     return DoDestroyDrawable(cl, req->glxwindow, GLX_DRAWABLE_WINDOW);\n }\n \n@@ -1472,12 +1555,16 @@ int __glXDisp_SwapBuffers(__GLXclientState *cl, GLbyte *pc)\n {\n     ClientPtr client = cl->client;\n     xGLXSwapBuffersReq *req = (xGLXSwapBuffersReq *) pc;\n-    GLXContextTag tag = req->contextTag;\n-    XID drawId = req->drawable;\n+    GLXContextTag tag;\n+    XID drawId;\n     __GLXcontext *glxc = NULL;\n     __GLXdrawable *pGlxDraw;\n     int error;\n \n+    REQUEST_SIZE_MATCH(xGLXSwapBuffersReq);\n+\n+    tag = req->contextTag;\n+    drawId = req->drawable;\n     if (tag) {\n \tglxc = __glXLookupContextByTag(cl, tag);\n \tif (!glxc) {\n@@ -1558,15 +1645,21 @@ DoQueryContext(__GLXclientState *cl, GLXContextID gcId)\n \n int __glXDisp_QueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXQueryContextInfoEXTReq *req = (xGLXQueryContextInfoEXTReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryContextInfoEXTReq);\n+\n     return DoQueryContext(cl, req->context);\n }\n \n int __glXDisp_QueryContext(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXQueryContextReq *req = (xGLXQueryContextReq *) pc;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryContextReq);\n+\n     return DoQueryContext(cl, req->context);\n }\n \n@@ -1580,6 +1673,8 @@ int __glXDisp_BindTexImageEXT(__GLXclientState *cl, GLbyte *pc)\n     int\t\t\t buffer;\n     int\t\t\t error;\n \n+    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 8);\n+\n     pc += __GLX_VENDPRIV_HDR_SIZE;\n \n     drawId = *((CARD32 *) (pc));\n@@ -1614,6 +1709,8 @@ int __glXDisp_ReleaseTexImageEXT(__GLXclientState *cl, GLbyte *pc)\n     int\t\t\t buffer;\n     int\t\t\t error;\n \n+    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 8);\n+\n     pc += __GLX_VENDPRIV_HDR_SIZE;\n \n     drawId = *((CARD32 *) (pc));\n@@ -1649,6 +1746,8 @@ int __glXDisp_CopySubBufferMESA(__GLXclientState *cl, GLbyte *pc)\n     (void) client;\n     (void) req;\n \n+    REQUEST_FIXED_SIZE(xGLXVendorPrivateReq, 20);\n+\n     pc += __GLX_VENDPRIV_HDR_SIZE;\n \n     drawId = *((CARD32 *) (pc));\n@@ -1737,16 +1836,22 @@ DoGetDrawableAttributes(__GLXclientState *cl, XID drawId)\n \n int __glXDisp_GetDrawableAttributes(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetDrawableAttributesReq *req = (xGLXGetDrawableAttributesReq *)pc;\n \n+    REQUEST_SIZE_MATCH(xGLXGetDrawableAttributesReq);\n+\n     return DoGetDrawableAttributes(cl, req->drawable);\n }\n \n int __glXDisp_GetDrawableAttributesSGIX(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXGetDrawableAttributesSGIXReq *req =\n \t(xGLXGetDrawableAttributesSGIXReq *)pc;\n     \n+    REQUEST_SIZE_MATCH(xGLXGetDrawableAttributesSGIXReq);\n+\n     return DoGetDrawableAttributes(cl, req->drawable);\n }\n \n@@ -1771,6 +1876,8 @@ int __glXDisp_Render(__GLXclientState *cl, GLbyte *pc)\n     __GLXcontext *glxc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXRenderReq);\n+\n     req = (xGLXRenderReq *) pc;\n     if (client->swapped) {\n \t__GLX_SWAP_SHORT(&req->length);\n@@ -1791,6 +1898,9 @@ int __glXDisp_Render(__GLXclientState *cl, GLbyte *pc)\n \t__GLXdispatchRenderProcPtr proc;\n \tint err;\n \n+\tif (left < sizeof(__GLXrenderHeader))\n+\t    return BadLength;\n+\n \t\/*\n \t** Verify that the header length and the overall length agree.\n \t** Also, each command must be word aligned.\n@@ -2069,10 +2179,12 @@ int __glXDisp_RenderLarge(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_VendorPrivate(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;\n     GLint vendorcode = req->vendorCode;\n     __GLXdispatchVendorPrivProcPtr proc;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateReq);\n \n     proc = (__GLXdispatchVendorPrivProcPtr)\n       __glXGetProtocolDecodeFunction(& VendorPriv_dispatch_info,\n@@ -2088,10 +2200,12 @@ int __glXDisp_VendorPrivate(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_VendorPrivateWithReply(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXVendorPrivateReq *req = (xGLXVendorPrivateReq *) pc;\n     GLint vendorcode = req->vendorCode;\n     __GLXdispatchVendorPrivProcPtr proc;\n \n+    REQUEST_AT_LEAST_SIZE(xGLXVendorPrivateReq);\n \n     proc = (__GLXdispatchVendorPrivProcPtr)\n       __glXGetProtocolDecodeFunction(& VendorPriv_dispatch_info,\n@@ -2114,6 +2228,8 @@ int __glXDisp_QueryExtensionsString(__GLXclientState *cl, GLbyte *pc)\n     char *buf;\n     int err;\n \n+    REQUEST_SIZE_MATCH(xGLXQueryExtensionsStringReq);\n+\n     if (!validGlxScreen(client, req->screen, &pGlxScreen, &err))\n \treturn err;\n \n@@ -2153,6 +2269,8 @@ int __glXDisp_QueryServerString(__GLXclientState *cl, GLbyte *pc)\n     int err;\n     char ver_str[16];\n \n+    REQUEST_SIZE_MATCH(xGLXQueryServerStringReq);\n+\n     if (!validGlxScreen(client, req->screen, &pGlxScreen, &err))\n \treturn err;\n \n@@ -2200,13 +2318,19 @@ int __glXDisp_QueryServerString(__GLXclientState *cl, GLbyte *pc)\n \n int __glXDisp_ClientInfo(__GLXclientState *cl, GLbyte *pc)\n {\n+    ClientPtr client = cl->client;\n     xGLXClientInfoReq *req = (xGLXClientInfoReq *) pc;\n     const char *buf;\n    \n+    REQUEST_AT_LEAST_SIZE(xGLXClientInfoReq);\n+\n+    buf = (const char *)(req+1);\n+    if (!memchr(buf, 0, (client->req_len << 2) - sizeof(xGLXClientInfoReq)))\n+\treturn BadLength;\n+\n     cl->GLClientmajorVersion = req->major;\n     cl->GLClientminorVersion = req->minor;\n     free(cl->GLClientextensions);\n-    buf = (const char *)(req+1);\n     cl->GLClientextensions = strdup(buf);\n \n     return Success;\ndiff --git a\/glx\/xfont.c b\/glx\/xfont.c\nindex 9943784..84a301f 100644\n--- a\/glx\/xfont.c\n+++ b\/glx\/xfont.c\n@@ -154,6 +154,8 @@ int __glXDisp_UseXFont(__GLXclientState *cl, GLbyte *pc)\n     __GLXcontext *cx;\n     int error;\n \n+    REQUEST_SIZE_MATCH(xGLXUseXFontReq);\n+\n     req = (xGLXUseXFontReq *) pc;\n     cx = __glXForceCurrent(cl, req->contextTag, &error);\n     if (!cx) {\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-4605","CWE_ID":"20","category":"security","commit_id":"f938112c495b0d26572435c0be73ac0bfe642ecd","commit_message":"From f938112c495b0d26572435c0be73ac0bfe642ecd Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sat, 4 Apr 2015 15:01:37 -0700\nSubject: [PATCH] Fix bug #68819 (Fileinfo on specific file causes spurious OOM\n and\/or segfault)\n\n---\n ext\/fileinfo\/libmagic\/softmagic.c    |  3 +++\n ext\/fileinfo\/tests\/bug68819_001.phpt | 18 ++++++++++++++++++\n ext\/fileinfo\/tests\/bug68819_002.phpt | 26 ++++++++++++++++++++++++++\n 3 files changed, 47 insertions(+)\n create mode 100644 ext\/fileinfo\/tests\/bug68819_001.phpt\n create mode 100644 ext\/fileinfo\/tests\/bug68819_002.phpt\n\n","diff_code":"diff --git a\/ext\/fileinfo\/libmagic\/softmagic.c b\/ext\/fileinfo\/libmagic\/softmagic.c\nindex e7b7855..54c1a03 100644\n--- a\/ext\/fileinfo\/libmagic\/softmagic.c\n+++ b\/ext\/fileinfo\/libmagic\/softmagic.c\n@@ -1037,6 +1037,9 @@ mcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n \t\t\tif (bytecnt > nbytes) {\n \t\t\t\tbytecnt = nbytes;\n \t\t\t}\n+\t\t\tif (offset > bytecnt) {\n+\t\t\t\toffset = bytecnt;\n+\t\t\t}\n \t\t\tif (s == NULL) {\n \t\t\t\tms->search.s_len = 0;\n \t\t\t\tms->search.s = NULL;\ndiff --git a\/ext\/fileinfo\/tests\/bug68819_001.phpt b\/ext\/fileinfo\/tests\/bug68819_001.phpt\nnew file mode 100644\nindex 0000000..ce39ee6\n--- \/dev\/null\n+++ b\/ext\/fileinfo\/tests\/bug68819_001.phpt\n@@ -0,0 +1,18 @@\n+--TEST--\n+Bug #68819 Fileinfo on specific file causes spurious OOM and\/or segfault, var 1\n+--SKIPIF--\n+<?php require_once(dirname(__FILE__) . '\/skipif.inc'); ?>\n+--FILE--\n+<?php\n+\n+$string = <<<HERE\n+----a-----'''---------a---------------a--------a-----a-----a---------a-----as-------a----a--a-------------a--as-----s---------------a---------a---a--s-a-----a-----------asy---------a-----a-----------a----s--------a-------------a-------a--------a----s------------a-----a----------------a----s-----------------\\r\\n-------------------a-------a-a-------a-----a----a----s----s--------a-----------------------a----a----s-------------a------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a----s----s--------a----------a----------------------a----a----s-------------a----------------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n------a-------a-a-------a-----a----a---a-----a-----------------------a----a---a-----a------------------s-------a----a---a-----a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s------\\r\\n-------------------a-------a-a-------a-----a----a---a-------a------------------------a----a---a-----''--a-------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a-------s-----a---a-------------------------a----a-------------a---a-------------------s-------a----a-------------a---a-----as-a--------------a-----a--s----s---------y------------a-----a-s---a-------''----a---s--a-''------''----s------------a-y----------------s------a-----y--a-s--a-s------s--a-s----------''----------------------------a---s--a----a---------a-s---a-s--------s--------a---------s--a-y-------------as----a----a-------------a------a---s--a-s------a--------a----s----y--as--a----a-s---------------a-----a--------------------------------------\\r\\n-------------------a-------a-a-------a-----a----a-----------s--------a-----------------------a----a--------------------a------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a-----------s--------a----------a----------------------a----a--------------------a------------------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a---a-----------------------a----a---a------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a---a----------a----------------------a----a---a------------------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-----a-a-----------a-------a-a-------a-----a----a----a---s-----a-----------------------a----a----a---------a-----------------s-------a----a----a---------a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a--------a----a-----------------------a----a----------a----a------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-----a-------------a-------a-a-------a-----a----a--------s-----a---a-------------------------a----a--------------a---a-------------------s-------------a---------------a----a---a---a-----as-a--------------a-----a--s----s---------y------------a-----a-s---a-------''----a---s--a-''------''----s------------a-y----------------s------a-----y--a-s--a-s------s--a-s----------''----------------------------a---s--a----a---------a-s---a-s--------s--------a---------s--a-y-------------as----a----a-------------a------a---s--a-s------a--------a----s----y--as--a----a-s---------------a-----a--------------------------------------\\r\\n-------------------a-------a-a-------a-----a----a----------------a-----------------------a----a----------------a------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a----------------a----------a----------------------a----a----------------a-----------------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n---a---------------a-------a-a-------a-----as------------------------a--a--s------------------a-s------------------------a-----s--a-----'''----------a-s---------------------------------------------a-----s--a-----------------a---------a---a--s-a-----a-----------asy---------a-----a-----------a----s----------------------a----s--a-------------a-------a--------a----s------------a-----a----------------a----s------------------\\r\\n-a-----------------a-------a-a-------a--y---------a------------------y---------a-----'''-------y------a-y--a-------------------------a---------a---a----------as-a---a--s-a-----a-----------asy---------a-----a-----------a----s--------a-------------a-------a--------a----s---------a-----a----------------a----s------------------\\r\\n-a-----------------a-------a-a-------a--y-------------a------------------y-------------a-----'''-------y----------a-y--a-------------------------a---------a---a----------as-a---a--s-a-----a-----------asy---------a-----a-----------a----s--------a-------------a-------a--------a----s---------a-----a----------------a----s------------------\\r\\n-------------------a-------a-a-------a--a----a-----a------------------a----a-----a-----'''----------a----s----a----a-------s---a------------------a-----------a--s-a-----a---------------------a------a----s-a-----a-------s-s-------a----s--------a-------------a-------a--------a----s---------a-----a----------------a----s------------------\\r\\n------aa-----------a-------a-a------------s-a--s---------a---a------------------------a------------a---a------------------s--------a------------a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a------------------------s-----s--a----a-----------------------------------------s--a----a------------------s---------------------------------s--a----a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a--------------s-a---a--------------------------a---a------------------s----------a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s---------------a-----a----------a----------s--a----------s-----------------\\r\\nsay-------a------------s-----''------a----s--------a-------------a-\\r\\n\n+HERE;\n+\n+$finfo = new finfo();\n+$type = $finfo->buffer($string);\n+\n+var_dump($type);\n+?>\n+--EXPECT--\n+string(60) \"ASCII text, with very long lines, with CRLF line terminators\"\ndiff --git a\/ext\/fileinfo\/tests\/bug68819_002.phpt b\/ext\/fileinfo\/tests\/bug68819_002.phpt\nnew file mode 100644\nindex 0000000..cec238d\n--- \/dev\/null\n+++ b\/ext\/fileinfo\/tests\/bug68819_002.phpt\n@@ -0,0 +1,26 @@\n+--TEST--\n+Bug #68819 Fileinfo on specific file causes spurious OOM and\/or segfault, var 2\n+--SKIPIF--\n+<?php require_once(dirname(__FILE__) . '\/skipif.inc'); ?>\n+--FILE--\n+<?php\n+\n+$string = '';\n+\n+\/\/ These two in any order\n+$string .= \"\\r\\n\";\n+$string .= \"''''\";\n+\n+\/\/ Total string length > 8192\n+$string .= str_repeat(chr(rand(32, 127)), 8184);\n+\n+\/\/ Ending in this string\n+$string .= \"say\";\n+\n+$finfo = new finfo();\n+$type = $finfo->buffer($string);\n+var_dump($type);\n+\n+?>\n+--EXPECT--\n+string(60) \"ASCII text, with very long lines, with CRLF line terminators\"\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8558","CWE_ID":"20","category":"security","commit_id":"156a2e4dbffa85997636a7a39ef12da6f1b40254","commit_message":"From 156a2e4dbffa85997636a7a39ef12da6f1b40254 Mon Sep 17 00:00:00 2001\nFrom: Gerd Hoffmann <kraxel@redhat.com>\nDate: Mon, 14 Dec 2015 09:21:23 +0100\nSubject: [PATCH] ehci: make idt processing more robust\n\nMake ehci_process_itd return an error in case we didn't do any actual\niso transfer because we've found no active transaction.  That'll avoid\nehci happily run in circles forever if the guest builds a loop out of\nidts.\n\nThis is CVE-2015-8558.\n\nCc: qemu-stable@nongnu.org\nReported-by: Qinghao Tang <luodalongde@gmail.com>\nTested-by: P J P <ppandit@redhat.com>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/usb\/hcd-ehci.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/hw\/usb\/hcd-ehci.c b\/hw\/usb\/hcd-ehci.c\nindex 4e2161b..d07f228 100644\n--- a\/hw\/usb\/hcd-ehci.c\n+++ b\/hw\/usb\/hcd-ehci.c\n@@ -1389,7 +1389,7 @@ static int ehci_process_itd(EHCIState *ehci,\n {\n     USBDevice *dev;\n     USBEndpoint *ep;\n-    uint32_t i, len, pid, dir, devaddr, endp;\n+    uint32_t i, len, pid, dir, devaddr, endp, xfers = 0;\n     uint32_t pg, off, ptr1, ptr2, max, mult;\n \n     ehci->periodic_sched_active = PERIODIC_ACTIVE;\n@@ -1479,9 +1479,10 @@ static int ehci_process_itd(EHCIState *ehci,\n                 ehci_raise_irq(ehci, USBSTS_INT);\n             }\n             itd->transact[i] &= ~ITD_XACT_ACTIVE;\n+            xfers++;\n         }\n     }\n-    return 0;\n+    return xfers ? 0 : -1;\n }\n \n \n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-12713","CWE_ID":"20","category":"security","commit_id":"c21eff4b031acb04fb4dfce8bd5fdfecc2b6524f","commit_message":"From c21eff4b031acb04fb4dfce8bd5fdfecc2b6524f Mon Sep 17 00:00:00 2001\nFrom: Jehan <jehan@girinstud.io>\nDate: Sun, 24 Jun 2018 04:48:48 +0200\nSubject: [PATCH] Issue #1689: create unique temporary file with\n g_file_open_tmp().\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nNot sure this is really solving the issue reported, which is that\n`g_get_tmp_dir()` uses environment variables (yet as g_file_open_tmp()\nuses g_get_tmp_dir()\u2026). But at least g_file_open_tmp() should create\nunique temporary files, which prevents overriding existing files (which\nis most likely the only real attack possible here, or at least the only\none I can think of unless some weird vulnerabilities exist in glib).\n---\n app\/tests\/test-xcf.c | 7 +++++--\n 1 file changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/app\/tests\/test-xcf.c b\/app\/tests\/test-xcf.c\nindex 9fc2ec1f4b..98ca4f0bed 100644\n--- a\/app\/tests\/test-xcf.c\n+++ b\/app\/tests\/test-xcf.c\n@@ -295,7 +295,8 @@ gimp_write_and_read_file (Gimp     *gimp,\n   GimpImage           *image;\n   GimpImage           *loaded_image;\n   GimpPlugInProcedure *proc;\n-  gchar               *filename;\n+  gchar               *filename = NULL;\n+  gint                 file_handle;\n   GFile               *file;\n \n   \/* Create the image *\/\n@@ -311,7 +312,9 @@ gimp_write_and_read_file (Gimp     *gimp,\n                          use_gimp_2_8_features);\n \n   \/* Write to file *\/\n-  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);\n+  file_handle = g_file_open_tmp (\"gimp-test-XXXXXX.xcf\", &filename, NULL);\n+  g_assert (file_handle != -1);\n+  close (file_handle);\n   file = g_file_new_for_path (filename);\n   g_free (filename);\n \n","owner":"GNOME","repo":"gimp","source":"cve"},{"CVE_ID":"CVE-2016-5690","CWE_ID":"20","category":"security","commit_id":"5511ef530576ed18fd636baa3bb4eda3d667665d","commit_message":"From 5511ef530576ed18fd636baa3bb4eda3d667665d Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 30 May 2016 07:51:39 -0400\nSubject: [PATCH] =?UTF-8?q?Add=20additional=20checks=20to=20DCM=20reader?=\n =?UTF-8?q?=20to=20prevent=20data-driven=20faults=20(bug=20report=20from?=\n =?UTF-8?q?=20Hanno=20B=C3=B6ck?=\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\n---\n ChangeLog    |  2 ++\n coders\/dcm.c | 15 +++++++++++----\n 2 files changed, 13 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 70f2d014da..de0b1fa589 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -5,6 +5,8 @@\n     https:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=3&t=29626).\n   * Don't interpret -fx option arguments (reference\n     https:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=3&t=29774);\n+  * Add additional checks to DCM reader to prevent data-driven faults (bug\n+    report from Hanno B\u00f6ck).\n \n 2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\ndiff --git a\/coders\/dcm.c b\/coders\/dcm.c\nindex f86e573265..26125f778b 100644\n--- a\/coders\/dcm.c\n+++ b\/coders\/dcm.c\n@@ -3216,6 +3216,8 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n             \/*\n               Photometric interpretation.\n             *\/\n+            if (data == (unsigned char *) NULL)\n+              break;\n             for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n               photometric[i]=(char) data[i];\n             photometric[i]='\\0';\n@@ -3237,6 +3239,8 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n             \/*\n               Number of frames.\n             *\/\n+            if (data == (unsigned char *) NULL)\n+              break;\n             number_scenes=StringToUnsignedLong((char *) data);\n             break;\n           }\n@@ -3674,7 +3678,7 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n       if (scale == (Quantum *) NULL)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       range=GetQuantumRange(depth);\n-      for (i=0; i < (ssize_t) (GetQuantumRange(depth)+1); i++)\n+      for (i=0; i <= (ssize_t) GetQuantumRange(depth); i++)\n         scale[i]=ScaleAnyToQuantum((size_t) i,range);\n     }\n   if (image->compression == RLECompression)\n@@ -3965,9 +3969,12 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n                 pixel.blue&=mask;\n                 if (scale != (Quantum *) NULL)\n                   {\n-                    pixel.red=scale[pixel.red];\n-                    pixel.green=scale[pixel.green];\n-                    pixel.blue=scale[pixel.blue];\n+                    if (pixel.red <= GetQuantumRange(depth))\n+                      pixel.red=scale[pixel.red];\n+                    if (pixel.green <= GetQuantumRange(depth))\n+                      pixel.green=scale[pixel.green];\n+                    if (pixel.blue <= GetQuantumRange(depth))\n+                      pixel.blue=scale[pixel.blue];\n                   }\n               }\n             SetPixelRed(image,(Quantum) pixel.red,q);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2012-2321","CWE_ID":"20","category":"security","commit_id":"a5f540db7354b76bcabd0a05d8eb8ba2bff4e911","commit_message":"From a5f540db7354b76bcabd0a05d8eb8ba2bff4e911 Mon Sep 17 00:00:00 2001\nFrom: Jukka Rissanen <jukka.rissanen@linux.intel.com>\nDate: Thu, 3 May 2012 16:15:08 +0300\nSubject: loopback: Check hostname\/domainname validity\n\n---\n plugins\/loopback.c | 23 +++++++++++++++++++----\n 1 file changed, 19 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/plugins\/loopback.c b\/plugins\/loopback.c\nindex 1800c490..a111eeed 100644\n--- a\/plugins\/loopback.c\n+++ b\/plugins\/loopback.c\n@@ -39,6 +39,7 @@\n #include <connman\/plugin.h>\n #include <connman\/utsname.h>\n #include <connman\/log.h>\n+#include <connman\/inet.h>\n \n static in_addr_t loopback_address;\n static in_addr_t loopback_netmask;\n@@ -206,12 +207,21 @@ static const char *loopback_get_hostname(void)\n \n static int loopback_set_hostname(const char *hostname)\n {\n-\tint err;\n+\tconst char *ptr;\n+\tint err, len;\n \n \tif (g_strcmp0(hostname, \"<hostname>\") == 0)\n \t\treturn 0;\n \n-\tif (sethostname(hostname, strlen(hostname)) < 0) {\n+\tlen = strlen(hostname);\n+\n+\tif (connman_inet_check_hostname(hostname, len) == FALSE)\n+\t\treturn -EINVAL;\n+\n+\tif ((ptr = strstr(hostname, \".\")) != NULL)\n+\t\tlen = ptr - hostname;\n+\n+\tif (sethostname(hostname, len) < 0) {\n \t\terr = -errno;\n \t\tconnman_error(\"Failed to set hostname to %s\", hostname);\n \t\treturn err;\n@@ -224,9 +234,14 @@ static int loopback_set_hostname(const char *hostname)\n \n static int loopback_set_domainname(const char *domainname)\n {\n-\tint err;\n+\tint err, len;\n+\n+\tlen = strlen(domainname);\n+\n+\tif (connman_inet_check_hostname(domainname, len) == FALSE)\n+\t\treturn -EINVAL;\n \n-\tif (setdomainname(domainname, strlen(domainname)) < 0) {\n+\tif (setdomainname(domainname, len) < 0) {\n \t\terr = -errno;\n \t\tconnman_error(\"Failed to set domainname to %s\", domainname);\n \t\treturn err;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-3733","CWE_ID":"20","category":"security","commit_id":"4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2","commit_message":"From 4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2 Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Fri, 3 Feb 2017 14:06:20 +0000\nSubject: [PATCH] Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error\/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\n---\n include\/openssl\/ssl3.h    |  5 ++++-\n ssl\/record\/rec_layer_s3.c |  6 +++---\n ssl\/record\/ssl3_record.c  | 10 +++++-----\n ssl\/ssl_locl.h            |  7 ++++++-\n ssl\/t1_enc.c              | 15 ++++++++++++---\n ssl\/t1_lib.c              | 12 ++++++------\n 6 files changed, 36 insertions(+), 19 deletions(-)\n\n","diff_code":"diff --git a\/include\/openssl\/ssl3.h b\/include\/openssl\/ssl3.h\nindex aca19223065..4ca434e760e 100644\n--- a\/include\/openssl\/ssl3.h\n+++ b\/include\/openssl\/ssl3.h\n@@ -264,11 +264,14 @@ extern \"C\" {\n # define TLS1_FLAGS_SKIP_CERT_VERIFY             0x0010\n \n \/* Set if we encrypt then mac instead of usual mac then encrypt *\/\n-# define TLS1_FLAGS_ENCRYPT_THEN_MAC             0x0100\n+# define TLS1_FLAGS_ENCRYPT_THEN_MAC_READ        0x0100\n+# define TLS1_FLAGS_ENCRYPT_THEN_MAC             TLS1_FLAGS_ENCRYPT_THEN_MAC_READ\n \n \/* Set if extended master secret extension received from peer *\/\n # define TLS1_FLAGS_RECEIVED_EXTMS               0x0200\n \n+# define TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE       0x0400\n+\n # define SSL3_MT_HELLO_REQUEST                   0\n # define SSL3_MT_CLIENT_HELLO                    1\n # define SSL3_MT_SERVER_HELLO                    2\ndiff --git a\/ssl\/record\/rec_layer_s3.c b\/ssl\/record\/rec_layer_s3.c\nindex 00379ea601b..4a7e59bc990 100644\n--- a\/ssl\/record\/rec_layer_s3.c\n+++ b\/ssl\/record\/rec_layer_s3.c\n@@ -395,7 +395,7 @@ int ssl3_write_bytes(SSL *s, int type, const void *buf_, int len)\n     if (type == SSL3_RT_APPLICATION_DATA &&\n         u_len >= 4 * (max_send_fragment = s->max_send_fragment) &&\n         s->compress == NULL && s->msg_callback == NULL &&\n-        !SSL_USE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&\n+        !SSL_WRITE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&\n         EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx)) &\n         EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) {\n         unsigned char aad[13];\n@@ -791,7 +791,7 @@ int do_ssl3_write(SSL *s, int type, const unsigned char *buf,\n          * wb->buf\n          *\/\n \n-        if (!SSL_USE_ETM(s) && mac_size != 0) {\n+        if (!SSL_WRITE_ETM(s) && mac_size != 0) {\n             if (s->method->ssl3_enc->mac(s, &wr[j],\n                                          &(outbuf[j][wr[j].length + eivlen]),\n                                          1) < 0)\n@@ -814,7 +814,7 @@ int do_ssl3_write(SSL *s, int type, const unsigned char *buf,\n         goto err;\n \n     for (j = 0; j < numpipes; j++) {\n-        if (SSL_USE_ETM(s) && mac_size != 0) {\n+        if (SSL_WRITE_ETM(s) && mac_size != 0) {\n             if (s->method->ssl3_enc->mac(s, &wr[j],\n                                          outbuf[j] + wr[j].length, 1) < 0)\n                 goto err;\ndiff --git a\/ssl\/record\/ssl3_record.c b\/ssl\/record\/ssl3_record.c\nindex e5cbd614cae..1f079339245 100644\n--- a\/ssl\/record\/ssl3_record.c\n+++ b\/ssl\/record\/ssl3_record.c\n@@ -346,7 +346,7 @@ int ssl3_get_record(SSL *s)\n      * If in encrypt-then-mac mode calculate mac from encrypted record. All\n      * the details below are public so no timing details can leak.\n      *\/\n-    if (SSL_USE_ETM(s) && s->read_hash) {\n+    if (SSL_READ_ETM(s) && s->read_hash) {\n         unsigned char *mac;\n         mac_size = EVP_MD_CTX_size(s->read_hash);\n         OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n@@ -393,7 +393,7 @@ int ssl3_get_record(SSL *s)\n     \/* r->length is now the compressed data plus mac *\/\n     if ((sess != NULL) &&\n         (s->enc_read_ctx != NULL) &&\n-        (EVP_MD_CTX_md(s->read_hash) != NULL) && !SSL_USE_ETM(s)) {\n+        (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) {\n         \/* s->read_hash != NULL => mac_size != -1 *\/\n         unsigned char *mac = NULL;\n         unsigned char mac_tmp[EVP_MAX_MD_SIZE];\n@@ -823,7 +823,7 @@ int tls1_enc(SSL *s, SSL3_RECORD *recs, unsigned int n_recs, int send)\n         }\n \n         ret = 1;\n-        if (!SSL_USE_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)\n+        if (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)\n             mac_size = EVP_MD_CTX_size(s->read_hash);\n         if ((bs != 1) && !send) {\n             int tmpret;\n@@ -997,7 +997,7 @@ int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int send)\n     header[11] = (rec->length) >> 8;\n     header[12] = (rec->length) & 0xff;\n \n-    if (!send && !SSL_USE_ETM(ssl) &&\n+    if (!send && !SSL_READ_ETM(ssl) &&\n         EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n         ssl3_cbc_record_digest_supported(mac_ctx)) {\n         \/*\n@@ -1022,7 +1022,7 @@ int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int send)\n             EVP_MD_CTX_free(hmac);\n             return -1;\n         }\n-        if (!send && !SSL_USE_ETM(ssl) && FIPS_mode())\n+        if (!send && !SSL_READ_ETM(ssl) && FIPS_mode())\n             if (!tls_fips_digest_extra(ssl->enc_read_ctx,\n                                        mac_ctx, rec->input,\n                                        rec->length, rec->orig_len)) {\ndiff --git a\/ssl\/ssl_locl.h b\/ssl\/ssl_locl.h\nindex 1586a46f635..08de52eea2c 100644\n--- a\/ssl\/ssl_locl.h\n+++ b\/ssl\/ssl_locl.h\n@@ -378,7 +378,8 @@\n # define SSL_CLIENT_USE_SIGALGS(s)        \\\n     SSL_CLIENT_USE_TLS1_2_CIPHERS(s)\n \n-# define SSL_USE_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC)\n+# define SSL_READ_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC_READ)\n+# define SSL_WRITE_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE)\n \n \/* Mostly for SSLv3 *\/\n # define SSL_PKEY_RSA_ENC        0\n@@ -1110,6 +1111,10 @@ struct ssl_st {\n      *\/\n     unsigned char *alpn_client_proto_list;\n     unsigned alpn_client_proto_list_len;\n+\n+    \/* Set to one if we have negotiated ETM *\/\n+    int tlsext_use_etm;\n+\n     \/*-\n      * 1 if we are renegotiating.\n      * 2 if we are a server and are inside a handshake\ndiff --git a\/ssl\/t1_enc.c b\/ssl\/t1_enc.c\nindex 4aa5ddd18a3..0fb88af249e 100644\n--- a\/ssl\/t1_enc.c\n+++ b\/ssl\/t1_enc.c\n@@ -130,6 +130,11 @@ int tls1_change_cipher_state(SSL *s, int which)\n #endif\n \n     if (which & SSL3_CC_READ) {\n+        if (s->tlsext_use_etm)\n+            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;\n+        else\n+            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;\n+\n         if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n             s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;\n         else\n@@ -168,6 +173,11 @@ int tls1_change_cipher_state(SSL *s, int which)\n         mac_secret = &(s->s3->read_mac_secret[0]);\n         mac_secret_size = &(s->s3->read_mac_secret_size);\n     } else {\n+        if (s->tlsext_use_etm)\n+            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;\n+        else\n+            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;\n+\n         if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)\n             s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;\n         else\n@@ -367,9 +377,8 @@ int tls1_setup_key_block(SSL *s)\n     if (s->s3->tmp.key_block_length != 0)\n         return (1);\n \n-    if (!ssl_cipher_get_evp\n-        (s->session, &c, &hash, &mac_type, &mac_secret_size, &comp,\n-         SSL_USE_ETM(s))) {\n+    if (!ssl_cipher_get_evp(s->session, &c, &hash, &mac_type, &mac_secret_size,\n+                            &comp, s->tlsext_use_etm)) {\n         SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);\n         return (0);\n     }\ndiff --git a\/ssl\/t1_lib.c b\/ssl\/t1_lib.c\nindex b51d60a7cc5..b2688f6552b 100644\n--- a\/ssl\/t1_lib.c\n+++ b\/ssl\/t1_lib.c\n@@ -1674,7 +1674,7 @@ unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,\n #endif\n     if (!custom_ext_add(s, 1, &ret, limit, al))\n         return NULL;\n-    if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) {\n+    if (s->tlsext_use_etm) {\n         \/*\n          * Don't use encrypt_then_mac if AEAD or RC4 might want to disable\n          * for other cases too.\n@@ -1683,7 +1683,7 @@ unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf,\n             || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4\n             || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT\n             || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12)\n-            s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n+            s->tlsext_use_etm = 0;\n         else {\n             \/*-\n              * check for enough space.\n@@ -1916,7 +1916,7 @@ static int ssl_scan_clienthello_tlsext(SSL *s, PACKET *pkt, int *al)\n     \/* Clear any signature algorithms extension received *\/\n     OPENSSL_free(s->s3->tmp.peer_sigalgs);\n     s->s3->tmp.peer_sigalgs = NULL;\n-    s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n+    s->tlsext_use_etm = 0;\n \n #ifndef OPENSSL_NO_SRP\n     OPENSSL_free(s->srp_ctx.login);\n@@ -2264,7 +2264,7 @@ static int ssl_scan_clienthello_tlsext(SSL *s, PACKET *pkt, int *al)\n         }\n #endif\n         else if (type == TLSEXT_TYPE_encrypt_then_mac)\n-            s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;\n+            s->tlsext_use_etm = 1;\n         \/*\n          * Note: extended master secret extension handled in\n          * tls_check_serverhello_tlsext_early()\n@@ -2366,7 +2366,7 @@ static int ssl_scan_serverhello_tlsext(SSL *s, PACKET *pkt, int *al)\n                              SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);\n #endif\n \n-    s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;\n+    s->tlsext_use_etm = 0;\n \n     s->s3->flags &= ~TLS1_FLAGS_RECEIVED_EXTMS;\n \n@@ -2585,7 +2585,7 @@ static int ssl_scan_serverhello_tlsext(SSL *s, PACKET *pkt, int *al)\n             \/* Ignore if inappropriate ciphersuite *\/\n             if (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD\n                 && s->s3->tmp.new_cipher->algorithm_enc != SSL_RC4)\n-                s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;\n+                s->tlsext_use_etm = 1;\n         } else if (type == TLSEXT_TYPE_extended_master_secret) {\n             s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS;\n             if (!s->hit)\n","owner":"openssl","repo":"openssl","source":"cve"},{"CVE_ID":"CVE-2011-1080","CWE_ID":"20","category":"security","commit_id":"d846f71195d57b0bbb143382647c2c6638b04c5a","commit_message":"From d846f71195d57b0bbb143382647c2c6638b04c5a Mon Sep 17 00:00:00 2001\nFrom: Vasiliy Kulikov <segoon@openwall.com>\nDate: Mon, 14 Feb 2011 16:49:23 +0100\nSubject: bridge: netfilter: fix information leak\n\nStruct tmp is copied from userspace.  It is not checked whether the \"name\"\nfield is NULL terminated.  This may lead to buffer overflow and passing\ncontents of kernel stack as a module name to try_then_request_module() and,\nconsequently, to modprobe commandline.  It would be seen by all userspace\nprocesses.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Patrick McHardy <kaber@trash.net>\n---\n net\/bridge\/netfilter\/ebtables.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/net\/bridge\/netfilter\/ebtables.c b\/net\/bridge\/netfilter\/ebtables.c\nindex 5f1825df9dca..893669caa8de 100644\n--- a\/net\/bridge\/netfilter\/ebtables.c\n+++ b\/net\/bridge\/netfilter\/ebtables.c\n@@ -1107,6 +1107,8 @@ static int do_replace(struct net *net, const void __user *user,\n \tif (tmp.num_counters >= INT_MAX \/ sizeof(struct ebt_counter))\n \t\treturn -ENOMEM;\n \n+\ttmp.name[sizeof(tmp.name) - 1] = 0;\n+\n \tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n \tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n \tif (!newinfo)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-9242","CWE_ID":"20","category":"security","commit_id":"232cd35d0804cc241eb887bb8d4d9b3b9881c64a","commit_message":"From 232cd35d0804cc241eb887bb8d4d9b3b9881c64a Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Fri, 19 May 2017 14:17:48 -0700\nSubject: [PATCH] ipv6: fix out of bound writes in __ip6_append_data()\n\nAndrey Konovalov and idaifish@gmail.com reported crashes caused by\none skb shared_info being overwritten from __ip6_append_data()\n\nAndrey program lead to following state :\n\ncopy -4200 datalen 2000 fraglen 2040\nmaxfraglen 2040 alloclen 2048 transhdrlen 0 offset 0 fraggap 6200\n\nThe skb_copy_and_csum_bits(skb_prev, maxfraglen, data + transhdrlen,\nfraggap, 0); is overwriting skb->head and skb_shared_info\n\nSince we apparently detect this rare condition too late, move the\ncode earlier to even avoid allocating skb and risking crashes.\n\nOnce again, many thanks to Andrey and syzkaller team.\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nReported-by: <idaifish@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/ip6_output.c | 15 ++++++++-------\n 1 file changed, 8 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/ip6_output.c b\/net\/ipv6\/ip6_output.c\nindex d4a31becbd25d..bf8a58a1c32d8 100644\n--- a\/net\/ipv6\/ip6_output.c\n+++ b\/net\/ipv6\/ip6_output.c\n@@ -1466,6 +1466,11 @@ static int __ip6_append_data(struct sock *sk,\n \t\t\t *\/\n \t\t\talloclen += sizeof(struct frag_hdr);\n \n+\t\t\tcopy = datalen - transhdrlen - fraggap;\n+\t\t\tif (copy < 0) {\n+\t\t\t\terr = -EINVAL;\n+\t\t\t\tgoto error;\n+\t\t\t}\n \t\t\tif (transhdrlen) {\n \t\t\t\tskb = sock_alloc_send_skb(sk,\n \t\t\t\t\t\talloclen + hh_len,\n@@ -1515,13 +1520,9 @@ static int __ip6_append_data(struct sock *sk,\n \t\t\t\tdata += fraggap;\n \t\t\t\tpskb_trim_unique(skb_prev, maxfraglen);\n \t\t\t}\n-\t\t\tcopy = datalen - transhdrlen - fraggap;\n-\n-\t\t\tif (copy < 0) {\n-\t\t\t\terr = -EINVAL;\n-\t\t\t\tkfree_skb(skb);\n-\t\t\t\tgoto error;\n-\t\t\t} else if (copy > 0 && getfrag(from, data + transhdrlen, offset, copy, fraggap, skb) < 0) {\n+\t\t\tif (copy > 0 &&\n+\t\t\t    getfrag(from, data + transhdrlen, offset,\n+\t\t\t\t    copy, fraggap, skb) < 0) {\n \t\t\t\terr = -EFAULT;\n \t\t\t\tkfree_skb(skb);\n \t\t\t\tgoto error;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-5361","CWE_ID":"20","category":"security","commit_id":"152d6d95632d8b9477c170f1de99bcd86d7fb1d6","commit_message":"From 152d6d95632d8b9477c170f1de99bcd86d7fb1d6 Mon Sep 17 00:00:00 2001\nFrom: Paul Wouters <pwouters@redhat.com>\nDate: Sun, 27 Mar 2016 12:31:50 -0400\nSubject: [PATCH] IKEv1: packet retransmit fixes for Main\/Aggr\/Xauth modes\n\n- Do not schedule retransmits for inI1outR1 packets (prevent DDOS)\n- Do schedule retransmits for XAUTH packets\n---\n programs\/pluto\/ikev1.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/programs\/pluto\/ikev1.c b\/programs\/pluto\/ikev1.c\nindex 67734dfcae..8bc61837ac 100644\n--- a\/programs\/pluto\/ikev1.c\n+++ b\/programs\/pluto\/ikev1.c\n@@ -245,7 +245,7 @@ static const struct state_microcode v1_state_microcode_table[] = {\n \t{ STATE_MAIN_R0, STATE_MAIN_R1,\n \t  SMF_ALL_AUTH | SMF_REPLY,\n \t  P(SA), P(VID) | P(CR), PT(NONE),\n-\t  EVENT_v1_RETRANSMIT, main_inI1_outR1 },\n+\t  EVENT_NULL, main_inI1_outR1 },\n \n \t\/* STATE_MAIN_I1: R1 --> I2\n \t * HDR, SA --> auth dependent\n@@ -394,7 +394,7 @@ static const struct state_microcode v1_state_microcode_table[] = {\n \t{ STATE_AGGR_R0, STATE_AGGR_R1,\n \t  SMF_PSK_AUTH | SMF_DS_AUTH | SMF_REPLY,\n \t  P(SA) | P(KE) | P(NONCE) | P(ID), P(VID) | P(NATD_RFC), PT(NONE),\n-\t  EVENT_v1_RETRANSMIT, aggr_inI1_outR1 },\n+\t  EVENT_NULL, aggr_inI1_outR1 },\n \n \t\/* STATE_AGGR_I1:\n \t * SMF_PSK_AUTH: HDR, SA, KE, Nr, IDir, HASH_R\n@@ -571,12 +571,12 @@ static const struct state_microcode v1_state_microcode_table[] = {\n \t{ STATE_XAUTH_I0, STATE_XAUTH_I1,\n \t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,\n \t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n-\t  EVENT_SA_REPLACE, xauth_inI0 },\n+\t  EVENT_v1_RETRANSMIT, xauth_inI0 },\n \n \t{ STATE_XAUTH_I1, STATE_MAIN_I4,\n \t  SMF_ALL_AUTH | SMF_ENCRYPTED | SMF_REPLY | SMF_RELEASE_PENDING_P2,\n \t  P(MCFG_ATTR) | P(HASH), P(VID), PT(HASH),\n-\t  EVENT_SA_REPLACE, xauth_inI1 },\n+\t  EVENT_v1_RETRANSMIT, xauth_inI1 },\n \n #undef P\n #undef PT\n","owner":"libreswan","repo":"libreswan","source":"cve"},{"CVE_ID":"CVE-2013-4587","CWE_ID":"20","category":"security","commit_id":"338c7dbadd2671189cec7faf64c84d01071b3f96","commit_message":"From 338c7dbadd2671189cec7faf64c84d01071b3f96 Mon Sep 17 00:00:00 2001\nFrom: Andy Honig <ahonig@google.com>\nDate: Mon, 18 Nov 2013 16:09:22 -0800\nSubject: KVM: Improve create VCPU parameter (CVE-2013-4587)\n\nIn multiple functions the vcpu_id is used as an offset into a bitfield.  Ag\nmalicious user could specify a vcpu_id greater than 255 in order to set or\nclear bits in kernel memory.  This could be used to elevate priveges in the\nkernel.  This patch verifies that the vcpu_id provided is less than 255.\nThe api documentation already specifies that the vcpu_id must be less than\nmax_vcpus, but this is currently not checked.\n\nReported-by: Andrew Honig <ahonig@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Andrew Honig <ahonig@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n virt\/kvm\/kvm_main.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/virt\/kvm\/kvm_main.c b\/virt\/kvm\/kvm_main.c\nindex a0aa84b5941a..4f588bc94186 100644\n--- a\/virt\/kvm\/kvm_main.c\n+++ b\/virt\/kvm\/kvm_main.c\n@@ -1898,6 +1898,9 @@ static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n \tint r;\n \tstruct kvm_vcpu *vcpu, *v;\n \n+\tif (id >= KVM_MAX_VCPUS)\n+\t\treturn -EINVAL;\n+\n \tvcpu = kvm_arch_vcpu_create(kvm, id);\n \tif (IS_ERR(vcpu))\n \t\treturn PTR_ERR(vcpu);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-4964","CWE_ID":"20","category":"security","commit_id":"06630554ccbdd25780aa03c3548aaff1eb56dffd","commit_message":"From 06630554ccbdd25780aa03c3548aaff1eb56dffd Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Tue, 24 May 2016 13:37:44 +0530\nSubject: [PATCH] scsi: mptsas: infinite loop while fetching requests\n\nThe LSI SAS1068 Host Bus Adapter emulator in Qemu, periodically\nlooks for requests and fetches them. A loop doing that in\nmptsas_fetch_requests() could run infinitely if 's->state' was\nnot operational. Move check to avoid such a loop.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nCc: qemu-stable@nongnu.org\nMessage-Id: <1464077264-25473-1-git-send-email-ppandit@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n hw\/scsi\/mptsas.c | 9 ++++-----\n 1 file changed, 4 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/hw\/scsi\/mptsas.c b\/hw\/scsi\/mptsas.c\nindex 499c146..be88e16 100644\n--- a\/hw\/scsi\/mptsas.c\n+++ b\/hw\/scsi\/mptsas.c\n@@ -754,11 +754,6 @@ static void mptsas_fetch_request(MPTSASState *s)\n     hwaddr addr;\n     int size;\n \n-    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n-        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n-        return;\n-    }\n-\n     \/* Read the message header from the guest first. *\/\n     addr = s->host_mfa_high_addr | MPTSAS_FIFO_GET(s, request_post);\n     pci_dma_read(pci, addr, req, sizeof(hdr));\n@@ -789,6 +784,10 @@ static void mptsas_fetch_requests(void *opaque)\n {\n     MPTSASState *s = opaque;\n \n+    if (s->state != MPI_IOC_STATE_OPERATIONAL) {\n+        mptsas_set_fault(s, MPI_IOCSTATUS_INVALID_STATE);\n+        return;\n+    }\n     while (!MPTSAS_FIFO_EMPTY(s, request_post)) {\n         mptsas_fetch_request(s);\n     }\n-- \n1.8.3.1\n\n","owner":"qemu","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2017-9217","CWE_ID":"20","category":"security","commit_id":"a924f43f30f9c4acaf70618dd2a055f8b0f166be","commit_message":"From a924f43f30f9c4acaf70618dd2a055f8b0f166be Mon Sep 17 00:00:00 2001\nFrom: Evgeny Vereshchagin <evvers@ya.ru>\nDate: Wed, 24 May 2017 08:56:48 +0300\nSubject: [PATCH] resolved: bugfix of null pointer p->question dereferencing\n (#6020)\n\nSee https:\/\/bugs.launchpad.net\/ubuntu\/+source\/systemd\/+bug\/1621396\n---\n src\/resolve\/resolved-dns-packet.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/src\/resolve\/resolved-dns-packet.c b\/src\/resolve\/resolved-dns-packet.c\nindex 652970284ed..240ee448f4e 100644\n--- a\/src\/resolve\/resolved-dns-packet.c\n+++ b\/src\/resolve\/resolved-dns-packet.c\n@@ -2269,6 +2269,9 @@ int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n         if (r < 0)\n                 return r;\n \n+        if (!p->question)\n+                return 0;\n+\n         if (p->question->n_keys != 1)\n                 return 0;\n \n","owner":"systemd","repo":"systemd","source":"cve"},{"CVE_ID":"CVE-2018-6347","CWE_ID":"20","category":"security","commit_id":"223e0aa6bc7590e86af1e917185a2e0efe160711","commit_message":"From 223e0aa6bc7590e86af1e917185a2e0efe160711 Mon Sep 17 00:00:00 2001\nFrom: Alan Frindell <afrind@fb.com>\nDate: Thu, 27 Dec 2018 16:11:46 -0800\nSubject: [PATCH] Don't lower lastStreamID_\n\nSummary:\nThis could throw off the logic about what is headers\/trailers\nCVE-2018-6347\n\nReviewed By: avasylev, bolekk\n\nDifferential Revision: D13521704\n\nfbshipit-source-id: ed436ff13f191bf04764494973fcb73b35ed1256\n---\n proxygen\/lib\/http\/codec\/HTTP2Codec.cpp        |  3 +-\n ...\/lib\/http\/codec\/test\/HTTP2CodecTest.cpp    | 25 +++++++++++++++\n ...\/test\/HTTPDownstreamSessionTest.cpp        | 32 +++++++++++++++++++\n ...\/lib\/http\/session\/test\/HTTPSessionMocks.h  | 11 +++++++\n 4 files changed, 70 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/proxygen\/lib\/http\/codec\/HTTP2Codec.cpp b\/proxygen\/lib\/http\/codec\/HTTP2Codec.cpp\nindex db9a82731..d3095d626 100644\n--- a\/proxygen\/lib\/http\/codec\/HTTP2Codec.cpp\n+++ b\/proxygen\/lib\/http\/codec\/HTTP2Codec.cpp\n@@ -987,7 +987,7 @@ ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n     VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n   }\n \n-  if (sessionClosing_ != ClosingState::CLOSED) {\n+  if (sessionClosing_ != ClosingState::CLOSED && streamId > lastStreamID_) {\n     lastStreamID_ = streamId;\n   }\n \n@@ -1313,6 +1313,7 @@ size_t HTTP2Codec::generateChunkTerminator(folly::IOBufQueue& \/*writeBuf*\/,\n size_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                     StreamID stream,\n                                     const HTTPHeaders& trailers) {\n+  VLOG(4) << \"generating TRAILERS for stream=\" << stream;\n   std::vector<compress::Header> allHeaders;\n   CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n \ndiff --git a\/proxygen\/lib\/http\/codec\/test\/HTTP2CodecTest.cpp b\/proxygen\/lib\/http\/codec\/test\/HTTP2CodecTest.cpp\nindex 22471b13e..c123e0d3a 100644\n--- a\/proxygen\/lib\/http\/codec\/test\/HTTP2CodecTest.cpp\n+++ b\/proxygen\/lib\/http\/codec\/test\/HTTP2CodecTest.cpp\n@@ -2145,3 +2145,28 @@ TEST_F(HTTP2CodecTest, TrailersReplyMissingContinuation) {\n   EXPECT_EQ(upstreamCodec_.getReceivedFrameCount(), 4);\n #endif\n }\n+\n+TEST_F(HTTP2CodecTest, TrailersNotLatest) {\n+  HTTPMessage req = getGetRequest(\"\/guacamole\");\n+  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n+  upstreamCodec_.generateHeader(output_, 1, req);\n+  upstreamCodec_.generateHeader(output_, 3, req);\n+\n+  HTTPHeaders trailers;\n+  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n+  upstreamCodec_.generateTrailers(output_, 1, trailers);\n+  upstreamCodec_.generateHeader(output_, 3, req);\n+\n+  parse();\n+\n+  EXPECT_EQ(callbacks_.messageBegin, 2);\n+  EXPECT_EQ(callbacks_.headersComplete, 2);\n+  EXPECT_EQ(callbacks_.bodyCalls, 0);\n+  EXPECT_EQ(callbacks_.trailers, 1);\n+  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n+  EXPECT_EQ(\"pico-de-gallo\",\n+            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n+  EXPECT_EQ(callbacks_.messageComplete, 1);\n+  EXPECT_EQ(callbacks_.streamErrors, 1);\n+  EXPECT_EQ(callbacks_.sessionErrors, 0);\n+}\ndiff --git a\/proxygen\/lib\/http\/session\/test\/HTTPDownstreamSessionTest.cpp b\/proxygen\/lib\/http\/session\/test\/HTTPDownstreamSessionTest.cpp\nindex a54088d95..f3478c52c 100644\n--- a\/proxygen\/lib\/http\/session\/test\/HTTPDownstreamSessionTest.cpp\n+++ b\/proxygen\/lib\/http\/session\/test\/HTTPDownstreamSessionTest.cpp\n@@ -3568,3 +3568,35 @@ TEST_F(HTTP2DownstreamSessionTest, TestSetEgressSettings) {\n   flushRequestsAndLoop();\n   gracefulShutdown();\n }\n+\n+TEST_F(HTTP2DownstreamSessionTest, TestDuplicateRequestStream) {\n+  \/\/ Send the following:\n+  \/\/ HEADERS id=1\n+  \/\/ HEADERS id=2\n+  \/\/ HEADERS id=1 (trailers)\n+  \/\/ HEADERS id=2 -> contains pseudo-headers after EOM so ignored\n+  auto handler2 = addSimpleStrictHandler();\n+  auto handler1 = addSimpleStrictHandler();\n+  auto streamID1 = sendRequest(\"\/withtrailers\", 0, false);\n+  auto streamID2 = sendRequest();\n+  HTTPHeaders trailers;\n+  trailers.add(\"Foo\", \"Bar\");\n+  clientCodec_->generateTrailers(requests_, streamID1, trailers);\n+  clientCodec_->generateEOM(requests_, streamID1);\n+\n+  clientCodec_->generateHeader(requests_, streamID2, getGetRequest(), false);\n+  handler1->expectHeaders();\n+  handler2->expectHeaders();\n+  handler2->expectEOM();\n+  handler1->expectTrailers();\n+  handler1->expectEOM([&] {\n+      handler1->sendReplyWithBody(200, 100);\n+      \/\/ 2 got an error after EOM, which gets ignored - need a response to\n+      \/\/ cleanly terminate it\n+      handler2->sendReplyWithBody(200, 100);\n+    });\n+  handler1->expectDetachTransaction();\n+  handler2->expectDetachTransaction();\n+  flushRequestsAndLoop();\n+  gracefulShutdown();\n+}\ndiff --git a\/proxygen\/lib\/http\/session\/test\/HTTPSessionMocks.h b\/proxygen\/lib\/http\/session\/test\/HTTPSessionMocks.h\nindex 9af0ea7a2..9b3f81ae0 100644\n--- a\/proxygen\/lib\/http\/session\/test\/HTTPSessionMocks.h\n+++ b\/proxygen\/lib\/http\/session\/test\/HTTPSessionMocks.h\n@@ -221,6 +221,17 @@ class MockHTTPHandler\n         .RetiresOnSaturation();\n   }\n \n+  void expectTrailers(\n+      std::function<void()> callback = std::function<void()>()) {\n+    if (callback) {\n+      EXPECT_CALL(*this, onTrailers(testing::_))\n+          .WillOnce(testing::InvokeWithoutArgs(callback))\n+          .RetiresOnSaturation();\n+    } else {\n+      EXPECT_CALL(*this, onTrailers(testing::_));\n+    }\n+  }\n+\n   void expectTrailers(\n       std::function<void(std::shared_ptr<HTTPHeaders> trailers)> cb) {\n     EXPECT_CALL(*this, onTrailers(testing::_))\n","owner":"facebook","repo":"proxygen","source":"cve"},{"CVE_ID":"CVE-2014-9645","CWE_ID":"20","category":"security","commit_id":"4e314faa0aecb66717418e9a47a4451aec59262b","commit_message":"From 4e314faa0aecb66717418e9a47a4451aec59262b Mon Sep 17 00:00:00 2001\nFrom: Denys Vlasenko <vda.linux@googlemail.com>\nDate: Thu, 20 Nov 2014 18:24:33 +0100\nSubject: modprobe,rmmod: reject module names with slashes\n\nfunction                                             old     new   delta\nadd_probe                                             86     113     +27\n\nSigned-off-by: Denys Vlasenko <vda.linux@googlemail.com>\n---\n modutils\/modprobe.c | 11 +++++++++++\n 1 file changed, 11 insertions(+)\n\n","diff_code":"diff --git a\/modutils\/modprobe.c b\/modutils\/modprobe.c\nindex f08f0850d..f0904285b 100644\n--- a\/modutils\/modprobe.c\n+++ b\/modutils\/modprobe.c\n@@ -238,6 +238,17 @@ static void add_probe(const char *name)\n {\n \tstruct module_entry *m;\n \n+\t\/*\n+\t * get_or_add_modentry() strips path from name and works\n+\t * on remaining basename.\n+\t * This would make \"rmmod dir\/name\" and \"modprobe dir\/name\"\n+\t * to work like \"rmmod name\" and \"modprobe name\",\n+\t * which is wrong, and can be abused via implicit modprobing:\n+\t * \"ifconfig \/usbserial up\" tries to modprobe netdev-\/usbserial.\n+\t *\/\n+\tif (strchr(name, '\/'))\n+\t\tbb_error_msg_and_die(\"malformed module name '%s'\", name);\n+\n \tm = get_or_add_modentry(name);\n \tif (!(option_mask32 & (OPT_REMOVE | OPT_SHOW_DEPS))\n \t && (m->flags & MODULE_FLAG_LOADED)\n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-7294","CWE_ID":"20","category":"security","commit_id":"2899351224fe2940aec37d7656e1e392c0fe07f0","commit_message":"From 2899351224fe2940aec37d7656e1e392c0fe07f0 Mon Sep 17 00:00:00 2001\nFrom: Paul Wouters <pwouters@redhat.com>\nDate: Tue, 26 Nov 2013 19:46:49 -0500\nSubject: [PATCH] SECURITY: Properly handle IKEv2 I1 notification packet\n without KE payload\n\n---\n programs\/pluto\/ikev2_parent.c | 31 ++++++++++++++++++-------------\n 1 file changed, 18 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/programs\/pluto\/ikev2_parent.c b\/programs\/pluto\/ikev2_parent.c\nindex 72526ba039..ce67cc3c03 100644\n--- a\/programs\/pluto\/ikev2_parent.c\n+++ b\/programs\/pluto\/ikev2_parent.c\n@@ -306,8 +306,6 @@ static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n \t}\n \treset_cur_state();\n \treset_globals();\n-\n-\tpassert(GLOBALS_ARE_RESET());\n }\n \n \/*\n@@ -729,18 +727,31 @@ stf_status ikev2parent_inI1outR1(struct msg_digest *md)\n \t *\/\n \t{\n \t\tstruct ikev2_ke *ke;\n+\t\tchar fromname[ADDRTOT_BUF];\n+\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n+\n+\t\tif (!md->chain[ISAKMP_NEXT_v2KE]) {\n+\t\t\t\/* is this a notify? If so, log it *\/\n+\t\t\tif(md->chain[ISAKMP_NEXT_v2N]) {\n+\t\t\t\tlibreswan_log(\"Received Notify(%d): %s\",\n+\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,\n+\t\t\t\t\tenum_name(&ikev2_notify_names,\n+\t\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));\n+\t\t\t}\n+\t\t\tlibreswan_log(\n+\t\t\t\t\"rejecting I1 from %s:%u, no KE payload present\",\n+\t\t\t\tfromname, md->sender_port);\n+\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n+\t\t}\n \t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n \n \t\tst->st_oakley.group = lookup_group(ke->isak_group);\n \t\tif (st->st_oakley.group == NULL) {\n-\t\t\tchar fromname[ADDRTOT_BUF];\n-\n-\t\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n \t\t\tlibreswan_log(\n \t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",\n \t\t\t\tfromname, md->sender_port,\n \t\t\t\tke->isak_group);\n-\t\t\treturn v2N_INVALID_KE_PAYLOAD;\n+\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n \t\t}\n \t}\n \n@@ -819,8 +830,6 @@ static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n \t\t\trelease_md(ke->md);\n \t}\n \treset_globals();\n-\n-\tpassert(GLOBALS_ARE_RESET());\n }\n \n static stf_status ikev2_parent_inI1outR1_tail(\n@@ -1145,8 +1154,6 @@ static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n \t\t\trelease_md(dh->md);\n \t}\n \treset_globals();\n-\n-\tpassert(GLOBALS_ARE_RESET());\n }\n \n static void ikev2_padup_pre_encrypt(struct msg_digest *md,\n@@ -1714,7 +1721,7 @@ stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n \t\/* verify that there is in fact an encrypted payload *\/\n \tif (!md->chain[ISAKMP_NEXT_v2E]) {\n \t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n-\t\treset_globals();\n+\t\treset_globals(); \/* XXX suspicious - why was this deemed neccessary? *\/\n \t\treturn STF_FATAL;\n \t}\n \n@@ -1794,8 +1801,6 @@ static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n \t\t\trelease_md(dh->md);\n \t}\n \treset_globals();\n-\n-\tpassert(GLOBALS_ARE_RESET());\n }\n \n static stf_status ikev2_parent_inI2outR2_tail(\n","owner":"libreswan","repo":"libreswan","source":"cve"},{"CVE_ID":"CVE-2014-5471","CWE_ID":"20","category":"security","commit_id":"410dd3cf4c9b36f27ed4542ee18b1af5e68645a4","commit_message":"From 410dd3cf4c9b36f27ed4542ee18b1af5e68645a4 Mon Sep 17 00:00:00 2001\nFrom: Jan Kara <jack@suse.cz>\nDate: Sun, 17 Aug 2014 11:49:57 +0200\nSubject: isofs: Fix unbounded recursion when processing relocated directories\n\nWe did not check relocated directory in any way when processing Rock\nRidge 'CL' tag. Thus a corrupted isofs image can possibly have a CL\nentry pointing to another CL entry leading to possibly unbounded\nrecursion in kernel code and thus stack overflow or deadlocks (if there\nis a loop created from CL entries).\n\nFix the problem by not allowing CL entry to point to a directory entry\nwith CL entry (such use makes no good sense anyway) and by checking\nwhether CL entry doesn't point to itself.\n\nCC: stable@vger.kernel.org\nReported-by: Chris Evans <cevans@google.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\n---\n fs\/isofs\/inode.c | 15 ++++++++-------\n fs\/isofs\/isofs.h | 23 +++++++++++++++++++----\n fs\/isofs\/rock.c  | 39 ++++++++++++++++++++++++++++-----------\n 3 files changed, 55 insertions(+), 22 deletions(-)\n\n","diff_code":"diff --git a\/fs\/isofs\/inode.c b\/fs\/isofs\/inode.c\nindex 4556ce1af5b0..5ddaf8625d3b 100644\n--- a\/fs\/isofs\/inode.c\n+++ b\/fs\/isofs\/inode.c\n@@ -61,7 +61,7 @@ static void isofs_put_super(struct super_block *sb)\n \treturn;\n }\n \n-static int isofs_read_inode(struct inode *);\n+static int isofs_read_inode(struct inode *, int relocated);\n static int isofs_statfs (struct dentry *, struct kstatfs *);\n \n static struct kmem_cache *isofs_inode_cachep;\n@@ -1259,7 +1259,7 @@ out_toomany:\n \tgoto out;\n }\n \n-static int isofs_read_inode(struct inode *inode)\n+static int isofs_read_inode(struct inode *inode, int relocated)\n {\n \tstruct super_block *sb = inode->i_sb;\n \tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n@@ -1404,7 +1404,7 @@ static int isofs_read_inode(struct inode *inode)\n \t *\/\n \n \tif (!high_sierra) {\n-\t\tparse_rock_ridge_inode(de, inode);\n+\t\tparse_rock_ridge_inode(de, inode, relocated);\n \t\t\/* if we want uid\/gid set, override the rock ridge setting *\/\n \t\tif (sbi->s_uid_set)\n \t\t\tinode->i_uid = sbi->s_uid;\n@@ -1483,9 +1483,10 @@ static int isofs_iget5_set(struct inode *ino, void *data)\n  * offset that point to the underlying meta-data for the inode.  The\n  * code below is otherwise similar to the iget() code in\n  * include\/linux\/fs.h *\/\n-struct inode *isofs_iget(struct super_block *sb,\n-\t\t\t unsigned long block,\n-\t\t\t unsigned long offset)\n+struct inode *__isofs_iget(struct super_block *sb,\n+\t\t\t   unsigned long block,\n+\t\t\t   unsigned long offset,\n+\t\t\t   int relocated)\n {\n \tunsigned long hashval;\n \tstruct inode *inode;\n@@ -1507,7 +1508,7 @@ struct inode *isofs_iget(struct super_block *sb,\n \t\treturn ERR_PTR(-ENOMEM);\n \n \tif (inode->i_state & I_NEW) {\n-\t\tret = isofs_read_inode(inode);\n+\t\tret = isofs_read_inode(inode, relocated);\n \t\tif (ret < 0) {\n \t\t\tiget_failed(inode);\n \t\t\tinode = ERR_PTR(ret);\ndiff --git a\/fs\/isofs\/isofs.h b\/fs\/isofs\/isofs.h\nindex 99167238518d..0ac4c1f73fbd 100644\n--- a\/fs\/isofs\/isofs.h\n+++ b\/fs\/isofs\/isofs.h\n@@ -107,7 +107,7 @@ extern int iso_date(char *, int);\n \n struct inode;\t\t\/* To make gcc happy *\/\n \n-extern int parse_rock_ridge_inode(struct iso_directory_record *, struct inode *);\n+extern int parse_rock_ridge_inode(struct iso_directory_record *, struct inode *, int relocated);\n extern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\n extern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\n \n@@ -118,9 +118,24 @@ extern struct dentry *isofs_lookup(struct inode *, struct dentry *, unsigned int\n extern struct buffer_head *isofs_bread(struct inode *, sector_t);\n extern int isofs_get_blocks(struct inode *, sector_t, struct buffer_head **, unsigned long);\n \n-extern struct inode *isofs_iget(struct super_block *sb,\n-                                unsigned long block,\n-                                unsigned long offset);\n+struct inode *__isofs_iget(struct super_block *sb,\n+\t\t\t   unsigned long block,\n+\t\t\t   unsigned long offset,\n+\t\t\t   int relocated);\n+\n+static inline struct inode *isofs_iget(struct super_block *sb,\n+\t\t\t\t       unsigned long block,\n+\t\t\t\t       unsigned long offset)\n+{\n+\treturn __isofs_iget(sb, block, offset, 0);\n+}\n+\n+static inline struct inode *isofs_iget_reloc(struct super_block *sb,\n+\t\t\t\t\t     unsigned long block,\n+\t\t\t\t\t     unsigned long offset)\n+{\n+\treturn __isofs_iget(sb, block, offset, 1);\n+}\n \n \/* Because the inode number is no longer relevant to finding the\n  * underlying meta-data for an inode, we are free to choose a more\ndiff --git a\/fs\/isofs\/rock.c b\/fs\/isofs\/rock.c\nindex c0bf42472e40..f488bbae541a 100644\n--- a\/fs\/isofs\/rock.c\n+++ b\/fs\/isofs\/rock.c\n@@ -288,12 +288,16 @@ eio:\n \tgoto out;\n }\n \n+#define RR_REGARD_XA 1\n+#define RR_RELOC_DE 2\n+\n static int\n parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n-\t\t\t\tstruct inode *inode, int regard_xa)\n+\t\t\t\tstruct inode *inode, int flags)\n {\n \tint symlink_len = 0;\n \tint cnt, sig;\n+\tunsigned int reloc_block;\n \tstruct inode *reloc;\n \tstruct rock_ridge *rr;\n \tint rootflag;\n@@ -305,7 +309,7 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n \n \tinit_rock_state(&rs, inode);\n \tsetup_rock_ridge(de, inode, &rs);\n-\tif (regard_xa) {\n+\tif (flags & RR_REGARD_XA) {\n \t\trs.chr += 14;\n \t\trs.len -= 14;\n \t\tif (rs.len < 0)\n@@ -485,12 +489,22 @@ repeat:\n \t\t\t\t\t\"relocated directory\\n\");\n \t\t\tgoto out;\n \t\tcase SIG('C', 'L'):\n-\t\t\tISOFS_I(inode)->i_first_extent =\n-\t\t\t    isonum_733(rr->u.CL.location);\n-\t\t\treloc =\n-\t\t\t    isofs_iget(inode->i_sb,\n-\t\t\t\t       ISOFS_I(inode)->i_first_extent,\n-\t\t\t\t       0);\n+\t\t\tif (flags & RR_RELOC_DE) {\n+\t\t\t\tprintk(KERN_ERR\n+\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n+\t\t\t\t       \"is not supported\\n\");\n+\t\t\t\tgoto eio;\n+\t\t\t}\n+\t\t\treloc_block = isonum_733(rr->u.CL.location);\n+\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n+\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n+\t\t\t\tprintk(KERN_ERR\n+\t\t\t\t       \"ISOFS: Directory relocation points to \"\n+\t\t\t\t       \"itself\\n\");\n+\t\t\t\tgoto eio;\n+\t\t\t}\n+\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n+\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n \t\t\tif (IS_ERR(reloc)) {\n \t\t\t\tret = PTR_ERR(reloc);\n \t\t\t\tgoto out;\n@@ -637,9 +651,11 @@ static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n \treturn rpnt;\n }\n \n-int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)\n+int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n+\t\t\t   int relocated)\n {\n-\tint result = parse_rock_ridge_inode_internal(de, inode, 0);\n+\tint flags = relocated ? RR_RELOC_DE : 0;\n+\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n \n \t\/*\n \t * if rockridge flag was reset and we didn't look for attributes\n@@ -647,7 +663,8 @@ int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)\n \t *\/\n \tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n \t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n-\t\tresult = parse_rock_ridge_inode_internal(de, inode, 14);\n+\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n+\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n \t}\n \treturn result;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-9499","CWE_ID":"20","category":"security","commit_id":"7fd419441bc7103398e313558171d342c6315f44","commit_message":"From 7fd419441bc7103398e313558171d342c6315f44 Mon Sep 17 00:00:00 2001\nFrom: Dirk Lemstra <dirk@git.imagemagick.org>\nDate: Mon, 15 May 2017 21:43:29 +0200\nSubject: [PATCH] Added check for incorrect number of meta channels report in\n #492.\n\n---\n coders\/mpc.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/coders\/mpc.c b\/coders\/mpc.c\nindex 8088da4925..86359572d1 100644\n--- a\/coders\/mpc.c\n+++ b\/coders\/mpc.c\n@@ -568,6 +568,9 @@ static Image *ReadMPCImage(const ImageInfo *image_info,ExceptionInfo *exception)\n                 if (LocaleCompare(keyword,\"number-meta-channels\") == 0)\n                   {\n                     image->number_meta_channels=StringToUnsignedLong(options);\n+                    if (image->number_meta_channels > MaxPixelChannels)\n+                      ThrowReaderException(CorruptImageError,\n+                        \"ImproperImageHeader\");\n                     break;\n                   }\n                 break;\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2012-0853","CWE_ID":"20","category":"security","commit_id":"c509f4f74713b035a06f79cb4d00e708f5226bc5","commit_message":"From c509f4f74713b035a06f79cb4d00e708f5226bc5 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sat, 17 Dec 2011 03:18:58 +0100\nSubject: [PATCH] atrac3: Fix crash in tonal component decoding.\n\nAdd a check to avoid writing past the end of the channel_unit.components[]\narray.\n\nBug Found by: cosminamironesei\nFixes CVE-2012-0853\nCC: libav-stable@libav.org\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\nSigned-off-by: Justin Ruggles <justin.ruggles@gmail.com>\n---\n libavcodec\/atrac3.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/atrac3.c b\/libavcodec\/atrac3.c\nindex fd036e7..136b16c 100644\n--- a\/libavcodec\/atrac3.c\n+++ b\/libavcodec\/atrac3.c\n@@ -402,6 +402,8 @@ static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent\n \n             for (k=0; k<coded_components; k++) {\n                 sfIndx = get_bits(gb,6);\n+                if (component_count >= 64)\n+                    return AVERROR_INVALIDDATA;\n                 pComponent[component_count].pos = j * 64 + (get_bits(gb,6));\n                 max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;\n                 coded_values = coded_values_per_component + 1;\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-6197","CWE_ID":"20","category":"security","commit_id":"11f3710417d026ea2f4fcf362d866342c5274185","commit_message":"From 11f3710417d026ea2f4fcf362d866342c5274185 Mon Sep 17 00:00:00 2001\nFrom: Miklos Szeredi <mszeredi@redhat.com>\nDate: Mon, 21 Mar 2016 17:31:44 +0100\nSubject: [PATCH] ovl: verify upper dentry before unlink and rename\n\nUnlink and rename in overlayfs checked the upper dentry for staleness by\nverifying upper->d_parent against upperdir.  However the dentry can go\nstale also by being unhashed, for example.\n\nExpand the verification to actually look up the name again (under parent\nlock) and check if it matches the upper dentry.  This matches what the VFS\ndoes before passing the dentry to filesytem's unlink\/rename methods, which\nexcludes any inconsistency caused by overlayfs.\n\nSigned-off-by: Miklos Szeredi <mszeredi@redhat.com>\n---\n fs\/overlayfs\/dir.c | 59 +++++++++++++++++++++++++++++-----------------\n 1 file changed, 38 insertions(+), 21 deletions(-)\n\n","diff_code":"diff --git a\/fs\/overlayfs\/dir.c b\/fs\/overlayfs\/dir.c\nindex 52f6de5d40a92..bc1758a160f6d 100644\n--- a\/fs\/overlayfs\/dir.c\n+++ b\/fs\/overlayfs\/dir.c\n@@ -596,21 +596,25 @@ static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n {\n \tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n \tstruct inode *dir = upperdir->d_inode;\n-\tstruct dentry *upper = ovl_dentry_upper(dentry);\n+\tstruct dentry *upper;\n \tint err;\n \n \tinode_lock_nested(dir, I_MUTEX_PARENT);\n+\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n+\t\t\t       dentry->d_name.len);\n+\terr = PTR_ERR(upper);\n+\tif (IS_ERR(upper))\n+\t\tgoto out_unlock;\n+\n \terr = -ESTALE;\n-\tif (upper->d_parent == upperdir) {\n-\t\t\/* Don't let d_delete() think it can reset d_inode *\/\n-\t\tdget(upper);\n+\tif (upper == ovl_dentry_upper(dentry)) {\n \t\tif (is_dir)\n \t\t\terr = vfs_rmdir(dir, upper);\n \t\telse\n \t\t\terr = vfs_unlink(dir, upper, NULL);\n-\t\tdput(upper);\n \t\tovl_dentry_version_inc(dentry->d_parent);\n \t}\n+\tdput(upper);\n \n \t\/*\n \t * Keeping this dentry hashed would mean having to release\n@@ -620,6 +624,7 @@ static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n \t *\/\n \tif (!err)\n \t\td_drop(dentry);\n+out_unlock:\n \tinode_unlock(dir);\n \n \treturn err;\n@@ -840,29 +845,39 @@ static int ovl_rename2(struct inode *olddir, struct dentry *old,\n \n \ttrap = lock_rename(new_upperdir, old_upperdir);\n \n-\tolddentry = ovl_dentry_upper(old);\n-\tnewdentry = ovl_dentry_upper(new);\n-\tif (newdentry) {\n+\n+\tolddentry = lookup_one_len(old->d_name.name, old_upperdir,\n+\t\t\t\t   old->d_name.len);\n+\terr = PTR_ERR(olddentry);\n+\tif (IS_ERR(olddentry))\n+\t\tgoto out_unlock;\n+\n+\terr = -ESTALE;\n+\tif (olddentry != ovl_dentry_upper(old))\n+\t\tgoto out_dput_old;\n+\n+\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n+\t\t\t\t   new->d_name.len);\n+\terr = PTR_ERR(newdentry);\n+\tif (IS_ERR(newdentry))\n+\t\tgoto out_dput_old;\n+\n+\terr = -ESTALE;\n+\tif (ovl_dentry_upper(new)) {\n \t\tif (opaquedir) {\n-\t\t\tnewdentry = opaquedir;\n-\t\t\topaquedir = NULL;\n+\t\t\tif (newdentry != opaquedir)\n+\t\t\t\tgoto out_dput;\n \t\t} else {\n-\t\t\tdget(newdentry);\n+\t\t\tif (newdentry != ovl_dentry_upper(new))\n+\t\t\t\tgoto out_dput;\n \t\t}\n \t} else {\n \t\tnew_create = true;\n-\t\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n-\t\t\t\t\t   new->d_name.len);\n-\t\terr = PTR_ERR(newdentry);\n-\t\tif (IS_ERR(newdentry))\n-\t\t\tgoto out_unlock;\n+\t\tif (!d_is_negative(newdentry) &&\n+\t\t    (!new_opaque || !ovl_is_whiteout(newdentry)))\n+\t\t\tgoto out_dput;\n \t}\n \n-\terr = -ESTALE;\n-\tif (olddentry->d_parent != old_upperdir)\n-\t\tgoto out_dput;\n-\tif (newdentry->d_parent != new_upperdir)\n-\t\tgoto out_dput;\n \tif (olddentry == trap)\n \t\tgoto out_dput;\n \tif (newdentry == trap)\n@@ -925,6 +940,8 @@ static int ovl_rename2(struct inode *olddir, struct dentry *old,\n \n out_dput:\n \tdput(newdentry);\n+out_dput_old:\n+\tdput(olddentry);\n out_unlock:\n \tunlock_rename(new_upperdir, old_upperdir);\n out_revert_creds:\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9721","CWE_ID":"20","category":"security","commit_id":"77ef79e3b565f120172c6d1c30fabec6185553da","commit_message":"From 77ef79e3b565f120172c6d1c30fabec6185553da Mon Sep 17 00:00:00 2001\nFrom: Pieter Hintjens <ph@imatix.com>\nDate: Fri, 5 Dec 2014 09:07:37 +0100\nSubject: [PATCH] Problem: issue #1273, protocol downgrade attack\n\nSolution: backport fix from libzmq master. Also backported test\ncases.\n---\n NEWS                          |   4 +-\n src\/session_base.cpp          |   8 +++\n src\/session_base.hpp          |   3 +-\n src\/stream_engine.cpp         |  15 +++++\n tests\/test_security_curve.cpp |  66 ++++++++++++++++---\n tests\/test_security_null.cpp  | 121 +++++++++++++++++++++-------------\n tests\/test_security_plain.cpp |  37 ++++++++++-\n 7 files changed, 197 insertions(+), 57 deletions(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex f001542d..b18ea7af 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -1,6 +1,8 @@\n-0MQ version 4.0.6 stable, released on 2015\/xx\/xx\n+0MQ version 4.0.6 stable, released on 2015\/12\/xx\n ================================================\n \n+* Fixed #1273 - V3 protocol handler vulnerable to downgrade attacks.\n+\n \n 0MQ version 4.0.5 stable, released on 2014\/10\/14\n ================================================\ndiff --git a\/src\/session_base.cpp b\/src\/session_base.cpp\nindex 537dcb3e..0b584361 100644\n--- a\/src\/session_base.cpp\n+++ b\/src\/session_base.cpp\n@@ -323,6 +323,14 @@ int zmq::session_base_t::zap_connect ()\n     return 0;\n }\n \n+bool zmq::session_base_t::zap_enabled ()\n+{\n+    return (\n+         options.mechanism != ZMQ_NULL ||\n+        (options.mechanism == ZMQ_NULL && options.zap_domain.length() > 0)\n+    );\n+}\n+\n void zmq::session_base_t::process_attach (i_engine *engine_)\n {\n     zmq_assert (engine_ != NULL);\ndiff --git a\/src\/session_base.hpp b\/src\/session_base.hpp\nindex 2ef7dc50..63e16bd9 100644\n--- a\/src\/session_base.hpp\n+++ b\/src\/session_base.hpp\n@@ -68,7 +68,8 @@ namespace zmq\n         int push_msg (msg_t *msg_);\n \n         int zap_connect ();\n-\n+        bool zap_enabled ();\n+        \n         \/\/  Fetches a message. Returns 0 if successful; -1 otherwise.\n         \/\/  The caller is responsible for freeing the message when no\n         \/\/  longer used.\ndiff --git a\/src\/stream_engine.cpp b\/src\/stream_engine.cpp\nindex 4d252d89..3d84d8ff 100644\n--- a\/src\/stream_engine.cpp\n+++ b\/src\/stream_engine.cpp\n@@ -464,6 +464,11 @@ bool zmq::stream_engine_t::handshake ()\n     \/\/  Is the peer using ZMTP\/1.0 with no revision number?\n     \/\/  If so, we send and receive rest of identity message\n     if (greeting_recv [0] != 0xff || !(greeting_recv [9] & 0x01)) {\n+        if (session->zap_enabled ()) {\n+            \/\/  Reject ZMTP 1.0 connections if ZAP is enabled\n+            error ();\n+            return false;\n+        }\n         encoder = new (std::nothrow) v1_encoder_t (out_batch_size);\n         alloc_assert (encoder);\n \n@@ -505,6 +510,11 @@ bool zmq::stream_engine_t::handshake ()\n     }\n     else\n     if (greeting_recv [revision_pos] == ZMTP_1_0) {\n+        if (session->zap_enabled ()) {\n+            \/\/  Reject ZMTP 1.0 connections if ZAP is enabled\n+            error ();\n+            return false;\n+        }\n         encoder = new (std::nothrow) v1_encoder_t (\n             out_batch_size);\n         alloc_assert (encoder);\n@@ -515,6 +525,11 @@ bool zmq::stream_engine_t::handshake ()\n     }\n     else\n     if (greeting_recv [revision_pos] == ZMTP_2_0) {\n+        if (session->zap_enabled ()) {\n+            \/\/  Reject ZMTP 1.0 connections if ZAP is enabled\n+            error ();\n+            return false;\n+        }\n         encoder = new (std::nothrow) v2_encoder_t (out_batch_size);\n         alloc_assert (encoder);\n \ndiff --git a\/tests\/test_security_curve.cpp b\/tests\/test_security_curve.cpp\nindex a24466f4..e99a4b34 100644\n--- a\/tests\/test_security_curve.cpp\n+++ b\/tests\/test_security_curve.cpp\n@@ -18,12 +18,23 @@\n *\/\n \n #include \"testutil.hpp\"\n+#if defined (ZMQ_HAVE_WINDOWS)\n+#   include <winsock2.h>\n+#   include <ws2tcpip.h>\n+#   include <stdexcept>\n+#   define close closesocket\n+#else\n+#   include <sys\/socket.h>\n+#   include <netinet\/in.h>\n+#   include <arpa\/inet.h>\n+#   include <unistd.h>\n+#endif\n \n \/\/  We'll generate random test keys at startup\n-static char client_public [40];\n-static char client_secret [40];\n-static char server_public [40];\n-static char server_secret [40];\n+static char client_public [41];\n+static char client_secret [41];\n+static char server_public [41];\n+static char server_secret [41];\n \n \/\/  --------------------------------------------------------------------------\n \/\/  This methods receives and validates ZAP requestes (allowing or denying\n@@ -46,7 +57,7 @@ static void zap_handler (void *handler)\n         int size = zmq_recv (handler, client_key, 32, 0);\n         assert (size == 32);\n \n-        char client_key_text [40];\n+        char client_key_text [41];\n         zmq_z85_encode (client_key_text, client_key, 32);\n \n         assert (streq (version, \"1.0\"));\n@@ -181,8 +192,8 @@ int main (void)\n \n     \/\/  Check CURVE security with bogus client credentials\n     \/\/  This must be caught by the ZAP handler\n-    char bogus_public [40];\n-    char bogus_secret [40];\n+    char bogus_public [41];\n+    char bogus_secret [41];\n     zmq_curve_keypair (bogus_public, bogus_secret);\n \n     client = zmq_socket (ctx, ZMQ_DEALER);\n@@ -217,7 +228,46 @@ int main (void)\n     assert (rc == 0);\n     expect_bounce_fail (server, client);\n     close_zero_linger (client);\n-    \n+\n+    \/\/ Unauthenticated messages from a vanilla socket shouldn't be received\n+    struct sockaddr_in ip4addr;\n+    int s;\n+\n+    ip4addr.sin_family = AF_INET;\n+    ip4addr.sin_port = htons (9998);\n+    inet_pton (AF_INET, \"127.0.0.1\", &ip4addr.sin_addr);\n+\n+    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    rc = connect (s, (struct sockaddr*) &ip4addr, sizeof (ip4addr));\n+    assert (rc > -1);\n+    \/\/ send anonymous ZMTP\/1.0 greeting\n+    send (s, \"\\x01\\x00\", 2, 0);\n+    \/\/ send sneaky message that shouldn't be received\n+    send (s, \"\\x08\\x00sneaky\\0\", 9, 0);\n+    int timeout = 150;\n+    zmq_setsockopt (server, ZMQ_RCVTIMEO, &timeout, sizeof (timeout));\n+    char *buf = s_recv (server);\n+    if (buf != NULL) {\n+        printf (\"Received unauthenticated message: %s\\n\", buf);\n+        assert (buf == NULL);\n+    }\n+    close (s);\n+\n+    \/\/  Check return codes for invalid buffer sizes\n+    client = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (client);\n+    errno = 0;\n+    rc = zmq_setsockopt (client, ZMQ_CURVE_SERVERKEY, server_public, 123);\n+    assert (rc == -1 && errno == EINVAL);\n+    errno = 0;\n+    rc = zmq_setsockopt (client, ZMQ_CURVE_PUBLICKEY, client_public, 123);\n+    assert (rc == -1 && errno == EINVAL);\n+    errno = 0;\n+    rc = zmq_setsockopt (client, ZMQ_CURVE_SECRETKEY, client_secret, 123);\n+    assert (rc == -1 && errno == EINVAL);\n+    rc = zmq_close (client);\n+    assert (rc == 0);\n+\n     \/\/  Shutdown\n     rc = zmq_close (server);\n     assert (rc == 0);\ndiff --git a\/tests\/test_security_null.cpp b\/tests\/test_security_null.cpp\nindex 8a55632d..6b74e8ce 100644\n--- a\/tests\/test_security_null.cpp\n+++ b\/tests\/test_security_null.cpp\n@@ -1,5 +1,5 @@\n \/*\n-    Copyright (c) 2007-2013 Contributors as noted in the AUTHORS file\n+    Copyright (c) 2007-2014 Contributors as noted in the AUTHORS file\n \n     This file is part of 0MQ.\n \n@@ -18,6 +18,17 @@\n *\/\n \n #include \"testutil.hpp\"\n+#if defined (ZMQ_HAVE_WINDOWS)\n+#   include <winsock2.h>\n+#   include <ws2tcpip.h>\n+#   include <stdexcept>\n+#   define close closesocket\n+#else\n+#   include <sys\/socket.h>\n+#   include <netinet\/in.h>\n+#   include <arpa\/inet.h>\n+#   include <unistd.h>\n+#endif\n \n static void\n zap_handler (void *handler)\n@@ -27,6 +38,7 @@ zap_handler (void *handler)\n         char *version = s_recv (handler);\n         if (!version)\n             break;          \/\/  Terminating\n+\n         char *sequence = s_recv (handler);\n         char *domain = s_recv (handler);\n         char *address = s_recv (handler);\n@@ -57,7 +69,7 @@ zap_handler (void *handler)\n         free (identity);\n         free (mechanism);\n     }\n-    zmq_close (handler);\n+    close_zero_linger (handler);\n }\n \n int main (void)\n@@ -76,72 +88,89 @@ int main (void)\n     void *zap_thread = zmq_threadstart (&zap_handler, handler);\n \n     \/\/  We bounce between a binding server and a connecting client\n+    \n+    \/\/  We first test client\/server with no ZAP domain\n+    \/\/  Libzmq does not call our ZAP handler, the connect must succeed\n     void *server = zmq_socket (ctx, ZMQ_DEALER);\n     assert (server);\n     void *client = zmq_socket (ctx, ZMQ_DEALER);\n     assert (client);\n-    \n-    \/\/  We first test client\/server with no ZAP domain\n-    \/\/  Libzmq does not call our ZAP handler, the connect must succeed\n     rc = zmq_bind (server, \"tcp:\/\/127.0.0.1:9000\");\n     assert (rc == 0);\n-    rc = zmq_connect (client, \"tcp:\/\/localhost:9000\");\n+    rc = zmq_connect (client, \"tcp:\/\/127.0.0.1:9000\");\n     assert (rc == 0);\n     bounce (server, client);\n-    zmq_unbind (server, \"tcp:\/\/127.0.0.1:9000\");\n-    zmq_disconnect (client, \"tcp:\/\/localhost:9000\");\n-    \n+    close_zero_linger (client);\n+    close_zero_linger (server);\n+\n     \/\/  Now define a ZAP domain for the server; this enables \n     \/\/  authentication. We're using the wrong domain so this test\n     \/\/  must fail.\n-    \/\/  **************************************************************\n-    \/\/  PH: the following causes libzmq to get confused, so that the\n-    \/\/  next step fails. To reproduce, uncomment this block. Note that\n-    \/\/  even creating a new client\/server socket pair, the behaviour\n-    \/\/  does not change.\n-    \/\/  **************************************************************\n-    \/\/  Destroying the old sockets and creating new ones isn't needed,\n-    \/\/  but it shows that the problem isn't related to specific sockets.\n-    \/\/close_zero_linger (client);\n-    \/\/close_zero_linger (server);\n-    \/\/server = zmq_socket (ctx, ZMQ_DEALER);\n-    \/\/assert (server);\n-    \/\/client = zmq_socket (ctx, ZMQ_DEALER);\n-    \/\/assert (client);\n-    \/\/\/\/  The above code should not be required\n-    \/\/rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, \"WRONG\", 5);\n-    \/\/assert (rc == 0);\n-    \/\/rc = zmq_bind (server, \"tcp:\/\/127.0.0.1:9001\");\n-    \/\/assert (rc == 0);\n-    \/\/rc = zmq_connect (client, \"tcp:\/\/localhost:9001\");\n-    \/\/assert (rc == 0);\n-    \/\/expect_bounce_fail (server, client);\n-    \/\/zmq_unbind (server, \"tcp:\/\/127.0.0.1:9001\");\n-    \/\/zmq_disconnect (client, \"tcp:\/\/localhost:9001\");\n-    \n+    server = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (server);\n+    client = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (client);\n+    rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, \"WRONG\", 5);\n+    assert (rc == 0);\n+    rc = zmq_bind (server, \"tcp:\/\/127.0.0.1:9001\");\n+    assert (rc == 0);\n+    rc = zmq_connect (client, \"tcp:\/\/127.0.0.1:9001\");\n+    assert (rc == 0);\n+    expect_bounce_fail (server, client);\n+    close_zero_linger (client);\n+    close_zero_linger (server);\n+\n     \/\/  Now use the right domain, the test must pass\n+    server = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (server);\n+    client = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (client);\n     rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, \"TEST\", 4);\n     assert (rc == 0);\n     rc = zmq_bind (server, \"tcp:\/\/127.0.0.1:9002\");\n     assert (rc == 0);\n-    rc = zmq_connect (client, \"tcp:\/\/localhost:9002\");\n+    rc = zmq_connect (client, \"tcp:\/\/127.0.0.1:9002\");\n     assert (rc == 0);\n-    \/\/  **************************************************************\n-    \/\/  PH: it fails here; though the ZAP reply is 200 OK, and\n-    \/\/  null_mechanism.cpp correctly parses that, the connection\n-    \/\/  never succeeds and the test hangs.\n-    \/\/  **************************************************************\n     bounce (server, client);\n-    zmq_unbind (server, \"tcp:\/\/127.0.0.1:9002\");\n-    zmq_disconnect (client, \"tcp:\/\/localhost:9002\");\n-    \n-    \/\/  Shutdown\n     close_zero_linger (client);\n     close_zero_linger (server);\n-    rc = zmq_ctx_term (ctx);\n+\n+    \/\/ Unauthenticated messages from a vanilla socket shouldn't be received\n+    server = zmq_socket (ctx, ZMQ_DEALER);\n+    assert (server);\n+    rc = zmq_setsockopt (server, ZMQ_ZAP_DOMAIN, \"WRONG\", 5);\n     assert (rc == 0);\n+    rc = zmq_bind (server, \"tcp:\/\/127.0.0.1:9003\");\n+    assert (rc == 0);\n+\n+    struct sockaddr_in ip4addr;\n+    int s;\n+\n+    ip4addr.sin_family = AF_INET;\n+    ip4addr.sin_port = htons(9003);\n+    inet_pton(AF_INET, \"127.0.0.1\", &ip4addr.sin_addr);\n \n-    \/\/  Wait until ZAP handler terminates.\n+    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    rc = connect (s, (struct sockaddr*) &ip4addr, sizeof ip4addr);\n+    assert (rc > -1);\n+    \/\/ send anonymous ZMTP\/1.0 greeting\n+    send (s, \"\\x01\\x00\", 2, 0);\n+    \/\/ send sneaky message that shouldn't be received\n+    send (s, \"\\x08\\x00sneaky\\0\", 9, 0);\n+    int timeout = 150;\n+    zmq_setsockopt (server, ZMQ_RCVTIMEO, &timeout, sizeof (timeout));\n+    char *buf = s_recv (server);\n+    if (buf != NULL) {\n+        printf (\"Received unauthenticated message: %s\\n\", buf);\n+        assert (buf == NULL);\n+    }\n+    close (s);\n+    close_zero_linger (server);\n+\n+    \/\/  Shutdown\n+    rc = zmq_ctx_term (ctx);\n+    assert (rc == 0);\n+    \/\/  Wait until ZAP handler terminates\n     zmq_threadclose (zap_thread);\n \n     return 0;\ndiff --git a\/tests\/test_security_plain.cpp b\/tests\/test_security_plain.cpp\nindex 74973fdf..c257840c 100644\n--- a\/tests\/test_security_plain.cpp\n+++ b\/tests\/test_security_plain.cpp\n@@ -1,5 +1,5 @@\n \/*\n-    Copyright (c) 2007-2013 Contributors as noted in the AUTHORS file\n+    Copyright (c) 2007-2014 Contributors as noted in the AUTHORS file\n \n     This file is part of 0MQ.\n \n@@ -18,6 +18,17 @@\n *\/\n \n #include \"testutil.hpp\"\n+#if defined (ZMQ_HAVE_WINDOWS)\n+#   include <winsock2.h>\n+#   include <ws2tcpip.h>\n+#   include <stdexcept>\n+#   define close closesocket\n+#else\n+#   include <sys\/socket.h>\n+#   include <netinet\/in.h>\n+#   include <arpa\/inet.h>\n+#   include <unistd.h>\n+#endif\n \n static void\n zap_handler (void *ctx)\n@@ -137,6 +148,30 @@ int main (void)\n     expect_bounce_fail (server, client);\n     close_zero_linger (client);\n \n+    \/\/ Unauthenticated messages from a vanilla socket shouldn't be received\n+    struct sockaddr_in ip4addr;\n+    int s;\n+\n+    ip4addr.sin_family = AF_INET;\n+    ip4addr.sin_port = htons (9998);\n+    inet_pton (AF_INET, \"127.0.0.1\", &ip4addr.sin_addr);\n+\n+    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+    rc = connect (s, (struct sockaddr*) &ip4addr, sizeof (ip4addr));\n+    assert (rc > -1);\n+    \/\/ send anonymous ZMTP\/1.0 greeting\n+    send (s, \"\\x01\\x00\", 2, 0);\n+    \/\/ send sneaky message that shouldn't be received\n+    send (s, \"\\x08\\x00sneaky\\0\", 9, 0);\n+    int timeout = 150;\n+    zmq_setsockopt (server, ZMQ_RCVTIMEO, &timeout, sizeof (timeout));\n+    char *buf = s_recv (server);\n+    if (buf != NULL) {\n+        printf (\"Received unauthenticated message: %s\\n\", buf);\n+        assert (buf == NULL);\n+    }\n+    close (s);\n+\n     \/\/  Shutdown\n     rc = zmq_close (server);\n     assert (rc == 0);\n","owner":"zeromq","repo":"zeromq4-x","source":"cve"},{"CVE_ID":"CVE-2017-12176","CWE_ID":"20","category":"security","commit_id":"b747da5e25be944337a9cd1415506fc06b70aa81","commit_message":"From b747da5e25be944337a9cd1415506fc06b70aa81 Mon Sep 17 00:00:00 2001\nFrom: Nathan Kidd <nkidd@opentext.com>\nDate: Fri, 9 Jan 2015 10:15:46 -0500\nSubject: Unvalidated extra length in ProcEstablishConnection (CVE-2017-12176)\n\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Nathan Kidd <nkidd@opentext.com>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n dix\/dispatch.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/dix\/dispatch.c b\/dix\/dispatch.c\nindex 8b371b6..176c7a0 100644\n--- a\/dix\/dispatch.c\n+++ b\/dix\/dispatch.c\n@@ -3702,7 +3702,12 @@ ProcEstablishConnection(ClientPtr client)\n     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);\n     auth_proto = (char *) prefix + sz_xConnClientPrefix;\n     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);\n-    if ((prefix->majorVersion != X_PROTOCOL) ||\n+\n+    if ((client->req_len << 2) != sz_xReq + sz_xConnClientPrefix +\n+\tpad_to_int32(prefix->nbytesAuthProto) +\n+\tpad_to_int32(prefix->nbytesAuthString))\n+        reason = \"Bad length\";\n+    else if ((prefix->majorVersion != X_PROTOCOL) ||\n         (prefix->minorVersion != X_PROTOCOL_REVISION))\n         reason = \"Protocol version mismatch\";\n     else\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-5892","CWE_ID":"20","category":"security","commit_id":"943d595a018e69b550db08cccba1d0778a86705a","commit_message":"From 943d595a018e69b550db08cccba1d0778a86705a Mon Sep 17 00:00:00 2001\nFrom: Lou Berger <lberger@labn.net>\nDate: Mon, 7 Jan 2019 11:32:54 -0500\nSubject: [PATCH] bgpd: don't use BGP_ATTR_VNC(255) unless ENABLE_BGP_VNC_ATTR\n is defined\n\nSigned-off-by: Lou Berger <lberger@labn.net>\n---\n bgpd\/bgp_attr.c | 8 ++++----\n bgpd\/bgpd.h     | 2 +-\n 2 files changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/bgpd\/bgp_attr.c b\/bgpd\/bgp_attr.c\nindex 87ebb9c285..b990e99bda 100644\n--- a\/bgpd\/bgp_attr.c\n+++ b\/bgpd\/bgp_attr.c\n@@ -78,7 +78,7 @@ static const struct message attr_str[] = {\n \t{BGP_ATTR_AS_PATHLIMIT, \"AS_PATHLIMIT\"},\n \t{BGP_ATTR_PMSI_TUNNEL, \"PMSI_TUNNEL_ATTRIBUTE\"},\n \t{BGP_ATTR_ENCAP, \"ENCAP\"},\n-#if ENABLE_BGP_VNC\n+#if ENABLE_BGP_VNC_ATTR\n \t{BGP_ATTR_VNC, \"VNC\"},\n #endif\n \t{BGP_ATTR_LARGE_COMMUNITIES, \"LARGE_COMMUNITY\"},\n@@ -2593,7 +2593,7 @@ bgp_attr_parse_ret_t bgp_attr_parse(struct peer *peer, struct attr *attr,\n \t\tcase BGP_ATTR_EXT_COMMUNITIES:\n \t\t\tret = bgp_attr_ext_communities(&attr_args);\n \t\t\tbreak;\n-#if ENABLE_BGP_VNC\n+#if ENABLE_BGP_VNC_ATTR\n \t\tcase BGP_ATTR_VNC:\n #endif\n \t\tcase BGP_ATTR_ENCAP:\n@@ -2946,7 +2946,7 @@ static void bgp_packet_mpattr_tea(struct bgp *bgp, struct peer *peer,\n \t\tattrhdrlen = 1 + 1;   \/* subTLV T + L *\/\n \t\tbreak;\n \n-#if ENABLE_BGP_VNC\n+#if ENABLE_BGP_VNC_ATTR\n \tcase BGP_ATTR_VNC:\n \t\tattrname = \"VNC\";\n \t\tsubtlvs = attr->vnc_subtlvs;\n@@ -3433,7 +3433,7 @@ bgp_size_t bgp_packet_attribute(struct bgp *bgp, struct peer *peer,\n \t\t\/* Tunnel Encap attribute *\/\n \t\tbgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_ENCAP);\n \n-#if ENABLE_BGP_VNC\n+#if ENABLE_BGP_VNC_ATTR\n \t\t\/* VNC attribute *\/\n \t\tbgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_VNC);\n #endif\ndiff --git a\/bgpd\/bgpd.h b\/bgpd\/bgpd.h\nindex 62096d651a..f28ca9fa0b 100644\n--- a\/bgpd\/bgpd.h\n+++ b\/bgpd\/bgpd.h\n@@ -1280,7 +1280,7 @@ struct bgp_nlri {\n #define BGP_ATTR_ENCAP                          23\n #define BGP_ATTR_LARGE_COMMUNITIES              32\n #define BGP_ATTR_PREFIX_SID                     40\n-#if ENABLE_BGP_VNC\n+#if ENABLE_BGP_VNC_ATTR\n #define BGP_ATTR_VNC                           255\n #endif\n \n","owner":"FRRouting","repo":"frr","source":"cve"},{"CVE_ID":"CVE-2009-4272","CWE_ID":"20","category":"security","commit_id":"b6280b47a7a42970d098a3059f4ebe7e55e90d8d","commit_message":"From b6280b47a7a42970d098a3059f4ebe7e55e90d8d Mon Sep 17 00:00:00 2001\nFrom: Neil Horman <nhorman@tuxdriver.com>\nDate: Mon, 22 Jun 2009 10:18:53 +0000\nSubject: ipv4 routing: Ensure that route cache entries are usable and\n reclaimable with caching is off\n\nWhen route caching is disabled (rt_caching returns false), We still use route\ncache entries that are created and passed into rt_intern_hash once.  These\nroutes need to be made usable for the one call path that holds a reference to\nthem, and they need to be reclaimed when they're finished with their use.  To be\nmade usable, they need to be associated with a neighbor table entry (which they\ncurrently are not), otherwise iproute_finish2 just discards the packet, since we\ndon't know which L2 peer to send the packet to.  To do this binding, we need to\nfollow the path a bit higher up in rt_intern_hash, which calls\narp_bind_neighbour, but not assign the route entry to the hash table.\nCurrently, if caching is off, we simply assign the route to the rp pointer and\nare reutrn success.  This patch associates us with a neighbor entry first.\n\nSecondly, we need to make sure that any single use routes like this are known to\nthe garbage collector when caching is off.  If caching is off, and we try to\nhash in a route, it will leak when its refcount reaches zero.  To avoid this,\nthis patch calls rt_free on the route cache entry passed into rt_intern_hash.\nThis places us on the gc list for the route cache garbage collector, so that\nwhen its refcount reaches zero, it will be reclaimed (Thanks to Alexey for this\nsuggestion).\n\nI've tested this on a local system here, and with these patches in place, I'm\nable to maintain routed connectivity to remote systems, even if I set\n\/proc\/sys\/net\/ipv4\/rt_cache_rebuild_count to -1, which forces rt_caching to\nreturn false.\n\nSigned-off-by: Neil Horman <nhorman@redhat.com>\nReported-by: Jarek Poplawski <jarkao2@gmail.com>\nReported-by: Maxime Bizon <mbizon@freebox.fr>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/route.c | 26 +++++++++++++++++++++++---\n 1 file changed, 23 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/route.c b\/net\/ipv4\/route.c\nindex 65b3a8b11a6c..278f46f5011b 100644\n--- a\/net\/ipv4\/route.c\n+++ b\/net\/ipv4\/route.c\n@@ -1093,8 +1093,27 @@ restart:\n \t\t * If we drop it here, the callers have no way to resolve routes\n \t\t * when we're not caching.  Instead, just point *rp at rt, so\n \t\t * the caller gets a single use out of the route\n+\t\t * Note that we do rt_free on this new route entry, so that\n+\t\t * once its refcount hits zero, we are still able to reap it\n+\t\t * (Thanks Alexey)\n+\t\t * Note also the rt_free uses call_rcu.  We don't actually\n+\t\t * need rcu protection here, this is just our path to get\n+\t\t * on the route gc list.\n \t\t *\/\n-\t\tgoto report_and_exit;\n+\n+\t\tif (rt->rt_type == RTN_UNICAST || rt->fl.iif == 0) {\n+\t\t\tint err = arp_bind_neighbour(&rt->u.dst);\n+\t\t\tif (err) {\n+\t\t\t\tif (net_ratelimit())\n+\t\t\t\t\tprintk(KERN_WARNING\n+\t\t\t\t\t    \"Neighbour table failure & not caching routes.\\n\");\n+\t\t\t\trt_drop(rt);\n+\t\t\t\treturn err;\n+\t\t\t}\n+\t\t}\n+\n+\t\trt_free(rt);\n+\t\tgoto skip_hashing;\n \t}\n \n \trthp = &rt_hash_table[hash].chain;\n@@ -1211,7 +1230,8 @@ restart:\n #if RT_CACHE_DEBUG >= 2\n \tif (rt->u.dst.rt_next) {\n \t\tstruct rtable *trt;\n-\t\tprintk(KERN_DEBUG \"rt_cache @%02x: %pI4\", hash, &rt->rt_dst);\n+\t\tprintk(KERN_DEBUG \"rt_cache @%02x: %pI4\",\n+\t\t       hash, &rt->rt_dst);\n \t\tfor (trt = rt->u.dst.rt_next; trt; trt = trt->u.dst.rt_next)\n \t\t\tprintk(\" . %pI4\", &trt->rt_dst);\n \t\tprintk(\"\\n\");\n@@ -1226,7 +1246,7 @@ restart:\n \n \tspin_unlock_bh(rt_hash_lock_addr(hash));\n \n-report_and_exit:\n+skip_hashing:\n \tif (rp)\n \t\t*rp = rt;\n \telse\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-7269","CWE_ID":"20","category":"security","commit_id":"f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","commit_message":"From f3d3342602f8bcbf37d7c46641cb9bca7618eb1c Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Thu, 21 Nov 2013 03:14:22 +0100\nSubject: [PATCH] net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include\/linux\/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec\/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n crypto\/algif_hash.c            |  2 --\n crypto\/algif_skcipher.c        |  1 -\n drivers\/isdn\/mISDN\/socket.c    | 13 ++++---------\n drivers\/net\/ppp\/pppoe.c        |  2 --\n include\/linux\/net.h            |  8 ++++++++\n net\/appletalk\/ddp.c            | 16 +++++++---------\n net\/atm\/common.c               |  2 --\n net\/ax25\/af_ax25.c             |  4 ++--\n net\/bluetooth\/af_bluetooth.c   |  9 ++-------\n net\/bluetooth\/hci_sock.c       |  2 --\n net\/bluetooth\/rfcomm\/sock.c    |  1 -\n net\/bluetooth\/sco.c            |  1 -\n net\/caif\/caif_socket.c         |  4 ----\n net\/compat.c                   |  3 ++-\n net\/core\/iovec.c               |  3 ++-\n net\/ipx\/af_ipx.c               |  3 +--\n net\/irda\/af_irda.c             |  4 ----\n net\/iucv\/af_iucv.c             |  2 --\n net\/key\/af_key.c               |  1 -\n net\/l2tp\/l2tp_ppp.c            |  2 --\n net\/llc\/af_llc.c               |  2 --\n net\/netlink\/af_netlink.c       |  2 --\n net\/netrom\/af_netrom.c         |  3 +--\n net\/nfc\/llcp_sock.c            |  2 --\n net\/nfc\/rawsock.c              |  2 --\n net\/packet\/af_packet.c         | 32 +++++++++++++++-----------------\n net\/rds\/recv.c                 |  2 --\n net\/rose\/af_rose.c             |  8 +++++---\n net\/rxrpc\/ar-recvmsg.c         |  9 ++++++---\n net\/socket.c                   | 19 +++++++++++--------\n net\/tipc\/socket.c              |  6 ------\n net\/unix\/af_unix.c             |  5 -----\n net\/vmw_vsock\/af_vsock.c       |  2 --\n net\/vmw_vsock\/vmci_transport.c |  2 --\n net\/x25\/af_x25.c               |  3 +--\n 35 files changed, 67 insertions(+), 115 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/algif_hash.c b\/crypto\/algif_hash.c\nindex 0262210cad386..ef5356cd280a5 100644\n--- a\/crypto\/algif_hash.c\n+++ b\/crypto\/algif_hash.c\n@@ -161,8 +161,6 @@ static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\ndiff --git a\/crypto\/algif_skcipher.c b\/crypto\/algif_skcipher.c\nindex a1c4f0a555832..6a6dfc062d2a4 100644\n--- a\/crypto\/algif_skcipher.c\n+++ b\/crypto\/algif_skcipher.c\n@@ -432,7 +432,6 @@ static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n \tlong copied = 0;\n \n \tlock_sock(sk);\n-\tmsg->msg_namelen = 0;\n \tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n \t     iovlen--, iov++) {\n \t\tunsigned long seglen = iov->iov_len;\ndiff --git a\/drivers\/isdn\/mISDN\/socket.c b\/drivers\/isdn\/mISDN\/socket.c\nindex e47dcb9d1e91d..5cefb479c7072 100644\n--- a\/drivers\/isdn\/mISDN\/socket.c\n+++ b\/drivers\/isdn\/mISDN\/socket.c\n@@ -117,7 +117,6 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sk_buff\t\t*skb;\n \tstruct sock\t\t*sk = sock->sk;\n-\tstruct sockaddr_mISDN\t*maddr;\n \n \tint\t\tcopied, err;\n \n@@ -135,9 +134,9 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n-\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_mISDN *maddr = msg->msg_name;\n+\n \t\tmaddr->family = AF_ISDN;\n \t\tmaddr->dev = _pms(sk)->dev->id;\n \t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n@@ -150,11 +149,7 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n \t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n \t\t}\n-\t} else {\n-\t\tif (msg->msg_namelen)\n-\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n-\t\t\t       __func__, msg->msg_namelen);\n-\t\tmsg->msg_namelen = 0;\n+\t\tmsg->msg_namelen = sizeof(*maddr);\n \t}\n \n \tcopied = skb->len + MISDN_HEADER_LEN;\ndiff --git a\/drivers\/net\/ppp\/pppoe.c b\/drivers\/net\/ppp\/pppoe.c\nindex 5f66e30d98239..82ee6ed954cb8 100644\n--- a\/drivers\/net\/ppp\/pppoe.c\n+++ b\/drivers\/net\/ppp\/pppoe.c\n@@ -979,8 +979,6 @@ static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (error < 0)\n \t\tgoto end;\n \n-\tm->msg_namelen = 0;\n-\n \tif (skb) {\n \t\ttotal_len = min_t(size_t, total_len, skb->len);\n \t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\ndiff --git a\/include\/linux\/net.h b\/include\/linux\/net.h\nindex b292a04355717..4bcee94cef931 100644\n--- a\/include\/linux\/net.h\n+++ b\/include\/linux\/net.h\n@@ -164,6 +164,14 @@ struct proto_ops {\n #endif\n \tint\t\t(*sendmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len);\n+\t\/* Notes for implementing recvmsg:\n+\t * ===============================\n+\t * msg->msg_namelen should get updated by the recvmsg handlers\n+\t * iff msg_name != NULL. It is by default 0 to prevent\n+\t * returning uninitialized memory to user space.  The recvfrom\n+\t * handlers can assume that msg.msg_name is either NULL or has\n+\t * a minimum size of sizeof(struct sockaddr_storage).\n+\t *\/\n \tint\t\t(*recvmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len,\n \t\t\t\t      int flags);\ndiff --git a\/net\/appletalk\/ddp.c b\/net\/appletalk\/ddp.c\nindex 7fee50d637f95..7d424ac6e760b 100644\n--- a\/net\/appletalk\/ddp.c\n+++ b\/net\/appletalk\/ddp.c\n@@ -1735,7 +1735,6 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n-\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n@@ -1764,14 +1763,13 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n \n-\tif (!err) {\n-\t\tif (sat) {\n-\t\t\tsat->sat_family      = AF_APPLETALK;\n-\t\t\tsat->sat_port        = ddp->deh_sport;\n-\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n-\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n-\t\t}\n-\t\tmsg->msg_namelen = sizeof(*sat);\n+\tif (!err && msg->msg_name) {\n+\t\tstruct sockaddr_at *sat = msg->msg_name;\n+\t\tsat->sat_family      = AF_APPLETALK;\n+\t\tsat->sat_port        = ddp->deh_sport;\n+\t\tsat->sat_addr.s_node = ddp->deh_snode;\n+\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n+\t\tmsg->msg_namelen     = sizeof(*sat);\n \t}\n \n \tskb_free_datagram(sk, skb);\t\/* Free the datagram. *\/\ndiff --git a\/net\/atm\/common.c b\/net\/atm\/common.c\nindex 737bef59ce899..7b491006eaf40 100644\n--- a\/net\/atm\/common.c\n+++ b\/net\/atm\/common.c\n@@ -531,8 +531,6 @@ int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n \ndiff --git a\/net\/ax25\/af_ax25.c b\/net\/ax25\/af_ax25.c\nindex a00123ebb0ae0..7bb1605bdfd99 100644\n--- a\/net\/ax25\/af_ax25.c\n+++ b\/net\/ax25\/af_ax25.c\n@@ -1636,11 +1636,11 @@ static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (msg->msg_namelen != 0) {\n-\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n+\tif (msg->msg_name) {\n \t\tax25_digi digi;\n \t\tax25_address src;\n \t\tconst unsigned char *mac = skb_mac_header(skb);\n+\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n \n \t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n \t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\ndiff --git a\/net\/bluetooth\/af_bluetooth.c b\/net\/bluetooth\/af_bluetooth.c\nindex f6a1671ea2ff7..56ca494621c66 100644\n--- a\/net\/bluetooth\/af_bluetooth.c\n+++ b\/net\/bluetooth\/af_bluetooth.c\n@@ -224,10 +224,9 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n-\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n-\t\t\tmsg->msg_namelen = 0;\n+\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n-\t\t}\n+\n \t\treturn err;\n \t}\n \n@@ -245,8 +244,6 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tif (bt_sk(sk)->skb_msg_name)\n \t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n \t\t\t\t\t\t&msg->msg_namelen);\n-\t\telse\n-\t\t\tmsg->msg_namelen = 0;\n \t}\n \n \tskb_free_datagram(sk, skb);\n@@ -295,8 +292,6 @@ int bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \tBT_DBG(\"sk %p size %zu\", sk, size);\n \n \tlock_sock(sk);\ndiff --git a\/net\/bluetooth\/hci_sock.c b\/net\/bluetooth\/hci_sock.c\nindex 71f0be1730801..6a6c8bb4fd72d 100644\n--- a\/net\/bluetooth\/hci_sock.c\n+++ b\/net\/bluetooth\/hci_sock.c\n@@ -856,8 +856,6 @@ static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/bluetooth\/rfcomm\/sock.c b\/net\/bluetooth\/rfcomm\/sock.c\nindex c4d3d423f89b8..c80766f892c36 100644\n--- a\/net\/bluetooth\/rfcomm\/sock.c\n+++ b\/net\/bluetooth\/rfcomm\/sock.c\n@@ -615,7 +615,6 @@ static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n-\t\tmsg->msg_namelen = 0;\n \t\treturn 0;\n \t}\n \ndiff --git a\/net\/bluetooth\/sco.c b\/net\/bluetooth\/sco.c\nindex 12a0e51e21e13..24fa3964b3c84 100644\n--- a\/net\/bluetooth\/sco.c\n+++ b\/net\/bluetooth\/sco.c\n@@ -711,7 +711,6 @@ static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n \t\tsk->sk_state = BT_CONFIG;\n-\t\tmsg->msg_namelen = 0;\n \n \t\trelease_sock(sk);\n \t\treturn 0;\ndiff --git a\/net\/caif\/caif_socket.c b\/net\/caif\/caif_socket.c\nindex 05a41c7ec304e..d6be3edb7a434 100644\n--- a\/net\/caif\/caif_socket.c\n+++ b\/net\/caif\/caif_socket.c\n@@ -286,8 +286,6 @@ static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (m->msg_flags&MSG_OOB)\n \t\tgoto read_error;\n \n-\tm->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n \tif (!skb)\n \t\tgoto read_error;\n@@ -361,8 +359,6 @@ static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/*\n \t * Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\ndiff --git a\/net\/compat.c b\/net\/compat.c\nindex 89032580bd1d8..618c6a8a911b6 100644\n--- a\/net\/compat.c\n+++ b\/net\/compat.c\n@@ -93,7 +93,8 @@ int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tkern_msg->msg_name = kern_address;\n+\t\tif (kern_msg->msg_name)\n+\t\t\tkern_msg->msg_name = kern_address;\n \t} else\n \t\tkern_msg->msg_name = NULL;\n \ndiff --git a\/net\/core\/iovec.c b\/net\/core\/iovec.c\nindex 4cdb7c48dad6c..b61869429f4ce 100644\n--- a\/net\/core\/iovec.c\n+++ b\/net\/core\/iovec.c\n@@ -48,7 +48,8 @@ int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *a\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tm->msg_name = address;\n+\t\tif (m->msg_name)\n+\t\t\tm->msg_name = address;\n \t} else {\n \t\tm->msg_name = NULL;\n \t}\ndiff --git a\/net\/ipx\/af_ipx.c b\/net\/ipx\/af_ipx.c\nindex 7a1e0fc1bd4dd..e096025b477f3 100644\n--- a\/net\/ipx\/af_ipx.c\n+++ b\/net\/ipx\/af_ipx.c\n@@ -1823,8 +1823,6 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n-\tmsg->msg_namelen = sizeof(*sipx);\n-\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n@@ -1832,6 +1830,7 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n+\t\tmsg->msg_namelen\t= sizeof(*sipx);\n \t}\n \trc = copied;\n \ndiff --git a\/net\/irda\/af_irda.c b\/net\/irda\/af_irda.c\nindex 0f676908d15b6..de7db23049f14 100644\n--- a\/net\/irda\/af_irda.c\n+++ b\/net\/irda\/af_irda.c\n@@ -1385,8 +1385,6 @@ static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n \n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \n-\tmsg->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n@@ -1451,8 +1449,6 @@ static int irda_recvmsg_stream(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, noblock);\n \n-\tmsg->msg_namelen = 0;\n-\n \tdo {\n \t\tint chunk;\n \t\tstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\ndiff --git a\/net\/iucv\/af_iucv.c b\/net\/iucv\/af_iucv.c\nindex 168aff5e60de5..c4b7218058b64 100644\n--- a\/net\/iucv\/af_iucv.c\n+++ b\/net\/iucv\/af_iucv.c\n@@ -1324,8 +1324,6 @@ static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint err = 0;\n \tu32 offset;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif ((sk->sk_state == IUCV_DISCONN) &&\n \t    skb_queue_empty(&iucv->backlog_skb_q) &&\n \t    skb_queue_empty(&sk->sk_receive_queue) &&\ndiff --git a\/net\/key\/af_key.c b\/net\/key\/af_key.c\nindex 911ef03bf8fbf..545f047868ad8 100644\n--- a\/net\/key\/af_key.c\n+++ b\/net\/key\/af_key.c\n@@ -3616,7 +3616,6 @@ static int pfkey_recvmsg(struct kiocb *kiocb,\n \tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n \tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n \tif (skb == NULL)\n \t\tgoto out;\ndiff --git a\/net\/l2tp\/l2tp_ppp.c b\/net\/l2tp\/l2tp_ppp.c\nindex ffda81ef1a709..be5fadf347394 100644\n--- a\/net\/l2tp\/l2tp_ppp.c\n+++ b\/net\/l2tp\/l2tp_ppp.c\n@@ -197,8 +197,6 @@ static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sk->sk_state & PPPOX_BOUND)\n \t\tgoto end;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = 0;\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\ndiff --git a\/net\/llc\/af_llc.c b\/net\/llc\/af_llc.c\nindex 6cba486353e8a..7b01b9f5846c8 100644\n--- a\/net\/llc\/af_llc.c\n+++ b\/net\/llc\/af_llc.c\n@@ -720,8 +720,6 @@ static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint target;\t\/* Read at least this many bytes *\/\n \tlong timeo;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tcopied = -ENOTCONN;\n \tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\ndiff --git a\/net\/netlink\/af_netlink.c b\/net\/netlink\/af_netlink.c\nindex f0176e1a5a81a..bca50b95c1823 100644\n--- a\/net\/netlink\/af_netlink.c\n+++ b\/net\/netlink\/af_netlink.c\n@@ -2335,8 +2335,6 @@ static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,\n \t}\n #endif\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = data_skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/netrom\/af_netrom.c b\/net\/netrom\/af_netrom.c\nindex 698814bfa7adf..53c19a35fc6dc 100644\n--- a\/net\/netrom\/af_netrom.c\n+++ b\/net\/netrom\/af_netrom.c\n@@ -1179,10 +1179,9 @@ static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n+\t\tmsg->msg_namelen = sizeof(*sax);\n \t}\n \n-\tmsg->msg_namelen = sizeof(*sax);\n-\n \tskb_free_datagram(sk, skb);\n \n \trelease_sock(sk);\ndiff --git a\/net\/nfc\/llcp_sock.c b\/net\/nfc\/llcp_sock.c\nindex d308402b67d80..824c6056bf823 100644\n--- a\/net\/nfc\/llcp_sock.c\n+++ b\/net\/nfc\/llcp_sock.c\n@@ -807,8 +807,6 @@ static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tpr_debug(\"%p %zu\\n\", sk, len);\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state == LLCP_CLOSED &&\ndiff --git a\/net\/nfc\/rawsock.c b\/net\/nfc\/rawsock.c\nindex cd958b381f961..66bcd2eb57737 100644\n--- a\/net\/nfc\/rawsock.c\n+++ b\/net\/nfc\/rawsock.c\n@@ -244,8 +244,6 @@ static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn rc;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/packet\/af_packet.c b\/net\/packet\/af_packet.c\nindex 2e8286b47c28e..61bd50adead1c 100644\n--- a\/net\/packet\/af_packet.c\n+++ b\/net\/packet\/af_packet.c\n@@ -2660,7 +2660,6 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tstruct sock *sk = sock->sk;\n \tstruct sk_buff *skb;\n \tint copied, err;\n-\tstruct sockaddr_ll *sll;\n \tint vnet_hdr_len = 0;\n \n \terr = -EINVAL;\n@@ -2744,22 +2743,10 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tgoto out_free;\n \t}\n \n-\t\/*\n-\t *\tIf the address length field is there to be filled in, we fill\n-\t *\tit in now.\n-\t *\/\n-\n-\tsll = &PACKET_SKB_CB(skb)->sa.ll;\n-\tif (sock->type == SOCK_PACKET)\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n-\telse\n-\t\tmsg->msg_namelen = sll->sll_halen + offsetof(struct sockaddr_ll, sll_addr);\n-\n-\t\/*\n-\t *\tYou lose any data beyond the buffer you gave. If it worries a\n-\t *\tuser program they can ask the device for its MTU anyway.\n+\t\/* You lose any data beyond the buffer you gave. If it worries\n+\t * a user program they can ask the device for its MTU\n+\t * anyway.\n \t *\/\n-\n \tcopied = skb->len;\n \tif (copied > len) {\n \t\tcopied = len;\n@@ -2772,9 +2759,20 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n \n-\tif (msg->msg_name)\n+\tif (msg->msg_name) {\n+\t\t\/* If the address length field is there to be filled\n+\t\t * in, we fill it in now.\n+\t\t *\/\n+\t\tif (sock->type == SOCK_PACKET) {\n+\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n+\t\t} else {\n+\t\t\tstruct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;\n+\t\t\tmsg->msg_namelen = sll->sll_halen +\n+\t\t\t\toffsetof(struct sockaddr_ll, sll_addr);\n+\t\t}\n \t\tmemcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa,\n \t\t       msg->msg_namelen);\n+\t}\n \n \tif (pkt_sk(sk)->auxdata) {\n \t\tstruct tpacket_auxdata aux;\ndiff --git a\/net\/rds\/recv.c b\/net\/rds\/recv.c\nindex 9f0f17cf6bf9b..de339b24ca140 100644\n--- a\/net\/rds\/recv.c\n+++ b\/net\/rds\/recv.c\n@@ -410,8 +410,6 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n \ndiff --git a\/net\/rose\/af_rose.c b\/net\/rose\/af_rose.c\nindex e98fcfbe60079..33af77246bfeb 100644\n--- a\/net\/rose\/af_rose.c\n+++ b\/net\/rose\/af_rose.c\n@@ -1216,7 +1216,6 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sock *sk = sock->sk;\n \tstruct rose_sock *rose = rose_sk(sk);\n-\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n \tsize_t copied;\n \tunsigned char *asmptr;\n \tstruct sk_buff *skb;\n@@ -1252,8 +1251,11 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (srose != NULL) {\n-\t\tmemset(srose, 0, msg->msg_namelen);\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_rose *srose;\n+\n+\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n+\t\tsrose = msg->msg_name;\n \t\tsrose->srose_family = AF_ROSE;\n \t\tsrose->srose_addr   = rose->dest_addr;\n \t\tsrose->srose_call   = rose->dest_call;\ndiff --git a\/net\/rxrpc\/ar-recvmsg.c b\/net\/rxrpc\/ar-recvmsg.c\nindex 4b48687c3890f..898492a8d61be 100644\n--- a\/net\/rxrpc\/ar-recvmsg.c\n+++ b\/net\/rxrpc\/ar-recvmsg.c\n@@ -143,10 +143,13 @@ int rxrpc_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \t\t\/* copy the peer address and timestamp *\/\n \t\tif (!continue_call) {\n-\t\t\tif (msg->msg_name && msg->msg_namelen > 0)\n+\t\t\tif (msg->msg_name) {\n+\t\t\t\tsize_t len =\n+\t\t\t\t\tsizeof(call->conn->trans->peer->srx);\n \t\t\t\tmemcpy(msg->msg_name,\n-\t\t\t\t       &call->conn->trans->peer->srx,\n-\t\t\t\t       sizeof(call->conn->trans->peer->srx));\n+\t\t\t\t       &call->conn->trans->peer->srx, len);\n+\t\t\t\tmsg->msg_namelen = len;\n+\t\t\t}\n \t\t\tsock_recv_ts_and_drops(msg, &rx->sk, skb);\n \t\t}\n \ndiff --git a\/net\/socket.c b\/net\/socket.c\nindex c226aceee65b8..fc285564e49ec 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -1840,8 +1840,10 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n \tmsg.msg_iov = &iov;\n \tiov.iov_len = size;\n \tiov.iov_base = ubuf;\n-\tmsg.msg_name = (struct sockaddr *)&address;\n-\tmsg.msg_namelen = sizeof(address);\n+\t\/* Save some cycles and don't copy the address if not needed *\/\n+\tmsg.msg_name = addr ? (struct sockaddr *)&address : NULL;\n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg.msg_namelen = 0;\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = sock_recvmsg(sock, &msg, size, flags);\n@@ -2221,16 +2223,14 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \t\t\tgoto out;\n \t}\n \n-\t\/*\n-\t *      Save the user-mode address (verify_iovec will change the\n-\t *      kernel msghdr to use the kernel address space)\n+\t\/* Save the user-mode address (verify_iovec will change the\n+\t * kernel msghdr to use the kernel address space)\n \t *\/\n-\n \tuaddr = (__force void __user *)msg_sys->msg_name;\n \tuaddr_len = COMPAT_NAMELEN(msg);\n-\tif (MSG_CMSG_COMPAT & flags) {\n+\tif (MSG_CMSG_COMPAT & flags)\n \t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n-\t} else\n+\telse\n \t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n \tif (err < 0)\n \t\tgoto out_freeiov;\n@@ -2239,6 +2239,9 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n \tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n \n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg_sys->msg_namelen = 0;\n+\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\ndiff --git a\/net\/tipc\/socket.c b\/net\/tipc\/socket.c\nindex 3906527259d19..3b61851bb9276 100644\n--- a\/net\/tipc\/socket.c\n+++ b\/net\/tipc\/socket.c\n@@ -980,9 +980,6 @@ static int recv_msg(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n restart:\n \n@@ -1091,9 +1088,6 @@ static int recv_stream(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n \ndiff --git a\/net\/unix\/af_unix.c b\/net\/unix\/af_unix.c\nindex c1f403bed683e..01625ccc3ae64 100644\n--- a\/net\/unix\/af_unix.c\n+++ b\/net\/unix\/af_unix.c\n@@ -1754,7 +1754,6 @@ static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n {\n \tstruct unix_sock *u = unix_sk(sk);\n \n-\tmsg->msg_namelen = 0;\n \tif (u->addr) {\n \t\tmsg->msg_namelen = u->addr->len;\n \t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n@@ -1778,8 +1777,6 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = mutex_lock_interruptible(&u->readlock);\n \tif (err) {\n \t\terr = sock_intr_errno(sock_rcvtimeo(sk, noblock));\n@@ -1924,8 +1921,6 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\n \t *\/\ndiff --git a\/net\/vmw_vsock\/af_vsock.c b\/net\/vmw_vsock\/af_vsock.c\nindex 545c08b8a1d48..5adfd94c5b85d 100644\n--- a\/net\/vmw_vsock\/af_vsock.c\n+++ b\/net\/vmw_vsock\/af_vsock.c\n@@ -1662,8 +1662,6 @@ vsock_stream_recvmsg(struct kiocb *kiocb,\n \tvsk = vsock_sk(sk);\n \terr = 0;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state != SS_CONNECTED) {\ndiff --git a\/net\/vmw_vsock\/vmci_transport.c b\/net\/vmw_vsock\/vmci_transport.c\nindex 9d6986634e0bf..687360da62d9f 100644\n--- a\/net\/vmw_vsock\/vmci_transport.c\n+++ b\/net\/vmw_vsock\/vmci_transport.c\n@@ -1746,8 +1746,6 @@ static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Retrieve the head sk_buff from the socket's receive queue. *\/\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\ndiff --git a\/net\/x25\/af_x25.c b\/net\/x25\/af_x25.c\nindex 45a3ab5612c13..7622789d37501 100644\n--- a\/net\/x25\/af_x25.c\n+++ b\/net\/x25\/af_x25.c\n@@ -1340,10 +1340,9 @@ static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n+\t\tmsg->msg_namelen = sizeof(*sx25);\n \t}\n \n-\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n-\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-13145","CWE_ID":"20","category":"security","commit_id":"ac23b02ecb741e5de60f5235ea443790c88a0b80","commit_message":"From ac23b02ecb741e5de60f5235ea443790c88a0b80 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 21 May 2017 11:07:10 -0400\nSubject: [PATCH] ...\n\n---\n coders\/jp2.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/jp2.c b\/coders\/jp2.c\nindex fe2ea13db5..2d519e692e 100644\n--- a\/coders\/jp2.c\n+++ b\/coders\/jp2.c\n@@ -392,7 +392,8 @@ static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n         (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||\n         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||\n         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||\n-        (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd))\n+        (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd) ||\n+        (jp2_image->comps[i].data == NULL))\n       {\n         opj_destroy_codec(jp2_codec);\n         opj_image_destroy(jp2_image);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2015-0228","CWE_ID":"20","category":"security","commit_id":"643f0fcf3b8ab09a68f0ecd2aa37aafeda3e63ef","commit_message":"From 643f0fcf3b8ab09a68f0ecd2aa37aafeda3e63ef Mon Sep 17 00:00:00 2001\nFrom: Eric Covener <covener@apache.org>\nDate: Wed, 4 Feb 2015 14:44:23 +0000\nSubject: [PATCH]   *) SECURITY: CVE-2015-0228 (cve.mitre.org)      mod_lua: A\n maliciously crafted websockets PING after a script      calls r:wsupgrade()\n can cause a child process crash.      [Edward Lu <Chaosed0 gmail.com>]\n\nDiscovered by Guido Vranken <guidovranken gmail.com>\n\nSubmitted by: Edward Lu\nCommitted by: covener\n\n\n\ngit-svn-id: https:\/\/svn.apache.org\/repos\/asf\/httpd\/httpd\/trunk@1657261 13f79535-47bb-0310-9956-ffa450edef68\n---\n CHANGES                   | 5 +++++\n modules\/lua\/lua_request.c | 6 +++++-\n 2 files changed, 10 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/CHANGES b\/CHANGES\nindex aa79dac9c68..02141ef5bd6 100644\n--- a\/CHANGES\n+++ b\/CHANGES\n@@ -1,6 +1,11 @@\n                                                          -*- coding: utf-8 -*-\n Changes with Apache 2.5.0\n \n+  *) SECURITY: CVE-2015-0228 (cve.mitre.org)\n+     mod_lua: A maliciously crafted websockets PING after a script\n+     calls r:wsupgrade() can cause a child process crash. \n+     [Edward Lu <Chaosed0 gmail.com>]\n+\n   *) mod_lua: After a r:wsupgrade(), mod_lua was not properly\n      responding to a websockets PING but instead invoking the specified \n      script. PR57524. [Edward Lu <Chaosed0 gmail.com>]\ndiff --git a\/modules\/lua\/lua_request.c b\/modules\/lua\/lua_request.c\nindex dded599a4c7..1200c55b35c 100644\n--- a\/modules\/lua\/lua_request.c\n+++ b\/modules\/lua\/lua_request.c\n@@ -2227,6 +2227,7 @@ static int lua_websocket_read(lua_State *L)\n {\n     apr_socket_t *sock;\n     apr_status_t rv;\n+    int do_read = 1;\n     int n = 0;\n     apr_size_t len = 1;\n     apr_size_t plen = 0;\n@@ -2244,6 +2245,8 @@ static int lua_websocket_read(lua_State *L)\n     mask_bytes = apr_pcalloc(r->pool, 4);\n     sock = ap_get_conn_socket(r->connection);\n \n+    while (do_read) { \n+    do_read = 0;\n     \/* Get opcode and FIN bit *\/\n     if (plaintext) {\n         rv = apr_socket_recv(sock, &byte, &len);\n@@ -2377,10 +2380,11 @@ static int lua_websocket_read(lua_State *L)\n                 frame[0] = 0x8A;\n                 frame[1] = 0;\n                 apr_socket_send(sock, frame, &plen); \/* Pong! *\/\n-                lua_websocket_read(L); \/* read the next frame instead *\/\n+                do_read = 1;\n             }\n         }\n     }\n+    }\n     return 0;\n }\n \n","owner":"apache","repo":"httpd","source":"cve"},{"CVE_ID":"CVE-2015-0272","CWE_ID":"20","category":"security","commit_id":"4d6bf4eef31b19779ad1d7df1687785e349f4807","commit_message":"From 4d6bf4eef31b19779ad1d7df1687785e349f4807 Mon Sep 17 00:00:00 2001\nFrom: Lubomir Rintel <lkundrak@v3.sk>\nDate: Wed, 25 Feb 2015 14:49:34 +0100\nSubject: nm-device: set ipv6 mtu at config commit time\n\nJust a refactoring, doesn't make any actual difference. It is consistent with\nIPv4 and will make it easier to implement a policy to recover from incorrect\nMTUs settings.\n---\n src\/devices\/nm-device.c | 22 ++++++++++++++++------\n 1 file changed, 16 insertions(+), 6 deletions(-)\n\nFrom 1bc202af028ad8987a92500bba6bb36156d8be5f Mon Sep 17 00:00:00 2001\nFrom: Lubomir Rintel <lkundrak@v3.sk>\nDate: Wed, 25 Feb 2015 15:21:48 +0100\nSubject: nm-device: move device MTU setting from IP4Config to NMDevice\n\nJust a refactoring, no functional change. This will make it easier to\ncoordinate the device MTU with IPv6 MTU.\n---\n src\/devices\/nm-device.c | 10 ++++++++++\n src\/nm-ip4-config.c     |  5 -----\n 2 files changed, 10 insertions(+), 5 deletions(-)\n\nFrom 7ba2a058f201ac237e2c5ddf6f513f8c306f314d Mon Sep 17 00:00:00 2001\nFrom: Lubomir Rintel <lkundrak@v3.sk>\nDate: Wed, 25 Feb 2015 15:35:26 +0100\nSubject: nm-device: avoid improper IPv6 MTU configuration\n\nEnsure it's always (before address configuration starts and on updates) >= 1280\nand not higher than the device MTU.\n---\n src\/devices\/nm-device.c | 53 +++++++++++++++++++++++++++++++++++++++++++++----\n 1 file changed, 49 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/src\/devices\/nm-device.c b\/src\/devices\/nm-device.c\nindex 02c4357..e3e6478 100644\n--- a\/src\/devices\/nm-device.c\n+++ b\/src\/devices\/nm-device.c\n@@ -283,6 +283,7 @@ typedef struct {\n \tNMIP6Config *  wwan_ip6_config;\n \tNMIP6Config *  ext_ip6_config; \/* Stuff added outside NM *\/\n \tgboolean       nm_ipv6ll; \/* TRUE if NM handles the device's IPv6LL address *\/\n+\tguint32        ip6_mtu;\n \n \tNMRDisc *      rdisc;\n \tgulong         rdisc_changed_id;\n@@ -4079,6 +4080,18 @@ print_support_extended_ifa_flags (NMSettingIP6ConfigPrivacy use_tempaddr)\n }\n \n static void\n+nm_device_ipv6_set_mtu (NMDevice *self, guint32 mtu)\n+{\n+\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n+\tchar val[16];\n+\n+\tif (mtu) {\n+\t\tg_snprintf (val, sizeof (val), \"%d\", mtu);\n+\t\tnm_device_ipv6_sysctl_set (self, \"mtu\", val);\n+\t}\n+}\n+\n+static void\n rdisc_config_changed (NMRDisc *rdisc, NMRDiscConfigMap changed, NMDevice *self)\n {\n \tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n@@ -4224,12 +4237,8 @@ rdisc_config_changed (NMRDisc *rdisc, NMRDiscConfigMap changed, NMDevice *self)\n \t\tnm_device_ipv6_sysctl_set (self, \"hop_limit\", val);\n \t}\n \n-\tif (changed & NM_RDISC_CONFIG_MTU) {\n-\t\tchar val[16];\n-\n-\t\tg_snprintf (val, sizeof (val), \"%d\", rdisc->mtu);\n-\t\tnm_device_ipv6_sysctl_set (self, \"mtu\", val);\n-\t}\n+\tif (changed & NM_RDISC_CONFIG_MTU)\n+\t\tpriv->ip6_mtu = rdisc->mtu;\n \n \tnm_device_activate_schedule_ip6_config_result (self);\n }\n@@ -6053,6 +6062,7 @@ nm_device_set_ip6_config (NMDevice *self,\n \n \t\/* Always commit to nm-platform to update lifetimes *\/\n \tif (commit && new_config) {\n+\t\tnm_device_ipv6_set_mtu (self, priv->ip6_mtu);\n \t\tsuccess = nm_ip6_config_commit (new_config, ip_ifindex);\n \t\tif (!success)\n \t\t\treason_local = NM_DEVICE_STATE_REASON_CONFIG_FAILED;\n-- \ncgit v1.1\n\n\ndiff --git a\/src\/devices\/nm-device.c b\/src\/devices\/nm-device.c\nindex e3e6478..808ba6f 100644\n--- a\/src\/devices\/nm-device.c\n+++ b\/src\/devices\/nm-device.c\n@@ -4080,6 +4080,14 @@ print_support_extended_ifa_flags (NMSettingIP6ConfigPrivacy use_tempaddr)\n }\n \n static void\n+nm_device_set_mtu (NMDevice *self, guint32 mtu)\n+{\n+        \/* MTU *\/\n+        if (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n+                nm_platform_link_set_mtu (ifindex, mtu);\n+}\n+\n+static void\n nm_device_ipv6_set_mtu (NMDevice *self, guint32 mtu)\n {\n \tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n@@ -5928,6 +5936,8 @@ nm_device_set_ip4_config (NMDevice *self,\n \tif (commit && new_config) {\n \t\tgboolean assumed = nm_device_uses_assumed_connection (self);\n \n+\t\tnm_device_set_mtu (self, nm_ip4_config_get_mtu (new_config));\n+\n \t\t\/* for assumed devices we set the device_route_metric to the default which will\n \t\t * stop nm_platform_ip4_address_sync() to replace the device routes. *\/\n \t\tsuccess = nm_ip4_config_commit (new_config, ip_ifindex,\ndiff --git a\/src\/nm-ip4-config.c b\/src\/nm-ip4-config.c\nindex 1f3e595..10e2b62 100644\n--- a\/src\/nm-ip4-config.c\n+++ b\/src\/nm-ip4-config.c\n@@ -264,7 +264,6 @@ gboolean\n nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)\n {\n \tNMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);\n-\tguint32 mtu = nm_ip4_config_get_mtu (config);\n \tint i;\n \n \tg_return_val_if_fail (ifindex > 0, FALSE);\n@@ -299,10 +298,6 @@ nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_ro\n \t\t\treturn FALSE;\n \t}\n \n-\t\/* MTU *\/\n-\tif (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n-\t\tnm_platform_link_set_mtu (ifindex, mtu);\n-\n \treturn TRUE;\n }\n \n-- \ncgit v1.1\n\n\ndiff --git a\/src\/devices\/nm-device.c b\/src\/devices\/nm-device.c\nindex 808ba6f..c31b476 100644\n--- a\/src\/devices\/nm-device.c\n+++ b\/src\/devices\/nm-device.c\n@@ -464,6 +464,12 @@ nm_device_ipv6_sysctl_set (NMDevice *self, const char *property, const char *val\n \treturn nm_platform_sysctl_set (nm_utils_ip6_property_path (nm_device_get_ip_iface (self), property), value);\n }\n \n+static guint32\n+nm_device_ipv6_sysctl_get_int32 (NMDevice *self, const char *property, gint32 fallback)\n+{\n+\treturn nm_platform_sysctl_get_int32 (nm_utils_ip6_property_path (nm_device_get_ip_iface (self), property), fallback);\n+}\n+\n static gboolean\n device_has_capability (NMDevice *self, NMDeviceCapabilities caps)\n {\n@@ -4079,21 +4085,53 @@ print_support_extended_ifa_flags (NMSettingIP6ConfigPrivacy use_tempaddr)\n \twarn = 2;\n }\n \n+static void nm_device_ipv6_set_mtu (NMDevice *self, guint32 mtu);\n+\n static void\n nm_device_set_mtu (NMDevice *self, guint32 mtu)\n {\n-        \/* MTU *\/\n-        if (mtu && mtu != nm_platform_link_get_mtu (ifindex))\n-                nm_platform_link_set_mtu (ifindex, mtu);\n+\tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n+\tint ifindex = nm_device_get_ifindex (self);\n+\n+\tif (mtu)\n+\t\tpriv->mtu = mtu;\n+\n+\t\/* Ensure the IPv6 MTU is still alright. *\/\n+\tif (priv->ip6_mtu)\n+\t\tnm_device_ipv6_set_mtu (self, priv->ip6_mtu);\n+\n+\tif (priv->mtu != nm_platform_link_get_mtu (ifindex))\n+\t\tnm_platform_link_set_mtu (ifindex, priv->mtu);\n }\n \n static void\n nm_device_ipv6_set_mtu (NMDevice *self, guint32 mtu)\n {\n \tNMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);\n+\tguint32 plat_mtu = nm_device_ipv6_sysctl_get_int32 (self, \"mtu\", priv->mtu);\n \tchar val[16];\n \n-\tif (mtu) {\n+\tpriv->ip6_mtu = mtu ?: plat_mtu;\n+\n+\tif (priv->ip6_mtu && priv->mtu < priv->ip6_mtu) {\n+\t\t_LOGW (LOGD_DEVICE | LOGD_IP6, \"Lowering IPv6 MTU (%d) to match device MTU (%d)\",\n+\t\t       priv->ip6_mtu, priv->mtu);\n+\t\tpriv->ip6_mtu = priv->mtu;\n+\t}\n+\n+\tif (priv->ip6_mtu < 1280) {\n+\t\t_LOGW (LOGD_DEVICE | LOGD_IP6, \"IPv6 MTU (%d) smaller than 1280, adjusting\",\n+\t\t       priv->ip6_mtu);\n+\t\tpriv->ip6_mtu = 1280;\n+\t}\n+\n+\tif (priv->mtu < priv->ip6_mtu) {\n+\t\t_LOGW (LOGD_DEVICE | LOGD_IP6, \"Raising device MTU (%d) to match IPv6 MTU (%d)\",\n+\t\t       priv->mtu, priv->ip6_mtu);\n+\t\tnm_device_set_mtu (self, priv->ip6_mtu);\n+\t}\n+\n+\tif (priv->ip6_mtu != plat_mtu) {\n \t\tg_snprintf (val, sizeof (val), \"%d\", mtu);\n \t\tnm_device_ipv6_sysctl_set (self, \"mtu\", val);\n \t}\n@@ -4598,6 +4636,13 @@ act_stage3_ip6_config_start (NMDevice *self,\n \t\treturn NM_ACT_STAGE_RETURN_STOP;\n \t}\n \n+\t\/* Ensure the MTU makes sense. If it was below 1280 the kernel would not\n+\t * expose any ipv6 sysctls or allow presence of any addresses on the interface,\n+\t * including LL, which * would make it impossible to autoconfigure MTU to a\n+\t * correct value. *\/\n+\tif (!nm_device_uses_assumed_connection (self))\n+\t\tnm_device_ipv6_set_mtu (self, priv->ip6_mtu);\n+\n \t\/* Any method past this point requires an IPv6LL address. Use NM-controlled\n \t * IPv6LL if this is not an assumed connection, since assumed connections\n \t * will already have IPv6 set up.\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-9919","CWE_ID":"20","category":"security","commit_id":"79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2","commit_message":"From 79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2 Mon Sep 17 00:00:00 2001\nFrom: David Ahern <dsa@cumulusnetworks.com>\nDate: Sun, 27 Nov 2016 18:52:53 -0800\nSubject: net: handle no dst on skb in icmp6_send\n\nAndrey reported the following while fuzzing the kernel with syzkaller:\n\nkasan: CONFIG_KASAN_INLINE enabled\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN\nModules linked in:\nCPU: 0 PID: 3859 Comm: a.out Not tainted 4.9.0-rc6+ #429\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01\/01\/2011\ntask: ffff8800666d4200 task.stack: ffff880067348000\nRIP: 0010:[<ffffffff833617ec>]  [<ffffffff833617ec>]\nicmp6_send+0x5fc\/0x1e30 net\/ipv6\/icmp.c:451\nRSP: 0018:ffff88006734f2c0  EFLAGS: 00010206\nRAX: ffff8800666d4200 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: dffffc0000000000 RDI: 0000000000000018\nRBP: ffff88006734f630 R08: ffff880064138418 R09: 0000000000000003\nR10: dffffc0000000000 R11: 0000000000000005 R12: 0000000000000000\nR13: ffffffff84e7e200 R14: ffff880064138484 R15: ffff8800641383c0\nFS:  00007fb3887a07c0(0000) GS:ffff88006cc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000000 CR3: 000000006b040000 CR4: 00000000000006f0\nStack:\n ffff8800666d4200 ffff8800666d49f8 ffff8800666d4200 ffffffff84c02460\n ffff8800666d4a1a 1ffff1000ccdaa2f ffff88006734f498 0000000000000046\n ffff88006734f440 ffffffff832f4269 ffff880064ba7456 0000000000000000\nCall Trace:\n [<ffffffff83364ddc>] icmpv6_param_prob+0x2c\/0x40 net\/ipv6\/icmp.c:557\n [<     inline     >] ip6_tlvopt_unknown net\/ipv6\/exthdrs.c:88\n [<ffffffff83394405>] ip6_parse_tlv+0x555\/0x670 net\/ipv6\/exthdrs.c:157\n [<ffffffff8339a759>] ipv6_parse_hopopts+0x199\/0x460 net\/ipv6\/exthdrs.c:663\n [<ffffffff832ee773>] ipv6_rcv+0xfa3\/0x1dc0 net\/ipv6\/ip6_input.c:191\n ...\n\nicmp6_send \/ icmpv6_send is invoked for both rx and tx paths. In both\ncases the dst->dev should be preferred for determining the L3 domain\nif the dst has been set on the skb. Fallback to the skb->dev if it has\nnot. This covers the case reported here where icmp6_send is invoked on\nRx before the route lookup.\n\nFixes: 5d41ce29e (\"net: icmp6_send should use dst dev to determine L3 domain\")\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: David Ahern <dsa@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/icmp.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/icmp.c b\/net\/ipv6\/icmp.c\nindex 7370ad2e693a..2772004ba5a1 100644\n--- a\/net\/ipv6\/icmp.c\n+++ b\/net\/ipv6\/icmp.c\n@@ -447,8 +447,10 @@ static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info,\n \n \tif (__ipv6_addr_needs_scope_id(addr_type))\n \t\tiif = skb->dev->ifindex;\n-\telse\n-\t\tiif = l3mdev_master_ifindex(skb_dst(skb)->dev);\n+\telse {\n+\t\tdst = skb_dst(skb);\n+\t\tiif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev);\n+\t}\n \n \t\/*\n \t *\tMust not send error if the source does not uniquely\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-0293","CWE_ID":"20","category":"security","commit_id":"86f8fb0e344d62454f8daf3e15236b2b59210756","commit_message":"From 86f8fb0e344d62454f8daf3e15236b2b59210756 Mon Sep 17 00:00:00 2001\nFrom: Emilia Kasper <emilia@openssl.org>\nDate: Wed, 4 Mar 2015 09:05:02 -0800\nSubject: [PATCH] Fix reachable assert in SSLv2 servers.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nThis assert is reachable for servers that support SSLv2 and export ciphers.\nTherefore, such servers can be DoSed by sending a specially crafted\nSSLv2 CLIENT-MASTER-KEY.\n\nAlso fix s2_srvr.c to error out early if the key lengths are malformed.\nThese lengths are sent unencrypted, so this does not introduce an oracle.\n\nCVE-2015-0293\n\nThis issue was discovered by Sean Burford (Google) and Emilia K\u00c3\u00a4sper of\nthe OpenSSL development team.\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Tim Hudson <tjh@openssl.org>\n---\n ssl\/s2_lib.c  |  2 +-\n ssl\/s2_srvr.c | 57 ++++++++++++++++++++++++++++++++++++++++-----------\n 2 files changed, 46 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/ssl\/s2_lib.c b\/ssl\/s2_lib.c\nindex f8a9439303..d55b93f76b 100644\n--- a\/ssl\/s2_lib.c\n+++ b\/ssl\/s2_lib.c\n@@ -493,7 +493,7 @@ int ssl2_generate_key_material(SSL *s)\n \n         OPENSSL_assert(s->session->master_key_length >= 0\n                        && s->session->master_key_length\n-                       < (int)sizeof(s->session->master_key));\n+                       <= (int)sizeof(s->session->master_key));\n         EVP_DigestUpdate(&ctx, s->session->master_key,\n                          s->session->master_key_length);\n         EVP_DigestUpdate(&ctx, &c, 1);\ndiff --git a\/ssl\/s2_srvr.c b\/ssl\/s2_srvr.c\nindex daba6dd7ad..4046697b26 100644\n--- a\/ssl\/s2_srvr.c\n+++ b\/ssl\/s2_srvr.c\n@@ -454,11 +454,6 @@ static int get_client_master_key(SSL *s)\n         SSLerr(SSL_F_GET_CLIENT_MASTER_KEY, SSL_R_NO_PRIVATEKEY);\n         return (-1);\n     }\n-    i = ssl_rsa_private_decrypt(s->cert, s->s2->tmp.enc,\n-                                &(p[s->s2->tmp.clear]),\n-                                &(p[s->s2->tmp.clear]),\n-                                (s->s2->ssl2_rollback) ? RSA_SSLV23_PADDING :\n-                                RSA_PKCS1_PADDING);\n \n     is_export = SSL_C_IS_EXPORT(s->session->cipher);\n \n@@ -475,23 +470,61 @@ static int get_client_master_key(SSL *s)\n     } else\n         ek = 5;\n \n+    \/*\n+     * The format of the CLIENT-MASTER-KEY message is\n+     * 1 byte message type\n+     * 3 bytes cipher\n+     * 2-byte clear key length (stored in s->s2->tmp.clear)\n+     * 2-byte encrypted key length (stored in s->s2->tmp.enc)\n+     * 2-byte key args length (IV etc)\n+     * clear key\n+     * encrypted key\n+     * key args\n+     *\n+     * If the cipher is an export cipher, then the encrypted key bytes\n+     * are a fixed portion of the total key (5 or 8 bytes). The size of\n+     * this portion is in |ek|. If the cipher is not an export cipher,\n+     * then the entire key material is encrypted (i.e., clear key length\n+     * must be zero).\n+     *\/\n+    if ((!is_export && s->s2->tmp.clear != 0) ||\n+        (is_export && s->s2->tmp.clear + ek != EVP_CIPHER_key_length(c))) {\n+        ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n+        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_BAD_LENGTH);\n+        return -1;\n+    }\n+    \/*\n+     * The encrypted blob must decrypt to the encrypted portion of the key.\n+     * Decryption can't be expanding, so if we don't have enough encrypted\n+     * bytes to fit the key in the buffer, stop now.\n+     *\/\n+    if ((is_export && s->s2->tmp.enc < ek) ||\n+        (!is_export && s->s2->tmp.enc < EVP_CIPHER_key_length(c))) {\n+        ssl2_return_error(s,SSL2_PE_UNDEFINED_ERROR);\n+        SSLerr(SSL_F_GET_CLIENT_MASTER_KEY,SSL_R_LENGTH_TOO_SHORT);\n+        return -1;\n+    }\n+\n+    i = ssl_rsa_private_decrypt(s->cert, s->s2->tmp.enc,\n+                                &(p[s->s2->tmp.clear]),\n+                                &(p[s->s2->tmp.clear]),\n+                                (s->s2->ssl2_rollback) ? RSA_SSLV23_PADDING :\n+                                RSA_PKCS1_PADDING);\n+\n     \/* bad decrypt *\/\n # if 1\n     \/*\n      * If a bad decrypt, continue with protocol but with a random master\n      * secret (Bleichenbacher attack)\n      *\/\n-    if ((i < 0) || ((!is_export && (i != EVP_CIPHER_key_length(c)))\n-                    || (is_export && ((i != ek)\n-                                      || (s->s2->tmp.clear +\n-                                          (unsigned int)i != (unsigned int)\n-                                          EVP_CIPHER_key_length(c)))))) {\n+    if ((i < 0) || ((!is_export && i != EVP_CIPHER_key_length(c))\n+                    || (is_export && i != ek))) {\n         ERR_clear_error();\n         if (is_export)\n             i = ek;\n         else\n             i = EVP_CIPHER_key_length(c);\n-        if (RAND_pseudo_bytes(p, i) <= 0)\n+        if (RAND_pseudo_bytes(&p[s->s2->tmp.clear], i) <= 0)\n             return 0;\n     }\n # else\n@@ -513,7 +546,7 @@ static int get_client_master_key(SSL *s)\n # endif\n \n     if (is_export)\n-        i += s->s2->tmp.clear;\n+        i = EVP_CIPHER_key_length(c);\n \n     if (i > SSL_MAX_MASTER_KEY_LENGTH) {\n         ssl2_return_error(s, SSL2_PE_UNDEFINED_ERROR);\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-3674","CWE_ID":"20","category":"security","commit_id":"7ef2dbd2392e3e4d430e0173e1e5c4df9f18b6dd","commit_message":"From 7ef2dbd2392e3e4d430e0173e1e5c4df9f18b6dd Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 7 May 2013 21:04:33 +0200\nSubject: [PATCH] avcodec\/cdgraphics: check buffer size before use\n\nFixes out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit ad002e1a13a8df934bd6cb2c84175a4780ab8942)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/cdgraphics.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/cdgraphics.c b\/libavcodec\/cdgraphics.c\nindex 202211d124..94ce6ae946 100644\n--- a\/libavcodec\/cdgraphics.c\n+++ b\/libavcodec\/cdgraphics.c\n@@ -300,7 +300,9 @@ static int cdg_decode_frame(AVCodecContext *avctx,\n     inst    = bytestream_get_byte(&buf);\n     inst    &= CDG_MASK;\n     buf += 2;  \/\/\/ skipping 2 unneeded bytes\n-    bytestream_get_buffer(&buf, cdg_data, buf_size - CDG_HEADER_SIZE);\n+\n+    if (buf_size > CDG_HEADER_SIZE)\n+        bytestream_get_buffer(&buf, cdg_data, buf_size - CDG_HEADER_SIZE);\n \n     if ((command & CDG_MASK) == CDG_COMMAND) {\n         switch (inst) {\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-4809","CWE_ID":"20","category":"security","commit_id":"fd7e0c02e272913a0a8b6d492c7260dfca0b1408","commit_message":"From fd7e0c02e272913a0a8b6d492c7260dfca0b1408 Mon Sep 17 00:00:00 2001\nFrom: Tim Kientzle <kientzle@acm.org>\nDate: Sat, 14 May 2016 12:37:37 -0700\nSubject: [PATCH] Reject cpio symlinks that exceed 1MB\n\n---\n libarchive\/archive_read_support_format_cpio.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/libarchive\/archive_read_support_format_cpio.c b\/libarchive\/archive_read_support_format_cpio.c\nindex c2ca85bd3..b09db0e9a 100644\n--- a\/libarchive\/archive_read_support_format_cpio.c\n+++ b\/libarchive\/archive_read_support_format_cpio.c\n@@ -401,6 +401,11 @@ archive_read_format_cpio_read_header(struct archive_read *a,\n \n \t\/* If this is a symlink, read the link contents. *\/\n \tif (archive_entry_filetype(entry) == AE_IFLNK) {\n+\t\tif (cpio->entry_bytes_remaining > 1024 * 1024) {\n+\t\t\tarchive_set_error(&a->archive, ENOMEM,\n+\t\t\t    \"Rejecting malformed cpio archive: symlink contents exceed 1 megabyte\");\n+\t\t\treturn (ARCHIVE_FATAL);\n+\t\t}\n \t\th = __archive_read_ahead(a,\n \t\t\t(size_t)cpio->entry_bytes_remaining, NULL);\n \t\tif (h == NULL)\n","owner":"libarchive","repo":"libarchive","source":"cve"},{"CVE_ID":"CVE-2016-1541","CWE_ID":"20","category":"security","commit_id":"d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7","commit_message":"From d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7 Mon Sep 17 00:00:00 2001\nFrom: Tim Kientzle <kientzle@acm.org>\nDate: Sun, 24 Apr 2016 17:13:45 -0700\nSubject: [PATCH] Issue #656:  Fix CVE-2016-1541, VU#862384\n\nWhen reading OS X metadata entries in Zip archives that were stored\nwithout compression, libarchive would use the uncompressed entry size\nto allocate a buffer but would use the compressed entry size to limit\nthe amount of data copied into that buffer.  Since the compressed\nand uncompressed sizes are provided by data in the archive itself,\nan attacker could manipulate these values to write data beyond\nthe end of the allocated buffer.\n\nThis fix provides three new checks to guard against such\nmanipulation and to make libarchive generally more robust when\nhandling this type of entry:\n 1. If an OS X metadata entry is stored without compression,\n    abort the entire archive if the compressed and uncompressed\n    data sizes do not match.\n 2. When sanity-checking the size of an OS X metadata entry,\n    abort this entry if either the compressed or uncompressed\n    size is larger than 4MB.\n 3. When copying data into the allocated buffer, check the copy\n    size against both the compressed entry size and uncompressed\n    entry size.\n---\n libarchive\/archive_read_support_format_zip.c | 13 +++++++++++++\n 1 file changed, 13 insertions(+)\n\n","diff_code":"diff --git a\/libarchive\/archive_read_support_format_zip.c b\/libarchive\/archive_read_support_format_zip.c\nindex 0f8262c62..0a0be96b5 100644\n--- a\/libarchive\/archive_read_support_format_zip.c\n+++ b\/libarchive\/archive_read_support_format_zip.c\n@@ -2778,6 +2778,11 @@ zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,\n \n \tswitch(rsrc->compression) {\n \tcase 0:  \/* No compression. *\/\n+\t\tif (rsrc->uncompressed_size != rsrc->compressed_size) {\n+\t\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n+\t\t\t    \"Malformed OS X metadata entry: inconsistent size\");\n+\t\t\treturn (ARCHIVE_FATAL);\n+\t\t}\n #ifdef HAVE_ZLIB_H\n \tcase 8: \/* Deflate compression. *\/\n #endif\n@@ -2798,6 +2803,12 @@ zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,\n \t\t    (intmax_t)rsrc->uncompressed_size);\n \t\treturn (ARCHIVE_WARN);\n \t}\n+\tif (rsrc->compressed_size > (4 * 1024 * 1024)) {\n+\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n+\t\t    \"Mac metadata is too large: %jd > 4M bytes\",\n+\t\t    (intmax_t)rsrc->compressed_size);\n+\t\treturn (ARCHIVE_WARN);\n+\t}\n \n \tmetadata = malloc((size_t)rsrc->uncompressed_size);\n \tif (metadata == NULL) {\n@@ -2836,6 +2847,8 @@ zip_read_mac_metadata(struct archive_read *a, struct archive_entry *entry,\n \t\t\tbytes_avail = remaining_bytes;\n \t\tswitch(rsrc->compression) {\n \t\tcase 0:  \/* No compression. *\/\n+\t\t\tif ((size_t)bytes_avail > metadata_bytes)\n+\t\t\t\tbytes_avail = metadata_bytes;\n \t\t\tmemcpy(mp, p, bytes_avail);\n \t\t\tbytes_used = (size_t)bytes_avail;\n \t\t\tmetadata_bytes -= bytes_used;\n","owner":"libarchive","repo":"libarchive","source":"cve"},{"CVE_ID":"CVE-2012-2321","CWE_ID":"20","category":"security","commit_id":"26ace5c59f790bce0f1988b88874c6f2c480fd5a","commit_message":"From 26ace5c59f790bce0f1988b88874c6f2c480fd5a Mon Sep 17 00:00:00 2001\nFrom: Jukka Rissanen <jukka.rissanen@linux.intel.com>\nDate: Thu, 3 May 2012 16:15:07 +0300\nSubject: inet: Add function that checks if the hostname is valid\n\n---\n include\/inet.h |  1 +\n src\/inet.c     | 48 ++++++++++++++++++++++++++++++++++++++++++++++++\n 2 files changed, 49 insertions(+)\n\n","diff_code":"diff --git a\/include\/inet.h b\/include\/inet.h\nindex 2048de1a..aa675737 100644\n--- a\/include\/inet.h\n+++ b\/include\/inet.h\n@@ -80,6 +80,7 @@ int connman_inet_setup_tunnel(char *tunnel, int mtu);\n int connman_inet_create_tunnel(char **iface);\n int connman_inet_get_dest_addr(int index, char **dest);\n int connman_inet_ipv6_get_dest_addr(int index, char **dest);\n+connman_bool_t connman_inet_check_hostname(const char *ptr, size_t len);\n \n #ifdef __cplusplus\n }\ndiff --git a\/src\/inet.c b\/src\/inet.c\nindex e01bfb38..effa68c0 100644\n--- a\/src\/inet.c\n+++ b\/src\/inet.c\n@@ -44,6 +44,7 @@\n #include <netinet\/icmp6.h>\n #include <fcntl.h>\n #include <linux\/if_tun.h>\n+#include <ctype.h>\n \n #include \"connman.h\"\n \n@@ -2172,3 +2173,50 @@ int __connman_inet_rtnl_addattr32(struct nlmsghdr *n, size_t maxlen, int type,\n \n \treturn 0;\n }\n+\n+\/* Check routine modified from ics-dhcp 4.2.3-P2 *\/\n+connman_bool_t connman_inet_check_hostname(const char *ptr, size_t len)\n+{\n+\tconst char *p;\n+\n+\t\/*\n+\t * Not empty or complete length not over 255 characters.\n+\t *\/\n+\tif ((len == 0) || (len > 256))\n+\t\treturn FALSE;\n+\n+\t\/*\n+\t * Consists of [[:alnum:]-]+ labels separated by [.]\n+\t * a [_] is against RFC but seems to be \"widely used\"\n+\t *\/\n+\tfor (p = ptr; (*p != 0) && (len-- > 0); p++) {\n+\n+\t\tif ((*p == '-') || (*p == '_')) {\n+\t\t\t\/*\n+\t\t\t * Not allowed at begin or end of a label.\n+\t\t\t *\/\n+\t\t\tif (((p - ptr) == 0) || (len == 0) || (p[1] == '.'))\n+\t\t\t\treturn FALSE;\n+\n+\t\t} else if (*p == '.') {\n+\t\t\t\/*\n+\t\t\t * Each label has to be 1-63 characters;\n+\t\t\t * we allow [.] at the end ('foo.bar.')\n+\t\t\t *\/\n+\t\t\tsize_t d = p - ptr;\n+\n+\t\t\tif ((d <= 0) || (d >= 64))\n+\t\t\t\treturn FALSE;\n+\n+\t\t\tptr = p + 1; \/* Jump to the next label *\/\n+\n+\t\t} else if (isalnum((unsigned char)*p) == 0) {\n+\t\t\t\/*\n+\t\t\t * Also numbers at the begin are fine\n+\t\t\t *\/\n+\t\t\treturn FALSE;\n+\t\t}\n+\t}\n+\n+\treturn TRUE;\n+}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4254","CWE_ID":"20","category":"security","commit_id":"c95eb3184ea1a3a2551df57190c81da695e2144b","commit_message":"From c95eb3184ea1a3a2551df57190c81da695e2144b Mon Sep 17 00:00:00 2001\nFrom: Will Deacon <will.deacon@arm.com>\nDate: Wed, 7 Aug 2013 23:39:41 +0100\nSubject: ARM: 7809\/1: perf: fix event validation for software group leaders\n\nIt is possible to construct an event group with a software event as a\ngroup leader and then subsequently add a hardware event to the group.\nThis results in the event group being validated by adding all members\nof the group to a fake PMU and attempting to allocate each event on\ntheir respective PMU.\n\nUnfortunately, for software events wthout a corresponding arm_pmu, this\nresults in a kernel crash attempting to dereference the ->get_event_idx\nfunction pointer.\n\nThis patch fixes the problem by checking explicitly for software events\nand ignoring those in event validation (since they can always be\nscheduled). We will probably want to revisit this for 3.12, since the\nvalidation checks don't appear to work correctly when dealing with\nmultiple hardware PMUs anyway.\n\nCc: <stable@vger.kernel.org>\nReported-by: Vince Weaver <vincent.weaver@maine.edu>\nTested-by: Vince Weaver <vincent.weaver@maine.edu>\nTested-by: Mark Rutland <mark.rutland@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>\n---\n arch\/arm\/kernel\/perf_event.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/arch\/arm\/kernel\/perf_event.c b\/arch\/arm\/kernel\/perf_event.c\nindex d9f5cd4e533f..0500f10b5041 100644\n--- a\/arch\/arm\/kernel\/perf_event.c\n+++ b\/arch\/arm\/kernel\/perf_event.c\n@@ -253,6 +253,9 @@ validate_event(struct pmu_hw_events *hw_events,\n \tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n \tstruct pmu *leader_pmu = event->group_leader->pmu;\n \n+\tif (is_software_event(event))\n+\t\treturn 1;\n+\n \tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n \t\treturn 1;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-0203","CWE_ID":"20","category":"security","commit_id":"86acdca1b63e6890540fa19495cfc708beff3d8b","commit_message":"From 86acdca1b63e6890540fa19495cfc708beff3d8b Mon Sep 17 00:00:00 2001\nFrom: Al Viro <viro@zeniv.linux.org.uk>\nDate: Tue, 22 Dec 2009 23:45:11 -0500\nSubject: [PATCH] fix autofs\/afs\/etc. magic mountpoint breakage\n\nWe end up trying to kfree() nd.last.name on open(\"\/mnt\/tmp\", O_CREAT)\nif \/mnt\/tmp is an autofs direct mount.  The reason is that nd.last_type\nis bogus here; we want LAST_BIND for everything of that kind and we\nget LAST_NORM left over from finding parent directory.\n\nSo make sure that it *is* set properly; set to LAST_BIND before\ndoing ->follow_link() - for normal symlinks it will be changed\nby __vfs_follow_link() and everything else needs it set that way.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>\n---\n fs\/namei.c     | 1 +\n fs\/proc\/base.c | 1 -\n 2 files changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/namei.c b\/fs\/namei.c\nindex b55440baf7ab8..1b26b16206642 100644\n--- a\/fs\/namei.c\n+++ b\/fs\/namei.c\n@@ -561,6 +561,7 @@ static __always_inline int __do_follow_link(struct path *path, struct nameidata\n \t\tdget(dentry);\n \t}\n \tmntget(path->mnt);\n+\tnd->last_type = LAST_BIND;\n \tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n \terror = PTR_ERR(cookie);\n \tif (!IS_ERR(cookie)) {\ndiff --git a\/fs\/proc\/base.c b\/fs\/proc\/base.c\nindex 18d5cc62d8ed9..e42bbd843ed13 100644\n--- a\/fs\/proc\/base.c\n+++ b\/fs\/proc\/base.c\n@@ -1419,7 +1419,6 @@ static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n \t\tgoto out;\n \n \terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n-\tnd->last_type = LAST_BIND;\n out:\n \treturn ERR_PTR(error);\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-3288","CWE_ID":"20","category":"security","commit_id":"6b7339f4c31ad69c8e9c0b2859276e22cf72176d","commit_message":"From 6b7339f4c31ad69c8e9c0b2859276e22cf72176d Mon Sep 17 00:00:00 2001\nFrom: \"Kirill A. Shutemov\" <kirill.shutemov@linux.intel.com>\nDate: Mon, 6 Jul 2015 23:18:37 +0300\nSubject: mm: avoid setting up anonymous pages into file mapping\n\nReading page fault handler code I've noticed that under right\ncircumstances kernel would map anonymous pages into file mappings: if\nthe VMA doesn't have vm_ops->fault() and the VMA wasn't fully populated\non ->mmap(), kernel would handle page fault to not populated pte with\ndo_anonymous_page().\n\nLet's change page fault handler to use do_anonymous_page() only on\nanonymous VMA (->vm_ops == NULL) and make sure that the VMA is not\nshared.\n\nFor file mappings without vm_ops->fault() or shred VMA without vm_ops,\npage fault on pte_none() entry would lead to SIGBUS.\n\nSigned-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nAcked-by: Oleg Nesterov <oleg@redhat.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Willy Tarreau <w@1wt.eu>\nCc: stable@vger.kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/memory.c | 20 +++++++++++++-------\n 1 file changed, 13 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/mm\/memory.c b\/mm\/memory.c\nindex a84fbb772034..388dcf9aa283 100644\n--- a\/mm\/memory.c\n+++ b\/mm\/memory.c\n@@ -2670,6 +2670,10 @@ static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\n \n \tpte_unmap(page_table);\n \n+\t\/* File mapping without ->vm_ops ? *\/\n+\tif (vma->vm_flags & VM_SHARED)\n+\t\treturn VM_FAULT_SIGBUS;\n+\n \t\/* Check if we need to add a guard page to the stack *\/\n \tif (check_stack_guard_page(vma, address) < 0)\n \t\treturn VM_FAULT_SIGSEGV;\n@@ -3099,6 +3103,9 @@ static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n \t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n \n \tpte_unmap(page_table);\n+\t\/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND *\/\n+\tif (!vma->vm_ops->fault)\n+\t\treturn VM_FAULT_SIGBUS;\n \tif (!(flags & FAULT_FLAG_WRITE))\n \t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n \t\t\t\torig_pte);\n@@ -3244,13 +3251,12 @@ static int handle_pte_fault(struct mm_struct *mm,\n \tbarrier();\n \tif (!pte_present(entry)) {\n \t\tif (pte_none(entry)) {\n-\t\t\tif (vma->vm_ops) {\n-\t\t\t\tif (likely(vma->vm_ops->fault))\n-\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n-\t\t\t\t\t\t\tpmd, flags, entry);\n-\t\t\t}\n-\t\t\treturn do_anonymous_page(mm, vma, address,\n-\t\t\t\t\t\t pte, pmd, flags);\n+\t\t\tif (vma->vm_ops)\n+\t\t\t\treturn do_fault(mm, vma, address, pte, pmd,\n+\t\t\t\t\t\tflags, entry);\n+\n+\t\t\treturn do_anonymous_page(mm, vma, address, pte, pmd,\n+\t\t\t\t\tflags);\n \t\t}\n \t\treturn do_swap_page(mm, vma, address,\n \t\t\t\t\tpte, pmd, flags, entry);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-18200","CWE_ID":"20","category":"security","commit_id":"638164a2718f337ea224b747cf5977ef143166a4","commit_message":"From 638164a2718f337ea224b747cf5977ef143166a4 Mon Sep 17 00:00:00 2001\nFrom: Chao Yu <yuchao0@huawei.com>\nDate: Mon, 2 Oct 2017 02:50:16 +0800\nSubject: [PATCH] f2fs: fix potential panic during fstrim\n\nAs Ju Hyung Park reported:\n\n\"When 'fstrim' is called for manual trim, a BUG() can be triggered\nrandomly with this patch.\n\nI'm seeing this issue on both x86 Desktop and arm64 Android phone.\n\nOn x86 Desktop, this was caused during Ubuntu boot-up. I have a\ncronjob installed which calls 'fstrim -v \/' during boot. On arm64\nAndroid, this was caused during GC looping with 1ms gc_min_sleep_time\n& gc_max_sleep_time.\"\n\nRoot cause of this issue is that f2fs_wait_discard_bios can only be\nused by f2fs_put_super, because during put_super there must be no\nother referrers, so it can ignore discard entry's reference count\nwhen removing the entry, otherwise in other caller we will hit bug_on\nin __remove_discard_cmd as there may be other issuer added reference\ncount in discard entry.\n\nThread A\t\t\t\tThread B\n\t\t\t\t\t- issue_discard_thread\n- f2fs_ioc_fitrim\n - f2fs_trim_fs\n  - f2fs_wait_discard_bios\n   - __issue_discard_cmd\n    - __submit_discard_cmd\n\t\t\t\t\t - __wait_discard_cmd\n\t\t\t\t\t  - dc->ref++\n\t\t\t\t\t  - __wait_one_discard_bio\n   - __wait_discard_cmd\n    - __remove_discard_cmd\n     - f2fs_bug_on(sbi, dc->ref)\n\nFixes: 969d1b180d987c2be02de890d0fff0f66a0e80de\nReported-by: Ju Hyung Park <qkrwngud825@gmail.com>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>\n---\n fs\/f2fs\/f2fs.h    | 2 +-\n fs\/f2fs\/segment.c | 6 +++---\n fs\/f2fs\/super.c   | 2 +-\n 3 files changed, 5 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/fs\/f2fs\/f2fs.h b\/fs\/f2fs\/f2fs.h\nindex 9a7c903869477..4b4a72f392be4 100644\n--- a\/fs\/f2fs\/f2fs.h\n+++ b\/fs\/f2fs\/f2fs.h\n@@ -2525,7 +2525,7 @@ void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr);\n bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);\n void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new);\n void stop_discard_thread(struct f2fs_sb_info *sbi);\n-void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi);\n+void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount);\n void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc);\n void release_discard_addrs(struct f2fs_sb_info *sbi);\n int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra);\ndiff --git a\/fs\/f2fs\/segment.c b\/fs\/f2fs\/segment.c\nindex 621b9b3d320bb..c695ff462ee69 100644\n--- a\/fs\/f2fs\/segment.c\n+++ b\/fs\/f2fs\/segment.c\n@@ -1210,11 +1210,11 @@ void stop_discard_thread(struct f2fs_sb_info *sbi)\n }\n \n \/* This comes from f2fs_put_super and f2fs_trim_fs *\/\n-void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n+void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount)\n {\n \t__issue_discard_cmd(sbi, false);\n \t__drop_discard_cmd(sbi);\n-\t__wait_discard_cmd(sbi, false);\n+\t__wait_discard_cmd(sbi, !umount);\n }\n \n static void mark_discard_range_all(struct f2fs_sb_info *sbi)\n@@ -2244,7 +2244,7 @@ int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n \t}\n \t\/* It's time to issue all the filed discards *\/\n \tmark_discard_range_all(sbi);\n-\tf2fs_wait_discard_bios(sbi);\n+\tf2fs_wait_discard_bios(sbi, false);\n out:\n \trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n \treturn err;\ndiff --git a\/fs\/f2fs\/super.c b\/fs\/f2fs\/super.c\nindex 89f61eb3d1671..933c3d529e653 100644\n--- a\/fs\/f2fs\/super.c\n+++ b\/fs\/f2fs\/super.c\n@@ -801,7 +801,7 @@ static void f2fs_put_super(struct super_block *sb)\n \t}\n \n \t\/* be sure to wait for any on-going discard commands *\/\n-\tf2fs_wait_discard_bios(sbi);\n+\tf2fs_wait_discard_bios(sbi, true);\n \n \tif (f2fs_discard_en(sbi) && !sbi->discard_blks) {\n \t\tstruct cp_control cpc = {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-6563","CWE_ID":"20","category":"security","commit_id":"d4697fe9a28dab7255c60433e4dd23cf7fce8a8b","commit_message":"From d4697fe9a28dab7255c60433e4dd23cf7fce8a8b Mon Sep 17 00:00:00 2001\nFrom: Damien Miller <djm@mindrot.org>\nDate: Tue, 11 Aug 2015 13:33:24 +1000\nSubject: [PATCH] Don't resend username to PAM; it already has it.\n\nPointed out by Moritz Jodeit; ok dtucker@\n---\n monitor.c      | 2 --\n monitor_wrap.c | 1 -\n 2 files changed, 3 deletions(-)\n\n","diff_code":"diff --git a\/monitor.c b\/monitor.c\nindex b4109657e..f1b873dc4 100644\n--- a\/monitor.c\n+++ b\/monitor.c\n@@ -1084,9 +1084,7 @@ extern KbdintDevice sshpam_device;\n int\n mm_answer_pam_init_ctx(int sock, Buffer *m)\n {\n-\n \tdebug3(\"%s\", __func__);\n-\tauthctxt->user = buffer_get_string(m, NULL);\n \tsshpam_ctxt = (sshpam_device.init_ctx)(authctxt);\n \tsshpam_authok = NULL;\n \tbuffer_clear(m);\ndiff --git a\/monitor_wrap.c b\/monitor_wrap.c\nindex e6217b3d4..eac421ba1 100644\n--- a\/monitor_wrap.c\n+++ b\/monitor_wrap.c\n@@ -614,7 +614,6 @@ mm_sshpam_init_ctx(Authctxt *authctxt)\n \n \tdebug3(\"%s\", __func__);\n \tbuffer_init(&m);\n-\tbuffer_put_cstring(&m, authctxt->user);\n \tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n \tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n \tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n","owner":"openssh","repo":"openssh-portable","source":"cve"},{"CVE_ID":"CVE-2013-0860","CWE_ID":"20","category":"security","commit_id":"68a0477bc0af026db971ddba22541029a9e8715b","commit_message":"From 68a0477bc0af026db971ddba22541029a9e8715b Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 11 Jan 2013 04:44:20 +0100\nSubject: [PATCH] error_concealment: Check that the picture is not in a half\n setup state.\n\nFixes state becoming inconsistent\nFixes a null pointer dereference\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 23318a57358358e7a4dc551e830e4503f0638cfe)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/error_resilience.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/error_resilience.c b\/libavcodec\/error_resilience.c\nindex 01f7424904..2b6bc42ade 100644\n--- a\/libavcodec\/error_resilience.c\n+++ b\/libavcodec\/error_resilience.c\n@@ -924,6 +924,12 @@ void ff_er_frame_end(MpegEncContext *s)\n         return;\n     };\n \n+    if (   s->picture_structure == PICT_FRAME\n+        && s->current_picture.f.linesize[0] != s->current_picture_ptr->f.linesize[0]) {\n+        av_log(s->avctx, AV_LOG_ERROR, \"Error concealment not possible, frame not fully initialized\\n\");\n+        return;\n+    }\n+\n     if (s->current_picture.f.motion_val[0] == NULL) {\n         av_log(s->avctx, AV_LOG_ERROR, \"Warning MVs not available\\n\");\n \n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-0429","CWE_ID":"20","category":"security","commit_id":"18de8f9f0762c3a542b1122589edb8af859d9813","commit_message":"From 18de8f9f0762c3a542b1122589edb8af859d9813 Mon Sep 17 00:00:00 2001\nFrom: Steinar Midtskogen <stemidts@cisco.com>\nDate: Mon, 30 Jul 2018 14:43:35 +0200\nSubject: [PATCH] Fix possible stack overflows in decoder for illegal bit\n streams\n\nFixes CVE-2018-0429\nA vulnerability in the Thor decoder (available at:\nhttps:\/\/github.com\/cisco\/thor) could allow an authenticated, local\nattacker to cause segmentation faults and stack overflows when using a\nnon-conformant Thor bitstream as input.\nThe vulnerability is due to lack of input validation when parsing the\nbitstream. A successful exploit could allow the attacker to cause a\nstack overflow and potentially inject and execute arbitrary code.\n---\n dec\/decode_block.c | 2 +-\n dec\/read_bits.c    | 1 +\n 2 files changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/dec\/decode_block.c b\/dec\/decode_block.c\nindex a5cecab..85deeb5 100644\n--- a\/dec\/decode_block.c\n+++ b\/dec\/decode_block.c\n@@ -650,7 +650,7 @@ void TEMPLATE(process_block_dec)(decoder_info_t *decoder_info,int size,int yposY\n \n   decoder_info->bit_count.super_mode[decoder_info->bit_count.stat_frame_type] += (stream->bitcnt - bit_start);\n \n-  if (split_flag){\n+  if (split_flag && size >= MIN_BLOCK_SIZE){\n     int new_size = size\/2;\n     TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+0*new_size,sub);\n     TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+0*new_size,sub);\ndiff --git a\/dec\/read_bits.c b\/dec\/read_bits.c\nindex 130b53d..6eda9be 100644\n--- a\/dec\/read_bits.c\n+++ b\/dec\/read_bits.c\n@@ -50,6 +50,7 @@ void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\n   decoder_info->width = get_flc(16, stream);\n   decoder_info->height = get_flc(16, stream);\n   decoder_info->log2_sb_size = get_flc(3, stream);\n+  decoder_info->log2_sb_size = clip(decoder_info->log2_sb_size, log2i(MIN_BLOCK_SIZE), log2i(MAX_SB_SIZE));\n   decoder_info->pb_split = get_flc(1, stream);\n   decoder_info->tb_split_enable = get_flc(1, stream);\n   decoder_info->max_num_ref = get_flc(2, stream) + 1;\n","owner":"cisco","repo":"thor","source":"cve"},{"CVE_ID":"CVE-2010-4254","CWE_ID":"20","category":"security","commit_id":"cf1ec146f7c6acdc6697032b3aaafc68ffacdcac","commit_message":"From cf1ec146f7c6acdc6697032b3aaafc68ffacdcac Mon Sep 17 00:00:00 2001\nFrom: Rodrigo Kumpera <kumpera@gmail.com>\nDate: Thu, 25 Nov 2010 14:23:31 -0200\nSubject: [PATCH] Handle invalid instantiation of generic methods.\n\n\t* verify.c: Add new function to internal verifier API to check\n\tmethod instantiations.\n\n\t* reflection.c (mono_reflection_bind_generic_method_parameters):\n\tCheck the instantiation before returning it.\n\n\tFixes #655847\n---\n mono\/metadata\/reflection.c       |  3 +++\n mono\/metadata\/verify-internals.h |  1 +\n mono\/metadata\/verify.c           | 15 +++++++++++++++\n 3 files changed, 19 insertions(+)\n\n","diff_code":"diff --git a\/mono\/metadata\/reflection.c b\/mono\/metadata\/reflection.c\nindex d43ad089027c..15e649681aef 100644\n--- a\/mono\/metadata\/reflection.c\n+++ b\/mono\/metadata\/reflection.c\n@@ -10605,6 +10605,9 @@ mono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, M\n \t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n \t\tmono_loader_unlock ();\n \t}\n+\n+\tif (!mono_verifier_is_method_valid_generic_instantiation (inflated))\n+\t\tmono_raise_exception (mono_get_exception_argument (\"typeArguments\", \"Invalid generic arguments\"));\n \t\n \treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);\n }\ndiff --git a\/mono\/metadata\/verify-internals.h b\/mono\/metadata\/verify-internals.h\nindex 1d0fb75f4505..e01325ef8375 100644\n--- a\/mono\/metadata\/verify-internals.h\n+++ b\/mono\/metadata\/verify-internals.h\n@@ -22,6 +22,7 @@ gboolean mono_verifier_is_enabled_for_class (MonoClass *klass) MONO_INTERNAL;\n gboolean mono_verifier_is_method_full_trust (MonoMethod *method) MONO_INTERNAL;\n gboolean mono_verifier_is_class_full_trust (MonoClass *klass) MONO_INTERNAL;\n gboolean mono_verifier_class_is_valid_generic_instantiation (MonoClass *class) MONO_INTERNAL;\n+gboolean mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method) MONO_INTERNAL;\n \n gboolean mono_verifier_verify_class (MonoClass *klass) MONO_INTERNAL;\n \ndiff --git a\/mono\/metadata\/verify.c b\/mono\/metadata\/verify.c\nindex a1d5bcf88e26..81eb1effbca0 100644\n--- a\/mono\/metadata\/verify.c\n+++ b\/mono\/metadata\/verify.c\n@@ -6042,6 +6042,14 @@ mono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n \treturn mono_class_is_valid_generic_instantiation (NULL, class);\n }\n \n+gboolean\n+mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method)\n+{\n+\tif (!method->is_inflated)\n+\t\treturn TRUE;\n+\treturn mono_method_is_valid_generic_instantiation (NULL, method);\n+}\n+\n #else\n \n gboolean\n@@ -6113,5 +6121,12 @@ mono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n \treturn TRUE;\n }\n \n+gboolean\n+mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method)\n+{\n+\treturn TRUE;\n+}\n+\n+\n \n #endif\n","owner":"mono","repo":"mono","source":"cve"},{"CVE_ID":"CVE-2017-14604","CWE_ID":"20","category":"security","commit_id":"1630f53481f445ada0a455e9979236d31a8d3bb0","commit_message":"From 1630f53481f445ada0a455e9979236d31a8d3bb0 Mon Sep 17 00:00:00 2001\nFrom: Carlos Soriano <csoriano@gnome.org>\nDate: Mon, 6 Feb 2017 18:47:54 +0100\nSubject: [PATCH] mime-actions: use file metadata for trusting desktop files\n\nCurrently we only trust desktop files that have the executable bit\nset, and don't replace the displayed icon or the displayed name until\nit's trusted, which prevents for running random programs by a malicious\ndesktop file.\n\nHowever, the executable permission is preserved if the desktop file\ncomes from a compressed file.\n\nTo prevent this, add a metadata::trusted metadata to the file once the\nuser acknowledges the file as trusted. This adds metadata to the file,\nwhich cannot be added unless it has access to the computer.\n\nAlso remove the SHEBANG \"trusted\" content we were putting inside the\ndesktop file, since that doesn't add more security since it can come\nwith the file itself.\n\nhttps:\/\/bugzilla.gnome.org\/show_bug.cgi?id=777991\n---\n src\/nautilus-directory-async.c |   7 +-\n src\/nautilus-file-operations.c | 153 +++++++--------------------------\n src\/nautilus-file-operations.h |  10 +--\n src\/nautilus-metadata.c        |   1 +\n src\/nautilus-metadata.h        |   2 +\n src\/nautilus-mime-actions.c    |  46 ++++++----\n 6 files changed, 73 insertions(+), 146 deletions(-)\n\n","diff_code":"diff --git a\/src\/nautilus-directory-async.c b\/src\/nautilus-directory-async.c\nindex e8a10cd3b7..b02e3de87b 100644\n--- a\/src\/nautilus-directory-async.c\n+++ b\/src\/nautilus-directory-async.c\n@@ -30,6 +30,7 @@\n #include \"nautilus-global-preferences.h\"\n #include \"nautilus-link.h\"\n #include \"nautilus-profile.h\"\n+#include \"nautilus-metadata.h\"\n #include <eel\/eel-glib-extensions.h>\n #include <gtk\/gtk.h>\n #include <libxml\/parser.h>\n@@ -3580,13 +3581,17 @@ is_link_trusted (NautilusFile *file,\n {\n     GFile *location;\n     gboolean res;\n+    g_autofree gchar* trusted = NULL;\n \n     if (!is_launcher)\n     {\n         return TRUE;\n     }\n \n-    if (nautilus_file_can_execute (file))\n+    trusted = nautilus_file_get_metadata (file,\n+                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n+                                          NULL);\n+    if (nautilus_file_can_execute (file) && trusted != NULL)\n     {\n         return TRUE;\n     }\ndiff --git a\/src\/nautilus-file-operations.c b\/src\/nautilus-file-operations.c\nindex 89bc93d1ae..cd8ea0bdc6 100644\n--- a\/src\/nautilus-file-operations.c\n+++ b\/src\/nautilus-file-operations.c\n@@ -235,10 +235,10 @@ typedef struct\n #define COPY_FORCE _(\"Copy _Anyway\")\n \n static void\n-mark_desktop_file_trusted (CommonJob    *common,\n-                           GCancellable *cancellable,\n-                           GFile        *file,\n-                           gboolean      interactive);\n+mark_desktop_file_executable (CommonJob    *common,\n+                              GCancellable *cancellable,\n+                              GFile        *file,\n+                              gboolean      interactive);\n \n static gboolean\n is_all_button_text (const char *button_text)\n@@ -5290,10 +5290,10 @@ copy_move_file (CopyMoveJob   *copy_job,\n             g_file_equal (copy_job->desktop_location, dest_dir) &&\n             is_trusted_desktop_file (src, job->cancellable))\n         {\n-            mark_desktop_file_trusted (job,\n-                                       job->cancellable,\n-                                       dest,\n-                                       FALSE);\n+            mark_desktop_file_executable (job,\n+                                          job->cancellable,\n+                                          dest,\n+                                          FALSE);\n         }\n \n         if (job->undo_info != NULL)\n@@ -7887,9 +7887,9 @@ nautilus_file_operations_empty_trash (GtkWidget *parent_view)\n }\n \n static void\n-mark_trusted_task_done (GObject      *source_object,\n-                        GAsyncResult *res,\n-                        gpointer      user_data)\n+mark_desktop_file_executable_task_done (GObject      *source_object,\n+                                        GAsyncResult *res,\n+                                        gpointer      user_data)\n {\n     MarkTrustedJob *job = user_data;\n \n@@ -7907,110 +7907,19 @@ mark_trusted_task_done (GObject      *source_object,\n #define TRUSTED_SHEBANG \"#!\/usr\/bin\/env xdg-open\\n\"\n \n static void\n-mark_desktop_file_trusted (CommonJob    *common,\n-                           GCancellable *cancellable,\n-                           GFile        *file,\n-                           gboolean      interactive)\n+mark_desktop_file_executable (CommonJob    *common,\n+                              GCancellable *cancellable,\n+                              GFile        *file,\n+                              gboolean      interactive)\n {\n-    char *contents, *new_contents;\n-    gsize length, new_length;\n     GError *error;\n     guint32 current_perms, new_perms;\n     int response;\n     GFileInfo *info;\n \n retry:\n-    error = NULL;\n-    if (!g_file_load_contents (file,\n-                               cancellable,\n-                               &contents, &length,\n-                               NULL, &error))\n-    {\n-        if (interactive)\n-        {\n-            response = run_error (common,\n-                                  g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n-                                  error->message,\n-                                  NULL,\n-                                  FALSE,\n-                                  CANCEL, RETRY,\n-                                  NULL);\n-        }\n-        else\n-        {\n-            response = 0;\n-        }\n-\n-\n-        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n-        {\n-            abort_job (common);\n-        }\n-        else if (response == 1)\n-        {\n-            goto retry;\n-        }\n-        else\n-        {\n-            g_assert_not_reached ();\n-        }\n-\n-        goto out;\n-    }\n-\n-    if (!g_str_has_prefix (contents, \"#!\"))\n-    {\n-        new_length = length + strlen (TRUSTED_SHEBANG);\n-        new_contents = g_malloc (new_length);\n-\n-        strcpy (new_contents, TRUSTED_SHEBANG);\n-        memcpy (new_contents + strlen (TRUSTED_SHEBANG),\n-                contents, length);\n-\n-        if (!g_file_replace_contents (file,\n-                                      new_contents,\n-                                      new_length,\n-                                      NULL,\n-                                      FALSE, 0,\n-                                      NULL, cancellable, &error))\n-        {\n-            g_free (contents);\n-            g_free (new_contents);\n-\n-            if (interactive)\n-            {\n-                response = run_error (common,\n-                                      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n-                                      error->message,\n-                                      NULL,\n-                                      FALSE,\n-                                      CANCEL, RETRY,\n-                                      NULL);\n-            }\n-            else\n-            {\n-                response = 0;\n-            }\n-\n-            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n-            {\n-                abort_job (common);\n-            }\n-            else if (response == 1)\n-            {\n-                goto retry;\n-            }\n-            else\n-            {\n-                g_assert_not_reached ();\n-            }\n-\n-            goto out;\n-        }\n-        g_free (new_contents);\n-    }\n-    g_free (contents);\n \n+    error = NULL;\n     info = g_file_query_info (file,\n                               G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                               G_FILE_ATTRIBUTE_UNIX_MODE,\n@@ -8101,10 +8010,10 @@ mark_desktop_file_trusted (CommonJob    *common,\n }\n \n static void\n-mark_trusted_task_thread_func (GTask        *task,\n-                               gpointer      source_object,\n-                               gpointer      task_data,\n-                               GCancellable *cancellable)\n+mark_desktop_file_executable_task_thread_func (GTask        *task,\n+                                               gpointer      source_object,\n+                                               gpointer      task_data,\n+                                               GCancellable *cancellable)\n {\n     MarkTrustedJob *job = task_data;\n     CommonJob *common;\n@@ -8113,18 +8022,18 @@ mark_trusted_task_thread_func (GTask        *task,\n \n     nautilus_progress_info_start (job->common.progress);\n \n-    mark_desktop_file_trusted (common,\n-                               cancellable,\n-                               job->file,\n-                               job->interactive);\n+    mark_desktop_file_executable (common,\n+                                  cancellable,\n+                                  job->file,\n+                                  job->interactive);\n }\n \n void\n-nautilus_file_mark_desktop_file_trusted (GFile              *file,\n-                                         GtkWindow          *parent_window,\n-                                         gboolean            interactive,\n-                                         NautilusOpCallback  done_callback,\n-                                         gpointer            done_callback_data)\n+nautilus_file_mark_desktop_file_executable (GFile              *file,\n+                                            GtkWindow          *parent_window,\n+                                            gboolean            interactive,\n+                                            NautilusOpCallback  done_callback,\n+                                            gpointer            done_callback_data)\n {\n     GTask *task;\n     MarkTrustedJob *job;\n@@ -8135,9 +8044,9 @@ nautilus_file_mark_desktop_file_trusted (GFile              *file,\n     job->done_callback = done_callback;\n     job->done_callback_data = done_callback_data;\n \n-    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);\n+    task = g_task_new (NULL, NULL, mark_desktop_file_executable_task_done, job);\n     g_task_set_task_data (task, job, NULL);\n-    g_task_run_in_thread (task, mark_trusted_task_thread_func);\n+    g_task_run_in_thread (task, mark_desktop_file_executable_task_thread_func);\n     g_object_unref (task);\n }\n \ndiff --git a\/src\/nautilus-file-operations.h b\/src\/nautilus-file-operations.h\nindex 31b782dbac..a479ee6e02 100644\n--- a\/src\/nautilus-file-operations.h\n+++ b\/src\/nautilus-file-operations.h\n@@ -146,11 +146,11 @@ void nautilus_file_operations_link      (GList                *files,\n \t\t\t\t\t GtkWindow            *parent_window,\n \t\t\t\t\t NautilusCopyCallback  done_callback,\n \t\t\t\t\t gpointer              done_callback_data);\n-void nautilus_file_mark_desktop_file_trusted (GFile           *file,\n-\t\t\t\t\t      GtkWindow        *parent_window,\n-\t\t\t\t\t      gboolean          interactive,\n-\t\t\t\t\t      NautilusOpCallback done_callback,\n-\t\t\t\t\t      gpointer          done_callback_data);\n+void nautilus_file_mark_desktop_file_executable (GFile           *file,\n+                                                 GtkWindow        *parent_window,\n+                                                 gboolean          interactive,\n+                                                 NautilusOpCallback done_callback,\n+                                                 gpointer          done_callback_data);\n void nautilus_file_operations_extract_files (GList                   *files,\n                                              GFile                   *destination_directory,\n                                              GtkWindow               *parent_window,\ndiff --git a\/src\/nautilus-metadata.c b\/src\/nautilus-metadata.c\nindex 8316426f97..bee04e7ca5 100644\n--- a\/src\/nautilus-metadata.c\n+++ b\/src\/nautilus-metadata.c\n@@ -51,6 +51,7 @@ static char *used_metadata_names[] =\n     NAUTILUS_METADATA_KEY_CUSTOM_ICON_NAME,\n     NAUTILUS_METADATA_KEY_SCREEN,\n     NAUTILUS_METADATA_KEY_EMBLEMS,\n+    NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n     NULL\n };\n \ndiff --git a\/src\/nautilus-metadata.h b\/src\/nautilus-metadata.h\nindex 7a734af31a..c4a303ec55 100644\n--- a\/src\/nautilus-metadata.h\n+++ b\/src\/nautilus-metadata.h\n@@ -67,6 +67,8 @@\n #define NAUTILUS_METADATA_KEY_SCREEN\t\t\t\t\"screen\"\n #define NAUTILUS_METADATA_KEY_EMBLEMS\t\t\t\t\"emblems\"\n \n+#define NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED\t\t\t\t\"trusted\"\n+\n guint nautilus_metadata_get_id (const char *metadata);\n \n #endif \/* NAUTILUS_METADATA_H *\/\ndiff --git a\/src\/nautilus-mime-actions.c b\/src\/nautilus-mime-actions.c\nindex 036b9679d8..14fe44bc39 100644\n--- a\/src\/nautilus-mime-actions.c\n+++ b\/src\/nautilus-mime-actions.c\n@@ -42,6 +42,7 @@\n #include \"nautilus-program-choosing.h\"\n #include \"nautilus-global-preferences.h\"\n #include \"nautilus-signaller.h\"\n+#include \"nautilus-metadata.h\"\n \n #define DEBUG_FLAG NAUTILUS_DEBUG_MIME\n #include \"nautilus-debug.h\"\n@@ -221,7 +222,6 @@ struct\n #define RESPONSE_RUN 1000\n #define RESPONSE_DISPLAY 1001\n #define RESPONSE_RUN_IN_TERMINAL 1002\n-#define RESPONSE_MARK_TRUSTED 1003\n \n #define SILENT_WINDOW_OPEN_LIMIT 5\n #define SILENT_OPEN_LIMIT 5\n@@ -1517,24 +1517,35 @@ untrusted_launcher_response_callback (GtkDialog                 *dialog,\n \n     switch (response_id)\n     {\n-        case RESPONSE_RUN:\n+        case GTK_RESPONSE_OK:\n         {\n+            file = nautilus_file_get_location (parameters->file);\n+\n+            \/* We need to do this in order to prevent malicious desktop files\n+             * with the executable bit already set.\n+             * See https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=777991\n+             *\/\n+            nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n+                                        NULL,\n+                                        \"yes\");\n+\n+            nautilus_file_mark_desktop_file_executable (file,\n+                                                        parameters->parent_window,\n+                                                        TRUE,\n+                                                        NULL, NULL);\n+\n+            \/* Need to force a reload of the attributes so is_trusted is marked\n+             * correctly. Not sure why the general monitor doesn't fire in this\n+             * case when setting the metadata\n+             *\/\n+            nautilus_file_invalidate_all_attributes (parameters->file);\n+\n             screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n             uri = nautilus_file_get_uri (parameters->file);\n             DEBUG (\"Launching untrusted launcher %s\", uri);\n             nautilus_launch_desktop_file (screen, uri, NULL,\n                                           parameters->parent_window);\n             g_free (uri);\n-        }\n-        break;\n-\n-        case RESPONSE_MARK_TRUSTED:\n-        {\n-            file = nautilus_file_get_location (parameters->file);\n-            nautilus_file_mark_desktop_file_trusted (file,\n-                                                     parameters->parent_window,\n-                                                     TRUE,\n-                                                     NULL, NULL);\n             g_object_unref (file);\n         }\n         break;\n@@ -1590,17 +1601,16 @@ activate_desktop_file (ActivateParameters *parameters,\n                       \"text\", primary,\n                       \"secondary-text\", secondary,\n                       NULL);\n+\n         gtk_dialog_add_button (GTK_DIALOG (dialog),\n-                               _(\"_Launch Anyway\"), RESPONSE_RUN);\n+                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n+\n+        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n         if (nautilus_file_can_set_permissions (file))\n         {\n             gtk_dialog_add_button (GTK_DIALOG (dialog),\n-                                   _(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n+                                   _(\"Trust and _Launch\"), GTK_RESPONSE_OK);\n         }\n-        gtk_dialog_add_button (GTK_DIALOG (dialog),\n-                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n-        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n-\n         g_signal_connect (dialog, \"response\",\n                           G_CALLBACK (untrusted_launcher_response_callback),\n                           parameters_desktop);\n","owner":"GNOME","repo":"nautilus","source":"cve"},{"CVE_ID":"CVE-2015-3138","CWE_ID":"20","category":"security","commit_id":"3ed82f4ed0095768529afc22b923c8f7171fff70","commit_message":"From 3ed82f4ed0095768529afc22b923c8f7171fff70 Mon Sep 17 00:00:00 2001\nFrom: Denis Ovsienko <denis@ovsienko.info>\nDate: Wed, 25 Mar 2015 22:35:12 +0000\nSubject: [PATCH] whiteboard: fixup a few reversed tests (GH #446)\n\nThis is a follow-up to commit 3a3ec26.\n---\n print-wb.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/print-wb.c b\/print-wb.c\nindex 3e3b06452..4fa5e3800 100644\n--- a\/print-wb.c\n+++ b\/print-wb.c\n@@ -201,7 +201,7 @@ wb_id(netdissect_options *ndo,\n \tlen -= sizeof(*io) * nid;\n \tio = (struct id_off *)(id + 1);\n \tcp = (char *)(io + nid);\n-\tif (!ND_TTEST2(cp, len)) {\n+\tif (ND_TTEST2(cp, len)) {\n \t\tND_PRINT((ndo, \"\\\"\"));\n \t\tfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\n \t\tND_PRINT((ndo, \"\\\"\"));\n@@ -266,7 +266,7 @@ wb_prep(netdissect_options *ndo,\n \t}\n \tn = EXTRACT_32BITS(&prep->pp_n);\n \tps = (const struct pgstate *)(prep + 1);\n-\twhile (--n >= 0 && !ND_TTEST(*ps)) {\n+\twhile (--n >= 0 && ND_TTEST(*ps)) {\n \t\tconst struct id_off *io, *ie;\n \t\tchar c = '<';\n \n@@ -275,7 +275,7 @@ wb_prep(netdissect_options *ndo,\n \t\t    ipaddr_string(ndo, &ps->page.p_sid),\n \t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n \t\tio = (struct id_off *)(ps + 1);\n-\t\tfor (ie = io + ps->nid; io < ie && !ND_TTEST(*io); ++io) {\n+\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n \t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n \t\t\t    EXTRACT_32BITS(&io->off)));\n \t\t\tc = ',';\n","owner":"the-tcpdump-group","repo":"tcpdump","source":"cve"},{"CVE_ID":"CVE-2017-14169","CWE_ID":"20","category":"security","commit_id":"9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad","commit_message":"From 9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?=E5=AD=99=E6=B5=A9=28=E6=99=93=E9=BB=91=29?=\n <tony.sh@alibaba-inc.com>\nDate: Tue, 29 Aug 2017 23:59:21 +0200\nSubject: [PATCH] avformat\/mxfdec: Fix Sign error in mxf_read_primer_pack()\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nFixes: 20170829B.mxf\n\nCo-Author: \u5f20\u6d2a\u4eae(\u671b\u521d)\" <wangchu.zhl@alibaba-inc.com>\nFound-by: Xiaohei and Wangchu from Alibaba Security Team\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/mxfdec.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavformat\/mxfdec.c b\/libavformat\/mxfdec.c\nindex 6adb77d81fb..91731a7533c 100644\n--- a\/libavformat\/mxfdec.c\n+++ b\/libavformat\/mxfdec.c\n@@ -500,7 +500,7 @@ static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, U\n         avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n         return AVERROR_PATCHWELCOME;\n     }\n-    if (item_num > 65536) {\n+    if (item_num > 65536 || item_num < 0) {\n         av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n         return AVERROR_INVALIDDATA;\n     }\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2016-5357","CWE_ID":"20","category":"security","commit_id":"6a140eca7b78b230f1f90a739a32257476513c78","commit_message":"From 6a140eca7b78b230f1f90a739a32257476513c78 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Fri, 29 Apr 2016 17:08:11 -0700\nSubject: [PATCH] Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nMerge the header and packet data parsing routines while we're at it.\n\nBug: 12396\nChange-Id: I7f981f9cdcbea7ecdeb88bfff2f12d875de2244f\nReviewed-on: https:\/\/code.wireshark.org\/review\/15176\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n---\n wiretap\/netscreen.c | 101 ++++++++++++++++++--------------------------\n wiretap\/netscreen.h |   3 --\n 2 files changed, 40 insertions(+), 64 deletions(-)\n\n","diff_code":"diff --git a\/wiretap\/netscreen.c b\/wiretap\/netscreen.c\nindex c447a9a214..e10b1d9fe3 100644\n--- a\/wiretap\/netscreen.c\n+++ b\/wiretap\/netscreen.c\n@@ -69,12 +69,8 @@ static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n static gboolean netscreen_seek_read(wtap *wth, gint64 seek_off,\n \tstruct wtap_pkthdr *phdr, Buffer *buf,\n \tint *err, gchar **err_info);\n-static int parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line,\n-\tchar *cap_int, gboolean *cap_dir, char *cap_dst,\n-\tint *err, gchar **err_info);\n-static gboolean parse_netscreen_hex_dump(FILE_T fh, int pkt_len,\n-\tconst char *cap_int, const char *cap_dst, struct wtap_pkthdr *phdr,\n-\tBuffer* buf, int *err, gchar **err_info);\n+static gboolean parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr,\n+\tBuffer* buf, char *line, int *err, gchar **err_info);\n static int parse_single_hex_dump_line(char* rec, guint8 *buf,\n \tguint byte_offset);\n \n@@ -191,27 +187,16 @@ static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n     gint64 *data_offset)\n {\n \tgint64\t\toffset;\n-\tint\t\tpkt_len;\n \tchar\t\tline[NETSCREEN_LINE_LENGTH];\n-\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n-\tgboolean\tcap_dir;\n-\tchar\t\tcap_dst[13];\n \n \t\/* Find the next packet *\/\n \toffset = netscreen_seek_next_packet(wth, err, err_info, line);\n \tif (offset < 0)\n \t\treturn FALSE;\n \n-\t\/* Parse the header *\/\n-\tpkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir,\n-\t    cap_dst, err, err_info);\n-\tif (pkt_len == -1)\n-\t\treturn FALSE;\n-\n-\t\/* Convert the ASCII hex dump to binary data, and fill in some\n-\t   struct wtap_pkthdr fields *\/\n-\tif (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int,\n-\t    cap_dst, &wth->phdr, wth->frame_buffer, err, err_info))\n+\t\/* Parse the header and convert the ASCII hex dump to binary data *\/\n+\tif (!parse_netscreen_packet(wth->fh, &wth->phdr,\n+\t    wth->frame_buffer, line, err, err_info))\n \t\treturn FALSE;\n \n \t\/*\n@@ -239,11 +224,7 @@ netscreen_seek_read(wtap *wth, gint64 seek_off,\n \tstruct wtap_pkthdr *phdr, Buffer *buf,\n \tint *err, gchar **err_info)\n {\n-\tint\t\tpkt_len;\n \tchar\t\tline[NETSCREEN_LINE_LENGTH];\n-\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n-\tgboolean\tcap_dir;\n-\tchar\t\tcap_dst[13];\n \n \tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n \t\treturn FALSE;\n@@ -257,15 +238,8 @@ netscreen_seek_read(wtap *wth, gint64 seek_off,\n \t\treturn FALSE;\n \t}\n \n-\tpkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,\n-\t    cap_dst, err, err_info);\n-\tif (pkt_len == -1)\n-\t\treturn FALSE;\n-\n-\tif (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,\n-\t    cap_dst, phdr, buf, err, err_info))\n-\t\treturn FALSE;\n-\treturn TRUE;\n+\treturn parse_netscreen_packet(wth->random_fh, phdr, buf, line,\n+\t    err, err_info);\n }\n \n \/* Parses a packet record header. There are a few possible formats:\n@@ -285,49 +259,54 @@ netscreen_seek_read(wtap *wth, gint64 seek_off,\n \n \n  *\/\n-static int\n-parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line, char *cap_int,\n-    gboolean *cap_dir, char *cap_dst, int *err, gchar **err_info)\n+static gboolean\n+parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n+    char *line, int *err, gchar **err_info)\n {\n-\tint\tsec;\n-\tint\tdsec, pkt_len;\n-\tchar\tdirection[2];\n-\tchar\tcap_src[13];\n+\tint\t\tsec;\n+\tint\t\tdsec;\n+\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n+\tchar\t\tdirection[2];\n+\tguint\t\tpkt_len;\n+\tchar\t\tcap_src[13];\n+\tchar\t\tcap_dst[13];\n+\tguint8\t\t*pd;\n+\tgchar\t\t*p;\n+\tint\t\tn, i = 0;\n+\tguint\t\toffset = 0;\n+\tgchar\t\tdststr[13];\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n \n-\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9\/:.-](%1[io]) len=%9d:%12s->%12s\/\",\n+\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9\/:.-](%1[io]) len=%9u:%12s->%12s\/\",\n \t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n \t\treturn -1;\n \t}\n+\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n+\t\t\/*\n+\t\t * Probably a corrupt capture file; don't blow up trying\n+\t\t * to allocate space for an immensely-large packet.\n+\t\t *\/\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup_printf(\"netscreen: File has %u-byte packet, bigger than maximum of %u\",\n+\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n+\t\treturn FALSE;\n+\t}\n \n-\t*cap_dir = (direction[0] == 'o' ? NETSCREEN_EGRESS : NETSCREEN_INGRESS);\n+\t\/*\n+\t * If direction[0] is 'o', the direction is NETSCREEN_EGRESS,\n+\t * otherwise it's NETSCREEN_INGRESS.\n+\t *\/\n \n \tphdr->ts.secs  = sec;\n \tphdr->ts.nsecs = dsec * 100000000;\n \tphdr->len = pkt_len;\n \n-\treturn pkt_len;\n-}\n-\n-\/* Converts ASCII hex dump to binary data, and fills in some struct\n-   wtap_pkthdr fields.  Returns TRUE on success and FALSE on any error. *\/\n-static gboolean\n-parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n-    const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,\n-    int *err, gchar **err_info)\n-{\n-\tguint8\t*pd;\n-\tgchar\tline[NETSCREEN_LINE_LENGTH];\n-\tgchar\t*p;\n-\tint\tn, i = 0, offset = 0;\n-\tgchar\tdststr[13];\n-\n \t\/* Make sure we have enough room for the packet *\/\n-\tws_buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);\n+\tws_buffer_assure_space(buf, pkt_len);\n \tpd = ws_buffer_start_ptr(buf);\n \n \twhile(1) {\n@@ -373,7 +352,7 @@ parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n \t\t\/* If there is no more data and the line was not empty,\n \t\t * then there must be an error in the file\n \t\t *\/\n-\t\tif(n == -1) {\n+\t\tif (n == -1) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"netscreen: cannot parse hex-data\");\n \t\t\treturn FALSE;\n@@ -385,7 +364,7 @@ parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,\n \t\t\/* If there was more hex-data than was announced in the len=x\n \t\t * header, then then there must be an error in the file\n \t\t *\/\n-\t\tif(offset > pkt_len) {\n+\t\tif (offset > pkt_len) {\n \t\t\t*err = WTAP_ERR_BAD_FILE;\n \t\t\t*err_info = g_strdup(\"netscreen: too much hex-data\");\n \t\t\treturn FALSE;\ndiff --git a\/wiretap\/netscreen.h b\/wiretap\/netscreen.h\nindex 7609e9f6c1..b3b8413594 100644\n--- a\/wiretap\/netscreen.h\n+++ b\/wiretap\/netscreen.h\n@@ -46,9 +46,6 @@\n #define NETSCREEN_INGRESS\t\tFALSE\n #define NETSCREEN_EGRESS\t\tTRUE\n \n-\n-#define NETSCREEN_MAX_PACKET_LEN\t65536\n-\n wtap_open_return_val netscreen_open(wtap *wth, int *err, gchar **err_info);\n \n #endif\n","owner":"wireshark","repo":"wireshark","source":"cve"},{"CVE_ID":"CVE-2010-2946","CWE_ID":"20","category":"security","commit_id":"aca0fa34bdaba39bfddddba8ca70dba4782e8fe6","commit_message":"From aca0fa34bdaba39bfddddba8ca70dba4782e8fe6 Mon Sep 17 00:00:00 2001\nFrom: Dave Kleikamp <shaggy@linux.vnet.ibm.com>\nDate: Mon, 9 Aug 2010 15:57:38 -0500\nSubject: jfs: don't allow os2 xattr namespace overlap with others\n\nIt's currently possible to bypass xattr namespace access rules by\nprefixing valid xattr names with \"os2.\", since the os2 namespace stores\nextended attributes in a legacy format with no prefix.\n\nThis patch adds checking to deny access to any valid namespace prefix\nfollowing \"os2.\".\n\nSigned-off-by: Dave Kleikamp <shaggy@linux.vnet.ibm.com>\nReported-by: Sergey Vlasov <vsu@altlinux.ru>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/jfs\/xattr.c | 87 +++++++++++++++++++++++++---------------------------------\n 1 file changed, 38 insertions(+), 49 deletions(-)\n\n","diff_code":"diff --git a\/fs\/jfs\/xattr.c b\/fs\/jfs\/xattr.c\nindex fa96bbb26343..2d7f165d0f1d 100644\n--- a\/fs\/jfs\/xattr.c\n+++ b\/fs\/jfs\/xattr.c\n@@ -86,46 +86,25 @@ struct ea_buffer {\n #define EA_MALLOC\t0x0008\n \n \n+static int is_known_namespace(const char *name)\n+{\n+\tif (strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) &&\n+\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n+\t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n+\t    strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n+\t\treturn false;\n+\n+\treturn true;\n+}\n+\n \/*\n  * These three routines are used to recognize on-disk extended attributes\n  * that are in a recognized namespace.  If the attribute is not recognized,\n  * \"os2.\" is prepended to the name\n  *\/\n-static inline int is_os2_xattr(struct jfs_ea *ea)\n+static int is_os2_xattr(struct jfs_ea *ea)\n {\n-\t\/*\n-\t * Check for \"system.\"\n-\t *\/\n-\tif ((ea->namelen >= XATTR_SYSTEM_PREFIX_LEN) &&\n-\t    !strncmp(ea->name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n-\t\treturn false;\n-\t\/*\n-\t * Check for \"user.\"\n-\t *\/\n-\tif ((ea->namelen >= XATTR_USER_PREFIX_LEN) &&\n-\t    !strncmp(ea->name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n-\t\treturn false;\n-\t\/*\n-\t * Check for \"security.\"\n-\t *\/\n-\tif ((ea->namelen >= XATTR_SECURITY_PREFIX_LEN) &&\n-\t    !strncmp(ea->name, XATTR_SECURITY_PREFIX,\n-\t\t     XATTR_SECURITY_PREFIX_LEN))\n-\t\treturn false;\n-\t\/*\n-\t * Check for \"trusted.\"\n-\t *\/\n-\tif ((ea->namelen >= XATTR_TRUSTED_PREFIX_LEN) &&\n-\t    !strncmp(ea->name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))\n-\t\treturn false;\n-\t\/*\n-\t * Add any other valid namespace prefixes here\n-\t *\/\n-\n-\t\/*\n-\t * We assume it's OS\/2's flat namespace\n-\t *\/\n-\treturn true;\n+\treturn !is_known_namespace(ea->name);\n }\n \n static inline int name_size(struct jfs_ea *ea)\n@@ -764,13 +743,23 @@ static int can_set_xattr(struct inode *inode, const char *name,\n \tif (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n \t\treturn can_set_system_xattr(inode, name, value, value_len);\n \n+\tif (!strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN)) {\n+\t\t\/*\n+\t\t * This makes sure that we aren't trying to set an\n+\t\t * attribute in a different namespace by prefixing it\n+\t\t * with \"os2.\"\n+\t\t *\/\n+\t\tif (is_known_namespace(name + XATTR_OS2_PREFIX_LEN))\n+\t\t\t\treturn -EOPNOTSUPP;\n+\t\treturn 0;\n+\t}\n+\n \t\/*\n \t * Don't allow setting an attribute in an unknown namespace.\n \t *\/\n \tif (strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) &&\n \t    strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) &&\n-\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) &&\n-\t    strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN))\n+\t    strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))\n \t\treturn -EOPNOTSUPP;\n \n \treturn 0;\n@@ -952,19 +941,8 @@ ssize_t __jfs_getxattr(struct inode *inode, const char *name, void *data,\n \tint xattr_size;\n \tssize_t size;\n \tint namelen = strlen(name);\n-\tchar *os2name = NULL;\n \tchar *value;\n \n-\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n-\t\tos2name = kmalloc(namelen - XATTR_OS2_PREFIX_LEN + 1,\n-\t\t\t\t  GFP_KERNEL);\n-\t\tif (!os2name)\n-\t\t\treturn -ENOMEM;\n-\t\tstrcpy(os2name, name + XATTR_OS2_PREFIX_LEN);\n-\t\tname = os2name;\n-\t\tnamelen -= XATTR_OS2_PREFIX_LEN;\n-\t}\n-\n \tdown_read(&JFS_IP(inode)->xattr_sem);\n \n \txattr_size = ea_get(inode, &ea_buf, 0);\n@@ -1002,8 +980,6 @@ ssize_t __jfs_getxattr(struct inode *inode, const char *name, void *data,\n       out:\n \tup_read(&JFS_IP(inode)->xattr_sem);\n \n-\tkfree(os2name);\n-\n \treturn size;\n }\n \n@@ -1012,6 +988,19 @@ ssize_t jfs_getxattr(struct dentry *dentry, const char *name, void *data,\n {\n \tint err;\n \n+\tif (strncmp(name, XATTR_OS2_PREFIX, XATTR_OS2_PREFIX_LEN) == 0) {\n+\t\t\/*\n+\t\t * skip past \"os2.\" prefix\n+\t\t *\/\n+\t\tname += XATTR_OS2_PREFIX_LEN;\n+\t\t\/*\n+\t\t * Don't allow retrieving properly prefixed attributes\n+\t\t * by prepending them with \"os2.\"\n+\t\t *\/\n+\t\tif (is_known_namespace(name))\n+\t\t\treturn -EOPNOTSUPP;\n+\t}\n+\n \terr = __jfs_getxattr(dentry->d_inode, name, data, buf_size);\n \n \treturn err;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2011-3637","CWE_ID":"20","category":"security","commit_id":"76597cd31470fa130784c78fadb4dab2e624a723","commit_message":"From 76597cd31470fa130784c78fadb4dab2e624a723 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Sun, 27 Mar 2011 19:09:29 -0700\nSubject: [PATCH] proc: fix oops on invalid \/proc\/<pid>\/maps access\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nWhen m_start returns an error, the seq_file logic will still call m_stop\nwith that error entry, so we'd better make sure that we check it before\nusing it as a vma.\n\nIntroduced by commit ec6fd8a4355c (\"report errors in \/proc\/*\/*map*\nsanely\"), which replaced NULL with various ERR_PTR() cases.\n\n(On ia64, you happen to get a unaligned fault instead of a page fault,\nsince the address used is generally some random error code like -EPERM)\n\nReported-by: Anca Emanuel <anca.emanuel@gmail.com>\nReported-by: Tony Luck <tony.luck@intel.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Am\u00e9rico Wang <xiyou.wangcong@gmail.com>\nCc: Stephen Wilson <wilsons@start.ca>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/proc\/task_mmu.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/proc\/task_mmu.c b\/fs\/proc\/task_mmu.c\nindex 7c708a418acc3..2e7addfd98035 100644\n--- a\/fs\/proc\/task_mmu.c\n+++ b\/fs\/proc\/task_mmu.c\n@@ -182,7 +182,8 @@ static void m_stop(struct seq_file *m, void *v)\n \tstruct proc_maps_private *priv = m->private;\n \tstruct vm_area_struct *vma = v;\n \n-\tvma_stop(priv, vma);\n+\tif (!IS_ERR(vma))\n+\t\tvma_stop(priv, vma);\n \tif (priv->task)\n \t\tput_task_struct(priv->task);\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-7015","CWE_ID":"20","category":"security","commit_id":"880c73cd76109697447fbfbaa8e5ee5683309446","commit_message":"From 880c73cd76109697447fbfbaa8e5ee5683309446 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 20 Aug 2013 23:18:48 +0200\nSubject: [PATCH] avcodec\/flashsv: check diff_start\/height\n\nFixes out of array accesses\nFixes Ticket2844\n\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/flashsv.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/flashsv.c b\/libavcodec\/flashsv.c\nindex 9982b5e9663..f00bf21d472 100644\n--- a\/libavcodec\/flashsv.c\n+++ b\/libavcodec\/flashsv.c\n@@ -387,6 +387,10 @@ static int flashsv_decode_frame(AVCodecContext *avctx, void *data,\n                     }\n                     s->diff_start  = get_bits(&gb, 8);\n                     s->diff_height = get_bits(&gb, 8);\n+                    if (s->diff_start + s->diff_height > cur_blk_height) {\n+                        av_log(avctx, AV_LOG_ERROR, \"Block parameters invalid\\n\");\n+                        return AVERROR_INVALIDDATA;\n+                    }\n                     av_log(avctx, AV_LOG_DEBUG,\n                            \"%dx%d diff start %d height %d\\n\",\n                            i, j, s->diff_start, s->diff_height);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2016-5689","CWE_ID":"20","category":"security","commit_id":"5511ef530576ed18fd636baa3bb4eda3d667665d","commit_message":"From 5511ef530576ed18fd636baa3bb4eda3d667665d Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 30 May 2016 07:51:39 -0400\nSubject: [PATCH] =?UTF-8?q?Add=20additional=20checks=20to=20DCM=20reader?=\n =?UTF-8?q?=20to=20prevent=20data-driven=20faults=20(bug=20report=20from?=\n =?UTF-8?q?=20Hanno=20B=C3=B6ck?=\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\n---\n ChangeLog    |  2 ++\n coders\/dcm.c | 15 +++++++++++----\n 2 files changed, 13 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 70f2d014da..de0b1fa589 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -5,6 +5,8 @@\n     https:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=3&t=29626).\n   * Don't interpret -fx option arguments (reference\n     https:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=3&t=29774);\n+  * Add additional checks to DCM reader to prevent data-driven faults (bug\n+    report from Hanno B\u00f6ck).\n \n 2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\ndiff --git a\/coders\/dcm.c b\/coders\/dcm.c\nindex f86e573265..26125f778b 100644\n--- a\/coders\/dcm.c\n+++ b\/coders\/dcm.c\n@@ -3216,6 +3216,8 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n             \/*\n               Photometric interpretation.\n             *\/\n+            if (data == (unsigned char *) NULL)\n+              break;\n             for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n               photometric[i]=(char) data[i];\n             photometric[i]='\\0';\n@@ -3237,6 +3239,8 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n             \/*\n               Number of frames.\n             *\/\n+            if (data == (unsigned char *) NULL)\n+              break;\n             number_scenes=StringToUnsignedLong((char *) data);\n             break;\n           }\n@@ -3674,7 +3678,7 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n       if (scale == (Quantum *) NULL)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       range=GetQuantumRange(depth);\n-      for (i=0; i < (ssize_t) (GetQuantumRange(depth)+1); i++)\n+      for (i=0; i <= (ssize_t) GetQuantumRange(depth); i++)\n         scale[i]=ScaleAnyToQuantum((size_t) i,range);\n     }\n   if (image->compression == RLECompression)\n@@ -3965,9 +3969,12 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n                 pixel.blue&=mask;\n                 if (scale != (Quantum *) NULL)\n                   {\n-                    pixel.red=scale[pixel.red];\n-                    pixel.green=scale[pixel.green];\n-                    pixel.blue=scale[pixel.blue];\n+                    if (pixel.red <= GetQuantumRange(depth))\n+                      pixel.red=scale[pixel.red];\n+                    if (pixel.green <= GetQuantumRange(depth))\n+                      pixel.green=scale[pixel.green];\n+                    if (pixel.blue <= GetQuantumRange(depth))\n+                      pixel.blue=scale[pixel.blue];\n                   }\n               }\n             SetPixelRed(image,(Quantum) pixel.red,q);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-5691","CWE_ID":"20","category":"security","commit_id":"5511ef530576ed18fd636baa3bb4eda3d667665d","commit_message":"From 5511ef530576ed18fd636baa3bb4eda3d667665d Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 30 May 2016 07:51:39 -0400\nSubject: [PATCH] =?UTF-8?q?Add=20additional=20checks=20to=20DCM=20reader?=\n =?UTF-8?q?=20to=20prevent=20data-driven=20faults=20(bug=20report=20from?=\n =?UTF-8?q?=20Hanno=20B=C3=B6ck?=\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\n---\n ChangeLog    |  2 ++\n coders\/dcm.c | 15 +++++++++++----\n 2 files changed, 13 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 70f2d014da..de0b1fa589 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -5,6 +5,8 @@\n     https:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=3&t=29626).\n   * Don't interpret -fx option arguments (reference\n     https:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=3&t=29774);\n+  * Add additional checks to DCM reader to prevent data-driven faults (bug\n+    report from Hanno B\u00f6ck).\n \n 2016-05-21  7.0.1-6 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 7.0.1-6, GIT revision 18241:d4f277c:20160521.\ndiff --git a\/coders\/dcm.c b\/coders\/dcm.c\nindex f86e573265..26125f778b 100644\n--- a\/coders\/dcm.c\n+++ b\/coders\/dcm.c\n@@ -3216,6 +3216,8 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n             \/*\n               Photometric interpretation.\n             *\/\n+            if (data == (unsigned char *) NULL)\n+              break;\n             for (i=0; i < (ssize_t) MagickMin(length,MagickPathExtent-1); i++)\n               photometric[i]=(char) data[i];\n             photometric[i]='\\0';\n@@ -3237,6 +3239,8 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n             \/*\n               Number of frames.\n             *\/\n+            if (data == (unsigned char *) NULL)\n+              break;\n             number_scenes=StringToUnsignedLong((char *) data);\n             break;\n           }\n@@ -3674,7 +3678,7 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n       if (scale == (Quantum *) NULL)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       range=GetQuantumRange(depth);\n-      for (i=0; i < (ssize_t) (GetQuantumRange(depth)+1); i++)\n+      for (i=0; i <= (ssize_t) GetQuantumRange(depth); i++)\n         scale[i]=ScaleAnyToQuantum((size_t) i,range);\n     }\n   if (image->compression == RLECompression)\n@@ -3965,9 +3969,12 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n                 pixel.blue&=mask;\n                 if (scale != (Quantum *) NULL)\n                   {\n-                    pixel.red=scale[pixel.red];\n-                    pixel.green=scale[pixel.green];\n-                    pixel.blue=scale[pixel.blue];\n+                    if (pixel.red <= GetQuantumRange(depth))\n+                      pixel.red=scale[pixel.red];\n+                    if (pixel.green <= GetQuantumRange(depth))\n+                      pixel.green=scale[pixel.green];\n+                    if (pixel.blue <= GetQuantumRange(depth))\n+                      pixel.blue=scale[pixel.blue];\n                   }\n               }\n             SetPixelRed(image,(Quantum) pixel.red,q);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2015-8217","CWE_ID":"20","category":"security","commit_id":"93f30f825c08477fe8f76be00539e96014cc83c8","commit_message":"From 93f30f825c08477fe8f76be00539e96014cc83c8 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Thu, 5 Nov 2015 14:52:33 +0100\nSubject: [PATCH] avcodec\/hevc_ps: Check chroma_format_idc\n\nFixes out of array access\nFixes: 24d05e8b84676799c735c9e27d97895e\/asan_heap-oob_1b70f6a_2955_7c3652a7f370f9f3ef40642bc2c99bb2.bit\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/hevc_ps.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/hevc_ps.c b\/libavcodec\/hevc_ps.c\nindex 427cf098aa..14f908e8de 100644\n--- a\/libavcodec\/hevc_ps.c\n+++ b\/libavcodec\/hevc_ps.c\n@@ -834,6 +834,10 @@ int ff_hevc_parse_sps(HEVCSPS *sps, GetBitContext *gb, unsigned int *sps_id,\n     }\n \n     sps->chroma_format_idc = get_ue_golomb_long(gb);\n+    if (sps->chroma_format_idc > 3U) {\n+        av_log(avctx, AV_LOG_ERROR, \"chroma_format_idc %d is invalid\\n\", sps->chroma_format_idc);\n+        return AVERROR_INVALIDDATA;\n+    }\n \n     if (sps->chroma_format_idc == 3)\n         sps->separate_colour_plane_flag = get_bits1(gb);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-2624","CWE_ID":"20","category":"security","commit_id":"39a362ae9d9b007473381dba5032f4dfc1744cf2","commit_message":"From 39a362ae9d9b007473381dba5032f4dfc1744cf2 Mon Sep 17 00:00:00 2001\nFrom: Thiemo Nagel <thiemo.nagel@ph.tum.de>\nDate: Sun, 16 Aug 2009 16:48:37 +0200\nSubject: avoid creating an undersized buffer for the hufts table\n\nA malformed input file can cause gzip to crash with a segmentation\nviolation or hang in an endless loop.\nReported in <http:\/\/bugs.debian.org\/507263>.\n* NEWS (Bug fixes): Mention it.\n---\n NEWS      | 2 ++\n inflate.c | 6 ++++--\n 2 files changed, 6 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 0e6918d..428c214 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -6,6 +6,8 @@ GNU gzip NEWS                                    -*- outline -*-\n \n   gzip no longer ignores a close-induced write failure, e.g., on NFS\n \n+  gzip -d no longer segfaults on certain invalid inputs\n+\n \n Major changes in Gzip 1.3.12 (2007-04-13)\n \ndiff --git a\/inflate.c b\/inflate.c\nindex 7dd630a..2f8670d 100644\n--- a\/inflate.c\n+++ b\/inflate.c\n@@ -335,13 +335,15 @@ int *m;                 \/* maximum lookup bits, returns actual *\/\n   } while (--i);\n   if (c[0] == n)                \/* null input--all zero length codes *\/\n   {\n-    q = (struct huft *) malloc (2 * sizeof *q);\n+    q = (struct huft *) malloc (3 * sizeof *q);\n     if (!q)\n       return 3;\n-    hufts += 2;\n+    hufts += 3;\n     q[0].v.t = (struct huft *) NULL;\n     q[1].e = 99;    \/* invalid code marker *\/\n     q[1].b = 1;\n+    q[2].e = 99;    \/* invalid code marker *\/\n+    q[2].b = 1;\n     *t = q + 1;\n     *m = 1;\n     return 0;\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-5589","CWE_ID":"20","category":"security","commit_id":"bf58162ddf970f63502837f366930e44d6a992cf","commit_message":"From bf58162ddf970f63502837f366930e44d6a992cf Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sat, 4 Jul 2015 21:01:50 -0700\nSubject: [PATCH] Fix bug #69958 - Segfault in Phar::convertToData on invalid\n file\n\n---\n ext\/phar\/phar_object.c       |  70 ++++++++++++++++++++++---------------------\n ext\/phar\/tests\/bug69958.phpt |  14 +++++++++\n ext\/phar\/tests\/bug69958.tar  | Bin 0 -> 513 bytes\n 3 files changed, 50 insertions(+), 34 deletions(-)\n create mode 100644 ext\/phar\/tests\/bug69958.phpt\n create mode 100644 ext\/phar\/tests\/bug69958.tar\n\n","diff_code":"diff --git a\/ext\/phar\/phar_object.c b\/ext\/phar\/phar_object.c\nindex add1fa0..1184863 100644\n--- a\/ext\/phar\/phar_object.c\n+++ b\/ext\/phar\/phar_object.c\n@@ -1269,7 +1269,7 @@ PHP_METHOD(Phar, __construct)\n \tINIT_PZVAL(&arg2);\n \tZVAL_LONG(&arg2, flags);\n \n-\tzend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj), \n+\tzend_call_method_with_2_params(&zobj, Z_OBJCE_P(zobj),\n \t\t&spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg1, &arg2);\n \n \tif (!phar_data->is_persistent) {\n@@ -1293,7 +1293,7 @@ PHP_METHOD(Phar, getSupportedSignatures)\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tarray_init(return_value);\n \n \tadd_next_index_stringl(return_value, \"MD5\", 3, 1);\n@@ -1320,7 +1320,7 @@ PHP_METHOD(Phar, getSupportedCompression)\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tarray_init(return_value);\n \tphar_request_initialize(TSRMLS_C);\n \n@@ -1608,7 +1608,7 @@ phar_spl_fileinfo:\n \t\t\t}\n \t\t\treturn ZEND_HASH_APPLY_STOP;\n \t\t}\n-\t\t\n+\n \t\tbase = temp;\n \t\tbase_len = strlen(base);\n \n@@ -1805,7 +1805,7 @@ after_open_fp:\n \/* {{{ proto array Phar::buildFromDirectory(string base_dir[, string regex])\n  * Construct a phar archive from an existing directory, recursively.\n  * Optional second parameter is a regular expression for filtering directory contents.\n- * \n+ *\n  * Return value is an array mapping phar index to actual files added.\n  *\/\n PHP_METHOD(Phar, buildFromDirectory)\n@@ -1845,7 +1845,7 @@ PHP_METHOD(Phar, buildFromDirectory)\n \tZVAL_LONG(&arg2, SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS);\n #endif\n \n-\tzend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator, \n+\tzend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator,\n \t\t\t&spl_ce_RecursiveDirectoryIterator->constructor, \"__construct\", NULL, &arg, &arg2);\n \n \tif (EG(exception)) {\n@@ -1862,7 +1862,7 @@ PHP_METHOD(Phar, buildFromDirectory)\n \t\tRETURN_FALSE;\n \t}\n \n-\tzend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator, \n+\tzend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator,\n \t\t\t&spl_ce_RecursiveIteratorIterator->constructor, \"__construct\", NULL, iter);\n \n \tif (EG(exception)) {\n@@ -1887,7 +1887,7 @@ PHP_METHOD(Phar, buildFromDirectory)\n \t\tINIT_PZVAL(&arg2);\n \t\tZVAL_STRINGL(&arg2, regex, regex_len, 0);\n \n-\t\tzend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator, \n+\t\tzend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator,\n \t\t\t&spl_ce_RegexIterator->constructor, \"__construct\", NULL, iteriter, &arg2);\n \t}\n \n@@ -2008,7 +2008,7 @@ PHP_METHOD(Phar, buildFromIterator)\n PHP_METHOD(Phar, count)\n {\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2173,7 +2173,7 @@ static zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool c\n \tspprintf(&newname, 0, \"%s.%s\", strtok(basename, \".\"), ext);\n \tefree(basename);\n \n-\t\n+\n \n \tbasepath = estrndup(oldpath, (strlen(oldpath) - oldname_len));\n \tphar->fname_len = spprintf(&newpath, 0, \"%s%s\", basepath, newname);\n@@ -2419,7 +2419,9 @@ no_copy:\n \t\tzend_hash_destroy(&(phar->manifest));\n \t\tzend_hash_destroy(&(phar->mounted_dirs));\n \t\tzend_hash_destroy(&(phar->virtual_dirs));\n-\t\tphp_stream_close(phar->fp);\n+\t\tif (phar->fp) {\n+\t\t\tphp_stream_close(phar->fp);\n+\t\t}\n \t\tefree(phar->fname);\n \t\tefree(phar);\n \t\treturn NULL;\n@@ -2639,7 +2641,7 @@ PHP_METHOD(Phar, convertToData)\n PHP_METHOD(Phar, isCompressed)\n {\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2663,7 +2665,7 @@ PHP_METHOD(Phar, isWritable)\n {\n \tphp_stream_statbuf ssb;\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2741,7 +2743,7 @@ PHP_METHOD(Phar, delete)\n PHP_METHOD(Phar, getAlias)\n {\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2758,7 +2760,7 @@ PHP_METHOD(Phar, getAlias)\n PHP_METHOD(Phar, getPath)\n {\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2874,7 +2876,7 @@ valid_alias:\n PHP_METHOD(Phar, getVersion)\n {\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2889,7 +2891,7 @@ PHP_METHOD(Phar, getVersion)\n PHP_METHOD(Phar, startBuffering)\n {\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2904,7 +2906,7 @@ PHP_METHOD(Phar, startBuffering)\n PHP_METHOD(Phar, isBuffering)\n {\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -2921,7 +2923,7 @@ PHP_METHOD(Phar, stopBuffering)\n \tchar *error;\n \n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -3156,7 +3158,7 @@ PHP_METHOD(Phar, setSignatureAlgorithm)\n PHP_METHOD(Phar, getSignature)\n {\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -3200,7 +3202,7 @@ PHP_METHOD(Phar, getSignature)\n PHP_METHOD(Phar, getModified)\n {\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -3462,7 +3464,7 @@ PHP_METHOD(Phar, decompressFiles)\n {\n \tchar *error;\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -3983,7 +3985,7 @@ PHP_METHOD(Phar, getStub)\n \tphar_entry_info *stub;\n \n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -4086,7 +4088,7 @@ PHP_METHOD(Phar, hasMetadata)\n PHP_METHOD(Phar, getMetadata)\n {\n \tPHAR_ARCHIVE_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -4544,7 +4546,7 @@ PHP_METHOD(PharFileInfo, __construct)\n \tINIT_PZVAL(&arg1);\n \tZVAL_STRINGL(&arg1, fname, fname_len, 0);\n \n-\tzend_call_method_with_1_params(&zobj, Z_OBJCE_P(zobj), \n+\tzend_call_method_with_1_params(&zobj, Z_OBJCE_P(zobj),\n \t\t&spl_ce_SplFileInfo->constructor, \"__construct\", NULL, &arg1);\n }\n \/* }}} *\/\n@@ -4582,7 +4584,7 @@ PHP_METHOD(PharFileInfo, __destruct)\n PHP_METHOD(PharFileInfo, getCompressedSize)\n {\n \tPHAR_ENTRY_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -4624,7 +4626,7 @@ PHP_METHOD(PharFileInfo, isCompressed)\n PHP_METHOD(PharFileInfo, getCRC32)\n {\n \tPHAR_ENTRY_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -4650,7 +4652,7 @@ PHP_METHOD(PharFileInfo, getCRC32)\n PHP_METHOD(PharFileInfo, isCRCChecked)\n {\n \tPHAR_ENTRY_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -4665,7 +4667,7 @@ PHP_METHOD(PharFileInfo, isCRCChecked)\n PHP_METHOD(PharFileInfo, getPharFlags)\n {\n \tPHAR_ENTRY_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -4743,7 +4745,7 @@ PHP_METHOD(PharFileInfo, chmod)\n PHP_METHOD(PharFileInfo, hasMetadata)\n {\n \tPHAR_ENTRY_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -4758,7 +4760,7 @@ PHP_METHOD(PharFileInfo, hasMetadata)\n PHP_METHOD(PharFileInfo, getMetadata)\n {\n \tPHAR_ENTRY_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -4839,7 +4841,7 @@ PHP_METHOD(PharFileInfo, delMetadata)\n \tchar *error;\n \n \tPHAR_ENTRY_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -4897,7 +4899,7 @@ PHP_METHOD(PharFileInfo, getContent)\n \tphar_entry_info *link;\n \n \tPHAR_ENTRY_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n@@ -5071,7 +5073,7 @@ PHP_METHOD(PharFileInfo, decompress)\n {\n \tchar *error;\n \tPHAR_ENTRY_OBJECT();\n-\t\n+\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\ndiff --git a\/ext\/phar\/tests\/bug69958.phpt b\/ext\/phar\/tests\/bug69958.phpt\nnew file mode 100644\nindex 0000000..d63b413\n--- \/dev\/null\n+++ b\/ext\/phar\/tests\/bug69958.phpt\n@@ -0,0 +1,14 @@\n+--TEST--\n+Phar: bug #69958: Segfault in Phar::convertToData on invalid file\n+--SKIPIF--\n+<?php if (!extension_loaded(\"phar\")) die(\"skip\"); ?>\n+--FILE--\n+<?php\n+$tarphar = new PharData(__DIR__.'\/bug69958.tar');\n+$phar = $tarphar->convertToData(Phar::TAR); \n+--EXPECTF--\n+Fatal error: Uncaught exception 'BadMethodCallException' with message 'phar \"%s\/bug69958.tar\" exists and must be unlinked prior to conversion' in %s\/bug69958.php:%d\n+Stack trace:\n+#0 %s\/bug69958.php(%d): PharData->convertToData(%d)\n+#1 {main}\n+  thrown in %s\/bug69958.php on line %d\ndiff --git a\/ext\/phar\/tests\/bug69958.tar b\/ext\/phar\/tests\/bug69958.tar\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..02275248bd08524f937a67e851f02ee38148e7f0\nGIT binary patch\nliteral 513\nNcmZQz7zHCb1ONg700961\n\nliteral 0\nHcmV?d00001\n\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-2140","CWE_ID":"20","category":"security","commit_id":"604c499cbbcc3d5fe5fb8d53306aa0fae1990109","commit_message":"From 604c499cbbcc3d5fe5fb8d53306aa0fae1990109 Mon Sep 17 00:00:00 2001\nFrom: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nDate: Wed, 16 Jan 2013 11:33:52 -0500\nSubject: [PATCH] xen\/blkback: Check device permissions before allowing\n OP_DISCARD\n\nWe need to make sure that the device is not RO or that\nthe request is not past the number of sectors we want to\nissue the DISCARD operation for.\n\nThis fixes CVE-2013-2140.\n\nCc: stable@vger.kernel.org\nAcked-by: Jan Beulich <JBeulich@suse.com>\nAcked-by: Ian Campbell <Ian.Campbell@citrix.com>\n[v1: Made it pr_warn instead of pr_debug]\nSigned-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\n---\n drivers\/block\/xen-blkback\/blkback.c | 13 ++++++++++++-\n 1 file changed, 12 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/block\/xen-blkback\/blkback.c b\/drivers\/block\/xen-blkback\/blkback.c\nindex e79ab45592332..4119bcdefd1af 100644\n--- a\/drivers\/block\/xen-blkback\/blkback.c\n+++ b\/drivers\/block\/xen-blkback\/blkback.c\n@@ -876,7 +876,18 @@ static int dispatch_discard_io(struct xen_blkif *blkif,\n \tint status = BLKIF_RSP_OKAY;\n \tstruct block_device *bdev = blkif->vbd.bdev;\n \tunsigned long secure;\n+\tstruct phys_req preq;\n+\n+\tpreq.sector_number = req->u.discard.sector_number;\n+\tpreq.nr_sects      = req->u.discard.nr_sectors;\n \n+\terr = xen_vbd_translate(&preq, blkif, WRITE);\n+\tif (err) {\n+\t\tpr_warn(DRV_PFX \"access denied: DISCARD [%llu->%llu] on dev=%04x\\n\",\n+\t\t\tpreq.sector_number,\n+\t\t\tpreq.sector_number + preq.nr_sects, blkif->vbd.pdevice);\n+\t\tgoto fail_response;\n+\t}\n \tblkif->st_ds_req++;\n \n \txen_blkif_get(blkif);\n@@ -887,7 +898,7 @@ static int dispatch_discard_io(struct xen_blkif *blkif,\n \terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n \t\t\t\t   req->u.discard.nr_sectors,\n \t\t\t\t   GFP_KERNEL, secure);\n-\n+fail_response:\n \tif (err == -EOPNOTSUPP) {\n \t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n \t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0547","CWE_ID":"20","category":"security","commit_id":"a065c177dfc8f968775593ba00dffafeebb2e054","commit_message":"From a065c177dfc8f968775593ba00dffafeebb2e054 Mon Sep 17 00:00:00 2001\nFrom: Jeff Layton <jlayton@redhat.com>\nDate: Tue, 26 Jan 2010 08:15:41 -0500\nSubject: [PATCH] mount.cifs: check for invalid characters in device name and\n mountpoint\n\nIt's apparently possible to corrupt the mtab if you pass embedded\nnewlines to addmntent. Apparently tabs are also a problem with certain\nearlier glibc versions. Backslashes are also a minor issue apparently,\nbut we can't reasonably filter those.\n\nMake sure that neither the devname or mountpoint contain any problematic\ncharacters before allowing the mount to proceed.\n\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\n---\n client\/mount.cifs.c | 34 ++++++++++++++++++++++++++++++++++\n 1 file changed, 34 insertions(+)\n\n","diff_code":"diff --git a\/client\/mount.cifs.c b\/client\/mount.cifs.c\nindex f30418bfc26..96f0c1c834f 100644\n--- a\/client\/mount.cifs.c\n+++ b\/client\/mount.cifs.c\n@@ -1164,6 +1164,36 @@ static void print_cifs_mount_version(void)\n \t\tMOUNT_CIFS_VENDOR_SUFFIX);\n }\n \n+\/*\n+ * This function borrowed from fuse-utils...\n+ *\n+ * glibc's addmntent (at least as of 2.10 or so) doesn't properly encode\n+ * newlines embedded within the text fields. To make sure no one corrupts\n+ * the mtab, fail the mount if there are embedded newlines.\n+ *\/\n+static int check_newline(const char *progname, const char *name)\n+{\n+    char *s;\n+    for (s = \"\\n\"; *s; s++) {\n+        if (strchr(name, *s)) {\n+            fprintf(stderr, \"%s: illegal character 0x%02x in mount entry\\n\",\n+                    progname, *s);\n+            return EX_USAGE;\n+        }\n+    }\n+    return 0;\n+}\n+\n+static int check_mtab(const char *progname, const char *devname,\n+\t\t\tconst char *dir)\n+{\n+\tif (check_newline(progname, devname) == -1 ||\n+\t    check_newline(progname, dir) == -1)\n+\t\treturn EX_USAGE;\n+\treturn 0;\n+}\n+\n+\n int main(int argc, char ** argv)\n {\n \tint c;\n@@ -1607,6 +1637,10 @@ mount_retry:\n \tif (verboseflag)\n \t\tfprintf(stderr, \"\\n\");\n \n+\trc = check_mtab(thisprogram, dev_name, mountpoint);\n+\tif (rc)\n+\t\tgoto mount_exit;\n+\n \tif (!fakemnt && mount(dev_name, \".\", cifs_fstype, flags, options)) {\n \t\tswitch (errno) {\n \t\tcase ECONNREFUSED:\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-3936","CWE_ID":"20","category":"security","commit_id":"635bcfccd439480003b74a665b5aa7c872c1ad6b","commit_message":"From 635bcfccd439480003b74a665b5aa7c872c1ad6b Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 24 Jan 2012 17:48:23 +0100\nSubject: [PATCH] dv: check stype\n\ndv: check stype\n\nFixes part1 of CVE-2011-3929\nPossibly fixes part of CVE-2011-3936\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nReviewed-by: Roman Shaposhnik <roman@shaposhnik.org>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\nSigned-off-by: Alex Converse <alex.converse@gmail.com>\n---\n libavformat\/dv.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/libavformat\/dv.c b\/libavformat\/dv.c\nindex 4106dfd..c90ddec 100644\n--- a\/libavformat\/dv.c\n+++ b\/libavformat\/dv.c\n@@ -204,6 +204,12 @@ static int dv_extract_audio_info(DVDemuxContext* c, uint8_t* frame)\n     stype = (as_pack[3] & 0x1f);      \/* 0 - 2CH, 2 - 4CH, 3 - 8CH *\/\n     quant =  as_pack[4] & 0x07;       \/* 0 - 16bit linear, 1 - 12bit nonlinear *\/\n \n+    if (stype > 3) {\n+        av_log(c->fctx, AV_LOG_ERROR, \"stype %d is invalid\\n\", stype);\n+        c->ach = 0;\n+        return 0;\n+    }\n+\n     \/* note: ach counts PAIRS of channels (i.e. stereo channels) *\/\n     ach = ((int[4]){  1,  0,  2,  4})[stype];\n     if (ach == 1 && quant && freq == 2)\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10061","CWE_ID":"20","category":"security","commit_id":"4e914bbe371433f0590cefdf3bd5f3a5710069f9","commit_message":"From 4e914bbe371433f0590cefdf3bd5f3a5710069f9 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 3 Jun 2016 20:18:07 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/196\n\n---\n coders\/tiff.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/tiff.c b\/coders\/tiff.c\nindex d051e1e666..fa589d94f6 100644\n--- a\/coders\/tiff.c\n+++ b\/coders\/tiff.c\n@@ -390,8 +390,10 @@ static Image *ReadGROUP4Image(const ImageInfo *image_info,\n   length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n   length=WriteLSBLong(file,(long) image->resolution.x);\n   length=WriteLSBLong(file,1);\n+  status=MagickTrue;\n   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n-    (void) fputc(c,file);\n+    if (fputc(c,file) != c)\n+      status=MagickFalse;\n   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n   length=WriteLSBLong(file,(unsigned int) length);\n   (void) fclose(file);\n@@ -413,6 +415,8 @@ static Image *ReadGROUP4Image(const ImageInfo *image_info,\n       (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n     }\n   (void) RelinquishUniqueFileResource(filename);\n+  if (status == MagickFalse)\n+    image=DestroyImage(image);\n   return(image);\n }\n #endif\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2014-0077","CWE_ID":"20","category":"security","commit_id":"d8316f3991d207fe32881a9ac20241be8fa2bad0","commit_message":"From d8316f3991d207fe32881a9ac20241be8fa2bad0 Mon Sep 17 00:00:00 2001\nFrom: \"Michael S. Tsirkin\" <mst@redhat.com>\nDate: Thu, 27 Mar 2014 12:00:26 +0200\nSubject: [PATCH] vhost: fix total length when packets are too short\n\nWhen mergeable buffers are disabled, and the\nincoming packet is too large for the rx buffer,\nget_rx_bufs returns success.\n\nThis was intentional in order for make recvmsg\ntruncate the packet and then handle_rx would\ndetect err != sock_len and drop it.\n\nUnfortunately we pass the original sock_len to\nrecvmsg - which means we use parts of iov not fully\nvalidated.\n\nFix this up by detecting this overrun and doing packet drop\nimmediately.\n\nCVE-2014-0077\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/vhost\/net.c | 14 ++++++++++++++\n 1 file changed, 14 insertions(+)\n\n","diff_code":"diff --git a\/drivers\/vhost\/net.c b\/drivers\/vhost\/net.c\nindex a0fa5de210cf5..026be580d3184 100644\n--- a\/drivers\/vhost\/net.c\n+++ b\/drivers\/vhost\/net.c\n@@ -532,6 +532,12 @@ static int get_rx_bufs(struct vhost_virtqueue *vq,\n \t*iovcount = seg;\n \tif (unlikely(log))\n \t\t*log_num = nlogs;\n+\n+\t\/* Detect overrun *\/\n+\tif (unlikely(datalen > 0)) {\n+\t\tr = UIO_MAXIOV + 1;\n+\t\tgoto err;\n+\t}\n \treturn headcount;\n err:\n \tvhost_discard_vq_desc(vq, headcount);\n@@ -587,6 +593,14 @@ static void handle_rx(struct vhost_net *net)\n \t\t\/* On error, stop handling until the next kick. *\/\n \t\tif (unlikely(headcount < 0))\n \t\t\tbreak;\n+\t\t\/* On overrun, truncate and discard *\/\n+\t\tif (unlikely(headcount > UIO_MAXIOV)) {\n+\t\t\tmsg.msg_iovlen = 1;\n+\t\t\terr = sock->ops->recvmsg(NULL, sock, &msg,\n+\t\t\t\t\t\t 1, MSG_DONTWAIT | MSG_TRUNC);\n+\t\t\tpr_debug(\"Discarded rx packet: len %zd\\n\", sock_len);\n+\t\t\tcontinue;\n+\t\t}\n \t\t\/* OK, now we need to know about added descriptors. *\/\n \t\tif (!headcount) {\n \t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-7872","CWE_ID":"20","category":"security","commit_id":"f05819df10d7b09f6d1eb6f8534a8f68e5a4fe61","commit_message":"From f05819df10d7b09f6d1eb6f8534a8f68e5a4fe61 Mon Sep 17 00:00:00 2001\nFrom: David Howells <dhowells@redhat.com>\nDate: Thu, 15 Oct 2015 17:21:37 +0100\nSubject: KEYS: Fix crash when attempt to garbage collect an uninstantiated\n keyring\n\nThe following sequence of commands:\n\n    i=`keyctl add user a a @s`\n    keyctl request2 keyring foo bar @t\n    keyctl unlink $i @s\n\ntries to invoke an upcall to instantiate a keyring if one doesn't already\nexist by that name within the user's keyring set.  However, if the upcall\nfails, the code sets keyring->type_data.reject_error to -ENOKEY or some\nother error code.  When the key is garbage collected, the key destroy\nfunction is called unconditionally and keyring_destroy() uses list_empty()\non keyring->type_data.link - which is in a union with reject_error.\nSubsequently, the kernel tries to unlink the keyring from the keyring names\nlist - which oopses like this:\n\n\tBUG: unable to handle kernel paging request at 00000000ffffff8a\n\tIP: [<ffffffff8126e051>] keyring_destroy+0x3d\/0x88\n\t...\n\tWorkqueue: events key_garbage_collector\n\t...\n\tRIP: 0010:[<ffffffff8126e051>] keyring_destroy+0x3d\/0x88\n\tRSP: 0018:ffff88003e2f3d30  EFLAGS: 00010203\n\tRAX: 00000000ffffff82 RBX: ffff88003bf1a900 RCX: 0000000000000000\n\tRDX: 0000000000000000 RSI: 000000003bfc6901 RDI: ffffffff81a73a40\n\tRBP: ffff88003e2f3d38 R08: 0000000000000152 R09: 0000000000000000\n\tR10: ffff88003e2f3c18 R11: 000000000000865b R12: ffff88003bf1a900\n\tR13: 0000000000000000 R14: ffff88003bf1a908 R15: ffff88003e2f4000\n\t...\n\tCR2: 00000000ffffff8a CR3: 000000003e3ec000 CR4: 00000000000006f0\n\t...\n\tCall Trace:\n\t [<ffffffff8126c756>] key_gc_unused_keys.constprop.1+0x5d\/0x10f\n\t [<ffffffff8126ca71>] key_garbage_collector+0x1fa\/0x351\n\t [<ffffffff8105ec9b>] process_one_work+0x28e\/0x547\n\t [<ffffffff8105fd17>] worker_thread+0x26e\/0x361\n\t [<ffffffff8105faa9>] ? rescuer_thread+0x2a8\/0x2a8\n\t [<ffffffff810648ad>] kthread+0xf3\/0xfb\n\t [<ffffffff810647ba>] ? kthread_create_on_node+0x1c2\/0x1c2\n\t [<ffffffff815f2ccf>] ret_from_fork+0x3f\/0x70\n\t [<ffffffff810647ba>] ? kthread_create_on_node+0x1c2\/0x1c2\n\nNote the value in RAX.  This is a 32-bit representation of -ENOKEY.\n\nThe solution is to only call ->destroy() if the key was successfully\ninstantiated.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nTested-by: Dmitry Vyukov <dvyukov@google.com>\n---\n security\/keys\/gc.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/security\/keys\/gc.c b\/security\/keys\/gc.c\nindex 39eac1fd5706..addf060399e0 100644\n--- a\/security\/keys\/gc.c\n+++ b\/security\/keys\/gc.c\n@@ -134,8 +134,10 @@ static noinline void key_gc_unused_keys(struct list_head *keys)\n \t\tkdebug(\"- %u\", key->serial);\n \t\tkey_check(key);\n \n-\t\t\/* Throw away the key data *\/\n-\t\tif (key->type->destroy)\n+\t\t\/* Throw away the key data if the key is instantiated *\/\n+\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n+\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n+\t\t    key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n \t\tsecurity_key_free(key);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-1915","CWE_ID":"20","category":"security","commit_id":"d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe","commit_message":"From d4d80b38aa85eccb26e3c61b04d16e8ca5de76fe Mon Sep 17 00:00:00 2001\nFrom: Breno Silva <breno.silva@gmail.com>\nDate: Mon, 4 Mar 2013 16:54:20 -0400\nSubject: [PATCH] Added SecXmlExternalEntity\n\n---\n apache2\/apache2_config.c | 48 ++++++++++++++++++++++++++++++++++++++--\n apache2\/modsecurity.h    |  3 +++\n apache2\/msc_xml.c        | 11 +++++++++\n 3 files changed, 60 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/apache2\/apache2_config.c b\/apache2\/apache2_config.c\nindex 7437ffbdc..188af59cb 100644\n--- a\/apache2\/apache2_config.c\n+++ b\/apache2\/apache2_config.c\n@@ -156,6 +156,9 @@ void *create_directory_config(apr_pool_t *mp, char *path)\n     dcfg->crypto_hash_framesrc_pm = NOT_SET;\n \n \n+    \/* xml external entity *\/\n+    dcfg->xml_external_entity = NOT_SET;\n+\n     return dcfg;\n }\n \n@@ -591,6 +594,10 @@ void *merge_directory_configs(apr_pool_t *mp, void *_parent, void *_child)\n     merged->crypto_hash_framesrc_pm = (child->crypto_hash_framesrc_pm == NOT_SET\n         ? parent->crypto_hash_framesrc_pm : child->crypto_hash_framesrc_pm);\n \n+    \/* xml external entity *\/\n+    merged->xml_external_entity = (child->xml_external_entity == NOT_SET\n+        ? parent->xml_external_entity : child->xml_external_entity);\n+\n     return merged;\n }\n \n@@ -711,6 +718,9 @@ void init_directory_config(directory_config *dcfg)\n     if (dcfg->crypto_hash_iframesrc_pm == NOT_SET) dcfg->crypto_hash_iframesrc_pm = 0;\n     if (dcfg->crypto_hash_framesrc_pm == NOT_SET) dcfg->crypto_hash_framesrc_pm = 0;\n \n+    \/* xml external entity *\/\n+    if (dcfg->xml_external_entity == NOT_SET) dcfg->xml_external_entity = 0;\n+\n }\n \n \/**\n@@ -2282,9 +2292,35 @@ static const char *cmd_sensor_id(cmd_parms *cmd, void *_dcfg, const char *p1)\n     return NULL;\n }\n \n+\/**\n+* \\brief Add SecXmlExternalEntity configuration option\n+*\n+* \\param cmd Pointer to configuration data\n+* \\param _dcfg Pointer to directory configuration\n+* \\param p1 Pointer to configuration option\n+*\n+* \\retval NULL On failure\n+* \\retval apr_psprintf On Success\n+*\/\n+static const char *cmd_xml_external_entity(cmd_parms *cmd, void *_dcfg, const char *p1)\n+{\n+    directory_config *dcfg = (directory_config *)_dcfg;\n+    if (dcfg == NULL) return NULL;\n+\n+    if (strcasecmp(p1, \"on\") == 0)  {\n+        dcfg->xml_external_entity = 1;\n+    }\n+    else if (strcasecmp(p1, \"off\") == 0)    {\n+        dcfg->xml_external_entity = 0;\n+    }\n+    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecXmlExternalEntity: %s\", p1);\n+\n+    return NULL;\n+}\n+\n \n \/**\n-* \\brief Add SecHash configuration option\n+* \\brief Add SecHashEngine configuration option\n *\n * \\param cmd Pointer to configuration data\n * \\param _dcfg Pointer to directory configuration\n@@ -2306,7 +2342,7 @@ static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n         dcfg->hash_is_enabled = HASH_DISABLED;\n         dcfg->hash_enforcement = HASH_DISABLED;\n     }\n-    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n+    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SexHashEngine: %s\", p1);\n \n     return NULL;\n }\n@@ -3223,6 +3259,14 @@ const command_rec module_directives[] = {\n         \"On or Off\"\n     ),\n \n+    AP_INIT_TAKE1 (\n+        \"SecXmlExternalEntity\",\n+        cmd_xml_external_entity,\n+        NULL,\n+        CMD_SCOPE_ANY,\n+        \"On or Off\"\n+    ),\n+\n     AP_INIT_FLAG (\n         \"SecRuleInheritance\",\n         cmd_rule_inheritance,\ndiff --git a\/apache2\/modsecurity.h b\/apache2\/modsecurity.h\nindex 3f210b753..cb1a8d188 100644\n--- a\/apache2\/modsecurity.h\n+++ b\/apache2\/modsecurity.h\n@@ -595,6 +595,9 @@ struct directory_config {\n     int                 crypto_hash_location_pm;\n     int                 crypto_hash_iframesrc_pm;\n     int                 crypto_hash_framesrc_pm;\n+\n+    \/* xml *\/\n+    int                 xml_external_entity;\n };\n \n struct error_message_t {\ndiff --git a\/apache2\/msc_xml.c b\/apache2\/msc_xml.c\nindex d9cb09cc8..87ab967e7 100644\n--- a\/apache2\/msc_xml.c\n+++ b\/apache2\/msc_xml.c\n@@ -14,17 +14,28 @@\n \n #include \"msc_xml.h\"\n \n+static xmlParserInputBufferPtr\n+xml_unload_external_entity(const char *URI, xmlCharEncoding enc)    {\n+    return NULL;\n+}\n+\n \n \/**\n  * Initialise XML parser.\n  *\/\n int xml_init(modsec_rec *msr, char **error_msg) {\n+    xmlParserInputBufferCreateFilenameFunc entity;\n+\n     if (error_msg == NULL) return -1;\n     *error_msg = NULL;\n \n     msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n     if (msr->xml == NULL) return -1;\n \n+    if(msr->txcfg->xml_external_entity == 0)    {\n+        entity = xmlParserInputBufferCreateFilenameDefault(xml_unload_external_entity);\n+    }\n+\n     return 1;\n }\n \n","owner":"SpiderLabs","repo":"ModSecurity","source":"cve"},{"CVE_ID":"CVE-2017-12187","CWE_ID":"20","category":"security","commit_id":"cad5a1050b7184d828aef9c1dd151c3ab649d37e","commit_message":"From cad5a1050b7184d828aef9c1dd151c3ab649d37e Mon Sep 17 00:00:00 2001\nFrom: Nathan Kidd <nkidd@opentext.com>\nDate: Fri, 9 Jan 2015 09:57:23 -0500\nSubject: Unvalidated lengths\n\nv2: Add overflow check and remove unnecessary check (Julien Cristau)\n\nThis addresses:\nCVE-2017-12184 in XINERAMA\nCVE-2017-12185 in MIT-SCREEN-SAVER\nCVE-2017-12186 in X-Resource\nCVE-2017-12187 in RENDER\n\nReviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Nathan Kidd <nkidd@opentext.com>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n Xext\/panoramiX.c          | 3 ++-\n Xext\/saver.c              | 2 ++\n Xext\/xres.c               | 4 +++-\n Xext\/xvdisp.c             | 4 +++-\n hw\/dmx\/dmxpict.c          | 2 ++\n pseudoramiX\/pseudoramiX.c | 3 ++-\n render\/render.c           | 3 +++\n 7 files changed, 17 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/Xext\/panoramiX.c b\/Xext\/panoramiX.c\nindex 209df29..844ea49 100644\n--- a\/Xext\/panoramiX.c\n+++ b\/Xext\/panoramiX.c\n@@ -988,10 +988,11 @@ ProcPanoramiXGetScreenSize(ClientPtr client)\n     xPanoramiXGetScreenSizeReply rep;\n     int rc;\n \n+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n+\n     if (stuff->screen >= PanoramiXNumScreens)\n         return BadMatch;\n \n-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n     rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n     if (rc != Success)\n         return rc;\ndiff --git a\/Xext\/saver.c b\/Xext\/saver.c\nindex 0949761..f6090d8 100644\n--- a\/Xext\/saver.c\n+++ b\/Xext\/saver.c\n@@ -1186,6 +1186,8 @@ ProcScreenSaverUnsetAttributes(ClientPtr client)\n         PanoramiXRes *draw;\n         int rc, i;\n \n+        REQUEST_SIZE_MATCH(xScreenSaverUnsetAttributesReq);\n+\n         rc = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n         if (rc != Success)\ndiff --git a\/Xext\/xres.c b\/Xext\/xres.c\nindex 21239f5..0242158 100644\n--- a\/Xext\/xres.c\n+++ b\/Xext\/xres.c\n@@ -947,6 +947,8 @@ ProcXResQueryResourceBytes (ClientPtr client)\n     ConstructResourceBytesCtx    ctx;\n \n     REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);\n+    if (stuff->numSpecs > UINT32_MAX \/ sizeof(ctx.specs[0]))\n+        return BadLength;\n     REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,\n                        stuff->numSpecs * sizeof(ctx.specs[0]));\n \n@@ -1052,8 +1054,8 @@ SProcXResQueryResourceBytes (ClientPtr client)\n     int c;\n     xXResResourceIdSpec *specs = (void*) ((char*) stuff + sizeof(*stuff));\n \n-    swapl(&stuff->numSpecs);\n     REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);\n+    swapl(&stuff->numSpecs);\n     REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,\n                        stuff->numSpecs * sizeof(specs[0]));\n \ndiff --git a\/Xext\/xvdisp.c b\/Xext\/xvdisp.c\nindex d99d3d4..5232b37 100644\n--- a\/Xext\/xvdisp.c\n+++ b\/Xext\/xvdisp.c\n@@ -1493,12 +1493,14 @@ XineramaXvShmPutImage(ClientPtr client)\n {\n     REQUEST(xvShmPutImageReq);\n     PanoramiXRes *draw, *gc, *port;\n-    Bool send_event = stuff->send_event;\n+    Bool send_event;\n     Bool isRoot;\n     int result, i, x, y;\n \n     REQUEST_SIZE_MATCH(xvShmPutImageReq);\n \n+    send_event = stuff->send_event;\n+\n     result = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n     if (result != Success)\ndiff --git a\/hw\/dmx\/dmxpict.c b\/hw\/dmx\/dmxpict.c\nindex 1f1022e..63caec9 100644\n--- a\/hw\/dmx\/dmxpict.c\n+++ b\/hw\/dmx\/dmxpict.c\n@@ -716,6 +716,8 @@ dmxProcRenderSetPictureFilter(ClientPtr client)\n         filter = (char *) (stuff + 1);\n         params = (XFixed *) (filter + ((stuff->nbytes + 3) & ~3));\n         nparams = ((XFixed *) stuff + client->req_len) - params;\n+        if (nparams < 0)\n+            return BadLength;\n \n         XRenderSetPictureFilter(dmxScreen->beDisplay,\n                                 pPictPriv->pict, filter, params, nparams);\ndiff --git a\/pseudoramiX\/pseudoramiX.c b\/pseudoramiX\/pseudoramiX.c\nindex d8b2593..95f6e10 100644\n--- a\/pseudoramiX\/pseudoramiX.c\n+++ b\/pseudoramiX\/pseudoramiX.c\n@@ -297,10 +297,11 @@ ProcPseudoramiXGetScreenSize(ClientPtr client)\n \n     TRACE;\n \n+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n+\n     if (stuff->screen >= pseudoramiXNumScreens)\n       return BadMatch;\n \n-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n     rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n     if (rc != Success)\n         return rc;\ndiff --git a\/render\/render.c b\/render\/render.c\nindex ccae49a..7d94bd5 100644\n--- a\/render\/render.c\n+++ b\/render\/render.c\n@@ -1757,6 +1757,9 @@ ProcRenderSetPictureFilter(ClientPtr client)\n     name = (char *) (stuff + 1);\n     params = (xFixed *) (name + pad_to_int32(stuff->nbytes));\n     nparams = ((xFixed *) stuff + client->req_len) - params;\n+    if (nparams < 0)\n+\treturn BadLength;\n+\n     result = SetPictureFilter(pPicture, name, stuff->nbytes, params, nparams);\n     return result;\n }\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-1248","CWE_ID":"20","category":"security","commit_id":"4fad66fbe637818b6b3d6bc5d21923ba72795040","commit_message":"From 4fad66fbe637818b6b3d6bc5d21923ba72795040 Mon Sep 17 00:00:00 2001\nFrom: James McCoy <jamessan@jamessan.com>\nDate: Sun, 20 Nov 2016 08:42:38 -0700\nSubject: [PATCH] vim-patch:8.0.0056\n\nProblem:    When setting 'filetype' there is no check for a valid name.\nSolution:   Only allow valid characters in 'filetype', 'syntax' and 'keymap'.\n\nhttps:\/\/github.com\/vim\/vim\/commit\/d0b5138ba4bccff8a744c99836041ef6322ed39a\n---\n src\/nvim\/option.c                 | 30 +++++++++++++++++--\n src\/nvim\/testdir\/test_options.vim | 50 +++++++++++++++++++++++++++++++\n 2 files changed, 77 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/src\/nvim\/option.c b\/src\/nvim\/option.c\nindex 0f95974cb4d..469aeecc23b 100644\n--- a\/src\/nvim\/option.c\n+++ b\/src\/nvim\/option.c\n@@ -2399,6 +2399,18 @@ static char *set_string_option(const int opt_idx, const char *const value,\n   return r;\n }\n \n+\/\/\/ Return true if \"val\" is a valid 'filetype' name.\n+\/\/\/ Also used for 'syntax' and 'keymap'.\n+static bool valid_filetype(char_u *val)\n+{\n+  for (char_u *s = val; *s != NUL; s++) {\n+    if (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)\".-_\", *s) == NULL) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n \/*\n  * Handle string options that need some action to perform when changed.\n  * Returns NULL for success, or an error message for an error.\n@@ -2623,8 +2635,12 @@ did_set_string_option (\n     xfree(p_penc);\n     p_penc = p;\n   } else if (varp == &curbuf->b_p_keymap) {\n-    \/* load or unload key mapping tables *\/\n-    errmsg = keymap_init();\n+    if (!valid_filetype(*varp)) {\n+      errmsg = e_invarg;\n+    } else {\n+      \/\/ load or unload key mapping tables\n+      errmsg = keymap_init();\n+    }\n \n     if (errmsg == NULL) {\n       if (*curbuf->b_p_keymap != NUL) {\n@@ -3118,8 +3134,16 @@ did_set_string_option (\n       if (check_opt_strings(p_icm, p_icm_values, false) != OK) {\n         errmsg = e_invarg;\n       }\n-  \/\/ Options that are a list of flags.\n+  } else if (gvarp == &p_ft) {\n+    if (!valid_filetype(*varp)) {\n+      errmsg = e_invarg;\n+    }\n+  } else if (gvarp == &p_syn) {\n+    if (!valid_filetype(*varp)) {\n+      errmsg = e_invarg;\n+    }\n   } else {\n+    \/\/ Options that are a list of flags.\n     p = NULL;\n     if (varp == &p_ww)\n       p = (char_u *)WW_ALL;\ndiff --git a\/src\/nvim\/testdir\/test_options.vim b\/src\/nvim\/testdir\/test_options.vim\nindex cceb180189d..93657f8fedf 100644\n--- a\/src\/nvim\/testdir\/test_options.vim\n+++ b\/src\/nvim\/testdir\/test_options.vim\n@@ -38,3 +38,53 @@ function! Test_path_keep_commas()\n \n   set path&\n endfunction\n+\n+func Test_filetype_valid()\n+  set ft=valid_name\n+  call assert_equal(\"valid_name\", &filetype)\n+  set ft=valid-name\n+  call assert_equal(\"valid-name\", &filetype)\n+\n+  call assert_fails(\":set ft=wrong;name\", \"E474:\")\n+  call assert_fails(\":set ft=wrong\\\\\\\\name\", \"E474:\")\n+  call assert_fails(\":set ft=wrong\\\\|name\", \"E474:\")\n+  call assert_fails(\":set ft=wrong\/name\", \"E474:\")\n+  call assert_fails(\":set ft=wrong\\\\\\nname\", \"E474:\")\n+  call assert_equal(\"valid-name\", &filetype)\n+\n+  exe \"set ft=trunc\\x00name\"\n+  call assert_equal(\"trunc\", &filetype)\n+endfunc\n+\n+func Test_syntax_valid()\n+  set syn=valid_name\n+  call assert_equal(\"valid_name\", &syntax)\n+  set syn=valid-name\n+  call assert_equal(\"valid-name\", &syntax)\n+\n+  call assert_fails(\":set syn=wrong;name\", \"E474:\")\n+  call assert_fails(\":set syn=wrong\\\\\\\\name\", \"E474:\")\n+  call assert_fails(\":set syn=wrong\\\\|name\", \"E474:\")\n+  call assert_fails(\":set syn=wrong\/name\", \"E474:\")\n+  call assert_fails(\":set syn=wrong\\\\\\nname\", \"E474:\")\n+  call assert_equal(\"valid-name\", &syntax)\n+\n+  exe \"set syn=trunc\\x00name\"\n+  call assert_equal(\"trunc\", &syntax)\n+endfunc\n+\n+func Test_keymap_valid()\n+  call assert_fails(\":set kmp=valid_name\", \"E544:\")\n+  call assert_fails(\":set kmp=valid_name\", \"valid_name\")\n+  call assert_fails(\":set kmp=valid-name\", \"E544:\")\n+  call assert_fails(\":set kmp=valid-name\", \"valid-name\")\n+\n+  call assert_fails(\":set kmp=wrong;name\", \"E474:\")\n+  call assert_fails(\":set kmp=wrong\\\\\\\\name\", \"E474:\")\n+  call assert_fails(\":set kmp=wrong\\\\|name\", \"E474:\")\n+  call assert_fails(\":set kmp=wrong\/name\", \"E474:\")\n+  call assert_fails(\":set kmp=wrong\\\\\\nname\", \"E474:\")\n+\n+  call assert_fails(\":set kmp=trunc\\x00name\", \"E544:\")\n+  call assert_fails(\":set kmp=trunc\\x00name\", \"trunc\")\n+endfunc\n","owner":"neovim","repo":"neovim","source":"cve"},{"CVE_ID":"CVE-2016-2143","CWE_ID":"20","category":"security","commit_id":"3446c13b268af86391d06611327006b059b8bab1","commit_message":"From 3446c13b268af86391d06611327006b059b8bab1 Mon Sep 17 00:00:00 2001\nFrom: Martin Schwidefsky <schwidefsky@de.ibm.com>\nDate: Mon, 15 Feb 2016 14:46:49 +0100\nSubject: [PATCH] s390\/mm: four page table levels vs. fork\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe fork of a process with four page table levels is broken since\ngit commit 6252d702c5311ce9 \"[S390] dynamic page tables.\"\n\nAll new mm contexts are created with three page table levels and\nan asce limit of 4TB. If the parent has four levels dup_mmap will\nadd vmas to the new context which are outside of the asce limit.\nThe subsequent call to copy_page_range will walk the three level\npage table structure of the new process with non-zero pgd and pud\nindexes. This leads to memory clobbers as the pgd_index *and* the\npud_index is added to the mm->pgd pointer without a pgd_deref\nin between.\n\nThe init_new_context() function is selecting the number of page\ntable levels for a new context. The function is used by mm_init()\nwhich in turn is called by dup_mm() and mm_alloc(). These two are\nused by fork() and exec(). The init_new_context() function can\ndistinguish the two cases by looking at mm->context.asce_limit,\nfor fork() the mm struct has been copied and the number of page\ntable levels may not change. For exec() the mm_alloc() function\nset the new mm structure to zero, in this case a three-level page\ntable is created as the temporary stack space is located at\nSTACK_TOP_MAX = 4TB.\n\nThis fixes CVE-2016-2143.\n\nReported-by: Marcin Ko\u015bcielnicki <koriakin@0x04.net>\nReviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>\n---\n arch\/s390\/include\/asm\/mmu_context.h | 16 +++++++++++-----\n arch\/s390\/include\/asm\/pgalloc.h     | 24 +++++++++++++++++++-----\n 2 files changed, 30 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/arch\/s390\/include\/asm\/mmu_context.h b\/arch\/s390\/include\/asm\/mmu_context.h\nindex fb1b93ea3e3fe..e485817f7b1a9 100644\n--- a\/arch\/s390\/include\/asm\/mmu_context.h\n+++ b\/arch\/s390\/include\/asm\/mmu_context.h\n@@ -15,17 +15,25 @@\n static inline int init_new_context(struct task_struct *tsk,\n \t\t\t\t   struct mm_struct *mm)\n {\n+\tspin_lock_init(&mm->context.list_lock);\n+\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n+\tINIT_LIST_HEAD(&mm->context.gmap_list);\n \tcpumask_clear(&mm->context.cpu_attach_mask);\n \tatomic_set(&mm->context.attach_count, 0);\n \tmm->context.flush_mm = 0;\n-\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n-\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n #ifdef CONFIG_PGSTE\n \tmm->context.alloc_pgste = page_table_allocate_pgste;\n \tmm->context.has_pgste = 0;\n \tmm->context.use_skey = 0;\n #endif\n-\tmm->context.asce_limit = STACK_TOP_MAX;\n+\tif (mm->context.asce_limit == 0) {\n+\t\t\/* context created by exec, set asce limit to 4TB *\/\n+\t\tmm->context.asce_bits = _ASCE_TABLE_LENGTH |\n+\t\t\t_ASCE_USER_BITS | _ASCE_TYPE_REGION3;\n+\t\tmm->context.asce_limit = STACK_TOP_MAX;\n+\t} else if (mm->context.asce_limit == (1UL << 31)) {\n+\t\tmm_inc_nr_pmds(mm);\n+\t}\n \tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n \treturn 0;\n }\n@@ -111,8 +119,6 @@ static inline void activate_mm(struct mm_struct *prev,\n static inline void arch_dup_mmap(struct mm_struct *oldmm,\n \t\t\t\t struct mm_struct *mm)\n {\n-\tif (oldmm->context.asce_limit < mm->context.asce_limit)\n-\t\tcrst_table_downgrade(mm, oldmm->context.asce_limit);\n }\n \n static inline void arch_exit_mmap(struct mm_struct *mm)\ndiff --git a\/arch\/s390\/include\/asm\/pgalloc.h b\/arch\/s390\/include\/asm\/pgalloc.h\nindex 7b7858f158b45..d7cc79fb61911 100644\n--- a\/arch\/s390\/include\/asm\/pgalloc.h\n+++ b\/arch\/s390\/include\/asm\/pgalloc.h\n@@ -100,12 +100,26 @@ static inline void pud_populate(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)\n \n static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n {\n-\tspin_lock_init(&mm->context.list_lock);\n-\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n-\tINIT_LIST_HEAD(&mm->context.gmap_list);\n-\treturn (pgd_t *) crst_table_alloc(mm);\n+\tunsigned long *table = crst_table_alloc(mm);\n+\n+\tif (!table)\n+\t\treturn NULL;\n+\tif (mm->context.asce_limit == (1UL << 31)) {\n+\t\t\/* Forking a compat process with 2 page table levels *\/\n+\t\tif (!pgtable_pmd_page_ctor(virt_to_page(table))) {\n+\t\t\tcrst_table_free(mm, table);\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\treturn (pgd_t *) table;\n+}\n+\n+static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)\n+{\n+\tif (mm->context.asce_limit == (1UL << 31))\n+\t\tpgtable_pmd_page_dtor(virt_to_page(pgd));\n+\tcrst_table_free(mm, (unsigned long *) pgd);\n }\n-#define pgd_free(mm, pgd) crst_table_free(mm, (unsigned long *) pgd)\n \n static inline void pmd_populate(struct mm_struct *mm,\n \t\t\t\tpmd_t *pmd, pgtable_t pte)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-4001","CWE_ID":"20","category":"security","commit_id":"3a15cc0e1ee7168db0782133d2607a6bfa422d66","commit_message":"From 3a15cc0e1ee7168db0782133d2607a6bfa422d66 Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Fri, 8 Apr 2016 11:33:48 +0530\nSubject: [PATCH] net: stellaris_enet: check packet length against receive\n buffer\n\nWhen receiving packets over Stellaris ethernet controller, it\nuses receive buffer of size 2048 bytes. In case the controller\naccepts large(MTU) packets, it could lead to memory corruption.\nAdd check to avoid it.\n\nReported-by: Oleksandr Bazhaniuk <oleksandr.bazhaniuk@intel.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-id: 1460095428-22698-1-git-send-email-ppandit@redhat.com\nReviewed-by: Peter Maydell <peter.maydell@linaro.org>\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>\n---\n hw\/net\/stellaris_enet.c | 12 +++++++++++-\n 1 file changed, 11 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/net\/stellaris_enet.c b\/hw\/net\/stellaris_enet.c\nindex 84cf60b..6880894 100644\n--- a\/hw\/net\/stellaris_enet.c\n+++ b\/hw\/net\/stellaris_enet.c\n@@ -236,8 +236,18 @@ static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, si\n     n = s->next_packet + s->np;\n     if (n >= 31)\n         n -= 31;\n-    s->np++;\n \n+    if (size >= sizeof(s->rx[n].data) - 6) {\n+        \/* If the packet won't fit into the\n+         * emulated 2K RAM, this is reported\n+         * as a FIFO overrun error.\n+         *\/\n+        s->ris |= SE_INT_FOV;\n+        stellaris_enet_update(s);\n+        return -1;\n+    }\n+\n+    s->np++;\n     s->rx[n].len = size + 6;\n     p = s->rx[n].data;\n     *(p++) = (size + 6);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-3185","CWE_ID":"20","category":"security","commit_id":"eaf4e77190d402ea014207e9a7d5da1a4f3727ba","commit_message":"From eaf4e77190d402ea014207e9a7d5da1a4f3727ba Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 21 Feb 2016 23:45:57 -0800\nSubject: [PATCH] Fix bug #71610: Type Confusion Vulnerability - SOAP \/\n make_http_soap_request()\n\n---\n ext\/soap\/php_http.c          |  2 ++\n ext\/soap\/tests\/bug71610.phpt | 15 +++++++++++++++\n 2 files changed, 17 insertions(+)\n create mode 100644 ext\/soap\/tests\/bug71610.phpt\n\n","diff_code":"diff --git a\/ext\/soap\/php_http.c b\/ext\/soap\/php_http.c\nindex 2baa0fa..a2d0b62 100644\n--- a\/ext\/soap\/php_http.c\n+++ b\/ext\/soap\/php_http.c\n@@ -833,8 +833,10 @@ try_again:\n \t\t\t\t\t\t    Z_TYPE_P(value) == IS_STRING) {\n \t\t\t\t\t\t  zval *tmp;\n \t\t\t\t\t\t  if (((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 1)) == NULL ||\n+\t\t\t\t\t\t\t   Z_TYPE_P(tmp) != IS_STRING ||\n \t\t\t\t\t\t       strncmp(phpurl->path?phpurl->path:\"\/\",Z_STRVAL_P(tmp),Z_STRLEN_P(tmp)) == 0) &&\n \t\t\t\t\t\t      ((tmp = zend_hash_index_find(Z_ARRVAL_P(data), 2)) == NULL ||\n+\t\t\t\t\t\t\t   Z_TYPE_P(tmp) != IS_STRING ||\n \t\t\t\t\t\t       in_domain(phpurl->host,Z_STRVAL_P(tmp))) &&\n \t\t\t\t\t\t      (use_ssl || (tmp = zend_hash_index_find(Z_ARRVAL_P(data), 3)) == NULL)) {\n \t\t\t\t\t\t\t\tsmart_str_append(&soap_headers, key);\ndiff --git a\/ext\/soap\/tests\/bug71610.phpt b\/ext\/soap\/tests\/bug71610.phpt\nnew file mode 100644\nindex 0000000..4f1c716\n--- \/dev\/null\n+++ b\/ext\/soap\/tests\/bug71610.phpt\n@@ -0,0 +1,15 @@\n+--TEST--\n+SOAP Bug #71610 - Type Confusion Vulnerability - SOAP \/ make_http_soap_request()\n+--SKIPIF--\n+<?php require_once('skipif.inc'); ?>\n+--FILE--\n+<?php\n+$exploit = unserialize('O:10:\"SoapClient\":3:{s:3:\"uri\";s:1:\"a\";s:8:\"location\";s:19:\"http:\/\/testuri.org\/\";s:8:\"_cookies\";a:1:{s:8:\"manhluat\";a:3:{i:0;s:0:\"\";i:1;N;i:2;N;}}}}');\n+try {\n+$exploit->blahblah();\n+} catch(SoapFault $e) {\n+\techo $e->getMessage().\"\\n\";\n+}\n+?>\n+--EXPECT--\n+looks like we got no XML document\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6504","CWE_ID":"20","category":"security","commit_id":"f5ad04766f4abaa78374ff03704316f8ce04627d","commit_message":"From f5ad04766f4abaa78374ff03704316f8ce04627d Mon Sep 17 00:00:00 2001\nFrom: ngosang <ngosang@hotmail.es>\nDate: Mon, 6 Feb 2017 20:44:57 +0100\nSubject: [PATCH] [WebUI] Avoid clickjacking attacks\n\n---\n src\/base\/http\/types.h                | 1 +\n src\/webui\/abstractwebapplication.cpp | 6 +++++-\n 2 files changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/base\/http\/types.h b\/src\/base\/http\/types.h\nindex d748d93427..ae401c7198 100644\n--- a\/src\/base\/http\/types.h\n+++ b\/src\/base\/http\/types.h\n@@ -43,6 +43,7 @@ namespace Http\n     const QString HEADER_CONTENT_ENCODING = \"Content-Encoding\";\n     const QString HEADER_CONTENT_LENGTH = \"Content-Length\";\n     const QString HEADER_CACHE_CONTROL = \"Cache-Control\";\n+    const QString HEADER_X_FRAME_OPTIONS = \"X-Frame-Options\";\n \n     const QString CONTENT_TYPE_CSS = \"text\/css; charset=UTF-8\";\n     const QString CONTENT_TYPE_GIF = \"image\/gif\";\ndiff --git a\/src\/webui\/abstractwebapplication.cpp b\/src\/webui\/abstractwebapplication.cpp\nindex c0e42bf0a0..738f7f4c27 100644\n--- a\/src\/webui\/abstractwebapplication.cpp\n+++ b\/src\/webui\/abstractwebapplication.cpp\n@@ -103,7 +103,11 @@ Http::Response AbstractWebApplication::processRequest(const Http::Request &reque\n     request_ = request;\n     env_ = env;\n \n-    clear(); \/\/ clear response\n+    \/\/ clear response\n+    clear();\n+\n+    \/\/ avoid clickjacking attacks\n+    header(Http::HEADER_X_FRAME_OPTIONS, \"SAMEORIGIN\");\n \n     sessionInitialize();\n     if (!sessionActive() && !isAuthNeeded())\n","owner":"qbittorrent","repo":"qBittorrent","source":"cve"},{"CVE_ID":"CVE-2016-10167","CWE_ID":"20","category":"security","commit_id":"fe9ed49dafa993e3af96b6a5a589efeea9bfb36f","commit_message":"From fe9ed49dafa993e3af96b6a5a589efeea9bfb36f Mon Sep 17 00:00:00 2001\nFrom: \"Christoph M. Becker\" <cmbecker69@gmx.de>\nDate: Tue, 16 Aug 2016 18:23:36 +0200\nSubject: [PATCH] Fix DOS vulnerability in gdImageCreateFromGd2Ctx()\n\nWe must not pretend that there are image data if there are none. Instead\nwe fail reading the image file gracefully.\n---\n src\/gd_gd2.c                     |  14 ++++++--------\n tests\/gd2\/.gitignore             |   1 +\n tests\/gd2\/CMakeLists.txt         |   1 +\n tests\/gd2\/Makemodule.am          |   7 +++++--\n tests\/gd2\/too_few_image_data.c   |  22 ++++++++++++++++++++++\n tests\/gd2\/too_few_image_data.gd2 | Bin 0 -> 1050 bytes\n 6 files changed, 35 insertions(+), 10 deletions(-)\n create mode 100644 tests\/gd2\/too_few_image_data.c\n create mode 100644 tests\/gd2\/too_few_image_data.gd2\n\n","diff_code":"diff --git a\/src\/gd_gd2.c b\/src\/gd_gd2.c\nindex 3c716826..d07828c7 100644\n--- a\/src\/gd_gd2.c\n+++ b\/src\/gd_gd2.c\n@@ -503,18 +503,16 @@ BGD_DECLARE(gdImagePtr) gdImageCreateFromGd2Ctx (gdIOCtxPtr in)\n \n \t\t\t\t\t\tif (im->trueColor) {\n \t\t\t\t\t\t\tif (!gdGetInt (&im->tpixels[y][x], in)) {\n-\t\t\t\t\t\t\t\t\/*printf(\"EOF while reading\\n\"); *\/\n-\t\t\t\t\t\t\t\t\/*gdImageDestroy(im); *\/\n-\t\t\t\t\t\t\t\t\/*return 0; *\/\n-\t\t\t\t\t\t\t\tim->tpixels[y][x] = 0;\n+\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n+\t\t\t\t\t\t\t\tgdImageDestroy(im);\n+\t\t\t\t\t\t\t\treturn NULL;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tint ch;\n \t\t\t\t\t\t\tif (!gdGetByte (&ch, in)) {\n-\t\t\t\t\t\t\t\t\/*printf(\"EOF while reading\\n\"); *\/\n-\t\t\t\t\t\t\t\t\/*gdImageDestroy(im); *\/\n-\t\t\t\t\t\t\t\t\/*return 0; *\/\n-\t\t\t\t\t\t\t\tch = 0;\n+\t\t\t\t\t\t\t\tgd_error(\"gd2: EOF while reading\\n\");\n+\t\t\t\t\t\t\t\tgdImageDestroy(im);\n+\t\t\t\t\t\t\t\treturn NULL;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tim->pixels[y][x] = ch;\n \t\t\t\t\t\t}\ndiff --git a\/tests\/gd2\/.gitignore b\/tests\/gd2\/.gitignore\nindex 136a2d50..39d8bf4e 100644\n--- a\/tests\/gd2\/.gitignore\n+++ b\/tests\/gd2\/.gitignore\n@@ -6,3 +6,4 @@\n \/gd2_read\n \/gd2_read_corrupt\n \/php_bug_72339\n+\/too_few_image_data\ndiff --git a\/tests\/gd2\/CMakeLists.txt b\/tests\/gd2\/CMakeLists.txt\nindex 8fcc9065..5a61d113 100644\n--- a\/tests\/gd2\/CMakeLists.txt\n+++ b\/tests\/gd2\/CMakeLists.txt\n@@ -7,6 +7,7 @@ LIST(APPEND TESTS_FILES\n \tphp_bug_72339\n \tgd2_read\n \tgd2_read_corrupt\n+\ttoo_few_image_data\n )\n \n ADD_GD_TESTS()\ndiff --git a\/tests\/gd2\/Makemodule.am b\/tests\/gd2\/Makemodule.am\nindex d69aee02..c1fbf440 100644\n--- a\/tests\/gd2\/Makemodule.am\n+++ b\/tests\/gd2\/Makemodule.am\n@@ -3,7 +3,8 @@ libgd_test_programs += \\\n \tgd2\/bug00309 \\\n \tgd2\/gd2_empty_file \\\n \tgd2\/php_bug_72339 \\\n-\tgd2\/gd2_read_corrupt\n+\tgd2\/gd2_read_corrupt \\\n+\tgd2\/too_few_image_data\n \n if HAVE_LIBZ\n libgd_test_programs += \\\n@@ -23,4 +24,6 @@ EXTRA_DIST += \\\n \tgd2\/conv_test_exp.png \\\n \tgd2\/empty.gd2 \\\n \tgd2\/invalid_header.gd2 \\\n-\tgd2\/invalid_neg_size.gd2\n+\tgd2\/invalid_neg_size.gd2 \\\n+\tgd2\/php_bug_72339_exp.gd2 \\\n+\tgd2\/too_few_image_data.gd2\ndiff --git a\/tests\/gd2\/too_few_image_data.c b\/tests\/gd2\/too_few_image_data.c\nnew file mode 100644\nindex 00000000..3153a080\n--- \/dev\/null\n+++ b\/tests\/gd2\/too_few_image_data.c\n@@ -0,0 +1,22 @@\n+\/*\n+too_few_image_data.gd2 claims to have a size of 12336x48 pixels, but doesn't\n+provide as much image data. We test that gdImageCreateFromGd2Ctx() returns NULL\n+in this case.\n+*\/\n+\n+#include \"gd.h\"\n+#include \"gdtest.h\"\n+\n+int main()\n+{\n+    gdImagePtr im;\n+    FILE *fp;\n+\n+    fp = gdTestFileOpen2(\"gd2\", \"too_few_image_data.gd2\");\n+    gdTestAssert(fp != NULL);\n+    im = gdImageCreateFromGd2(fp);\n+    gdTestAssert(im == NULL);\n+    fclose(fp);\n+\n+    return gdNumFailures();\n+}\ndiff --git a\/tests\/gd2\/too_few_image_data.gd2 b\/tests\/gd2\/too_few_image_data.gd2\nnew file mode 100644\nindex 0000000000000000000000000000000000000000..1c797d1acfae114be5505962f9f3201f01bca420\nGIT binary patch\nliteral 1050\nkcmYdKF=Aj~GB98;U@~A}1kqrw!6+CFfzc2c!6Cp30J@*U8UO$Q\n\nliteral 0\nHcmV?d00001\n\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2016-1248","CWE_ID":"20","category":"security","commit_id":"d0b5138ba4bccff8a744c99836041ef6322ed39a","commit_message":"From d0b5138ba4bccff8a744c99836041ef6322ed39a Mon Sep 17 00:00:00 2001\nFrom: Bram Moolenaar <Bram@vim.org>\nDate: Fri, 4 Nov 2016 15:23:45 +0100\nSubject: [PATCH] patch 8.0.0056 Problem:    When setting 'filetype' there is\n no check for a valid name. Solution:   Only allow valid characters in\n 'filetype', 'syntax' and 'keymap'.\n\n---\n src\/option.c                 | 38 ++++++++++++++++++++++++++--\n src\/testdir\/test_options.vim | 49 ++++++++++++++++++++++++++++++++++++\n src\/version.c                |  2 ++\n 3 files changed, 87 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/option.c b\/src\/option.c\nindex ebf443b84b..8eea1f8766 100644\n--- a\/src\/option.c\n+++ b\/src\/option.c\n@@ -5822,6 +5822,21 @@ set_string_option(\n     return r;\n }\n \n+\/*\n+ * Return TRUE if \"val\" is a valid 'filetype' name.\n+ * Also used for 'syntax' and 'keymap'.\n+ *\/\n+    static int\n+valid_filetype(char_u *val)\n+{\n+    char_u *s;\n+\n+    for (s = val; *s != NUL; ++s)\n+\tif (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)\".-_\", *s) == NULL)\n+\t    return FALSE;\n+    return TRUE;\n+}\n+\n \/*\n  * Handle string options that need some action to perform when changed.\n  * Returns NULL for success, or an error message for an error.\n@@ -6235,8 +6250,11 @@ did_set_string_option(\n #ifdef FEAT_KEYMAP\n     else if (varp == &curbuf->b_p_keymap)\n     {\n-\t\/* load or unload key mapping tables *\/\n-\terrmsg = keymap_init();\n+\tif (!valid_filetype(*varp))\n+\t    errmsg = e_invarg;\n+\telse\n+\t    \/* load or unload key mapping tables *\/\n+\t    errmsg = keymap_init();\n \n \tif (errmsg == NULL)\n \t{\n@@ -7222,6 +7240,22 @@ did_set_string_option(\n     }\n #endif\n \n+#ifdef FEAT_AUTOCMD\n+    else if (gvarp == &p_ft)\n+    {\n+\tif (!valid_filetype(*varp))\n+\t    errmsg = e_invarg;\n+    }\n+#endif\n+\n+#ifdef FEAT_SYN_HL\n+    else if (gvarp == &p_syn)\n+    {\n+\tif (!valid_filetype(*varp))\n+\t    errmsg = e_invarg;\n+    }\n+#endif\n+\n     \/* Options that are a list of flags. *\/\n     else\n     {\ndiff --git a\/src\/testdir\/test_options.vim b\/src\/testdir\/test_options.vim\nindex 21dd7fe4f8..dee435c38a 100644\n--- a\/src\/testdir\/test_options.vim\n+++ b\/src\/testdir\/test_options.vim\n@@ -48,3 +48,52 @@ func Test_signcolumn()\n   endif\n endfunc\n \n+func Test_filetype_valid()\n+  set ft=valid_name\n+  call assert_equal(\"valid_name\", &filetype)\n+  set ft=valid-name\n+  call assert_equal(\"valid-name\", &filetype)\n+\n+  call assert_fails(\":set ft=wrong;name\", \"E474:\")\n+  call assert_fails(\":set ft=wrong\\\\\\\\name\", \"E474:\")\n+  call assert_fails(\":set ft=wrong\\\\|name\", \"E474:\")\n+  call assert_fails(\":set ft=wrong\/name\", \"E474:\")\n+  call assert_fails(\":set ft=wrong\\\\\\nname\", \"E474:\")\n+  call assert_equal(\"valid-name\", &filetype)\n+\n+  exe \"set ft=trunc\\x00name\"\n+  call assert_equal(\"trunc\", &filetype)\n+endfunc\n+\n+func Test_syntax_valid()\n+  set syn=valid_name\n+  call assert_equal(\"valid_name\", &syntax)\n+  set syn=valid-name\n+  call assert_equal(\"valid-name\", &syntax)\n+\n+  call assert_fails(\":set syn=wrong;name\", \"E474:\")\n+  call assert_fails(\":set syn=wrong\\\\\\\\name\", \"E474:\")\n+  call assert_fails(\":set syn=wrong\\\\|name\", \"E474:\")\n+  call assert_fails(\":set syn=wrong\/name\", \"E474:\")\n+  call assert_fails(\":set syn=wrong\\\\\\nname\", \"E474:\")\n+  call assert_equal(\"valid-name\", &syntax)\n+\n+  exe \"set syn=trunc\\x00name\"\n+  call assert_equal(\"trunc\", &syntax)\n+endfunc\n+\n+func Test_keymap_valid()\n+  call assert_fails(\":set kmp=valid_name\", \"E544:\")\n+  call assert_fails(\":set kmp=valid_name\", \"valid_name\")\n+  call assert_fails(\":set kmp=valid-name\", \"E544:\")\n+  call assert_fails(\":set kmp=valid-name\", \"valid-name\")\n+\n+  call assert_fails(\":set kmp=wrong;name\", \"E474:\")\n+  call assert_fails(\":set kmp=wrong\\\\\\\\name\", \"E474:\")\n+  call assert_fails(\":set kmp=wrong\\\\|name\", \"E474:\")\n+  call assert_fails(\":set kmp=wrong\/name\", \"E474:\")\n+  call assert_fails(\":set kmp=wrong\\\\\\nname\", \"E474:\")\n+\n+  call assert_fails(\":set kmp=trunc\\x00name\", \"E544:\")\n+  call assert_fails(\":set kmp=trunc\\x00name\", \"trunc\")\n+endfunc\ndiff --git a\/src\/version.c b\/src\/version.c\nindex 0b62f9cae9..f63041ec4c 100644\n--- a\/src\/version.c\n+++ b\/src\/version.c\n@@ -764,6 +764,8 @@ static char *(features[]) =\n \n static int included_patches[] =\n {   \/* Add new patch number below this line *\/\n+\/**\/\n+    56,\n \/**\/\n     55,\n \/**\/\n","owner":"vim","repo":"vim","source":"cve"},{"CVE_ID":"CVE-2014-1874","CWE_ID":"20","category":"security","commit_id":"2172fa709ab32ca60e86179dc67d0857be8e2c98","commit_message":"From 2172fa709ab32ca60e86179dc67d0857be8e2c98 Mon Sep 17 00:00:00 2001\nFrom: Stephen Smalley <sds@tycho.nsa.gov>\nDate: Thu, 30 Jan 2014 11:26:59 -0500\nSubject: [PATCH] SELinux:  Fix kernel BUG on empty security contexts.\n\nSetting an empty security context (length=0) on a file will\nlead to incorrectly dereferencing the type and other fields\nof the security context structure, yielding a kernel BUG.\nAs a zero-length security context is never valid, just reject\nall such security contexts whether coming from userspace\nvia setxattr or coming from the filesystem upon a getxattr\nrequest by SELinux.\n\nSetting a security context value (empty or otherwise) unknown to\nSELinux in the first place is only possible for a root process\n(CAP_MAC_ADMIN), and, if running SELinux in enforcing mode, only\nif the corresponding SELinux mac_admin permission is also granted\nto the domain by policy.  In Fedora policies, this is only allowed for\nspecific domains such as livecd for setting down security contexts\nthat are not defined in the build host policy.\n\nReproducer:\nsu\nsetenforce 0\ntouch foo\nsetfattr -n security.selinux foo\n\nCaveat:\nRelabeling or removing foo after doing the above may not be possible\nwithout booting with SELinux disabled.  Any subsequent access to foo\nafter doing the above will also trigger the BUG.\n\nBUG output from Matthew Thode:\n[  473.893141] ------------[ cut here ]------------\n[  473.962110] kernel BUG at security\/selinux\/ss\/services.c:654!\n[  473.995314] invalid opcode: 0000 [#6] SMP\n[  474.027196] Modules linked in:\n[  474.058118] CPU: 0 PID: 8138 Comm: ls Tainted: G      D   I\n3.13.0-grsec #1\n[  474.116637] Hardware name: Supermicro X8ST3\/X8ST3, BIOS 2.0\n07\/29\/10\n[  474.149768] task: ffff8805f50cd010 ti: ffff8805f50cd488 task.ti:\nffff8805f50cd488\n[  474.183707] RIP: 0010:[<ffffffff814681c7>]  [<ffffffff814681c7>]\ncontext_struct_compute_av+0xce\/0x308\n[  474.219954] RSP: 0018:ffff8805c0ac3c38  EFLAGS: 00010246\n[  474.252253] RAX: 0000000000000000 RBX: ffff8805c0ac3d94 RCX:\n0000000000000100\n[  474.287018] RDX: ffff8805e8aac000 RSI: 00000000ffffffff RDI:\nffff8805e8aaa000\n[  474.321199] RBP: ffff8805c0ac3cb8 R08: 0000000000000010 R09:\n0000000000000006\n[  474.357446] R10: 0000000000000000 R11: ffff8805c567a000 R12:\n0000000000000006\n[  474.419191] R13: ffff8805c2b74e88 R14: 00000000000001da R15:\n0000000000000000\n[  474.453816] FS:  00007f2e75220800(0000) GS:ffff88061fc00000(0000)\nknlGS:0000000000000000\n[  474.489254] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  474.522215] CR2: 00007f2e74716090 CR3: 00000005c085e000 CR4:\n00000000000207f0\n[  474.556058] Stack:\n[  474.584325]  ffff8805c0ac3c98 ffffffff811b549b ffff8805c0ac3c98\nffff8805f1190a40\n[  474.618913]  ffff8805a6202f08 ffff8805c2b74e88 00068800d0464990\nffff8805e8aac860\n[  474.653955]  ffff8805c0ac3cb8 000700068113833a ffff880606c75060\nffff8805c0ac3d94\n[  474.690461] Call Trace:\n[  474.723779]  [<ffffffff811b549b>] ? lookup_fast+0x1cd\/0x22a\n[  474.778049]  [<ffffffff81468824>] security_compute_av+0xf4\/0x20b\n[  474.811398]  [<ffffffff8196f419>] avc_compute_av+0x2a\/0x179\n[  474.843813]  [<ffffffff8145727b>] avc_has_perm+0x45\/0xf4\n[  474.875694]  [<ffffffff81457d0e>] inode_has_perm+0x2a\/0x31\n[  474.907370]  [<ffffffff81457e76>] selinux_inode_getattr+0x3c\/0x3e\n[  474.938726]  [<ffffffff81455cf6>] security_inode_getattr+0x1b\/0x22\n[  474.970036]  [<ffffffff811b057d>] vfs_getattr+0x19\/0x2d\n[  475.000618]  [<ffffffff811b05e5>] vfs_fstatat+0x54\/0x91\n[  475.030402]  [<ffffffff811b063b>] vfs_lstat+0x19\/0x1b\n[  475.061097]  [<ffffffff811b077e>] SyS_newlstat+0x15\/0x30\n[  475.094595]  [<ffffffff8113c5c1>] ? __audit_syscall_entry+0xa1\/0xc3\n[  475.148405]  [<ffffffff8197791e>] system_call_fastpath+0x16\/0x1b\n[  475.179201] Code: 00 48 85 c0 48 89 45 b8 75 02 0f 0b 48 8b 45 a0 48\n8b 3d 45 d0 b6 00 8b 40 08 89 c6 ff ce e8 d1 b0 06 00 48 85 c0 49 89 c7\n75 02 <0f> 0b 48 8b 45 b8 4c 8b 28 eb 1e 49 8d 7d 08 be 80 01 00 00 e8\n[  475.255884] RIP  [<ffffffff814681c7>]\ncontext_struct_compute_av+0xce\/0x308\n[  475.296120]  RSP <ffff8805c0ac3c38>\n[  475.328734] ---[ end trace f076482e9d754adc ]---\n\nReported-by:  Matthew Thode <mthode@mthode.org>\nSigned-off-by: Stephen Smalley <sds@tycho.nsa.gov>\nCc: stable@vger.kernel.org\nSigned-off-by: Paul Moore <pmoore@redhat.com>\n---\n security\/selinux\/ss\/services.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/security\/selinux\/ss\/services.c b\/security\/selinux\/ss\/services.c\nindex fc5a63a05a1cc..f1e46d776544f 100644\n--- a\/security\/selinux\/ss\/services.c\n+++ b\/security\/selinux\/ss\/services.c\n@@ -1232,6 +1232,10 @@ static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n \tstruct context context;\n \tint rc = 0;\n \n+\t\/* An empty security context is never valid. *\/\n+\tif (!scontext_len)\n+\t\treturn -EINVAL;\n+\n \tif (!ss_initialized) {\n \t\tint i;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-0463","CWE_ID":"20","category":"security","commit_id":"272b62c1f0f6f742046e45b50b6fec98860208a0","commit_message":"From 272b62c1f0f6f742046e45b50b6fec98860208a0 Mon Sep 17 00:00:00 2001\nFrom: Goldwyn Rodrigues <rgoldwyn@gmail.com>\nDate: Thu, 17 Feb 2011 09:44:40 -0600\nSubject: Treat writes as new when holes span across page boundaries\n\nWhen a hole spans across page boundaries, the next write forces\na read of the block. This could end up reading existing garbage\ndata from the disk in ocfs2_map_page_blocks. This leads to\nnon-zero holes. In order to avoid this, mark the writes as new\nwhen the holes span across page boundaries.\n\nSigned-off-by: Goldwyn Rodrigues <rgoldwyn@suse.de>\nSigned-off-by: jlbec <jlbec@evilplan.org>\n---\n fs\/ocfs2\/aops.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/fs\/ocfs2\/aops.c b\/fs\/ocfs2\/aops.c\nindex 0d44b7701844..b5d7fb9ab1f3 100644\n--- a\/fs\/ocfs2\/aops.c\n+++ b\/fs\/ocfs2\/aops.c\n@@ -1015,6 +1015,12 @@ static int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,\n \tocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,\n \t\t\t\t\t&cluster_start, &cluster_end);\n \n+\t\/* treat the write as new if the a hole\/lseek spanned across\n+\t * the page boundary.\n+\t *\/\n+\tnew = new | ((i_size_read(inode) <= page_offset(page)) &&\n+\t\t\t(page_offset(page) <= user_pos));\n+\n \tif (page == wc->w_target_page) {\n \t\tmap_from = user_pos & (PAGE_CACHE_SIZE - 1);\n \t\tmap_to = map_from + user_len;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-2739","CWE_ID":"20","category":"security","commit_id":"b2853fd6c2d0f383dbdf7427e263eb576a633867","commit_message":"From b2853fd6c2d0f383dbdf7427e263eb576a633867 Mon Sep 17 00:00:00 2001\nFrom: Moni Shoua <monis@mellanox.com>\nDate: Thu, 27 Mar 2014 10:52:58 +0200\nSubject: IB\/core: Don't resolve passive side RoCE L2 address in CMA REQ\n handler\n\nThe code that resolves the passive side source MAC within the rdma_cm\nconnection request handler was both redundant and buggy, so remove it.\n\nIt was redundant since later, when an RC QP is modified to RTR state,\nthe resolution will take place in the ib_core module.  It was buggy\nbecause this callback also deals with UD SIDR exchange, for which we\nincorrectly looked at the REQ member of the CM event and dereferenced\na random value.\n\nFixes: dd5f03beb4f7 (\"IB\/core: Ethernet L2 attributes in verbs\/cm structures\")\nSigned-off-by: Moni Shoua <monis@mellanox.com>\nSigned-off-by: Or Gerlitz <ogerlitz@mellanox.com>\nSigned-off-by: Roland Dreier <roland@purestorage.com>\n---\n drivers\/infiniband\/core\/cm.c  | 17 -----------------\n drivers\/infiniband\/core\/cma.c | 26 --------------------------\n include\/rdma\/ib_cm.h          |  1 -\n 3 files changed, 44 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/infiniband\/core\/cm.c b\/drivers\/infiniband\/core\/cm.c\nindex 0601b9daf840..c3239170d8b7 100644\n--- a\/drivers\/infiniband\/core\/cm.c\n+++ b\/drivers\/infiniband\/core\/cm.c\n@@ -349,23 +349,6 @@ static void cm_init_av_for_response(struct cm_port *port, struct ib_wc *wc,\n \t\t\t   grh, &av->ah_attr);\n }\n \n-int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac)\n-{\n-\tstruct cm_id_private *cm_id_priv;\n-\n-\tcm_id_priv = container_of(id, struct cm_id_private, id);\n-\n-\tif (smac != NULL)\n-\t\tmemcpy(cm_id_priv->av.smac, smac, sizeof(cm_id_priv->av.smac));\n-\n-\tif (alt_smac != NULL)\n-\t\tmemcpy(cm_id_priv->alt_av.smac, alt_smac,\n-\t\t       sizeof(cm_id_priv->alt_av.smac));\n-\n-\treturn 0;\n-}\n-EXPORT_SYMBOL(ib_update_cm_av);\n-\n static int cm_init_av_by_path(struct ib_sa_path_rec *path, struct cm_av *av)\n {\n \tstruct cm_device *cm_dev;\ndiff --git a\/drivers\/infiniband\/core\/cma.c b\/drivers\/infiniband\/core\/cma.c\nindex 199958d9ddc8..42c3058e6e9c 100644\n--- a\/drivers\/infiniband\/core\/cma.c\n+++ b\/drivers\/infiniband\/core\/cma.c\n@@ -1284,15 +1284,6 @@ static int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\n \tstruct rdma_id_private *listen_id, *conn_id;\n \tstruct rdma_cm_event event;\n \tint offset, ret;\n-\tu8 smac[ETH_ALEN];\n-\tu8 alt_smac[ETH_ALEN];\n-\tu8 *psmac = smac;\n-\tu8 *palt_smac = alt_smac;\n-\tint is_iboe = ((rdma_node_get_transport(cm_id->device->node_type) ==\n-\t\t\tRDMA_TRANSPORT_IB) &&\n-\t\t       (rdma_port_get_link_layer(cm_id->device,\n-\t\t\tib_event->param.req_rcvd.port) ==\n-\t\t\tIB_LINK_LAYER_ETHERNET));\n \n \tlisten_id = cm_id->context;\n \tif (!cma_check_req_qp_type(&listen_id->id, ib_event))\n@@ -1336,28 +1327,11 @@ static int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\n \tret = conn_id->id.event_handler(&conn_id->id, &event);\n \tif (ret)\n \t\tgoto err3;\n-\n-\tif (is_iboe) {\n-\t\tif (ib_event->param.req_rcvd.primary_path != NULL)\n-\t\t\trdma_addr_find_smac_by_sgid(\n-\t\t\t\t&ib_event->param.req_rcvd.primary_path->sgid,\n-\t\t\t\tpsmac, NULL);\n-\t\telse\n-\t\t\tpsmac = NULL;\n-\t\tif (ib_event->param.req_rcvd.alternate_path != NULL)\n-\t\t\trdma_addr_find_smac_by_sgid(\n-\t\t\t\t&ib_event->param.req_rcvd.alternate_path->sgid,\n-\t\t\t\tpalt_smac, NULL);\n-\t\telse\n-\t\t\tpalt_smac = NULL;\n-\t}\n \t\/*\n \t * Acquire mutex to prevent user executing rdma_destroy_id()\n \t * while we're accessing the cm_id.\n \t *\/\n \tmutex_lock(&lock);\n-\tif (is_iboe)\n-\t\tib_update_cm_av(cm_id, psmac, palt_smac);\n \tif (cma_comp(conn_id, RDMA_CM_CONNECT) &&\n \t    (conn_id->id.qp_type != IB_QPT_UD))\n \t\tib_send_cm_mra(cm_id, CMA_CM_MRA_SETTING, NULL, 0);\ndiff --git a\/include\/rdma\/ib_cm.h b\/include\/rdma\/ib_cm.h\nindex f29e3a27c2cc..0e3ff30647d5 100644\n--- a\/include\/rdma\/ib_cm.h\n+++ b\/include\/rdma\/ib_cm.h\n@@ -601,5 +601,4 @@ struct ib_cm_sidr_rep_param {\n int ib_send_cm_sidr_rep(struct ib_cm_id *cm_id,\n \t\t\tstruct ib_cm_sidr_rep_param *param);\n \n-int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac);\n #endif \/* IB_CM_H *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-3929","CWE_ID":"20","category":"security","commit_id":"635bcfccd439480003b74a665b5aa7c872c1ad6b","commit_message":"From 635bcfccd439480003b74a665b5aa7c872c1ad6b Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 24 Jan 2012 17:48:23 +0100\nSubject: [PATCH] dv: check stype\n\ndv: check stype\n\nFixes part1 of CVE-2011-3929\nPossibly fixes part of CVE-2011-3936\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nReviewed-by: Roman Shaposhnik <roman@shaposhnik.org>\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\nSigned-off-by: Alex Converse <alex.converse@gmail.com>\n---\n libavformat\/dv.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/libavformat\/dv.c b\/libavformat\/dv.c\nindex 4106dfd..c90ddec 100644\n--- a\/libavformat\/dv.c\n+++ b\/libavformat\/dv.c\n@@ -204,6 +204,12 @@ static int dv_extract_audio_info(DVDemuxContext* c, uint8_t* frame)\n     stype = (as_pack[3] & 0x1f);      \/* 0 - 2CH, 2 - 4CH, 3 - 8CH *\/\n     quant =  as_pack[4] & 0x07;       \/* 0 - 16bit linear, 1 - 12bit nonlinear *\/\n \n+    if (stype > 3) {\n+        av_log(c->fctx, AV_LOG_ERROR, \"stype %d is invalid\\n\", stype);\n+        c->ach = 0;\n+        return 0;\n+    }\n+\n     \/* note: ach counts PAIRS of channels (i.e. stereo channels) *\/\n     ach = ((int[4]){  1,  0,  2,  4})[stype];\n     if (ach == 1 && quant && freq == 2)\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-6334","CWE_ID":"20","category":"security","commit_id":"6937de5544c3eead3466b75020d8382080ed0cff","commit_message":"From 6937de5544c3eead3466b75020d8382080ed0cff Mon Sep 17 00:00:00 2001\nFrom: Fred Emmott <fe@fb.com>\nDate: Fri, 30 Mar 2018 11:21:01 -0700\nSubject: [PATCH] [security][CVE-2018-6334] kill globals for file uploads in\n hhvm\n\nCode should look at _GET, _POST, _FILES, etc. directly to avoid security concerns.\n\nThis included both `$GLOBALS` and `register_globals`-like behavior.\n\nCVE-2018-6334\n---\n hphp\/runtime\/server\/upload.cpp | 54 +++++-----------------------------\n 1 file changed, 7 insertions(+), 47 deletions(-)\n\n","diff_code":"diff --git a\/hphp\/runtime\/server\/upload.cpp b\/hphp\/runtime\/server\/upload.cpp\nindex 25e34667e10..c67364f5fea 100644\n--- a\/hphp\/runtime\/server\/upload.cpp\n+++ b\/hphp\/runtime\/server\/upload.cpp\n@@ -16,16 +16,18 @@\n *\/\n \n #include \"hphp\/runtime\/server\/upload.h\"\n+\n #include \"hphp\/runtime\/base\/program-functions.h\"\n-#include \"hphp\/runtime\/base\/runtime-option.h\"\n+#include \"hphp\/runtime\/base\/request-event-handler.h\"\n #include \"hphp\/runtime\/base\/request-local.h\"\n+#include \"hphp\/runtime\/base\/runtime-option.h\"\n+#include \"hphp\/runtime\/base\/string-util.h\"\n #include \"hphp\/runtime\/base\/zend-printf.h\"\n-#include \"hphp\/runtime\/base\/php-globals.h\"\n #include \"hphp\/runtime\/ext\/apc\/ext_apc.h\"\n+\n #include \"hphp\/util\/logger.h\"\n-#include \"hphp\/runtime\/base\/string-util.h\"\n #include \"hphp\/util\/text-util.h\"\n-#include \"hphp\/runtime\/base\/request-event-handler.h\"\n+\n #include <folly\/FileUtil.h>\n \n using std::set;\n@@ -714,7 +716,7 @@ void rfc1867PostHandler(Transport* transport,\n   std::string array_index, abuf;\n   char *lbuf=nullptr;\n   int total_bytes=0, cancel_upload=0, is_arr_upload=0, array_len=0;\n-  int max_file_size=0, skip_upload=0, anonindex=0, is_anonymous;\n+  int max_file_size=0, skip_upload=0, anonindex=0;\n   std::set<std::string> &uploaded_files = s_rfc1867_data->rfc1867UploadedFiles;\n   multipart_buffer *mbuff;\n   int fd=-1;\n@@ -855,11 +857,8 @@ void rfc1867PostHandler(Transport* transport,\n       }\n \n       if (!param) {\n-        is_anonymous = 1;\n         param = (char*)malloc(MAX_SIZE_ANONNAME);\n         snprintf(param, MAX_SIZE_ANONNAME, \"%u\", anonindex++);\n-      } else {\n-        is_anonymous = 0;\n       }\n \n       \/* New Rule: never repair potential malicious user input *\/\n@@ -1067,17 +1066,6 @@ void rfc1867PostHandler(Transport* transport,\n         s = tmp;\n       }\n \n-      Array globals = php_globals_as_array();\n-      if (!is_anonymous) {\n-        if (s) {\n-          String val(s+1, strlen(s+1), CopyString);\n-          safe_php_register_variable(lbuf, val, globals, 0);\n-        } else {\n-          String val(filename, strlen(filename), CopyString);\n-          safe_php_register_variable(lbuf, val, globals, 0);\n-        }\n-      }\n-\n       \/* Add $foo[name] *\/\n       if (is_arr_upload) {\n         snprintf(lbuf, llen, \"%s[name][%s]\",\n@@ -1107,18 +1095,6 @@ void rfc1867PostHandler(Transport* transport,\n         }\n       }\n \n-      \/* Add $foo_type *\/\n-      if (is_arr_upload) {\n-        snprintf(lbuf, llen, \"%s_type[%s]\",\n-                 abuf.c_str(), array_index.c_str());\n-      } else {\n-        snprintf(lbuf, llen, \"%s_type\", param);\n-      }\n-      if (!is_anonymous) {\n-        String val(cd, strlen(cd), CopyString);\n-        safe_php_register_variable(lbuf, val, globals, 0);\n-      }\n-\n       \/* Add $foo[type] *\/\n       if (is_arr_upload) {\n         snprintf(lbuf, llen, \"%s[type][%s]\",\n@@ -1140,11 +1116,6 @@ void rfc1867PostHandler(Transport* transport,\n \n       Variant tempFileName(temp_filename);\n \n-      \/* if param is of form xxx[.*] this will cut it to xxx *\/\n-      if (!is_anonymous) {\n-        safe_php_register_variable(param, tempFileName, globals, 1);\n-      }\n-\n       \/* Add $foo[tmp_name] *\/\n       if (is_arr_upload) {\n         snprintf(lbuf, llen, \"%s[tmp_name][%s]\",\n@@ -1174,17 +1145,6 @@ void rfc1867PostHandler(Transport* transport,\n       }\n       safe_php_register_variable(lbuf, error_type, files, 0);\n \n-      \/* Add $foo_size *\/\n-      if (is_arr_upload) {\n-        snprintf(lbuf, llen, \"%s_size[%s]\",\n-                 abuf.c_str(), array_index.c_str());\n-      } else {\n-        snprintf(lbuf, llen, \"%s_size\", param);\n-      }\n-      if (!is_anonymous) {\n-        safe_php_register_variable(lbuf, file_size, globals, 0);\n-      }\n-\n       \/* Add $foo[size] *\/\n       if (is_arr_upload) {\n         snprintf(lbuf, llen, \"%s[size][%s]\",\n","owner":"facebook","repo":"hhvm","source":"cve"},{"CVE_ID":"CVE-2017-11665","CWE_ID":"20","category":"security","commit_id":"ffcc82219cef0928bed2d558b19ef6ea35634130","commit_message":"From ffcc82219cef0928bed2d558b19ef6ea35634130 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Fri, 28 Jul 2017 14:37:26 +0200\nSubject: [PATCH] avformat\/rtmppkt: Convert ff_amf_get_field_value() to\n bytestream2\n\nFixes: out of array accesses\n\nFound-by: JunDong Xie of Ant-financial Light-Year Security Lab\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/rtmppkt.c | 57 ++++++++++++++++++++++++++++---------------\n 1 file changed, 37 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/libavformat\/rtmppkt.c b\/libavformat\/rtmppkt.c\nindex 572e165498a..3ae605d2804 100644\n--- a\/libavformat\/rtmppkt.c\n+++ b\/libavformat\/rtmppkt.c\n@@ -505,53 +505,70 @@ int ff_amf_tag_size(const uint8_t *data, const uint8_t *data_end)\n     return bytestream2_tell(&gb);\n }\n \n-int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n+static int amf_get_field_value2(GetByteContext *gb,\n                            const uint8_t *name, uint8_t *dst, int dst_size)\n {\n     int namelen = strlen(name);\n     int len;\n \n-    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n-        len = ff_amf_tag_size(data, data_end);\n-        if (len < 0)\n-            len = data_end - data;\n-        data += len;\n+    while (bytestream2_peek_byte(gb) != AMF_DATA_TYPE_OBJECT && bytestream2_get_bytes_left(gb) > 0) {\n+        int ret = amf_tag_skip(gb);\n+        if (ret < 0)\n+            return -1;\n     }\n-    if (data_end - data < 3)\n+    if (bytestream2_get_bytes_left(gb) < 3)\n         return -1;\n-    data++;\n+    bytestream2_get_byte(gb);\n+\n     for (;;) {\n-        int size = bytestream_get_be16(&data);\n+        int size = bytestream2_get_be16(gb);\n         if (!size)\n             break;\n-        if (size < 0 || size >= data_end - data)\n+        if (size < 0 || size >= bytestream2_get_bytes_left(gb))\n             return -1;\n-        data += size;\n-        if (size == namelen && !memcmp(data-size, name, namelen)) {\n-            switch (*data++) {\n+        bytestream2_skip(gb, size);\n+        if (size == namelen && !memcmp(gb->buffer-size, name, namelen)) {\n+            switch (bytestream2_get_byte(gb)) {\n             case AMF_DATA_TYPE_NUMBER:\n-                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n+                snprintf(dst, dst_size, \"%g\", av_int2double(bytestream2_get_be64(gb)));\n                 break;\n             case AMF_DATA_TYPE_BOOL:\n-                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n+                snprintf(dst, dst_size, \"%s\", bytestream2_get_byte(gb) ? \"true\" : \"false\");\n                 break;\n             case AMF_DATA_TYPE_STRING:\n-                len = bytestream_get_be16(&data);\n-                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n+                len = bytestream2_get_be16(gb);\n+                if (dst_size < 1)\n+                    return -1;\n+                if (dst_size < len + 1)\n+                    len = dst_size - 1;\n+                bytestream2_get_buffer(gb, dst, len);\n+                dst[len] = 0;\n                 break;\n             default:\n                 return -1;\n             }\n             return 0;\n         }\n-        len = ff_amf_tag_size(data, data_end);\n-        if (len < 0 || len >= data_end - data)\n+        len = amf_tag_skip(gb);\n+        if (len < 0 || bytestream2_get_bytes_left(gb) <= 0)\n             return -1;\n-        data += len;\n     }\n     return -1;\n }\n \n+int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n+                           const uint8_t *name, uint8_t *dst, int dst_size)\n+{\n+    GetByteContext gb;\n+\n+    if (data >= data_end)\n+        return -1;\n+\n+    bytestream2_init(&gb, data, data_end - data);\n+\n+    return amf_get_field_value2(&gb, name, dst, dst_size);\n+}\n+\n static const char* rtmp_packet_type(int type)\n {\n     switch (type) {\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2010-4818","CWE_ID":"20","category":"security","commit_id":"3f0d3f4d97bce75c1828635c322b6560a45a037f","commit_message":"From 3f0d3f4d97bce75c1828635c322b6560a45a037f Mon Sep 17 00:00:00 2001\nFrom: Julien Cristau <jcristau@debian.org>\nDate: Sat, 3 Jul 2010 19:42:26 +0100\nSubject: glx: make sure screen is non-negative in validGlxScreen\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nReviewed-by: Adam Jackson <ajax@redhat.com>\nReviewed-by: Kristian H\u00f8gsberg <krh@bitplanet.net>\nReviewed-by: Daniel Stone <daniel@fooishbar.org>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n glx\/glxcmds.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/glx\/glxcmds.c b\/glx\/glxcmds.c\nindex de9c3f0..419cc46 100644\n--- a\/glx\/glxcmds.c\n+++ b\/glx\/glxcmds.c\n@@ -56,7 +56,7 @@ validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err)\n     \/*\n     ** Check if screen exists.\n     *\/\n-    if (screen >= screenInfo.numScreens) {\n+    if (screen < 0 || screen >= screenInfo.numScreens) {\n \tclient->errorValue = screen;\n \t*err = BadValue;\n \treturn FALSE;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8844","CWE_ID":"20","category":"security","commit_id":"d2b9d2a5ad5ef04ff978c9923d19730cb05efd55","commit_message":"From d2b9d2a5ad5ef04ff978c9923d19730cb05efd55 Mon Sep 17 00:00:00 2001\nFrom: Michael Neuling <mikey@neuling.org>\nDate: Thu, 19 Nov 2015 15:44:44 +1100\nSubject: [PATCH] powerpc\/tm: Block signal return setting invalid MSR state\n\nCurrently we allow both the MSR T and S bits to be set by userspace on\na signal return.  Unfortunately this is a reserved configuration and\nwill cause a TM Bad Thing exception if attempted (via rfid).\n\nThis patch checks for this case in both the 32 and 64 bit signals\ncode.  If both T and S are set, we mark the context as invalid.\n\nFound using a syscall fuzzer.\n\nFixes: 2b0a576d15e0 (\"powerpc: Add new transactional memory state to the signal context\")\nCc: stable@vger.kernel.org # v3.9+\nSigned-off-by: Michael Neuling <mikey@neuling.org>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\n---\n arch\/powerpc\/include\/asm\/reg.h  |  1 +\n arch\/powerpc\/kernel\/signal_32.c | 14 +++++++++-----\n arch\/powerpc\/kernel\/signal_64.c |  4 ++++\n 3 files changed, 14 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/arch\/powerpc\/include\/asm\/reg.h b\/arch\/powerpc\/include\/asm\/reg.h\nindex a908ada8e0a53..2220f7a60def3 100644\n--- a\/arch\/powerpc\/include\/asm\/reg.h\n+++ b\/arch\/powerpc\/include\/asm\/reg.h\n@@ -108,6 +108,7 @@\n #define MSR_TS_T\t__MASK(MSR_TS_T_LG)\t\/*  Transaction Transactional *\/\n #define MSR_TS_MASK\t(MSR_TS_T | MSR_TS_S)   \/* Transaction State bits *\/\n #define MSR_TM_ACTIVE(x) (((x) & MSR_TS_MASK) != 0) \/* Transaction active? *\/\n+#define MSR_TM_RESV(x) (((x) & MSR_TS_MASK) == MSR_TS_MASK) \/* Reserved *\/\n #define MSR_TM_TRANSACTIONAL(x)\t(((x) & MSR_TS_MASK) == MSR_TS_T)\n #define MSR_TM_SUSPENDED(x)\t(((x) & MSR_TS_MASK) == MSR_TS_S)\n \ndiff --git a\/arch\/powerpc\/kernel\/signal_32.c b\/arch\/powerpc\/kernel\/signal_32.c\nindex 0dbee465af7a7..ef7c24e84a623 100644\n--- a\/arch\/powerpc\/kernel\/signal_32.c\n+++ b\/arch\/powerpc\/kernel\/signal_32.c\n@@ -875,6 +875,15 @@ static long restore_tm_user_regs(struct pt_regs *regs,\n \t\treturn 1;\n #endif \/* CONFIG_SPE *\/\n \n+\t\/* Get the top half of the MSR from the user context *\/\n+\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n+\t\treturn 1;\n+\tmsr_hi <<= 32;\n+\t\/* If TM bits are set to the reserved value, it's an invalid context *\/\n+\tif (MSR_TM_RESV(msr_hi))\n+\t\treturn 1;\n+\t\/* Pull in the MSR TM bits from the user context *\/\n+\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n \t\/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n \t * registers, including FP and V[S]Rs.  After recheckpointing, the\n \t * transactional versions should be loaded.\n@@ -884,11 +893,6 @@ static long restore_tm_user_regs(struct pt_regs *regs,\n \tcurrent->thread.tm_texasr |= TEXASR_FS;\n \t\/* This loads the checkpointed FP\/VEC state, if used *\/\n \ttm_recheckpoint(&current->thread, msr);\n-\t\/* Get the top half of the MSR *\/\n-\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n-\t\treturn 1;\n-\t\/* Pull in MSR TM from user context *\/\n-\tregs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK);\n \n \t\/* This loads the speculative FP\/VEC state, if used *\/\n \tif (msr & MSR_FP) {\ndiff --git a\/arch\/powerpc\/kernel\/signal_64.c b\/arch\/powerpc\/kernel\/signal_64.c\nindex 20756dfb9f346..c676ecec0869b 100644\n--- a\/arch\/powerpc\/kernel\/signal_64.c\n+++ b\/arch\/powerpc\/kernel\/signal_64.c\n@@ -438,6 +438,10 @@ static long restore_tm_sigcontexts(struct pt_regs *regs,\n \n \t\/* get MSR separately, transfer the LE bit if doing signal return *\/\n \terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n+\t\/* Don't allow reserved mode. *\/\n+\tif (MSR_TM_RESV(msr))\n+\t\treturn -EINVAL;\n+\n \t\/* pull in MSR TM from user context *\/\n \tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8853","CWE_ID":"20","category":"security","commit_id":"22b433eff9a1ffa2454e18405a56650f07b385b5","commit_message":"From 22b433eff9a1ffa2454e18405a56650f07b385b5 Mon Sep 17 00:00:00 2001\nFrom: Karl Williamson <khw@cpan.org>\nDate: Wed, 16 Sep 2015 14:34:31 -0600\nSubject: [PATCH] PATCH [perl #123562] Regexp-matching \"hangs\"\n\nThe regex engine got into an infinite loop because of the malformation.\nIt is trying to back-up over a sequence of UTF-8 continuation bytes.\nBut the character just before the sequence should be a start byte.  If\nnot, there is a malformation.  I added a test to croak if that isn't the\ncase so that it doesn't just infinitely loop.  I did this also in the\nsimilar areas of regexec.c.\n\nComments long ago added to the code suggested that we check for\nmalformations in the vicinity of the new tests.  But that was never\ndone.  These new tests should be good enough to prevent looping, anyway.\n---\n regexec.c  | 12 ++++++++++++\n t\/re\/pat.t | 18 +++++++++++++++++-\n 2 files changed, 29 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/regexec.c b\/regexec.c\nindex c88f46759c..1aa0c47ca3 100644\n--- a\/regexec.c\n+++ b\/regexec.c\n@@ -8761,6 +8761,10 @@ S_reghop3(U8 *s, SSize_t off, const U8* lim)\n             if (UTF8_IS_CONTINUED(*s)) {\n                 while (s > lim && UTF8_IS_CONTINUATION(*s))\n                     s--;\n+                if (! UTF8_IS_START(*s)) {\n+                    dTHX;\n+                    Perl_croak(aTHX_ \"Malformed UTF-8 character (fatal)\");\n+                }\n \t    }\n             \/* XXX could check well-formedness here *\/\n \t}\n@@ -8785,6 +8789,10 @@ S_reghop4(U8 *s, SSize_t off, const U8* llim, const U8* rlim)\n             if (UTF8_IS_CONTINUED(*s)) {\n                 while (s > llim && UTF8_IS_CONTINUATION(*s))\n                     s--;\n+                if (! UTF8_IS_START(*s)) {\n+                    dTHX;\n+                    Perl_croak(aTHX_ \"Malformed UTF-8 character (fatal)\");\n+                }\n             }\n             \/* XXX could check well-formedness here *\/\n         }\n@@ -8814,6 +8822,10 @@ S_reghopmaybe3(U8* s, SSize_t off, const U8* lim)\n             if (UTF8_IS_CONTINUED(*s)) {\n                 while (s > lim && UTF8_IS_CONTINUATION(*s))\n                     s--;\n+                if (! UTF8_IS_START(*s)) {\n+                    dTHX;\n+                    Perl_croak(aTHX_ \"Malformed UTF-8 character (fatal)\");\n+                }\n \t    }\n             \/* XXX could check well-formedness here *\/\n \t}\ndiff --git a\/t\/re\/pat.t b\/t\/re\/pat.t\nindex 64f64878dc..3377b192e5 100644\n--- a\/t\/re\/pat.t\n+++ b\/t\/re\/pat.t\n@@ -23,7 +23,7 @@ BEGIN {\n     skip_all_without_unicode_tables();\n }\n \n-plan tests => 774;  # Update this when adding\/deleting tests.\n+plan tests => 775;  # Update this when adding\/deleting tests.\n \n run_tests() unless caller;\n \n@@ -1675,6 +1675,22 @@ EOP\n                 \"test that we handle things like m\/\\\\888888888\/ without infinite loops\" );\n         }\n \n+        {   # Test that we handle some malformed UTF-8 without looping [perl\n+            # #123562]\n+\n+            my $code='\n+                BEGIN{require q(test.pl);}\n+                use Encode qw(_utf8_on);\n+                my $malformed = \"a\\x80\\n\";\n+                _utf8_on($malformed);\n+                watchdog(3);\n+                $malformed =~ \/(\\n\\r|\\r)$\/;\n+                print q(No infinite loop here!);\n+            ';\n+            fresh_perl_like($code, qr\/Malformed UTF-8 character\/, {},\n+                \"test that we handle some UTF-8 malformations without looping\" );\n+        }\n+\n \t{\n \t\t# [perl #123843] hits SEGV trying to compile this pattern\n \t\tmy $match;\n-- \n2.15.1-424-g9478a660812\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0854","CWE_ID":"20","category":"security","commit_id":"1f41cffe1e3e79620f587545bdfcbd7e6e68ed29","commit_message":"From 1f41cffe1e3e79620f587545bdfcbd7e6e68ed29 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sun, 11 Nov 2012 00:01:24 +0100\nSubject: [PATCH] mjpegdec: check SE.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/mjpegdec.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/mjpegdec.c b\/libavcodec\/mjpegdec.c\nindex 6b5266de58..0a71a6f5ab 100644\n--- a\/libavcodec\/mjpegdec.c\n+++ b\/libavcodec\/mjpegdec.c\n@@ -1095,6 +1095,11 @@ static int mjpeg_decode_scan_progressive_ac(MJpegDecodeContext *s, int ss,\n     int last_scan = 0;\n     int16_t *quant_matrix = s->quant_matrixes[s->quant_index[c]];\n \n+    if (se > 63) {\n+        av_log(s->avctx, AV_LOG_ERROR, \"SE %d is too large\\n\", se);\n+        return AVERROR_INVALIDDATA;\n+    }\n+\n     if (!Al) {\n         s->coefs_finished[c] |= (1LL << (se + 1)) - (1LL << ss);\n         last_scan = !~s->coefs_finished[c];\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-17204","CWE_ID":"20","category":"security","commit_id":"4af6da3b275b764b1afe194df6499b33d2bf4cde","commit_message":"From 4af6da3b275b764b1afe194df6499b33d2bf4cde Mon Sep 17 00:00:00 2001\nFrom: Ben Pfaff <blp@ovn.org>\nDate: Thu, 5 Jul 2018 15:28:51 -0700\nSubject: [PATCH] ofp-group: Don't assert-fail decoding bad OF1.5 group mod\n type or command.\n\nWhen decoding a group mod, the current code validates the group type and\ncommand after the whole group mod has been decoded.  The OF1.5 decoder,\nhowever, tries to use the type and command earlier, when it might still be\ninvalid.  This caused an assertion failure (via OVS_NOT_REACHED).  This\ncommit fixes the problem.\n\novs-vswitchd does not enable support for OpenFlow 1.5 by default.\n\nReported-at: https:\/\/bugs.chromium.org\/p\/oss-fuzz\/issues\/detail?id=9249\nSigned-off-by: Ben Pfaff <blp@ovn.org>\nReviewed-by: Yifeng Sun <pkusunyifeng@gmail.com>\n---\n lib\/ofp-util.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/lib\/ofp-util.c b\/lib\/ofp-util.c\nindex 9bf8fee2be..b961230589 100644\n--- a\/lib\/ofp-util.c\n+++ b\/lib\/ofp-util.c\n@@ -8941,7 +8941,7 @@ parse_group_prop_ntr_selection_method(struct ofpbuf *payload,\n                     \"only allowed for select groups\");\n         return OFPERR_OFPBPC_BAD_VALUE;\n     default:\n-        OVS_NOT_REACHED();\n+        return OFPERR_OFPGMFC_BAD_TYPE;\n     }\n \n     switch (group_cmd) {\n@@ -8956,7 +8956,7 @@ parse_group_prop_ntr_selection_method(struct ofpbuf *payload,\n                     \"only allowed for add and delete group modifications\");\n         return OFPERR_OFPBPC_BAD_VALUE;\n     default:\n-        OVS_NOT_REACHED();\n+        return OFPERR_OFPGMFC_BAD_COMMAND;\n     }\n \n     if (payload->size < sizeof *prop) {\n","owner":"openvswitch","repo":"ovs","source":"cve"},{"CVE_ID":"CVE-2017-5592","CWE_ID":"20","category":"security","commit_id":"8e75437a7e43d4c55e861691f74892e666e29b0b","commit_message":"From 8e75437a7e43d4c55e861691f74892e666e29b0b Mon Sep 17 00:00:00 2001\nFrom: James Booth <boothj5@gmail.com>\nDate: Mon, 23 Jan 2017 22:25:36 +0000\nSubject: [PATCH] Add carbons from check\n\n---\n src\/xmpp\/message.c                   | 9 ++++++++-\n tests\/functionaltests\/test_carbons.c | 2 +-\n 2 files changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/xmpp\/message.c b\/src\/xmpp\/message.c\nindex 9d80fb1fd..3f8ad5a0a 100644\n--- a\/src\/xmpp\/message.c\n+++ b\/src\/xmpp\/message.c\n@@ -714,6 +714,14 @@ _handle_carbons(xmpp_stanza_t *const stanza)\n         return TRUE;\n     }\n \n+    Jid *my_jid = jid_create(connection_get_fulljid());\n+    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n+    Jid *msg_jid = jid_create(stanza_from);\n+    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n+        log_warning(\"Invalid carbon received, from: %s\", stanza_from);\n+        return TRUE;\n+    }\n+\n     const gchar *to = xmpp_stanza_get_to(message);\n     const gchar *from = xmpp_stanza_get_from(message);\n \n@@ -722,7 +730,6 @@ _handle_carbons(xmpp_stanza_t *const stanza)\n \n     Jid *jid_from = jid_create(from);\n     Jid *jid_to = jid_create(to);\n-    Jid *my_jid = jid_create(connection_get_fulljid());\n \n     \/\/ check for pgp encrypted message\n     char *enc_message = NULL;\ndiff --git a\/tests\/functionaltests\/test_carbons.c b\/tests\/functionaltests\/test_carbons.c\nindex 414284ffa..7926a76fa 100644\n--- a\/tests\/functionaltests\/test_carbons.c\n+++ b\/tests\/functionaltests\/test_carbons.c\n@@ -70,7 +70,7 @@ receive_carbon(void **state)\n     assert_true(prof_output_exact(\"unencrypted\"));\n \n     stbbr_send(\n-        \"<message type='chat' to='stabber@localhost\/profanity' from='buddy1@localhost'>\"\n+        \"<message type='chat' to='stabber@localhost\/profanity' from='stabber@localhost'>\"\n             \"<received xmlns='urn:xmpp:carbons:2'>\"\n                 \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                     \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost\/profanity' from='buddy1@localhost\/mobile'>\"\n","owner":"boothj5","repo":"profanity","source":"cve"},{"CVE_ID":"CVE-2018-5391","CWE_ID":"20","category":"security","commit_id":"7969e5c40dfd04799d4341f1b7cd266b6e47f227","commit_message":"From 7969e5c40dfd04799d4341f1b7cd266b6e47f227 Mon Sep 17 00:00:00 2001\nFrom: Peter Oskolkov <posk@google.com>\nDate: Thu, 2 Aug 2018 23:34:37 +0000\nSubject: ip: discard IPv4 datagrams with overlapping segments.\n\nThis behavior is required in IPv6, and there is little need\nto tolerate overlapping fragments in IPv4. This change\nsimplifies the code and eliminates potential DDoS attack vectors.\n\nTested: ran ip_defrag selftest (not yet available uptream).\n\nSuggested-by: David S. Miller <davem@davemloft.net>\nSigned-off-by: Peter Oskolkov <posk@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Florian Westphal <fw@strlen.de>\nAcked-by: Stephen Hemminger <stephen@networkplumber.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/uapi\/linux\/snmp.h |  1 +\n net\/ipv4\/ip_fragment.c    | 75 ++++++++++++-----------------------------------\n net\/ipv4\/proc.c           |  1 +\n 3 files changed, 21 insertions(+), 56 deletions(-)\n\nFrom 385114dec8a49b5e5945e77ba7de6356106713f4 Mon Sep 17 00:00:00 2001\nFrom: Peter Oskolkov <posk@google.com>\nDate: Thu, 2 Aug 2018 23:34:38 +0000\nSubject: net: modify skb_rbtree_purge to return the truesize of all purged\n skbs.\n\nTested: see the next patch is the series.\n\nSuggested-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Peter Oskolkov <posk@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Florian Westphal <fw@strlen.de>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/linux\/skbuff.h | 2 +-\n net\/core\/skbuff.c      | 6 +++++-\n 2 files changed, 6 insertions(+), 2 deletions(-)\n\nFrom fa0f527358bd900ef92f925878ed6bfbd51305cc Mon Sep 17 00:00:00 2001\nFrom: Peter Oskolkov <posk@google.com>\nDate: Thu, 2 Aug 2018 23:34:39 +0000\nSubject: ip: use rb trees for IP frag queue.\n\nSimilar to TCP OOO RX queue, it makes sense to use rb trees to store\nIP fragments, so that OOO fragments are inserted faster.\n\nTested:\n\n- a follow-up patch contains a rather comprehensive ip defrag\n  self-test (functional)\n- ran neper `udp_stream -c -H <host> -F 100 -l 300 -T 20`:\n    netstat --statistics\n    Ip:\n        282078937 total packets received\n        0 forwarded\n        0 incoming packets discarded\n        946760 incoming packets delivered\n        18743456 requests sent out\n        101 fragments dropped after timeout\n        282077129 reassemblies required\n        944952 packets reassembled ok\n        262734239 packet reassembles failed\n   (The numbers\/stats above are somewhat better re:\n    reassemblies vs a kernel without this patchset. More\n    comprehensive performance testing TBD).\n\nReported-by: Jann Horn <jannh@google.com>\nReported-by: Juha-Matti Tilli <juha-matti.tilli@iki.fi>\nSuggested-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Peter Oskolkov <posk@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Florian Westphal <fw@strlen.de>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/linux\/skbuff.h                  |   9 +-\n include\/net\/inet_frag.h                 |   3 +-\n net\/ipv4\/inet_fragment.c                |  16 +--\n net\/ipv4\/ip_fragment.c                  | 182 ++++++++++++++++++--------------\n net\/ipv6\/netfilter\/nf_conntrack_reasm.c |   1 +\n net\/ipv6\/reassembly.c                   |   1 +\n 6 files changed, 121 insertions(+), 91 deletions(-)\n\n","diff_code":"diff --git a\/include\/uapi\/linux\/snmp.h b\/include\/uapi\/linux\/snmp.h\nindex e5ebc83827ab..f80135e5feaa 100644\n--- a\/include\/uapi\/linux\/snmp.h\n+++ b\/include\/uapi\/linux\/snmp.h\n@@ -56,6 +56,7 @@ enum\n \tIPSTATS_MIB_ECT1PKTS,\t\t\t\/* InECT1Pkts *\/\n \tIPSTATS_MIB_ECT0PKTS,\t\t\t\/* InECT0Pkts *\/\n \tIPSTATS_MIB_CEPKTS,\t\t\t\/* InCEPkts *\/\n+\tIPSTATS_MIB_REASM_OVERLAPS,\t\t\/* ReasmOverlaps *\/\n \t__IPSTATS_MIB_MAX\n };\n \ndiff --git a\/net\/ipv4\/ip_fragment.c b\/net\/ipv4\/ip_fragment.c\nindex d14d741fb05e..960bf5eab59f 100644\n--- a\/net\/ipv4\/ip_fragment.c\n+++ b\/net\/ipv4\/ip_fragment.c\n@@ -277,6 +277,7 @@ static int ip_frag_reinit(struct ipq *qp)\n \/* Add new segment to existing queue. *\/\n static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)\n {\n+\tstruct net *net = container_of(qp->q.net, struct net, ipv4.frags);\n \tstruct sk_buff *prev, *next;\n \tstruct net_device *dev;\n \tunsigned int fragsize;\n@@ -357,65 +358,23 @@ static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)\n \t}\n \n found:\n-\t\/* We found where to put this one.  Check for overlap with\n-\t * preceding fragment, and, if needed, align things so that\n-\t * any overlaps are eliminated.\n+\t\/* RFC5722, Section 4, amended by Errata ID : 3089\n+\t *                          When reassembling an IPv6 datagram, if\n+\t *   one or more its constituent fragments is determined to be an\n+\t *   overlapping fragment, the entire datagram (and any constituent\n+\t *   fragments) MUST be silently discarded.\n+\t *\n+\t * We do the same here for IPv4.\n \t *\/\n-\tif (prev) {\n-\t\tint i = (prev->ip_defrag_offset + prev->len) - offset;\n \n-\t\tif (i > 0) {\n-\t\t\toffset += i;\n-\t\t\terr = -EINVAL;\n-\t\t\tif (end <= offset)\n-\t\t\t\tgoto err;\n-\t\t\terr = -ENOMEM;\n-\t\t\tif (!pskb_pull(skb, i))\n-\t\t\t\tgoto err;\n-\t\t\tif (skb->ip_summed != CHECKSUM_UNNECESSARY)\n-\t\t\t\tskb->ip_summed = CHECKSUM_NONE;\n-\t\t}\n-\t}\n+\t\/* Is there an overlap with the previous fragment? *\/\n+\tif (prev &&\n+\t    (prev->ip_defrag_offset + prev->len) > offset)\n+\t\tgoto discard_qp;\n \n-\terr = -ENOMEM;\n-\n-\twhile (next && next->ip_defrag_offset < end) {\n-\t\tint i = end - next->ip_defrag_offset; \/* overlap is 'i' bytes *\/\n-\n-\t\tif (i < next->len) {\n-\t\t\tint delta = -next->truesize;\n-\n-\t\t\t\/* Eat head of the next overlapped fragment\n-\t\t\t * and leave the loop. The next ones cannot overlap.\n-\t\t\t *\/\n-\t\t\tif (!pskb_pull(next, i))\n-\t\t\t\tgoto err;\n-\t\t\tdelta += next->truesize;\n-\t\t\tif (delta)\n-\t\t\t\tadd_frag_mem_limit(qp->q.net, delta);\n-\t\t\tnext->ip_defrag_offset += i;\n-\t\t\tqp->q.meat -= i;\n-\t\t\tif (next->ip_summed != CHECKSUM_UNNECESSARY)\n-\t\t\t\tnext->ip_summed = CHECKSUM_NONE;\n-\t\t\tbreak;\n-\t\t} else {\n-\t\t\tstruct sk_buff *free_it = next;\n-\n-\t\t\t\/* Old fragment is completely overridden with\n-\t\t\t * new one drop it.\n-\t\t\t *\/\n-\t\t\tnext = next->next;\n-\n-\t\t\tif (prev)\n-\t\t\t\tprev->next = next;\n-\t\t\telse\n-\t\t\t\tqp->q.fragments = next;\n-\n-\t\t\tqp->q.meat -= free_it->len;\n-\t\t\tsub_frag_mem_limit(qp->q.net, free_it->truesize);\n-\t\t\tkfree_skb(free_it);\n-\t\t}\n-\t}\n+\t\/* Is there an overlap with the next fragment? *\/\n+\tif (next && next->ip_defrag_offset < end)\n+\t\tgoto discard_qp;\n \n \t\/* Note : skb->ip_defrag_offset and skb->dev share the same location *\/\n \tdev = skb->dev;\n@@ -463,6 +422,10 @@ found:\n \tskb_dst_drop(skb);\n \treturn -EINPROGRESS;\n \n+discard_qp:\n+\tinet_frag_kill(&qp->q);\n+\terr = -EINVAL;\n+\t__IP_INC_STATS(net, IPSTATS_MIB_REASM_OVERLAPS);\n err:\n \tkfree_skb(skb);\n \treturn err;\ndiff --git a\/net\/ipv4\/proc.c b\/net\/ipv4\/proc.c\nindex b46e4cf9a55a..70289682a670 100644\n--- a\/net\/ipv4\/proc.c\n+++ b\/net\/ipv4\/proc.c\n@@ -119,6 +119,7 @@ static const struct snmp_mib snmp4_ipextstats_list[] = {\n \tSNMP_MIB_ITEM(\"InECT1Pkts\", IPSTATS_MIB_ECT1PKTS),\n \tSNMP_MIB_ITEM(\"InECT0Pkts\", IPSTATS_MIB_ECT0PKTS),\n \tSNMP_MIB_ITEM(\"InCEPkts\", IPSTATS_MIB_CEPKTS),\n+\tSNMP_MIB_ITEM(\"ReasmOverlaps\", IPSTATS_MIB_REASM_OVERLAPS),\n \tSNMP_MIB_SENTINEL\n };\n \n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/include\/linux\/skbuff.h b\/include\/linux\/skbuff.h\nindex fd3cb1b247df..47848367c816 100644\n--- a\/include\/linux\/skbuff.h\n+++ b\/include\/linux\/skbuff.h\n@@ -2585,7 +2585,7 @@ static inline void __skb_queue_purge(struct sk_buff_head *list)\n \t\tkfree_skb(skb);\n }\n \n-void skb_rbtree_purge(struct rb_root *root);\n+unsigned int skb_rbtree_purge(struct rb_root *root);\n \n void *netdev_alloc_frag(unsigned int fragsz);\n \ndiff --git a\/net\/core\/skbuff.c b\/net\/core\/skbuff.c\nindex 51b0a9126e12..8d574a88125d 100644\n--- a\/net\/core\/skbuff.c\n+++ b\/net\/core\/skbuff.c\n@@ -2858,23 +2858,27 @@ EXPORT_SYMBOL(skb_queue_purge);\n \/**\n  *\tskb_rbtree_purge - empty a skb rbtree\n  *\t@root: root of the rbtree to empty\n+ *\tReturn value: the sum of truesizes of all purged skbs.\n  *\n  *\tDelete all buffers on an &sk_buff rbtree. Each buffer is removed from\n  *\tthe list and one reference dropped. This function does not take\n  *\tany lock. Synchronization should be handled by the caller (e.g., TCP\n  *\tout-of-order queue is protected by the socket lock).\n  *\/\n-void skb_rbtree_purge(struct rb_root *root)\n+unsigned int skb_rbtree_purge(struct rb_root *root)\n {\n \tstruct rb_node *p = rb_first(root);\n+\tunsigned int sum = 0;\n \n \twhile (p) {\n \t\tstruct sk_buff *skb = rb_entry(p, struct sk_buff, rbnode);\n \n \t\tp = rb_next(p);\n \t\trb_erase(&skb->rbnode, root);\n+\t\tsum += skb->truesize;\n \t\tkfree_skb(skb);\n \t}\n+\treturn sum;\n }\n \n \/**\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/include\/linux\/skbuff.h b\/include\/linux\/skbuff.h\nindex 47848367c816..7ebdf158a795 100644\n--- a\/include\/linux\/skbuff.h\n+++ b\/include\/linux\/skbuff.h\n@@ -676,13 +676,16 @@ struct sk_buff {\n \t\t\t\t * UDP receive path is one user.\n \t\t\t\t *\/\n \t\t\t\tunsigned long\t\tdev_scratch;\n-\t\t\t\tint\t\t\tip_defrag_offset;\n \t\t\t};\n \t\t};\n-\t\tstruct rb_node\t\trbnode; \/* used in netem & tcp stack *\/\n+\t\tstruct rb_node\t\trbnode; \/* used in netem, ip4 defrag, and tcp stack *\/\n \t\tstruct list_head\tlist;\n \t};\n-\tstruct sock\t\t*sk;\n+\n+\tunion {\n+\t\tstruct sock\t\t*sk;\n+\t\tint\t\t\tip_defrag_offset;\n+\t};\n \n \tunion {\n \t\tktime_t\t\ttstamp;\ndiff --git a\/include\/net\/inet_frag.h b\/include\/net\/inet_frag.h\nindex f4272a29dc44..b86d14528188 100644\n--- a\/include\/net\/inet_frag.h\n+++ b\/include\/net\/inet_frag.h\n@@ -75,7 +75,8 @@ struct inet_frag_queue {\n \tstruct timer_list\ttimer;\n \tspinlock_t\t\tlock;\n \trefcount_t\t\trefcnt;\n-\tstruct sk_buff\t\t*fragments;\n+\tstruct sk_buff\t\t*fragments;  \/* Used in IPv6. *\/\n+\tstruct rb_root\t\trb_fragments; \/* Used in IPv4. *\/\n \tstruct sk_buff\t\t*fragments_tail;\n \tktime_t\t\t\tstamp;\n \tint\t\t\tlen;\ndiff --git a\/net\/ipv4\/inet_fragment.c b\/net\/ipv4\/inet_fragment.c\nindex ccd140e4082d..6d258a5669e7 100644\n--- a\/net\/ipv4\/inet_fragment.c\n+++ b\/net\/ipv4\/inet_fragment.c\n@@ -137,12 +137,16 @@ void inet_frag_destroy(struct inet_frag_queue *q)\n \tfp = q->fragments;\n \tnf = q->net;\n \tf = nf->f;\n-\twhile (fp) {\n-\t\tstruct sk_buff *xp = fp->next;\n-\n-\t\tsum_truesize += fp->truesize;\n-\t\tkfree_skb(fp);\n-\t\tfp = xp;\n+\tif (fp) {\n+\t\tdo {\n+\t\t\tstruct sk_buff *xp = fp->next;\n+\n+\t\t\tsum_truesize += fp->truesize;\n+\t\t\tkfree_skb(fp);\n+\t\t\tfp = xp;\n+\t\t} while (fp);\n+\t} else {\n+\t\tsum_truesize = skb_rbtree_purge(&q->rb_fragments);\n \t}\n \tsum = sum_truesize + f->qsize;\n \ndiff --git a\/net\/ipv4\/ip_fragment.c b\/net\/ipv4\/ip_fragment.c\nindex 960bf5eab59f..0e8f8de77e71 100644\n--- a\/net\/ipv4\/ip_fragment.c\n+++ b\/net\/ipv4\/ip_fragment.c\n@@ -136,7 +136,7 @@ static void ip_expire(struct timer_list *t)\n {\n \tstruct inet_frag_queue *frag = from_timer(frag, t, timer);\n \tconst struct iphdr *iph;\n-\tstruct sk_buff *head;\n+\tstruct sk_buff *head = NULL;\n \tstruct net *net;\n \tstruct ipq *qp;\n \tint err;\n@@ -152,14 +152,31 @@ static void ip_expire(struct timer_list *t)\n \n \tipq_kill(qp);\n \t__IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS);\n-\n-\thead = qp->q.fragments;\n-\n \t__IP_INC_STATS(net, IPSTATS_MIB_REASMTIMEOUT);\n \n-\tif (!(qp->q.flags & INET_FRAG_FIRST_IN) || !head)\n+\tif (!qp->q.flags & INET_FRAG_FIRST_IN)\n \t\tgoto out;\n \n+\t\/* sk_buff::dev and sk_buff::rbnode are unionized. So we\n+\t * pull the head out of the tree in order to be able to\n+\t * deal with head->dev.\n+\t *\/\n+\tif (qp->q.fragments) {\n+\t\thead = qp->q.fragments;\n+\t\tqp->q.fragments = head->next;\n+\t} else {\n+\t\thead = skb_rb_first(&qp->q.rb_fragments);\n+\t\tif (!head)\n+\t\t\tgoto out;\n+\t\trb_erase(&head->rbnode, &qp->q.rb_fragments);\n+\t\tmemset(&head->rbnode, 0, sizeof(head->rbnode));\n+\t\tbarrier();\n+\t}\n+\tif (head == qp->q.fragments_tail)\n+\t\tqp->q.fragments_tail = NULL;\n+\n+\tsub_frag_mem_limit(qp->q.net, head->truesize);\n+\n \thead->dev = dev_get_by_index_rcu(net, qp->iif);\n \tif (!head->dev)\n \t\tgoto out;\n@@ -179,16 +196,16 @@ static void ip_expire(struct timer_list *t)\n \t    (skb_rtable(head)->rt_type != RTN_LOCAL))\n \t\tgoto out;\n \n-\tskb_get(head);\n \tspin_unlock(&qp->q.lock);\n \ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\n-\tkfree_skb(head);\n \tgoto out_rcu_unlock;\n \n out:\n \tspin_unlock(&qp->q.lock);\n out_rcu_unlock:\n \trcu_read_unlock();\n+\tif (head)\n+\t\tkfree_skb(head);\n \tipq_put(qp);\n }\n \n@@ -231,7 +248,7 @@ static int ip_frag_too_far(struct ipq *qp)\n \tend = atomic_inc_return(&peer->rid);\n \tqp->rid = end;\n \n-\trc = qp->q.fragments && (end - start) > max;\n+\trc = qp->q.fragments_tail && (end - start) > max;\n \n \tif (rc) {\n \t\tstruct net *net;\n@@ -245,7 +262,6 @@ static int ip_frag_too_far(struct ipq *qp)\n \n static int ip_frag_reinit(struct ipq *qp)\n {\n-\tstruct sk_buff *fp;\n \tunsigned int sum_truesize = 0;\n \n \tif (!mod_timer(&qp->q.timer, jiffies + qp->q.net->timeout)) {\n@@ -253,20 +269,14 @@ static int ip_frag_reinit(struct ipq *qp)\n \t\treturn -ETIMEDOUT;\n \t}\n \n-\tfp = qp->q.fragments;\n-\tdo {\n-\t\tstruct sk_buff *xp = fp->next;\n-\n-\t\tsum_truesize += fp->truesize;\n-\t\tkfree_skb(fp);\n-\t\tfp = xp;\n-\t} while (fp);\n+\tsum_truesize = skb_rbtree_purge(&qp->q.rb_fragments);\n \tsub_frag_mem_limit(qp->q.net, sum_truesize);\n \n \tqp->q.flags = 0;\n \tqp->q.len = 0;\n \tqp->q.meat = 0;\n \tqp->q.fragments = NULL;\n+\tqp->q.rb_fragments = RB_ROOT;\n \tqp->q.fragments_tail = NULL;\n \tqp->iif = 0;\n \tqp->ecn = 0;\n@@ -278,7 +288,8 @@ static int ip_frag_reinit(struct ipq *qp)\n static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)\n {\n \tstruct net *net = container_of(qp->q.net, struct net, ipv4.frags);\n-\tstruct sk_buff *prev, *next;\n+\tstruct rb_node **rbn, *parent;\n+\tstruct sk_buff *skb1;\n \tstruct net_device *dev;\n \tunsigned int fragsize;\n \tint flags, offset;\n@@ -341,58 +352,58 @@ static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)\n \tif (err)\n \t\tgoto err;\n \n-\t\/* Find out which fragments are in front and at the back of us\n-\t * in the chain of fragments so far.  We must know where to put\n-\t * this fragment, right?\n-\t *\/\n-\tprev = qp->q.fragments_tail;\n-\tif (!prev || prev->ip_defrag_offset < offset) {\n-\t\tnext = NULL;\n-\t\tgoto found;\n-\t}\n-\tprev = NULL;\n-\tfor (next = qp->q.fragments; next != NULL; next = next->next) {\n-\t\tif (next->ip_defrag_offset >= offset)\n-\t\t\tbreak;\t\/* bingo! *\/\n-\t\tprev = next;\n-\t}\n+\t\/* Note : skb->rbnode and skb->dev share the same location. *\/\n+\tdev = skb->dev;\n+\t\/* Makes sure compiler wont do silly aliasing games *\/\n+\tbarrier();\n \n-found:\n \t\/* RFC5722, Section 4, amended by Errata ID : 3089\n \t *                          When reassembling an IPv6 datagram, if\n \t *   one or more its constituent fragments is determined to be an\n \t *   overlapping fragment, the entire datagram (and any constituent\n \t *   fragments) MUST be silently discarded.\n \t *\n-\t * We do the same here for IPv4.\n+\t * We do the same here for IPv4 (and increment an snmp counter).\n \t *\/\n \n-\t\/* Is there an overlap with the previous fragment? *\/\n-\tif (prev &&\n-\t    (prev->ip_defrag_offset + prev->len) > offset)\n-\t\tgoto discard_qp;\n-\n-\t\/* Is there an overlap with the next fragment? *\/\n-\tif (next && next->ip_defrag_offset < end)\n-\t\tgoto discard_qp;\n+\t\/* Find out where to put this fragment.  *\/\n+\tskb1 = qp->q.fragments_tail;\n+\tif (!skb1) {\n+\t\t\/* This is the first fragment we've received. *\/\n+\t\trb_link_node(&skb->rbnode, NULL, &qp->q.rb_fragments.rb_node);\n+\t\tqp->q.fragments_tail = skb;\n+\t} else if ((skb1->ip_defrag_offset + skb1->len) < end) {\n+\t\t\/* This is the common\/special case: skb goes to the end. *\/\n+\t\t\/* Detect and discard overlaps. *\/\n+\t\tif (offset < (skb1->ip_defrag_offset + skb1->len))\n+\t\t\tgoto discard_qp;\n+\t\t\/* Insert after skb1. *\/\n+\t\trb_link_node(&skb->rbnode, &skb1->rbnode, &skb1->rbnode.rb_right);\n+\t\tqp->q.fragments_tail = skb;\n+\t} else {\n+\t\t\/* Binary search. Note that skb can become the first fragment, but\n+\t\t * not the last (covered above). *\/\n+\t\trbn = &qp->q.rb_fragments.rb_node;\n+\t\tdo {\n+\t\t\tparent = *rbn;\n+\t\t\tskb1 = rb_to_skb(parent);\n+\t\t\tif (end <= skb1->ip_defrag_offset)\n+\t\t\t\trbn = &parent->rb_left;\n+\t\t\telse if (offset >= skb1->ip_defrag_offset + skb1->len)\n+\t\t\t\trbn = &parent->rb_right;\n+\t\t\telse \/* Found an overlap with skb1. *\/\n+\t\t\t\tgoto discard_qp;\n+\t\t} while (*rbn);\n+\t\t\/* Here we have parent properly set, and rbn pointing to\n+\t\t * one of its NULL left\/right children. Insert skb. *\/\n+\t\trb_link_node(&skb->rbnode, parent, rbn);\n+\t}\n+\trb_insert_color(&skb->rbnode, &qp->q.rb_fragments);\n \n-\t\/* Note : skb->ip_defrag_offset and skb->dev share the same location *\/\n-\tdev = skb->dev;\n \tif (dev)\n \t\tqp->iif = dev->ifindex;\n-\t\/* Makes sure compiler wont do silly aliasing games *\/\n-\tbarrier();\n \tskb->ip_defrag_offset = offset;\n \n-\t\/* Insert this fragment in the chain of fragments. *\/\n-\tskb->next = next;\n-\tif (!next)\n-\t\tqp->q.fragments_tail = skb;\n-\tif (prev)\n-\t\tprev->next = skb;\n-\telse\n-\t\tqp->q.fragments = skb;\n-\n \tqp->q.stamp = skb->tstamp;\n \tqp->q.meat += skb->len;\n \tqp->ecn |= ecn;\n@@ -414,7 +425,7 @@ found:\n \t\tunsigned long orefdst = skb->_skb_refdst;\n \n \t\tskb->_skb_refdst = 0UL;\n-\t\terr = ip_frag_reasm(qp, prev, dev);\n+\t\terr = ip_frag_reasm(qp, skb, dev);\n \t\tskb->_skb_refdst = orefdst;\n \t\treturn err;\n \t}\n@@ -431,15 +442,15 @@ err:\n \treturn err;\n }\n \n-\n \/* Build a new IP datagram from all its fragments. *\/\n-\n-static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,\n+static int ip_frag_reasm(struct ipq *qp, struct sk_buff *skb,\n \t\t\t struct net_device *dev)\n {\n \tstruct net *net = container_of(qp->q.net, struct net, ipv4.frags);\n \tstruct iphdr *iph;\n-\tstruct sk_buff *fp, *head = qp->q.fragments;\n+\tstruct sk_buff *fp, *head = skb_rb_first(&qp->q.rb_fragments);\n+\tstruct sk_buff **nextp; \/* To build frag_list. *\/\n+\tstruct rb_node *rbn;\n \tint len;\n \tint ihlen;\n \tint err;\n@@ -453,25 +464,20 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,\n \t\tgoto out_fail;\n \t}\n \t\/* Make the one we just received the head. *\/\n-\tif (prev) {\n-\t\thead = prev->next;\n-\t\tfp = skb_clone(head, GFP_ATOMIC);\n+\tif (head != skb) {\n+\t\tfp = skb_clone(skb, GFP_ATOMIC);\n \t\tif (!fp)\n \t\t\tgoto out_nomem;\n-\n-\t\tfp->next = head->next;\n-\t\tif (!fp->next)\n+\t\trb_replace_node(&skb->rbnode, &fp->rbnode, &qp->q.rb_fragments);\n+\t\tif (qp->q.fragments_tail == skb)\n \t\t\tqp->q.fragments_tail = fp;\n-\t\tprev->next = fp;\n-\n-\t\tskb_morph(head, qp->q.fragments);\n-\t\thead->next = qp->q.fragments->next;\n-\n-\t\tconsume_skb(qp->q.fragments);\n-\t\tqp->q.fragments = head;\n+\t\tskb_morph(skb, head);\n+\t\trb_replace_node(&head->rbnode, &skb->rbnode,\n+\t\t\t\t&qp->q.rb_fragments);\n+\t\tconsume_skb(head);\n+\t\thead = skb;\n \t}\n \n-\tWARN_ON(!head);\n \tWARN_ON(head->ip_defrag_offset != 0);\n \n \t\/* Allocate a new buffer for the datagram. *\/\n@@ -496,24 +502,35 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,\n \t\tclone = alloc_skb(0, GFP_ATOMIC);\n \t\tif (!clone)\n \t\t\tgoto out_nomem;\n-\t\tclone->next = head->next;\n-\t\thead->next = clone;\n \t\tskb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;\n \t\tskb_frag_list_init(head);\n \t\tfor (i = 0; i < skb_shinfo(head)->nr_frags; i++)\n \t\t\tplen += skb_frag_size(&skb_shinfo(head)->frags[i]);\n \t\tclone->len = clone->data_len = head->data_len - plen;\n-\t\thead->data_len -= clone->len;\n-\t\thead->len -= clone->len;\n+\t\tskb->truesize += clone->truesize;\n \t\tclone->csum = 0;\n \t\tclone->ip_summed = head->ip_summed;\n \t\tadd_frag_mem_limit(qp->q.net, clone->truesize);\n+\t\tskb_shinfo(head)->frag_list = clone;\n+\t\tnextp = &clone->next;\n+\t} else {\n+\t\tnextp = &skb_shinfo(head)->frag_list;\n \t}\n \n-\tskb_shinfo(head)->frag_list = head->next;\n \tskb_push(head, head->data - skb_network_header(head));\n \n-\tfor (fp=head->next; fp; fp = fp->next) {\n+\t\/* Traverse the tree in order, to build frag_list. *\/\n+\trbn = rb_next(&head->rbnode);\n+\trb_erase(&head->rbnode, &qp->q.rb_fragments);\n+\twhile (rbn) {\n+\t\tstruct rb_node *rbnext = rb_next(rbn);\n+\t\tfp = rb_to_skb(rbn);\n+\t\trb_erase(rbn, &qp->q.rb_fragments);\n+\t\trbn = rbnext;\n+\t\t*nextp = fp;\n+\t\tnextp = &fp->next;\n+\t\tfp->prev = NULL;\n+\t\tmemset(&fp->rbnode, 0, sizeof(fp->rbnode));\n \t\thead->data_len += fp->len;\n \t\thead->len += fp->len;\n \t\tif (head->ip_summed != fp->ip_summed)\n@@ -524,7 +541,9 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,\n \t}\n \tsub_frag_mem_limit(qp->q.net, head->truesize);\n \n+\t*nextp = NULL;\n \thead->next = NULL;\n+\thead->prev = NULL;\n \thead->dev = dev;\n \thead->tstamp = qp->q.stamp;\n \tIPCB(head)->frag_max_size = max(qp->max_df_size, qp->q.max_size);\n@@ -552,6 +571,7 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,\n \n \t__IP_INC_STATS(net, IPSTATS_MIB_REASMOKS);\n \tqp->q.fragments = NULL;\n+\tqp->q.rb_fragments = RB_ROOT;\n \tqp->q.fragments_tail = NULL;\n \treturn 0;\n \ndiff --git a\/net\/ipv6\/netfilter\/nf_conntrack_reasm.c b\/net\/ipv6\/netfilter\/nf_conntrack_reasm.c\nindex 0610bdab721c..38d69ef516d5 100644\n--- a\/net\/ipv6\/netfilter\/nf_conntrack_reasm.c\n+++ b\/net\/ipv6\/netfilter\/nf_conntrack_reasm.c\n@@ -463,6 +463,7 @@ nf_ct_frag6_reasm(struct frag_queue *fq, struct sk_buff *prev,  struct net_devic\n \t\t\t\t\t  head->csum);\n \n \tfq->q.fragments = NULL;\n+\tfq->q.rb_fragments = RB_ROOT;\n \tfq->q.fragments_tail = NULL;\n \n \treturn true;\ndiff --git a\/net\/ipv6\/reassembly.c b\/net\/ipv6\/reassembly.c\nindex 6edd2ac8ae4b..b4e558ab39fa 100644\n--- a\/net\/ipv6\/reassembly.c\n+++ b\/net\/ipv6\/reassembly.c\n@@ -405,6 +405,7 @@ static int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,\n \t__IP6_INC_STATS(net, __in6_dev_get(dev), IPSTATS_MIB_REASMOKS);\n \trcu_read_unlock();\n \tfq->q.fragments = NULL;\n+\tfq->q.rb_fragments = RB_ROOT;\n \tfq->q.fragments_tail = NULL;\n \treturn 1;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-3215","CWE_ID":"20","category":"security","commit_id":"fbfa4d1083ea84c5429992ca3e996d7d4fbc8238","commit_message":"From fbfa4d1083ea84c5429992ca3e996d7d4fbc8238 Mon Sep 17 00:00:00 2001\nFrom: Joseph Hindin <yhindin@rehat.com>\nDate: Mon, 15 Dec 2014 23:37:23 +0200\nSubject: [PATCH] NetKVM: BZ#1169718: More rigoruous testing of incoming packet\n\nSigned-off-by: Joseph Hindin <yhindin@rehat.com>\n---\n NetKVM\/Common\/ParaNdis-Common.cpp | 10 +++++--\n NetKVM\/Common\/sw-offload.cpp      | 50 ++++++++++++++++++++++++-------\n 2 files changed, 48 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/NetKVM\/Common\/ParaNdis-Common.cpp b\/NetKVM\/Common\/ParaNdis-Common.cpp\nindex 704a2d5..799fb91 100644\n--- a\/NetKVM\/Common\/ParaNdis-Common.cpp\n+++ b\/NetKVM\/Common\/ParaNdis-Common.cpp\n@@ -2222,11 +2222,10 @@ tChecksumCheckResult ParaNdis_CheckRxChecksum(\n                                             ULONG ulDataOffset)\n {\n     tOffloadSettingsFlags f = pContext->Offload.flags;\n-    tChecksumCheckResult res, resIp;\n+    tChecksumCheckResult res;\n     tTcpIpPacketParsingResult ppr;\n     ULONG flagsToCalculate = 0;\n     res.value = 0;\n-    resIp.value = 0;\n \n     \/\/VIRTIO_NET_HDR_F_NEEDS_CSUM - we need to calculate TCP\/UDP CS\n     \/\/VIRTIO_NET_HDR_F_DATA_VALID - host tells us TCP\/UDP CS is OK\n@@ -2250,6 +2249,13 @@ tChecksumCheckResult ParaNdis_CheckRxChecksum(\n \n     ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__);\n \n+    if (ppr.ipCheckSum == ppresIPTooShort || ppr.xxpStatus == ppresXxpIncomplete)\n+    {\n+        res.flags.IpOK = FALSE;\n+        res.flags.IpFailed = TRUE;\n+        return res;\n+    }\n+\n     if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)\n     {\n         pContext->extraStatistics.framesRxCSHwOK++;\ndiff --git a\/NetKVM\/Common\/sw-offload.cpp b\/NetKVM\/Common\/sw-offload.cpp\nindex 0076c08..f2e9045 100644\n--- a\/NetKVM\/Common\/sw-offload.cpp\n+++ b\/NetKVM\/Common\/sw-offload.cpp\n@@ -156,19 +156,21 @@ ProcessTCPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USH\n     ULONG tcpipDataAt;\n     tTcpIpPacketParsingResult res = _res;\n     tcpipDataAt = ipHeaderSize + sizeof(TCPHeader);\n-    res.xxpStatus = ppresXxpIncomplete;\n     res.TcpUdp = ppresIsTCP;\n \n     if (len >= tcpipDataAt)\n     {\n         TCPHeader *pTcpHeader = (TCPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);\n         res.xxpStatus = ppresXxpKnown;\n+        res.xxpFull = TRUE;\n         tcpipDataAt = ipHeaderSize + TCP_HEADER_LENGTH(pTcpHeader);\n         res.XxpIpHeaderSize = tcpipDataAt;\n     }\n     else\n     {\n         DPrintf(2, (\"tcp: %d < min headers %d\\n\", len, tcpipDataAt));\n+        res.xxpFull = FALSE;\n+        res.xxpStatus = ppresXxpIncomplete;\n     }\n     return res;\n }\n@@ -178,7 +180,6 @@ ProcessUDPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USH\n {\n     tTcpIpPacketParsingResult res = _res;\n     ULONG udpDataStart = ipHeaderSize + sizeof(UDPHeader);\n-    res.xxpStatus = ppresXxpIncomplete;\n     res.TcpUdp = ppresIsUDP;\n     res.XxpIpHeaderSize = udpDataStart;\n     if (len >= udpDataStart)\n@@ -186,9 +187,15 @@ ProcessUDPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USH\n         UDPHeader *pUdpHeader = (UDPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize);\n         USHORT datagramLength = swap_short(pUdpHeader->udp_length);\n         res.xxpStatus = ppresXxpKnown;\n+        res.xxpFull = TRUE;\n         \/\/ may be full or not, but the datagram length is known\n         DPrintf(2, (\"udp: len %d, datagramLength %d\\n\", len, datagramLength));\n     }\n+    else\n+    {\n+        res.xxpFull = FALSE;\n+        res.xxpStatus = ppresXxpIncomplete;\n+    }\n     return res;\n }\n \n@@ -196,24 +203,44 @@ static __inline tTcpIpPacketParsingResult\n QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n {\n     tTcpIpPacketParsingResult res;\n+    res.value = 0;\n+\n+    if (len < 4)\n+    {\n+        res.ipStatus = ppresNotIP;\n+        return res;\n+    }\n+\n     UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n     UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n     USHORT ipHeaderSize = 0;\n     USHORT fullLength = 0;\n     res.value = 0;\n-    \n+\n     if (ip_version == 4)\n     {\n+        if (len < sizeof(IPv4Header))\n+        {\n+            res.ipStatus = ppresNotIP;\n+            return res;\n+        }\n         ipHeaderSize = (ver_len & 0xF) << 2;\n         fullLength = swap_short(pIpHeader->v4.ip_length);\n-        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\n-            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength));\n+        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n+            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n+\n         res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n-        if (len < ipHeaderSize) res.ipCheckSum = ppresIPTooShort;\n-        if (fullLength) {}\n-        else\n+        if (res.ipStatus == ppresNotIP)\n         {\n-            DPrintf(2, (\"ip v.%d, iplen %d\\n\", ip_version, fullLength));\n+            return res;\n+        }\n+\n+        if (ipHeaderSize >= fullLength || len < fullLength)\n+        {\n+            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n+                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n+            res.ipCheckSum = ppresIPTooShort;\n+            return res;\n         }\n     }\n     else if (ip_version == 6)\n@@ -291,7 +318,7 @@ QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n     if (res.ipStatus == ppresIPV4)\n     {\n         res.ipHeaderSize = ipHeaderSize;\n-        res.xxpFull = len >= fullLength ? 1 : 0;\n+\n         \/\/ bit \"more fragments\" or fragment offset mean the packet is fragmented\n         res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n         switch (pIpHeader->v4.ip_protocol)\n@@ -615,6 +642,9 @@ tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n     IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n \n     tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength);\n+    if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)\n+        return res;\n+\n     if (res.ipStatus == ppresIPV4)\n     {\n         if (flags & pcrIpChecksum)\n","owner":"YanVugenfirer","repo":"kvm-guest-drivers-windows","source":"cve"},{"CVE_ID":"CVE-2016-4538","CWE_ID":"20","category":"security","commit_id":"d650063a0457aec56364e4005a636dc6c401f9cd","commit_message":"From d650063a0457aec56364e4005a636dc6c401f9cd Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 24 Apr 2016 18:33:32 -0700\nSubject: [PATCH] Fix bug #72093: bcpowmod accepts negative scale and corrupts\n _one_ definition\n\nWe can not modify result since it can be copy of _zero_ or _one_, etc. and\n\"copy\" in bcmath is just bumping the refcount.\n---\n ext\/bcmath\/bcmath.c            | 60 +++++++++++++++++++++++++++++-------------\n ext\/bcmath\/tests\/bug72093.phpt | 13 +++++++++\n main\/php_version.h             |  6 ++---\n 3 files changed, 57 insertions(+), 22 deletions(-)\n create mode 100644 ext\/bcmath\/tests\/bug72093.phpt\n\n","diff_code":"diff --git a\/ext\/bcmath\/bcmath.c b\/ext\/bcmath\/bcmath.c\nindex 02177e4..dd691159 100644\n--- a\/ext\/bcmath\/bcmath.c\n+++ b\/ext\/bcmath\/bcmath.c\n@@ -201,6 +201,21 @@ static void php_str2num(bc_num *num, char *str TSRMLS_DC)\n }\n \/* }}} *\/\n \n+\/* {{{ split_bc_num\n+   Convert to bc_num detecting scale *\/\n+static bc_num split_bc_num(bc_num num) {\n+\tbc_num newnum;\n+\tif (num->n_refs >= 1) {\n+\t\treturn num;\n+\t}\n+\tnewnum = _bc_new_num_ex(0, 0, 0);\n+\t*newnum = *num;\n+\tnewnum->n_refs = 1;\n+\tnum->n_refs--;\n+\treturn newnum;\n+}\n+\/* }}} *\/\n+\n \/* {{{ proto string bcadd(string left_operand, string right_operand [, int scale])\n    Returns the sum of two arbitrary precision numbers *\/\n PHP_FUNCTION(bcadd)\n@@ -214,7 +229,7 @@ PHP_FUNCTION(bcadd)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n@@ -225,11 +240,12 @@ PHP_FUNCTION(bcadd)\n \tphp_str2num(&first, left TSRMLS_CC);\n \tphp_str2num(&second, right TSRMLS_CC);\n \tbc_add (first, second, &result, scale);\n-\t\n+\n \tif (result->n_scale > scale) {\n+\t\tresult = split_bc_num(result);\n \t\tresult->n_scale = scale;\n \t}\n-\t\n+\n \tZ_STRVAL_P(return_value) = bc_num2str(result);\n \tZ_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));\n \tZ_TYPE_P(return_value) = IS_STRING;\n@@ -253,7 +269,7 @@ PHP_FUNCTION(bcsub)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n@@ -266,6 +282,7 @@ PHP_FUNCTION(bcsub)\n \tbc_sub (first, second, &result, scale);\n \n \tif (result->n_scale > scale) {\n+\t\tresult = split_bc_num(result);\n \t\tresult->n_scale = scale;\n \t}\n \n@@ -292,11 +309,11 @@ PHP_FUNCTION(bcmul)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n-\t\n+\n \tbc_init_num(&first TSRMLS_CC);\n \tbc_init_num(&second TSRMLS_CC);\n \tbc_init_num(&result TSRMLS_CC);\n@@ -305,6 +322,7 @@ PHP_FUNCTION(bcmul)\n \tbc_multiply (first, second, &result, scale TSRMLS_CC);\n \n \tif (result->n_scale > scale) {\n+\t\tresult = split_bc_num(result);\n \t\tresult->n_scale = scale;\n \t}\n \n@@ -331,11 +349,11 @@ PHP_FUNCTION(bcdiv)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n-\t\n+\n \tbc_init_num(&first TSRMLS_CC);\n \tbc_init_num(&second TSRMLS_CC);\n \tbc_init_num(&result TSRMLS_CC);\n@@ -345,6 +363,7 @@ PHP_FUNCTION(bcdiv)\n \tswitch (bc_divide(first, second, &result, scale TSRMLS_CC)) {\n \t\tcase 0: \/* OK *\/\n \t\t\tif (result->n_scale > scale) {\n+\t\t\t\tresult = split_bc_num(result);\n \t\t\t\tresult->n_scale = scale;\n \t\t\t}\n \t\t\tZ_STRVAL_P(return_value) = bc_num2str(result);\n@@ -374,13 +393,13 @@ PHP_FUNCTION(bcmod)\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &left, &left_len, &right, &right_len) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tbc_init_num(&first TSRMLS_CC);\n \tbc_init_num(&second TSRMLS_CC);\n \tbc_init_num(&result TSRMLS_CC);\n \tbc_str2num(&first, left, 0 TSRMLS_CC);\n \tbc_str2num(&second, right, 0 TSRMLS_CC);\n-\t\n+\n \tswitch (bc_modulo(first, second, &result, 0 TSRMLS_CC)) {\n \t\tcase 0:\n \t\t\tZ_STRVAL_P(return_value) = bc_num2str(result);\n@@ -391,7 +410,7 @@ PHP_FUNCTION(bcmod)\n \t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Division by zero\");\n \t\t\tbreak;\n \t}\n-\t\n+\n \tbc_free_num(&first);\n \tbc_free_num(&second);\n \tbc_free_num(&result);\n@@ -424,8 +443,9 @@ PHP_FUNCTION(bcpowmod)\n \tscale_int = (int) ((int)scale < 0) ? 0 : scale;\n \n \tif (bc_raisemod(first, second, mod, &result, scale_int TSRMLS_CC) != -1) {\n-\t\tif (result->n_scale > scale) {\n-\t\t\tresult->n_scale = scale;\n+\t\tif (result->n_scale > scale_int) {\n+\t\t\tresult = split_bc_num(result);\n+\t\t\tresult->n_scale = scale_int;\n \t\t}\n \t\tZ_STRVAL_P(return_value) = bc_num2str(result);\n \t\tZ_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));\n@@ -433,7 +453,7 @@ PHP_FUNCTION(bcpowmod)\n \t} else {\n \t\tRETVAL_FALSE;\n \t}\n-\t\n+\n \tbc_free_num(&first);\n \tbc_free_num(&second);\n \tbc_free_num(&mod);\n@@ -455,7 +475,7 @@ PHP_FUNCTION(bcpow)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n@@ -468,6 +488,7 @@ PHP_FUNCTION(bcpow)\n \tbc_raise (first, second, &result, scale TSRMLS_CC);\n \n \tif (result->n_scale > scale) {\n+\t\tresult = split_bc_num(result);\n \t\tresult->n_scale = scale;\n \t}\n \n@@ -494,16 +515,17 @@ PHP_FUNCTION(bcsqrt)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"s|l\", &left, &left_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 2) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n \n \tbc_init_num(&result TSRMLS_CC);\n \tphp_str2num(&result, left TSRMLS_CC);\n-\t\n+\n \tif (bc_sqrt (&result, scale TSRMLS_CC) != 0) {\n \t\tif (result->n_scale > scale) {\n+\t\t\tresult = split_bc_num(result);\n \t\t\tresult->n_scale = scale;\n \t\t}\n \t\tZ_STRVAL_P(return_value) = bc_num2str(result);\n@@ -531,7 +553,7 @@ PHP_FUNCTION(bccomp)\n \tif (zend_parse_parameters(argc TSRMLS_CC, \"ss|l\", &left, &left_len, &right, &right_len, &scale_param) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n+\n \tif (argc == 3) {\n \t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n \t}\n@@ -555,7 +577,7 @@ PHP_FUNCTION(bccomp)\n PHP_FUNCTION(bcscale)\n {\n \tlong new_scale;\n-\t\n+\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &new_scale) == FAILURE) {\n \t\treturn;\n \t}\ndiff --git a\/ext\/bcmath\/tests\/bug72093.phpt b\/ext\/bcmath\/tests\/bug72093.phpt\nnew file mode 100644\nindex 0000000..be664b8\n--- \/dev\/null\n+++ b\/ext\/bcmath\/tests\/bug72093.phpt\n@@ -0,0 +1,13 @@\n+--TEST--\n+Bug 72093: bcpowmod accepts negative scale and corrupts _one_ definition\n+--SKIPIF--\n+<?php if(!extension_loaded(\"bcmath\")) print \"skip\"; ?>\n+--FILE--\n+<?php\n+var_dump(bcpowmod(1, \"A\", 128, -200));\n+var_dump(bcpowmod(1, 1.2, 1, 1));\n+?>\n+--EXPECTF--\n+string(1) \"1\"\n+bc math warning: non-zero scale in exponent\n+string(3) \"0.0\"\ndiff --git a\/main\/php_version.h b\/main\/php_version.h\nindex f87cc38..4ebff7f 100644\n--- a\/main\/php_version.h\n+++ b\/main\/php_version.h\n@@ -2,7 +2,7 @@\n \/* edit configure.in to change version number *\/\n #define PHP_MAJOR_VERSION 5\n #define PHP_MINOR_VERSION 5\n-#define PHP_RELEASE_VERSION 35\n+#define PHP_RELEASE_VERSION 27\n #define PHP_EXTRA_VERSION \"-dev\"\n-#define PHP_VERSION \"5.5.35-dev\"\n-#define PHP_VERSION_ID 50535\n+#define PHP_VERSION \"5.5.27-dev\"\n+#define PHP_VERSION_ID 50527\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-7162","CWE_ID":"20","category":"security","commit_id":"f70be1f41688859ec8dbe266df35a1839ceb96c5","commit_message":"From f70be1f41688859ec8dbe266df35a1839ceb96c5 Mon Sep 17 00:00:00 2001\nFrom: Paolo Bacchilega <paobac@src.gnome.org>\nDate: Wed, 17 Aug 2016 15:41:35 +0200\nSubject: [PATCH] do not follow symlinks when deleting a folder recursively\n\n[bug #698554]\n---\n src\/file-utils.c | 5 ++---\n 1 file changed, 2 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/src\/file-utils.c b\/src\/file-utils.c\nindex a60fca25..bddf894e 100644\n--- a\/src\/file-utils.c\n+++ b\/src\/file-utils.c\n@@ -411,9 +411,8 @@ _g_file_remove_directory (GFile         *directory,\n \t\treturn TRUE;\n \n \tenumerator = g_file_enumerate_children (directory,\n-\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n-\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_TYPE,\n-\t\t\t\t\t        0,\n+\t\t\t\t\t        G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_TYPE,\n+\t\t\t\t\t\tG_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n \t\t\t\t\t        cancellable,\n \t\t\t\t\t        error);\n \n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-1000252","CWE_ID":"20","category":"security","commit_id":"3a8b0677fc6180a467e26cc32ce6b0c09a32f9bb","commit_message":"From 3a8b0677fc6180a467e26cc32ce6b0c09a32f9bb Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Jan=20H=2E=20Sch=C3=B6nherr?= <jschoenh@amazon.de>\nDate: Thu, 7 Sep 2017 19:02:30 +0100\nSubject: KVM: VMX: Do not BUG() on out-of-bounds guest IRQ\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThe value of the guest_irq argument to vmx_update_pi_irte() is\nultimately coming from a KVM_IRQFD API call. Do not BUG() in\nvmx_update_pi_irte() if the value is out-of bounds. (Especially,\nsince KVM as a whole seems to hang after that.)\n\nInstead, print a message only once if we find that we don't have a\nroute for a certain IRQ (which can be out-of-bounds or within the\narray).\n\nThis fixes CVE-2017-1000252.\n\nFixes: efc644048ecde54 (\"KVM: x86: Update IRTE for posted-interrupts\")\nSigned-off-by: Jan H. Sch\u00f6nherr <jschoenh@amazon.de>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/vmx.c | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex 8e1ae716f938..0b15b43ef45d 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -11834,7 +11834,7 @@ static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n \tstruct kvm_lapic_irq irq;\n \tstruct kvm_vcpu *vcpu;\n \tstruct vcpu_data vcpu_info;\n-\tint idx, ret = -EINVAL;\n+\tint idx, ret = 0;\n \n \tif (!kvm_arch_has_assigned_device(kvm) ||\n \t\t!irq_remapping_cap(IRQ_POSTING_CAP) ||\n@@ -11843,7 +11843,12 @@ static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n \n \tidx = srcu_read_lock(&kvm->irq_srcu);\n \tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n-\tBUG_ON(guest_irq >= irq_rt->nr_rt_entries);\n+\tif (guest_irq >= irq_rt->nr_rt_entries ||\n+\t    hlist_empty(&irq_rt->map[guest_irq])) {\n+\t\tpr_warn_once(\"no route for guest_irq %u\/%u (broken user space?)\\n\",\n+\t\t\t     guest_irq, irq_rt->nr_rt_entries);\n+\t\tgoto out;\n+\t}\n \n \thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n \t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-1155","CWE_ID":"20","category":"security","commit_id":"85bbc05b21678e80423815d2ef1dfe26208491ab","commit_message":"From 85bbc05b21678e80423815d2ef1dfe26208491ab Mon Sep 17 00:00:00 2001\nFrom: coekie <coekie@dbcabf3a-b0e7-0310-adc4-f8d773084564>\nDate: Mon, 28 Dec 2009 12:15:18 +0000\nSubject: [PATCH] Check if an SSL certificate matches the hostname of the\n server we are connecting to\n\ngit-svn-id: http:\/\/svn.irssi.org\/repos\/irssi\/trunk@5104 dbcabf3a-b0e7-0310-adc4-f8d773084564\n---\n src\/core\/network-openssl.c | 157 +++++++++++++++++++++++++++++++++++--\n src\/core\/network.h         |   2 +-\n src\/core\/servers.c         |   2 +-\n 3 files changed, 154 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/src\/core\/network-openssl.c b\/src\/core\/network-openssl.c\nindex 92832ba..5a9c9bc 100644\n--- a\/src\/core\/network-openssl.c\n+++ b\/src\/core\/network-openssl.c\n@@ -26,6 +26,7 @@\n \n #include <openssl\/crypto.h>\n #include <openssl\/x509.h>\n+#include <openssl\/x509v3.h>\n #include <openssl\/pem.h>\n #include <openssl\/ssl.h>\n #include <openssl\/err.h>\n@@ -39,6 +40,7 @@ typedef struct\n \tSSL *ssl;\n \tSSL_CTX *ctx;\n \tunsigned int verify:1;\n+\tconst char *hostname;\n } GIOSSLChannel;\n \n static SSL_CTX *ssl_ctx = NULL;\n@@ -53,7 +55,149 @@ static void irssi_ssl_free(GIOChannel *handle)\n \tg_free(chan);\n }\n \n-static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)\n+\/* Checks if the given string has internal NUL characters. *\/\n+static gboolean has_internal_nul(const char* str, int len) {\n+\t\/* Remove trailing nul characters. They would give false alarms *\/\n+\twhile (len > 0 && str[len-1] == 0)\n+\t\tlen--;\n+\treturn strlen(str) != len;\n+}\n+\n+\/* tls_dns_name - Extract valid DNS name from subjectAltName value *\/\n+static const char *tls_dns_name(const GENERAL_NAME * gn)\n+{\n+\tconst char *dnsname;\n+\n+\t\/* We expect the OpenSSL library to construct GEN_DNS extension objects as\n+\t   ASN1_IA5STRING values. Check we got the right union member. *\/\n+\tif (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {\n+\t\tg_warning(\"Invalid ASN1 value type in subjectAltName\");\n+\t\treturn NULL;\n+\t}\n+\n+\t\/* Safe to treat as an ASCII string possibly holding a DNS name *\/\n+\tdnsname = (char *) ASN1_STRING_data(gn->d.ia5);\n+\n+\tif (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {\n+\t\tg_warning(\"Internal NUL in subjectAltName\");\n+\t\treturn NULL;\n+\t}\n+\n+\treturn dnsname;\n+}\n+\n+\/* tls_text_name - extract certificate property value by name *\/\n+static char *tls_text_name(X509_NAME *name, int nid)\n+{\n+\tint     pos;\n+\tX509_NAME_ENTRY *entry;\n+\tASN1_STRING *entry_str;\n+\tint     utf8_length;\n+\tunsigned char *utf8_value;\n+\tchar *result;\n+\n+\tif (name == 0 || (pos = X509_NAME_get_index_by_NID(name, nid, -1)) < 0) {\n+\t\treturn NULL;\n+    }\n+\n+    entry = X509_NAME_get_entry(name, pos);\n+    g_return_val_if_fail(entry != NULL, NULL);\n+    entry_str = X509_NAME_ENTRY_get_data(entry);\n+    g_return_val_if_fail(entry_str != NULL, NULL);\n+\n+    \/* Convert everything into UTF-8. It's up to OpenSSL to do something\n+\t   reasonable when converting ASCII formats that contain non-ASCII\n+\t   content. *\/\n+    if ((utf8_length = ASN1_STRING_to_UTF8(&utf8_value, entry_str)) < 0) {\n+    \tg_warning(\"Error decoding ASN.1 type=%d\", ASN1_STRING_type(entry_str));\n+    \treturn NULL;\n+    }\n+\n+    if (has_internal_nul((char *)utf8_value, utf8_length)) {\n+    \tg_warning(\"NUL character in hostname in certificate\");\n+    \tOPENSSL_free(utf8_value);\n+    \treturn NULL;\n+    }\n+\n+    result = g_strdup((char *) utf8_value);\n+\tOPENSSL_free(utf8_value);\n+\treturn result;\n+}\n+\n+\n+\/** check if a hostname in the certificate matches the hostname we used for the connection *\/\n+static gboolean match_hostname(const char *cert_hostname, const char *hostname)\n+{\n+\tconst char *hostname_left;\n+\n+\tif (!strcasecmp(cert_hostname, hostname)) { \/* exact match *\/\n+\t\treturn TRUE;\n+\t} else if (cert_hostname[0] == '*' && cert_hostname[1] == '.' && cert_hostname[2] != 0) { \/* wildcard match *\/\n+\t\t\/* The initial '*' matches exactly one hostname component *\/\n+\t\thostname_left = strchr(hostname, '.');\n+\t\tif (hostname_left != NULL && ! strcasecmp(hostname_left + 1, cert_hostname + 2)) {\n+\t\t\treturn TRUE;\n+\t\t}\n+\t}\n+\treturn FALSE;\n+}\n+\n+\/* based on verify_extract_name from tls_client.c in postfix *\/\n+static gboolean irssi_ssl_verify_hostname(X509 *cert, const char *hostname)\n+{\n+\tint gen_index, gen_count;\n+\tgboolean matched = FALSE, has_dns_name = FALSE;\n+\tconst char *cert_dns_name;\n+\tchar *cert_subject_cn;\n+\tconst GENERAL_NAME *gn;\n+\tSTACK_OF(GENERAL_NAME) * gens;\n+\n+\t\/* Verify the dNSName(s) in the peer certificate against the hostname. *\/\n+\tgens = X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0);\n+\tif (gens) {\n+\t\tgen_count = sk_GENERAL_NAME_num(gens);\n+\t\tfor (gen_index = 0; gen_index < gen_count && !matched; ++gen_index) {\n+\t\t\tgn = sk_GENERAL_NAME_value(gens, gen_index);\n+\t\t\tif (gn->type != GEN_DNS)\n+\t\t\t\tcontinue;\n+\n+\t\t\t\/* Even if we have an invalid DNS name, we still ultimately\n+\t\t\t   ignore the CommonName, because subjectAltName:DNS is\n+\t\t\t   present (though malformed). *\/\n+\t\t\thas_dns_name = TRUE;\n+\t\t\tcert_dns_name = tls_dns_name(gn);\n+\t\t\tif (cert_dns_name && *cert_dns_name) {\n+\t\t\t\tmatched = match_hostname(cert_dns_name, hostname);\n+\t\t\t}\n+    \t}\n+\n+\t    \/* Free stack *and* member GENERAL_NAME objects *\/\n+\t    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n+\t}\n+\n+\tif (has_dns_name) {\n+\t\tif (! matched) {\n+\t\t\t\/* The CommonName in the issuer DN is obsolete when SubjectAltName is available. *\/\n+\t\t\tg_warning(\"None of the Subject Alt Names in the certificate match hostname '%s'\", hostname);\n+\t\t}\n+\t\treturn matched;\n+\t} else { \/* No subjectAltNames, look at CommonName *\/\n+\t\tcert_subject_cn = tls_text_name(X509_get_subject_name(cert), NID_commonName);\n+\t    if (cert_subject_cn && *cert_subject_cn) {\n+\t    \tmatched = match_hostname(cert_subject_cn, hostname);\n+\t    \tif (! matched) {\n+\t\t\t\tg_warning(\"SSL certificate common name '%s' doesn't match host name '%s'\", cert_subject_cn, hostname);\n+\t    \t}\n+\t    } else {\n+\t    \tg_warning(\"No subjectAltNames and no valid common name in certificate\");\n+\t    }\n+\t    free(cert_subject_cn);\n+\t}\n+\n+\treturn matched;\n+}\n+\n+static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, const char* hostname, X509 *cert)\n {\n \tif (SSL_get_verify_result(ssl) != X509_V_OK) {\n \t\tunsigned char md[EVP_MAX_MD_SIZE];\n@@ -89,6 +233,8 @@ static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)\n \t\t\t}\n \t\t}\n \t\treturn FALSE;\n+\t} else if (! irssi_ssl_verify_hostname(cert, hostname)){\n+\t\treturn FALSE;\n \t}\n \treturn TRUE;\n }\n@@ -241,7 +387,7 @@ static gboolean irssi_ssl_init(void)\n \n }\n \n-static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *mycert, const char *mypkey, const char *cafile, const char *capath, gboolean verify)\n+static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *hostname, const char *mycert, const char *mypkey, const char *cafile, const char *capath, gboolean verify)\n {\n \tGIOSSLChannel *chan;\n \tGIOChannel *gchan;\n@@ -326,6 +472,7 @@ static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *mycer\n \tchan->ssl = ssl;\n \tchan->ctx = ctx;\n \tchan->verify = verify;\n+\tchan->hostname = hostname;\n \n \tgchan = (GIOChannel *)chan;\n \tgchan->funcs = &irssi_ssl_channel_funcs;\n@@ -336,14 +483,14 @@ static GIOChannel *irssi_ssl_get_iochannel(GIOChannel *handle, const char *mycer\n \treturn gchan;\n }\n \n-GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n+GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n {\n \tGIOChannel *handle, *ssl_handle;\n \n \thandle = net_connect_ip(ip, port, my_ip);\n \tif (handle == NULL)\n \t\treturn NULL;\n-\tssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);\n+\tssl_handle  = irssi_ssl_get_iochannel(handle, hostname, cert, pkey, cafile, capath, verify);\n \tif (ssl_handle == NULL)\n \t\tg_io_channel_unref(handle);\n \treturn ssl_handle;\n@@ -385,7 +532,7 @@ int irssi_ssl_handshake(GIOChannel *handle)\n \t\tg_warning(\"SSL server supplied no certificate\");\n \t\treturn -1;\n \t}\n-\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);\n+\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, chan->hostname, cert);\n \tX509_free(cert);\n \treturn ret ? 0 : -1;\n }\ndiff --git a\/src\/core\/network.h b\/src\/core\/network.h\nindex 65505ea..8583724 100644\n--- a\/src\/core\/network.h\n+++ b\/src\/core\/network.h\n@@ -47,7 +47,7 @@ int net_ip_compare(IPADDR *ip1, IPADDR *ip2);\n \/* Connect to socket *\/\n GIOChannel *net_connect(const char *addr, int port, IPADDR *my_ip);\n \/* Connect to socket with ip address and SSL*\/\n-GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify);\n+GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify);\n int irssi_ssl_handshake(GIOChannel *handle);\n \/* Connect to socket with ip address *\/\n GIOChannel *net_connect_ip(IPADDR *ip, int port, IPADDR *my_ip);\ndiff --git a\/src\/core\/servers.c b\/src\/core\/servers.c\nindex d5844e7..017a203 100644\n--- a\/src\/core\/servers.c\n+++ b\/src\/core\/servers.c\n@@ -224,7 +224,7 @@ static void server_real_connect(SERVER_REC *server, IPADDR *ip,\n \t\tport = server->connrec->proxy != NULL ?\n \t\t\tserver->connrec->proxy_port : server->connrec->port;\n \t\thandle = server->connrec->use_ssl ?\n-\t\t\tnet_connect_ip_ssl(ip, port, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\n+\t\t\tnet_connect_ip_ssl(ip, port, server->connrec->address, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\n server->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\n \t\t\tnet_connect_ip(ip, port, own_ip);\n \t} else {\n","owner":"ensc","repo":"irssi-proxy","source":"cve"},{"CVE_ID":"CVE-2015-1787","CWE_ID":"20","category":"security","commit_id":"b19d8143212ae5fbc9cebfd51c01f802fabccd33","commit_message":"From b19d8143212ae5fbc9cebfd51c01f802fabccd33 Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Tue, 10 Mar 2015 16:38:32 +0000\nSubject: [PATCH] Fix DHE Null CKE vulnerability\n\nIf client auth is used then a server can seg fault in the event of a DHE\ncipher being used and a zero length ClientKeyExchange message being sent\nby the client. This could be exploited in a DoS attack.\n\nCVE-2015-1787\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\n---\n ssl\/s3_srvr.c | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/ssl\/s3_srvr.c b\/ssl\/s3_srvr.c\nindex 9e6ab0136a..c016139b1d 100644\n--- a\/ssl\/s3_srvr.c\n+++ b\/ssl\/s3_srvr.c\n@@ -2251,10 +2251,17 @@ int ssl3_get_client_key_exchange(SSL *s)\n     if (alg_k & (SSL_kEDH | SSL_kDHr | SSL_kDHd)) {\n         int idx = -1;\n         EVP_PKEY *skey = NULL;\n-        if (n)\n+        if (n > 1) {\n             n2s(p, i);\n-        else\n+        } else {\n+            if (alg_k & SSL_kDHE) {\n+                al = SSL_AD_HANDSHAKE_FAILURE;\n+                SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\n+                       SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG);\n+                goto f_err;\n+            }\n             i = 0;\n+        }\n         if (n && n != i + 2) {\n             if (!(s->options & SSL_OP_SSLEAY_080_CLIENT_DH_BUG)) {\n                 SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-5472","CWE_ID":"20","category":"security","commit_id":"410dd3cf4c9b36f27ed4542ee18b1af5e68645a4","commit_message":"From 410dd3cf4c9b36f27ed4542ee18b1af5e68645a4 Mon Sep 17 00:00:00 2001\nFrom: Jan Kara <jack@suse.cz>\nDate: Sun, 17 Aug 2014 11:49:57 +0200\nSubject: [PATCH] isofs: Fix unbounded recursion when processing relocated\n directories\n\nWe did not check relocated directory in any way when processing Rock\nRidge 'CL' tag. Thus a corrupted isofs image can possibly have a CL\nentry pointing to another CL entry leading to possibly unbounded\nrecursion in kernel code and thus stack overflow or deadlocks (if there\nis a loop created from CL entries).\n\nFix the problem by not allowing CL entry to point to a directory entry\nwith CL entry (such use makes no good sense anyway) and by checking\nwhether CL entry doesn't point to itself.\n\nCC: stable@vger.kernel.org\nReported-by: Chris Evans <cevans@google.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\n---\n fs\/isofs\/inode.c | 15 ++++++++-------\n fs\/isofs\/isofs.h | 23 +++++++++++++++++++----\n fs\/isofs\/rock.c  | 39 ++++++++++++++++++++++++++++-----------\n 3 files changed, 55 insertions(+), 22 deletions(-)\n\n","diff_code":"diff --git a\/fs\/isofs\/inode.c b\/fs\/isofs\/inode.c\nindex 4556ce1af5b04..5ddaf8625d3b7 100644\n--- a\/fs\/isofs\/inode.c\n+++ b\/fs\/isofs\/inode.c\n@@ -61,7 +61,7 @@ static void isofs_put_super(struct super_block *sb)\n \treturn;\n }\n \n-static int isofs_read_inode(struct inode *);\n+static int isofs_read_inode(struct inode *, int relocated);\n static int isofs_statfs (struct dentry *, struct kstatfs *);\n \n static struct kmem_cache *isofs_inode_cachep;\n@@ -1259,7 +1259,7 @@ static int isofs_read_level3_size(struct inode *inode)\n \tgoto out;\n }\n \n-static int isofs_read_inode(struct inode *inode)\n+static int isofs_read_inode(struct inode *inode, int relocated)\n {\n \tstruct super_block *sb = inode->i_sb;\n \tstruct isofs_sb_info *sbi = ISOFS_SB(sb);\n@@ -1404,7 +1404,7 @@ static int isofs_read_inode(struct inode *inode)\n \t *\/\n \n \tif (!high_sierra) {\n-\t\tparse_rock_ridge_inode(de, inode);\n+\t\tparse_rock_ridge_inode(de, inode, relocated);\n \t\t\/* if we want uid\/gid set, override the rock ridge setting *\/\n \t\tif (sbi->s_uid_set)\n \t\t\tinode->i_uid = sbi->s_uid;\n@@ -1483,9 +1483,10 @@ static int isofs_iget5_set(struct inode *ino, void *data)\n  * offset that point to the underlying meta-data for the inode.  The\n  * code below is otherwise similar to the iget() code in\n  * include\/linux\/fs.h *\/\n-struct inode *isofs_iget(struct super_block *sb,\n-\t\t\t unsigned long block,\n-\t\t\t unsigned long offset)\n+struct inode *__isofs_iget(struct super_block *sb,\n+\t\t\t   unsigned long block,\n+\t\t\t   unsigned long offset,\n+\t\t\t   int relocated)\n {\n \tunsigned long hashval;\n \tstruct inode *inode;\n@@ -1507,7 +1508,7 @@ struct inode *isofs_iget(struct super_block *sb,\n \t\treturn ERR_PTR(-ENOMEM);\n \n \tif (inode->i_state & I_NEW) {\n-\t\tret = isofs_read_inode(inode);\n+\t\tret = isofs_read_inode(inode, relocated);\n \t\tif (ret < 0) {\n \t\t\tiget_failed(inode);\n \t\t\tinode = ERR_PTR(ret);\ndiff --git a\/fs\/isofs\/isofs.h b\/fs\/isofs\/isofs.h\nindex 99167238518d6..0ac4c1f73fbd6 100644\n--- a\/fs\/isofs\/isofs.h\n+++ b\/fs\/isofs\/isofs.h\n@@ -107,7 +107,7 @@ extern int iso_date(char *, int);\n \n struct inode;\t\t\/* To make gcc happy *\/\n \n-extern int parse_rock_ridge_inode(struct iso_directory_record *, struct inode *);\n+extern int parse_rock_ridge_inode(struct iso_directory_record *, struct inode *, int relocated);\n extern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\n extern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\n \n@@ -118,9 +118,24 @@ extern struct dentry *isofs_lookup(struct inode *, struct dentry *, unsigned int\n extern struct buffer_head *isofs_bread(struct inode *, sector_t);\n extern int isofs_get_blocks(struct inode *, sector_t, struct buffer_head **, unsigned long);\n \n-extern struct inode *isofs_iget(struct super_block *sb,\n-                                unsigned long block,\n-                                unsigned long offset);\n+struct inode *__isofs_iget(struct super_block *sb,\n+\t\t\t   unsigned long block,\n+\t\t\t   unsigned long offset,\n+\t\t\t   int relocated);\n+\n+static inline struct inode *isofs_iget(struct super_block *sb,\n+\t\t\t\t       unsigned long block,\n+\t\t\t\t       unsigned long offset)\n+{\n+\treturn __isofs_iget(sb, block, offset, 0);\n+}\n+\n+static inline struct inode *isofs_iget_reloc(struct super_block *sb,\n+\t\t\t\t\t     unsigned long block,\n+\t\t\t\t\t     unsigned long offset)\n+{\n+\treturn __isofs_iget(sb, block, offset, 1);\n+}\n \n \/* Because the inode number is no longer relevant to finding the\n  * underlying meta-data for an inode, we are free to choose a more\ndiff --git a\/fs\/isofs\/rock.c b\/fs\/isofs\/rock.c\nindex c0bf42472e408..f488bbae541ac 100644\n--- a\/fs\/isofs\/rock.c\n+++ b\/fs\/isofs\/rock.c\n@@ -288,12 +288,16 @@ int get_rock_ridge_filename(struct iso_directory_record *de,\n \tgoto out;\n }\n \n+#define RR_REGARD_XA 1\n+#define RR_RELOC_DE 2\n+\n static int\n parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n-\t\t\t\tstruct inode *inode, int regard_xa)\n+\t\t\t\tstruct inode *inode, int flags)\n {\n \tint symlink_len = 0;\n \tint cnt, sig;\n+\tunsigned int reloc_block;\n \tstruct inode *reloc;\n \tstruct rock_ridge *rr;\n \tint rootflag;\n@@ -305,7 +309,7 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n \n \tinit_rock_state(&rs, inode);\n \tsetup_rock_ridge(de, inode, &rs);\n-\tif (regard_xa) {\n+\tif (flags & RR_REGARD_XA) {\n \t\trs.chr += 14;\n \t\trs.len -= 14;\n \t\tif (rs.len < 0)\n@@ -485,12 +489,22 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n \t\t\t\t\t\"relocated directory\\n\");\n \t\t\tgoto out;\n \t\tcase SIG('C', 'L'):\n-\t\t\tISOFS_I(inode)->i_first_extent =\n-\t\t\t    isonum_733(rr->u.CL.location);\n-\t\t\treloc =\n-\t\t\t    isofs_iget(inode->i_sb,\n-\t\t\t\t       ISOFS_I(inode)->i_first_extent,\n-\t\t\t\t       0);\n+\t\t\tif (flags & RR_RELOC_DE) {\n+\t\t\t\tprintk(KERN_ERR\n+\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n+\t\t\t\t       \"is not supported\\n\");\n+\t\t\t\tgoto eio;\n+\t\t\t}\n+\t\t\treloc_block = isonum_733(rr->u.CL.location);\n+\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n+\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n+\t\t\t\tprintk(KERN_ERR\n+\t\t\t\t       \"ISOFS: Directory relocation points to \"\n+\t\t\t\t       \"itself\\n\");\n+\t\t\t\tgoto eio;\n+\t\t\t}\n+\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n+\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n \t\t\tif (IS_ERR(reloc)) {\n \t\t\t\tret = PTR_ERR(reloc);\n \t\t\t\tgoto out;\n@@ -637,9 +651,11 @@ static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n \treturn rpnt;\n }\n \n-int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)\n+int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n+\t\t\t   int relocated)\n {\n-\tint result = parse_rock_ridge_inode_internal(de, inode, 0);\n+\tint flags = relocated ? RR_RELOC_DE : 0;\n+\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n \n \t\/*\n \t * if rockridge flag was reset and we didn't look for attributes\n@@ -647,7 +663,8 @@ int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)\n \t *\/\n \tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n \t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n-\t\tresult = parse_rock_ridge_inode_internal(de, inode, 14);\n+\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n+\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n \t}\n \treturn result;\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-4272","CWE_ID":"20","category":"security","commit_id":"73e42897e8e5619eacb787d2ce69be12f47cfc21","commit_message":"From 73e42897e8e5619eacb787d2ce69be12f47cfc21 Mon Sep 17 00:00:00 2001\nFrom: Neil Horman <nhorman@tuxdriver.com>\nDate: Sat, 20 Jun 2009 01:15:16 -0700\nSubject: ipv4: fix NULL pointer + success return in route lookup path\n\nDon't drop route if we're not caching\n\n\tI recently got a report of an oops on a route lookup.  Maxime was\ntesting what would happen if route caching was turned off (doing so by setting\nmaking rt_caching always return 0), and found that it triggered an oops.  I\nlooked at it and found that the problem stemmed from the fact that the route\nlookup routines were returning success from their lookup paths (which is good),\nbut never set the **rp pointer to anything (which is bad).  This happens because\nin rt_intern_hash, if rt_caching returns false, we call rt_drop and return 0.\nThis almost emulates slient success.  What we should be doing is assigning *rp =\nrt and _not_ dropping the route.  This way, during slow path lookups, when we\ncreate a new route cache entry, we don't immediately discard it, rather we just\ndon't add it into the cache hash table, but we let this one lookup use it for\nthe purpose of this route request.  Maxime has tested and reports it prevents\nthe oops.  There is still a subsequent routing issue that I'm looking into\nfurther, but I'm confident that, even if its related to this same path, this\npatch makes sense to take.\n\nSigned-off-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/route.c | 14 ++++++++++++--\n 1 file changed, 12 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/route.c b\/net\/ipv4\/route.c\nindex cd76b3cb7092..65b3a8b11a6c 100644\n--- a\/net\/ipv4\/route.c\n+++ b\/net\/ipv4\/route.c\n@@ -1085,8 +1085,16 @@ restart:\n \tnow = jiffies;\n \n \tif (!rt_caching(dev_net(rt->u.dst.dev))) {\n-\t\trt_drop(rt);\n-\t\treturn 0;\n+\t\t\/*\n+\t\t * If we're not caching, just tell the caller we\n+\t\t * were successful and don't touch the route.  The\n+\t\t * caller hold the sole reference to the cache entry, and\n+\t\t * it will be released when the caller is done with it.\n+\t\t * If we drop it here, the callers have no way to resolve routes\n+\t\t * when we're not caching.  Instead, just point *rp at rt, so\n+\t\t * the caller gets a single use out of the route\n+\t\t *\/\n+\t\tgoto report_and_exit;\n \t}\n \n \trthp = &rt_hash_table[hash].chain;\n@@ -1217,6 +1225,8 @@ restart:\n \trcu_assign_pointer(rt_hash_table[hash].chain, rt);\n \n \tspin_unlock_bh(rt_hash_lock_addr(hash));\n+\n+report_and_exit:\n \tif (rp)\n \t\t*rp = rt;\n \telse\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-0376","CWE_ID":"20","category":"security","commit_id":"56a7c5bc15e0447203a491c1ee37de9939ad1dcd","commit_message":"From 56a7c5bc15e0447203a491c1ee37de9939ad1dcd Mon Sep 17 00:00:00 2001\nFrom: David Goulet <dgoulet@torproject.org>\nDate: Mon, 5 Jun 2017 11:11:42 -0400\nSubject: [PATCH] TROVE-2017-005: Fix assertion failure in\n connection_edge_process_relay_cell\n\nOn an hidden service rendezvous circuit, a BEGIN_DIR could be sent\n(maliciously) which would trigger a tor_assert() because\nconnection_edge_process_relay_cell() thought that the circuit is an\nor_circuit_t but is an origin circuit in reality.\n\nFixes #22494\n\nReported-by: Roger Dingledine <arma@torproject.org>\nSigned-off-by: David Goulet <dgoulet@torproject.org>\n---\n changes\/trove-2017-005 | 7 +++++++\n src\/or\/relay.c         | 3 ++-\n 2 files changed, 9 insertions(+), 1 deletion(-)\n create mode 100644 changes\/trove-2017-005\n\n","diff_code":"diff --git a\/changes\/trove-2017-005 b\/changes\/trove-2017-005\nnew file mode 100644\nindex 0000000000..cebb013f86\n--- \/dev\/null\n+++ b\/changes\/trove-2017-005\n@@ -0,0 +1,7 @@\n+  o Major bugfixes (hidden service, relay, security):\n+    - Fix an assertion failure caused by receiving a BEGIN_DIR cell on\n+      a hidden service rendezvous circuit. Fixes bug 22494, tracked as\n+      TROVE-2017-005 and CVE-2017-0376; bugfix on 0.2.2.1-alpha. Found\n+      by armadev.\n+\n+\ndiff --git a\/src\/or\/relay.c b\/src\/or\/relay.c\nindex 7f06c6e145..59b79f95c9 100644\n--- a\/src\/or\/relay.c\n+++ b\/src\/or\/relay.c\n@@ -1297,7 +1297,8 @@ connection_edge_process_relay_cell(cell_t *cell, circuit_t *circ,\n                \"Begin cell for known stream. Dropping.\");\n         return 0;\n       }\n-      if (rh.command == RELAY_COMMAND_BEGIN_DIR) {\n+      if (rh.command == RELAY_COMMAND_BEGIN_DIR &&\n+          circ->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) {\n         \/* Assign this circuit and its app-ward OR connection a unique ID,\n          * so that we can measure download times. The local edge and dir\n          * connection will be assigned the same ID when they are created\n","owner":"torproject","repo":"tor","source":"cve"},{"CVE_ID":"CVE-2017-7539","CWE_ID":"20","category":"security","commit_id":"ff82911cd3f69f028f2537825c9720ff78bc3f19","commit_message":"From ff82911cd3f69f028f2537825c9720ff78bc3f19 Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Mon, 13 Feb 2017 14:52:24 +0100\nSubject: [PATCH] nbd: convert to use qio_channel_yield\n\nIn the client, read the reply headers from a coroutine, switching the\nread side between the \"read header\" coroutine and the I\/O coroutine that\nreads the body of the reply.\n\nIn the server, if the server can read more requests it will create a new\n\"read request\" coroutine as soon as a request has been read.  Otherwise,\nthe new coroutine is created in nbd_request_put.\n\nReviewed-by: Stefan Hajnoczi <stefanha@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\nReviewed-by: Fam Zheng <famz@redhat.com>\nReviewed-by: Daniel P. Berrange <berrange@redhat.com>\nMessage-id: 20170213135235.12274-8-pbonzini@redhat.com\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\n---\n block\/nbd-client.c | 117 ++++++++++++++++++++++++-----------------------------\n block\/nbd-client.h |   2 +-\n nbd\/client.c       |   2 +-\n nbd\/common.c       |   9 +----\n nbd\/server.c       |  94 +++++++++++++-----------------------------\n 5 files changed, 83 insertions(+), 141 deletions(-)\n\n","diff_code":"diff --git a\/block\/nbd-client.c b\/block\/nbd-client.c\nindex 06f1532..10fcc9e 100644\n--- a\/block\/nbd-client.c\n+++ b\/block\/nbd-client.c\n@@ -33,8 +33,9 @@\n #define HANDLE_TO_INDEX(bs, handle) ((handle) ^ ((uint64_t)(intptr_t)bs))\n #define INDEX_TO_HANDLE(bs, index)  ((index)  ^ ((uint64_t)(intptr_t)bs))\n \n-static void nbd_recv_coroutines_enter_all(NBDClientSession *s)\n+static void nbd_recv_coroutines_enter_all(BlockDriverState *bs)\n {\n+    NBDClientSession *s = nbd_get_client_session(bs);\n     int i;\n \n     for (i = 0; i < MAX_NBD_REQUESTS; i++) {\n@@ -42,6 +43,7 @@ static void nbd_recv_coroutines_enter_all(NBDClientSession *s)\n             qemu_coroutine_enter(s->recv_coroutine[i]);\n         }\n     }\n+    BDRV_POLL_WHILE(bs, s->read_reply_co);\n }\n \n static void nbd_teardown_connection(BlockDriverState *bs)\n@@ -56,7 +58,7 @@ static void nbd_teardown_connection(BlockDriverState *bs)\n     qio_channel_shutdown(client->ioc,\n                          QIO_CHANNEL_SHUTDOWN_BOTH,\n                          NULL);\n-    nbd_recv_coroutines_enter_all(client);\n+    nbd_recv_coroutines_enter_all(bs);\n \n     nbd_client_detach_aio_context(bs);\n     object_unref(OBJECT(client->sioc));\n@@ -65,54 +67,43 @@ static void nbd_teardown_connection(BlockDriverState *bs)\n     client->ioc = NULL;\n }\n \n-static void nbd_reply_ready(void *opaque)\n+static coroutine_fn void nbd_read_reply_entry(void *opaque)\n {\n-    BlockDriverState *bs = opaque;\n-    NBDClientSession *s = nbd_get_client_session(bs);\n+    NBDClientSession *s = opaque;\n     uint64_t i;\n     int ret;\n \n-    if (!s->ioc) { \/* Already closed *\/\n-        return;\n-    }\n-\n-    if (s->reply.handle == 0) {\n-        \/* No reply already in flight.  Fetch a header.  It is possible\n-         * that another thread has done the same thing in parallel, so\n-         * the socket is not readable anymore.\n-         *\/\n+    for (;;) {\n+        assert(s->reply.handle == 0);\n         ret = nbd_receive_reply(s->ioc, &s->reply);\n-        if (ret == -EAGAIN) {\n-            return;\n-        }\n         if (ret < 0) {\n-            s->reply.handle = 0;\n-            goto fail;\n+            break;\n         }\n-    }\n \n-    \/* There's no need for a mutex on the receive side, because the\n-     * handler acts as a synchronization point and ensures that only\n-     * one coroutine is called until the reply finishes.  *\/\n-    i = HANDLE_TO_INDEX(s, s->reply.handle);\n-    if (i >= MAX_NBD_REQUESTS) {\n-        goto fail;\n-    }\n+        \/* There's no need for a mutex on the receive side, because the\n+         * handler acts as a synchronization point and ensures that only\n+         * one coroutine is called until the reply finishes.\n+         *\/\n+        i = HANDLE_TO_INDEX(s, s->reply.handle);\n+        if (i >= MAX_NBD_REQUESTS || !s->recv_coroutine[i]) {\n+            break;\n+        }\n \n-    if (s->recv_coroutine[i]) {\n-        qemu_coroutine_enter(s->recv_coroutine[i]);\n-        return;\n+        \/* We're woken up by the recv_coroutine itself.  Note that there\n+         * is no race between yielding and reentering read_reply_co.  This\n+         * is because:\n+         *\n+         * - if recv_coroutine[i] runs on the same AioContext, it is only\n+         *   entered after we yield\n+         *\n+         * - if recv_coroutine[i] runs on a different AioContext, reentering\n+         *   read_reply_co happens through a bottom half, which can only\n+         *   run after we yield.\n+         *\/\n+        aio_co_wake(s->recv_coroutine[i]);\n+        qemu_coroutine_yield();\n     }\n-\n-fail:\n-    nbd_teardown_connection(bs);\n-}\n-\n-static void nbd_restart_write(void *opaque)\n-{\n-    BlockDriverState *bs = opaque;\n-\n-    qemu_coroutine_enter(nbd_get_client_session(bs)->send_coroutine);\n+    s->read_reply_co = NULL;\n }\n \n static int nbd_co_send_request(BlockDriverState *bs,\n@@ -120,7 +111,6 @@ static int nbd_co_send_request(BlockDriverState *bs,\n                                QEMUIOVector *qiov)\n {\n     NBDClientSession *s = nbd_get_client_session(bs);\n-    AioContext *aio_context;\n     int rc, ret, i;\n \n     qemu_co_mutex_lock(&s->send_mutex);\n@@ -141,11 +131,6 @@ static int nbd_co_send_request(BlockDriverState *bs,\n         return -EPIPE;\n     }\n \n-    s->send_coroutine = qemu_coroutine_self();\n-    aio_context = bdrv_get_aio_context(bs);\n-\n-    aio_set_fd_handler(aio_context, s->sioc->fd, false,\n-                       nbd_reply_ready, nbd_restart_write, NULL, bs);\n     if (qiov) {\n         qio_channel_set_cork(s->ioc, true);\n         rc = nbd_send_request(s->ioc, request);\n@@ -160,9 +145,6 @@ static int nbd_co_send_request(BlockDriverState *bs,\n     } else {\n         rc = nbd_send_request(s->ioc, request);\n     }\n-    aio_set_fd_handler(aio_context, s->sioc->fd, false,\n-                       nbd_reply_ready, NULL, NULL, bs);\n-    s->send_coroutine = NULL;\n     qemu_co_mutex_unlock(&s->send_mutex);\n     return rc;\n }\n@@ -174,8 +156,7 @@ static void nbd_co_receive_reply(NBDClientSession *s,\n {\n     int ret;\n \n-    \/* Wait until we're woken up by the read handler.  TODO: perhaps\n-     * peek at the next reply and avoid yielding if it's ours?  *\/\n+    \/* Wait until we're woken up by nbd_read_reply_entry.  *\/\n     qemu_coroutine_yield();\n     *reply = s->reply;\n     if (reply->handle != request->handle ||\n@@ -209,13 +190,19 @@ static void nbd_coroutine_start(NBDClientSession *s,\n     \/* s->recv_coroutine[i] is set as soon as we get the send_lock.  *\/\n }\n \n-static void nbd_coroutine_end(NBDClientSession *s,\n+static void nbd_coroutine_end(BlockDriverState *bs,\n                               NBDRequest *request)\n {\n+    NBDClientSession *s = nbd_get_client_session(bs);\n     int i = HANDLE_TO_INDEX(s, request->handle);\n+\n     s->recv_coroutine[i] = NULL;\n-    if (s->in_flight-- == MAX_NBD_REQUESTS) {\n-        qemu_co_queue_next(&s->free_sema);\n+    s->in_flight--;\n+    qemu_co_queue_next(&s->free_sema);\n+\n+    \/* Kick the read_reply_co to get the next reply.  *\/\n+    if (s->read_reply_co) {\n+        aio_co_wake(s->read_reply_co);\n     }\n }\n \n@@ -241,7 +228,7 @@ int nbd_client_co_preadv(BlockDriverState *bs, uint64_t offset,\n     } else {\n         nbd_co_receive_reply(client, &request, &reply, qiov);\n     }\n-    nbd_coroutine_end(client, &request);\n+    nbd_coroutine_end(bs, &request);\n     return -reply.error;\n }\n \n@@ -271,7 +258,7 @@ int nbd_client_co_pwritev(BlockDriverState *bs, uint64_t offset,\n     } else {\n         nbd_co_receive_reply(client, &request, &reply, NULL);\n     }\n-    nbd_coroutine_end(client, &request);\n+    nbd_coroutine_end(bs, &request);\n     return -reply.error;\n }\n \n@@ -306,7 +293,7 @@ int nbd_client_co_pwrite_zeroes(BlockDriverState *bs, int64_t offset,\n     } else {\n         nbd_co_receive_reply(client, &request, &reply, NULL);\n     }\n-    nbd_coroutine_end(client, &request);\n+    nbd_coroutine_end(bs, &request);\n     return -reply.error;\n }\n \n@@ -331,7 +318,7 @@ int nbd_client_co_flush(BlockDriverState *bs)\n     } else {\n         nbd_co_receive_reply(client, &request, &reply, NULL);\n     }\n-    nbd_coroutine_end(client, &request);\n+    nbd_coroutine_end(bs, &request);\n     return -reply.error;\n }\n \n@@ -357,23 +344,23 @@ int nbd_client_co_pdiscard(BlockDriverState *bs, int64_t offset, int count)\n     } else {\n         nbd_co_receive_reply(client, &request, &reply, NULL);\n     }\n-    nbd_coroutine_end(client, &request);\n+    nbd_coroutine_end(bs, &request);\n     return -reply.error;\n \n }\n \n void nbd_client_detach_aio_context(BlockDriverState *bs)\n {\n-    aio_set_fd_handler(bdrv_get_aio_context(bs),\n-                       nbd_get_client_session(bs)->sioc->fd,\n-                       false, NULL, NULL, NULL, NULL);\n+    NBDClientSession *client = nbd_get_client_session(bs);\n+    qio_channel_detach_aio_context(QIO_CHANNEL(client->sioc));\n }\n \n void nbd_client_attach_aio_context(BlockDriverState *bs,\n                                    AioContext *new_context)\n {\n-    aio_set_fd_handler(new_context, nbd_get_client_session(bs)->sioc->fd,\n-                       false, nbd_reply_ready, NULL, NULL, bs);\n+    NBDClientSession *client = nbd_get_client_session(bs);\n+    qio_channel_attach_aio_context(QIO_CHANNEL(client->sioc), new_context);\n+    aio_co_schedule(new_context, client->read_reply_co);\n }\n \n void nbd_client_close(BlockDriverState *bs)\n@@ -434,7 +421,7 @@ int nbd_client_init(BlockDriverState *bs,\n     \/* Now that we're connected, set the socket to be non-blocking and\n      * kick the reply mechanism.  *\/\n     qio_channel_set_blocking(QIO_CHANNEL(sioc), false, NULL);\n-\n+    client->read_reply_co = qemu_coroutine_create(nbd_read_reply_entry, client);\n     nbd_client_attach_aio_context(bs, bdrv_get_aio_context(bs));\n \n     logout(\"Established connection with NBD server\\n\");\ndiff --git a\/block\/nbd-client.h b\/block\/nbd-client.h\nindex f8d6006..8cdfc92 100644\n--- a\/block\/nbd-client.h\n+++ b\/block\/nbd-client.h\n@@ -25,7 +25,7 @@ typedef struct NBDClientSession {\n \n     CoMutex send_mutex;\n     CoQueue free_sema;\n-    Coroutine *send_coroutine;\n+    Coroutine *read_reply_co;\n     int in_flight;\n \n     Coroutine *recv_coroutine[MAX_NBD_REQUESTS];\ndiff --git a\/nbd\/client.c b\/nbd\/client.c\nindex ffb0743..5c9dee3 100644\n--- a\/nbd\/client.c\n+++ b\/nbd\/client.c\n@@ -778,7 +778,7 @@ ssize_t nbd_receive_reply(QIOChannel *ioc, NBDReply *reply)\n     ssize_t ret;\n \n     ret = read_sync(ioc, buf, sizeof(buf));\n-    if (ret < 0) {\n+    if (ret <= 0) {\n         return ret;\n     }\n \ndiff --git a\/nbd\/common.c b\/nbd\/common.c\nindex a5f39ea..dccbb8e 100644\n--- a\/nbd\/common.c\n+++ b\/nbd\/common.c\n@@ -43,14 +43,7 @@ ssize_t nbd_wr_syncv(QIOChannel *ioc,\n         }\n         if (len == QIO_CHANNEL_ERR_BLOCK) {\n             if (qemu_in_coroutine()) {\n-                \/* XXX figure out if we can create a variant on\n-                 * qio_channel_yield() that works with AIO contexts\n-                 * and consider using that in this branch *\/\n-                qemu_coroutine_yield();\n-            } else if (done) {\n-                \/* XXX this is needed by nbd_reply_ready.  *\/\n-                qio_channel_wait(ioc,\n-                                 do_read ? G_IO_IN : G_IO_OUT);\n+                qio_channel_yield(ioc, do_read ? G_IO_IN : G_IO_OUT);\n             } else {\n                 return -EAGAIN;\n             }\ndiff --git a\/nbd\/server.c b\/nbd\/server.c\nindex efe5cb8..ac92fa0 100644\n--- a\/nbd\/server.c\n+++ b\/nbd\/server.c\n@@ -95,8 +95,6 @@ struct NBDClient {\n     CoMutex send_lock;\n     Coroutine *send_coroutine;\n \n-    bool can_read;\n-\n     QTAILQ_ENTRY(NBDClient) next;\n     int nb_requests;\n     bool closing;\n@@ -104,9 +102,7 @@ struct NBDClient {\n \n \/* That's all folks *\/\n \n-static void nbd_set_handlers(NBDClient *client);\n-static void nbd_unset_handlers(NBDClient *client);\n-static void nbd_update_can_read(NBDClient *client);\n+static void nbd_client_receive_next_request(NBDClient *client);\n \n static gboolean nbd_negotiate_continue(QIOChannel *ioc,\n                                        GIOCondition condition,\n@@ -785,7 +781,7 @@ void nbd_client_put(NBDClient *client)\n          *\/\n         assert(client->closing);\n \n-        nbd_unset_handlers(client);\n+        qio_channel_detach_aio_context(client->ioc);\n         object_unref(OBJECT(client->sioc));\n         object_unref(OBJECT(client->ioc));\n         if (client->tlscreds) {\n@@ -826,7 +822,6 @@ static NBDRequestData *nbd_request_get(NBDClient *client)\n \n     assert(client->nb_requests <= MAX_NBD_REQUESTS - 1);\n     client->nb_requests++;\n-    nbd_update_can_read(client);\n \n     req = g_new0(NBDRequestData, 1);\n     nbd_client_get(client);\n@@ -844,7 +839,8 @@ static void nbd_request_put(NBDRequestData *req)\n     g_free(req);\n \n     client->nb_requests--;\n-    nbd_update_can_read(client);\n+    nbd_client_receive_next_request(client);\n+\n     nbd_client_put(client);\n }\n \n@@ -858,7 +854,13 @@ static void blk_aio_attached(AioContext *ctx, void *opaque)\n     exp->ctx = ctx;\n \n     QTAILQ_FOREACH(client, &exp->clients, next) {\n-        nbd_set_handlers(client);\n+        qio_channel_attach_aio_context(client->ioc, ctx);\n+        if (client->recv_coroutine) {\n+            aio_co_schedule(ctx, client->recv_coroutine);\n+        }\n+        if (client->send_coroutine) {\n+            aio_co_schedule(ctx, client->send_coroutine);\n+        }\n     }\n }\n \n@@ -870,7 +872,7 @@ static void blk_aio_detach(void *opaque)\n     TRACE(\"Export %s: Detaching clients from AIO context %p\\n\", exp->name, exp->ctx);\n \n     QTAILQ_FOREACH(client, &exp->clients, next) {\n-        nbd_unset_handlers(client);\n+        qio_channel_detach_aio_context(client->ioc);\n     }\n \n     exp->ctx = NULL;\n@@ -1045,7 +1047,6 @@ static ssize_t nbd_co_send_reply(NBDRequestData *req, NBDReply *reply,\n     g_assert(qemu_in_coroutine());\n     qemu_co_mutex_lock(&client->send_lock);\n     client->send_coroutine = qemu_coroutine_self();\n-    nbd_set_handlers(client);\n \n     if (!len) {\n         rc = nbd_send_reply(client->ioc, reply);\n@@ -1062,7 +1063,6 @@ static ssize_t nbd_co_send_reply(NBDRequestData *req, NBDReply *reply,\n     }\n \n     client->send_coroutine = NULL;\n-    nbd_set_handlers(client);\n     qemu_co_mutex_unlock(&client->send_lock);\n     return rc;\n }\n@@ -1079,9 +1079,7 @@ static ssize_t nbd_co_receive_request(NBDRequestData *req,\n     ssize_t rc;\n \n     g_assert(qemu_in_coroutine());\n-    client->recv_coroutine = qemu_coroutine_self();\n-    nbd_update_can_read(client);\n-\n+    assert(client->recv_coroutine == qemu_coroutine_self());\n     rc = nbd_receive_request(client->ioc, request);\n     if (rc < 0) {\n         if (rc != -EAGAIN) {\n@@ -1163,23 +1161,25 @@ static ssize_t nbd_co_receive_request(NBDRequestData *req,\n \n out:\n     client->recv_coroutine = NULL;\n-    nbd_update_can_read(client);\n+    nbd_client_receive_next_request(client);\n \n     return rc;\n }\n \n-static void nbd_trip(void *opaque)\n+\/* Owns a reference to the NBDClient passed as opaque.  *\/\n+static coroutine_fn void nbd_trip(void *opaque)\n {\n     NBDClient *client = opaque;\n     NBDExport *exp = client->exp;\n     NBDRequestData *req;\n-    NBDRequest request;\n+    NBDRequest request = { 0 };    \/* GCC thinks it can be used uninitialized *\/\n     NBDReply reply;\n     ssize_t ret;\n     int flags;\n \n     TRACE(\"Reading request.\");\n     if (client->closing) {\n+        nbd_client_put(client);\n         return;\n     }\n \n@@ -1338,60 +1338,21 @@ static void nbd_trip(void *opaque)\n \n done:\n     nbd_request_put(req);\n+    nbd_client_put(client);\n     return;\n \n out:\n     nbd_request_put(req);\n     client_close(client);\n+    nbd_client_put(client);\n }\n \n-static void nbd_read(void *opaque)\n-{\n-    NBDClient *client = opaque;\n-\n-    if (client->recv_coroutine) {\n-        qemu_coroutine_enter(client->recv_coroutine);\n-    } else {\n-        qemu_coroutine_enter(qemu_coroutine_create(nbd_trip, client));\n-    }\n-}\n-\n-static void nbd_restart_write(void *opaque)\n-{\n-    NBDClient *client = opaque;\n-\n-    qemu_coroutine_enter(client->send_coroutine);\n-}\n-\n-static void nbd_set_handlers(NBDClient *client)\n-{\n-    if (client->exp && client->exp->ctx) {\n-        aio_set_fd_handler(client->exp->ctx, client->sioc->fd, true,\n-                           client->can_read ? nbd_read : NULL,\n-                           client->send_coroutine ? nbd_restart_write : NULL,\n-                           NULL, client);\n-    }\n-}\n-\n-static void nbd_unset_handlers(NBDClient *client)\n-{\n-    if (client->exp && client->exp->ctx) {\n-        aio_set_fd_handler(client->exp->ctx, client->sioc->fd, true, NULL,\n-                           NULL, NULL, NULL);\n-    }\n-}\n-\n-static void nbd_update_can_read(NBDClient *client)\n+static void nbd_client_receive_next_request(NBDClient *client)\n {\n-    bool can_read = client->recv_coroutine ||\n-                    client->nb_requests < MAX_NBD_REQUESTS;\n-\n-    if (can_read != client->can_read) {\n-        client->can_read = can_read;\n-        nbd_set_handlers(client);\n-\n-        \/* There is no need to invoke aio_notify(), since aio_set_fd_handler()\n-         * in nbd_set_handlers() will have taken care of that *\/\n+    if (!client->recv_coroutine && client->nb_requests < MAX_NBD_REQUESTS) {\n+        nbd_client_get(client);\n+        client->recv_coroutine = qemu_coroutine_create(nbd_trip, client);\n+        aio_co_schedule(client->exp->ctx, client->recv_coroutine);\n     }\n }\n \n@@ -1409,11 +1370,13 @@ static coroutine_fn void nbd_co_client_start(void *opaque)\n         goto out;\n     }\n     qemu_co_mutex_init(&client->send_lock);\n-    nbd_set_handlers(client);\n \n     if (exp) {\n         QTAILQ_INSERT_TAIL(&exp->clients, client, next);\n     }\n+\n+    nbd_client_receive_next_request(client);\n+\n out:\n     g_free(data);\n }\n@@ -1439,7 +1402,6 @@ void nbd_client_new(NBDExport *exp,\n     object_ref(OBJECT(client->sioc));\n     client->ioc = QIO_CHANNEL(sioc);\n     object_ref(OBJECT(client->ioc));\n-    client->can_read = true;\n     client->close = close_fn;\n \n     data->client = client;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-5355","CWE_ID":"20","category":"security","commit_id":"3270dfac43da861c714df76513456b46765ff47f","commit_message":"From 3270dfac43da861c714df76513456b46765ff47f Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Sun, 1 May 2016 16:29:41 -0700\nSubject: [PATCH] Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12394\nChange-Id: I4b19b95f2e1ffc96dac5c91bff6698c246f52007\nReviewed-on: https:\/\/code.wireshark.org\/review\/15230\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n---\n wiretap\/toshiba.c | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/wiretap\/toshiba.c b\/wiretap\/toshiba.c\nindex 9a06681189..091b790884 100644\n--- a\/wiretap\/toshiba.c\n+++ b\/wiretap\/toshiba.c\n@@ -248,8 +248,7 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n-\tguint\tpkt_len;\n-\tint\tpktnum, hr, min, sec, csec;\n+\tint\tpkt_len, pktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n@@ -301,12 +300,17 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n-\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n+\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n+\tif (pkt_len < 0) {\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup(\"toshiba: packet header has a negative packet length\");\n+\t\treturn FALSE;\n+\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t\/*\n \t\t * Probably a corrupt capture file; don't blow up trying\n","owner":"wireshark","repo":"wireshark","source":"cve"},{"CVE_ID":"CVE-2017-5898","CWE_ID":"20","category":"security","commit_id":"c7dfbf322595ded4e70b626bf83158a9f3807c6a","commit_message":"From c7dfbf322595ded4e70b626bf83158a9f3807c6a Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Fri, 3 Feb 2017 00:52:28 +0530\nSubject: [PATCH] usb: ccid: check ccid apdu length\n\nCCID device emulator uses Application Protocol Data Units(APDU)\nto exchange command and responses to and from the host.\nThe length in these units couldn't be greater than 65536. Add\ncheck to ensure the same. It'd also avoid potential integer\noverflow in emulated_apdu_from_guest.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-id: 20170202192228.10847-1-ppandit@redhat.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/usb\/dev-smartcard-reader.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/usb\/dev-smartcard-reader.c b\/hw\/usb\/dev-smartcard-reader.c\nindex 89e11b6..1325ea1 100644\n--- a\/hw\/usb\/dev-smartcard-reader.c\n+++ b\/hw\/usb\/dev-smartcard-reader.c\n@@ -967,7 +967,7 @@ static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)\n     DPRINTF(s, 1, \"%s: seq %d, len %d\\n\", __func__,\n                 recv->hdr.bSeq, len);\n     ccid_add_pending_answer(s, (CCID_Header *)recv);\n-    if (s->card) {\n+    if (s->card && len <= BULK_OUT_DATA_SIZE) {\n         ccid_card_apdu_from_guest(s->card, recv->abData, len);\n     } else {\n         DPRINTF(s, D_WARN, \"warning: discarded apdu\\n\");\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-12459","CWE_ID":"20","category":"security","commit_id":"2fc108f60f98cd00813418a8754a46476b404a3c","commit_message":"From 2fc108f60f98cd00813418a8754a46476b404a3c Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sat, 9 Jun 2018 22:25:38 +0200\nSubject: [PATCH] avcodec\/mpeg4videodec: Clear bits_per_raw_sample if it has\n originated from a previous instance\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nFixes: assertion failure\nFixes: ffmpeg_crash_5.avi\n\nFound-by: Thuan Pham <thuanpv@comp.nus.edu.sg>, Marcel B\u00f6hme, Andrew Santosa and Alexandru Razvan Caciulescu with AFLSmart\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/mpeg4videodec.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/mpeg4videodec.c b\/libavcodec\/mpeg4videodec.c\nindex 51b58fac02f..d0ebaac6e8e 100644\n--- a\/libavcodec\/mpeg4videodec.c\n+++ b\/libavcodec\/mpeg4videodec.c\n@@ -3109,6 +3109,12 @@ int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n     \/* search next start code *\/\n     align_get_bits(gb);\n \n+    \/\/ If we have not switched to studio profile than we also did not switch bps\n+    \/\/ that means something else (like a previous instance) outside set bps which\n+    \/\/ would be inconsistant with the currect state, thus reset it\n+    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)\n+        s->avctx->bits_per_raw_sample = 0;\n+\n     if (s->codec_tag == AV_RL32(\"WV1F\") && show_bits(gb, 24) == 0x575630) {\n         skip_bits(gb, 24);\n         if (get_bits(gb, 8) == 0xF0)\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2013-4353","CWE_ID":"20","category":"security","commit_id":"197e0ea817ad64820789d86711d55ff50d71f631","commit_message":"From 197e0ea817ad64820789d86711d55ff50d71f631 Mon Sep 17 00:00:00 2001\nFrom: \"Dr. Stephen Henson\" <steve@openssl.org>\nDate: Mon, 6 Jan 2014 14:35:04 +0000\nSubject: [PATCH] Fix for TLS record tampering bug CVE-2013-4353\n\n---\n CHANGES       | 5 +++++\n NEWS          | 1 +\n ssl\/s3_both.c | 6 +++++-\n 3 files changed, 11 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/CHANGES b\/CHANGES\nindex 173be2465e..6494184bad 100644\n--- a\/CHANGES\n+++ b\/CHANGES\n@@ -4,6 +4,11 @@\n \n  Changes between 1.0.1e and 1.0.1f [xx XXX xxxx]\n \n+  *) Fix for TLS record tampering bug. A carefully crafted invalid \n+     handshake could crash OpenSSL with a NULL pointer exception.\n+     Thanks to Anton Johansson for reporting this issues.\n+     (CVE-2013-4353)\n+\n   *) Keep original DTLS digest and encryption contexts in retransmission\n      structures so we can use the previous session parameters if they need\n      to be resent. (CVE-2013-6450)\ndiff --git a\/NEWS b\/NEWS\nindex cdf84d927d..81b6ed2c7b 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -7,6 +7,7 @@\n \n   Major changes between OpenSSL 1.0.1e and OpenSSL 1.0.1f [under development]\n \n+      o Fix for TLS record tampering bug CVE-2013-4353\n       o Fix for TLS version checking bug CVE-2013-6449\n       o Fix for DTLS retransmission bug CVE-2013-6450\n \ndiff --git a\/ssl\/s3_both.c b\/ssl\/s3_both.c\nindex 1e5dcab7d3..53b9390fdd 100644\n--- a\/ssl\/s3_both.c\n+++ b\/ssl\/s3_both.c\n@@ -210,7 +210,11 @@ static void ssl3_take_mac(SSL *s)\n \t{\n \tconst char *sender;\n \tint slen;\n-\n+\t\/* If no new cipher setup return immediately: other functions will\n+\t * set the appropriate error.\n+\t *\/\n+\tif (s->s3->tmp.new_cipher == NULL)\n+\t\treturn;\n \tif (s->state & SSL_ST_CONNECT)\n \t\t{\n \t\tsender=s->method->ssl3_enc->server_finished_label;\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3710","CWE_ID":"20","category":"security","commit_id":"39c7ac1106be844a5296d3eb5971946cc09ffda0","commit_message":"From 39c7ac1106be844a5296d3eb5971946cc09ffda0 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Fri, 17 Oct 2014 15:49:00 +0000\nSubject: [PATCH] Fix note bounds reading, Francisco Alonso \/ Red Hat\n\n---\n ChangeLog     | 4 ++++\n src\/readelf.c | 9 ++++++++-\n 2 files changed, 12 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex b42e3d789..681e7a950 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,7 @@\n+2014-10-17  11:48  Christos Zoulas <christos@zoulas.com>\n+\n+\t* fix bounds in note reading (Francisco Alonso \/ Red Hat)\n+\n 2014-10-11  15:02  Christos Zoulas <christos@zoulas.com>\n \n \t* fix autoconf glue for setlocale and locale_t; some OS's\ndiff --git a\/src\/readelf.c b\/src\/readelf.c\nindex 08f81f5b8..9ebdebd61 100644\n--- a\/src\/readelf.c\n+++ b\/src\/readelf.c\n@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.102 2014\/03\/11 21:00:13 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.103 2014\/05\/02 02:25:10 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -477,6 +477,13 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \tuint32_t namesz, descsz;\n \tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n \n+\tif (xnh_sizeof + offset > size) {\n+\t\t\/*\n+\t\t * We're out of note headers.\n+\t\t *\/\n+\t\treturn xnh_sizeof + offset;\n+\t}\n+\n \t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n \toffset += xnh_sizeof;\n \n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2017-6498","CWE_ID":"20","category":"security","commit_id":"65f75a32a93ae4044c528a987a68366ecd4b46b9","commit_message":"From 65f75a32a93ae4044c528a987a68366ecd4b46b9 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 19 Jan 2017 19:30:48 -0500\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/pull\/359\n\n---\n coders\/tga.c | 9 +++++----\n 1 file changed, 5 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/coders\/tga.c b\/coders\/tga.c\nindex d8adc52f7b..7b87278ef5 100644\n--- a\/coders\/tga.c\n+++ b\/coders\/tga.c\n@@ -710,6 +710,7 @@ static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)\n     compression;\n \n   const char\n+    *comment,\n     *value;\n \n   const double\n@@ -766,9 +767,9 @@ static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)\n     compression=image_info->compression;\n   range=GetQuantumRange(5UL);\n   tga_info.id_length=0;\n-  value=GetImageProperty(image,\"comment\");\n-  if (value != (const char *) NULL)\n-    tga_info.id_length=(unsigned char) MagickMin(strlen(value),255);\n+  comment=GetImageProperty(image,\"comment\");\n+  if (comment != (const char *) NULL)\n+    tga_info.id_length=(unsigned char) MagickMin(strlen(comment),255);\n   tga_info.colormap_type=0;\n   tga_info.colormap_index=0;\n   tga_info.colormap_length=0;\n@@ -852,7 +853,7 @@ static MagickBooleanType WriteTGAImage(const ImageInfo *image_info,Image *image)\n   (void) WriteBlobByte(image,tga_info.bits_per_pixel);\n   (void) WriteBlobByte(image,tga_info.attributes);\n   if (tga_info.id_length != 0)\n-    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) value);\n+    (void) WriteBlob(image,tga_info.id_length,(unsigned char *) comment);\n   if (tga_info.colormap_type != 0)\n     {\n       unsigned char\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2015-8818","CWE_ID":"20","category":"security","commit_id":"b242e0e0e2969c044a318e56f7988bbd84de1f63","commit_message":"From b242e0e0e2969c044a318e56f7988bbd84de1f63 Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Sat, 4 Jul 2015 00:24:51 +0200\nSubject: [PATCH] exec: skip MMIO regions correctly in\n cpu_physical_memory_write_rom_internal\n\nLoading the BIOS in the mac99 machine is interesting, because there is a\nPROM in the middle of the BIOS region (from 16K to 32K).  Before memory\nregion accesses were clamped, when QEMU was asked to load a BIOS from\n0xfff00000 to 0xffffffff it would put even those 16K from the BIOS file\ninto the region.  This is weird because those 16K were not actually\nvisible between 0xfff04000 and 0xfff07fff.  However, it worked.\n\nAfter clamping was added, this also worked.  In this case, the\ncpu_physical_memory_write_rom_internal function split the write in\nthree parts: the first 16K were copied, the PROM area (second 16K) were\nignored, then the rest was copied.\n\nProblems then started with commit 965eb2f (exec: do not clamp accesses\nto MMIO regions, 2015-06-17).  Clamping accesses is not done for MMIO\nregions because they can overlap wildly, and MMIO registers can be\nexpected to perform full-width accesses based only on their address\n(with no respect for adjacent registers that could decode to completely\ndifferent MemoryRegions).  However, this lack of clamping also applied\nto the PROM area!  cpu_physical_memory_write_rom_internal thus failed\nto copy the third range above, i.e. only copied the first 16K of the BIOS.\n\nIn effect, address_space_translate is expecting _something else_ to do\nthe clamping for MMIO regions if the incoming length is large.  This\n\"something else\" is memory_access_size in the case of address_space_rw,\nso use the same logic in cpu_physical_memory_write_rom_internal.\n\nReported-by: Alexander Graf <agraf@redhat.com>\nReviewed-by: Laurent Vivier <lvivier@redhat.com>\nTested-by: Laurent Vivier <lvivier@redhat.com>\nFixes: 965eb2f\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n exec.c | 14 +++++++++++++-\n 1 file changed, 13 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/exec.c b\/exec.c\nindex 3457f7e..251dc79 100644\n--- a\/exec.c\n+++ b\/exec.c\n@@ -353,6 +353,18 @@ address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *x\n     *xlat = addr + section->offset_within_region;\n \n     mr = section->mr;\n+\n+    \/* MMIO registers can be expected to perform full-width accesses based only\n+     * on their address, without considering adjacent registers that could\n+     * decode to completely different MemoryRegions.  When such registers\n+     * exist (e.g. I\/O ports 0xcf8 and 0xcf9 on most PC chipsets), MMIO\n+     * regions overlap wildly.  For this reason we cannot clamp the accesses\n+     * here.\n+     *\n+     * If the length is small (as is the case for address_space_ldl\/stl),\n+     * everything works fine.  If the incoming length is large, however,\n+     * the caller really has to do the clamping through memory_access_size.\n+     *\/\n     if (memory_region_is_ram(mr)) {\n         diff = int128_sub(section->size, int128_make64(addr));\n         *plen = int128_get64(int128_min(diff, int128_make64(*plen)));\n@@ -2491,7 +2503,7 @@ static inline void cpu_physical_memory_write_rom_internal(AddressSpace *as,\n \n         if (!(memory_region_is_ram(mr) ||\n               memory_region_is_romd(mr))) {\n-            \/* do nothing *\/\n+            l = memory_access_size(mr, l, addr1);\n         } else {\n             addr1 += memory_region_get_ram_addr(mr);\n             \/* ROM\/RAM case *\/\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2007-3731","CWE_ID":"20","category":"security","commit_id":"a10d9a71bafd3a283da240d2868e71346d2aef6f","commit_message":"From a10d9a71bafd3a283da240d2868e71346d2aef6f Mon Sep 17 00:00:00 2001\nFrom: Peter Zijlstra <peterz@infradead.org>\nDate: Wed, 18 Jul 2007 20:59:22 +0200\nSubject: i386: fixup TRACE_IRQ breakage\n\nThe TRACE_IRQS_ON function in iret_exc: calls a C function without\nensuring that the segments are set properly. Move the trace function and\nthe enabling of interrupt into the C stub.\n\nSigned-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/i386\/kernel\/entry.S |  2 --\n arch\/i386\/kernel\/traps.c | 10 ++++++----\n 2 files changed, 6 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/arch\/i386\/kernel\/entry.S b\/arch\/i386\/kernel\/entry.S\nindex 32980b834935..a714d6b43506 100644\n--- a\/arch\/i386\/kernel\/entry.S\n+++ b\/arch\/i386\/kernel\/entry.S\n@@ -409,8 +409,6 @@ restore_nocheck_notrace:\n 1:\tINTERRUPT_RETURN\n .section .fixup,\"ax\"\n iret_exc:\n-\tTRACE_IRQS_ON\n-\tENABLE_INTERRUPTS(CLBR_NONE)\n \tpushl $0\t\t\t# no error code\n \tpushl $do_iret_error\n \tjmp error_code\ndiff --git a\/arch\/i386\/kernel\/traps.c b\/arch\/i386\/kernel\/traps.c\nindex 18c1c285836d..d32fd4b6f78e 100644\n--- a\/arch\/i386\/kernel\/traps.c\n+++ b\/arch\/i386\/kernel\/traps.c\n@@ -518,10 +518,12 @@ fastcall void do_##name(struct pt_regs * regs, long error_code) \\\n \tdo_trap(trapnr, signr, str, 0, regs, error_code, NULL); \\\n }\n \n-#define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) \\\n+#define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr, irq) \\\n fastcall void do_##name(struct pt_regs * regs, long error_code) \\\n { \\\n \tsiginfo_t info; \\\n+\tif (irq) \\\n+\t\tlocal_irq_enable(); \\\n \tinfo.si_signo = signr; \\\n \tinfo.si_errno = 0; \\\n \tinfo.si_code = sicode; \\\n@@ -561,13 +563,13 @@ DO_VM86_ERROR( 3, SIGTRAP, \"int3\", int3)\n #endif\n DO_VM86_ERROR( 4, SIGSEGV, \"overflow\", overflow)\n DO_VM86_ERROR( 5, SIGSEGV, \"bounds\", bounds)\n-DO_ERROR_INFO( 6, SIGILL,  \"invalid opcode\", invalid_op, ILL_ILLOPN, regs->eip)\n+DO_ERROR_INFO( 6, SIGILL,  \"invalid opcode\", invalid_op, ILL_ILLOPN, regs->eip, 0)\n DO_ERROR( 9, SIGFPE,  \"coprocessor segment overrun\", coprocessor_segment_overrun)\n DO_ERROR(10, SIGSEGV, \"invalid TSS\", invalid_TSS)\n DO_ERROR(11, SIGBUS,  \"segment not present\", segment_not_present)\n DO_ERROR(12, SIGBUS,  \"stack segment\", stack_segment)\n-DO_ERROR_INFO(17, SIGBUS, \"alignment check\", alignment_check, BUS_ADRALN, 0)\n-DO_ERROR_INFO(32, SIGSEGV, \"iret exception\", iret_error, ILL_BADSTK, 0)\n+DO_ERROR_INFO(17, SIGBUS, \"alignment check\", alignment_check, BUS_ADRALN, 0, 0)\n+DO_ERROR_INFO(32, SIGSEGV, \"iret exception\", iret_error, ILL_BADSTK, 0, 1)\n \n fastcall void __kprobes do_general_protection(struct pt_regs * regs,\n \t\t\t\t\t      long error_code)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9144","CWE_ID":"20","category":"security","commit_id":"7fdf9ea808caa3c81a0eb42656e5fafc59084198","commit_message":"From 7fdf9ea808caa3c81a0eb42656e5fafc59084198 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 12 May 2017 07:14:36 -0400\nSubject: [PATCH] Check for EOF conditions for RLE image format\n\n---\n ChangeLog    |  1 +\n coders\/rle.c | 93 +++++++++++++++++++++++++++++++++++++---------------\n 2 files changed, 67 insertions(+), 27 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex a2178ffe09..251e0aa975 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -5,6 +5,7 @@\n 2017-05-08  6.9.8-5 Cristy  <quetzlzacatenango@image...>\n   * Fix transient PDF bug (reference\n     https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/463).\n+  * Check for EOF conditions for RLE image format.\n \n 2017-04-24  6.9.8-4 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 6.9.8-4, GIT revision 11521:d7433aa:20170424.\ndiff --git a\/coders\/rle.c b\/coders\/rle.c\nindex d780d56a1b..fc5b4124e6 100644\n--- a\/coders\/rle.c\n+++ b\/coders\/rle.c\n@@ -132,6 +132,15 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n #define ByteDataOp  0x05\n #define RunDataOp  0x06\n #define EOFOp  0x07\n+#define ThrowRLEException(exception,message) \\\n+{ \\\n+  if (colormap != (unsigned char *) NULL) \\\n+    colormap=(unsigned char *) RelinquishMagickMemory(colormap); \\\n+  if (pixel_info != (MemoryInfo *) NULL) \\\n+    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n+  ThrowReaderException((exception),(message)); \\\n+}\n+\n \n   char\n     magick[12];\n@@ -209,6 +218,8 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   \/*\n     Determine if this a RLE file.\n   *\/\n+  colormap=(unsigned char *) NULL;\n+  pixel_info=(MemoryInfo *) NULL;\n   count=ReadBlob(image,2,(unsigned char *) magick);\n   if ((count != 2) || (memcmp(magick,\"\\122\\314\",2) != 0))\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n@@ -217,8 +228,8 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     \/*\n       Read image header.\n     *\/\n-    image->page.x=ReadBlobLSBShort(image);\n-    image->page.y=ReadBlobLSBShort(image);\n+    image->page.x=(ssize_t) ReadBlobLSBShort(image);\n+    image->page.y=(ssize_t) ReadBlobLSBShort(image);\n     image->columns=ReadBlobLSBShort(image);\n     image->rows=ReadBlobLSBShort(image);\n     flags=(MagickStatusType) ReadBlobByte(image);\n@@ -229,6 +240,8 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     map_length=(unsigned char) ReadBlobByte(image);\n     if (map_length >= 22)\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    if (EOFBlob(image) != MagickFalse)\n+      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n     one=1;\n     map_length=one << map_length;\n     if ((number_planes == 0) || (number_planes == 2) ||\n@@ -256,11 +269,7 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     if ((number_planes & 0x01) == 0)\n       (void) ReadBlobByte(image);\n     if (EOFBlob(image) != MagickFalse)\n-      {\n-        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n-          image->filename);\n-        break;\n-      }\n+      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n     colormap=(unsigned char *) NULL;\n     if (number_colormaps != 0)\n       {\n@@ -274,8 +283,12 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         p=colormap;\n         for (i=0; i < (ssize_t) number_colormaps; i++)\n           for (x=0; x < (ssize_t) map_length; x++)\n+          {\n             *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(\n               ReadBlobLSBShort(image)));\n+            if (EOFBlob(image) != MagickFalse)\n+              ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n+          }\n       }\n     if ((flags & 0x08) != 0)\n       {\n@@ -303,11 +316,7 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           }\n       }\n     if (EOFBlob(image) != MagickFalse)\n-      {\n-        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n-          image->filename);\n-        break;\n-      }\n+      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n       if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n         break;\n@@ -365,6 +374,8 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n     x=0;\n     y=0;\n     opcode=ReadBlobByte(image);\n+    if (opcode == EOF)\n+      ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n     do\n     {\n       switch (opcode & 0x3f)\n@@ -372,8 +383,14 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         case SkipLinesOp:\n         {\n           operand=ReadBlobByte(image);\n+          if (opcode == EOF)\n+            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n           if (opcode & 0x40)\n-            operand=ReadBlobLSBSignedShort(image);\n+            {\n+              operand=ReadBlobLSBSignedShort(image);\n+              if (opcode == EOF)\n+                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n+            }\n           x=0;\n           y+=operand;\n           break;\n@@ -381,6 +398,8 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         case SetColorOp:\n         {\n           operand=ReadBlobByte(image);\n+          if (opcode == EOF)\n+            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n           plane=(unsigned char) operand;\n           if (plane == 255)\n             plane=(unsigned char) (number_planes-1);\n@@ -390,21 +409,33 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         case SkipPixelsOp:\n         {\n           operand=ReadBlobByte(image);\n+          if (opcode == EOF)\n+            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n           if (opcode & 0x40)\n-            operand=ReadBlobLSBSignedShort(image);\n+            {\n+              operand=ReadBlobLSBSignedShort(image);\n+              if (opcode == EOF)\n+                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n+            }\n           x+=operand;\n           break;\n         }\n         case ByteDataOp:\n         {\n           operand=ReadBlobByte(image);\n+          if (opcode == EOF)\n+            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n           if (opcode & 0x40)\n-            operand=ReadBlobLSBSignedShort(image);\n-          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n-            number_planes+plane;\n+            {\n+              operand=ReadBlobLSBSignedShort(image);\n+              if (opcode == EOF)\n+                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n+            }\n+          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n+            number_planes+plane);\n           operand++;\n           if ((offset < 0) ||\n-              (offset+((size_t) operand*number_planes) > pixel_info_length))\n+              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n             {\n               if (number_colormaps != 0)\n                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n@@ -428,15 +459,21 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         case RunDataOp:\n         {\n           operand=ReadBlobByte(image);\n+          if (opcode == EOF)\n+            ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n           if (opcode & 0x40)\n-            operand=ReadBlobLSBSignedShort(image);\n+            {\n+              operand=ReadBlobLSBSignedShort(image);\n+              if (opcode == EOF)\n+                ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n+            }\n           pixel=(unsigned char) ReadBlobByte(image);\n           (void) ReadBlobByte(image);\n           operand++;\n-          offset=((image->rows-y-1)*image->columns*number_planes)+x*\n-            number_planes+plane;\n+          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*\n+            number_planes+plane);\n           if ((offset < 0) ||\n-              (offset+((size_t) operand*number_planes) > pixel_info_length))\n+              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))\n             {\n               if (number_colormaps != 0)\n                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n@@ -458,6 +495,8 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           break;\n       }\n       opcode=ReadBlobByte(image);\n+      if (opcode == EOF)\n+        ThrowRLEException(CorruptImageError,\"UnexpectedEndOfFile\");\n     } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));\n     if (number_colormaps != 0)\n       {\n@@ -473,7 +512,7 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         if (number_colormaps == 1)\n           for (i=0; i < (ssize_t) number_pixels; i++)\n           {\n-            if (IsValidColormapIndex(image,*p & mask,&index,exception) ==\n+            if (IsValidColormapIndex(image,(ssize_t) (*p & mask),&index,exception) ==\n                 MagickFalse)\n               break;\n             *p=colormap[(ssize_t) index];\n@@ -484,7 +523,7 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n             for (i=0; i < (ssize_t) number_pixels; i++)\n               for (x=0; x < (ssize_t) number_planes; x++)\n               {\n-                if (IsValidColormapIndex(image,(size_t) (x*map_length+\n+                if (IsValidColormapIndex(image,(ssize_t) (x*map_length+\n                     (*p & mask)),&index,exception) == MagickFalse)\n                   break;\n                 *p=colormap[(ssize_t) index];\n@@ -598,15 +637,15 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)\n                 break;\n               for (x=0; x < (ssize_t) image->columns; x++)\n               {\n-                if (IsValidColormapIndex(image,*p++,&index,exception) ==\n+                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==\n                     MagickFalse)\n                   break;\n                 SetPixelRed(q,image->colormap[(ssize_t) index].red);\n-                if (IsValidColormapIndex(image,*p++,&index,exception) ==\n+                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==\n                     MagickFalse)\n                   break;\n                 SetPixelGreen(q,image->colormap[(ssize_t) index].green);\n-                if (IsValidColormapIndex(image,*p++,&index,exception) ==\n+                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==\n                     MagickFalse)\n                   break;\n                 SetPixelBlue(q,image->colormap[(ssize_t) index].blue);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-6837","CWE_ID":"20","category":"security","commit_id":"c48e4c6503f7dabd41f11d4c9c7b7f8960e7f2c0","commit_message":"From c48e4c6503f7dabd41f11d4c9c7b7f8960e7f2c0 Mon Sep 17 00:00:00 2001\nFrom: Antonio Larrosa <larrosa@kde.org>\nDate: Mon, 6 Mar 2017 12:51:22 +0100\nSubject: [PATCH] Always check the number of coefficients\n\nWhen building the library with NDEBUG, asserts are eliminated\nso it's better to always check that the number of coefficients\nis inside the array range.\n\nThis fixes the 00191-audiofile-indexoob issue in #41\n---\n libaudiofile\/WAVE.cpp | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/libaudiofile\/WAVE.cpp b\/libaudiofile\/WAVE.cpp\nindex 0e81cf7..61f9541 100644\n--- a\/libaudiofile\/WAVE.cpp\n+++ b\/libaudiofile\/WAVE.cpp\n@@ -281,6 +281,12 @@ status WAVEFile::parseFormat(const Tag &id, uint32_t size)\n \n \t\t\t\/* numCoefficients should be at least 7. *\/\n \t\t\tassert(numCoefficients >= 7 && numCoefficients <= 255);\n+\t\t\tif (numCoefficients < 7 || numCoefficients > 255)\n+\t\t\t{\n+\t\t\t\t_af_error(AF_BAD_HEADER,\n+\t\t\t\t\t\t\"Bad number of coefficients\");\n+\t\t\t\treturn AF_FAIL;\n+\t\t\t}\n \n \t\t\tm_msadpcmNumCoefficients = numCoefficients;\n \n","owner":"antlarr","repo":"audiofile","source":"cve"},{"CVE_ID":"CVE-2012-0879","CWE_ID":"20","category":"security","commit_id":"b69f2292063d2caf37ca9aec7d63ded203701bf3","commit_message":"From b69f2292063d2caf37ca9aec7d63ded203701bf3 Mon Sep 17 00:00:00 2001\nFrom: Louis Rilling <louis.rilling@kerlabs.com>\nDate: Fri, 4 Dec 2009 14:52:42 +0100\nSubject: block: Fix io_context leak after failure of clone with CLONE_IO\n\nWith CLONE_IO, parent's io_context->nr_tasks is incremented, but never\ndecremented whenever copy_process() fails afterwards, which prevents\nexit_io_context() from calling IO schedulers exit functions.\n\nGive a task_struct to exit_io_context(), and call exit_io_context() instead of\nput_io_context() in copy_process() cleanup path.\n\nSigned-off-by: Louis Rilling <louis.rilling@kerlabs.com>\nSigned-off-by: Jens Axboe <jens.axboe@oracle.com>\n---\n block\/blk-ioc.c           | 10 +++++-----\n include\/linux\/iocontext.h |  5 +++--\n kernel\/exit.c             |  2 +-\n kernel\/fork.c             |  3 ++-\n 4 files changed, 11 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/block\/blk-ioc.c b\/block\/blk-ioc.c\nindex dcd041290b28..cbdabb0dd6d7 100644\n--- a\/block\/blk-ioc.c\n+++ b\/block\/blk-ioc.c\n@@ -66,14 +66,14 @@ static void cfq_exit(struct io_context *ioc)\n }\n \n \/* Called by the exitting task *\/\n-void exit_io_context(void)\n+void exit_io_context(struct task_struct *task)\n {\n \tstruct io_context *ioc;\n \n-\ttask_lock(current);\n-\tioc = current->io_context;\n-\tcurrent->io_context = NULL;\n-\ttask_unlock(current);\n+\ttask_lock(task);\n+\tioc = task->io_context;\n+\ttask->io_context = NULL;\n+\ttask_unlock(task);\n \n \tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n \t\tif (ioc->aic && ioc->aic->exit)\ndiff --git a\/include\/linux\/iocontext.h b\/include\/linux\/iocontext.h\nindex d61b0b8b5cd1..a63235996309 100644\n--- a\/include\/linux\/iocontext.h\n+++ b\/include\/linux\/iocontext.h\n@@ -98,14 +98,15 @@ static inline struct io_context *ioc_task_link(struct io_context *ioc)\n \treturn NULL;\n }\n \n+struct task_struct;\n #ifdef CONFIG_BLOCK\n int put_io_context(struct io_context *ioc);\n-void exit_io_context(void);\n+void exit_io_context(struct task_struct *task);\n struct io_context *get_io_context(gfp_t gfp_flags, int node);\n struct io_context *alloc_io_context(gfp_t gfp_flags, int node);\n void copy_io_context(struct io_context **pdst, struct io_context **psrc);\n #else\n-static inline void exit_io_context(void)\n+static inline void exit_io_context(struct task_struct *task)\n {\n }\n \ndiff --git a\/kernel\/exit.c b\/kernel\/exit.c\nindex f7864ac2ecc1..2544000125d9 100644\n--- a\/kernel\/exit.c\n+++ b\/kernel\/exit.c\n@@ -1004,7 +1004,7 @@ NORET_TYPE void do_exit(long code)\n \ttsk->flags |= PF_EXITPIDONE;\n \n \tif (tsk->io_context)\n-\t\texit_io_context();\n+\t\texit_io_context(tsk);\n \n \tif (tsk->splice_pipe)\n \t\t__free_pipe_info(tsk->splice_pipe);\ndiff --git a\/kernel\/fork.c b\/kernel\/fork.c\nindex 166b8c49257c..607353425bb0 100644\n--- a\/kernel\/fork.c\n+++ b\/kernel\/fork.c\n@@ -1310,7 +1310,8 @@ bad_fork_free_pid:\n \tif (pid != &init_struct_pid)\n \t\tfree_pid(pid);\n bad_fork_cleanup_io:\n-\tput_io_context(p->io_context);\n+\tif (p->io_context)\n+\t\texit_io_context(p);\n bad_fork_cleanup_namespaces:\n \texit_task_namespaces(p);\n bad_fork_cleanup_mm:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-2523","CWE_ID":"20","category":"security","commit_id":"b22f5126a24b3b2f15448c3f2a254fc10cbc2b92","commit_message":"From b22f5126a24b3b2f15448c3f2a254fc10cbc2b92 Mon Sep 17 00:00:00 2001\nFrom: Daniel Borkmann <dborkman@redhat.com>\nDate: Mon, 6 Jan 2014 00:57:54 +0100\nSubject: netfilter: nf_conntrack_dccp: fix skb_header_pointer API usages\n\nSome occurences in the netfilter tree use skb_header_pointer() in\nthe following way ...\n\n  struct dccp_hdr _dh, *dh;\n  ...\n  skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\n... where dh itself is a pointer that is being passed as the copy\nbuffer. Instead, we need to use &_dh as the forth argument so that\nwe're copying the data into an actual buffer that sits on the stack.\n\nCurrently, we probably could overwrite memory on the stack (e.g.\nwith a possibly mal-formed DCCP packet), but unintentionally, as\nwe only want the buffer to be placed into _dh variable.\n\nFixes: 2bc780499aa3 (\"[NETFILTER]: nf_conntrack: add DCCP protocol support\")\nSigned-off-by: Daniel Borkmann <dborkman@redhat.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>\n---\n net\/netfilter\/nf_conntrack_proto_dccp.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/net\/netfilter\/nf_conntrack_proto_dccp.c b\/net\/netfilter\/nf_conntrack_proto_dccp.c\nindex 38412684a882..cb372f96f10d 100644\n--- a\/net\/netfilter\/nf_conntrack_proto_dccp.c\n+++ b\/net\/netfilter\/nf_conntrack_proto_dccp.c\n@@ -428,7 +428,7 @@ static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n \tconst char *msg;\n \tu_int8_t state;\n \n-\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n+\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n \tBUG_ON(dh == NULL);\n \n \tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n@@ -486,7 +486,7 @@ static int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,\n \tu_int8_t type, old_state, new_state;\n \tenum ct_dccp_roles role;\n \n-\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n+\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n \tBUG_ON(dh == NULL);\n \ttype = dh->dccph_type;\n \n@@ -577,7 +577,7 @@ static int dccp_error(struct net *net, struct nf_conn *tmpl,\n \tunsigned int cscov;\n \tconst char *msg;\n \n-\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n+\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n \tif (dh == NULL) {\n \t\tmsg = \"nf_ct_dccp: short packet \";\n \t\tgoto out_invalid;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-20684","CWE_ID":"20","category":"security","commit_id":"49d876f2c5fc00bcedaa986a7cf6dedd6bf16f54","commit_message":"From 49d876f2c5fc00bcedaa986a7cf6dedd6bf16f54 Mon Sep 17 00:00:00 2001\nFrom: Martin Prikryl <martin@winscp.net>\nDate: Mon, 3 Sep 2018 12:50:44 +0000\nSubject: [PATCH] Bug 1675: Prevent SCP server sending files that were not\n requested\n\nhttps:\/\/winscp.net\/tracker\/1675\n\nSource commit: 4aa587620973bf793fb6e783052277c0f7be4b55\n---\n source\/core\/ScpFileSystem.cpp | 4 ++++\n source\/resource\/TextsCore.h   | 1 +\n source\/resource\/TextsCore1.rc | 1 +\n 3 files changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/source\/core\/ScpFileSystem.cpp b\/source\/core\/ScpFileSystem.cpp\nindex f5a06b9fc..40dcb5401 100644\n--- a\/source\/core\/ScpFileSystem.cpp\n+++ b\/source\/core\/ScpFileSystem.cpp\n@@ -2361,6 +2361,10 @@ void __fastcall TSCPFileSystem::SCPSink(const UnicodeString TargetDir,\n           {\n             FTerminal->LogEvent(FORMAT(L\"Warning: Remote host set a compound pathname '%s'\", (Line)));\n           }\n+          if ((Level == 0) && (OnlyFileName != UnixExtractFileName(FileName)))\n+          {\n+            SCPError(LoadStr(UNREQUESTED_FILE), False);\n+          }\n \n           FullFileName = SourceDir + OnlyFileName;\n           OperationProgress->SetFile(FullFileName);\ndiff --git a\/source\/resource\/TextsCore.h b\/source\/resource\/TextsCore.h\nindex 905e15103..4f4f70a83 100644\n--- a\/source\/resource\/TextsCore.h\n+++ b\/source\/resource\/TextsCore.h\n@@ -270,6 +270,7 @@\n #define S3_STATUS_ACCESS_DENIED 746\n #define UNKNOWN_FILE_ENCRYPTION 747\n #define INVALID_ENCRYPT_KEY     748\n+#define UNREQUESTED_FILE        749\n \n #define CORE_CONFIRMATION_STRINGS 300\n #define CONFIRM_PROLONG_TIMEOUT3 301\ndiff --git a\/source\/resource\/TextsCore1.rc b\/source\/resource\/TextsCore1.rc\nindex 32c6364d0..ee50347ac 100644\n--- a\/source\/resource\/TextsCore1.rc\n+++ b\/source\/resource\/TextsCore1.rc\n@@ -241,6 +241,7 @@ BEGIN\n   MISSING_TARGET_BUCKET, \"Specify target bucket.\"\n   UNKNOWN_FILE_ENCRYPTION, \"File is not encrypted using a known encryption.\"\n   INVALID_ENCRYPT_KEY, \"**Invalid encryption key.**\\n\\nEncryption key for %s encryption must have %d bytes. It must be entered in hexadecimal representation (i.e. %d characters).\"\n+  UNREQUESTED_FILE, \"Server sent a file that was not requested.\"\n \n   CORE_CONFIRMATION_STRINGS, \"CORE_CONFIRMATION\"\n   CONFIRM_PROLONG_TIMEOUT3, \"Host is not communicating for %d seconds.\\n\\nWait for another %0:d seconds?\"\n","owner":"winscp","repo":"winscp","source":"cve"},{"CVE_ID":"CVE-2017-16227","CWE_ID":"20","category":"security","commit_id":"7a42b78be9a4108d98833069a88e6fddb9285008","commit_message":"From 7a42b78be9a4108d98833069a88e6fddb9285008 Mon Sep 17 00:00:00 2001\nFrom: Andreas Jaggi <aj@open.ch>\nDate: Mon, 2 Oct 2017 19:38:43 +0530\nSubject: bgpd: Fix AS_PATH size calculation for long paths\n\nIf you have an AS_PATH with more entries than\nwhat can be written into a single AS_SEGMENT_MAX\nit needs to be broken up.  The code that noticed\nthat the AS_PATH needs to be broken up was not\ncorrectly calculating the size of the resulting\nmessage.  This patch addresses this issue.\n---\n bgpd\/bgp_aspath.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/bgpd\/bgp_aspath.c b\/bgpd\/bgp_aspath.c\nindex b7af5e8..d813bfb 100644\n--- a\/bgpd\/bgp_aspath.c\n+++ b\/bgpd\/bgp_aspath.c\n@@ -903,7 +903,7 @@ aspath_put (struct stream *s, struct aspath *as, int use32bit )\n               assegment_header_put (s, seg->type, AS_SEGMENT_MAX);\n               assegment_data_put (s, seg->as, AS_SEGMENT_MAX, use32bit);\n               written += AS_SEGMENT_MAX;\n-              bytes += ASSEGMENT_SIZE (written, use32bit);\n+              bytes += ASSEGMENT_SIZE (AS_SEGMENT_MAX, use32bit);\n             }\n           \n           \/* write the final segment, probably is also the first *\/\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-1185","CWE_ID":"20","category":"security","commit_id":"e2b362d9f23d4c63018709ab5f81a02f72b91e75","commit_message":"From e2b362d9f23d4c63018709ab5f81a02f72b91e75 Mon Sep 17 00:00:00 2001\nFrom: Kay Sievers <kay.sievers@vrfy.org>\nDate: Wed, 8 Apr 2009 07:46:54 -0700\nSubject: libudev: monitor - unify socket message handling\n\n---\n udev\/lib\/libudev-monitor.c | 62 ++++++++++++++++++++++------------------------\n 1 file changed, 30 insertions(+), 32 deletions(-)\n\n","diff_code":"diff --git a\/udev\/lib\/libudev-monitor.c b\/udev\/lib\/libudev-monitor.c\nindex a8b1a4e2..21bd19ba 100644\n--- a\/udev\/lib\/libudev-monitor.c\n+++ b\/udev\/lib\/libudev-monitor.c\n@@ -143,25 +143,22 @@ int udev_monitor_enable_receiving(struct udev_monitor *udev_monitor)\n \tint err;\n \tconst int on = 1;\n \n-\tif (udev_monitor->snl.nl_family != 0) {\n-\t\terr = bind(udev_monitor->sock,\n-\t\t\t   (struct sockaddr *)&udev_monitor->snl, sizeof(struct sockaddr_nl));\n-\t\tif (err < 0) {\n-\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n-\t\t\treturn err;\n-\t\t}\n-\t\tdbg(udev_monitor->udev, \"monitor %p listening on netlink\\n\", udev_monitor);\n-\t} else if (udev_monitor->sun.sun_family != 0) {\n+\tif (udev_monitor->sun.sun_family != 0)\n \t\terr = bind(udev_monitor->sock,\n \t\t\t   (struct sockaddr *)&udev_monitor->sun, udev_monitor->addrlen);\n-\t\tif (err < 0) {\n-\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n-\t\t\treturn err;\n-\t\t}\n-\t\t\/* enable receiving of the sender credentials *\/\n-\t\tsetsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));\n-\t\tdbg(udev_monitor->udev, \"monitor %p listening on socket\\n\", udev_monitor);\n+\telse if (udev_monitor->snl.nl_family != 0)\n+\t\terr = bind(udev_monitor->sock,\n+\t\t\t   (struct sockaddr *)&udev_monitor->snl, sizeof(struct sockaddr_nl));\n+\telse\n+\t\treturn -EINVAL;\n+\n+\tif (err < 0) {\n+\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n+\t\treturn err;\n \t}\n+\n+\t\/* enable receiving of sender credentials *\/\n+\tsetsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));\n \treturn 0;\n }\n \n@@ -262,6 +259,8 @@ struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monito\n \tstruct msghdr smsg;\n \tstruct iovec iov;\n \tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n+\tstruct cmsghdr *cmsg;\n+\tstruct ucred *cred;\n \tchar buf[4096];\n \tsize_t bufpos;\n \tint devpath_set = 0;\n@@ -287,19 +286,16 @@ struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monito\n \t\treturn NULL;\n \t}\n \n-\tif (udev_monitor->sun.sun_family != 0) {\n-\t\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&smsg);\n-\t\tstruct ucred *cred = (struct ucred *)CMSG_DATA (cmsg);\n-\n-\t\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n-\t\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n-\t\t\treturn NULL;\n-\t\t}\n+\tcmsg = CMSG_FIRSTHDR(&smsg);\n+\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n+\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n+\t\treturn NULL;\n+\t}\n \n-\t\tif (cred->uid != 0) {\n-\t\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n-\t\t\treturn NULL;\n-\t\t}\n+\tcred = (struct ucred *)CMSG_DATA(cmsg);\n+\tif (cred->uid != 0) {\n+\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n+\t\treturn NULL;\n \t}\n \n \t\/* skip header *\/\n@@ -404,18 +400,20 @@ int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_devi\n \tlen = udev_device_get_properties_monitor_buf(udev_device, &buf);\n \tif (len < 32)\n \t\treturn -1;\n-\tif (udev_monitor->sun.sun_family != 0) {\n+\tif (udev_monitor->sun.sun_family != 0)\n \t\tcount = sendto(udev_monitor->sock,\n \t\t\t       buf, len, 0,\n \t\t\t       (struct sockaddr *)&udev_monitor->sun,\n \t\t\t       udev_monitor->addrlen);\n-\t} else {\n-\t\t\/* no destination besides the muticast group, we will always get -1 ECONNREFUSED *\/\n+\telse if (udev_monitor->snl.nl_family != 0)\n+\t\t\/* no destination besides the muticast group, we will always get ECONNREFUSED *\/\n \t\tcount = sendto(udev_monitor->sock,\n \t\t\t       buf, len, 0,\n \t\t\t       (struct sockaddr *)&udev_monitor->snl_peer,\n \t\t\t       sizeof(struct sockaddr_nl));\n-\t}\n+\telse\n+\t\treturn -1;\n+\n \tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n \treturn count;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"keszybz","repo":"systemd","source":"cve"},{"CVE_ID":"CVE-2016-7157","CWE_ID":"20","category":"security","commit_id":"65a8e1f6413a0f6f79894da710b5d6d43361d27d","commit_message":"From 65a8e1f6413a0f6f79894da710b5d6d43361d27d Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Mon, 29 Aug 2016 11:35:37 +0200\nSubject: [PATCH] scsi: mptconfig: fix misuse of MPTSAS_CONFIG_PACK\n\nThese issues cause respectively a QEMU crash and a leak of 2 bytes of\nstack.  They were discovered by VictorV of 360 Marvel Team.\n\nReported-by: Tom Victor <i-tangtianwen@360.cm>\nCc: qemu-stable@nongnu.org\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n hw\/scsi\/mptconfig.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/hw\/scsi\/mptconfig.c b\/hw\/scsi\/mptconfig.c\nindex 3e4f400..87a416a 100644\n--- a\/hw\/scsi\/mptconfig.c\n+++ b\/hw\/scsi\/mptconfig.c\n@@ -203,7 +203,7 @@ size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address\n {\n     \/* VPD - all zeros *\/\n     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n-                              \"s256\");\n+                              \"*s256\");\n }\n \n static\n@@ -328,7 +328,7 @@ size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)\n     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n                               \"*l*lwwb*b*b*blww\",\n                               pcic->vendor_id, pcic->device_id, pcic->revision,\n-                              pcic->subsystem_vendor_id,\n+                              pcic->class_id, pcic->subsystem_vendor_id,\n                               pcic->subsystem_id);\n }\n \n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-14619","CWE_ID":"20","category":"security","commit_id":"b32a7dc8aef1882fbf983eb354837488cc9d54dc","commit_message":"From b32a7dc8aef1882fbf983eb354837488cc9d54dc Mon Sep 17 00:00:00 2001\nFrom: Eric Biggers <ebiggers@google.com>\nDate: Mon, 27 Nov 2017 23:23:05 -0800\nSubject: crypto: algif_aead - fix reference counting of null skcipher\n\nIn the AEAD interface for AF_ALG, the reference to the \"null skcipher\"\nheld by each tfm was being dropped in the wrong place -- when each\naf_alg_ctx was freed instead of when the aead_tfm was freed.  As\ndiscovered by syzkaller, a specially crafted program could use this to\ncause the null skcipher to be freed while it is still in use.\n\nFix it by dropping the reference in the right place.\n\nFixes: 72548b093ee3 (\"crypto: algif_aead - copy AAD from src to dst\")\nReported-by: syzbot <syzkaller@googlegroups.com>\nCc: <stable@vger.kernel.org> # v4.14+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nReviewed-by: Stephan Mueller <smueller@chronox.de>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\n---\n crypto\/algif_aead.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/crypto\/algif_aead.c b\/crypto\/algif_aead.c\nindex aacae0837aff..9d73be28cf01 100644\n--- a\/crypto\/algif_aead.c\n+++ b\/crypto\/algif_aead.c\n@@ -487,6 +487,7 @@ static void aead_release(void *private)\n \tstruct aead_tfm *tfm = private;\n \n \tcrypto_free_aead(tfm->aead);\n+\tcrypto_put_default_null_skcipher2();\n \tkfree(tfm);\n }\n \n@@ -519,7 +520,6 @@ static void aead_sock_destruct(struct sock *sk)\n \tunsigned int ivlen = crypto_aead_ivsize(tfm);\n \n \taf_alg_pull_tsgl(sk, ctx->used, NULL, 0);\n-\tcrypto_put_default_null_skcipher2();\n \tsock_kzfree_s(sk, ctx->iv, ivlen);\n \tsock_kfree_s(sk, ctx, ctx->len);\n \taf_alg_release_parent(sk);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-5147","CWE_ID":"20","category":"security","commit_id":"4600cf725a86ce31266153647ae5aa1197b1215b","commit_message":"From 4600cf725a86ce31266153647ae5aa1197b1215b Mon Sep 17 00:00:00 2001\nFrom: yugui <yugui@b2dd03c8-39d4-4d8f-98ff-823fe69b080e>\nDate: Mon, 11 May 2009 15:07:10 +0000\nSubject: [PATCH] * ext\/dl\/dl.c (rb_dlhandle_initialize): prohibits DL::dlopen \n  with a tainted name of library.   Patch by sheepman <sheepman AT\n sheepman.sakura.ne.jp>.\n\n* ext\/dl\/dl.c (rb_dlhandle_sym): ditto\n\ngit-svn-id: svn+ssh:\/\/ci.ruby-lang.org\/ruby\/branches\/ruby_1_9_1@23405 b2dd03c8-39d4-4d8f-98ff-823fe69b080e\n---\n ChangeLog       | 8 ++++++++\n ext\/dl\/handle.c | 8 +++++---\n 2 files changed, 13 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 1de38d363881..9bacb4012588 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,11 @@\n+Mon May 11 23:14:06 2009  Yuki Sonoda (Yugui)  <yugui@yugui.jp>\n+\n+\t* ext\/dl\/dl.c (rb_dlhandle_initialize): prohibits DL::dlopen\n+\t  with a tainted name of library.\n+\t  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.\n+\n+\t* ext\/dl\/dl.c (rb_dlhandle_sym): ditto\n+\n Mon May 11 22:33:46 2009  Yuki Sonoda (Yugui)  <yugui@yugui.jp>\n \n \t* ext\/dl\/lib\/dl\/func.rb (DL::Function#call): prevents\ndiff --git a\/ext\/dl\/handle.c b\/ext\/dl\/handle.c\nindex ee3c644985f8..d72f725fbbde 100644\n--- a\/ext\/dl\/handle.c\n+++ b\/ext\/dl\/handle.c\n@@ -5,6 +5,8 @@\n #include <ruby.h>\n #include \"dl.h\"\n \n+#define SafeStringValuePtr(v) (rb_string_value(&v), rb_check_safe_obj(v), RSTRING_PTR(v))\n+\n VALUE rb_cDLHandle;\n \n void\n@@ -56,11 +58,11 @@ rb_dlhandle_initialize(int argc, VALUE argv[], VALUE self)\n     cflag = RTLD_LAZY | RTLD_GLOBAL;\n     break;\n   case 1:\n-    clib = NIL_P(lib) ? NULL : StringValuePtr(lib);\n+    clib = NIL_P(lib) ? NULL : SafeStringValuePtr(lib);\n     cflag = RTLD_LAZY | RTLD_GLOBAL;\n     break;\n   case 2:\n-    clib = NIL_P(lib) ? NULL : StringValuePtr(lib);\n+    clib = NIL_P(lib) ? NULL : SafeStringValuePtr(lib);\n     cflag = NUM2INT(flag);\n     break;\n   default:\n@@ -140,7 +142,7 @@ rb_dlhandle_sym(VALUE self, VALUE sym)\n \n     rb_secure(2);\n \n-    name = StringValuePtr(sym);\n+    name = SafeStringValuePtr(sym);\n \n     Data_Get_Struct(self, struct dl_handle, dlhandle);\n     if( ! dlhandle->open ){\n","owner":"ruby","repo":"ruby","source":"cve"},{"CVE_ID":"CVE-2016-2548","CWE_ID":"20","category":"security","commit_id":"b5a663aa426f4884c71cd8580adae73f33570f0d","commit_message":"From b5a663aa426f4884c71cd8580adae73f33570f0d Mon Sep 17 00:00:00 2001\nFrom: Takashi Iwai <tiwai@suse.de>\nDate: Thu, 14 Jan 2016 16:30:58 +0100\nSubject: ALSA: timer: Harden slave timer list handling\n\nA slave timer instance might be still accessible in a racy way while\noperating the master instance as it lacks of locking.  Since the\nmaster operation is mostly protected with timer->lock, we should cope\nwith it while changing the slave instance, too.  Also, some linked\nlists (active_list and ack_list) of slave instances aren't unlinked\nimmediately at stopping or closing, and this may lead to unexpected\naccesses.\n\nThis patch tries to address these issues.  It adds spin lock of\ntimer->lock (either from master or slave, which is equivalent) in a\nfew places.  For avoiding a deadlock, we ensure that the global\nslave_active_lock is always locked at first before each timer lock.\n\nAlso, ack and active_list of slave instances are properly unlinked at\nsnd_timer_stop() and snd_timer_close().\n\nLast but not least, remove the superfluous call of _snd_timer_stop()\nat removing slave links.  This is a noop, and calling it may confuse\nreaders wrt locking.  Further cleanup will follow in a later patch.\n\nActually we've got reports of use-after-free by syzkaller fuzzer, and\nthis hopefully fixes these issues.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/core\/timer.c | 18 ++++++++++++++----\n 1 file changed, 14 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/sound\/core\/timer.c b\/sound\/core\/timer.c\nindex 3810ee8f1205..4e8d7bfffff6 100644\n--- a\/sound\/core\/timer.c\n+++ b\/sound\/core\/timer.c\n@@ -215,11 +215,13 @@ static void snd_timer_check_master(struct snd_timer_instance *master)\n \t\t    slave->slave_id == master->slave_id) {\n \t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n \t\t\tspin_lock_irq(&slave_active_lock);\n+\t\t\tspin_lock(&master->timer->lock);\n \t\t\tslave->master = master;\n \t\t\tslave->timer = master->timer;\n \t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n \t\t\t\tlist_add_tail(&slave->active_list,\n \t\t\t\t\t      &master->slave_active_head);\n+\t\t\tspin_unlock(&master->timer->lock);\n \t\t\tspin_unlock_irq(&slave_active_lock);\n \t\t}\n \t}\n@@ -346,15 +348,18 @@ int snd_timer_close(struct snd_timer_instance *timeri)\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\t\/* remove slave links *\/\n+\t\tspin_lock_irq(&slave_active_lock);\n+\t\tspin_lock(&timer->lock);\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n-\t\t\tspin_lock_irq(&slave_active_lock);\n-\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n-\t\t\tspin_unlock_irq(&slave_active_lock);\n+\t\t\tlist_del_init(&slave->ack_list);\n+\t\t\tlist_del_init(&slave->active_list);\n \t\t}\n+\t\tspin_unlock(&timer->lock);\n+\t\tspin_unlock_irq(&slave_active_lock);\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:\n@@ -441,9 +446,12 @@ static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n \n \tspin_lock_irqsave(&slave_active_lock, flags);\n \ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n-\tif (timeri->master)\n+\tif (timeri->master && timeri->timer) {\n+\t\tspin_lock(&timeri->timer->lock);\n \t\tlist_add_tail(&timeri->active_list,\n \t\t\t      &timeri->master->slave_active_head);\n+\t\tspin_unlock(&timeri->timer->lock);\n+\t}\n \tspin_unlock_irqrestore(&slave_active_lock, flags);\n \treturn 1; \/* delayed start *\/\n }\n@@ -489,6 +497,8 @@ static int _snd_timer_stop(struct snd_timer_instance * timeri,\n \t\tif (!keep_flag) {\n \t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n \t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n+\t\t\tlist_del_init(&timeri->ack_list);\n+\t\t\tlist_del_init(&timeri->active_list);\n \t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n \t\t}\n \t\tgoto __end;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-0038","CWE_ID":"20","category":"security","commit_id":"2def2ef2ae5f3990aabdbe8a755911902707d268","commit_message":"From 2def2ef2ae5f3990aabdbe8a755911902707d268 Mon Sep 17 00:00:00 2001\nFrom: PaX Team <pageexec@freemail.hu>\nDate: Thu, 30 Jan 2014 16:59:25 -0800\nSubject: x86, x32: Correct invalid use of user timespec in the kernel\n\nThe x32 case for the recvmsg() timout handling is broken:\n\n  asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n                                      unsigned int vlen, unsigned int flags,\n                                      struct compat_timespec __user *timeout)\n  {\n          int datagrams;\n          struct timespec ktspec;\n\n          if (flags & MSG_CMSG_COMPAT)\n                  return -EINVAL;\n\n          if (COMPAT_USE_64BIT_TIME)\n                  return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n                                        flags | MSG_CMSG_COMPAT,\n                                        (struct timespec *) timeout);\n          ...\n\nThe timeout pointer parameter is provided by userland (hence the __user\nannotation) but for x32 syscalls it's simply cast to a kernel pointer\nand is passed to __sys_recvmmsg which will eventually directly\ndereference it for both reading and writing.  Other callers to\n__sys_recvmmsg properly copy from userland to the kernel first.\n\nThe bug was introduced by commit ee4fa23c4bfc (\"compat: Use\nCOMPAT_USE_64BIT_TIME in net\/compat.c\") and should affect all kernels\nsince 3.4 (and perhaps vendor kernels if they backported x32 support\nalong with this code).\n\nNote that CONFIG_X86_X32_ABI gets enabled at build time and only if\nCONFIG_X86_X32 is enabled and ld can build x32 executables.\n\nOther uses of COMPAT_USE_64BIT_TIME seem fine.\n\nThis addresses CVE-2014-0038.\n\nSigned-off-by: PaX Team <pageexec@freemail.hu>\nSigned-off-by: H. Peter Anvin <hpa@linux.intel.com>\nCc: <stable@vger.kernel.org> # v3.4+\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n net\/compat.c | 9 ++-------\n 1 file changed, 2 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/net\/compat.c b\/net\/compat.c\nindex dd32e34c1e2c..f50161fb812e 100644\n--- a\/net\/compat.c\n+++ b\/net\/compat.c\n@@ -780,21 +780,16 @@ asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n \n-\tif (COMPAT_USE_64BIT_TIME)\n-\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n-\t\t\t\t      flags | MSG_CMSG_COMPAT,\n-\t\t\t\t      (struct timespec *) timeout);\n-\n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n \n-\tif (get_compat_timespec(&ktspec, timeout))\n+\tif (compat_get_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n-\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n+\tif (datagrams > 0 && compat_put_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \n \treturn datagrams;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-5338","CWE_ID":"20","category":"security","commit_id":"ff589551c8e8e9e95e211b9d8daafb4ed39f1aec","commit_message":"From ff589551c8e8e9e95e211b9d8daafb4ed39f1aec Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Mon, 6 Jun 2016 22:04:43 +0530\nSubject: [PATCH] scsi: esp: check TI buffer index before read\/write\n\nThe 53C9X Fast SCSI Controller(FSC) comes with internal 16-byte\nFIFO buffers. One is used to handle commands and other is for\ninformation transfer. Three control variables 'ti_rptr',\n'ti_wptr' and 'ti_size' are used to control r\/w access to the\ninformation transfer buffer ti_buf[TI_BUFSZ=16]. In that,\n\n'ti_rptr' is used as read index, where read occurs.\n'ti_wptr' is a write index, where write would occur.\n'ti_size' indicates total bytes to be read from the buffer.\n\nWhile reading\/writing to this buffer, index could exceed its\nsize. Add check to avoid OOB r\/w access.\n\nReported-by: Huawei PSIRT <psirt@huawei.com>\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nMessage-Id: <1465230883-22303-1-git-send-email-ppandit@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n hw\/scsi\/esp.c | 20 +++++++++-----------\n 1 file changed, 9 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/hw\/scsi\/esp.c b\/hw\/scsi\/esp.c\nindex 591c817..3adb685 100644\n--- a\/hw\/scsi\/esp.c\n+++ b\/hw\/scsi\/esp.c\n@@ -400,19 +400,17 @@ uint64_t esp_reg_read(ESPState *s, uint32_t saddr)\n     trace_esp_mem_readb(saddr, s->rregs[saddr]);\n     switch (saddr) {\n     case ESP_FIFO:\n-        if (s->ti_size > 0) {\n+        if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n+            \/* Data out.  *\/\n+            qemu_log_mask(LOG_UNIMP, \"esp: PIO data read not implemented\\n\");\n+            s->rregs[ESP_FIFO] = 0;\n+            esp_raise_irq(s);\n+        } else if (s->ti_rptr < s->ti_wptr) {\n             s->ti_size--;\n-            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {\n-                \/* Data out.  *\/\n-                qemu_log_mask(LOG_UNIMP,\n-                              \"esp: PIO data read not implemented\\n\");\n-                s->rregs[ESP_FIFO] = 0;\n-            } else {\n-                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n-            }\n+            s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];\n             esp_raise_irq(s);\n         }\n-        if (s->ti_size == 0) {\n+        if (s->ti_rptr == s->ti_wptr) {\n             s->ti_rptr = 0;\n             s->ti_wptr = 0;\n         }\n@@ -456,7 +454,7 @@ void esp_reg_write(ESPState *s, uint32_t saddr, uint64_t val)\n             } else {\n                 trace_esp_error_fifo_overrun();\n             }\n-        } else if (s->ti_size == TI_BUFSZ - 1) {\n+        } else if (s->ti_wptr == TI_BUFSZ - 1) {\n             trace_esp_error_fifo_overrun();\n         } else {\n             s->ti_size++;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10544","CWE_ID":"20","category":"security","commit_id":"37deefd01f0875e133ea967122e3a5e421b8fcd9","commit_message":"From 37deefd01f0875e133ea967122e3a5e421b8fcd9 Mon Sep 17 00:00:00 2001\nFrom: Alex Hultman <alexhultman@localhost.localdomain>\nDate: Thu, 13 Oct 2016 23:19:43 +0200\nSubject: [PATCH] Don't inflate more than ~16mb, drop connection on inflate\n error\n\n---\n src\/Hub.cpp           | 7 +++++--\n src\/WebSocketImpl.cpp | 8 ++++++++\n 2 files changed, 13 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/Hub.cpp b\/src\/Hub.cpp\nindex 35020083..6ff96a4c 100644\n--- a\/src\/Hub.cpp\n+++ b\/src\/Hub.cpp\n@@ -2,6 +2,8 @@\n #include \"HTTPSocket.h\"\n #include <openssl\/sha.h>\n \n+static const int INFLATE_LESS_THAN_ROUGHLY = 16777216;\n+\n namespace uWS {\n \n char *Hub::inflate(char *data, size_t &length) {\n@@ -18,12 +20,13 @@ char *Hub::inflate(char *data, size_t &length) {\n         if (!inflationStream.avail_in) {\n             break;\n         }\n+\n         dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n-    } while (err == Z_BUF_ERROR);\n+    } while (err == Z_BUF_ERROR && dynamicInflationBuffer.length() <= INFLATE_LESS_THAN_ROUGHLY);\n \n     inflateReset(&inflationStream);\n \n-    if (err != Z_BUF_ERROR && err != Z_OK) {\n+    if ((err != Z_BUF_ERROR && err != Z_OK) || dynamicInflationBuffer.length() > INFLATE_LESS_THAN_ROUGHLY) {\n         length = 0;\n         return nullptr;\n     }\ndiff --git a\/src\/WebSocketImpl.cpp b\/src\/WebSocketImpl.cpp\nindex 976ba7cf..e9d91ca9 100644\n--- a\/src\/WebSocketImpl.cpp\n+++ b\/src\/WebSocketImpl.cpp\n@@ -36,6 +36,10 @@ bool WebSocketProtocol<isServer>::handleFragment(char *data, size_t length, unsi\n                 webSocketData->compressionStatus = WebSocket<isServer>::Data::CompressionStatus::ENABLED;\n                 Hub *hub = ((Group<isServer> *) s.getSocketData()->nodeData)->hub;\n                 data = hub->inflate(data, length);\n+                if (!data) {\n+                    forceClose(user);\n+                    return true;\n+                }\n             }\n \n             if (opCode == 1 && !isValidUtf8((unsigned char *) data, length)) {\n@@ -56,6 +60,10 @@ bool WebSocketProtocol<isServer>::handleFragment(char *data, size_t length, unsi\n                     Hub *hub = ((Group<isServer> *) s.getSocketData()->nodeData)->hub;\n                     webSocketData->fragmentBuffer.append(\"....\");\n                     data = hub->inflate((char *) webSocketData->fragmentBuffer.data(), length);\n+                    if (!data) {\n+                        forceClose(user);\n+                        return true;\n+                    }\n                 } else {\n                     data = (char *) webSocketData->fragmentBuffer.data();\n                 }\n","owner":"uWebSockets","repo":"uWebSockets","source":"cve"},{"CVE_ID":"CVE-2011-2213","CWE_ID":"20","category":"security","commit_id":"eeb1497277d6b1a0a34ed36b97e18f2bd7d6de0d","commit_message":"From eeb1497277d6b1a0a34ed36b97e18f2bd7d6de0d Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <eric.dumazet@gmail.com>\nDate: Fri, 17 Jun 2011 16:25:39 -0400\nSubject: inet_diag: fix inet_diag_bc_audit()\n\nA malicious user or buggy application can inject code and trigger an\ninfinite loop in inet_diag_bc_audit()\n\nAlso make sure each instruction is aligned on 4 bytes boundary, to avoid\nunaligned accesses.\n\nReported-by: Dan Rosenberg <drosenberg@vsecurity.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/inet_diag.c | 14 ++++++--------\n 1 file changed, 6 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/inet_diag.c b\/net\/ipv4\/inet_diag.c\nindex 6ffe94ca5bc9..3267d3898437 100644\n--- a\/net\/ipv4\/inet_diag.c\n+++ b\/net\/ipv4\/inet_diag.c\n@@ -437,7 +437,7 @@ static int valid_cc(const void *bc, int len, int cc)\n \t\t\treturn 0;\n \t\tif (cc == len)\n \t\t\treturn 1;\n-\t\tif (op->yes < 4)\n+\t\tif (op->yes < 4 || op->yes & 3)\n \t\t\treturn 0;\n \t\tlen -= op->yes;\n \t\tbc  += op->yes;\n@@ -447,11 +447,11 @@ static int valid_cc(const void *bc, int len, int cc)\n \n static int inet_diag_bc_audit(const void *bytecode, int bytecode_len)\n {\n-\tconst unsigned char *bc = bytecode;\n+\tconst void *bc = bytecode;\n \tint  len = bytecode_len;\n \n \twhile (len > 0) {\n-\t\tstruct inet_diag_bc_op *op = (struct inet_diag_bc_op *)bc;\n+\t\tconst struct inet_diag_bc_op *op = bc;\n \n \/\/printk(\"BC: %d %d %d {%d} \/ %d\\n\", op->code, op->yes, op->no, op[1].no, len);\n \t\tswitch (op->code) {\n@@ -462,22 +462,20 @@ static int inet_diag_bc_audit(const void *bytecode, int bytecode_len)\n \t\tcase INET_DIAG_BC_S_LE:\n \t\tcase INET_DIAG_BC_D_GE:\n \t\tcase INET_DIAG_BC_D_LE:\n-\t\t\tif (op->yes < 4 || op->yes > len + 4)\n-\t\t\t\treturn -EINVAL;\n \t\tcase INET_DIAG_BC_JMP:\n-\t\t\tif (op->no < 4 || op->no > len + 4)\n+\t\t\tif (op->no < 4 || op->no > len + 4 || op->no & 3)\n \t\t\t\treturn -EINVAL;\n \t\t\tif (op->no < len &&\n \t\t\t    !valid_cc(bytecode, bytecode_len, len - op->no))\n \t\t\t\treturn -EINVAL;\n \t\t\tbreak;\n \t\tcase INET_DIAG_BC_NOP:\n-\t\t\tif (op->yes < 4 || op->yes > len + 4)\n-\t\t\t\treturn -EINVAL;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\treturn -EINVAL;\n \t\t}\n+\t\tif (op->yes < 4 || op->yes > len + 4 || op->yes & 3)\n+\t\t\treturn -EINVAL;\n \t\tbc  += op->yes;\n \t\tlen -= op->yes;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-7189","CWE_ID":"20","category":"security","commit_id":"bab0b99f376dac9170ac81382a5ed526938d595a","commit_message":"From bab0b99f376dac9170ac81382a5ed526938d595a Mon Sep 17 00:00:00 2001\nFrom: Sara Golemon <pollita@php.net>\nDate: Tue, 7 Mar 2017 11:27:46 -0800\nSubject: [PATCH] Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp:\/\/127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error.\n---\n ext\/standard\/tests\/streams\/parseip-001.phpt | 37 +++++++++++++++++++++\n main\/streams\/xp_socket.c                    | 29 ++++++++++------\n 2 files changed, 55 insertions(+), 11 deletions(-)\n create mode 100644 ext\/standard\/tests\/streams\/parseip-001.phpt\n\n","diff_code":"diff --git a\/ext\/standard\/tests\/streams\/parseip-001.phpt b\/ext\/standard\/tests\/streams\/parseip-001.phpt\nnew file mode 100644\nindex 000000000000..594756db6b7c\n--- \/dev\/null\n+++ b\/ext\/standard\/tests\/streams\/parseip-001.phpt\n@@ -0,0 +1,37 @@\n+--TEST--\n+Use of double-port in fsockopen()\n+--FILE--\n+<?php\n+\n+$try = [\n+  '127.0.0.1:80',\n+  'tcp:\/\/127.0.0.1:80',\n+  '[::1]:80',\n+  'tcp:\/\/[::1]:80',\n+  'localhost:80',\n+  'tcp:\/\/localhost:80',\n+];\n+\n+foreach ($try as $addr) {\n+  echo \"== $addr ==\\n\";\n+  var_dump(@fsockopen($addr, 81, $errno, $errstr), $errstr);\n+}\n+--EXPECTF--\n+== 127.0.0.1:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"127.0.0.1:80:81\"\"\n+== tcp:\/\/127.0.0.1:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"127.0.0.1:80:81\"\"\n+== [::1]:80 ==\n+bool(false)\n+string(37) \"Failed to parse address \"[::1]:80:81\"\"\n+== tcp:\/\/[::1]:80 ==\n+bool(false)\n+string(37) \"Failed to parse address \"[::1]:80:81\"\"\n+== localhost:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"localhost:80:81\"\"\n+== tcp:\/\/localhost:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"localhost:80:81\"\"\n\\ No newline at end of file\ndiff --git a\/main\/streams\/xp_socket.c b\/main\/streams\/xp_socket.c\nindex 701a993ccc1d..3ff64787aa14 100644\n--- a\/main\/streams\/xp_socket.c\n+++ b\/main\/streams\/xp_socket.c\n@@ -571,37 +571,44 @@ static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *po\n \tchar *host = NULL;\n \n #ifdef HAVE_IPV6\n-\tchar *p;\n-\n \tif (*(str) == '[' && str_len > 1) {\n \t\t\/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) *\/\n-\t\tp = memchr(str + 1, ']', str_len - 2);\n+\t\tchar *p = memchr(str + 1, ']', str_len - 2), *e = NULL;\n \t\tif (!p || *(p + 1) != ':') {\n \t\t\tif (get_err) {\n \t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n \t\t\t}\n \t\t\treturn NULL;\n \t\t}\n-\t\t*portno = atoi(p + 2);\n+\t\t*portno = strtol(p + 2, &e, 10);\n+\t\tif (e && *e) {\n+\t\t\tif (get_err) {\n+\t\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n+\t\t\t}\n+\t\t\treturn NULL;\n+\t\t}\n \t\treturn estrndup(str + 1, p - str - 1);\n \t}\n #endif\n+\n \tif (str_len) {\n \t\tcolon = memchr(str, ':', str_len - 1);\n \t} else {\n \t\tcolon = NULL;\n \t}\n+\n \tif (colon) {\n-\t\t*portno = atoi(colon + 1);\n-\t\thost = estrndup(str, colon - str);\n-\t} else {\n-\t\tif (get_err) {\n-\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n+\t\tchar *e = NULL;\n+\t\t*portno = strtol(colon + 1, &e, 10);\n+\t\tif (!e || !*e) {\n+\t\t\treturn estrndup(str, colon - str);\n \t\t}\n-\t\treturn NULL;\n \t}\n \n-\treturn host;\n+\tif (get_err) {\n+\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n+\t}\n+\treturn NULL;\n }\n \n static inline char *parse_ip_address(php_stream_xport_param *xparam, int *portno)\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2012-6647","CWE_ID":"20","category":"security","commit_id":"6f7b0a2a5c0fb03be7c25bd1745baa50582348ef","commit_message":"From 6f7b0a2a5c0fb03be7c25bd1745baa50582348ef Mon Sep 17 00:00:00 2001\nFrom: Darren Hart <dvhart@linux.intel.com>\nDate: Fri, 20 Jul 2012 11:53:31 -0700\nSubject: [PATCH] futex: Forbid uaddr == uaddr2 in futex_wait_requeue_pi()\n\nIf uaddr == uaddr2, then we have broken the rule of only requeueing\nfrom a non-pi futex to a pi futex with this call. If we attempt this,\nas the trinity test suite manages to do, we miss early wakeups as\nq.key is equal to key2 (because they are the same uaddr). We will then\nattempt to dereference the pi_mutex (which would exist had the futex_q\nbeen properly requeued to a pi futex) and trigger a NULL pointer\ndereference.\n\nSigned-off-by: Darren Hart <dvhart@linux.intel.com>\nCc: Dave Jones <davej@redhat.com>\nCc: stable@vger.kernel.org\nLink: http:\/\/lkml.kernel.org\/r\/ad82bfe7f7d130247fbe2b5b4275654807774227.1342809673.git.dvhart@linux.intel.com\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\n---\n kernel\/futex.c | 13 ++++++++-----\n 1 file changed, 8 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/futex.c b\/kernel\/futex.c\nindex 5551adaf7cdfd..3717e7b306e08 100644\n--- a\/kernel\/futex.c\n+++ b\/kernel\/futex.c\n@@ -2231,11 +2231,11 @@ int handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,\n  * @uaddr2:\tthe pi futex we will take prior to returning to user-space\n  *\n  * The caller will wait on uaddr and will be requeued by futex_requeue() to\n- * uaddr2 which must be PI aware.  Normal wakeup will wake on uaddr2 and\n- * complete the acquisition of the rt_mutex prior to returning to userspace.\n- * This ensures the rt_mutex maintains an owner when it has waiters; without\n- * one, the pi logic wouldn't know which task to boost\/deboost, if there was a\n- * need to.\n+ * uaddr2 which must be PI aware and unique from uaddr.  Normal wakeup will wake\n+ * on uaddr2 and complete the acquisition of the rt_mutex prior to returning to\n+ * userspace.  This ensures the rt_mutex maintains an owner when it has waiters;\n+ * without one, the pi logic would not know which task to boost\/deboost, if\n+ * there was a need to.\n  *\n  * We call schedule in futex_wait_queue_me() when we enqueue and return there\n  * via the following:\n@@ -2272,6 +2272,9 @@ static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n \tstruct futex_q q = futex_q_init;\n \tint res, ret;\n \n+\tif (uaddr == uaddr2)\n+\t\treturn -EINVAL;\n+\n \tif (!bitset)\n \t\treturn -EINVAL;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-11449","CWE_ID":"20","category":"security","commit_id":"b007dd3a048097d8f58949297f5b434612e1e1a3","commit_message":"From b007dd3a048097d8f58949297f5b434612e1e1a3 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 6 Jul 2017 06:41:49 -0400\nSubject: [PATCH] ...\n\n---\n coders\/mpc.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/coders\/mpc.c b\/coders\/mpc.c\nindex fc489552a1..092367a78f 100644\n--- a\/coders\/mpc.c\n+++ b\/coders\/mpc.c\n@@ -1008,6 +1008,7 @@ ModuleExport size_t RegisterMPCImage(void)\n   entry=SetMagickInfo(\"CACHE\");\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n+  entry->seekable_stream=MagickTrue;\n   entry->stealth=MagickTrue;\n   (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"MPC\");\n@@ -1015,6 +1016,7 @@ ModuleExport size_t RegisterMPCImage(void)\n   entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n   entry->magick=(IsImageFormatHandler *) IsMPC;\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n+  entry->seekable_stream=MagickTrue;\n   entry->module=ConstantString(\"MPC\");\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-9436","CWE_ID":"20","category":"security","commit_id":"33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd","commit_message":"From 33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd Mon Sep 17 00:00:00 2001\nFrom: Tatsuya Kinoshita <tats@debian.org>\nDate: Sat, 20 Aug 2016 07:12:41 +0900\nSubject: [PATCH] Fix uninitialised values for <i> and <dd>\n\nBug-Debian: https:\/\/github.com\/tats\/w3m\/issues\/16\n---\n file.c      | 6 ++++++\n parsetagx.c | 1 +\n 2 files changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/file.c b\/file.c\nindex de916bc..b66f8c8 100644\n--- a\/file.c\n+++ b\/file.c\n@@ -4686,6 +4686,12 @@ HTMLtagproc1(struct parsed_tag *tag, struct html_feed_environ *h_env)\n     case HTML_DD:\n \tCLOSE_A;\n \tCLOSE_DT;\n+\tif (h_env->envc == 0 ||\n+\t    (h_env->envc_real < h_env->nenv &&\n+\t     envs[h_env->envc].env != HTML_DL &&\n+\t     envs[h_env->envc].env != HTML_DL_COMPACT)) {\n+\t    PUSH_ENV(HTML_DL);\n+\t}\n \tif (envs[h_env->envc].env == HTML_DL_COMPACT) {\n \t    if (obuf->pos > envs[h_env->envc].indent)\n \t\tflushline(h_env, obuf, envs[h_env->envc].indent, 0,\ndiff --git a\/parsetagx.c b\/parsetagx.c\nindex 3435f9f..1cc7048 100644\n--- a\/parsetagx.c\n+++ b\/parsetagx.c\n@@ -120,6 +120,7 @@ parse_tag(char **s, int internal)\n     int i, attr_id = 0, nattr;\n \n     \/* Parse tag name *\/\n+    tagname[0] = '\\0';\n     q = (*s) + 1;\n     p = tagname;\n     if (*q == '\/') {\n","owner":"tats","repo":"w3m","source":"cve"},{"CVE_ID":"CVE-2013-0867","CWE_ID":"20","category":"security","commit_id":"3ef1538121fa6daeb1767510f1d4ae2c306c9fec","commit_message":"From 3ef1538121fa6daeb1767510f1d4ae2c306c9fec Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 29 Jan 2013 04:17:48 +0100\nSubject: [PATCH] h264: check the pixel format directly and force a reinit on\n mismatches.\n\nThe existing checks are insufficient to detect a pixel format\nchanges in case of some damaged streams.\nFixes inconsistency and later out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 11c99c78bafa77f679a1a3ba06ad00984b9a4cae)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/h264.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/h264.c b\/libavcodec\/h264.c\nindex 7ae778a58c..1152258fc5 100644\n--- a\/libavcodec\/h264.c\n+++ b\/libavcodec\/h264.c\n@@ -2765,7 +2765,8 @@ static int decode_slice_header(H264Context *h, H264Context *h0)\n                      || s->avctx->bits_per_raw_sample != h->sps.bit_depth_luma\n                      || h->cur_chroma_format_idc != h->sps.chroma_format_idc\n                      || av_cmp_q(h->sps.sar, s->avctx->sample_aspect_ratio)));\n-\n+    if (h0->s.avctx->pix_fmt != get_pixel_format(h0))\n+        must_reinit = 1;\n \n     s->mb_width  = h->sps.mb_width;\n     s->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-6825","CWE_ID":"20","category":"security","commit_id":"f1a38264f20382731cf2cc75fdd98f4c9a84a626","commit_message":"From f1a38264f20382731cf2cc75fdd98f4c9a84a626 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Thu, 16 Jul 2015 11:52:33 +0200\nSubject: [PATCH] avcodec\/pthread_frame: clear priv_data, avoid stale pointer\n in error case\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nFixes: b4b47bc2b3fb7ca710bfffe5aa969e37_signal_sigabrt_7ffff70eccc9_744_nc_sample2.avi with memlimit of 4194304\n\nFound-by: Samuel Gro\u00c3\u009f, Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/pthread_frame.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/libavcodec\/pthread_frame.c b\/libavcodec\/pthread_frame.c\nindex df372e0c99..8987c12fe7 100644\n--- a\/libavcodec\/pthread_frame.c\n+++ b\/libavcodec\/pthread_frame.c\n@@ -690,6 +690,7 @@ int ff_frame_thread_init(AVCodecContext *avctx)\n \n         copy->internal = av_malloc(sizeof(AVCodecInternal));\n         if (!copy->internal) {\n+            copy->priv_data = NULL;\n             err = AVERROR(ENOMEM);\n             goto error;\n         }\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-17805","CWE_ID":"20","category":"security","commit_id":"ecaaab5649781c5a0effdaf298a925063020500e","commit_message":"From ecaaab5649781c5a0effdaf298a925063020500e Mon Sep 17 00:00:00 2001\nFrom: Eric Biggers <ebiggers@google.com>\nDate: Tue, 28 Nov 2017 20:56:59 -0800\nSubject: [PATCH] crypto: salsa20 - fix blkcipher_walk API usage\n\nWhen asked to encrypt or decrypt 0 bytes, both the generic and x86\nimplementations of Salsa20 crash in blkcipher_walk_done(), either when\ndoing 'kfree(walk->buffer)' or 'free_page((unsigned long)walk->page)',\nbecause walk->buffer and walk->page have not been initialized.\n\nThe bug is that Salsa20 is calling blkcipher_walk_done() even when\nnothing is in 'walk.nbytes'.  But blkcipher_walk_done() is only meant to\nbe called when a nonzero number of bytes have been provided.\n\nThe broken code is part of an optimization that tries to make only one\ncall to salsa20_encrypt_bytes() to process inputs that are not evenly\ndivisible by 64 bytes.  To fix the bug, just remove this \"optimization\"\nand use the blkcipher_walk API the same way all the other users do.\n\nReproducer:\n\n    #include <linux\/if_alg.h>\n    #include <sys\/socket.h>\n    #include <unistd.h>\n\n    int main()\n    {\n            int algfd, reqfd;\n            struct sockaddr_alg addr = {\n                    .salg_type = \"skcipher\",\n                    .salg_name = \"salsa20\",\n            };\n            char key[16] = { 0 };\n\n            algfd = socket(AF_ALG, SOCK_SEQPACKET, 0);\n            bind(algfd, (void *)&addr, sizeof(addr));\n            reqfd = accept(algfd, 0, 0);\n            setsockopt(algfd, SOL_ALG, ALG_SET_KEY, key, sizeof(key));\n            read(reqfd, key, sizeof(key));\n    }\n\nReported-by: syzbot <syzkaller@googlegroups.com>\nFixes: eb6f13eb9f81 (\"[CRYPTO] salsa20_generic: Fix multi-page processing\")\nCc: <stable@vger.kernel.org> # v2.6.25+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\n---\n arch\/x86\/crypto\/salsa20_glue.c | 7 -------\n crypto\/salsa20_generic.c       | 7 -------\n 2 files changed, 14 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/crypto\/salsa20_glue.c b\/arch\/x86\/crypto\/salsa20_glue.c\nindex 399a29d067d63..cb91a64a99e7c 100644\n--- a\/arch\/x86\/crypto\/salsa20_glue.c\n+++ b\/arch\/x86\/crypto\/salsa20_glue.c\n@@ -59,13 +59,6 @@ static int encrypt(struct blkcipher_desc *desc,\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n-\tif (likely(walk.nbytes == nbytes))\n-\t{\n-\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n-\t\t\t\t      walk.dst.virt.addr, nbytes);\n-\t\treturn blkcipher_walk_done(desc, &walk, 0);\n-\t}\n-\n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n \t\t\t\t      walk.dst.virt.addr,\ndiff --git a\/crypto\/salsa20_generic.c b\/crypto\/salsa20_generic.c\nindex f550b5d946307..d7da0eea5622a 100644\n--- a\/crypto\/salsa20_generic.c\n+++ b\/crypto\/salsa20_generic.c\n@@ -188,13 +188,6 @@ static int encrypt(struct blkcipher_desc *desc,\n \n \tsalsa20_ivsetup(ctx, walk.iv);\n \n-\tif (likely(walk.nbytes == nbytes))\n-\t{\n-\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n-\t\t\t\t      walk.src.virt.addr, nbytes);\n-\t\treturn blkcipher_walk_done(desc, &walk, 0);\n-\t}\n-\n \twhile (walk.nbytes >= 64) {\n \t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n \t\t\t\t      walk.src.virt.addr,\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-17862","CWE_ID":"20","category":"security","commit_id":"c131187db2d3fa2f8bf32fdf4e9a4ef805168467","commit_message":"From c131187db2d3fa2f8bf32fdf4e9a4ef805168467 Mon Sep 17 00:00:00 2001\nFrom: Alexei Starovoitov <ast@fb.com>\nDate: Wed, 22 Nov 2017 16:42:05 -0800\nSubject: [PATCH] bpf: fix branch pruning logic\n\nwhen the verifier detects that register contains a runtime constant\nand it's compared with another constant it will prune exploration\nof the branch that is guaranteed not to be taken at runtime.\nThis is all correct, but malicious program may be constructed\nin such a way that it always has a constant comparison and\nthe other branch is never taken under any conditions.\nIn this case such path through the program will not be explored\nby the verifier. It won't be taken at run-time either, but since\nall instructions are JITed the malicious program may cause JITs\nto complain about using reserved fields, etc.\nTo fix the issue we have to track the instructions explored by\nthe verifier and sanitize instructions that are dead at run time\nwith NOPs. We cannot reject such dead code, since llvm generates\nit for valid C code, since it doesn't do as much data flow\nanalysis as the verifier does.\n\nFixes: 17a5267067f3 (\"bpf: verifier (add verifier core)\")\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\n---\n include\/linux\/bpf_verifier.h |  2 +-\n kernel\/bpf\/verifier.c        | 27 +++++++++++++++++++++++++++\n 2 files changed, 28 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/include\/linux\/bpf_verifier.h b\/include\/linux\/bpf_verifier.h\nindex b61482d354a29..c561b986bab0e 100644\n--- a\/include\/linux\/bpf_verifier.h\n+++ b\/include\/linux\/bpf_verifier.h\n@@ -115,7 +115,7 @@ struct bpf_insn_aux_data {\n \t\tstruct bpf_map *map_ptr;\t\/* pointer for call insn into lookup_elem *\/\n \t};\n \tint ctx_field_size; \/* the ctx field size for load insn, maybe 0 *\/\n-\tint converted_op_size; \/* the valid value width after perceived conversion *\/\n+\tbool seen; \/* this insn was processed by the verifier *\/\n };\n \n #define MAX_USED_MAPS 64 \/* max number of maps accessed by one eBPF program *\/\ndiff --git a\/kernel\/bpf\/verifier.c b\/kernel\/bpf\/verifier.c\nindex 308b0638ec5d5..d4593571c4049 100644\n--- a\/kernel\/bpf\/verifier.c\n+++ b\/kernel\/bpf\/verifier.c\n@@ -3827,6 +3827,7 @@ static int do_check(struct bpf_verifier_env *env)\n \t\t\treturn err;\n \n \t\tregs = cur_regs(env);\n+\t\tenv->insn_aux_data[insn_idx].seen = true;\n \t\tif (class == BPF_ALU || class == BPF_ALU64) {\n \t\t\terr = check_alu_op(env, insn);\n \t\t\tif (err)\n@@ -4022,6 +4023,7 @@ static int do_check(struct bpf_verifier_env *env)\n \t\t\t\t\treturn err;\n \n \t\t\t\tinsn_idx++;\n+\t\t\t\tenv->insn_aux_data[insn_idx].seen = true;\n \t\t\t} else {\n \t\t\t\tverbose(env, \"invalid BPF_LD mode\\n\");\n \t\t\t\treturn -EINVAL;\n@@ -4204,6 +4206,7 @@ static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n \t\t\t\tu32 off, u32 cnt)\n {\n \tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n+\tint i;\n \n \tif (cnt == 1)\n \t\treturn 0;\n@@ -4213,6 +4216,8 @@ static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n \tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n \tmemcpy(new_data + off + cnt - 1, old_data + off,\n \t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n+\tfor (i = off; i < off + cnt - 1; i++)\n+\t\tnew_data[i].seen = true;\n \tenv->insn_aux_data = new_data;\n \tvfree(old_data);\n \treturn 0;\n@@ -4231,6 +4236,25 @@ static struct bpf_prog *bpf_patch_insn_data(struct bpf_verifier_env *env, u32 of\n \treturn new_prog;\n }\n \n+\/* The verifier does more data flow analysis than llvm and will not explore\n+ * branches that are dead at run time. Malicious programs can have dead code\n+ * too. Therefore replace all dead at-run-time code with nops.\n+ *\/\n+static void sanitize_dead_code(struct bpf_verifier_env *env)\n+{\n+\tstruct bpf_insn_aux_data *aux_data = env->insn_aux_data;\n+\tstruct bpf_insn nop = BPF_MOV64_REG(BPF_REG_0, BPF_REG_0);\n+\tstruct bpf_insn *insn = env->prog->insnsi;\n+\tconst int insn_cnt = env->prog->len;\n+\tint i;\n+\n+\tfor (i = 0; i < insn_cnt; i++) {\n+\t\tif (aux_data[i].seen)\n+\t\t\tcontinue;\n+\t\tmemcpy(insn + i, &nop, sizeof(nop));\n+\t}\n+}\n+\n \/* convert load instructions that access fields of 'struct __sk_buff'\n  * into sequence of instructions that access fields of 'struct sk_buff'\n  *\/\n@@ -4557,6 +4581,9 @@ int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)\n \twhile (!pop_stack(env, NULL, NULL));\n \tfree_states(env);\n \n+\tif (ret == 0)\n+\t\tsanitize_dead_code(env);\n+\n \tif (ret == 0)\n \t\t\/* program is valid, convert *(u32*)(ctx + off) accesses *\/\n \t\tret = convert_ctx_accesses(env);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-18021","CWE_ID":"20","category":"security","commit_id":"d26c25a9d19b5976b319af528886f89cf455692d","commit_message":"From d26c25a9d19b5976b319af528886f89cf455692d Mon Sep 17 00:00:00 2001\nFrom: Dave Martin <Dave.Martin@arm.com>\nDate: Thu, 27 Sep 2018 16:53:21 +0100\nSubject: arm64: KVM: Tighten guest core register access from userspace\n\nWe currently allow userspace to access the core register file\nin about any possible way, including straddling multiple\nregisters and doing unaligned accesses.\n\nThis is not the expected use of the ABI, and nobody is actually\nusing it that way. Let's tighten it by explicitly checking\nthe size and alignment for each field of the register file.\n\nCc: <stable@vger.kernel.org>\nFixes: 2f4a07c5f9fe (\"arm64: KVM: guest one-reg interface\")\nReviewed-by: Christoffer Dall <christoffer.dall@arm.com>\nReviewed-by: Mark Rutland <mark.rutland@arm.com>\nSigned-off-by: Dave Martin <Dave.Martin@arm.com>\n[maz: rewrote Dave's initial patch to be more easily backported]\nSigned-off-by: Marc Zyngier <marc.zyngier@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>\n---\n arch\/arm64\/kvm\/guest.c | 45 +++++++++++++++++++++++++++++++++++++++++++++\n 1 file changed, 45 insertions(+)\n\n","diff_code":"diff --git a\/arch\/arm64\/kvm\/guest.c b\/arch\/arm64\/kvm\/guest.c\nindex 07256b08226c..3088463bafc1 100644\n--- a\/arch\/arm64\/kvm\/guest.c\n+++ b\/arch\/arm64\/kvm\/guest.c\n@@ -57,6 +57,45 @@ static u64 core_reg_offset_from_id(u64 id)\n \treturn id & ~(KVM_REG_ARCH_MASK | KVM_REG_SIZE_MASK | KVM_REG_ARM_CORE);\n }\n \n+static int validate_core_offset(const struct kvm_one_reg *reg)\n+{\n+\tu64 off = core_reg_offset_from_id(reg->id);\n+\tint size;\n+\n+\tswitch (off) {\n+\tcase KVM_REG_ARM_CORE_REG(regs.regs[0]) ...\n+\t     KVM_REG_ARM_CORE_REG(regs.regs[30]):\n+\tcase KVM_REG_ARM_CORE_REG(regs.sp):\n+\tcase KVM_REG_ARM_CORE_REG(regs.pc):\n+\tcase KVM_REG_ARM_CORE_REG(regs.pstate):\n+\tcase KVM_REG_ARM_CORE_REG(sp_el1):\n+\tcase KVM_REG_ARM_CORE_REG(elr_el1):\n+\tcase KVM_REG_ARM_CORE_REG(spsr[0]) ...\n+\t     KVM_REG_ARM_CORE_REG(spsr[KVM_NR_SPSR - 1]):\n+\t\tsize = sizeof(__u64);\n+\t\tbreak;\n+\n+\tcase KVM_REG_ARM_CORE_REG(fp_regs.vregs[0]) ...\n+\t     KVM_REG_ARM_CORE_REG(fp_regs.vregs[31]):\n+\t\tsize = sizeof(__uint128_t);\n+\t\tbreak;\n+\n+\tcase KVM_REG_ARM_CORE_REG(fp_regs.fpsr):\n+\tcase KVM_REG_ARM_CORE_REG(fp_regs.fpcr):\n+\t\tsize = sizeof(__u32);\n+\t\tbreak;\n+\n+\tdefault:\n+\t\treturn -EINVAL;\n+\t}\n+\n+\tif (KVM_REG_SIZE(reg->id) == size &&\n+\t    IS_ALIGNED(off, size \/ sizeof(__u32)))\n+\t\treturn 0;\n+\n+\treturn -EINVAL;\n+}\n+\n static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n {\n \t\/*\n@@ -76,6 +115,9 @@ static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n \t    (off + (KVM_REG_SIZE(reg->id) \/ sizeof(__u32))) >= nr_regs)\n \t\treturn -ENOENT;\n \n+\tif (validate_core_offset(reg))\n+\t\treturn -EINVAL;\n+\n \tif (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))\n \t\treturn -EFAULT;\n \n@@ -98,6 +140,9 @@ static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n \t    (off + (KVM_REG_SIZE(reg->id) \/ sizeof(__u32))) >= nr_regs)\n \t\treturn -ENOENT;\n \n+\tif (validate_core_offset(reg))\n+\t\treturn -EINVAL;\n+\n \tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n \t\treturn -EINVAL;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-2724","CWE_ID":"20","category":"security","commit_id":"1e7a32924b22d1f786b6f490ce8590656f578f91","commit_message":"From 1e7a32924b22d1f786b6f490ce8590656f578f91 Mon Sep 17 00:00:00 2001\nFrom: Jeff Layton <jlayton@samba.org>\nDate: Fri, 29 Jul 2011 07:12:48 -0400\nSubject: [PATCH] mount.cifs: check_newline returns EX_USAGE on error, not -1\n\nReported-by: Jan Lieskovsky <jlieskov@redhat.com>\nSigned-off-by: Jeff Layton <jlayton@samba.org>\n---\n mount.cifs.c | 3 +--\n 1 file changed, 1 insertion(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/mount.cifs.c b\/mount.cifs.c\nindex 107a5a5..aa4581f 100644\n--- a\/mount.cifs.c\n+++ b\/mount.cifs.c\n@@ -1419,8 +1419,7 @@ static int check_newline(const char *progname, const char *name)\n static int check_mtab(const char *progname, const char *devname,\n \t\t      const char *dir)\n {\n-\tif (check_newline(progname, devname) == -1 ||\n-\t    check_newline(progname, dir) == -1)\n+\tif (check_newline(progname, devname) || check_newline(progname, dir))\n \t\treturn EX_USAGE;\n \treturn 0;\n }\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-1586","CWE_ID":"20","category":"security","commit_id":"29014da83e5fc358d6bff0f574e9ed45e61a35ac","commit_message":"From 29014da83e5fc358d6bff0f574e9ed45e61a35ac Mon Sep 17 00:00:00 2001\nFrom: Chris Coulson <chris.coulson@canonical.com>\nDate: Fri, 23 Sep 2016 21:15:25 +0100\nSubject: Refactor ownership of BrowserContext (LP: #1503639, LP: #1626099)\n\nPreviously, BrowserContext was reference counted inside Oxide. However, it's not reference counted in Chromium which meant we needed an additional mechanism (BrowserContextDestroyer) to ensure that it outlives any RenderProcessHosts using it. As this required a custom trait for deletion, it lead to the weird scenario where BrowserContext (a non-threadsafe class inherited from base::NonThreadSafe) had to have a thread-safe reference count.\n\nNow, the main BrowserContext is exclusively owned by the application, and is scheduled for deletion via BrowserContextDestroyer as soon as the application releases it. OTR BrowserContexts are owned by the BrowserContext that creates them, and WebContentsUnloader schedules the OTR BrowserContext for deletion as soon as the last WebContents using it is scheduled for unload.\n\n","diff_code":"diff --git a\/qt\/core\/browser\/oxide_qt_web_context.cc b\/qt\/core\/browser\/oxide_qt_web_context.cc\nindex 3dc3c13..617fbea 100644\n--- a\/qt\/core\/browser\/oxide_qt_web_context.cc\n+++ b\/qt\/core\/browser\/oxide_qt_web_context.cc\n@@ -53,7 +53,6 @@\n #include \"qt\/core\/browser\/oxide_qt_user_script.h\"\n #include \"qt\/core\/glue\/oxide_qt_web_context_proxy_client.h\"\n #include \"shared\/browser\/media\/oxide_media_capture_devices_context.h\"\n-#include \"shared\/browser\/oxide_browser_context.h\"\n #include \"shared\/browser\/oxide_browser_context_delegate.h\"\n #include \"shared\/browser\/oxide_browser_process_main.h\"\n #include \"shared\/browser\/oxide_devtools_manager.h\"\n@@ -66,6 +65,7 @@\n namespace oxide {\n namespace qt {\n \n+using oxide::BrowserContext;\n using oxide::DevToolsManager;\n using oxide::MediaCaptureDevicesContext;\n using oxide::UserAgentSettings;\n@@ -456,7 +456,7 @@ WebContext::~WebContext() {\n }\n \n \/\/ static\n-WebContext* WebContext::FromBrowserContext(oxide::BrowserContext* context) {\n+WebContext* WebContext::FromBrowserContext(BrowserContext* context) {\n   BrowserContextDelegate* delegate =\n       static_cast<BrowserContextDelegate*>(context->GetDelegate());\n   if (!delegate) {\n@@ -466,21 +466,21 @@ WebContext* WebContext::FromBrowserContext(oxide::BrowserContext* context) {\n   return delegate->context();\n }\n \n-oxide::BrowserContext* WebContext::GetContext() {\n+BrowserContext* WebContext::GetContext() {\n   if (context_.get()) {\n     return context_.get();\n   }\n \n   DCHECK(construct_props_);\n \n-  oxide::BrowserContext::Params params(\n+  BrowserContext::Params params(\n       construct_props_->data_path,\n       construct_props_->cache_path,\n       construct_props_->max_cache_size_hint,\n       construct_props_->session_cookie_mode);\n   params.host_mapping_rules = construct_props_->host_mapping_rules;\n \n-  context_ = oxide::BrowserContext::Create(params);\n+  context_ = BrowserContext::Create(params);\n \n   UserAgentSettings* ua_settings = UserAgentSettings::Get(context_.get());\n \ndiff --git a\/qt\/core\/browser\/oxide_qt_web_context.h b\/qt\/core\/browser\/oxide_qt_web_context.h\nindex db2f68f..1425b38 100644\n--- a\/qt\/core\/browser\/oxide_qt_web_context.h\n+++ b\/qt\/core\/browser\/oxide_qt_web_context.h\n@@ -33,6 +33,7 @@\n \n #include \"qt\/core\/glue\/oxide_qt_web_context_proxy.h\"\n #include \"shared\/browser\/media\/oxide_media_capture_devices_context_client.h\"\n+#include \"shared\/browser\/oxide_browser_context.h\"\n \n QT_BEGIN_NAMESPACE\n class QNetworkAccessManager;\n@@ -43,9 +44,6 @@ class CookieStore;\n }\n \n namespace oxide {\n-\n-class BrowserContext;\n-\n namespace qt {\n \n class SetCookiesContext;\n@@ -152,7 +150,7 @@ class WebContext : public WebContextProxy,\n \n   WebContextProxyClient* client_;\n \n-  scoped_refptr<BrowserContext> context_;\n+  BrowserContext::UniquePtr context_;\n \n   struct ConstructProperties;\n   std::unique_ptr<ConstructProperties> construct_props_;\ndiff --git a\/qt\/quick\/api\/oxideqquickwebview.cc b\/qt\/quick\/api\/oxideqquickwebview.cc\nindex 06fe5ba..d0076ae 100644\n--- a\/qt\/quick\/api\/oxideqquickwebview.cc\n+++ b\/qt\/quick\/api\/oxideqquickwebview.cc\n@@ -2042,8 +2042,8 @@ If the application doesn't set this, then WebView will use the application\n default WebContext (Oxide::defaultWebContext).\n \n The application should ensure that the provided WebContext outlives this\n-WebView. Although WebView will continue to function normally if its provided\n-WebContext is deleted, it will mean that this property is null.\n+WebView. Deleting the WebContext whilst the WebView is still alive may cause\n+some features to stop working.\n \n If this WebView is created as a request to open a new window (via\n newViewRequested), then the WebContext will be inherited from the opening\ndiff --git a\/qt\/tests\/qmltests\/core\/single-process.exclude b\/qt\/tests\/qmltests\/core\/single-process.exclude\nindex 8a6a683..937b64d 100644\n--- a\/qt\/tests\/qmltests\/core\/single-process.exclude\n+++ b\/qt\/tests\/qmltests\/core\/single-process.exclude\n@@ -1,2 +1,3 @@\n+tst_bug1626099.qml\n tst_Incognito_cleanup.qml\n tst_Incognito_cookies.qml\ndiff --git a\/qt\/tests\/qmltests\/core\/tst_bug1626099.html b\/qt\/tests\/qmltests\/core\/tst_bug1626099.html\nnew file mode 100644\nindex 0000000..3ac94c5\n--- \/dev\/null\n+++ b\/qt\/tests\/qmltests\/core\/tst_bug1626099.html\n@@ -0,0 +1,15 @@\n+<html>\n+<head>\n+<script>\n+\n+window.addEventListener(\"unload\", function(e) {\n+  while (true) {\n+    console.log(\"Spinning unload handler\");\n+  }\n+});\n+\n+<\/script>\n+<\/head>\n+<body>\n+<\/body>\n+<\/html>\ndiff --git a\/qt\/tests\/qmltests\/core\/tst_bug1626099.qml b\/qt\/tests\/qmltests\/core\/tst_bug1626099.qml\nnew file mode 100644\nindex 0000000..d11d76d\n--- \/dev\/null\n+++ b\/qt\/tests\/qmltests\/core\/tst_bug1626099.qml\n@@ -0,0 +1,44 @@\n+import QtQuick 2.0\n+import QtTest 1.0\n+import Oxide.testsupport 1.0\n+\n+Item {\n+  id: top\n+\n+  Component {\n+    id: webViewFactory\n+    TestWebView {\n+      incognito: true\n+    }\n+  }\n+\n+  TestCase {\n+    id: test\n+    name: \"Incognito_cleanup\"\n+    when: windowShown\n+\n+    \/\/ Verify that the OTR browsing context is destroyed as soon as the\n+    \/\/ last incognito webview using it is destroyed. This is like\n+    \/\/ tst_Incognito_cleanup.qml with the exception that it runs the test\n+    \/\/ with a page that spins its unload handler, in order to delay\n+    \/\/ teardown of the incognito BrowserContext\n+    function test_bug1626099() {\n+      var webView = webViewFactory.createObject(top, {});\n+      webView.url = \"http:\/\/testsuite\/tst_bug1626099.html\";\n+      verify(webView.waitForLoadSucceeded());\n+\n+      webView.getTestApi().evaluateCode(\"document.cookie = \\\"foo=bar\\\"\", false);\n+      compare(webView.getTestApi().evaluateCode(\"document.cookie\", false), \"foo=bar\");\n+\n+      var webViewHelper = TestSupport.createQObjectTestHelper(webView);\n+      webView.destroy();\n+      TestUtils.waitFor(function() { return webViewHelper.destroyed; });\n+\n+      webView = webViewFactory.createObject(top, {});\n+      webView.url = \"http:\/\/testsuite\/tst_bug1626099.html\";\n+      verify(webView.waitForLoadSucceeded());\n+\n+      compare(webView.getTestApi().evaluateCode(\"document.cookie\", false), \"\");\n+    }\n+  }\n+}\ndiff --git a\/shared\/BUILD.gn b\/shared\/BUILD.gn\nindex 43cafb2..c9e7e91 100644\n--- a\/shared\/BUILD.gn\n+++ b\/shared\/BUILD.gn\n@@ -284,6 +284,8 @@ component(\"shared\") {\n     \"browser\/input\/oxide_input_method_context.h\",\n     \"browser\/input\/oxide_input_method_context_observer.cc\",\n     \"browser\/input\/oxide_input_method_context_observer.h\",\n+    \"browser\/in_process_renderer_observer.cc\",\n+    \"browser\/in_process_renderer_observer.h\",\n     \"browser\/media\/oxide_media_capture_devices_context.cc\",\n     \"browser\/media\/oxide_media_capture_devices_context.h\",\n     \"browser\/media\/oxide_media_capture_devices_context_client.h\",\ndiff --git a\/shared\/browser\/in_process_renderer_observer.cc b\/shared\/browser\/in_process_renderer_observer.cc\nnew file mode 100644\nindex 0000000..d69034e\n--- \/dev\/null\n+++ b\/shared\/browser\/in_process_renderer_observer.cc\n@@ -0,0 +1,37 @@\n+\/\/ vim:expandtab:shiftwidth=2:tabstop=2:\n+\/\/ Copyright (C) 2016 Canonical Ltd.\n+\n+\/\/ This library is free software; you can redistribute it and\/or\n+\/\/ modify it under the terms of the GNU Lesser General Public\n+\/\/ License as published by the Free Software Foundation; either\n+\/\/ version 2.1 of the License, or (at your option) any later version.\n+\n+\/\/ This library is distributed in the hope that it will be useful,\n+\/\/ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+\/\/ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+\/\/ Lesser General Public License for more details.\n+\n+\/\/ You should have received a copy of the GNU Lesser General Public\n+\/\/ License along with this library; if not, write to the Free Software\n+\/\/ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+\n+#include \"in_process_renderer_observer.h\"\n+\n+#include \"content\/public\/browser\/render_process_host.h\"\n+\n+#include \"oxide_web_contents_unloader.h\"\n+\n+namespace oxide {\n+\n+void InProcessRendererObserver::RenderProcessHostDestroyed(\n+    content::RenderProcessHost* host) {\n+  WebContentsUnloader::GetInstance()->Shutdown();\n+}\n+\n+InProcessRendererObserver::InProcessRendererObserver() {\n+  DCHECK(content::RenderProcessHost::run_renderer_in_process());\n+}\n+\n+InProcessRendererObserver::~InProcessRendererObserver() = default;\n+\n+} \/\/ namespace oxide\ndiff --git a\/shared\/browser\/in_process_renderer_observer.h b\/shared\/browser\/in_process_renderer_observer.h\nnew file mode 100644\nindex 0000000..03d0d2f\n--- \/dev\/null\n+++ b\/shared\/browser\/in_process_renderer_observer.h\n@@ -0,0 +1,40 @@\n+\/\/ vim:expandtab:shiftwidth=2:tabstop=2:\n+\/\/ Copyright (C) 2016 Canonical Ltd.\n+\n+\/\/ This library is free software; you can redistribute it and\/or\n+\/\/ modify it under the terms of the GNU Lesser General Public\n+\/\/ License as published by the Free Software Foundation; either\n+\/\/ version 2.1 of the License, or (at your option) any later version.\n+\n+\/\/ This library is distributed in the hope that it will be useful,\n+\/\/ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+\/\/ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+\/\/ Lesser General Public License for more details.\n+\n+\/\/ You should have received a copy of the GNU Lesser General Public\n+\/\/ License along with this library; if not, write to the Free Software\n+\/\/ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+\n+#ifndef _OXIDE_SHARED_BROWSER_IN_PROCESS_RENDERER_OBSERVER_H_\n+#define _OXIDE_SHARED_BROWSER_IN_PROCESS_RENDERER_OBSERVER_H_\n+\n+#include \"base\/macros.h\"\n+#include \"content\/public\/browser\/render_process_host_observer.h\"\n+\n+namespace oxide {\n+\n+class InProcessRendererObserver : public content::RenderProcessHostObserver {\n+ public:\n+  InProcessRendererObserver();\n+  ~InProcessRendererObserver() override;\n+\n+ private:\n+  \/\/ content::RenderProcessHostObserver implementation\n+  void RenderProcessHostDestroyed(content::RenderProcessHost* host) override;\n+\n+  DISALLOW_COPY_AND_ASSIGN(InProcessRendererObserver);\n+};\n+\n+} \/\/ namespace oxide\n+\n+#endif \/\/ _OXIDE_SHARED_BROWSER_IN_PROCESS_RENDERER_OBSERVER_H_\ndiff --git a\/shared\/browser\/oxide_browser_context.cc b\/shared\/browser\/oxide_browser_context.cc\nindex 8d2420b..00ae02b 100644\n--- a\/shared\/browser\/oxide_browser_context.cc\n+++ b\/shared\/browser\/oxide_browser_context.cc\n@@ -558,24 +558,16 @@ class OTRBrowserContextImpl : public BrowserContext {\n  public:\n   OTRBrowserContextImpl(BrowserContextImpl* original,\n                         BrowserContextIODataImpl* original_io_data);\n-\n-  base::WeakPtr<OTRBrowserContextImpl> GetWeakPtr() {\n-    return weak_ptr_factory_.GetWeakPtr();\n-  }\n+  ~OTRBrowserContextImpl() override;\n \n  private:\n-  ~OTRBrowserContextImpl() override;\n+  BrowserContext* GetOffTheRecordContext() override { return this; }\n \n-  scoped_refptr<BrowserContext> GetOffTheRecordContext() override {\n-    return make_scoped_refptr(this);\n-  }\n-  BrowserContext* GetOriginalContext() const override;\n+  BrowserContext* GetOriginalContext() override;\n \n   bool HasOffTheRecordContext() const override { return true; }\n \n-  scoped_refptr<BrowserContextImpl> original_context_;\n-\n-  base::WeakPtrFactory<OTRBrowserContextImpl> weak_ptr_factory_;\n+  BrowserContextImpl* original_context_;\n };\n \n class BrowserContextImpl : public BrowserContext {\n@@ -583,50 +575,49 @@ class BrowserContextImpl : public BrowserContext {\n   BrowserContextImpl(const BrowserContext::Params& params);\n \n  private:\n+  friend class BrowserContext;\n+\n   ~BrowserContextImpl() override;\n \n-  scoped_refptr<BrowserContext> GetOffTheRecordContext() override;\n+  BrowserContext* GetOffTheRecordContext() override;\n \n-  BrowserContext* GetOriginalContext() const override {\n-    return const_cast<BrowserContextImpl*>(this);\n-  }\n+  BrowserContext* GetOriginalContext() override { return this; }\n \n   bool HasOffTheRecordContext() const override {\n     return otr_context_ != nullptr;\n   }\n \n-  base::WeakPtr<OTRBrowserContextImpl> otr_context_;\n+  std::unique_ptr<OTRBrowserContextImpl> otr_context_;\n };\n \n-OTRBrowserContextImpl::~OTRBrowserContextImpl() {}\n-\n-BrowserContext* OTRBrowserContextImpl::GetOriginalContext() const {\n-  return original_context_.get();\n+BrowserContext* OTRBrowserContextImpl::GetOriginalContext() {\n+  return original_context_;\n }\n \n+OTRBrowserContextImpl::~OTRBrowserContextImpl() {}\n+\n OTRBrowserContextImpl::OTRBrowserContextImpl(\n     BrowserContextImpl* original,\n     BrowserContextIODataImpl* original_io_data)\n     : BrowserContext(new OTRBrowserContextIODataImpl(original_io_data)),\n-      original_context_(original),\n-      weak_ptr_factory_(this) {\n+      original_context_(original) {\n   BrowserContextDependencyManager::GetInstance()\n       ->CreateBrowserContextServices(this);\n }\n \n-BrowserContextImpl::~BrowserContextImpl() {\n-  CHECK(!otr_context_);\n-}\n-\n-scoped_refptr<BrowserContext> BrowserContextImpl::GetOffTheRecordContext() {\n+BrowserContext* BrowserContextImpl::GetOffTheRecordContext() {\n   if (!otr_context_) {\n-    OTRBrowserContextImpl* context = new OTRBrowserContextImpl(\n-        this,\n-        static_cast<BrowserContextIODataImpl *>(io_data()));\n-    otr_context_ = context->GetWeakPtr();\n+    otr_context_ =\n+        base::MakeUnique<OTRBrowserContextImpl>(\n+            this,\n+            static_cast<BrowserContextIODataImpl*>(io_data()));\n   }\n \n-  return make_scoped_refptr(otr_context_.get());\n+  return otr_context_.get();\n+}\n+\n+BrowserContextImpl::~BrowserContextImpl() {\n+  CHECK(!otr_context_);\n }\n \n BrowserContextImpl::BrowserContextImpl(const BrowserContext::Params& params)\n@@ -643,8 +634,9 @@ BrowserContextImpl::BrowserContextImpl(const BrowserContext::Params& params)\n       ->CreateBrowserContextServices(this);\n }\n \n-void BrowserContextTraits::Destruct(const BrowserContext* x) {\n-  BrowserContextDestroyer::DestroyContext(const_cast<BrowserContext*>(x));\n+void BrowserContext::Deleter::operator()(BrowserContext* context) {\n+  CHECK(!context->IsOffTheRecord());\n+  BrowserContextDestroyer::DestroyContext(base::WrapUnique(context));\n }\n \n std::unique_ptr<content::ZoomLevelDelegate>\n@@ -744,8 +736,8 @@ void BrowserContext::RemoveObserver(BrowserContextObserver* observer) {\n   observers_.RemoveObserver(observer);\n }\n \n-BrowserContext::BrowserContext(BrowserContextIOData* io_data) :\n-    io_data_(io_data) {\n+BrowserContext::BrowserContext(BrowserContextIOData* io_data)\n+    : io_data_(io_data) {\n   CHECK(BrowserProcessMain::GetInstance()->IsRunning()) <<\n       \"The main browser process components must be started before \" <<\n       \"creating a context\";\n@@ -786,9 +778,8 @@ BrowserContext::~BrowserContext() {\n }\n \n \/\/ static\n-scoped_refptr<BrowserContext> BrowserContext::Create(const Params& params) {\n-  scoped_refptr<BrowserContext> context = new BrowserContextImpl(params);\n-  return context;\n+BrowserContext::UniquePtr BrowserContext::Create(const Params& params) {\n+  return BrowserContext::UniquePtr(new BrowserContextImpl(params));\n }\n \n \/\/ static\n@@ -800,7 +791,10 @@ void BrowserContext::ForEach(const BrowserContextCallback& callback) {\n \n \/\/ static\n void BrowserContext::AssertNoContextsExist() {\n-  CHECK_EQ(g_all_contexts.Get().size(), static_cast<size_t>(0));\n+  CHECK_EQ(g_all_contexts.Get().size(), static_cast<size_t>(0))\n+      << \"BrowserContexts still exist at shutdown! This is normally the result \"\n+      << \"of an application leak, but it's possible that there might be an \"\n+      << \"Oxide bug too\";\n }\n \n BrowserContextID BrowserContext::GetID() const {\n@@ -820,6 +814,14 @@ void BrowserContext::SetDelegate(BrowserContextDelegate* delegate) {\n   data.delegate = delegate;\n }\n \n+\/\/ static\n+void BrowserContext::DestroyOffTheRecordContextForContext(\n+    BrowserContext* context) {\n+  CHECK(!context->IsOffTheRecord() && context->HasOffTheRecordContext());\n+  BrowserContextDestroyer::DestroyContext(\n+      std::move(static_cast<BrowserContextImpl*>(context)->otr_context_));\n+}\n+\n bool BrowserContext::IsOffTheRecord() const {\n   DCHECK(CalledOnValidThread());\n   return io_data()->IsOffTheRecord();\n@@ -829,7 +831,7 @@ bool BrowserContext::IsSameContext(BrowserContext* other) const {\n   DCHECK(CalledOnValidThread());\n   return other->GetOriginalContext() == this ||\n          (other->HasOffTheRecordContext() &&\n-          other->GetOffTheRecordContext().get() == this);\n+          other->GetOffTheRecordContext() == this);\n }\n \n base::FilePath BrowserContext::GetPath() const {\ndiff --git a\/shared\/browser\/oxide_browser_context.h b\/shared\/browser\/oxide_browser_context.h\nindex b6c61e4..3523017 100644\n--- a\/shared\/browser\/oxide_browser_context.h\n+++ b\/shared\/browser\/oxide_browser_context.h\n@@ -146,17 +146,10 @@ class BrowserContextIOData {\n \n class BrowserContext;\n \n-struct OXIDE_SHARED_EXPORT BrowserContextTraits {\n-  static void Destruct(const BrowserContext* x);\n-};\n-\n \/\/ This class holds the context needed for a browsing session. It lives on\n-\/\/ and must only be accessed on the UI thread - note that it uses a thread-safe\n-\/\/ refcount only so that we can override the delete behaviour\n-class OXIDE_SHARED_EXPORT BrowserContext\n-    : public content::BrowserContext,\n-      public base::RefCountedThreadSafe<BrowserContext, BrowserContextTraits>,\n-      public base::NonThreadSafe {\n+\/\/ and must only be accessed on the UI thread\n+class OXIDE_SHARED_EXPORT BrowserContext : public content::BrowserContext,\n+                                           public base::NonThreadSafe {\n  public:\n \n   struct Params {\n@@ -176,12 +169,24 @@ class OXIDE_SHARED_EXPORT BrowserContext\n     std::vector<std::string> host_mapping_rules;\n   };\n \n+  virtual ~BrowserContext();\n+\n   static BrowserContext* FromContent(\n       content::BrowserContext* context) {\n     return static_cast<BrowserContext *>(context);\n   }\n \n-  static scoped_refptr<BrowserContext> Create(const Params& params);\n+  struct Deleter {\n+    void operator()(BrowserContext* context);\n+  };\n+\n+  typedef std::unique_ptr<BrowserContext, Deleter> UniquePtr;\n+\n+  \/\/ Create a new BrowserContext. Callers should be aware that the returned\n+  \/\/ std::unique_ptr is not guaranteed to delete the BrowserContext immediately\n+  \/\/ when released - it schedules the BrowserContext to be deleted when it's no\n+  \/\/ longer in use.\n+  static UniquePtr Create(const Params& params);\n \n   typedef base::Callback<void(BrowserContext*)> BrowserContextCallback;\n   static void ForEach(const BrowserContextCallback& callback);\n@@ -194,10 +199,22 @@ class OXIDE_SHARED_EXPORT BrowserContext\n   BrowserContextDelegate* GetDelegate() const;\n   void SetDelegate(BrowserContextDelegate* delegate);\n \n-  virtual scoped_refptr<BrowserContext> GetOffTheRecordContext() = 0;\n-  virtual BrowserContext* GetOriginalContext() const = 0;\n+  \/\/ Returns an OTR BrowserContext, creating it if it needs to. Callers must\n+  \/\/ never delete the returned BrowserContext directly, but must pass the\n+  \/\/ BrowserContext returned by GetOriginalContext() to\n+  \/\/ DestroyOffTheRecordContextForContext when it's no longer required.\n+  virtual BrowserContext* GetOffTheRecordContext() = 0;\n+\n+  \/\/ Returns the main BrowserContext associated with |this|. Callers must never\n+  \/\/ delete the returned BrowserContext.\n+  \/\/ The returned BrowserContext is only guaranteed to be valid until |this| is\n+  \/\/ released.\n+  virtual BrowserContext* GetOriginalContext() = 0;\n+\n   virtual bool HasOffTheRecordContext() const = 0;\n \n+  static void DestroyOffTheRecordContextForContext(BrowserContext* context);\n+\n   bool IsOffTheRecord() const override; \/\/ from content::BrowserContext\n \n   bool IsSameContext(BrowserContext* other) const;\n@@ -231,10 +248,7 @@ class OXIDE_SHARED_EXPORT BrowserContext\n   BrowserContextIOData* GetIOData() const;\n \n  protected:\n-  friend class BrowserContextDestroyer; \/\/ for destructor\n-\n   BrowserContext(BrowserContextIOData* io_data);\n-  virtual ~BrowserContext();\n \n   BrowserContextIOData* io_data() const { return io_data_; }\n \ndiff --git a\/shared\/browser\/oxide_browser_context_destroyer.cc b\/shared\/browser\/oxide_browser_context_destroyer.cc\nindex 676de2c..e57cd36 100644\n--- a\/shared\/browser\/oxide_browser_context_destroyer.cc\n+++ b\/shared\/browser\/oxide_browser_context_destroyer.cc\n@@ -17,8 +17,11 @@\n \n #include \"oxide_browser_context_destroyer.h\"\n \n+#include <list>\n+\n+#include \"base\/lazy_instance.h\"\n #include \"base\/logging.h\"\n-#include \"base\/message_loop\/message_loop.h\"\n+#include \"base\/threading\/thread_task_runner_handle.h\"\n #include \"content\/public\/browser\/browser_context.h\"\n #include \"content\/public\/browser\/render_process_host.h\"\n \n@@ -26,76 +29,229 @@\n \n namespace oxide {\n \n+namespace {\n+\n+base::LazyInstance<std::list<BrowserContextDestroyer*>>\n+    g_contexts_pending_deletion = LAZY_INSTANCE_INITIALIZER;\n+\n+std::set<content::RenderProcessHost*> \n+GetHostsForContext(BrowserContext* context) {\n+  std::set<content::RenderProcessHost*> hosts;\n+\n+  for (auto it = content::RenderProcessHost::AllHostsIterator();\n+       !it.IsAtEnd(); it.Advance()) {\n+    content::RenderProcessHost* host = it.GetCurrentValue();\n+    if (host->GetBrowserContext() != context) {\n+      continue;\n+    }\n+\n+    hosts.insert(host);\n+  }\n+\n+  return std::move(hosts);\n+}\n+\n+}\n+\n BrowserContextDestroyer::BrowserContextDestroyer(\n-    BrowserContext* context,\n-    const std::set<content::RenderProcessHost*>& hosts)\n-    : context_(context),\n-      pending_hosts_(0) {\n-  for (std::set<content::RenderProcessHost*>::iterator it = hosts.begin();\n-       it != hosts.end(); ++it) {\n-    (*it)->AddObserver(this);\n-    ++pending_hosts_;\n+    std::unique_ptr<BrowserContext> context,\n+    const std::set<content::RenderProcessHost*>& hosts,\n+    uint32_t otr_contexts_pending_deletion)\n+    : context_(std::move(context)),\n+      otr_contexts_pending_deletion_(otr_contexts_pending_deletion),\n+      finish_destroy_scheduled_(false) {\n+  DCHECK(hosts.size() > 0 ||\n+         (!context->IsOffTheRecord() &&\n+          (otr_contexts_pending_deletion > 0 ||\n+               context->HasOffTheRecordContext())));\n+\n+  g_contexts_pending_deletion.Get().push_back(this);\n+\n+  for (auto* host : hosts) {\n+    ObserveHost(host);\n   }\n }\n \n-BrowserContextDestroyer::~BrowserContextDestroyer() {}\n+BrowserContextDestroyer::~BrowserContextDestroyer() = default;\n+\n+void BrowserContextDestroyer::ObserveHost(content::RenderProcessHost* host) {\n+  DCHECK(pending_host_ids_.find(host->GetID()) == pending_host_ids_.end());\n+\n+  host->AddObserver(this);\n+  pending_host_ids_.insert(host->GetID());\n+}\n+\n+void BrowserContextDestroyer::MaybeScheduleFinishDestroyContext(\n+    content::RenderProcessHost* host_being_destroyed) {\n+  DCHECK(!finish_destroy_scheduled_);\n+\n+  if (pending_host_ids_.size() > 0) {\n+    \/\/ We're monitoring RenderProcessHosts that are using this context, so it's\n+    \/\/ not safe to delete yet\n+    return;\n+  }\n+\n+  if (!context_->IsOffTheRecord() &&\n+      (otr_contexts_pending_deletion_ > 0 ||\n+           context_->HasOffTheRecordContext())) {\n+    \/\/ There are still live OTR BrowserContexts that depend on this context, so\n+    \/\/ it can't be deleted yet\n+    return;\n+  }\n+\n+  finish_destroy_scheduled_ = true;\n+\n+  base::ThreadTaskRunnerHandle::Get()->PostTask(\n+      FROM_HERE,\n+      base::Bind(&BrowserContextDestroyer::FinishDestroyContext,\n+                 \/\/ We have exclusive ownership of |this| - nobody else can\n+                 \/\/ reference or delete it\n+                 base::Unretained(this)));\n+}\n \n void BrowserContextDestroyer::FinishDestroyContext() {\n-  DCHECK_EQ(pending_hosts_, 0U);\n+  DCHECK(finish_destroy_scheduled_);\n+  CHECK_EQ(GetHostsForContext(context_.get()).size(), 0U)\n+      << \"One or more RenderProcessHosts exist whilst its BrowserContext is \"\n+      << \"being deleted!\";\n \n-  delete context_;\n-  context_ = nullptr;\n+  g_contexts_pending_deletion.Get().remove(this);\n+\n+  if (context_->IsOffTheRecord()) {\n+    \/\/ If this is an OTR context and its owner BrowserContext has been scheduled\n+    \/\/ for deletion, update the owner's BrowserContextDestroyer\n+    BrowserContextDestroyer* orig_destroyer =\n+        GetForContext(context_->GetOriginalContext());\n+    if (orig_destroyer) {\n+      DCHECK_GT(orig_destroyer->otr_contexts_pending_deletion_, 0U);\n+      DCHECK(!orig_destroyer->finish_destroy_scheduled_);\n+      --orig_destroyer->otr_contexts_pending_deletion_;\n+      orig_destroyer->MaybeScheduleFinishDestroyContext();\n+    }\n+  }\n \n   delete this;\n }\n \n+\/\/ static\n+BrowserContextDestroyer* BrowserContextDestroyer::GetForContext(\n+    content::BrowserContext* context) {\n+  auto it = std::find_if(g_contexts_pending_deletion.Get().begin(),\n+                         g_contexts_pending_deletion.Get().end(),\n+                         [context](const BrowserContextDestroyer* d) {\n+    return d->context_.get() == context;\n+  });\n+\n+  if (it == g_contexts_pending_deletion.Get().end()) {\n+    return nullptr;\n+  }\n+\n+  return *it;\n+}\n+\n void BrowserContextDestroyer::RenderProcessHostDestroyed(\n     content::RenderProcessHost* host) {\n-  DCHECK_GT(pending_hosts_, 0U);\n-  if (--pending_hosts_ != 0) {\n-    return;\n-  }\n+  DCHECK_GT(pending_host_ids_.size(), 0U);\n+\n+  size_t erased = pending_host_ids_.erase(host->GetID());\n+  DCHECK_GT(erased, 0U);\n+\n+  MaybeScheduleFinishDestroyContext(host);\n+}\n+\n+\/\/ static\n+void BrowserContextDestroyer::DestroyContext(\n+    std::unique_ptr<BrowserContext> context) {\n \n-  if (content::RenderProcessHost::run_renderer_in_process()) {\n-    FinishDestroyContext();\n+  bool has_live_otr_context = false;\n+  uint32_t otr_contexts_pending_deletion = 0;\n+\n+  if (!context->IsOffTheRecord()) {\n+    \/\/ If |context| is not an OTR BrowserContext, we need to keep track of how\n+    \/\/ many OTR BrowserContexts that were owned by it are scheduled for deletion\n+    \/\/ but still exist, as |context| must outlive these\n+    for (auto* destroyer : g_contexts_pending_deletion.Get()) {\n+      if (destroyer->context_->IsOffTheRecord() &&\n+          destroyer->context_->GetOriginalContext() == context.get()) {\n+        ++otr_contexts_pending_deletion;\n+      }\n+    }\n+\n+    \/\/ If |context| is not an OTR BrowserContext but currently owns a live OTR\n+    \/\/ BrowserContext, then we have to outlive that\n+    has_live_otr_context = context->HasOffTheRecordContext();\n   } else {\n-    base::MessageLoop::current()->PostTask(\n-        FROM_HERE,\n-        base::Bind(&BrowserContextDestroyer::FinishDestroyContext,\n-                   \/\/ We have exclusive ownership of |this| - nobody else can\n-                   \/\/ reference or delete it\n-                   base::Unretained(this)));\n+    \/\/ If |context| is an OTR BrowserContext and its owner has already been\n+    \/\/ scheduled for deletion, then we need to prevent the owner from being\n+    \/\/ deleted until after |context|\n+    BrowserContextDestroyer* orig_destroyer =\n+        GetForContext(context->GetOriginalContext());\n+    if (orig_destroyer) {\n+      CHECK(!orig_destroyer->finish_destroy_scheduled_);\n+      ++orig_destroyer->otr_contexts_pending_deletion_;\n+    }\n+  }\n+\n+  \/\/ Get all of the live RenderProcessHosts that are using |context|\n+  std::set<content::RenderProcessHost*> hosts =\n+      GetHostsForContext(context.get());\n+\n+  content::BrowserContext::NotifyWillBeDestroyed(context.get());\n+\n+  \/\/ |hosts| might not be empty if the application released its BrowserContext\n+  \/\/ too early, or if |context| is an OTR context or this application is single\n+  \/\/ process\n+\n+  if (!hosts.empty() ||\n+      otr_contexts_pending_deletion > 0 ||\n+      has_live_otr_context) {\n+    \/\/ |context| is not safe to delete yet\n+    new BrowserContextDestroyer(std::move(context),\n+                                hosts,\n+                                otr_contexts_pending_deletion);\n   }\n }\n \n \/\/ static\n-void BrowserContextDestroyer::DestroyContext(BrowserContext* context) {\n-  CHECK(context->IsOffTheRecord() || !context->HasOffTheRecordContext());\n+void BrowserContextDestroyer::Shutdown() {\n+  auto destroy_all_unused_contexts = []() {\n+    auto it = g_contexts_pending_deletion.Get().begin();\n+    while (it != g_contexts_pending_deletion.Get().end()) {\n+      BrowserContextDestroyer* destroyer = *it;\n+      ++it;\n \n-  content::BrowserContext::NotifyWillBeDestroyed(context);\n-\n-  std::set<content::RenderProcessHost*> hosts;\n+      if (!destroyer->finish_destroy_scheduled_) {\n+        continue;\n+      }\n \n-  for (content::RenderProcessHost::iterator it =\n-           content::RenderProcessHost::AllHostsIterator();\n-       !it.IsAtEnd(); it.Advance()) {\n-    content::RenderProcessHost* host = it.GetCurrentValue();\n-    if (host->GetBrowserContext() != context) {\n-      continue;\n+      destroyer->FinishDestroyContext();\n+      \/\/ |destroyer| is invalid now\n     }\n+  };\n \n-    hosts.insert(host);\n+  \/\/ We make 2 passes over the list because the first pass can destroy an\n+  \/\/ incognito BrowserContext that subsequently schedules its owner context for\n+  \/\/ deletion\n+  destroy_all_unused_contexts();\n+  destroy_all_unused_contexts();\n+}\n+\n+\/\/ static\n+void BrowserContextDestroyer::RenderProcessHostAssignedToSiteInstance(\n+    content::RenderProcessHost* host) {\n+  BrowserContextDestroyer* destroyer = GetForContext(host->GetBrowserContext());\n+  if (!destroyer) {\n+    return;\n   }\n \n-  \/\/ XXX: Given that we shutdown the service worker context and that there\n-  \/\/ shouldn't be any live WebContents left, are there any circumstances\n-  \/\/ other than in single-process mode where |hosts| isn't empty?\n+  CHECK(!destroyer->finish_destroy_scheduled_);\n \n-  if (hosts.empty()) {\n-    delete context;\n-  } else {\n-    new BrowserContextDestroyer(context, hosts);\n+  if (destroyer->pending_host_ids_.find(host->GetID()) !=\n+      destroyer->pending_host_ids_.end()) {\n+    return;\n   }\n+\n+  destroyer->ObserveHost(host);\n }\n \n } \/\/ namespace oxide\ndiff --git a\/shared\/browser\/oxide_browser_context_destroyer.h b\/shared\/browser\/oxide_browser_context_destroyer.h\nindex 61d363b..037be29 100644\n--- a\/shared\/browser\/oxide_browser_context_destroyer.h\n+++ b\/shared\/browser\/oxide_browser_context_destroyer.h\n@@ -18,12 +18,14 @@\n #ifndef _OXIDE_SHARED_BROWSER_BROWSER_CONTEXT_DESTROYER_H_\n #define _OXIDE_SHARED_BROWSER_BROWSER_CONTEXT_DESTROYER_H_\n \n+#include <memory>\n #include <set>\n \n #include \"base\/macros.h\"\n #include \"content\/public\/browser\/render_process_host_observer.h\"\n \n namespace content {\n+class BrowserContext;\n class RenderProcessHost;\n }\n \n@@ -31,23 +33,51 @@ namespace oxide {\n \n class BrowserContext;\n \n+\/\/ A mechanism to manage BrowserContext destruction, ensuring it stays alive\n+\/\/ until consumers inside Chromium no longer require it\n class BrowserContextDestroyer : public content::RenderProcessHostObserver {\n  public:\n-  static void DestroyContext(BrowserContext* context);\n+  \/\/ Schedule |context| for deletion. If no RenderProcessHosts are using it then\n+  \/\/ this will result in it being deleted immediately, else deletion will be\n+  \/\/ happen after all RenderProcessHosts using it have gone away\n+  static void DestroyContext(std::unique_ptr<BrowserContext> context);\n+\n+  \/\/ Delete all BrowserContexts that are pending deletion and safe to be deleted\n+  static void Shutdown();\n+\n+  \/\/ Notify that |host| has been assigned to a SiteInstance. This is the first\n+  \/\/ notification we get from content after a RenderProcessHost is created,\n+  \/\/ although this doesn't mean it was actually just created.\n+  \/\/ This ensures that |host| will be tracked if its BrowserContext has already\n+  \/\/ been scheduled for deletion.\n+  static void RenderProcessHostAssignedToSiteInstance(\n+      content::RenderProcessHost* host);\n \n  private:\n-  BrowserContextDestroyer(BrowserContext* context,\n-                          const std::set<content::RenderProcessHost*>& hosts);\n+  BrowserContextDestroyer(std::unique_ptr<BrowserContext> context,\n+                          const std::set<content::RenderProcessHost*>& hosts,\n+                          uint32_t otr_contexts_pending_deletion);\n   ~BrowserContextDestroyer() override;\n \n+  void ObserveHost(content::RenderProcessHost* host);\n+\n+  void MaybeScheduleFinishDestroyContext(\n+      content::RenderProcessHost* host_being_destroyed = nullptr);\n   void FinishDestroyContext();\n \n+  static BrowserContextDestroyer* GetForContext(\n+      content::BrowserContext* context);\n+\n   \/\/ content::RenderProcessHostObserver implementation\n   void RenderProcessHostDestroyed(content::RenderProcessHost* host) override;\n \n-  BrowserContext* context_;\n+  std::unique_ptr<BrowserContext> context_;\n+\n+  std::set<int> pending_host_ids_;\n+\n+  uint32_t otr_contexts_pending_deletion_;\n \n-  uint32_t pending_hosts_;\n+  bool finish_destroy_scheduled_;\n   \n   DISALLOW_COPY_AND_ASSIGN(BrowserContextDestroyer);\n };\ndiff --git a\/shared\/browser\/oxide_browser_main_parts.cc b\/shared\/browser\/oxide_browser_main_parts.cc\nindex 701a6e7..069a288 100644\n--- a\/shared\/browser\/oxide_browser_main_parts.cc\n+++ b\/shared\/browser\/oxide_browser_main_parts.cc\n@@ -49,6 +49,7 @@\n #include \"shared\/gpu\/oxide_gl_context_dependent.h\"\n \n #include \"oxide_browser_context.h\"\n+#include \"oxide_browser_context_destroyer.h\"\n #include \"oxide_browser_platform_integration.h\"\n #include \"oxide_browser_process_main.h\"\n #include \"oxide_geolocation_delegate.h\"\n@@ -57,6 +58,7 @@\n #include \"oxide_lifecycle_observer.h\"\n #include \"oxide_message_pump.h\"\n #include \"oxide_render_process_initializer.h\"\n+#include \"oxide_web_contents_unloader.h\"\n #include \"oxide_web_contents_view.h\"\n #include \"screen.h\"\n \n@@ -341,15 +343,15 @@ bool BrowserMainParts::MainMessageLoopRun(int* result_code) {\n }\n \n void BrowserMainParts::PostMainMessageLoopRun() {\n+  WebContentsUnloader::GetInstance()->Shutdown();\n+\n+  BrowserContextDestroyer::Shutdown();\n+  BrowserContext::AssertNoContextsExist();\n+\n   CompositorUtils::GetInstance()->Shutdown();\n }\n \n void BrowserMainParts::PostDestroyThreads() {\n-  if (BrowserProcessMain::GetInstance()->GetProcessModel() ==\n-      PROCESS_MODEL_SINGLE_PROCESS) {\n-    BrowserContext::AssertNoContextsExist();\n-  }\n-\n   device_client_.reset();\n \n   display::Screen::SetScreenInstance(nullptr);\ndiff --git a\/shared\/browser\/oxide_browser_process_main.cc b\/shared\/browser\/oxide_browser_process_main.cc\nindex 22dc77c..65d8187 100644\n--- a\/shared\/browser\/oxide_browser_process_main.cc\n+++ b\/shared\/browser\/oxide_browser_process_main.cc\n@@ -72,10 +72,8 @@\n #include \"shared\/common\/oxide_content_client.h\"\n #include \"shared\/common\/oxide_form_factor.h\"\n \n-#include \"oxide_browser_context.h\"\n #include \"oxide_form_factor_detection.h\"\n #include \"oxide_message_pump.h\"\n-#include \"oxide_web_contents_unloader.h\"\n \n namespace content {\n \n@@ -581,14 +579,6 @@ void BrowserProcessMainImpl::Shutdown() {\n \n   MessagePump::Get()->Stop();\n \n-  WebContentsUnloader::GetInstance()->Shutdown();\n-\n-  if (process_model_ != PROCESS_MODEL_SINGLE_PROCESS) {\n-    \/\/ In single process mode, we do this check after destroying\n-    \/\/ threads, as we hold the single BrowserContext alive until then\n-    BrowserContext::AssertNoContextsExist();\n-  }\n-\n   browser_main_runner_->Shutdown();\n   browser_main_runner_.reset();\n \ndiff --git a\/shared\/browser\/oxide_content_browser_client.cc b\/shared\/browser\/oxide_content_browser_client.cc\nindex 1023648..e10e20d 100644\n--- a\/shared\/browser\/oxide_content_browser_client.cc\n+++ b\/shared\/browser\/oxide_content_browser_client.cc\n@@ -46,7 +46,9 @@\n #include \"shared\/common\/oxide_content_client.h\"\n \n #include \"display_form_factor.h\"\n+#include \"in_process_renderer_observer.h\"\n #include \"oxide_browser_context.h\"\n+#include \"oxide_browser_context_destroyer.h\"\n #include \"oxide_browser_main_parts.h\"\n #include \"oxide_browser_platform_integration.h\"\n #include \"oxide_browser_process_main.h\"\n@@ -92,12 +94,17 @@ content::BrowserMainParts* ContentBrowserClient::CreateBrowserMainParts(\n \n void ContentBrowserClient::RenderProcessWillLaunch(\n     content::RenderProcessHost* host) {\n+  if (content::RenderProcessHost::run_renderer_in_process()) {\n+    host->AddObserver(new InProcessRendererObserver());\n+  }\n+\n   host->AddFilter(new RenderMessageFilter(host));\n }\n \n-std::string ContentBrowserClient::GetAcceptLangs(\n-    content::BrowserContext* browser_context) {\n-  return UserAgentSettings::Get(browser_context)->GetAcceptLangs();\n+void ContentBrowserClient::SiteInstanceGotProcess(\n+    content::SiteInstance* site_instance) {\n+  BrowserContextDestroyer::RenderProcessHostAssignedToSiteInstance(\n+      site_instance->GetProcess());\n }\n \n void ContentBrowserClient::AppendExtraCommandLineSwitches(\n@@ -130,6 +137,16 @@ void ContentBrowserClient::AppendExtraCommandLineSwitches(\n   }\n }\n \n+std::string\n+ContentBrowserClient::GetApplicationLocale() {\n+  return application_locale_;\n+}\n+\n+std::string ContentBrowserClient::GetAcceptLangs(\n+    content::BrowserContext* browser_context) {\n+  return UserAgentSettings::Get(browser_context)->GetAcceptLangs();\n+}\n+\n bool ContentBrowserClient::AllowGetCookie(const GURL& url,\n                                           const GURL& first_party,\n                                           const net::CookieList& cookie_list,\n@@ -339,11 +356,6 @@ ContentBrowserClient::GetOsTypeOverrideForGpuDataManager(\n #endif\n }\n \n-std::string\n-ContentBrowserClient::GetApplicationLocale() {\n-  return application_locale_;\n-}\n-\n ContentBrowserClient::ContentBrowserClient(\n     const std::string& application_locale,\n     BrowserPlatformIntegration* integration)\ndiff --git a\/shared\/browser\/oxide_content_browser_client.h b\/shared\/browser\/oxide_content_browser_client.h\nindex 15d47c9..45f3f33 100644\n--- a\/shared\/browser\/oxide_content_browser_client.h\n+++ b\/shared\/browser\/oxide_content_browser_client.h\n@@ -48,14 +48,15 @@ class ContentBrowserClient final : public content::ContentBrowserClient {\n \n  private:\n   \/\/ content::ContentBrowserClient implementation\n-  std::string GetApplicationLocale() override;\n   content::BrowserMainParts* CreateBrowserMainParts(\n       const content::MainFunctionParams& parameters) override;\n   void RenderProcessWillLaunch(content::RenderProcessHost* host) override;\n-  std::string GetAcceptLangs(\n-      content::BrowserContext* browser_context) override;\n+  void SiteInstanceGotProcess(content::SiteInstance* site_instance) override;\n   void AppendExtraCommandLineSwitches(base::CommandLine* command_line,\n                                       int child_process_id) override;\n+  std::string GetApplicationLocale() override;\n+  std::string GetAcceptLangs(\n+      content::BrowserContext* browser_context) override;\n   bool AllowGetCookie(const GURL& url,\n                       const GURL& first_party,\n                       const net::CookieList& cookie_list,\ndiff --git a\/shared\/browser\/oxide_web_contents_unloader.cc b\/shared\/browser\/oxide_web_contents_unloader.cc\nindex efc28ea..6e0d4cf 100644\n--- a\/shared\/browser\/oxide_web_contents_unloader.cc\n+++ b\/shared\/browser\/oxide_web_contents_unloader.cc\n@@ -24,8 +24,26 @@\n #include \"content\/public\/browser\/web_contents.h\"\n #include \"content\/public\/browser\/web_contents_observer.h\"\n \n+#include \"oxide_browser_context.h\"\n+#include \"oxide_web_view_contents_helper.h\"\n+\n namespace oxide {\n \n+namespace {\n+\n+void MaybeDestroyOffTheRecordContext(BrowserContext* context) {\n+  DCHECK(context->IsOffTheRecord());\n+\n+  if (WebViewContentsHelper::IsContextInUse(context)) {\n+    return;\n+  }\n+\n+  BrowserContext::DestroyOffTheRecordContextForContext(\n+      context->GetOriginalContext());\n+}\n+\n+}\n+\n class WebContentsUnloaderObserver : public content::WebContentsObserver {\n  public:\n   explicit WebContentsUnloaderObserver(content::WebContents* contents)\n@@ -46,10 +64,12 @@ class WebContentsUnloaderObserver : public content::WebContentsObserver {\n WebContentsUnloader::WebContentsUnloader() = default;\n \n void WebContentsUnloader::CloseContents(content::WebContents* contents) {\n-  ScopedVector<content::WebContents>::iterator it =\n-      std::find(contents_unloading_.begin(),\n-                contents_unloading_.end(),\n-                contents);\n+  auto it = std::find_if(\n+      contents_unloading_.begin(),\n+      contents_unloading_.end(),\n+      [contents](const std::unique_ptr<content::WebContents>& c) {\n+    return contents == c.get();\n+  });\n   DCHECK(it != contents_unloading_.end());\n \n   contents_unloading_.erase(it);\n@@ -64,21 +84,28 @@ WebContentsUnloader* WebContentsUnloader::GetInstance() {\n \n void WebContentsUnloader::Unload(\n     std::unique_ptr<content::WebContents> contents) {\n-  if (!contents->NeedToFireBeforeUnload()) {\n+  content::WebContents* c = contents.get();\n+  contents_unloading_.push_back(std::move(contents));\n+\n+  content::BrowserContext* context = c->GetBrowserContext();\n+  if (context->IsOffTheRecord()) {\n+    MaybeDestroyOffTheRecordContext(BrowserContext::FromContent(context));\n+  }\n+\n+  if (!c->NeedToFireBeforeUnload()) {\n     \/\/ Despite the name, this checks if sudden termination is allowed. If so,\n     \/\/ we shouldn't fire the unload handler particularly if this was script\n     \/\/ closed, else we'll never get an ACK\n+    CloseContents(c);\n+    \/\/ |c| is invalid now\n     return;\n   }\n \n   \/\/ To intercept render process crashes\n-  new WebContentsUnloaderObserver(contents.get());\n+  new WebContentsUnloaderObserver(c);\n \n   \/\/ So we can intercept CloseContents\n-  contents->SetDelegate(this);\n-\n-  content::WebContents* c = contents.get();\n-  contents_unloading_.push_back(contents.release());\n+  c->SetDelegate(this);\n \n   c->ClosePage();\n   \/\/ Note: |c| might be deleted at this point\n@@ -88,4 +115,13 @@ void WebContentsUnloader::Shutdown() {\n   contents_unloading_.clear();\n }\n \n+bool WebContentsUnloader::IsUnloadInProgress(content::WebContents* contents) {\n+  return std::find_if(\n+      contents_unloading_.begin(),\n+      contents_unloading_.end(),\n+      [contents](const std::unique_ptr<content::WebContents>& c) {\n+    return contents == c.get();\n+  }) != contents_unloading_.end();\n+}\n+\n }\ndiff --git a\/shared\/browser\/oxide_web_contents_unloader.h b\/shared\/browser\/oxide_web_contents_unloader.h\nindex 00651ee..619d59e 100644\n--- a\/shared\/browser\/oxide_web_contents_unloader.h\n+++ b\/shared\/browser\/oxide_web_contents_unloader.h\n@@ -19,9 +19,9 @@\n #define _OXIDE_SHARED_BROWSER_WEB_CONTENTS_UNLOADER_H_\n \n #include <memory>\n+#include <vector>\n \n #include \"base\/macros.h\"\n-#include \"base\/memory\/scoped_vector.h\"\n #include \"content\/public\/browser\/web_contents_delegate.h\"\n \n namespace base {\n@@ -48,9 +48,13 @@ class WebContentsUnloader : public content::WebContentsDelegate {\n   \/\/ takes ownership of |contents| and deletes it when complete\n   void Unload(std::unique_ptr<content::WebContents> contents);\n \n-  \/\/ Delete all WebContents that are currently closing\n+  \/\/ Delete all WebContents that are currently closing without waiting for\n+  \/\/ unload handlers to complete\n   void Shutdown();\n \n+  \/\/ Determine whether |contents| is currently unloading\n+  bool IsUnloadInProgress(content::WebContents* contents);\n+\n  private:\n   friend class base::DefaultSingletonTraits<WebContentsUnloader>;\n \n@@ -60,7 +64,7 @@ class WebContentsUnloader : public content::WebContentsDelegate {\n   void CloseContents(content::WebContents* contents) override;\n \n   \/\/ The WebContents for which we are waiting to unload\n-  ScopedVector<content::WebContents> contents_unloading_;\n+  std::vector<std::unique_ptr<content::WebContents>> contents_unloading_;\n \n   DISALLOW_COPY_AND_ASSIGN(WebContentsUnloader);\n };\ndiff --git a\/shared\/browser\/oxide_web_view.cc b\/shared\/browser\/oxide_web_view.cc\nindex d1f2769..03520d9 100644\n--- a\/shared\/browser\/oxide_web_view.cc\n+++ b\/shared\/browser\/oxide_web_view.cc\n@@ -994,11 +994,11 @@ WebView::WebView(const CommonParams& common_params,\n     : WebView(common_params.client) {\n   CHECK(create_params.context) << \"Didn't specify a BrowserContext\";\n \n-  scoped_refptr<BrowserContext> context = create_params.incognito ?\n+  BrowserContext* context = create_params.incognito ?\n       create_params.context->GetOffTheRecordContext() :\n       create_params.context->GetOriginalContext();\n \n-  content::WebContents::CreateParams content_params(context.get());\n+  content::WebContents::CreateParams content_params(context);\n   content_params.initial_size =\n       gfx::ToEnclosingRect(common_params.view_client->GetBounds()).size();\n   content_params.initially_hidden = !common_params.view_client->IsVisible();\n@@ -1013,7 +1013,7 @@ WebView::WebView(const CommonParams& common_params,\n   if (create_params.restore_entries.size() > 0) {\n     std::vector<std::unique_ptr<content::NavigationEntry>> entries =\n         sessions::ContentSerializedNavigationBuilder::ToNavigationEntries(\n-            create_params.restore_entries, context.get());\n+            create_params.restore_entries, context);\n     web_contents_->GetController().Restore(\n         create_params.restore_index,\n         create_params.restore_type,\ndiff --git a\/shared\/browser\/oxide_web_view_contents_helper.cc b\/shared\/browser\/oxide_web_view_contents_helper.cc\nindex a0aecf2..e244345 100644\n--- a\/shared\/browser\/oxide_web_view_contents_helper.cc\n+++ b\/shared\/browser\/oxide_web_view_contents_helper.cc\n@@ -17,6 +17,9 @@\n \n #include \"oxide_web_view_contents_helper.h\"\n \n+#include <set>\n+\n+#include \"base\/lazy_instance.h\"\n #include \"base\/logging.h\"\n #include \"content\/public\/browser\/render_view_host.h\"\n #include \"content\/public\/browser\/web_contents.h\"\n@@ -26,6 +29,7 @@\n #include \"shared\/common\/oxide_content_client.h\"\n \n #include \"oxide_browser_context.h\"\n+#include \"oxide_web_contents_unloader.h\"\n #include \"oxide_web_contents_view.h\"\n #include \"oxide_web_preferences.h\"\n #include \"oxide_web_view.h\"\n@@ -34,9 +38,14 @@ namespace oxide {\n \n namespace {\n const char kWebViewContentsHelperKey[] = \"oxide_web_view_contents_helper_data\";\n+base::LazyInstance<std::set<WebViewContentsHelper*>> g_contents_helpers =\n+    LAZY_INSTANCE_INITIALIZER;\n }\n \n WebViewContentsHelper::~WebViewContentsHelper() {\n+  size_t erased = g_contents_helpers.Get().erase(this);\n+  DCHECK_GT(erased, 0U);\n+\n   if (web_preferences() && owns_web_preferences_) {\n     WebPreferences* prefs = web_preferences();\n     WebPreferencesObserver::Observe(nullptr);\n@@ -57,14 +66,10 @@ void WebViewContentsHelper::NotifyPopupBlockerEnabledChanged() {\n   UpdateWebPreferences();\n }\n \n-void WebViewContentsHelper::WebPreferencesValueChanged() {\n-  UpdateWebPreferences();\n-}\n-\n void WebViewContentsHelper::NotifyDoNotTrackChanged() {\n   content::RendererPreferences* renderer_prefs =\n       web_contents_->GetMutableRendererPrefs();\n-  renderer_prefs->enable_do_not_track = context_->GetDoNotTrack();\n+  renderer_prefs->enable_do_not_track = GetBrowserContext()->GetDoNotTrack();\n \n   \/\/ Send the new override string to the renderer.\n   content::RenderViewHost* rvh = web_contents_->GetRenderViewHost();\n@@ -88,20 +93,25 @@ void WebViewContentsHelper::OnShellModeChanged() {\n   UpdateWebPreferences();\n }\n \n+void WebViewContentsHelper::WebPreferencesValueChanged() {\n+  UpdateWebPreferences();\n+}\n+\n WebViewContentsHelper::WebViewContentsHelper(content::WebContents* contents,\n                                              content::WebContents* opener)\n     : BrowserContextObserver(\n           BrowserContext::FromContent(contents->GetBrowserContext())),\n-      context_(BrowserContext::FromContent(contents->GetBrowserContext())),\n       web_contents_(contents),\n       owns_web_preferences_(false) {\n   DCHECK(!FromWebContents(web_contents_));\n \n+  g_contents_helpers.Get().insert(this);\n+\n   web_contents_->SetUserData(kWebViewContentsHelperKey, this);\n \n   content::RendererPreferences* renderer_prefs =\n       web_contents_->GetMutableRendererPrefs();\n-  renderer_prefs->enable_do_not_track = context_->GetDoNotTrack();\n+  renderer_prefs->enable_do_not_track = GetBrowserContext()->GetDoNotTrack();\n \n   \/\/ Hardcoded selection colors to match the current Ambiance theme from the\n   \/\/ Ubuntu UI Toolkit (https:\/\/bazaar.launchpad.net\/~ubuntu-sdk-team\/ubuntu-ui-toolkit\/trunk\/view\/head:\/src\/Ubuntu\/Components\/Themes\/Ambiance\/1.3\/Palette.qml)\n@@ -135,7 +145,6 @@ WebViewContentsHelper* WebViewContentsHelper::FromWebContents(\n       contents->GetUserData(kWebViewContentsHelperKey));\n }\n \n-\/\/ static\n WebViewContentsHelper* WebViewContentsHelper::FromRenderViewHost(\n     content::RenderViewHost* rvh) {\n   content::WebContents* contents =\n@@ -147,12 +156,25 @@ WebViewContentsHelper* WebViewContentsHelper::FromRenderViewHost(\n   return FromWebContents(contents);\n }\n \n+\/\/ static\n+bool WebViewContentsHelper::IsContextInUse(BrowserContext* context) {\n+  for (auto* helper : g_contents_helpers.Get()) {\n+    if (helper->GetBrowserContext() == context &&\n+        !WebContentsUnloader::GetInstance()->IsUnloadInProgress(\n+            helper->GetWebContents())) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n content::WebContents* WebViewContentsHelper::GetWebContents() const {\n   return web_contents_;\n }\n \n BrowserContext* WebViewContentsHelper::GetBrowserContext() const {\n-  return context_.get();\n+  return BrowserContext::FromContent(web_contents_->GetBrowserContext());\n }\n \n WebPreferences* WebViewContentsHelper::GetWebPreferences() const {\ndiff --git a\/shared\/browser\/oxide_web_view_contents_helper.h b\/shared\/browser\/oxide_web_view_contents_helper.h\nindex 9274bd5..3a5e474 100644\n--- a\/shared\/browser\/oxide_web_view_contents_helper.h\n+++ b\/shared\/browser\/oxide_web_view_contents_helper.h\n@@ -48,6 +48,8 @@ class WebViewContentsHelper final : private BrowserContextObserver,\n   static WebViewContentsHelper* FromWebContents(content::WebContents* contents);\n   static WebViewContentsHelper* FromRenderViewHost(content::RenderViewHost* rvh);\n \n+  static bool IsContextInUse(BrowserContext* context);\n+\n   content::WebContents* GetWebContents() const;\n   BrowserContext* GetBrowserContext() const;\n \n@@ -72,7 +74,6 @@ class WebViewContentsHelper final : private BrowserContextObserver,\n   \/\/ WebPreferencesObserver implementation\n   void WebPreferencesValueChanged() final;\n \n-  scoped_refptr<BrowserContext> context_;\n   content::WebContents* web_contents_;\n \n   bool owns_web_preferences_;\n-- \ncgit v0.10.2\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-3558","CWE_ID":"20","category":"security","commit_id":"c5d6e07588cd03061bc54d451a7fa6e84883d62b","commit_message":"From c5d6e07588cd03061bc54d451a7fa6e84883d62b Mon Sep 17 00:00:00 2001\nFrom: Stepan Palamarchuk <stepan@fb.com>\nDate: Thu, 14 Feb 2019 13:37:15 -0800\nSubject: [PATCH] Throw on bad types during skipping data\n\nSummary:\nThe current code silently returns on bad types. In case when we have an invalid data, we may get a container of a large size with a bad type, this would lead to us running long loop doing nothing (though we already can say that the data is invalid).\n\nThe new code would throw an exception as soon as we try to skip a value of invalid type.\n\nFixes CVE-2019-3552\n\nReviewed By: yfeldblum, stevegury\n\nDifferential Revision: D8344920\n\nfbshipit-source-id: f12e8f3442f7ad5e1a81d822380701e929b80f0d\n---\n ...\/lib\/cpp\/protocol\/TProtocolException.cpp   |  8 +++\n thrift\/lib\/cpp\/protocol\/TProtocolException.h  |  2 +\n thrift\/lib\/cpp2\/protocol\/Protocol.h           |  5 +-\n thrift\/lib\/py\/protocol\/TProtocol.py           |  9 ++-\n thrift\/test\/ProtocolSkipTest.cpp              | 68 +++++++++++++++++++\n 5 files changed, 87 insertions(+), 5 deletions(-)\n create mode 100644 thrift\/test\/ProtocolSkipTest.cpp\n\n","diff_code":"diff --git a\/thrift\/lib\/cpp\/protocol\/TProtocolException.cpp b\/thrift\/lib\/cpp\/protocol\/TProtocolException.cpp\nindex d0ad89450..ab84de2a7 100644\n--- a\/thrift\/lib\/cpp\/protocol\/TProtocolException.cpp\n+++ b\/thrift\/lib\/cpp\/protocol\/TProtocolException.cpp\n@@ -57,4 +57,12 @@ namespace apache { namespace thrift { namespace protocol {\n           \"Attempt to interpret value {} as bool, probably the data is corrupted\",\n           value));\n }\n+\n+[[noreturn]] void TProtocolException::throwInvalidSkipType(TType type) {\n+  throw TProtocolException(\n+      TProtocolException::INVALID_DATA,\n+      folly::sformat(\n+          \"Encountered invalid field\/element type ({}) during skipping\",\n+          static_cast<uint8_t>(type)));\n+}\n }}}\ndiff --git a\/thrift\/lib\/cpp\/protocol\/TProtocolException.h b\/thrift\/lib\/cpp\/protocol\/TProtocolException.h\nindex 874654fa4..193d25d78 100644\n--- a\/thrift\/lib\/cpp\/protocol\/TProtocolException.h\n+++ b\/thrift\/lib\/cpp\/protocol\/TProtocolException.h\n@@ -23,6 +23,7 @@\n #define _THRIFT_PROTOCOL_TPROTOCOLEXCEPTION_H_ 1\n \n #include <thrift\/lib\/cpp\/Thrift.h>\n+#include <thrift\/lib\/cpp\/protocol\/TType.h>\n \n #include <string>\n \n@@ -106,6 +107,7 @@ class TProtocolException : public apache::thrift::TLibraryException {\n       folly::StringPiece field,\n       folly::StringPiece type);\n   [[noreturn]] static void throwBoolValueOutOfRange(uint8_t value);\n+  [[noreturn]] static void throwInvalidSkipType(TType type);\n \n  protected:\n   \/**\ndiff --git a\/thrift\/lib\/cpp2\/protocol\/Protocol.h b\/thrift\/lib\/cpp2\/protocol\/Protocol.h\nindex d1cc63ed6..033668ac7 100644\n--- a\/thrift\/lib\/cpp2\/protocol\/Protocol.h\n+++ b\/thrift\/lib\/cpp2\/protocol\/Protocol.h\n@@ -176,8 +176,9 @@ void skip(Protocol_& prot, TType arg_type) {\n       prot.readListEnd();\n       return;\n     }\n-    default:\n-      return;\n+    default: {\n+      TProtocolException::throwInvalidSkipType(arg_type);\n+    }\n   }\n }\n \ndiff --git a\/thrift\/lib\/py\/protocol\/TProtocol.py b\/thrift\/lib\/py\/protocol\/TProtocol.py\nindex a229eb025..252b53db4 100644\n--- a\/thrift\/lib\/py\/protocol\/TProtocol.py\n+++ b\/thrift\/lib\/py\/protocol\/TProtocol.py\n@@ -177,9 +177,7 @@ def readString(self):\n         pass\n \n     def skip(self, type):\n-        if type == TType.STOP:\n-            return\n-        elif type == TType.BOOL:\n+        if type == TType.BOOL:\n             self.readBool()\n         elif type == TType.BYTE:\n             self.readByte()\n@@ -220,6 +218,11 @@ def skip(self, type):\n             for _ in range(size):\n                 self.skip(etype)\n             self.readListEnd()\n+        else:\n+            raise TProtocolException(\n+                TProtocolException.INVALID_DATA,\n+                \"Unexpected type for skipping {}\".format(type)\n+            )\n \n     def readIntegral(self, type):\n         if type == TType.BOOL:\ndiff --git a\/thrift\/test\/ProtocolSkipTest.cpp b\/thrift\/test\/ProtocolSkipTest.cpp\nnew file mode 100644\nindex 000000000..762ec64a8\n--- \/dev\/null\n+++ b\/thrift\/test\/ProtocolSkipTest.cpp\n@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright 2004-present Facebook, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\n+#include <gtest\/gtest.h>\n+\n+#include <thrift\/lib\/cpp2\/protocol\/CompactProtocol.h>\n+\n+using namespace apache::thrift;\n+\n+TEST(ProtocolSkipTest, SkipInt) {\n+  IOBufQueue queue;\n+  CompactProtocolWriter writer;\n+  writer.setOutput(&queue);\n+  writer.writeI32(123);\n+  auto buf = queue.move();\n+  CompactProtocolReader reader;\n+  reader.setInput(buf.get());\n+  reader.skip(TType::T_I32);\n+}\n+\n+TEST(ProtocolSkipTest, SkipStop) {\n+  IOBufQueue queue;\n+  CompactProtocolWriter writer;\n+  writer.setOutput(&queue);\n+  writer.writeFieldStop();\n+  auto buf = queue.move();\n+  CompactProtocolReader reader;\n+  reader.setInput(buf.get());\n+  bool thrown = false;\n+  try {\n+    reader.skip(TType::T_STOP);\n+  } catch (const TProtocolException& ex) {\n+    EXPECT_EQ(TProtocolException::INVALID_DATA, ex.getType());\n+    thrown = true;\n+  }\n+  EXPECT_TRUE(thrown);\n+}\n+\n+TEST(ProtocolSkipTest, SkipStopInContainer) {\n+  IOBufQueue queue;\n+  CompactProtocolWriter writer;\n+  writer.setOutput(&queue);\n+  writer.writeListBegin(TType::T_STOP, 1u << 30);\n+  auto buf = queue.move();\n+  CompactProtocolReader reader;\n+  reader.setInput(buf.get());\n+  bool thrown = false;\n+  try {\n+    reader.skip(TType::T_LIST);\n+  } catch (const TProtocolException& ex) {\n+    EXPECT_EQ(TProtocolException::INVALID_DATA, ex.getType());\n+    thrown = true;\n+  }\n+  EXPECT_TRUE(thrown);\n+}\n","owner":"facebook","repo":"fbthrift","source":"cve"},{"CVE_ID":"CVE-2018-5803","CWE_ID":"20","category":"security","commit_id":"07f2c7ab6f8d0a7e7c5764c4e6cc9c52951b9d9c","commit_message":"From 07f2c7ab6f8d0a7e7c5764c4e6cc9c52951b9d9c Mon Sep 17 00:00:00 2001\nFrom: Alexey Kodanev <alexey.kodanev@oracle.com>\nDate: Fri, 9 Feb 2018 17:35:23 +0300\nSubject: sctp: verify size of a new chunk in _sctp_make_chunk()\n\nWhen SCTP makes INIT or INIT_ACK packet the total chunk length\ncan exceed SCTP_MAX_CHUNK_LEN which leads to kernel panic when\ntransmitting these packets, e.g. the crash on sending INIT_ACK:\n\n[  597.804948] skbuff: skb_over_panic: text:00000000ffae06e4 len:120168\n               put:120156 head:000000007aa47635 data:00000000d991c2de\n               tail:0x1d640 end:0xfec0 dev:<NULL>\n...\n[  597.976970] ------------[ cut here ]------------\n[  598.033408] kernel BUG at net\/core\/skbuff.c:104!\n[  600.314841] Call Trace:\n[  600.345829]  <IRQ>\n[  600.371639]  ? sctp_packet_transmit+0x2095\/0x26d0 [sctp]\n[  600.436934]  skb_put+0x16c\/0x200\n[  600.477295]  sctp_packet_transmit+0x2095\/0x26d0 [sctp]\n[  600.540630]  ? sctp_packet_config+0x890\/0x890 [sctp]\n[  600.601781]  ? __sctp_packet_append_chunk+0x3b4\/0xd00 [sctp]\n[  600.671356]  ? sctp_cmp_addr_exact+0x3f\/0x90 [sctp]\n[  600.731482]  sctp_outq_flush+0x663\/0x30d0 [sctp]\n[  600.788565]  ? sctp_make_init+0xbf0\/0xbf0 [sctp]\n[  600.845555]  ? sctp_check_transmitted+0x18f0\/0x18f0 [sctp]\n[  600.912945]  ? sctp_outq_tail+0x631\/0x9d0 [sctp]\n[  600.969936]  sctp_cmd_interpreter.isra.22+0x3be1\/0x5cb0 [sctp]\n[  601.041593]  ? sctp_sf_do_5_1B_init+0x85f\/0xc30 [sctp]\n[  601.104837]  ? sctp_generate_t1_cookie_event+0x20\/0x20 [sctp]\n[  601.175436]  ? sctp_eat_data+0x1710\/0x1710 [sctp]\n[  601.233575]  sctp_do_sm+0x182\/0x560 [sctp]\n[  601.284328]  ? sctp_has_association+0x70\/0x70 [sctp]\n[  601.345586]  ? sctp_rcv+0xef4\/0x32f0 [sctp]\n[  601.397478]  ? sctp6_rcv+0xa\/0x20 [sctp]\n...\n\nHere the chunk size for INIT_ACK packet becomes too big, mostly\nbecause of the state cookie (INIT packet has large size with\nmany address parameters), plus additional server parameters.\n\nLater this chunk causes the panic in skb_put_data():\n\n  skb_packet_transmit()\n      sctp_packet_pack()\n          skb_put_data(nskb, chunk->skb->data, chunk->skb->len);\n\n'nskb' (head skb) was previously allocated with packet->size\nfrom u16 'chunk->chunk_hdr->length'.\n\nAs suggested by Marcelo we should check the chunk's length in\n_sctp_make_chunk() before trying to allocate skb for it and\ndiscard a chunk if its size bigger than SCTP_MAX_CHUNK_LEN.\n\nSigned-off-by: Alexey Kodanev <alexey.kodanev@oracle.com>\nAcked-by: Marcelo Ricardo Leitner <marcelo.leinter@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/sctp\/sm_make_chunk.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/sctp\/sm_make_chunk.c b\/net\/sctp\/sm_make_chunk.c\nindex 793b05ec692b..d01475f5f710 100644\n--- a\/net\/sctp\/sm_make_chunk.c\n+++ b\/net\/sctp\/sm_make_chunk.c\n@@ -1380,9 +1380,14 @@ static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n \tstruct sctp_chunk *retval;\n \tstruct sk_buff *skb;\n \tstruct sock *sk;\n+\tint chunklen;\n+\n+\tchunklen = SCTP_PAD4(sizeof(*chunk_hdr) + paylen);\n+\tif (chunklen > SCTP_MAX_CHUNK_LEN)\n+\t\tgoto nodata;\n \n \t\/* No need to allocate LL here, as this is only a chunk. *\/\n-\tskb = alloc_skb(SCTP_PAD4(sizeof(*chunk_hdr) + paylen), gfp);\n+\tskb = alloc_skb(chunklen, gfp);\n \tif (!skb)\n \t\tgoto nodata;\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-6380","CWE_ID":"20","category":"security","commit_id":"b4789b8e6be3151a955ade74872822f30e8cd914","commit_message":"From b4789b8e6be3151a955ade74872822f30e8cd914 Mon Sep 17 00:00:00 2001\nFrom: Mahesh Rajashekhara <Mahesh.Rajashekhara@pmcs.com>\nDate: Thu, 31 Oct 2013 14:01:02 +0530\nSubject: [PATCH] aacraid: prevent invalid pointer dereference\n\nIt appears that driver runs into a problem here if fibsize is too small\nbecause we allocate user_srbcmd with fibsize size only but later we\naccess it until user_srbcmd->sg.count to copy it over to srbcmd.\n\nIt is not correct to test (fibsize < sizeof(*user_srbcmd)) because this\nstructure already includes one sg element and this is not needed for\ncommands without data.  So, we would recommend to add the following\n(instead of test for fibsize == 0).\n\nSigned-off-by: Mahesh Rajashekhara <Mahesh.Rajashekhara@pmcs.com>\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/scsi\/aacraid\/commctrl.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/scsi\/aacraid\/commctrl.c b\/drivers\/scsi\/aacraid\/commctrl.c\nindex d85ac1a9d2c06..fbcd48d0bfc33 100644\n--- a\/drivers\/scsi\/aacraid\/commctrl.c\n+++ b\/drivers\/scsi\/aacraid\/commctrl.c\n@@ -511,7 +511,8 @@ static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)\n \t\tgoto cleanup;\n \t}\n \n-\tif (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr))) {\n+\tif ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) ||\n+\t    (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) {\n \t\trcode = -EINVAL;\n \t\tgoto cleanup;\n \t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7536","CWE_ID":"20","category":"security","commit_id":"478cce544fdf1de882d78381768458f397964453","commit_message":"From 478cce544fdf1de882d78381768458f397964453 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Sun, 14 Feb 2016 08:40:26 +0100\nSubject: [PATCH] Fixed SEGV reported in\n https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/130\n\n---\n magick\/profile.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/magick\/profile.c b\/magick\/profile.c\nindex 76d2ec4baa..35cdd32ed4 100644\n--- a\/magick\/profile.c\n+++ b\/magick\/profile.c\n@@ -1444,7 +1444,8 @@ static void WriteTo8BimProfile(Image *image,const char *name,\n     count=(ssize_t) value;\n     if ((count & 0x01) != 0)\n       count++;\n-    if ((p > (datum+length-count)) || (count > (ssize_t) length))\n+    if ((count < 0) || (p > (datum+length-count)) ||\n+        (count > (ssize_t) length))\n       break;\n     if (id != profile_id)\n       p+=count;\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2017-8849","CWE_ID":"20","category":"security","commit_id":"a90289b0962663bc1d247bbbd31b9e65b2ca000e","commit_message":"From a90289b0962663bc1d247bbbd31b9e65b2ca000e Mon Sep 17 00:00:00 2001\nFrom: Albert Astals Cid <aacid@kde.org>\nDate: Wed, 10 May 2017 10:21:02 +0200\nSubject: Find the mount\/umount commands in the helper\n\nInstead of trusting what we get passed in\n\nCVE-2017-8849\n---\n core\/smb4kglobal.cpp         | 32 +++++++++++++++++++\n core\/smb4kglobal.h           | 14 +++++++++\n core\/smb4kmounter.cpp        | 42 +++----------------------\n helpers\/CMakeLists.txt       |  7 +++++\n helpers\/smb4kmounthelper.cpp | 75 ++++++++++++++++++++++++++++++++++++++++----\n helpers\/smb4kmounthelper.h   |  2 +-\n 6 files changed, 127 insertions(+), 45 deletions(-)\n\n","diff_code":"diff --git a\/core\/smb4kglobal.cpp b\/core\/smb4kglobal.cpp\nindex 765203d..cfa7ba5 100644\n--- a\/core\/smb4kglobal.cpp\n+++ b\/core\/smb4kglobal.cpp\n@@ -864,3 +864,35 @@ QStringList Smb4KGlobal::whitelistedMountArguments()\n #endif\n \n \n+const QString Smb4KGlobal::findMountExecutable()\n+{\n+  QStringList paths;\n+  paths << \"\/bin\";\n+  paths << \"\/sbin\";\n+  paths << \"\/usr\/bin\";\n+  paths << \"\/usr\/sbin\";\n+  paths << \"\/usr\/local\/bin\";\n+  paths << \"\/usr\/local\/sbin\";\n+\n+#if defined(Q_OS_LINUX)\n+  return QStandardPaths::findExecutable(\"mount.cifs\", paths);\n+#elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n+  return QStandardPaths::findExecutable(\"mount_smbfs\", paths);\n+#else\n+  return QString();\n+#endif\n+}\n+\n+\n+const QString Smb4KGlobal::findUmountExecutable()\n+{\n+  QStringList paths;\n+  paths << \"\/bin\";\n+  paths << \"\/sbin\";\n+  paths << \"\/usr\/bin\";\n+  paths << \"\/usr\/sbin\";\n+  paths << \"\/usr\/local\/bin\";\n+  paths << \"\/usr\/local\/sbin\";\n+\n+  return QStandardPaths::findExecutable(\"umount\", paths);\n+}\ndiff --git a\/core\/smb4kglobal.h b\/core\/smb4kglobal.h\nindex 63b6294..f29e342 100644\n--- a\/core\/smb4kglobal.h\n+++ b\/core\/smb4kglobal.h\n@@ -454,6 +454,20 @@ namespace Smb4KGlobal\n    *\/\n   Q_DECL_EXPORT QStringList whitelistedMountArguments();\n #endif\n+  \n+  \/**\n+   * Find the mount executable on the system.\n+   * \n+   * @returns the path of the mount executable.\n+   *\/\n+  Q_DECL_EXPORT const QString findMountExecutable();\n+  \n+  \/**\n+   * Find the umount executable on the system.\n+   * \n+   * @returns the path of the umount executable.\n+   *\/\n+  Q_DECL_EXPORT const QString findUmountExecutable();\n };\n \n #endif\ndiff --git a\/core\/smb4kmounter.cpp b\/core\/smb4kmounter.cpp\nindex 91f3863..0bc71aa 100644\n--- a\/core\/smb4kmounter.cpp\n+++ b\/core\/smb4kmounter.cpp\n@@ -1104,16 +1104,7 @@ void Smb4KMounter::timerEvent(QTimerEvent *)\n bool Smb4KMounter::fillMountActionArgs(Smb4KShare *share, QVariantMap& map)\n {\n   \/\/ Find the mount program.\n-  QString mount;\n-  QStringList paths;\n-  paths << \"\/bin\";\n-  paths << \"\/sbin\";\n-  paths << \"\/usr\/bin\";\n-  paths << \"\/usr\/sbin\";\n-  paths << \"\/usr\/local\/bin\";\n-  paths << \"\/usr\/local\/sbin\";\n-\n-  mount = QStandardPaths::findExecutable(\"mount.cifs\", paths);\n+  const QString mount = findMountExecutable();\n \n   if (!mount.isEmpty())\n   {\n@@ -1645,16 +1636,7 @@ bool Smb4KMounter::fillMountActionArgs(Smb4KShare *share, QVariantMap& map)\n bool Smb4KMounter::fillMountActionArgs(Smb4KShare *share, QVariantMap& map)\n {\n   \/\/ Find the mount program.\n-  QString mount;\n-  QStringList paths;\n-  paths << \"\/bin\";\n-  paths << \"\/sbin\";\n-  paths << \"\/usr\/bin\";\n-  paths << \"\/usr\/sbin\";\n-  paths << \"\/usr\/local\/bin\";\n-  paths << \"\/usr\/local\/sbin\";\n-\n-  mount = QStandardPaths::findExecutable(\"mount_smbfs\", paths);\n+  const QString mount = findMountExecutable();\n \n   if (!mount.isEmpty())\n   {\n@@ -1823,15 +1805,7 @@ bool Smb4KMounter::fillUnmountActionArgs(Smb4KShare *share, bool force, bool sil\n   \/\/\n   \/\/ The umount program\n   \/\/\n-  QStringList paths;\n-  paths << \"\/bin\";\n-  paths << \"\/sbin\";\n-  paths << \"\/usr\/bin\";\n-  paths << \"\/usr\/sbin\";\n-  paths << \"\/usr\/local\/bin\";\n-  paths << \"\/usr\/local\/sbin\";\n-\n-  QString umount = QStandardPaths::findExecutable(\"umount\", paths);\n+  const QString umount = findUmountExecutable();\n \n   if (umount.isEmpty() && !silent)\n   {\n@@ -1884,15 +1858,7 @@ bool Smb4KMounter::fillUnmountActionArgs(Smb4KShare *share, bool force, bool sil\n   \/\/\n   \/\/ The umount program\n   \/\/\n-  QStringList paths;\n-  paths << \"\/bin\";\n-  paths << \"\/sbin\";\n-  paths << \"\/usr\/bin\";\n-  paths << \"\/usr\/sbin\";\n-  paths << \"\/usr\/local\/bin\";\n-  paths << \"\/usr\/local\/sbin\";\n-\n-  QString umount = QStandardPaths::findExecutable(\"umount\", paths);\n+  const QString umount = findUmountExecutable();\n \n   if (umount.isEmpty() && !silent)\n   {\ndiff --git a\/helpers\/CMakeLists.txt b\/helpers\/CMakeLists.txt\nindex 77bb3a5..015c8b6 100644\n--- a\/helpers\/CMakeLists.txt\n+++ b\/helpers\/CMakeLists.txt\n@@ -1,8 +1,15 @@\n+include_directories(\n+  ${CMAKE_CURRENT_SOURCE_DIR}\n+  ${CMAKE_CURRENT_BINARY_DIR}\n+  ${CMAKE_SOURCE_DIR}\/core \n+  ${CMAKE_BINARY_DIR}\/core)\n+\n set(smb4kmounthelper_SRCS smb4kmounthelper.cpp)\n \n add_executable(mounthelper ${smb4kmounthelper_SRCS})\n \n target_link_libraries(mounthelper\n+  smb4kcore\n   Qt5::Core\n   KF5::Auth\n   KF5::CoreAddons\ndiff --git a\/helpers\/smb4kmounthelper.cpp b\/helpers\/smb4kmounthelper.cpp\nindex 641530e..0a1e215 100644\n--- a\/helpers\/smb4kmounthelper.cpp\n+++ b\/helpers\/smb4kmounthelper.cpp\n@@ -2,7 +2,7 @@\n     The helper that mounts and unmounts shares.\n                              -------------------\n     begin                : Sa Okt 16 2010\n-    copyright            : (C) 2010-2016 by Alexander Reinholdt\n+    copyright            : (C) 2010-2017 by Alexander Reinholdt\n     email                : alexander.reinholdt@kdemail.net\n  ***************************************************************************\/\n \n@@ -29,6 +29,7 @@\n \n \/\/ application specific includes\n #include \"smb4kmounthelper.h\"\n+#include \"..\/core\/smb4kglobal.h\"\n \n \/\/ Qt includes\n #include <QProcessEnvironment>\n@@ -42,14 +43,24 @@\n #include <KI18n\/KLocalizedString>\n #include <KIOCore\/KMountPoint>\n \n+using namespace Smb4KGlobal;\n+\n KAUTH_HELPER_MAIN(\"org.kde.smb4k.mounthelper\", Smb4KMountHelper);\n \n \n ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n {\n+  \/\/\n+  \/\/ The action reply\n+  \/\/\n   ActionReply reply;\n   \n   \/\/\n+  \/\/ Get the mount executable\n+  \/\/\n+  const QString mount = findMountExecutable();\n+  \n+  \/\/\n   \/\/ Iterate through the entries.\n   \/\/\n   QMapIterator<QString, QVariant> it(args);\n@@ -61,6 +72,20 @@ ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n     QVariantMap entry = it.value().toMap();\n     \n     \/\/\n+    \/\/ Check the executable\n+    \/\/\n+    if (mount != entry[\"mh_command\"].toString())\n+    {\n+      \/\/ Something weird is going on, bail out.\n+      reply.setType(ActionReply::HelperErrorType);\n+      return reply;\n+    }\n+    else\n+    {\n+      \/\/ Do nothing\n+    }\n+    \n+    \/\/\n     \/\/ The process\n     \/\/\n     KProcess proc(this);\n@@ -87,12 +112,12 @@ ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n     \/\/\n     QStringList command;\n #if defined(Q_OS_LINUX)\n-    command << entry[\"mh_command\"].toString();\n+    command << mount;\n     command << entry[\"mh_unc\"].toString();\n     command << entry[\"mh_mountpoint\"].toString();\n     command << entry[\"mh_options\"].toStringList();\n #elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n-    command << entry[\"mh_command\"].toString();\n+    command << mount;\n     command << entry[\"mh_options\"].toStringList();\n     command << entry[\"mh_unc\"].toString();\n     command << entry[\"mh_mountpoint\"].toString();\n@@ -208,6 +233,11 @@ ActionReply Smb4KMountHelper::unmountOneByOne(const QVariantMap& args)\n   ActionReply reply;\n   \n   \/\/\n+  \/\/ Get the mount executable\n+  \/\/\n+  const QString umount = findUmountExecutable();\n+  \n+  \/\/\n   \/\/ Iterate through the entries.\n   \/\/\n   QMapIterator<QString, QVariant> it(args);\n@@ -217,6 +247,20 @@ ActionReply Smb4KMountHelper::unmountOneByOne(const QVariantMap& args)\n     it.next();\n     QString index = it.key();\n     QVariantMap entry = it.value().toMap();\n+    \n+    \/\/\n+    \/\/ Check the executable\n+    \/\/\n+    if (umount != entry[\"mh_command\"].toString())\n+    {\n+      \/\/ Something weird is going on, bail out.\n+      reply.setType(ActionReply::HelperErrorType);\n+      return reply;\n+    }\n+    else\n+    {\n+      \/\/ Do nothing\n+    }\n       \n     \/\/\n     \/\/ Check if the mountpoint is valid and the filesystem is correct.\n@@ -261,7 +305,7 @@ ActionReply Smb4KMountHelper::unmountOneByOne(const QVariantMap& args)\n     \/\/ The command\n     \/\/\n     QStringList command;\n-    command << entry[\"mh_command\"].toString();\n+    command << umount;\n     command << entry[\"mh_options\"].toStringList();\n     command << entry[\"mh_mountpoint\"].toString();\n     \n@@ -342,6 +386,11 @@ ActionReply Smb4KMountHelper::unmountAtOnce(const QVariantMap& args)\n   ActionReply reply;\n   \n   \/\/\n+  \/\/ Get the mount executable\n+  \/\/\n+  const QString umount = findUmountExecutable();\n+  \n+  \/\/\n   \/\/ Check the mountpoints and put the valid ones into a string list\n   \/\/\n   QStringList validMountPoints;\n@@ -351,7 +400,7 @@ ActionReply Smb4KMountHelper::unmountAtOnce(const QVariantMap& args)\n   {\n     it.next();\n     QVariantMap entry = it.value().toMap();\n-      \n+    \n     bool mountPointOk = false;\n     KMountPoint::List mountPoints = KMountPoint::currentMountPoints(KMountPoint::BasicInfoNeeded|KMountPoint::NeedMountOptions);\n       \n@@ -399,9 +448,23 @@ ActionReply Smb4KMountHelper::unmountAtOnce(const QVariantMap& args)\n     \n   if (!validMountPoints.isEmpty())\n   {\n+    \/\/\n+    \/\/ Check the executable\n+    \/\/\n+    if (umount != args.first().toMap().value(\"mh_command\").toString()) \n+    {\n+      \/\/ Something weird is going on, bail output\n+      reply.setType(ActionReply::HelperErrorType);\n+      return reply;\n+    }\n+    else\n+    {\n+      \/\/ Do nothing\n+    }\n+    \n     \/\/ The command\n     QStringList command;\n-    command << args.first().toMap().value(\"mh_command\").toString();\n+    command << umount;\n     command << args.first().toMap().value(\"mh_options\").toStringList();\n     command << validMountPoints;\n       \ndiff --git a\/helpers\/smb4kmounthelper.h b\/helpers\/smb4kmounthelper.h\nindex f3bc573..4b735af 100644\n--- a\/helpers\/smb4kmounthelper.h\n+++ b\/helpers\/smb4kmounthelper.h\n@@ -2,7 +2,7 @@\n     The helper that mounts and unmounts shares.\n                              -------------------\n     begin                : Sa Okt 16 2010\n-    copyright            : (C) 2010-2016 by Alexander Reinholdt\n+    copyright            : (C) 2010-2017 by Alexander Reinholdt\n     email                : alexander.reinholdt@kdemail.net\n  ***************************************************************************\/\n \n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9746","CWE_ID":"20","category":"security","commit_id":"8b281f83e8516535756f92dbf90940ac44bd45e1","commit_message":"From 8b281f83e8516535756f92dbf90940ac44bd45e1 Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Thu, 23 Jan 2014 08:14:53 +0100\nSubject: Fix Savannah bug #41309.\n\n* src\/type1\/t1load.c (t1_parse_font_matrix): Properly handle result\nof `T1_ToFixedArray'.\n\n* src\/cid\/cidload.c (cid_parse_font_matrix): Synchronize with\n`t1_parse_font_matrix'.\n\n* src\/type42\/t42parse.c (t42_parse_font_matrix): Synchronize with\n`t1_parse_font_matrix'.\n(t42_parse_encoding): Synchronize with `t1_parse_encoding'.\n\n* src\/psaux\/psobjs.c (ps_parser_load_field) <T1_FIELD_TYPE_BBOX>,\n<T1_FIELD_TYPE_MMOX>: Properly handle result of `ps_tofixedarray'.\n---\n ChangeLog             | 17 +++++++++++++++++\n src\/cid\/cidload.c     | 19 ++++++++++++++-----\n src\/psaux\/psobjs.c    |  8 +++++---\n src\/type1\/t1load.c    |  4 ++--\n src\/type42\/t42parse.c | 50 ++++++++++++++++++++++++++++++++++++++------------\n 5 files changed, 76 insertions(+), 22 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 324ed18..8df8049 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,20 @@\n+2014-01-23  Werner Lemberg  <wl@gnu.org>\n+\n+\tFix Savannah bug #41309.\n+\n+\t* src\/type1\/t1load.c (t1_parse_font_matrix): Properly handle result\n+\tof `T1_ToFixedArray'.\n+\n+\t* src\/cid\/cidload.c (cid_parse_font_matrix): Synchronize with\n+\t`t1_parse_font_matrix'.\n+\n+\t* src\/type42\/t42parse.c (t42_parse_font_matrix): Synchronize with\n+\t`t1_parse_font_matrix'.\n+\t(t42_parse_encoding): Synchronize with `t1_parse_encoding'.\n+\n+\t* src\/psaux\/psobjs.c (ps_parser_load_field) <T1_FIELD_TYPE_BBOX>,\n+\t<T1_FIELD_TYPE_MMOX>: Properly handle result of `ps_tofixedarray'.\n+\n 2014-01-22  Werner Lemberg  <wl@gnu.org>\n \n \t* src\/autofit\/hbshim.c (af_get_coverage): Fix memory leaks.\ndiff --git a\/src\/cid\/cidload.c b\/src\/cid\/cidload.c\nindex 46def71..1cda0ee 100644\n--- a\/src\/cid\/cidload.c\n+++ b\/src\/cid\/cidload.c\n@@ -4,7 +4,7 @@\n \/*                                                                         *\/\n \/*    CID-keyed Type1 font loader (body).                                  *\/\n \/*                                                                         *\/\n-\/*  Copyright 1996-2006, 2009, 2011-2013 by                                *\/\n+\/*  Copyright 1996-2006, 2009, 2011-2014 by                                *\/\n \/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      *\/\n \/*                                                                         *\/\n \/*  This file is part of the FreeType project, and may only be used,       *\/\n@@ -160,16 +160,26 @@\n     {\n       FT_Matrix*  matrix;\n       FT_Vector*  offset;\n+      FT_Int      result;\n \n \n       dict   = face->cid.font_dicts + parser->num_dict;\n       matrix = &dict->font_matrix;\n       offset = &dict->font_offset;\n \n-      (void)cid_parser_to_fixed_array( parser, 6, temp, 3 );\n+      result = cid_parser_to_fixed_array( parser, 6, temp, 3 );\n+\n+      if ( result < 6 )\n+        return FT_THROW( Invalid_File_Format );\n \n       temp_scale = FT_ABS( temp[3] );\n \n+      if ( temp_scale == 0 )\n+      {\n+        FT_ERROR(( \"cid_parse_font_matrix: invalid font matrix\\n\" ));\n+        return FT_THROW( Invalid_File_Format );\n+      }\n+\n       \/* Set Units per EM based on FontMatrix values.  We set the value to *\/\n       \/* 1000 \/ temp_scale, because temp_scale was already multiplied by   *\/\n       \/* 1000 (in t1_tofixed, from psobjs.c).                              *\/\n@@ -184,7 +194,7 @@\n         temp[2] = FT_DivFix( temp[2], temp_scale );\n         temp[4] = FT_DivFix( temp[4], temp_scale );\n         temp[5] = FT_DivFix( temp[5], temp_scale );\n-        temp[3] = 0x10000L;\n+        temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;\n       }\n \n       matrix->xx = temp[0];\n@@ -197,8 +207,7 @@\n       offset->y  = temp[5] >> 16;\n     }\n \n-    return FT_Err_Ok;      \/* this is a callback function; *\/\n-                            \/* we must return an error code *\/\n+    return FT_Err_Ok;\n   }\n \n \ndiff --git a\/src\/psaux\/psobjs.c b\/src\/psaux\/psobjs.c\nindex dd976d3..b4b7d45 100644\n--- a\/src\/psaux\/psobjs.c\n+++ b\/src\/psaux\/psobjs.c\n@@ -4,7 +4,7 @@\n \/*                                                                         *\/\n \/*    Auxiliary functions for PostScript fonts (body).                     *\/\n \/*                                                                         *\/\n-\/*  Copyright 1996-2013 by                                                 *\/\n+\/*  Copyright 1996-2014 by                                                 *\/\n \/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      *\/\n \/*                                                                         *\/\n \/*  This file is part of the FreeType project, and may only be used,       *\/\n@@ -847,6 +847,8 @@\n   \/* first character must be a delimiter or a part of a number *\/\n   \/* NB: `values' can be NULL if we just want to skip the      *\/\n   \/*     array; in this case we ignore `max_values'            *\/\n+  \/*                                                           *\/\n+  \/* return number of successfully parsed values               *\/\n \n   static FT_Int\n   ps_tofixedarray( FT_Byte*  *acur,\n@@ -1200,7 +1202,7 @@\n \n           result = ps_tofixedarray( &cur, limit, 4, temp, 0 );\n \n-          if ( result < 0 )\n+          if ( result < 4 )\n           {\n             FT_ERROR(( \"ps_parser_load_field:\"\n                        \" expected four integers in bounding box\\n\" ));\n@@ -1230,7 +1232,7 @@\n           {\n             result = ps_tofixedarray( &cur, limit, max_objects,\n                                       temp + i * max_objects, 0 );\n-            if ( result < 0 )\n+            if ( result < 0 || (FT_UInt)result < max_objects )\n             {\n               FT_ERROR(( \"ps_parser_load_field:\"\n                          \" expected %d integers in the %s subarray\\n\"\ndiff --git a\/src\/type1\/t1load.c b\/src\/type1\/t1load.c\nindex 4b5026b..d4171d9 100644\n--- a\/src\/type1\/t1load.c\n+++ b\/src\/type1\/t1load.c\n@@ -4,7 +4,7 @@\n \/*                                                                         *\/\n \/*    Type 1 font loader (body).                                           *\/\n \/*                                                                         *\/\n-\/*  Copyright 1996-2013 by                                                 *\/\n+\/*  Copyright 1996-2014 by                                                 *\/\n \/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      *\/\n \/*                                                                         *\/\n \/*  This file is part of the FreeType project, and may only be used,       *\/\n@@ -1107,7 +1107,7 @@\n \n     result = T1_ToFixedArray( parser, 6, temp, 3 );\n \n-    if ( result < 0 )\n+    if ( result < 6 )\n     {\n       parser->root.error = FT_THROW( Invalid_File_Format );\n       return;\ndiff --git a\/src\/type42\/t42parse.c b\/src\/type42\/t42parse.c\nindex 3cdd8a1..9b66888 100644\n--- a\/src\/type42\/t42parse.c\n+++ b\/src\/type42\/t42parse.c\n@@ -4,7 +4,7 @@\n \/*                                                                         *\/\n \/*    Type 42 font parser (body).                                          *\/\n \/*                                                                         *\/\n-\/*  Copyright 2002-2013 by                                                 *\/\n+\/*  Copyright 2002-2014 by                                                 *\/\n \/*  Roberto Alameda.                                                       *\/\n \/*                                                                         *\/\n \/*  This file is part of the FreeType project, and may only be used,       *\/\n@@ -255,12 +255,26 @@\n     FT_Face     root   = (FT_Face)&face->root;\n     FT_Fixed    temp[6];\n     FT_Fixed    temp_scale;\n+    FT_Int      result;\n \n \n-    (void)T1_ToFixedArray( parser, 6, temp, 3 );\n+    result = T1_ToFixedArray( parser, 6, temp, 3 );\n+\n+    if ( result < 6 )\n+    {\n+      parser->root.error = FT_THROW( Invalid_File_Format );\n+      return;\n+    }\n \n     temp_scale = FT_ABS( temp[3] );\n \n+    if ( temp_scale == 0 )\n+    {\n+      FT_ERROR(( \"t1_parse_font_matrix: invalid font matrix\\n\" ));\n+      parser->root.error = FT_THROW( Invalid_File_Format );\n+      return;\n+    }\n+\n     \/* Set Units per EM based on FontMatrix values.  We set the value to *\/\n     \/* 1000 \/ temp_scale, because temp_scale was already multiplied by   *\/\n     \/* 1000 (in t1_tofixed, from psobjs.c).                              *\/\n@@ -275,7 +289,7 @@\n       temp[2] = FT_DivFix( temp[2], temp_scale );\n       temp[4] = FT_DivFix( temp[4], temp_scale );\n       temp[5] = FT_DivFix( temp[5], temp_scale );\n-      temp[3] = 0x10000L;\n+      temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;\n     }\n \n     matrix->xx = temp[0];\n@@ -314,7 +328,7 @@\n     if ( ft_isdigit( *cur ) || *cur == '[' )\n     {\n       T1_Encoding  encode          = &face->type1.encoding;\n-      FT_UInt      count, n;\n+      FT_Int       count, n;\n       PS_Table     char_table      = &loader->encoding_table;\n       FT_Memory    memory          = parser->root.memory;\n       FT_Error     error;\n@@ -329,7 +343,7 @@\n         parser->root.cursor++;\n       }\n       else\n-        count = (FT_UInt)T1_ToInt( parser );\n+        count = (FT_Int)T1_ToInt( parser );\n \n       T1_Skip_Spaces( parser );\n       if ( parser->root.cursor >= limit )\n@@ -417,7 +431,7 @@\n \n           cur = parser->root.cursor;\n \n-          if ( *cur == '\/' && cur + 2 < limit && n < count )\n+          if ( cur + 2 < limit && *cur == '\/' && n < count )\n           {\n             FT_PtrDist  len;\n \n@@ -426,6 +440,8 @@\n \n             parser->root.cursor = cur;\n             T1_Skip_PS_Token( parser );\n+            if ( parser->root.cursor >= limit )\n+              return;\n             if ( parser->root.error )\n               return;\n \n@@ -439,6 +455,19 @@\n \n             n++;\n           }\n+          else if ( only_immediates )\n+          {\n+            \/* Since the current position is not updated for           *\/\n+            \/* immediates-only mode we would get an infinite loop if   *\/\n+            \/* we don't do anything here.                              *\/\n+            \/*                                                         *\/\n+            \/* This encoding array is not valid according to the type1 *\/\n+            \/* specification (it might be an encoding for a CID type1  *\/\n+            \/* font, however), so we conclude that this font is NOT a  *\/\n+            \/* type1 font.                                             *\/\n+            parser->root.error = FT_THROW( Unknown_File_Format );\n+            return;\n+          }\n         }\n         else\n         {\n@@ -450,8 +479,8 @@\n         T1_Skip_Spaces( parser );\n       }\n \n-      face->type1.encoding_type  = T1_ENCODING_TYPE_ARRAY;\n-      parser->root.cursor        = cur;\n+      face->type1.encoding_type = T1_ENCODING_TYPE_ARRAY;\n+      parser->root.cursor       = cur;\n     }\n \n     \/* Otherwise, we should have either `StandardEncoding', *\/\n@@ -471,10 +500,7 @@\n         face->type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;\n \n       else\n-      {\n-        FT_ERROR(( \"t42_parse_encoding: invalid token\\n\" ));\n-        parser->root.error = FT_THROW( Invalid_File_Format );\n-      }\n+        parser->root.error = FT_THROW( Ignore );\n     }\n   }\n \n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-1000037","CWE_ID":"20","category":"security","commit_id":"8a3257b01faa899dd9b5e35c6bb3403cd709c371","commit_message":"From 8a3257b01faa899dd9b5e35c6bb3403cd709c371 Mon Sep 17 00:00:00 2001\nFrom: Tor Andersson <tor.andersson@artifex.com>\nDate: Wed, 24 Jan 2018 14:05:09 +0100\nSubject: [PATCH 1\/1] Fix 698886: Don't try to load non-stream XObjects.\n\n---\n source\/pdf\/pdf-interpret.c | 2 --\n source\/pdf\/pdf-xobject.c   | 3 +++\n 2 files changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/source\/pdf\/pdf-interpret.c b\/source\/pdf\/pdf-interpret.c\nindex 6ce63eb..3aeeeae 100644\n--- a\/source\/pdf\/pdf-interpret.c\n+++ b\/source\/pdf\/pdf-interpret.c\n@@ -264,8 +264,6 @@ pdf_process_extgstate(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, pdf_ob\n \t\t\tfz_var(xobj);\n \n \t\t\tgroup = pdf_dict_get(ctx, obj, PDF_NAME_G);\n-\t\t\tif (!group)\n-\t\t\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"cannot load softmask xobject (%d 0 R)\", pdf_to_num(ctx, obj));\n \t\t\txobj = pdf_load_xobject(ctx, csi->doc, group);\n \n \t\t\tfz_try(ctx)\ndiff --git a\/source\/pdf\/pdf-xobject.c b\/source\/pdf\/pdf-xobject.c\nindex c7b03a4..38a31c4 100644\n--- a\/source\/pdf\/pdf-xobject.c\n+++ b\/source\/pdf\/pdf-xobject.c\n@@ -97,6 +97,9 @@ pdf_load_xobject(fz_context *ctx, pdf_document *doc, pdf_obj *dict)\n {\n \tpdf_xobject *form;\n \n+\tif (!pdf_is_stream(ctx, dict))\n+\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"XObject must be a stream\");\n+\n \tif ((form = pdf_find_item(ctx, pdf_drop_xobject_imp, dict)) != NULL)\n \t\treturn form;\n \n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-11368","CWE_ID":"20","category":"security","commit_id":"ffb35baac6981f9e8914f8f3bffd37f284b85970","commit_message":"From ffb35baac6981f9e8914f8f3bffd37f284b85970 Mon Sep 17 00:00:00 2001\nFrom: Greg Hudson <ghudson@mit.edu>\nDate: Thu, 13 Jul 2017 12:14:20 -0400\nSubject: [PATCH] Prevent KDC unset status assertion failures\n\nAssign status values if S4U2Self padata fails to decode, if an\nS4U2Proxy request uses invalid KDC options, or if an S4U2Proxy request\nuses an evidence ticket which does not match the canonicalized request\nserver principal name.  Reported by Samuel Cabrero.\n\nIf a status value is not assigned during KDC processing, default to\n\"UNKNOWN_REASON\" rather than failing an assertion.  This change will\nprevent future denial of service bugs due to similar mistakes, and\nwill allow us to omit assigning status values for unlikely errors such\nas small memory allocation failures.\n\nCVE-2017-11368:\n\nIn MIT krb5 1.7 and later, an authenticated attacker can cause an\nassertion failure in krb5kdc by sending an invalid S4U2Self or\nS4U2Proxy request.\n\n  CVSSv3 Vector: AV:N\/AC:L\/PR:L\/UI:N\/S:U\/C:N\/I:N\/A:H\/E:H\/RL:O\/RC:C\n\nticket: 8599 (new)\ntarget_version: 1.15-next\ntarget_version: 1.14-next\ntags: pullup\n---\n src\/kdc\/do_as_req.c  |  4 ++--\n src\/kdc\/do_tgs_req.c |  3 ++-\n src\/kdc\/kdc_util.c   | 10 ++++++++--\n 3 files changed, 12 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/kdc\/do_as_req.c b\/src\/kdc\/do_as_req.c\nindex 2d3ad134d0..9b256c8764 100644\n--- a\/src\/kdc\/do_as_req.c\n+++ b\/src\/kdc\/do_as_req.c\n@@ -366,8 +366,8 @@ finish_process_as_req(struct as_req_state *state, krb5_error_code errcode)\n     did_log = 1;\n \n egress:\n-    if (errcode != 0)\n-        assert (state->status != 0);\n+    if (errcode != 0 && state->status == NULL)\n+        state->status = \"UNKNOWN_REASON\";\n \n     au_state->status = state->status;\n     au_state->reply = &state->reply;\ndiff --git a\/src\/kdc\/do_tgs_req.c b\/src\/kdc\/do_tgs_req.c\nindex cdc79ad2f1..d8d67199b9 100644\n--- a\/src\/kdc\/do_tgs_req.c\n+++ b\/src\/kdc\/do_tgs_req.c\n@@ -823,7 +823,8 @@ process_tgs_req(struct server_handle *handle, krb5_data *pkt,\n     free(reply.enc_part.ciphertext.data);\n \n cleanup:\n-    assert(status != NULL);\n+    if (status == NULL)\n+        status = \"UNKNOWN_REASON\";\n     if (reply_key)\n         krb5_free_keyblock(kdc_context, reply_key);\n     if (errcode)\ndiff --git a\/src\/kdc\/kdc_util.c b\/src\/kdc\/kdc_util.c\nindex 778a629e52..b710aefe4c 100644\n--- a\/src\/kdc\/kdc_util.c\n+++ b\/src\/kdc\/kdc_util.c\n@@ -1220,8 +1220,10 @@ kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n     req_data.data = (char *)pa_data->contents;\n \n     code = decode_krb5_pa_for_user(&req_data, &for_user);\n-    if (code)\n+    if (code) {\n+        *status = \"DECODE_PA_FOR_USER\";\n         return code;\n+    }\n \n     code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n     if (code) {\n@@ -1320,8 +1322,10 @@ kdc_process_s4u_x509_user(krb5_context context,\n     req_data.data = (char *)pa_data->contents;\n \n     code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n-    if (code)\n+    if (code) {\n+        *status = \"DECODE_PA_S4U_X509_USER\";\n         return code;\n+    }\n \n     code = verify_s4u_x509_user_checksum(context,\n                                          tgs_subkey ? tgs_subkey :\n@@ -1624,6 +1628,7 @@ kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n      * that is validated previously in validate_tgs_request().\n      *\/\n     if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {\n+        *status = \"INVALID_S4U2PROXY_OPTIONS\";\n         return KRB5KDC_ERR_BADOPTION;\n     }\n \n@@ -1631,6 +1636,7 @@ kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n     if (!krb5_principal_compare(kdc_context,\n                                 server->princ, \/* after canon *\/\n                                 server_princ)) {\n+        *status = \"EVIDENCE_TICKET_MISMATCH\";\n         return KRB5KDC_ERR_SERVER_NOMATCH;\n     }\n \n","owner":"krb5","repo":"krb5","source":"cve"},{"CVE_ID":"CVE-2010-3849","CWE_ID":"20","category":"security","commit_id":"fa0e846494792e722d817b9d3d625a4ef4896c96","commit_message":"From fa0e846494792e722d817b9d3d625a4ef4896c96 Mon Sep 17 00:00:00 2001\nFrom: Phil Blundell <philb@gnu.org>\nDate: Wed, 24 Nov 2010 11:49:19 -0800\nSubject: econet: disallow NULL remote addr for sendmsg(), fixes CVE-2010-3849\n\nLater parts of econet_sendmsg() rely on saddr != NULL, so return early\nwith EINVAL if NULL was passed otherwise an oops may occur.\n\nSigned-off-by: Phil Blundell <philb@gnu.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/econet\/af_econet.c | 26 ++++++++------------------\n 1 file changed, 8 insertions(+), 18 deletions(-)\n\n","diff_code":"diff --git a\/net\/econet\/af_econet.c b\/net\/econet\/af_econet.c\nindex f8c1ae4b41f0..e366f1bef91f 100644\n--- a\/net\/econet\/af_econet.c\n+++ b\/net\/econet\/af_econet.c\n@@ -297,23 +297,14 @@ static int econet_sendmsg(struct kiocb *iocb, struct socket *sock,\n \n \tmutex_lock(&econet_mutex);\n \n-\tif (saddr == NULL) {\n-\t\tstruct econet_sock *eo = ec_sk(sk);\n-\n-\t\taddr.station = eo->station;\n-\t\taddr.net     = eo->net;\n-\t\tport\t     = eo->port;\n-\t\tcb\t     = eo->cb;\n-\t} else {\n-\t\tif (msg->msg_namelen < sizeof(struct sockaddr_ec)) {\n-\t\t\tmutex_unlock(&econet_mutex);\n-\t\t\treturn -EINVAL;\n-\t\t}\n-\t\taddr.station = saddr->addr.station;\n-\t\taddr.net = saddr->addr.net;\n-\t\tport = saddr->port;\n-\t\tcb = saddr->cb;\n-\t}\n+        if (saddr == NULL || msg->msg_namelen < sizeof(struct sockaddr_ec)) {\n+                mutex_unlock(&econet_mutex);\n+                return -EINVAL;\n+        }\n+        addr.station = saddr->addr.station;\n+        addr.net = saddr->addr.net;\n+        port = saddr->port;\n+        cb = saddr->cb;\n \n \t\/* Look for a device with the right network number. *\/\n \tdev = net2dev_map[addr.net];\n@@ -351,7 +342,6 @@ static int econet_sendmsg(struct kiocb *iocb, struct socket *sock,\n \n \t\teb = (struct ec_cb *)&skb->cb;\n \n-\t\t\/* BUG: saddr may be NULL *\/\n \t\teb->cookie = saddr->cookie;\n \t\teb->sec = *saddr;\n \t\teb->sent = ec_tx_done;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-16644","CWE_ID":"20","category":"security","commit_id":"afa878a689870c28b6994ecf3bb8dbfb2b76d135","commit_message":"From afa878a689870c28b6994ecf3bb8dbfb2b76d135 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Mon, 27 Aug 2018 19:35:15 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1269\n\n---\n coders\/pict.c | 27 +++++++++++++++++++++++++++\n 1 file changed, 27 insertions(+)\n\n","diff_code":"diff --git a\/coders\/pict.c b\/coders\/pict.c\nindex 35dadfeee0..3600c12152 100644\n--- a\/coders\/pict.c\n+++ b\/coders\/pict.c\n@@ -982,6 +982,9 @@ static Image *ReadPICTImage(const ImageInfo *image_info,\n               Clipping rectangle.\n             *\/\n             length=ReadBlobMSBShort(image);\n+            if (length > GetBlobSize(image))\n+              ThrowPICTException(CorruptImageError,\n+                \"InsufficientImageDataInFile\");\n             if (length != 0x000a)\n               {\n                 for (i=0; i < (ssize_t) (length-2); i++)\n@@ -1030,6 +1033,9 @@ static Image *ReadPICTImage(const ImageInfo *image_info,\n             if (pattern != 1)\n               ThrowPICTException(CorruptImageError,\"UnknownPatternType\");\n             length=ReadBlobMSBShort(image);\n+            if (length > GetBlobSize(image))\n+              ThrowPICTException(CorruptImageError,\n+                \"InsufficientImageDataInFile\");\n             if (ReadRectangle(image,&frame) == MagickFalse)\n               ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n             if (ReadPixmap(image,&pixmap) == MagickFalse)\n@@ -1041,6 +1047,9 @@ static Image *ReadPICTImage(const ImageInfo *image_info,\n             (void) ReadBlobMSBLong(image);\n             flags=(ssize_t) ReadBlobMSBShort(image);\n             length=ReadBlobMSBShort(image);\n+            if (length > GetBlobSize(image))\n+              ThrowPICTException(CorruptImageError,\n+                \"InsufficientImageDataInFile\");\n             for (i=0; i <= (ssize_t) length; i++)\n               (void) ReadBlobMSBLong(image);\n             width=(size_t) (frame.bottom-frame.top);\n@@ -1101,6 +1110,9 @@ static Image *ReadPICTImage(const ImageInfo *image_info,\n               Skip polygon or region.\n             *\/\n             length=ReadBlobMSBShort(image);\n+            if (length > GetBlobSize(image))\n+              ThrowPICTException(CorruptImageError,\n+                \"InsufficientImageDataInFile\");\n             for (i=0; i < (ssize_t) (length-2); i++)\n               if (ReadBlobByte(image) == EOF)\n                 break;\n@@ -1223,6 +1235,9 @@ static Image *ReadPICTImage(const ImageInfo *image_info,\n                   Skip region.\n                 *\/\n                 length=ReadBlobMSBShort(image);\n+                if (length > GetBlobSize(image))\n+                  ThrowPICTException(CorruptImageError,\n+                    \"InsufficientImageDataInFile\");\n                 for (i=0; i < (ssize_t) (length-2); i++)\n                   if (ReadBlobByte(image) == EOF)\n                     break;\n@@ -1345,6 +1360,9 @@ static Image *ReadPICTImage(const ImageInfo *image_info,\n             *\/\n             type=ReadBlobMSBShort(image);\n             length=ReadBlobMSBShort(image);\n+            if (length > GetBlobSize(image))\n+              ThrowPICTException(CorruptImageError,\n+                \"InsufficientImageDataInFile\");\n             if (length == 0)\n               break;\n             (void) ReadBlobMSBLong(image);\n@@ -1454,6 +1472,9 @@ static Image *ReadPICTImage(const ImageInfo *image_info,\n             ThrowPICTException(FileOpenError,\"UnableToCreateTemporaryFile\");\n           }\n         length=ReadBlobMSBLong(image);\n+        if (length > GetBlobSize(image))\n+          ThrowPICTException(CorruptImageError,\n+            \"InsufficientImageDataInFile\");\n         if (length > 154)\n           {\n             for (i=0; i < 6; i++)\n@@ -1505,6 +1526,9 @@ static Image *ReadPICTImage(const ImageInfo *image_info,\n           Skip reserved.\n         *\/\n         length=ReadBlobMSBShort(image);\n+        if (length > GetBlobSize(image))\n+          ThrowPICTException(CorruptImageError,\n+            \"InsufficientImageDataInFile\");\n         for (i=0; i < (ssize_t) length; i++)\n           if (ReadBlobByte(image) == EOF)\n             break;\n@@ -1516,6 +1540,9 @@ static Image *ReadPICTImage(const ImageInfo *image_info,\n           Skip reserved.\n         *\/\n         length=(size_t) ((code >> 7) & 0xff);\n+        if (length > GetBlobSize(image))\n+          ThrowPICTException(CorruptImageError,\n+            \"InsufficientImageDataInFile\");\n         for (i=0; i < (ssize_t) length; i++)\n           if (ReadBlobByte(image) == EOF)\n             break;\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2015-7509","CWE_ID":"20","category":"security","commit_id":"c9b92530a723ac5ef8e352885a1862b18f31b2f5","commit_message":"From c9b92530a723ac5ef8e352885a1862b18f31b2f5 Mon Sep 17 00:00:00 2001\nFrom: Anatol Pomozov <anatol.pomozov@gmail.com>\nDate: Tue, 18 Sep 2012 13:38:59 -0400\nSubject: ext4: make orphan functions be no-op in no-journal mode\n\nInstead of checking whether the handle is valid, we check if journal\nis enabled. This avoids taking the s_orphan_lock mutex in all cases\nwhen there is no journal in use, including the error paths where\next4_orphan_del() is called with a handle set to NULL.\n\nSigned-off-by: Anatol Pomozov <anatol.pomozov@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\n---\n fs\/ext4\/namei.c | 7 +++----\n 1 file changed, 3 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/namei.c b\/fs\/ext4\/namei.c\nindex 37c03b32e194..8f4bda75122e 100644\n--- a\/fs\/ext4\/namei.c\n+++ b\/fs\/ext4\/namei.c\n@@ -2369,7 +2369,7 @@ int ext4_orphan_add(handle_t *handle, struct inode *inode)\n \tstruct ext4_iloc iloc;\n \tint err = 0, rc;\n \n-\tif (!ext4_handle_valid(handle))\n+\tif (!EXT4_SB(sb)->s_journal)\n \t\treturn 0;\n \n \tmutex_lock(&EXT4_SB(sb)->s_orphan_lock);\n@@ -2443,8 +2443,7 @@ int ext4_orphan_del(handle_t *handle, struct inode *inode)\n \tstruct ext4_iloc iloc;\n \tint err = 0;\n \n-\t\/* ext4_handle_valid() assumes a valid handle_t pointer *\/\n-\tif (handle && !ext4_handle_valid(handle))\n+\tif (!EXT4_SB(inode->i_sb)->s_journal)\n \t\treturn 0;\n \n \tmutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);\n@@ -2463,7 +2462,7 @@ int ext4_orphan_del(handle_t *handle, struct inode *inode)\n \t * transaction handle with which to update the orphan list on\n \t * disk, but we still need to remove the inode from the linked\n \t * list in memory. *\/\n-\tif (sbi->s_journal && !handle)\n+\tif (!handle)\n \t\tgoto out;\n \n \terr = ext4_reserve_inode_write(handle, inode, &iloc);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-0746","CWE_ID":"20","category":"security","commit_id":"e6b8bc09ba2075cd91fbffefcd2778b1a00bd76f","commit_message":"From e6b8bc09ba2075cd91fbffefcd2778b1a00bd76f Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Fri, 16 Jan 2009 11:13:40 -0500\nSubject: ext4: Add sanity check to make_indexed_dir\n\nMake sure the rec_len field in the '..' entry is sane, lest we overrun\nthe directory block and cause a kernel oops on a purposefully\ncorrupted filesystem.\n\nThanks to Sami Liedes for reporting this bug.\n\nhttp:\/\/bugzilla.kernel.org\/show_bug.cgi?id=12430\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org\n---\n fs\/ext4\/namei.c | 21 +++++++++++++++------\n 1 file changed, 15 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/namei.c b\/fs\/ext4\/namei.c\nindex fec0b4c2f5f1..ba702bd7910d 100644\n--- a\/fs\/ext4\/namei.c\n+++ b\/fs\/ext4\/namei.c\n@@ -1368,7 +1368,7 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n \tstruct fake_dirent *fde;\n \n \tblocksize =  dir->i_sb->s_blocksize;\n-\tdxtrace(printk(KERN_DEBUG \"Creating index\\n\"));\n+\tdxtrace(printk(KERN_DEBUG \"Creating index: inode %lu\\n\", dir->i_ino));\n \tretval = ext4_journal_get_write_access(handle, bh);\n \tif (retval) {\n \t\text4_std_error(dir->i_sb, retval);\n@@ -1377,6 +1377,20 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n \t}\n \troot = (struct dx_root *) bh->b_data;\n \n+\t\/* The 0th block becomes the root, move the dirents out *\/\n+\tfde = &root->dotdot;\n+\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n+\t\text4_rec_len_from_disk(fde->rec_len));\n+\tif ((char *) de >= (((char *) root) + blocksize)) {\n+\t\text4_error(dir->i_sb, __func__,\n+\t\t\t   \"invalid rec_len for '..' in inode %lu\",\n+\t\t\t   dir->i_ino);\n+\t\tbrelse(bh);\n+\t\treturn -EIO;\n+\t}\n+\tlen = ((char *) root) + blocksize - (char *) de;\n+\n+\t\/* Allocate new block for the 0th block's dirents *\/\n \tbh2 = ext4_append(handle, dir, &block, &retval);\n \tif (!(bh2)) {\n \t\tbrelse(bh);\n@@ -1385,11 +1399,6 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,\n \tEXT4_I(dir)->i_flags |= EXT4_INDEX_FL;\n \tdata1 = bh2->b_data;\n \n-\t\/* The 0th block becomes the root, move the dirents out *\/\n-\tfde = &root->dotdot;\n-\tde = (struct ext4_dir_entry_2 *)((char *)fde +\n-\t\text4_rec_len_from_disk(fde->rec_len));\n-\tlen = ((char *) root) + blocksize - (char *) de;\n \tmemcpy (data1, de, len);\n \tde = (struct ext4_dir_entry_2 *) data1;\n \ttop = data1 + len;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-0745","CWE_ID":"20","category":"security","commit_id":"fdff73f094e7220602cc3f8959c7230517976412","commit_message":"From fdff73f094e7220602cc3f8959c7230517976412 Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Mon, 26 Jan 2009 19:06:41 -0500\nSubject: ext4: Initialize the new group descriptor when resizing the\n filesystem\n\nMake sure all of the fields of the group descriptor are properly\ninitialized.  Previously, we allowed bg_flags field to be contain\nrandom garbage, which could trigger non-deterministic behavior,\nincluding a kernel OOPS.\n\nhttp:\/\/bugzilla.kernel.org\/show_bug.cgi?id=12433\n\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org\n---\n fs\/ext4\/resize.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/resize.c b\/fs\/ext4\/resize.c\nindex c328be5d6885..c06886abd658 100644\n--- a\/fs\/ext4\/resize.c\n+++ b\/fs\/ext4\/resize.c\n@@ -861,12 +861,13 @@ int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n \tgdp = (struct ext4_group_desc *)((char *)primary->b_data +\n \t\t\t\t\t gdb_off * EXT4_DESC_SIZE(sb));\n \n+\tmemset(gdp, 0, EXT4_DESC_SIZE(sb));\n \text4_block_bitmap_set(sb, gdp, input->block_bitmap); \/* LV FIXME *\/\n \text4_inode_bitmap_set(sb, gdp, input->inode_bitmap); \/* LV FIXME *\/\n \text4_inode_table_set(sb, gdp, input->inode_table); \/* LV FIXME *\/\n \text4_free_blks_set(sb, gdp, input->free_blocks_count);\n \text4_free_inodes_set(sb, gdp, EXT4_INODES_PER_GROUP(sb));\n-\tgdp->bg_flags |= cpu_to_le16(EXT4_BG_INODE_ZEROED);\n+\tgdp->bg_flags = cpu_to_le16(EXT4_BG_INODE_ZEROED);\n \tgdp->bg_checksum = ext4_group_desc_csum(sbi, input->group, gdp);\n \n \t\/*\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-8933","CWE_ID":"20","category":"security","commit_id":"56f66684592abf257c4004e6e1fff041c64a12ce","commit_message":"From 56f66684592abf257c4004e6e1fff041c64a12ce Mon Sep 17 00:00:00 2001\nFrom: Andriy Grytsenko <andrej@rep.kiev.ua>\nDate: Sun, 14 May 2017 21:28:00 +0300\nSubject: [PATCH] Fix potential access violation, use runtime user dir instead\n of tmp dir.\n\nNote: it limits libmenu-cache compatibility to menu-cached >= 0.7.0.\n---\n NEWS                            | 3 +++\n libmenu-cache\/menu-cache.c      | 7 ++++++-\n menu-cache-daemon\/menu-cached.c | 3 +++\n 3 files changed, 12 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex f7f12e6..6177e9d 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -3,6 +3,9 @@\n * Added new API menu_cache_app_get_generic_name() to get generic\n     name for application.\n \n+* Fixed potential access violation, use runtime user dir instead of tmp dir.\n+    It limits libmenu-cache compatibility to menu-cached >= 0.7.0.\n+\n \n Changes in 1.0.2 since 1.0.1:\n \ndiff --git a\/libmenu-cache\/menu-cache.c b\/libmenu-cache\/menu-cache.c\nindex 9e3e0db..d914127 100644\n--- a\/libmenu-cache\/menu-cache.c\n+++ b\/libmenu-cache\/menu-cache.c\n@@ -3,7 +3,7 @@\n  *\n  *      Copyright 2008 PCMan <pcman.tw@gmail.com>\n  *      Copyright 2009 J\u00c3\u00bcrgen H\u00c3\u00b6tzel <juergen@archlinux.org>\n- *      Copyright 2012-2015 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>\n+ *      Copyright 2012-2017 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>\n  *\n  *      This library is free software; you can redistribute it and\/or\n  *      modify it under the terms of the GNU Lesser General Public\n@@ -1538,8 +1538,13 @@ static void get_socket_name( char* buf, int len )\n         if(*p)\n             *p = '\\0';\n     }\n+#if GLIB_CHECK_VERSION(2, 28, 0)\n+    g_snprintf( buf, len, \"%s\/menu-cached-%s\", g_get_user_runtime_dir(),\n+                dpy ? dpy : \":0\" );\n+#else\n     g_snprintf( buf, len, \"%s\/.menu-cached-%s-%s\", g_get_tmp_dir(),\n                 dpy ? dpy : \":0\", g_get_user_name() );\n+#endif\n     g_free(dpy);\n }\n \ndiff --git a\/menu-cache-daemon\/menu-cached.c b\/menu-cache-daemon\/menu-cached.c\nindex a6895ee..c100484 100644\n--- a\/menu-cache-daemon\/menu-cached.c\n+++ b\/menu-cache-daemon\/menu-cached.c\n@@ -473,6 +473,9 @@ static void get_socket_name( char* buf, int len )\n         if(*p)\n             *p = '\\0';\n     }\n+    \/* NOTE: this socket name is incompatible with versions > 1.0.2,\n+            although this function is never used since 0.7.0 but\n+            libmenu-cache always requests exact socket name instead *\/\n     g_snprintf( buf, len, \"%s\/.menu-cached-%s-%s\", g_get_tmp_dir(),\n                 dpy ? dpy : \":0\", g_get_user_name() );\n     g_free(dpy);\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8323","CWE_ID":"20","category":"security","commit_id":"da087238963c1239fdabd47dc1b65279605aca70","commit_message":"From da087238963c1239fdabd47dc1b65279605aca70 Mon Sep 17 00:00:00 2001\nFrom: Thomas d'Otreppe <tdotreppe@aircrack-ng.org>\nDate: Fri, 3 Oct 2014 01:58:02 +0000\nSubject: [PATCH] Buddy-ng: Fixed segmentation fault (Closes #15 on GitHub).\n\ngit-svn-id: http:\/\/svn.aircrack-ng.org\/trunk@2418 28c6078b-6c39-48e3-add9-af49d547ecab\n---\n src\/buddy-ng.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/src\/buddy-ng.c b\/src\/buddy-ng.c\nindex 8a7927c7..8da8996d 100644\n--- a\/src\/buddy-ng.c\n+++ b\/src\/buddy-ng.c\n@@ -83,6 +83,8 @@ int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n \t*cmd++ = htons(S_CMD_PACKET);\n \t*cmd++ = *pid;\n \tplen = len - 2;\n+    if (plen < 0)\n+        return 0;\n \n \tlast_id = ntohs(*pid);\n \tif (last_id > 20000)\n","owner":"aircrack-ng","repo":"aircrack-ng","source":"cve"},{"CVE_ID":"CVE-2009-1185","CWE_ID":"20","category":"security","commit_id":"e86a923d508c2aed371cdd958ce82489cf2ab615","commit_message":"From e86a923d508c2aed371cdd958ce82489cf2ab615 Mon Sep 17 00:00:00 2001\nFrom: Scott James Remnant <scott@ubuntu.com>\nDate: Wed, 8 Apr 2009 16:16:14 -0700\nSubject: libudev: monitor - ignore messages from unusual sources\n\nFor added protection, ignore any unicast message received on the\nnetlink socket or any multicast message on the kernel group not\nreceived from the kernel.\n\nSigned-off-by: Scott James Remnant <scott@ubuntu.com>\n---\n udev\/lib\/libudev-monitor.c | 29 +++++++++++++++++++++++------\n 1 file changed, 23 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/udev\/lib\/libudev-monitor.c b\/udev\/lib\/libudev-monitor.c\nindex 21bd19ba..79627ed4 100644\n--- a\/udev\/lib\/libudev-monitor.c\n+++ b\/udev\/lib\/libudev-monitor.c\n@@ -260,6 +260,7 @@ struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monito\n \tstruct iovec iov;\n \tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n \tstruct cmsghdr *cmsg;\n+\tstruct sockaddr_nl snl;\n \tstruct ucred *cred;\n \tchar buf[4096];\n \tsize_t bufpos;\n@@ -280,34 +281,50 @@ struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monito\n \tsmsg.msg_control = cred_msg;\n \tsmsg.msg_controllen = sizeof(cred_msg);\n \n+\tif (udev_monitor->snl.nl_family != 0) {\n+\t\tsmsg.msg_name = &snl;\n+\t\tsmsg.msg_namelen = sizeof snl;\n+\t}\n+\n \tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n \t\tif (errno != EINTR)\n-\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n+\t\t\tinfo(udev_monitor->udev, \"unable to receive message\\n\");\n \t\treturn NULL;\n \t}\n \n+\tif (udev_monitor->snl.nl_family != 0) {\n+\t\tif (snl.nl_groups == 0) {\n+\t\t\tinfo(udev_monitor->udev, \"unicast netlink message ignored\\n\");\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif ((snl.nl_groups == UDEV_MONITOR_KERNEL) && (snl.nl_pid > 0)) {\n+\t\t\tinfo(udev_monitor->udev, \"multicast kernel netlink message from pid %d ignored\\n\", snl.nl_pid);\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n \tcmsg = CMSG_FIRSTHDR(&smsg);\n \tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n-\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n+\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\\n\");\n \t\treturn NULL;\n \t}\n \n \tcred = (struct ucred *)CMSG_DATA(cmsg);\n \tif (cred->uid != 0) {\n-\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n+\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\\n\", cred->uid);\n \t\treturn NULL;\n \t}\n \n \t\/* skip header *\/\n \tbufpos = strlen(buf) + 1;\n \tif (bufpos < sizeof(\"a@\/d\") || bufpos >= sizeof(buf)) {\n-\t\tinfo(udev_monitor->udev, \"invalid message length\");\n+\t\tinfo(udev_monitor->udev, \"invalid message length\\n\");\n \t\treturn NULL;\n \t}\n \n \t\/* check message header *\/\n \tif (strstr(buf, \"@\/\") == NULL) {\n-\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n+\t\tinfo(udev_monitor->udev, \"unrecognized message header\\n\");\n \t\treturn NULL;\n \t}\n \n@@ -414,6 +431,6 @@ int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_devi\n \telse\n \t\treturn -1;\n \n-\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n+\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p\\n\", count, udev_monitor);\n \treturn count;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-12458","CWE_ID":"20","category":"security","commit_id":"e1182fac1afba92a4975917823a5f644bee7e6e8","commit_message":"From e1182fac1afba92a4975917823a5f644bee7e6e8 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Mon, 21 May 2018 23:08:05 +0200\nSubject: [PATCH] avcodec\/mpeg4videoenc: Use 64 bit for times in\n mpeg4_encode_gop_header()\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nFixes truncation\nFixes Assertion n <= 31 && value < (1U << n) failed at libavcodec\/put_bits.h:169\nFixes: ffmpeg_crash_2.avi\n\nFound-by: Thuan Pham <thuanpv@comp.nus.edu.sg>, Marcel B\u00f6hme, Andrew Santosa and Alexandru RazvanCaciulescu with AFLSmart\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/mpeg4videoenc.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/mpeg4videoenc.c b\/libavcodec\/mpeg4videoenc.c\nindex 494452c9383..f6a5992df77 100644\n--- a\/libavcodec\/mpeg4videoenc.c\n+++ b\/libavcodec\/mpeg4videoenc.c\n@@ -882,7 +882,7 @@ void ff_set_mpeg4_time(MpegEncContext *s)\n \n static void mpeg4_encode_gop_header(MpegEncContext *s)\n {\n-    int hours, minutes, seconds;\n+    int64_t hours, minutes, seconds;\n     int64_t time;\n \n     put_bits(&s->pb, 16, 0);\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2013-4270","CWE_ID":"20","category":"security","commit_id":"2433c8f094a008895e66f25bd1773cdb01c91d01","commit_message":"From 2433c8f094a008895e66f25bd1773cdb01c91d01 Mon Sep 17 00:00:00 2001\nFrom: \"Eric W. Biederman\" <ebiederm@xmission.com>\nDate: Sat, 5 Oct 2013 13:15:30 -0700\nSubject: [PATCH] net: Update the sysctl permissions handler to test effective\n uid\/gid\n\nModify the code to use current_euid(), and in_egroup_p, as in done\nin fs\/proc\/proc_sysctl.c:test_perm()\n\nCc: stable@vger.kernel.org\nReviewed-by: Eric Sandeen <sandeen@redhat.com>\nReported-by: Eric Sandeen <sandeen@redhat.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n net\/sysctl_net.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/sysctl_net.c b\/net\/sysctl_net.c\nindex 9bc6db04be3ea..e7000be321b01 100644\n--- a\/net\/sysctl_net.c\n+++ b\/net\/sysctl_net.c\n@@ -47,12 +47,12 @@ static int net_ctl_permissions(struct ctl_table_header *head,\n \n \t\/* Allow network administrator to have same access as root. *\/\n \tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n-\t    uid_eq(root_uid, current_uid())) {\n+\t    uid_eq(root_uid, current_euid())) {\n \t\tint mode = (table->mode >> 6) & 7;\n \t\treturn (mode << 6) | (mode << 3) | mode;\n \t}\n \t\/* Allow netns root group to have the same access as the root group *\/\n-\tif (gid_eq(root_gid, current_gid())) {\n+\tif (in_egroup_p(root_gid)) {\n \t\tint mode = (table->mode >> 3) & 7;\n \t\treturn (mode << 3) | mode;\n \t}\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-7519","CWE_ID":"20","category":"security","commit_id":"ddb8ecc4ebf260e4967f57f271d4f5761abeac3e","commit_message":"From ddb8ecc4ebf260e4967f57f271d4f5761abeac3e Mon Sep 17 00:00:00 2001\nFrom: \"Hongli Lai (Phusion)\" <hongli@phusion.nl>\nDate: Mon, 7 Dec 2015 12:17:49 +0100\nSubject: [PATCH] Fix CVE-2015-7519 header collision vulnerability\n\n---\n CHANGELOG                                 |  1 +\n src\/agent\/Core\/Controller\/SendRequest.cpp | 45 ++++++++++++++++++++---\n 2 files changed, 40 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/CHANGELOG b\/CHANGELOG\nindex 494203acb8..79360788f4 100644\n--- a\/CHANGELOG\n+++ b\/CHANGELOG\n@@ -1,6 +1,7 @@\n Release 5.0.22\n --------------\n \n+ * Fixes a header collision vulnerability (CVE-2015-7519, medium severity). Please see our blog for detailed vulnerability description and advisory. Thanks to the SUSE security team for reporting this issue.\n  * [Apache] Fixes compatibility with Apache 2.4.17's mod_autoindex. Fix contributed by Eric Covener. Closes GH-1642.\n  * [Standalone] Passenger Standalone now [accepts configuration options from environment variables](https:\/\/www.phusionpassenger.com\/library\/config\/standalone\/intro.html). This makes using Passenger Standalone significantly easier on Heroku or on systems that follow the 12-factor principle. Closes GH-1661.\n  * [Standalone] The Nginx configuration template has been cleaned up. It is now significantly easier to edit the Nginx configuration template without breaking compatibility with future versions.\ndiff --git a\/src\/agent\/Core\/Controller\/SendRequest.cpp b\/src\/agent\/Core\/Controller\/SendRequest.cpp\nindex 64d3d9e9de..6da59c2865 100644\n--- a\/src\/agent\/Core\/Controller\/SendRequest.cpp\n+++ b\/src\/agent\/Core\/Controller\/SendRequest.cpp\n@@ -204,6 +204,33 @@ Controller::sendBodyToAppWhenAppSinkIdle(Channel *_channel, unsigned int size) {\n \t}\n }\n \n+static bool\n+isAlphaNum(char ch) {\n+\treturn (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n+}\n+\n+\/**\n+ * For CGI, alphanum headers with optional dashes are mapped to UPP3R_CAS3. This\n+ * function can be used to reject non-alphanum\/dash headers that would end up with\n+ * the same mapping (e.g. upp3r_cas3 and upp3r-cas3 would end up the same, and\n+ * potentially collide each other in the receiving application). This is\n+ * used to fix CVE-2015-7519.\n+ *\/\n+static bool\n+containsNonAlphaNumDash(const LString &s) {\n+\tconst LString::Part *part = s.start;\n+\twhile (part != NULL) {\n+\t\tfor (unsigned int i = 0; i < part->size; i++) {\n+\t\t\tconst char start = part->data[i];\n+\t\t\tif (start != '-' && !isAlphaNum(start)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\tpart = part->next;\n+\t}\n+\treturn false;\n+}\n+\n static void\n httpHeaderToScgiUpperCase(unsigned char *data, unsigned int size) {\n \tstatic const boost::uint8_t toUpperMap[256] = {\n@@ -529,12 +556,18 @@ Controller::constructHeaderForSessionProtocol(Request *req, char * restrict buff\n \n \tServerKit::HeaderTable::Iterator it(req->headers);\n \twhile (*it != NULL) {\n-\t\tif ((it->header->hash == HTTP_CONTENT_LENGTH.hash()\n-\t\t\t|| it->header->hash == HTTP_CONTENT_TYPE.hash()\n-\t\t\t|| it->header->hash == HTTP_CONNECTION.hash())\n-\t\t && (psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-type\"))\n-\t\t\t|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-length\"))\n-\t\t\t|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"connection\"))))\n+\t\t\/\/ This header-skipping is not accounted for in determineHeaderSizeForSessionProtocol(), but\n+\t\t\/\/ since we are only reducing the size it just wastes some mem bytes.\n+\t\tif ((\n+\t\t\t\t(it->header->hash == HTTP_CONTENT_LENGTH.hash()\n+\t\t\t\t\t\t|| it->header->hash == HTTP_CONTENT_TYPE.hash()\n+\t\t\t\t\t\t|| it->header->hash == HTTP_CONNECTION.hash()\n+\t\t\t\t) && (psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-type\"))\n+\t\t\t\t\t\t|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"content-length\"))\n+\t\t\t\t\t\t|| psg_lstr_cmp(&it->header->key, P_STATIC_STRING(\"connection\"))\n+\t\t\t\t)\n+\t\t\t) || containsNonAlphaNumDash(it->header->key)\n+\t\t   )\n \t\t{\n \t\t\tit.next();\n \t\t\tcontinue;\n","owner":"phusion","repo":"passenger","source":"cve"},{"CVE_ID":"CVE-2010-4819","CWE_ID":"20","category":"security","commit_id":"5725849a1b427cd4a72b84e57f211edb35838718","commit_message":"From 5725849a1b427cd4a72b84e57f211edb35838718 Mon Sep 17 00:00:00 2001\nFrom: Adam Jackson <ajax@redhat.com>\nDate: Mon, 28 Jun 2010 18:08:50 -0400\nSubject: render: Bounds check for nglyphs in ProcRenderAddGlyphs (#28801)\n\nSigned-off-by: Adam Jackson <ajax@redhat.com>\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Keith Packard <keithp@keithp.com>\n---\n render\/render.c | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\n(limited to 'render\/render.c')\n\n","diff_code":"diff --git a\/render\/render.c b\/render\/render.c\nindex ef233e4..00241f9 100644\n--- a\/render\/render.c\n+++ b\/render\/render.c\n@@ -1077,6 +1077,14 @@ ProcRenderAddGlyphs (ClientPtr client)\n     gi = (xGlyphInfo *) (gids + nglyphs);\n     bits = (CARD8 *) (gi + nglyphs);\n     remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;\n+\n+    \/* protect against bad nglyphs *\/\n+    if (gi < stuff || gi > ((CARD32 *)stuff + client->req_len) ||\n+        bits < stuff || bits > ((CARD32 *)stuff + client->req_len)) {\n+        err = BadLength;\n+        goto bail;\n+    }\n+\n     for (i = 0; i < nglyphs; i++)\n     {\n \tsize_t padded_width;\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-1763","CWE_ID":"20","category":"security","commit_id":"6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0","commit_message":"From 6e601a53566d84e1ffd25e7b6fe0b6894ffd79c0 Mon Sep 17 00:00:00 2001\nFrom: Mathias Krause <minipli@googlemail.com>\nDate: Sat, 23 Feb 2013 01:13:47 +0000\nSubject: [PATCH] sock_diag: Fix out-of-bounds access to sock_diag_handlers[]\n\nUserland can send a netlink message requesting SOCK_DIAG_BY_FAMILY\nwith a family greater or equal then AF_MAX -- the array size of\nsock_diag_handlers[]. The current code does not test for this\ncondition therefore is vulnerable to an out-of-bound access opening\ndoors for a privilege escalation.\n\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nAcked-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/sock_diag.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/net\/core\/sock_diag.c b\/net\/core\/sock_diag.c\nindex 602cd637182eb..750f44f3aa311 100644\n--- a\/net\/core\/sock_diag.c\n+++ b\/net\/core\/sock_diag.c\n@@ -121,6 +121,9 @@ static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n \tif (nlmsg_len(nlh) < sizeof(*req))\n \t\treturn -EINVAL;\n \n+\tif (req->sdiag_family >= AF_MAX)\n+\t\treturn -EINVAL;\n+\n \thndl = sock_diag_lock_handler(req->sdiag_family);\n \tif (hndl == NULL)\n \t\terr = -ENOENT;\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8900","CWE_ID":"20","category":"security","commit_id":"97aa7d7cfd2027f6ba7ce42caf8b798541b9cdc6","commit_message":"From 97aa7d7cfd2027f6ba7ce42caf8b798541b9cdc6 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Sun, 25 Jan 2015 07:27:09 +0000\nSubject: [PATCH] Fixed infinite loop and added checks for the sscanf result.\n\n---\n coders\/hdr.c | 36 ++++++++++++++++++++----------------\n 1 file changed, 20 insertions(+), 16 deletions(-)\n\n","diff_code":"diff --git a\/coders\/hdr.c b\/coders\/hdr.c\nindex ccea763916..cd07f22e7f 100644\n--- a\/coders\/hdr.c\n+++ b\/coders\/hdr.c\n@@ -274,7 +274,7 @@ static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n           if (value_expected == MagickFalse)\n             continue;\n           p=value;\n-          while ((c != '\\n') && (c != '\\0'))\n+          while ((c != '\\n') && (c != '\\0') && (c != EOF))\n           {\n             if ((size_t) (p-value) < (MaxTextExtent-1))\n               *p++=c;\n@@ -319,18 +319,20 @@ static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n                     chromaticity[6],\n                     white_point[2];\n \n-                  (void) sscanf(value,\"%g %g %g %g %g %g %g %g\",\n-                    &chromaticity[0],&chromaticity[1],&chromaticity[2],\n-                    &chromaticity[3],&chromaticity[4],&chromaticity[5],\n-                    &white_point[0],&white_point[1]);\n-                  image->chromaticity.red_primary.x=chromaticity[0];\n-                  image->chromaticity.red_primary.y=chromaticity[1];\n-                  image->chromaticity.green_primary.x=chromaticity[2];\n-                  image->chromaticity.green_primary.y=chromaticity[3];\n-                  image->chromaticity.blue_primary.x=chromaticity[4];\n-                  image->chromaticity.blue_primary.y=chromaticity[5];\n-                  image->chromaticity.white_point.x=white_point[0],\n-                  image->chromaticity.white_point.y=white_point[1];\n+                  if (sscanf(value,\"%g %g %g %g %g %g %g %g\",&chromaticity[0],\n+                      &chromaticity[1],&chromaticity[2],&chromaticity[3],\n+                      &chromaticity[4],&chromaticity[5],&white_point[0],\n+                      &white_point[1]) == 8)\n+                    {\n+                      image->chromaticity.red_primary.x=chromaticity[0];\n+                      image->chromaticity.red_primary.y=chromaticity[1];\n+                      image->chromaticity.green_primary.x=chromaticity[2];\n+                      image->chromaticity.green_primary.y=chromaticity[3];\n+                      image->chromaticity.blue_primary.x=chromaticity[4];\n+                      image->chromaticity.blue_primary.y=chromaticity[5];\n+                      image->chromaticity.white_point.x=white_point[0],\n+                      image->chromaticity.white_point.y=white_point[1];\n+                    }\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n@@ -349,9 +351,11 @@ static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n                     height,\n                     width;\n \n-                  (void) sscanf(value,\"%d +X %d\",&height,&width);\n-                  image->columns=(size_t) width;\n-                  image->rows=(size_t) height;\n+                  if (sscanf(value,\"%d +X %d\",&height,&width) == 2)\n+                    {\n+                      image->columns=(size_t) width;\n+                      image->rows=(size_t) height;\n+                    }\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2008-1294","CWE_ID":"20","category":"security","commit_id":"9926e4c74300c4b31dee007298c6475d33369df0","commit_message":"From 9926e4c74300c4b31dee007298c6475d33369df0 Mon Sep 17 00:00:00 2001\nFrom: Tom Alsberg <alsbergt@cs.huji.ac.il>\nDate: Tue, 8 May 2007 00:30:31 -0700\nSubject: CPU time limit patch \/ setrlimit(RLIMIT_CPU, 0) cheat fix\n\nAs discovered here today, the change in Kernel 2.6.17 intended to inhibit\nusers from setting RLIMIT_CPU to 0 (as that is equivalent to unlimited) by\n\"cheating\" and setting it to 1 in such a case, does not make a difference,\nas the check is done in the wrong place (too late), and only applies to the\nprofiling code.\n\nOn all systems I checked running kernels above 2.6.17, no matter what the\nhard and soft CPU time limits were before, a user could escape them by\nissuing in the shell (sh\/bash\/zsh) \"ulimit -t 0\", and then the user's\nprocess was not ever killed.\n\nAttached is a trivial patch to fix that.  Simply moving the check to a\nslightly earlier location (specifically, before the line that actually\nassigns the limit - *old_rlim = new_rlim), does the trick.\n\nDo note that at least the zsh (but not ash, dash, or bash) shell has the\nproblem of \"caching\" the limits set by the ulimit command, so when running\nzsh the fix will not immediately be evident - after entering \"ulimit -t 0\",\n\"ulimit -a\" will show \"-t: cpu time (seconds) 0\", even though the actual\nlimit as returned by getrlimit(...) will be 1.  It can be verified by\nopening a subshell (which will not have the values of the parent shell in\ncache) and checking in it, or just by running a CPU intensive command like\n\"echo '65536^1048576' | bc\" and verifying that it dumps core after one\nsecond.\n\nRegardless of whether that is a misfeature in the shell, perhaps it would\nbe better to return -EINVAL from setrlimit in such a case instead of\ncheating and setting to 1, as that does not really reflect the actual state\nof the process anymore.  I do not however know what the ground for that\ndecision was in the original 2.6.17 change, and whether there would be any\n\"backward\" compatibility issues, so I preferred not to touch that right\nnow.\n\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/sys.c | 19 ++++++++++---------\n 1 file changed, 10 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/kernel\/sys.c b\/kernel\/sys.c\nindex fe1f3ab20477..926bf9d7ac45 100644\n--- a\/kernel\/sys.c\n+++ b\/kernel\/sys.c\n@@ -1923,6 +1923,16 @@ asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n \tif (retval)\n \t\treturn retval;\n \n+\tif (resource == RLIMIT_CPU && new_rlim.rlim_cur == 0) {\n+\t\t\/*\n+\t\t * The caller is asking for an immediate RLIMIT_CPU\n+\t\t * expiry.  But we use the zero value to mean \"it was\n+\t\t * never set\".  So let's cheat and make it one second\n+\t\t * instead\n+\t\t *\/\n+\t\tnew_rlim.rlim_cur = 1;\n+\t}\n+\n \ttask_lock(current->group_leader);\n \t*old_rlim = new_rlim;\n \ttask_unlock(current->group_leader);\n@@ -1944,15 +1954,6 @@ asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n \t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n \t\tcputime_t cputime;\n \n-\t\tif (rlim_cur == 0) {\n-\t\t\t\/*\n-\t\t\t * The caller is asking for an immediate RLIMIT_CPU\n-\t\t\t * expiry.  But we use the zero value to mean \"it was\n-\t\t\t * never set\".  So let's cheat and make it one second\n-\t\t\t * instead\n-\t\t\t *\/\n-\t\t\trlim_cur = 1;\n-\t\t}\n \t\tcputime = secs_to_cputime(rlim_cur);\n \t\tread_lock(&tasklist_lock);\n \t\tspin_lock_irq(&current->sighand->siglock);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-0292","CWE_ID":"20","category":"security","commit_id":"166978a09cf5edff4028e670b6074215a4c75eca","commit_message":"From 166978a09cf5edff4028e670b6074215a4c75eca Mon Sep 17 00:00:00 2001\nFrom: Colin Walters <walters@verbum.org>\nDate: Thu, 14 Feb 2013 10:19:34 -0500\nSubject: CVE-2013-0292: dbus-gproxy: Verify sender of NameOwnerChanged signals\n to be o.f.DBus\n\nAnyone can hop on the bus and emit a signal whose interface is\no.f.DBus; it's expected at the moments that clients (and notably DBus\nlibraries) check the sender.\n\nThis could previously be used to trick a system service using dbus-glib\ninto thinking a malicious signal came from a privileged source, by\nclaiming that ownership of the privileged source's well-known name had\nchanged from the privileged source's real unique name to the attacker's\nunique name.\n\n[altered to be NULL-safe so it won't crash on peer connections -smcv]\nSigned-off-by: Simon McVittie <simon.mcvittie@collabora.co.uk>\nReviewed-by: Simon McVittie <simon.mcvittie@collabora.co.uk>\n---\n dbus\/dbus-gproxy.c | 7 ++++---\n 1 file changed, 4 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/dbus\/dbus-gproxy.c b\/dbus\/dbus-gproxy.c\nindex 2fc52f9..c3ae9ec 100644\n--- a\/dbus\/dbus-gproxy.c\n+++ b\/dbus\/dbus-gproxy.c\n@@ -1250,8 +1250,11 @@ dbus_g_proxy_manager_filter (DBusConnection    *connection,\n       GSList *tmp;\n       const char *sender;\n \n+      sender = dbus_message_get_sender (message);\n+\n       \/* First we handle NameOwnerChanged internally *\/\n-      if (dbus_message_is_signal (message,\n+      if (g_strcmp0 (sender, DBUS_SERVICE_DBUS) == 0 &&\n+\t  dbus_message_is_signal (message,\n \t\t\t\t  DBUS_INTERFACE_DBUS,\n \t\t\t\t  \"NameOwnerChanged\"))\n \t{\n@@ -1280,8 +1283,6 @@ dbus_g_proxy_manager_filter (DBusConnection    *connection,\n \t    }\n \t}\n \n-      sender = dbus_message_get_sender (message);\n-\n       \/* dbus spec requires these, libdbus validates *\/\n       g_assert (dbus_message_get_path (message) != NULL);\n       g_assert (dbus_message_get_interface (message) != NULL);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-3675","CWE_ID":"20","category":"security","commit_id":"524d0d2cfc7bab1b348f85e7c0369859e63781cf","commit_message":"From 524d0d2cfc7bab1b348f85e7c0369859e63781cf Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 7 May 2013 21:58:27 +0200\nSubject: [PATCH] sanm: Check dimensions before use\n\nFixes integer overflow and out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 9dd04f6d8cdd1c10c28b2cb4252c1a41df581915)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/sanm.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/sanm.c b\/libavcodec\/sanm.c\nindex caeaa366a6..61c3006068 100644\n--- a\/libavcodec\/sanm.c\n+++ b\/libavcodec\/sanm.c\n@@ -739,6 +739,11 @@ static int process_frame_obj(SANMVideoContext *ctx)\n     w     = bytestream2_get_le16u(&ctx->gb);\n     h     = bytestream2_get_le16u(&ctx->gb);\n \n+    if (!w || !h) {\n+        av_log(ctx->avctx, AV_LOG_ERROR, \"dimensions are invalid\\n\");\n+        return AVERROR_INVALIDDATA;\n+    }\n+\n     if (ctx->width < left + w || ctx->height < top + h) {\n         if (av_image_check_size(FFMAX(left + w, ctx->width),\n                                 FFMAX(top  + h, ctx->height), 0, ctx->avctx) < 0)\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-4667","CWE_ID":"20","category":"security","commit_id":"d3217b15a19a4779c39b212358a5c71d725822ee","commit_message":"From d3217b15a19a4779c39b212358a5c71d725822ee Mon Sep 17 00:00:00 2001\nFrom: Xufeng Zhang <xufeng.zhang@windriver.com>\nDate: Thu, 12 Jun 2014 10:53:36 +0800\nSubject: sctp: Fix sk_ack_backlog wrap-around problem\n\nConsider the scenario:\nFor a TCP-style socket, while processing the COOKIE_ECHO chunk in\nsctp_sf_do_5_1D_ce(), after it has passed a series of sanity check,\na new association would be created in sctp_unpack_cookie(), but afterwards,\nsome processing maybe failed, and sctp_association_free() will be called to\nfree the previously allocated association, in sctp_association_free(),\nsk_ack_backlog value is decremented for this socket, since the initial\nvalue for sk_ack_backlog is 0, after the decrement, it will be 65535,\na wrap-around problem happens, and if we want to establish new associations\nafterward in the same socket, ABORT would be triggered since sctp deem the\naccept queue as full.\nFix this issue by only decrementing sk_ack_backlog for associations in\nthe endpoint's list.\n\nFix-suggested-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: Xufeng Zhang <xufeng.zhang@windriver.com>\nAcked-by: Daniel Borkmann <dborkman@redhat.com>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/sctp\/associola.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/sctp\/associola.c b\/net\/sctp\/associola.c\nindex 9e0509ce2f84..9de23a222d3f 100644\n--- a\/net\/sctp\/associola.c\n+++ b\/net\/sctp\/associola.c\n@@ -331,7 +331,7 @@ void sctp_association_free(struct sctp_association *asoc)\n \t\/* Only real associations count against the endpoint, so\n \t * don't bother for if this is a temporary association.\n \t *\/\n-\tif (!asoc->temp) {\n+\tif (!list_empty(&asoc->asocs)) {\n \t\tlist_del(&asoc->asocs);\n \n \t\t\/* Decrement the backlog value for a TCP-style listening\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-10087","CWE_ID":"20","category":"security","commit_id":"dd83c161fbcc5d8be637ab159c0de015cbff5ba4","commit_message":"From dd83c161fbcc5d8be637ab159c0de015cbff5ba4 Mon Sep 17 00:00:00 2001\nFrom: zhongjiang <zhongjiang@huawei.com>\nDate: Mon, 10 Jul 2017 15:53:01 -0700\nSubject: [PATCH] kernel\/exit.c: avoid undefined behaviour when calling wait4()\n\nwait4(-2147483648, 0x20, 0, 0xdd0000) triggers:\nUBSAN: Undefined behaviour in kernel\/exit.c:1651:9\n\nThe related calltrace is as follows:\n\n  negation of -2147483648 cannot be represented in type 'int':\n  CPU: 9 PID: 16482 Comm: zj Tainted: G    B          ---- -------   3.10.0-327.53.58.71.x86_64+ #66\n  Hardware name: Huawei Technologies Co., Ltd. Tecal RH2285          \/BC11BTSA              , BIOS CTSAV036 04\/27\/2011\n  Call Trace:\n    dump_stack+0x19\/0x1b\n    ubsan_epilogue+0xd\/0x50\n    __ubsan_handle_negate_overflow+0x109\/0x14e\n    SyS_wait4+0x1cb\/0x1e0\n    system_call_fastpath+0x16\/0x1b\n\nExclude the overflow to avoid the UBSAN warning.\n\nLink: http:\/\/lkml.kernel.org\/r\/1497264618-20212-1-git-send-email-zhongjiang@huawei.com\nSigned-off-by: zhongjiang <zhongjiang@huawei.com>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: David Rientjes <rientjes@google.com>\nCc: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Xishi Qiu <qiuxishi@huawei.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/exit.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/kernel\/exit.c b\/kernel\/exit.c\nindex 608c9775a37bc..c5548faa9f377 100644\n--- a\/kernel\/exit.c\n+++ b\/kernel\/exit.c\n@@ -1639,6 +1639,10 @@ long kernel_wait4(pid_t upid, int __user *stat_addr, int options,\n \t\t\t__WNOTHREAD|__WCLONE|__WALL))\n \t\treturn -EINVAL;\n \n+\t\/* -INT_MIN is not defined *\/\n+\tif (upid == INT_MIN)\n+\t\treturn -ESRCH;\n+\n \tif (upid == -1)\n \t\ttype = PIDTYPE_MAX;\n \telse if (upid < 0) {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-3487","CWE_ID":"20","category":"security","commit_id":"93e063ee374b6a75729df9e7201fb511e47e259d","commit_message":"From 93e063ee374b6a75729df9e7201fb511e47e259d Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Mon, 9 Jun 2014 13:04:37 +0000\nSubject: [PATCH] Add missing check offset test (Francisco Alonso, Jan Kaluza\n at RedHat)\n\n---\n src\/cdf.c | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/cdf.c b\/src\/cdf.c\nindex 0bfb31a22..c258e82f3 100644\n--- a\/src\/cdf.c\n+++ b\/src\/cdf.c\n@@ -35,7 +35,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: cdf.c,v 1.61 2014\/06\/04 17:23:19 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: cdf.c,v 1.62 2014\/06\/04 17:26:07 christos Exp $\")\n #endif\n \n #include <assert.h>\n@@ -816,7 +816,11 @@ cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n \tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n \t\tgoto out;\n \tfor (i = 0; i < sh.sh_properties; i++) {\n-\t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);\n+\t\tsize_t tail = (i << 1) + 1;\n+\t\tif (cdf_check_stream_offset(sst, h, p, tail * sizeof(uint32_t),\n+\t\t    __LINE__) == -1)\n+\t\t\tgoto out;\n+\t\tsize_t ofs = CDF_GETUINT32(p, tail);\n \t\tq = (const uint8_t *)(const void *)\n \t\t    ((const char *)(const void *)p + ofs\n \t\t    - 2 * sizeof(uint32_t));\n","owner":"glensc","repo":"file","source":"cve"},{"CVE_ID":"CVE-2013-0290","CWE_ID":"20","category":"security","commit_id":"77c1090f94d1b0b5186fb13a1b71b47b1343f87f","commit_message":"From 77c1090f94d1b0b5186fb13a1b71b47b1343f87f Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Tue, 12 Feb 2013 06:16:53 +0000\nSubject: net: fix infinite loop in __skb_recv_datagram()\n\nTommi was fuzzing with trinity and reported the following problem :\n\ncommit 3f518bf745 (datagram: Add offset argument to __skb_recv_datagram)\nmissed that a raw socket receive queue can contain skbs with no payload.\n\nWe can loop in __skb_recv_datagram() with MSG_PEEK mode, because\nwait_for_packet() is not prepared to skip these skbs.\n\n[   83.541011] INFO: rcu_sched detected stalls on CPUs\/tasks: {}\n(detected by 0, t=26002 jiffies, g=27673, c=27672, q=75)\n[   83.541011] INFO: Stall ended before state dump start\n[  108.067010] BUG: soft lockup - CPU#0 stuck for 22s! [trinity-child31:2847]\n...\n[  108.067010] Call Trace:\n[  108.067010]  [<ffffffff818cc103>] __skb_recv_datagram+0x1a3\/0x3b0\n[  108.067010]  [<ffffffff818cc33d>] skb_recv_datagram+0x2d\/0x30\n[  108.067010]  [<ffffffff819ed43d>] rawv6_recvmsg+0xad\/0x240\n[  108.067010]  [<ffffffff818c4b04>] sock_common_recvmsg+0x34\/0x50\n[  108.067010]  [<ffffffff818bc8ec>] sock_recvmsg+0xbc\/0xf0\n[  108.067010]  [<ffffffff818bf31e>] sys_recvfrom+0xde\/0x150\n[  108.067010]  [<ffffffff81ca4329>] system_call_fastpath+0x16\/0x1b\n\nReported-by: Tommi Rantala <tt.rantala@gmail.com>\nTested-by: Tommi Rantala <tt.rantala@gmail.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Pavel Emelyanov <xemul@parallels.com>\nAcked-by: Pavel Emelyanov <xemul@parallels.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/datagram.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/core\/datagram.c b\/net\/core\/datagram.c\nindex 0337e2b76862..368f9c3f9dc6 100644\n--- a\/net\/core\/datagram.c\n+++ b\/net\/core\/datagram.c\n@@ -187,7 +187,7 @@ struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n \t\tskb_queue_walk(queue, skb) {\n \t\t\t*peeked = skb->peeked;\n \t\t\tif (flags & MSG_PEEK) {\n-\t\t\t\tif (*off >= skb->len) {\n+\t\t\t\tif (*off >= skb->len && skb->len) {\n \t\t\t\t\t*off -= skb->len;\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-16643","CWE_ID":"20","category":"security","commit_id":"6b6bff054d569a77973f2140c0e86366e6168a6c","commit_message":"From 6b6bff054d569a77973f2140c0e86366e6168a6c Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 5 Jul 2018 14:29:46 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1199\n\n---\n coders\/cals.c | 3 ++-\n coders\/dcm.c  | 9 +++++----\n coders\/pict.c | 3 ++-\n coders\/pwp.c  | 3 ++-\n 4 files changed, 11 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/coders\/cals.c b\/coders\/cals.c\nindex 842cff4acc..bce23e8212 100644\n--- a\/coders\/cals.c\n+++ b\/coders\/cals.c\n@@ -257,7 +257,8 @@ static Image *ReadCALSImage(const ImageInfo *image_info,\n   if ((unique_file == -1) || (file == (FILE *) NULL))\n     ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n   while ((c=ReadBlobByte(image)) != EOF)\n-    (void) fputc(c,file);\n+    if (fputc(c,file) != c)\n+      break;\n   (void) fclose(file);\n   (void) CloseBlob(image);\n   image=DestroyImage(image);\ndiff --git a\/coders\/dcm.c b\/coders\/dcm.c\nindex 334fd2ec89..49fe55a192 100644\n--- a\/coders\/dcm.c\n+++ b\/coders\/dcm.c\n@@ -3228,13 +3228,13 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n               (strncmp(implicit_vr,\"SS\",2) == 0) ||\n               (strncmp(implicit_vr,\"US\",2) == 0))\n             quantum=2;\n-          else \n+          else\n             if ((strncmp(implicit_vr,\"FL\",2) == 0) ||\n                 (strncmp(implicit_vr,\"OF\",2) == 0) ||\n                 (strncmp(implicit_vr,\"SL\",2) == 0) ||\n                 (strncmp(implicit_vr,\"UL\",2) == 0))\n               quantum=4;\n-            else \n+            else\n               if (strncmp(implicit_vr,\"FD\",2) == 0)\n                 quantum=8;\n               else\n@@ -3880,7 +3880,8 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n                   \"UnexpectedEndOfFile\",image->filename);\n                 break;\n               }\n-            (void) fputc(c,file);\n+            if (fputc(c,file) != c)\n+              break;\n           }\n           (void) fclose(file);\n           if (c == EOF)\n@@ -3934,7 +3935,7 @@ static Image *ReadDCMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n         length=(size_t) (GetQuantumRange(info.depth)+1);\n         if (length > (size_t) GetBlobSize(image))\n           ThrowDCMException(CorruptImageError,\"InsufficientImageDataInFile\");\n-        if (info.scale != (Quantum *) NULL) \n+        if (info.scale != (Quantum *) NULL)\n           info.scale=(Quantum *) RelinquishMagickMemory(info.scale);\n         info.scale=(Quantum *) AcquireQuantumMemory(MagickMax(length,256),\n           sizeof(*info.scale));\ndiff --git a\/coders\/pict.c b\/coders\/pict.c\nindex 8aafadec26..35dadfeee0 100644\n--- a\/coders\/pict.c\n+++ b\/coders\/pict.c\n@@ -1472,7 +1472,8 @@ static Image *ReadPICTImage(const ImageInfo *image_info,\n               c=ReadBlobByte(image);\n               if (c == EOF)\n                 break;\n-              (void) fputc(c,file);\n+              if (fputc(c,file) != c)\n+                break;\n             }\n           }\n         (void) fclose(file);\ndiff --git a\/coders\/pwp.c b\/coders\/pwp.c\nindex e5ae5c8805..cad4250027 100644\n--- a\/coders\/pwp.c\n+++ b\/coders\/pwp.c\n@@ -233,7 +233,8 @@ static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n       c=ReadBlobByte(pwp_image);\n       if (c == EOF)\n         break;\n-      (void) fputc(c,file);\n+      if (fputc(c,file) != c)\n+        break;\n     }\n     (void) fclose(file);\n     if (c == EOF)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-7129","CWE_ID":"20","category":"security","commit_id":"426aeb2808955ee3d3f52e0cfb102834cdb836a5","commit_message":"From 426aeb2808955ee3d3f52e0cfb102834cdb836a5 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Thu, 4 Aug 2016 00:17:42 -0700\nSubject: [PATCH] Fix bug #72749: wddx_deserialize allows illegal memory access\n\n---\n ext\/wddx\/tests\/bug72749.phpt | 34 ++++++++++++++++++++++++++++++++++\n ext\/wddx\/wddx.c              | 20 ++++++++++++++------\n 2 files changed, 48 insertions(+), 6 deletions(-)\n create mode 100644 ext\/wddx\/tests\/bug72749.phpt\n\n","diff_code":"diff --git a\/ext\/wddx\/tests\/bug72749.phpt b\/ext\/wddx\/tests\/bug72749.phpt\nnew file mode 100644\nindex 000000000000..ee17d0f22956\n--- \/dev\/null\n+++ b\/ext\/wddx\/tests\/bug72749.phpt\n@@ -0,0 +1,34 @@\n+--TEST--\n+Bug #72749: wddx_deserialize allows illegal memory access\n+--SKIPIF--\n+<?php\n+if (!extension_loaded('wddx')) {\n+    die('skip. wddx not available');\n+}\n+?>\n+--FILE--\n+<?php\n+$xml = <<<XML\n+<?xml version='1.0'?>\n+<!DOCTYPE wddxPacket SYSTEM 'wddx_0100.dtd'>\n+<wddxPacket version='1.0'>\n+<header\/>\n+        <data>\n+                <struct>\n+                     <var name='aDateTime3'>\n+                         <dateTime>2\\r2004-09-10T05:52:49+00<\/dateTime>\n+                     <\/var>\n+                 <\/struct>\n+        <\/data>\n+<\/wddxPacket>\n+XML;\n+\n+$array = wddx_deserialize($xml);\n+var_dump($array);\n+?>\n+--EXPECT--\n+array(1) {\n+  [\"aDateTime3\"]=>\n+  string(24) \"2\n+2004-09-10T05:52:49+00\"\n+}\ndiff --git a\/ext\/wddx\/wddx.c b\/ext\/wddx\/wddx.c\nindex cde3e074064f..faadbfe1dfe3 100644\n--- a\/ext\/wddx\/wddx.c\n+++ b\/ext\/wddx\/wddx.c\n@@ -1123,18 +1123,26 @@ static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n \t\t\tcase ST_DATETIME: {\n \t\t\t\tchar *tmp;\n \n-\t\t\t\ttmp = emalloc(len + 1);\n-\t\t\t\tmemcpy(tmp, s, len);\n+\t\t\t\tif (Z_TYPE_P(ent->data) == IS_STRING) {\n+\t\t\t\t\ttmp = safe_emalloc(Z_STRLEN_P(ent->data), 1, (size_t)len + 1);\n+\t\t\t\t\tmemcpy(tmp, Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data));\n+\t\t\t\t\tmemcpy(tmp + Z_STRLEN_P(ent->data), s, len);\n+\t\t\t\t\tlen += Z_STRLEN_P(ent->data);\n+\t\t\t\t\tefree(Z_STRVAL_P(ent->data));\n+\t\t\t\t\tZ_TYPE_P(ent->data) = IS_LONG;\n+\t\t\t\t} else {\n+\t\t\t\t\ttmp = emalloc(len + 1);\n+\t\t\t\t\tmemcpy(tmp, s, len);\n+\t\t\t\t}\n \t\t\t\ttmp[len] = '\\0';\n \n \t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n \t\t\t\t\/* date out of range < 1969 or > 2038 *\/\n \t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n-\t\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n-\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n-\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n+\t\t\t\t\tZVAL_STRINGL(ent->data, tmp, len, 0);\n+\t\t\t\t} else {\n+\t\t\t\t\tefree(tmp);\n \t\t\t\t}\n-\t\t\t\tefree(tmp);\n \t\t\t}\n \t\t\t\tbreak;\n \n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2012-0853","CWE_ID":"20","category":"security","commit_id":"9af6abdc17deb95c9b1f1d9242ba49b8b5e0b016","commit_message":"From 9af6abdc17deb95c9b1f1d9242ba49b8b5e0b016 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sat, 17 Dec 2011 03:18:58 +0100\nSubject: [PATCH] atrac3: Fix crash in tonal component decoding. Fixes\n Ticket780 Bug Found by: cosminamironesei\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/atrac3.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/atrac3.c b\/libavcodec\/atrac3.c\nindex b9f1f516cc..fcf7c925eb 100644\n--- a\/libavcodec\/atrac3.c\n+++ b\/libavcodec\/atrac3.c\n@@ -402,6 +402,8 @@ static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent\n \n             for (k=0; k<coded_components; k++) {\n                 sfIndx = get_bits(gb,6);\n+                if(component_count>=64)\n+                    return AVERROR_INVALIDDATA;\n                 pComponent[component_count].pos = j * 64 + (get_bits(gb,6));\n                 max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;\n                 coded_values = coded_values_per_component + 1;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8702","CWE_ID":"20","category":"security","commit_id":"6058483d9fbc1b904d5ae7cfea47bfcde5c5b559","commit_message":"From 6058483d9fbc1b904d5ae7cfea47bfcde5c5b559 Mon Sep 17 00:00:00 2001\nFrom: Attila Molnar <attilamolnar@hush.com>\nDate: Thu, 16 Apr 2015 18:04:03 +0200\nSubject: [PATCH] Reject replies to DNS PTR requests that contain invalid\n characters\n\nFixes issue #1033 reported by @ping86\n---\n src\/dns.cpp | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\n","diff_code":"diff --git a\/src\/dns.cpp b\/src\/dns.cpp\nindex 75e5731fe9..14305ccab2 100644\n--- a\/src\/dns.cpp\n+++ b\/src\/dns.cpp\n@@ -700,8 +700,16 @@ DNSResult DNS::GetResult()\n \t\t\t\t\/* Identical handling to PTR *\/\n \n \t\t\tcase DNS_QUERY_PTR:\n+\t\t\t{\n \t\t\t\t\/* Reverse lookups just come back as char* *\/\n \t\t\t\tresultstr = std::string((const char*)data.first);\n+\t\t\t\tif (resultstr.find_first_not_of(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-\") != std::string::npos)\n+\t\t\t\t{\n+\t\t\t\t\tstd::string ro = req->orig;\n+\t\t\t\t\tdelete req;\n+\t\t\t\t\treturn DNSResult(this_id | ERROR_MASK, \"Invalid char(s) in reply\", 0, ro);\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tbreak;\n \n \t\t\tdefault:\n","owner":"inspircd","repo":"inspircd","source":"cve"},{"CVE_ID":"CVE-2013-2232","CWE_ID":"20","category":"security","commit_id":"a963a37d384d71ad43b3e9e79d68d42fbe0901f3","commit_message":"From a963a37d384d71ad43b3e9e79d68d42fbe0901f3 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Wed, 26 Jun 2013 04:15:07 -0700\nSubject: [PATCH] ipv6: ip6_sk_dst_check() must not assume ipv6 dst\n\nIt's possible to use AF_INET6 sockets and to connect to an IPv4\ndestination. After this, socket dst cache is a pointer to a rtable,\nnot rt6_info.\n\nip6_sk_dst_check() should check the socket dst cache is IPv6, or else\nvarious corruptions\/crashes can happen.\n\nDave Jones can reproduce immediate crash with\ntrinity -q -l off -n -c sendmsg -c connect\n\nWith help from Hannes Frederic Sowa\n\nReported-by: Dave Jones <davej@redhat.com>\nReported-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/ip6_output.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/ip6_output.c b\/net\/ipv6\/ip6_output.c\nindex 95703ba2c084d..d5d20cde8d928 100644\n--- a\/net\/ipv6\/ip6_output.c\n+++ b\/net\/ipv6\/ip6_output.c\n@@ -821,11 +821,17 @@ static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n \t\t\t\t\t  const struct flowi6 *fl6)\n {\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n-\tstruct rt6_info *rt = (struct rt6_info *)dst;\n+\tstruct rt6_info *rt;\n \n \tif (!dst)\n \t\tgoto out;\n \n+\tif (dst->ops->family != AF_INET6) {\n+\t\tdst_release(dst);\n+\t\treturn NULL;\n+\t}\n+\n+\trt = (struct rt6_info *)dst;\n \t\/* Yes, checking route validity in not connected\n \t * case is not very simple. Take into account,\n \t * that we do not support routing by source, TOS,\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2009-1914","CWE_ID":"20","category":"security","commit_id":"192d7a4667c6d11d1a174ec4cad9a3c5d5f9043c","commit_message":"From 192d7a4667c6d11d1a174ec4cad9a3c5d5f9043c Mon Sep 17 00:00:00 2001\nFrom: Mikulas Patocka <mpatocka@redhat.com>\nDate: Wed, 18 Mar 2009 23:53:16 -0700\nSubject: sparc64: Fix crash with \/proc\/iomem\n\nWhen you compile kernel on Sparc64 with heap memory checking and type\n\"cat \/proc\/iomem\", you get a crash, because pointers in struct\nresource are uninitialized.\n\nMost code fills struct resource with zeros, so I assume that it is\nresponsibility of the caller of request_resource to initialized it,\nnot the responsibility of request_resource functuion.\n\nAfter 2.6.29 is out, there could be a check for uninitialized fields\nadded to request_resource to avoid crashes like this.\n\nSigned-off-by: Mikulas Patocka <mpatocka@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n arch\/sparc\/kernel\/pci_common.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/sparc\/kernel\/pci_common.c b\/arch\/sparc\/kernel\/pci_common.c\nindex 64e6edf17b9d..b775658a927d 100644\n--- a\/arch\/sparc\/kernel\/pci_common.c\n+++ b\/arch\/sparc\/kernel\/pci_common.c\n@@ -368,7 +368,7 @@ static void pci_register_iommu_region(struct pci_pbm_info *pbm)\n \tconst u32 *vdma = of_get_property(pbm->op->node, \"virtual-dma\", NULL);\n \n \tif (vdma) {\n-\t\tstruct resource *rp = kmalloc(sizeof(*rp), GFP_KERNEL);\n+\t\tstruct resource *rp = kzalloc(sizeof(*rp), GFP_KERNEL);\n \n \t\tif (!rp) {\n \t\t\tprom_printf(\"Cannot allocate IOMMU resource.\\n\");\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-4353","CWE_ID":"20","category":"security","commit_id":"07116a314f4dcd4d96990bbd74db95a03a9f650a","commit_message":"From 07116a314f4dcd4d96990bbd74db95a03a9f650a Mon Sep 17 00:00:00 2001\nFrom: Werner Koch <wk@gnupg.org>\nDate: Thu, 9 Apr 2015 11:50:03 +0200\nSubject: [PATCH] Do not abort on decoder stack overflow.\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\n* src\/ber-decoder.c (push_decoder_state, pop_decoder_state): Return an\nerror code.\n(set_error): Prefix error message with \"ksba:\". Act on new return code.\n(decoder_next): Act on new return code.\n--\n\nThis changes the behaviour from\n\n  gpgsm: unknown hash algorithm '1.8.48.48.48.48.48.48.48.48'\n  gpgsm: detached signature w\/o data - assuming certs-only\n  ERROR: decoder stack overflow!\n  Aborted\n\nto\n\n  gpgsm: detached signature w\/o data - assuming certs-only\n  ksba: ber-decoder: stack overflow!\n  gpgsm: ksba_cms_parse failed: Limit reached\n\nUse \"gpgsm --verify FILE\" to exhibit the problem.  FILE is\n-----BEGIN PGP ARMORED FILE-----\n\nMDAGCSqGSIb3DQEHAqCAMDACAQExDzANBgkwMDAwMDAwMDAwADCABgkwMDAwMDAw\nMDAAMDEwoIGTMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw\nMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw\nMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw\nMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw\nMDAwMDAwMDAwMDAwMDAjMDA=\n=PQdP\n-----END PGP ARMORED FILE-----\n\nReported-by: Hanno B\u00c3\u00b6ck\nSigned-off-by: Werner Koch <wk@gnupg.org>\n---\n src\/ber-decoder.c | 30 ++++++++++++++++++------------\n 1 file changed, 18 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/src\/ber-decoder.c b\/src\/ber-decoder.c\nindex b4689fa..9e70d92 100644\n--- a\/src\/ber-decoder.c\n+++ b\/src\/ber-decoder.c\n@@ -1,5 +1,5 @@\n \/* ber-decoder.c - Basic Encoding Rules Decoder\n- *      Copyright (C) 2001, 2004, 2006, 2012 g10 Code GmbH\n+ * Copyright (C) 2001, 2004, 2006, 2012, 2015 g10 Code GmbH\n  *\n  * This file is part of KSBA.\n  *\n@@ -175,26 +175,28 @@ dump_decoder_state (DECODER_STATE ds)\n }\n \n \/* Push ITEM onto the stack *\/\n-static void\n+static gpg_error_t\n push_decoder_state (DECODER_STATE ds)\n {\n   if (ds->idx >= ds->stacksize)\n     {\n-      fprintf (stderr, \"ERROR: decoder stack overflow!\\n\");\n-      abort ();\n+      fprintf (stderr, \"ksba: ber-decoder: stack overflow!\\n\");\n+      return gpg_error (GPG_ERR_LIMIT_REACHED);\n     }\n   ds->stack[ds->idx++] = ds->cur;\n+  return 0;\n }\n \n-static void\n+static gpg_error_t\n pop_decoder_state (DECODER_STATE ds)\n {\n   if (!ds->idx)\n     {\n-      fprintf (stderr, \"ERROR: decoder stack underflow!\\n\");\n-      abort ();\n+      fprintf (stderr, \"ksba: ber-decoder: stack underflow!\\n\");\n+      return gpg_error (GPG_ERR_INTERNAL);\n     }\n   ds->cur = ds->stack[--ds->idx];\n+  return 0;\n }\n \n \n@@ -202,7 +204,7 @@ pop_decoder_state (DECODER_STATE ds)\n static int\n set_error (BerDecoder d, AsnNode node, const char *text)\n {\n-  fprintf (stderr,\"ber-decoder: node `%s': %s\\n\",\n+  fprintf (stderr,\"ksba: ber-decoder: node `%s': %s\\n\",\n            node? node->name:\"?\", text);\n   d->last_errdesc = text;\n   return gpg_error (GPG_ERR_BAD_BER);\n@@ -955,9 +957,9 @@ decoder_next (BerDecoder d)\n                        && (ds->cur.nread\n                            > ds->stack[ds->idx-1].length))\n                     {\n-                      fprintf (stderr, \"  ERROR: object length field \"\n+                      fprintf (stderr, \"ksba: ERROR: object length field \"\n                                \"%d octects too large\\n\",\n-                              ds->cur.nread > ds->cur.length);\n+                               ds->cur.nread - ds->cur.length);\n                       ds->cur.nread = ds->cur.length;\n                     }\n                   if ( ds->idx\n@@ -967,7 +969,9 @@ decoder_next (BerDecoder d)\n                                    >= ds->stack[ds->idx-1].length))))\n                     {\n                       int n = ds->cur.nread;\n-                      pop_decoder_state (ds);\n+                      err = pop_decoder_state (ds);\n+                      if (err)\n+                        return err;\n                       ds->cur.nread += n;\n                       ds->cur.went_up++;\n                     }\n@@ -983,7 +987,9 @@ decoder_next (BerDecoder d)\n                   \/* prepare for the next level *\/\n                   ds->cur.length = ti.length;\n                   ds->cur.ndef_length = ti.ndef;\n-                  push_decoder_state (ds);\n+                  err = push_decoder_state (ds);\n+                  if (err)\n+                    return err;\n                   ds->cur.length = 0;\n                   ds->cur.ndef_length = 0;\n                   ds->cur.nread = 0;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-8543","CWE_ID":"20","category":"security","commit_id":"8b0e96e1f21b761ca15dbb470cd619a1ebf86c3e","commit_message":"From 8b0e96e1f21b761ca15dbb470cd619a1ebf86c3e Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 3 Oct 2014 14:45:04 +0200\nSubject: [PATCH] avcodec\/mmvideo: Bounds check 2nd line of HHV Intra blocks\n\nFixes out of array access\nFixes: asan_heap-oob_4da4f3_8_asan_heap-oob_4da4f3_419_scene1a.mm\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/mmvideo.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/mmvideo.c b\/libavcodec\/mmvideo.c\nindex 026d4630ae..9ff6393aec 100644\n--- a\/libavcodec\/mmvideo.c\n+++ b\/libavcodec\/mmvideo.c\n@@ -109,7 +109,7 @@ static int mm_decode_intra(MmContext * s, int half_horiz, int half_vert)\n \n         if (color) {\n             memset(s->frame->data[0] + y*s->frame->linesize[0] + x, color, run_length);\n-            if (half_vert)\n+            if (half_vert && y + half_vert < s->avctx->height)\n                 memset(s->frame->data[0] + (y+1)*s->frame->linesize[0] + x, color, run_length);\n         }\n         x+= run_length;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-0494","CWE_ID":"20","category":"security","commit_id":"1fc9c95ec144499e69dc8ec76dbe07799d7d82cd","commit_message":"From 1fc9c95ec144499e69dc8ec76dbe07799d7d82cd Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Tim=20R=C3=BChsen?= <tim.ruehsen@gmx.de>\nDate: Fri, 27 Apr 2018 10:41:56 +0200\nSubject: Fix cookie injection (CVE-2018-0494)\n\n* src\/http.c (resp_new): Replace \\r\\n by space in continuation lines\n\nFixes #53763\n \"Malicious website can write arbitrary cookie entries to cookie jar\"\n\nHTTP header parsing left the \\r\\n from continuation line intact.\nThe Set-Cookie code didn't check and could be tricked to write\n\\r\\n into the cookie jar, allowing a server to generate cookies at will.\n---\n src\/http.c | 18 +++++++++++++-----\n 1 file changed, 13 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/http.c b\/src\/http.c\nindex c8960f1..77bdbbe 100644\n--- a\/src\/http.c\n+++ b\/src\/http.c\n@@ -613,9 +613,9 @@ struct response {\n    resp_header_*.  *\/\n \n static struct response *\n-resp_new (const char *head)\n+resp_new (char *head)\n {\n-  const char *hdr;\n+  char *hdr;\n   int count, size;\n \n   struct response *resp = xnew0 (struct response);\n@@ -644,15 +644,23 @@ resp_new (const char *head)\n         break;\n \n       \/* Find the end of HDR, including continuations. *\/\n-      do\n+      for (;;)\n         {\n-          const char *end = strchr (hdr, '\\n');\n+          char *end = strchr (hdr, '\\n');\n+\n           if (end)\n             hdr = end + 1;\n           else\n             hdr += strlen (hdr);\n+\n+          if (*hdr != ' ' && *hdr != '\\t')\n+            break;\n+\n+          \/\/ continuation, transform \\r and \\n into spaces\n+          *end = ' ';\n+          if (end > head && end[-1] == '\\r')\n+            end[-1] = ' ';\n         }\n-      while (*hdr == ' ' || *hdr == '\\t');\n     }\n   DO_REALLOC (resp->headers, size, count + 1, const char *);\n   resp->headers[count] = NULL;\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-2136","CWE_ID":"20","category":"security","commit_id":"cc9b17ad29ecaa20bfe426a8d4dbfb94b13ff1cc","commit_message":"From cc9b17ad29ecaa20bfe426a8d4dbfb94b13ff1cc Mon Sep 17 00:00:00 2001\nFrom: Jason Wang <jasowang@redhat.com>\nDate: Wed, 30 May 2012 21:18:10 +0000\nSubject: net: sock: validate data_len before allocating skb in\n sock_alloc_send_pskb()\n\nWe need to validate the number of pages consumed by data_len, otherwise frags\narray could be overflowed by userspace. So this patch validate data_len and\nreturn -EMSGSIZE when data_len may occupies more frags than MAX_SKB_FRAGS.\n\nSigned-off-by: Jason Wang <jasowang@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/sock.c | 7 +++++--\n 1 file changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/core\/sock.c b\/net\/core\/sock.c\nindex 653f8c0aedc5..9e5b71fda6ec 100644\n--- a\/net\/core\/sock.c\n+++ b\/net\/core\/sock.c\n@@ -1592,6 +1592,11 @@ struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n \tgfp_t gfp_mask;\n \tlong timeo;\n \tint err;\n+\tint npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n+\n+\terr = -EMSGSIZE;\n+\tif (npages > MAX_SKB_FRAGS)\n+\t\tgoto failure;\n \n \tgfp_mask = sk->sk_allocation;\n \tif (gfp_mask & __GFP_WAIT)\n@@ -1610,14 +1615,12 @@ struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n \t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n \t\t\tskb = alloc_skb(header_len, gfp_mask);\n \t\t\tif (skb) {\n-\t\t\t\tint npages;\n \t\t\t\tint i;\n \n \t\t\t\t\/* No pages, we're done... *\/\n \t\t\t\tif (!data_len)\n \t\t\t\t\tbreak;\n \n-\t\t\t\tnpages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n \t\t\t\tskb->truesize += data_len;\n \t\t\t\tskb_shinfo(skb)->nr_frags = npages;\n \t\t\t\tfor (i = 0; i < npages; i++) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-0860","CWE_ID":"20","category":"security","commit_id":"3e196e4def03c7a91423803402f84d638d316c33","commit_message":"From 3e196e4def03c7a91423803402f84d638d316c33 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 11 Jan 2013 04:44:20 +0100\nSubject: [PATCH] error_concealment: Check that the picture is not in a half\n setup state.\n\nFixes state becoming inconsistent\nFixes a null pointer dereference\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 23318a57358358e7a4dc551e830e4503f0638cfe)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/error_resilience.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/error_resilience.c b\/libavcodec\/error_resilience.c\nindex 6ae06f2ad1..a166256a18 100644\n--- a\/libavcodec\/error_resilience.c\n+++ b\/libavcodec\/error_resilience.c\n@@ -923,6 +923,12 @@ void ff_er_frame_end(MpegEncContext *s)\n         return;\n     };\n \n+    if (   s->picture_structure == PICT_FRAME\n+        && s->current_picture.f.linesize[0] != s->current_picture_ptr->f.linesize[0]) {\n+        av_log(s->avctx, AV_LOG_ERROR, \"Error concealment not possible, frame not fully initialized\\n\");\n+        return;\n+    }\n+\n     if (s->current_picture.f.motion_val[0] == NULL) {\n         av_log(s->avctx, AV_LOG_ERROR, \"Warning MVs not available\\n\");\n \n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-6696","CWE_ID":"20","category":"security","commit_id":"ed28c1ba666b39581adb860bf51cdde43c84cc89","commit_message":"From ed28c1ba666b39581adb860bf51cdde43c84cc89 Mon Sep 17 00:00:00 2001\nFrom: Adam <Adam@anope.org>\nDate: Mon, 26 Mar 2012 04:59:13 -0400\nSubject: [PATCH] Fixed out of bounds memory access from malformed DNS queries\n that have an invalid length label. Introduced in\n a6a07de0daa353bcd29056a4535a9c4784c113c8.\n\n---\n src\/dns.cpp | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/dns.cpp b\/src\/dns.cpp\nindex 2e1c751c4c..be74e6aa34 100644\n--- a\/src\/dns.cpp\n+++ b\/src\/dns.cpp\n@@ -760,7 +760,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, unsigned length)\n \t\t\t\telse i += header.payload[i] + 1; \/* skip length and label *\/\n \t\t\t}\n \t\t}\n-\t\tif (length - i < 10)\n+\t\tif (static_cast<int>(length - i) < 10)\n \t\t\treturn std::make_pair((unsigned char*)NULL,\"Incorrectly sized DNS reply\");\n \n \t\t\/* XXX: We actually initialise 'rr' here including its ttl field *\/\n","owner":"inspircd","repo":"inspircd","source":"cve"},{"CVE_ID":"CVE-2018-1000037","CWE_ID":"20","category":"security","commit_id":"b2e7d38e845c7d4922d05e6e41f3a2dc1bc1b14a","commit_message":"From b2e7d38e845c7d4922d05e6e41f3a2dc1bc1b14a Mon Sep 17 00:00:00 2001\nFrom: Sebastian Rasmussen <sebras@gmail.com>\nDate: Sat, 3 Feb 2018 02:52:59 +0100\nSubject: [PATCH 1\/1] Bug 698890: Remember to end groups when showing images.\n\n---\n source\/pdf\/pdf-op-run.c | 114 ++++++++++++++++++++++++++++++------------------\n 1 file changed, 72 insertions(+), 42 deletions(-)\n\n","diff_code":"diff --git a\/source\/pdf\/pdf-op-run.c b\/source\/pdf\/pdf-op-run.c\nindex 355e94d..f16d228 100644\n--- a\/source\/pdf\/pdf-op-run.c\n+++ b\/source\/pdf\/pdf-op-run.c\n@@ -501,12 +501,47 @@ pdf_show_pattern(fz_context *ctx, pdf_run_processor *pr, pdf_pattern *pat, pdf_g\n }\n \n static void\n+pdf_show_image_imp(fz_context *ctx, pdf_run_processor *pr, fz_image *image, fz_matrix *image_ctm, fz_rect *bbox)\n+{\n+\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n+\n+\tif (image->colorspace)\n+\t{\n+\t\tfz_fill_image(ctx, pr->dev, image, image_ctm, gstate->fill.alpha, &gstate->fill.color_params);\n+\t\treturn;\n+\t}\n+\n+\tif (gstate->fill.kind == PDF_MAT_COLOR)\n+\t\tfz_fill_image_mask(ctx, pr->dev, image, image_ctm,\n+\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n+\telse if (gstate->fill.kind == PDF_MAT_PATTERN && gstate->fill.pattern)\n+\t{\n+\t\tfz_clip_image_mask(ctx, pr->dev, image, image_ctm, bbox);\n+\t\tfz_try(ctx)\n+\t\t\tpdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], bbox, PDF_FILL);\n+\t\tfz_always(ctx)\n+\t\t\tfz_pop_clip(ctx, pr->dev);\n+\t\tfz_catch(ctx)\n+\t\t\tfz_rethrow(ctx);\n+\t}\n+\telse if (gstate->fill.kind == PDF_MAT_SHADE && gstate->fill.shade)\n+\t{\n+\t\tfz_clip_image_mask(ctx, pr->dev, image, image_ctm, bbox);\n+\t\tfz_try(ctx)\n+\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n+\t\tfz_always(ctx)\n+\t\t\tfz_pop_clip(ctx, pr->dev);\n+\t\tfz_catch(ctx)\n+\t\t\tfz_rethrow(ctx);\n+\t}\n+}\n+\n+static void\n pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n {\n \tpdf_gstate *gstate = pr->gstate + pr->gtop;\n \tfz_matrix image_ctm;\n \tfz_rect bbox;\n-\tsoftmask_save softmask = { NULL };\n \n \tif (pr->super.hidden)\n \t\treturn;\n@@ -518,57 +553,52 @@ pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)\n \tbbox = fz_unit_rect;\n \tfz_transform_rect(&bbox, &image_ctm);\n \n-\tif (image->mask)\n+\tif (image->mask && gstate->blendmode)\n \t{\n \t\t\/* apply blend group even though we skip the soft mask *\/\n-\t\tif (gstate->blendmode)\n-\t\t\tfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);\n-\t\tfz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\n-\t}\n-\telse\n-\t\tgstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n+\t\tfz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);\n \n-\tif (!image->colorspace)\n-\t{\n-\t\tswitch (gstate->fill.kind)\n+\t\tfz_try(ctx)\n+\t\t\tfz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\n+\t\tfz_catch(ctx)\n \t\t{\n-\t\tcase PDF_MAT_NONE:\n-\t\t\tbreak;\n-\t\tcase PDF_MAT_COLOR:\n-\t\t\tfz_fill_image_mask(ctx, pr->dev, image, &image_ctm,\n-\t\t\t\tgstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);\n-\t\t\tbreak;\n-\t\tcase PDF_MAT_PATTERN:\n-\t\t\tif (gstate->fill.pattern)\n-\t\t\t{\n-\t\t\t\tfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n-\t\t\t\tpdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);\n-\t\t\t\tfz_pop_clip(ctx, pr->dev);\n-\t\t\t}\n-\t\t\tbreak;\n-\t\tcase PDF_MAT_SHADE:\n-\t\t\tif (gstate->fill.shade)\n-\t\t\t{\n-\t\t\t\tfz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);\n-\t\t\t\tfz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);\n-\t\t\t\tfz_pop_clip(ctx, pr->dev);\n-\t\t\t}\n-\t\t\tbreak;\n+\t\t\tfz_end_group(ctx, pr->dev);\n+\t\t\tfz_rethrow(ctx);\n \t\t}\n+\n+\t\tfz_try(ctx)\n+\t\t\tpdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);\n+\t\tfz_always(ctx)\n+\t\t{\n+\t\t\tfz_pop_clip(ctx, pr->dev);\n+\t\t\tfz_end_group(ctx, pr->dev);\n+\t\t}\n+\t\tfz_catch(ctx)\n+\t\t\tfz_rethrow(ctx);\n \t}\n-\telse\n+\telse if (image->mask)\n \t{\n-\t\tfz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);\n+\t\tfz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);\n+\t\tfz_try(ctx)\n+\t\t\tpdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);\n+\t\tfz_always(ctx)\n+\t\t\tfz_pop_clip(ctx, pr->dev);\n+\t\tfz_catch(ctx)\n+\t\t\tfz_rethrow(ctx);\n \t}\n-\n-\tif (image->mask)\n+\telse\n \t{\n-\t\tfz_pop_clip(ctx, pr->dev);\n-\t\tif (gstate->blendmode)\n-\t\t\tfz_end_group(ctx, pr->dev);\n+\t\tsoftmask_save softmask = { NULL };\n+\n+\t\tgstate = pdf_begin_group(ctx, pr, &bbox, &softmask);\n+\n+\t\tfz_try(ctx)\n+\t\t\tpdf_show_image_imp(ctx, pr, image, &image_ctm, &bbox);\n+\t\tfz_always(ctx)\n+\t\t\tpdf_end_group(ctx, pr, &softmask);\n+\t\tfz_catch(ctx)\n+\t\t\tfz_rethrow(ctx);\n \t}\n-\telse\n-\t\tpdf_end_group(ctx, pr, &softmask);\n }\n \n static void\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12843","CWE_ID":"20","category":"security","commit_id":"5edadcfb83bf27107578830801817f9e6d0ad941","commit_message":"From 5edadcfb83bf27107578830801817f9e6d0ad941 Mon Sep 17 00:00:00 2001\nFrom: Bron Gondwana <brong@fastmail.fm>\nDate: Fri, 11 Aug 2017 11:58:24 +1000\nSubject: [PATCH] dlist: don't allow overwrite of arbitrary files\n\n---\n imap\/dlist.c | 12 +++---------\n 1 file changed, 3 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/imap\/dlist.c b\/imap\/dlist.c\nindex efe38b70c..aa1024c14 100644\n--- a\/imap\/dlist.c\n+++ b\/imap\/dlist.c\n@@ -141,16 +141,10 @@ EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,\n                                         const struct message_guid *guid)\n {\n     static char buf[MAX_MAILBOX_PATH];\n-    const char *base;\n \n-    \/* part can be either a configured partition name, or a path *\/\n-    if (strchr(part, '\/')) {\n-        base = part;\n-    }\n-    else {\n-        base = isarchive ? config_archivepartitiondir(part)\n-                         : config_partitiondir(part);\n-    }\n+    \/* part must be a configured partition name on this server *\/\n+    const char *base = isarchive ? config_archivepartitiondir(part)\n+                                 : config_partitiondir(part);\n \n     \/* we expect to have a base at this point, so let's assert that *\/\n     assert(base != NULL);\n","owner":"cyrusimap","repo":"cyrus-imapd","source":"cve"},{"CVE_ID":"CVE-2013-7266","CWE_ID":"20","category":"security","commit_id":"f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","commit_message":"From f3d3342602f8bcbf37d7c46641cb9bca7618eb1c Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Thu, 21 Nov 2013 03:14:22 +0100\nSubject: [PATCH] net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include\/linux\/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec\/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n crypto\/algif_hash.c            |  2 --\n crypto\/algif_skcipher.c        |  1 -\n drivers\/isdn\/mISDN\/socket.c    | 13 ++++---------\n drivers\/net\/ppp\/pppoe.c        |  2 --\n include\/linux\/net.h            |  8 ++++++++\n net\/appletalk\/ddp.c            | 16 +++++++---------\n net\/atm\/common.c               |  2 --\n net\/ax25\/af_ax25.c             |  4 ++--\n net\/bluetooth\/af_bluetooth.c   |  9 ++-------\n net\/bluetooth\/hci_sock.c       |  2 --\n net\/bluetooth\/rfcomm\/sock.c    |  1 -\n net\/bluetooth\/sco.c            |  1 -\n net\/caif\/caif_socket.c         |  4 ----\n net\/compat.c                   |  3 ++-\n net\/core\/iovec.c               |  3 ++-\n net\/ipx\/af_ipx.c               |  3 +--\n net\/irda\/af_irda.c             |  4 ----\n net\/iucv\/af_iucv.c             |  2 --\n net\/key\/af_key.c               |  1 -\n net\/l2tp\/l2tp_ppp.c            |  2 --\n net\/llc\/af_llc.c               |  2 --\n net\/netlink\/af_netlink.c       |  2 --\n net\/netrom\/af_netrom.c         |  3 +--\n net\/nfc\/llcp_sock.c            |  2 --\n net\/nfc\/rawsock.c              |  2 --\n net\/packet\/af_packet.c         | 32 +++++++++++++++-----------------\n net\/rds\/recv.c                 |  2 --\n net\/rose\/af_rose.c             |  8 +++++---\n net\/rxrpc\/ar-recvmsg.c         |  9 ++++++---\n net\/socket.c                   | 19 +++++++++++--------\n net\/tipc\/socket.c              |  6 ------\n net\/unix\/af_unix.c             |  5 -----\n net\/vmw_vsock\/af_vsock.c       |  2 --\n net\/vmw_vsock\/vmci_transport.c |  2 --\n net\/x25\/af_x25.c               |  3 +--\n 35 files changed, 67 insertions(+), 115 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/algif_hash.c b\/crypto\/algif_hash.c\nindex 0262210cad386..ef5356cd280a5 100644\n--- a\/crypto\/algif_hash.c\n+++ b\/crypto\/algif_hash.c\n@@ -161,8 +161,6 @@ static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\ndiff --git a\/crypto\/algif_skcipher.c b\/crypto\/algif_skcipher.c\nindex a1c4f0a555832..6a6dfc062d2a4 100644\n--- a\/crypto\/algif_skcipher.c\n+++ b\/crypto\/algif_skcipher.c\n@@ -432,7 +432,6 @@ static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n \tlong copied = 0;\n \n \tlock_sock(sk);\n-\tmsg->msg_namelen = 0;\n \tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n \t     iovlen--, iov++) {\n \t\tunsigned long seglen = iov->iov_len;\ndiff --git a\/drivers\/isdn\/mISDN\/socket.c b\/drivers\/isdn\/mISDN\/socket.c\nindex e47dcb9d1e91d..5cefb479c7072 100644\n--- a\/drivers\/isdn\/mISDN\/socket.c\n+++ b\/drivers\/isdn\/mISDN\/socket.c\n@@ -117,7 +117,6 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sk_buff\t\t*skb;\n \tstruct sock\t\t*sk = sock->sk;\n-\tstruct sockaddr_mISDN\t*maddr;\n \n \tint\t\tcopied, err;\n \n@@ -135,9 +134,9 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n-\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_mISDN *maddr = msg->msg_name;\n+\n \t\tmaddr->family = AF_ISDN;\n \t\tmaddr->dev = _pms(sk)->dev->id;\n \t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n@@ -150,11 +149,7 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n \t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n \t\t}\n-\t} else {\n-\t\tif (msg->msg_namelen)\n-\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n-\t\t\t       __func__, msg->msg_namelen);\n-\t\tmsg->msg_namelen = 0;\n+\t\tmsg->msg_namelen = sizeof(*maddr);\n \t}\n \n \tcopied = skb->len + MISDN_HEADER_LEN;\ndiff --git a\/drivers\/net\/ppp\/pppoe.c b\/drivers\/net\/ppp\/pppoe.c\nindex 5f66e30d98239..82ee6ed954cb8 100644\n--- a\/drivers\/net\/ppp\/pppoe.c\n+++ b\/drivers\/net\/ppp\/pppoe.c\n@@ -979,8 +979,6 @@ static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (error < 0)\n \t\tgoto end;\n \n-\tm->msg_namelen = 0;\n-\n \tif (skb) {\n \t\ttotal_len = min_t(size_t, total_len, skb->len);\n \t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\ndiff --git a\/include\/linux\/net.h b\/include\/linux\/net.h\nindex b292a04355717..4bcee94cef931 100644\n--- a\/include\/linux\/net.h\n+++ b\/include\/linux\/net.h\n@@ -164,6 +164,14 @@ struct proto_ops {\n #endif\n \tint\t\t(*sendmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len);\n+\t\/* Notes for implementing recvmsg:\n+\t * ===============================\n+\t * msg->msg_namelen should get updated by the recvmsg handlers\n+\t * iff msg_name != NULL. It is by default 0 to prevent\n+\t * returning uninitialized memory to user space.  The recvfrom\n+\t * handlers can assume that msg.msg_name is either NULL or has\n+\t * a minimum size of sizeof(struct sockaddr_storage).\n+\t *\/\n \tint\t\t(*recvmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len,\n \t\t\t\t      int flags);\ndiff --git a\/net\/appletalk\/ddp.c b\/net\/appletalk\/ddp.c\nindex 7fee50d637f95..7d424ac6e760b 100644\n--- a\/net\/appletalk\/ddp.c\n+++ b\/net\/appletalk\/ddp.c\n@@ -1735,7 +1735,6 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n-\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n@@ -1764,14 +1763,13 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n \n-\tif (!err) {\n-\t\tif (sat) {\n-\t\t\tsat->sat_family      = AF_APPLETALK;\n-\t\t\tsat->sat_port        = ddp->deh_sport;\n-\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n-\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n-\t\t}\n-\t\tmsg->msg_namelen = sizeof(*sat);\n+\tif (!err && msg->msg_name) {\n+\t\tstruct sockaddr_at *sat = msg->msg_name;\n+\t\tsat->sat_family      = AF_APPLETALK;\n+\t\tsat->sat_port        = ddp->deh_sport;\n+\t\tsat->sat_addr.s_node = ddp->deh_snode;\n+\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n+\t\tmsg->msg_namelen     = sizeof(*sat);\n \t}\n \n \tskb_free_datagram(sk, skb);\t\/* Free the datagram. *\/\ndiff --git a\/net\/atm\/common.c b\/net\/atm\/common.c\nindex 737bef59ce899..7b491006eaf40 100644\n--- a\/net\/atm\/common.c\n+++ b\/net\/atm\/common.c\n@@ -531,8 +531,6 @@ int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n \ndiff --git a\/net\/ax25\/af_ax25.c b\/net\/ax25\/af_ax25.c\nindex a00123ebb0ae0..7bb1605bdfd99 100644\n--- a\/net\/ax25\/af_ax25.c\n+++ b\/net\/ax25\/af_ax25.c\n@@ -1636,11 +1636,11 @@ static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (msg->msg_namelen != 0) {\n-\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n+\tif (msg->msg_name) {\n \t\tax25_digi digi;\n \t\tax25_address src;\n \t\tconst unsigned char *mac = skb_mac_header(skb);\n+\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n \n \t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n \t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\ndiff --git a\/net\/bluetooth\/af_bluetooth.c b\/net\/bluetooth\/af_bluetooth.c\nindex f6a1671ea2ff7..56ca494621c66 100644\n--- a\/net\/bluetooth\/af_bluetooth.c\n+++ b\/net\/bluetooth\/af_bluetooth.c\n@@ -224,10 +224,9 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n-\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n-\t\t\tmsg->msg_namelen = 0;\n+\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n-\t\t}\n+\n \t\treturn err;\n \t}\n \n@@ -245,8 +244,6 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tif (bt_sk(sk)->skb_msg_name)\n \t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n \t\t\t\t\t\t&msg->msg_namelen);\n-\t\telse\n-\t\t\tmsg->msg_namelen = 0;\n \t}\n \n \tskb_free_datagram(sk, skb);\n@@ -295,8 +292,6 @@ int bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \tBT_DBG(\"sk %p size %zu\", sk, size);\n \n \tlock_sock(sk);\ndiff --git a\/net\/bluetooth\/hci_sock.c b\/net\/bluetooth\/hci_sock.c\nindex 71f0be1730801..6a6c8bb4fd72d 100644\n--- a\/net\/bluetooth\/hci_sock.c\n+++ b\/net\/bluetooth\/hci_sock.c\n@@ -856,8 +856,6 @@ static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/bluetooth\/rfcomm\/sock.c b\/net\/bluetooth\/rfcomm\/sock.c\nindex c4d3d423f89b8..c80766f892c36 100644\n--- a\/net\/bluetooth\/rfcomm\/sock.c\n+++ b\/net\/bluetooth\/rfcomm\/sock.c\n@@ -615,7 +615,6 @@ static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n-\t\tmsg->msg_namelen = 0;\n \t\treturn 0;\n \t}\n \ndiff --git a\/net\/bluetooth\/sco.c b\/net\/bluetooth\/sco.c\nindex 12a0e51e21e13..24fa3964b3c84 100644\n--- a\/net\/bluetooth\/sco.c\n+++ b\/net\/bluetooth\/sco.c\n@@ -711,7 +711,6 @@ static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n \t\tsk->sk_state = BT_CONFIG;\n-\t\tmsg->msg_namelen = 0;\n \n \t\trelease_sock(sk);\n \t\treturn 0;\ndiff --git a\/net\/caif\/caif_socket.c b\/net\/caif\/caif_socket.c\nindex 05a41c7ec304e..d6be3edb7a434 100644\n--- a\/net\/caif\/caif_socket.c\n+++ b\/net\/caif\/caif_socket.c\n@@ -286,8 +286,6 @@ static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (m->msg_flags&MSG_OOB)\n \t\tgoto read_error;\n \n-\tm->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n \tif (!skb)\n \t\tgoto read_error;\n@@ -361,8 +359,6 @@ static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/*\n \t * Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\ndiff --git a\/net\/compat.c b\/net\/compat.c\nindex 89032580bd1d8..618c6a8a911b6 100644\n--- a\/net\/compat.c\n+++ b\/net\/compat.c\n@@ -93,7 +93,8 @@ int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tkern_msg->msg_name = kern_address;\n+\t\tif (kern_msg->msg_name)\n+\t\t\tkern_msg->msg_name = kern_address;\n \t} else\n \t\tkern_msg->msg_name = NULL;\n \ndiff --git a\/net\/core\/iovec.c b\/net\/core\/iovec.c\nindex 4cdb7c48dad6c..b61869429f4ce 100644\n--- a\/net\/core\/iovec.c\n+++ b\/net\/core\/iovec.c\n@@ -48,7 +48,8 @@ int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *a\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tm->msg_name = address;\n+\t\tif (m->msg_name)\n+\t\t\tm->msg_name = address;\n \t} else {\n \t\tm->msg_name = NULL;\n \t}\ndiff --git a\/net\/ipx\/af_ipx.c b\/net\/ipx\/af_ipx.c\nindex 7a1e0fc1bd4dd..e096025b477f3 100644\n--- a\/net\/ipx\/af_ipx.c\n+++ b\/net\/ipx\/af_ipx.c\n@@ -1823,8 +1823,6 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n-\tmsg->msg_namelen = sizeof(*sipx);\n-\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n@@ -1832,6 +1830,7 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n+\t\tmsg->msg_namelen\t= sizeof(*sipx);\n \t}\n \trc = copied;\n \ndiff --git a\/net\/irda\/af_irda.c b\/net\/irda\/af_irda.c\nindex 0f676908d15b6..de7db23049f14 100644\n--- a\/net\/irda\/af_irda.c\n+++ b\/net\/irda\/af_irda.c\n@@ -1385,8 +1385,6 @@ static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n \n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \n-\tmsg->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n@@ -1451,8 +1449,6 @@ static int irda_recvmsg_stream(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, noblock);\n \n-\tmsg->msg_namelen = 0;\n-\n \tdo {\n \t\tint chunk;\n \t\tstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\ndiff --git a\/net\/iucv\/af_iucv.c b\/net\/iucv\/af_iucv.c\nindex 168aff5e60de5..c4b7218058b64 100644\n--- a\/net\/iucv\/af_iucv.c\n+++ b\/net\/iucv\/af_iucv.c\n@@ -1324,8 +1324,6 @@ static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint err = 0;\n \tu32 offset;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif ((sk->sk_state == IUCV_DISCONN) &&\n \t    skb_queue_empty(&iucv->backlog_skb_q) &&\n \t    skb_queue_empty(&sk->sk_receive_queue) &&\ndiff --git a\/net\/key\/af_key.c b\/net\/key\/af_key.c\nindex 911ef03bf8fbf..545f047868ad8 100644\n--- a\/net\/key\/af_key.c\n+++ b\/net\/key\/af_key.c\n@@ -3616,7 +3616,6 @@ static int pfkey_recvmsg(struct kiocb *kiocb,\n \tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n \tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n \tif (skb == NULL)\n \t\tgoto out;\ndiff --git a\/net\/l2tp\/l2tp_ppp.c b\/net\/l2tp\/l2tp_ppp.c\nindex ffda81ef1a709..be5fadf347394 100644\n--- a\/net\/l2tp\/l2tp_ppp.c\n+++ b\/net\/l2tp\/l2tp_ppp.c\n@@ -197,8 +197,6 @@ static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sk->sk_state & PPPOX_BOUND)\n \t\tgoto end;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = 0;\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\ndiff --git a\/net\/llc\/af_llc.c b\/net\/llc\/af_llc.c\nindex 6cba486353e8a..7b01b9f5846c8 100644\n--- a\/net\/llc\/af_llc.c\n+++ b\/net\/llc\/af_llc.c\n@@ -720,8 +720,6 @@ static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint target;\t\/* Read at least this many bytes *\/\n \tlong timeo;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tcopied = -ENOTCONN;\n \tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\ndiff --git a\/net\/netlink\/af_netlink.c b\/net\/netlink\/af_netlink.c\nindex f0176e1a5a81a..bca50b95c1823 100644\n--- a\/net\/netlink\/af_netlink.c\n+++ b\/net\/netlink\/af_netlink.c\n@@ -2335,8 +2335,6 @@ static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,\n \t}\n #endif\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = data_skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/netrom\/af_netrom.c b\/net\/netrom\/af_netrom.c\nindex 698814bfa7adf..53c19a35fc6dc 100644\n--- a\/net\/netrom\/af_netrom.c\n+++ b\/net\/netrom\/af_netrom.c\n@@ -1179,10 +1179,9 @@ static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n+\t\tmsg->msg_namelen = sizeof(*sax);\n \t}\n \n-\tmsg->msg_namelen = sizeof(*sax);\n-\n \tskb_free_datagram(sk, skb);\n \n \trelease_sock(sk);\ndiff --git a\/net\/nfc\/llcp_sock.c b\/net\/nfc\/llcp_sock.c\nindex d308402b67d80..824c6056bf823 100644\n--- a\/net\/nfc\/llcp_sock.c\n+++ b\/net\/nfc\/llcp_sock.c\n@@ -807,8 +807,6 @@ static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tpr_debug(\"%p %zu\\n\", sk, len);\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state == LLCP_CLOSED &&\ndiff --git a\/net\/nfc\/rawsock.c b\/net\/nfc\/rawsock.c\nindex cd958b381f961..66bcd2eb57737 100644\n--- a\/net\/nfc\/rawsock.c\n+++ b\/net\/nfc\/rawsock.c\n@@ -244,8 +244,6 @@ static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn rc;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/packet\/af_packet.c b\/net\/packet\/af_packet.c\nindex 2e8286b47c28e..61bd50adead1c 100644\n--- a\/net\/packet\/af_packet.c\n+++ b\/net\/packet\/af_packet.c\n@@ -2660,7 +2660,6 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tstruct sock *sk = sock->sk;\n \tstruct sk_buff *skb;\n \tint copied, err;\n-\tstruct sockaddr_ll *sll;\n \tint vnet_hdr_len = 0;\n \n \terr = -EINVAL;\n@@ -2744,22 +2743,10 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tgoto out_free;\n \t}\n \n-\t\/*\n-\t *\tIf the address length field is there to be filled in, we fill\n-\t *\tit in now.\n-\t *\/\n-\n-\tsll = &PACKET_SKB_CB(skb)->sa.ll;\n-\tif (sock->type == SOCK_PACKET)\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n-\telse\n-\t\tmsg->msg_namelen = sll->sll_halen + offsetof(struct sockaddr_ll, sll_addr);\n-\n-\t\/*\n-\t *\tYou lose any data beyond the buffer you gave. If it worries a\n-\t *\tuser program they can ask the device for its MTU anyway.\n+\t\/* You lose any data beyond the buffer you gave. If it worries\n+\t * a user program they can ask the device for its MTU\n+\t * anyway.\n \t *\/\n-\n \tcopied = skb->len;\n \tif (copied > len) {\n \t\tcopied = len;\n@@ -2772,9 +2759,20 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n \n-\tif (msg->msg_name)\n+\tif (msg->msg_name) {\n+\t\t\/* If the address length field is there to be filled\n+\t\t * in, we fill it in now.\n+\t\t *\/\n+\t\tif (sock->type == SOCK_PACKET) {\n+\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n+\t\t} else {\n+\t\t\tstruct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;\n+\t\t\tmsg->msg_namelen = sll->sll_halen +\n+\t\t\t\toffsetof(struct sockaddr_ll, sll_addr);\n+\t\t}\n \t\tmemcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa,\n \t\t       msg->msg_namelen);\n+\t}\n \n \tif (pkt_sk(sk)->auxdata) {\n \t\tstruct tpacket_auxdata aux;\ndiff --git a\/net\/rds\/recv.c b\/net\/rds\/recv.c\nindex 9f0f17cf6bf9b..de339b24ca140 100644\n--- a\/net\/rds\/recv.c\n+++ b\/net\/rds\/recv.c\n@@ -410,8 +410,6 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n \ndiff --git a\/net\/rose\/af_rose.c b\/net\/rose\/af_rose.c\nindex e98fcfbe60079..33af77246bfeb 100644\n--- a\/net\/rose\/af_rose.c\n+++ b\/net\/rose\/af_rose.c\n@@ -1216,7 +1216,6 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sock *sk = sock->sk;\n \tstruct rose_sock *rose = rose_sk(sk);\n-\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n \tsize_t copied;\n \tunsigned char *asmptr;\n \tstruct sk_buff *skb;\n@@ -1252,8 +1251,11 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (srose != NULL) {\n-\t\tmemset(srose, 0, msg->msg_namelen);\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_rose *srose;\n+\n+\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n+\t\tsrose = msg->msg_name;\n \t\tsrose->srose_family = AF_ROSE;\n \t\tsrose->srose_addr   = rose->dest_addr;\n \t\tsrose->srose_call   = rose->dest_call;\ndiff --git a\/net\/rxrpc\/ar-recvmsg.c b\/net\/rxrpc\/ar-recvmsg.c\nindex 4b48687c3890f..898492a8d61be 100644\n--- a\/net\/rxrpc\/ar-recvmsg.c\n+++ b\/net\/rxrpc\/ar-recvmsg.c\n@@ -143,10 +143,13 @@ int rxrpc_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \t\t\/* copy the peer address and timestamp *\/\n \t\tif (!continue_call) {\n-\t\t\tif (msg->msg_name && msg->msg_namelen > 0)\n+\t\t\tif (msg->msg_name) {\n+\t\t\t\tsize_t len =\n+\t\t\t\t\tsizeof(call->conn->trans->peer->srx);\n \t\t\t\tmemcpy(msg->msg_name,\n-\t\t\t\t       &call->conn->trans->peer->srx,\n-\t\t\t\t       sizeof(call->conn->trans->peer->srx));\n+\t\t\t\t       &call->conn->trans->peer->srx, len);\n+\t\t\t\tmsg->msg_namelen = len;\n+\t\t\t}\n \t\t\tsock_recv_ts_and_drops(msg, &rx->sk, skb);\n \t\t}\n \ndiff --git a\/net\/socket.c b\/net\/socket.c\nindex c226aceee65b8..fc285564e49ec 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -1840,8 +1840,10 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n \tmsg.msg_iov = &iov;\n \tiov.iov_len = size;\n \tiov.iov_base = ubuf;\n-\tmsg.msg_name = (struct sockaddr *)&address;\n-\tmsg.msg_namelen = sizeof(address);\n+\t\/* Save some cycles and don't copy the address if not needed *\/\n+\tmsg.msg_name = addr ? (struct sockaddr *)&address : NULL;\n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg.msg_namelen = 0;\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = sock_recvmsg(sock, &msg, size, flags);\n@@ -2221,16 +2223,14 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \t\t\tgoto out;\n \t}\n \n-\t\/*\n-\t *      Save the user-mode address (verify_iovec will change the\n-\t *      kernel msghdr to use the kernel address space)\n+\t\/* Save the user-mode address (verify_iovec will change the\n+\t * kernel msghdr to use the kernel address space)\n \t *\/\n-\n \tuaddr = (__force void __user *)msg_sys->msg_name;\n \tuaddr_len = COMPAT_NAMELEN(msg);\n-\tif (MSG_CMSG_COMPAT & flags) {\n+\tif (MSG_CMSG_COMPAT & flags)\n \t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n-\t} else\n+\telse\n \t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n \tif (err < 0)\n \t\tgoto out_freeiov;\n@@ -2239,6 +2239,9 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n \tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n \n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg_sys->msg_namelen = 0;\n+\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\ndiff --git a\/net\/tipc\/socket.c b\/net\/tipc\/socket.c\nindex 3906527259d19..3b61851bb9276 100644\n--- a\/net\/tipc\/socket.c\n+++ b\/net\/tipc\/socket.c\n@@ -980,9 +980,6 @@ static int recv_msg(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n restart:\n \n@@ -1091,9 +1088,6 @@ static int recv_stream(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n \ndiff --git a\/net\/unix\/af_unix.c b\/net\/unix\/af_unix.c\nindex c1f403bed683e..01625ccc3ae64 100644\n--- a\/net\/unix\/af_unix.c\n+++ b\/net\/unix\/af_unix.c\n@@ -1754,7 +1754,6 @@ static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n {\n \tstruct unix_sock *u = unix_sk(sk);\n \n-\tmsg->msg_namelen = 0;\n \tif (u->addr) {\n \t\tmsg->msg_namelen = u->addr->len;\n \t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n@@ -1778,8 +1777,6 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = mutex_lock_interruptible(&u->readlock);\n \tif (err) {\n \t\terr = sock_intr_errno(sock_rcvtimeo(sk, noblock));\n@@ -1924,8 +1921,6 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\n \t *\/\ndiff --git a\/net\/vmw_vsock\/af_vsock.c b\/net\/vmw_vsock\/af_vsock.c\nindex 545c08b8a1d48..5adfd94c5b85d 100644\n--- a\/net\/vmw_vsock\/af_vsock.c\n+++ b\/net\/vmw_vsock\/af_vsock.c\n@@ -1662,8 +1662,6 @@ vsock_stream_recvmsg(struct kiocb *kiocb,\n \tvsk = vsock_sk(sk);\n \terr = 0;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state != SS_CONNECTED) {\ndiff --git a\/net\/vmw_vsock\/vmci_transport.c b\/net\/vmw_vsock\/vmci_transport.c\nindex 9d6986634e0bf..687360da62d9f 100644\n--- a\/net\/vmw_vsock\/vmci_transport.c\n+++ b\/net\/vmw_vsock\/vmci_transport.c\n@@ -1746,8 +1746,6 @@ static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Retrieve the head sk_buff from the socket's receive queue. *\/\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\ndiff --git a\/net\/x25\/af_x25.c b\/net\/x25\/af_x25.c\nindex 45a3ab5612c13..7622789d37501 100644\n--- a\/net\/x25\/af_x25.c\n+++ b\/net\/x25\/af_x25.c\n@@ -1340,10 +1340,9 @@ static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n+\t\tmsg->msg_namelen = sizeof(*sx25);\n \t}\n \n-\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n-\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-6302","CWE_ID":"20","category":"security","commit_id":"e97763c92c655dcf4af2860b3abd2bc4c8a267f9","commit_message":"From e97763c92c655dcf4af2860b3abd2bc4c8a267f9 Mon Sep 17 00:00:00 2001\nFrom: \"Dr. Stephen Henson\" <steve@openssl.org>\nDate: Mon, 22 Aug 2016 17:20:01 +0100\nSubject: [PATCH] Sanity check ticket length.\n\nIf a ticket callback changes the HMAC digest to SHA512 the existing\nsanity checks are not sufficient and an attacker could perform a DoS\nattack with a malformed ticket. Add additional checks based on\nHMAC size.\n\nThanks to Shi Lei for reporting this bug.\n\nCVE-2016-6302\n\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\n---\n ssl\/t1_lib.c | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/ssl\/t1_lib.c b\/ssl\/t1_lib.c\nindex 938f8be15f..b8f8fd22fe 100644\n--- a\/ssl\/t1_lib.c\n+++ b\/ssl\/t1_lib.c\n@@ -2969,9 +2969,7 @@ static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\n     HMAC_CTX *hctx = NULL;\n     EVP_CIPHER_CTX *ctx;\n     SSL_CTX *tctx = s->initial_ctx;\n-    \/* Need at least keyname + iv + some encrypted data *\/\n-    if (eticklen < 48)\n-        return 2;\n+\n     \/* Initialize session ticket encryption and HMAC contexts *\/\n     hctx = HMAC_CTX_new();\n     if (hctx == NULL)\n@@ -3018,6 +3016,12 @@ static int tls_decrypt_ticket(SSL *s, const unsigned char *etick,\n     if (mlen < 0) {\n         goto err;\n     }\n+    \/* Sanity check ticket length: must exceed keyname + IV + HMAC *\/\n+    if (eticklen <=\n+        TLSEXT_KEYNAME_LENGTH + EVP_CIPHER_CTX_iv_length(ctx) + mlen) {\n+        ret = 2;\n+        goto err;\n+    }\n     eticklen -= mlen;\n     \/* Check HMAC of encrypted ticket *\/\n     if (HMAC_Update(hctx, etick, eticklen) <= 0\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-5390","CWE_ID":"20","category":"security","commit_id":"72cd43ba64fc172a443410ce01645895850844c8","commit_message":"From 72cd43ba64fc172a443410ce01645895850844c8 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Mon, 23 Jul 2018 09:28:17 -0700\nSubject: tcp: free batches of packets in tcp_prune_ofo_queue()\n\nJuha-Matti Tilli reported that malicious peers could inject tiny\npackets in out_of_order_queue, forcing very expensive calls\nto tcp_collapse_ofo_queue() and tcp_prune_ofo_queue() for\nevery incoming packet. out_of_order_queue rb-tree can contain\nthousands of nodes, iterating over all of them is not nice.\n\nBefore linux-4.9, we would have pruned all packets in ofo_queue\nin one go, every XXXX packets. XXXX depends on sk_rcvbuf and skbs\ntruesize, but is about 7000 packets with tcp_rmem[2] default of 6 MB.\n\nSince we plan to increase tcp_rmem[2] in the future to cope with\nmodern BDP, can not revert to the old behavior, without great pain.\n\nStrategy taken in this patch is to purge ~12.5 % of the queue capacity.\n\nFixes: 36a6503fedda (\"tcp: refine tcp_prune_ofo_queue() to not drop all packets\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Juha-Matti Tilli <juha-matti.tilli@iki.fi>\nAcked-by: Yuchung Cheng <ycheng@google.com>\nAcked-by: Soheil Hassas Yeganeh <soheil@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp_input.c | 15 +++++++++++----\n 1 file changed, 11 insertions(+), 4 deletions(-)\n\nFrom f4a3313d8e2ca9fd8d8f45e40a2903ba782607e7 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Mon, 23 Jul 2018 09:28:18 -0700\nSubject: tcp: avoid collapses in tcp_prune_queue() if possible\n\nRight after a TCP flow is created, receiving tiny out of order\npackets allways hit the condition :\n\nif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\ttcp_clamp_window(sk);\n\ntcp_clamp_window() increases sk_rcvbuf to match sk_rmem_alloc\n(guarded by tcp_rmem[2])\n\nCalling tcp_collapse_ofo_queue() in this case is not useful,\nand offers a O(N^2) surface attack to malicious peers.\n\nBetter not attempt anything before full queue capacity is reached,\nforcing attacker to spend lots of resource and allow us to more\neasily detect the abuse.\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Soheil Hassas Yeganeh <soheil@google.com>\nAcked-by: Yuchung Cheng <ycheng@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp_input.c | 3 +++\n 1 file changed, 3 insertions(+)\n\nFrom 3d4bf93ac12003f9b8e1e2de37fe27983deebdcf Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Mon, 23 Jul 2018 09:28:19 -0700\nSubject: tcp: detect malicious patterns in tcp_collapse_ofo_queue()\n\nIn case an attacker feeds tiny packets completely out of order,\ntcp_collapse_ofo_queue() might scan the whole rb-tree, performing\nexpensive copies, but not changing socket memory usage at all.\n\n1) Do not attempt to collapse tiny skbs.\n2) Add logic to exit early when too many tiny skbs are detected.\n\nWe prefer not doing aggressive collapsing (which copies packets)\nfor pathological flows, and revert to tcp_prune_ofo_queue() which\nwill be less expensive.\n\nIn the future, we might add the possibility of terminating flows\nthat are proven to be malicious.\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Soheil Hassas Yeganeh <soheil@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp_input.c | 15 +++++++++++++--\n 1 file changed, 13 insertions(+), 2 deletions(-)\n\nFrom 8541b21e781a22dce52a74fef0b9bed00404a1cd Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Mon, 23 Jul 2018 09:28:20 -0700\nSubject: tcp: call tcp_drop() from tcp_data_queue_ofo()\n\nIn order to be able to give better diagnostics and detect\nmalicious traffic, we need to have better sk->sk_drops tracking.\n\nFixes: 9f5afeae5152 (\"tcp: use an RB tree for ooo receive queue\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Soheil Hassas Yeganeh <soheil@google.com>\nAcked-by: Yuchung Cheng <ycheng@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp_input.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\nFrom 58152ecbbcc6a0ce7fddd5bf5f6ee535834ece0c Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Mon, 23 Jul 2018 09:28:21 -0700\nSubject: tcp: add tcp_ooo_try_coalesce() helper\n\nIn case skb in out_or_order_queue is the result of\nmultiple skbs coalescing, we would like to get a proper gso_segs\ncounter tracking, so that future tcp_drop() can report an accurate\nnumber.\n\nI chose to not implement this tracking for skbs in receive queue,\nsince they are not dropped, unless socket is disconnected.\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Soheil Hassas Yeganeh <soheil@google.com>\nAcked-by: Yuchung Cheng <ycheng@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/tcp_input.c | 25 +++++++++++++++++++++----\n 1 file changed, 21 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/net\/ipv4\/tcp_input.c b\/net\/ipv4\/tcp_input.c\nindex 6bade06aaf72..64e45b279431 100644\n--- a\/net\/ipv4\/tcp_input.c\n+++ b\/net\/ipv4\/tcp_input.c\n@@ -4942,6 +4942,7 @@ new_range:\n  * 2) not add too big latencies if thousands of packets sit there.\n  *    (But if application shrinks SO_RCVBUF, we could still end up\n  *     freeing whole queue here)\n+ * 3) Drop at least 12.5 % of sk_rcvbuf to avoid malicious attacks.\n  *\n  * Return true if queue has shrunk.\n  *\/\n@@ -4949,20 +4950,26 @@ static bool tcp_prune_ofo_queue(struct sock *sk)\n {\n \tstruct tcp_sock *tp = tcp_sk(sk);\n \tstruct rb_node *node, *prev;\n+\tint goal;\n \n \tif (RB_EMPTY_ROOT(&tp->out_of_order_queue))\n \t\treturn false;\n \n \tNET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);\n+\tgoal = sk->sk_rcvbuf >> 3;\n \tnode = &tp->ooo_last_skb->rbnode;\n \tdo {\n \t\tprev = rb_prev(node);\n \t\trb_erase(node, &tp->out_of_order_queue);\n+\t\tgoal -= rb_to_skb(node)->truesize;\n \t\ttcp_drop(sk, rb_to_skb(node));\n-\t\tsk_mem_reclaim(sk);\n-\t\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf &&\n-\t\t    !tcp_under_memory_pressure(sk))\n-\t\t\tbreak;\n+\t\tif (!prev || goal <= 0) {\n+\t\t\tsk_mem_reclaim(sk);\n+\t\t\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf &&\n+\t\t\t    !tcp_under_memory_pressure(sk))\n+\t\t\t\tbreak;\n+\t\t\tgoal = sk->sk_rcvbuf >> 3;\n+\t\t}\n \t\tnode = prev;\n \t} while (node);\n \ttp->ooo_last_skb = rb_to_skb(prev);\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/net\/ipv4\/tcp_input.c b\/net\/ipv4\/tcp_input.c\nindex 64e45b279431..53289911362a 100644\n--- a\/net\/ipv4\/tcp_input.c\n+++ b\/net\/ipv4\/tcp_input.c\n@@ -5004,6 +5004,9 @@ static int tcp_prune_queue(struct sock *sk)\n \telse if (tcp_under_memory_pressure(sk))\n \t\ttp->rcv_ssthresh = min(tp->rcv_ssthresh, 4U * tp->advmss);\n \n+\tif (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n+\t\treturn 0;\n+\n \ttcp_collapse_ofo_queue(sk);\n \tif (!skb_queue_empty(&sk->sk_receive_queue))\n \t\ttcp_collapse(sk, &sk->sk_receive_queue, NULL,\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/net\/ipv4\/tcp_input.c b\/net\/ipv4\/tcp_input.c\nindex 53289911362a..78068b902e7b 100644\n--- a\/net\/ipv4\/tcp_input.c\n+++ b\/net\/ipv4\/tcp_input.c\n@@ -4902,6 +4902,7 @@ end:\n static void tcp_collapse_ofo_queue(struct sock *sk)\n {\n \tstruct tcp_sock *tp = tcp_sk(sk);\n+\tu32 range_truesize, sum_tiny = 0;\n \tstruct sk_buff *skb, *head;\n \tu32 start, end;\n \n@@ -4913,6 +4914,7 @@ new_range:\n \t}\n \tstart = TCP_SKB_CB(skb)->seq;\n \tend = TCP_SKB_CB(skb)->end_seq;\n+\trange_truesize = skb->truesize;\n \n \tfor (head = skb;;) {\n \t\tskb = skb_rb_next(skb);\n@@ -4923,11 +4925,20 @@ new_range:\n \t\tif (!skb ||\n \t\t    after(TCP_SKB_CB(skb)->seq, end) ||\n \t\t    before(TCP_SKB_CB(skb)->end_seq, start)) {\n-\t\t\ttcp_collapse(sk, NULL, &tp->out_of_order_queue,\n-\t\t\t\t     head, skb, start, end);\n+\t\t\t\/* Do not attempt collapsing tiny skbs *\/\n+\t\t\tif (range_truesize != head->truesize ||\n+\t\t\t    end - start >= SKB_WITH_OVERHEAD(SK_MEM_QUANTUM)) {\n+\t\t\t\ttcp_collapse(sk, NULL, &tp->out_of_order_queue,\n+\t\t\t\t\t     head, skb, start, end);\n+\t\t\t} else {\n+\t\t\t\tsum_tiny += range_truesize;\n+\t\t\t\tif (sum_tiny > sk->sk_rcvbuf >> 3)\n+\t\t\t\t\treturn;\n+\t\t\t}\n \t\t\tgoto new_range;\n \t\t}\n \n+\t\trange_truesize += skb->truesize;\n \t\tif (unlikely(before(TCP_SKB_CB(skb)->seq, start)))\n \t\t\tstart = TCP_SKB_CB(skb)->seq;\n \t\tif (after(TCP_SKB_CB(skb)->end_seq, end))\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/net\/ipv4\/tcp_input.c b\/net\/ipv4\/tcp_input.c\nindex 78068b902e7b..b062a7692238 100644\n--- a\/net\/ipv4\/tcp_input.c\n+++ b\/net\/ipv4\/tcp_input.c\n@@ -4510,7 +4510,7 @@ coalesce_done:\n \t\t\t\t\/* All the bits are present. Drop. *\/\n \t\t\t\tNET_INC_STATS(sock_net(sk),\n \t\t\t\t\t      LINUX_MIB_TCPOFOMERGE);\n-\t\t\t\t__kfree_skb(skb);\n+\t\t\t\ttcp_drop(sk, skb);\n \t\t\t\tskb = NULL;\n \t\t\t\ttcp_dsack_set(sk, seq, end_seq);\n \t\t\t\tgoto add_sack;\n@@ -4529,7 +4529,7 @@ coalesce_done:\n \t\t\t\t\t\t TCP_SKB_CB(skb1)->end_seq);\n \t\t\t\tNET_INC_STATS(sock_net(sk),\n \t\t\t\t\t      LINUX_MIB_TCPOFOMERGE);\n-\t\t\t\t__kfree_skb(skb1);\n+\t\t\t\ttcp_drop(sk, skb1);\n \t\t\t\tgoto merge_right;\n \t\t\t}\n \t\t} else if (tcp_try_coalesce(sk, skb1,\n-- \ncgit 1.2-0.3.lf.el7\n\n\ndiff --git a\/net\/ipv4\/tcp_input.c b\/net\/ipv4\/tcp_input.c\nindex b062a7692238..3bcd30a2ba06 100644\n--- a\/net\/ipv4\/tcp_input.c\n+++ b\/net\/ipv4\/tcp_input.c\n@@ -4358,6 +4358,23 @@ static bool tcp_try_coalesce(struct sock *sk,\n \treturn true;\n }\n \n+static bool tcp_ooo_try_coalesce(struct sock *sk,\n+\t\t\t     struct sk_buff *to,\n+\t\t\t     struct sk_buff *from,\n+\t\t\t     bool *fragstolen)\n+{\n+\tbool res = tcp_try_coalesce(sk, to, from, fragstolen);\n+\n+\t\/* In case tcp_drop() is called later, update to->gso_segs *\/\n+\tif (res) {\n+\t\tu32 gso_segs = max_t(u16, 1, skb_shinfo(to)->gso_segs) +\n+\t\t\t       max_t(u16, 1, skb_shinfo(from)->gso_segs);\n+\n+\t\tskb_shinfo(to)->gso_segs = min_t(u32, gso_segs, 0xFFFF);\n+\t}\n+\treturn res;\n+}\n+\n static void tcp_drop(struct sock *sk, struct sk_buff *skb)\n {\n \tsk_drops_add(sk, skb);\n@@ -4481,8 +4498,8 @@ static void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb)\n \t\/* In the typical case, we are adding an skb to the end of the list.\n \t * Use of ooo_last_skb avoids the O(Log(N)) rbtree lookup.\n \t *\/\n-\tif (tcp_try_coalesce(sk, tp->ooo_last_skb,\n-\t\t\t     skb, &fragstolen)) {\n+\tif (tcp_ooo_try_coalesce(sk, tp->ooo_last_skb,\n+\t\t\t\t skb, &fragstolen)) {\n coalesce_done:\n \t\ttcp_grow_window(sk, skb);\n \t\tkfree_skb_partial(skb, fragstolen);\n@@ -4532,8 +4549,8 @@ coalesce_done:\n \t\t\t\ttcp_drop(sk, skb1);\n \t\t\t\tgoto merge_right;\n \t\t\t}\n-\t\t} else if (tcp_try_coalesce(sk, skb1,\n-\t\t\t\t\t    skb, &fragstolen)) {\n+\t\t} else if (tcp_ooo_try_coalesce(sk, skb1,\n+\t\t\t\t\t\tskb, &fragstolen)) {\n \t\t\tgoto coalesce_done;\n \t\t}\n \t\tp = &parent->rb_right;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-18021","CWE_ID":"20","category":"security","commit_id":"2a3f93459d689d990b3ecfbe782fec89b97d3279","commit_message":"From 2a3f93459d689d990b3ecfbe782fec89b97d3279 Mon Sep 17 00:00:00 2001\nFrom: Marc Zyngier <marc.zyngier@arm.com>\nDate: Thu, 27 Sep 2018 16:53:22 +0100\nSubject: arm64: KVM: Sanitize PSTATE.M when being set from userspace\n\nNot all execution modes are valid for a guest, and some of them\ndepend on what the HW actually supports. Let's verify that what\nuserspace provides is compatible with both the VM settings and\nthe HW capabilities.\n\nCc: <stable@vger.kernel.org>\nFixes: 0d854a60b1d7 (\"arm64: KVM: enable initialization of a 32bit vcpu\")\nReviewed-by: Christoffer Dall <christoffer.dall@arm.com>\nReviewed-by: Mark Rutland <mark.rutland@arm.com>\nReviewed-by: Dave Martin <Dave.Martin@arm.com>\nSigned-off-by: Marc Zyngier <marc.zyngier@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>\n---\n arch\/arm64\/kvm\/guest.c | 10 +++++++++-\n 1 file changed, 9 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/arm64\/kvm\/guest.c b\/arch\/arm64\/kvm\/guest.c\nindex 3088463bafc1..a6c9fbaeaefc 100644\n--- a\/arch\/arm64\/kvm\/guest.c\n+++ b\/arch\/arm64\/kvm\/guest.c\n@@ -152,17 +152,25 @@ static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n \t}\n \n \tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n-\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n+\t\tu64 mode = (*(u64 *)valp) & PSR_AA32_MODE_MASK;\n \t\tswitch (mode) {\n \t\tcase PSR_AA32_MODE_USR:\n+\t\t\tif (!system_supports_32bit_el0())\n+\t\t\t\treturn -EINVAL;\n+\t\t\tbreak;\n \t\tcase PSR_AA32_MODE_FIQ:\n \t\tcase PSR_AA32_MODE_IRQ:\n \t\tcase PSR_AA32_MODE_SVC:\n \t\tcase PSR_AA32_MODE_ABT:\n \t\tcase PSR_AA32_MODE_UND:\n+\t\t\tif (!vcpu_el1_is_32bit(vcpu))\n+\t\t\t\treturn -EINVAL;\n+\t\t\tbreak;\n \t\tcase PSR_MODE_EL0t:\n \t\tcase PSR_MODE_EL1t:\n \t\tcase PSR_MODE_EL1h:\n+\t\t\tif (vcpu_el1_is_32bit(vcpu))\n+\t\t\t\treturn -EINVAL;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\terr = -EINVAL;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-2549","CWE_ID":"20","category":"security","commit_id":"2ba1fe7a06d3624f9a7586d672b55f08f7c670f3","commit_message":"From 2ba1fe7a06d3624f9a7586d672b55f08f7c670f3 Mon Sep 17 00:00:00 2001\nFrom: Takashi Iwai <tiwai@suse.de>\nDate: Mon, 18 Jan 2016 13:52:47 +0100\nSubject: [PATCH] ALSA: hrtimer: Fix stall by hrtimer_cancel()\n\nhrtimer_cancel() waits for the completion from the callback, thus it\nmust not be called inside the callback itself.  This was already a\nproblem in the past with ALSA hrtimer driver, and the early commit\n[fcfdebe70759: ALSA: hrtimer - Fix lock-up] tried to address it.\n\nHowever, the previous fix is still insufficient: it may still cause a\nlockup when the ALSA timer instance reprograms itself in its callback.\nThen it invokes the start function even in snd_timer_interrupt() that\nis called in hrtimer callback itself, results in a CPU stall.  This is\nno hypothetical problem but actually triggered by syzkaller fuzzer.\n\nThis patch tries to fix the issue again.  Now we call\nhrtimer_try_to_cancel() at both start and stop functions so that it\nwon't fall into a deadlock, yet giving some chance to cancel the queue\nif the functions have been called outside the callback.  The proper\nhrtimer_cancel() is called in anyway at closing, so this should be\nenough.\n\nReported-and-tested-by: Dmitry Vyukov <dvyukov@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/core\/hrtimer.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/sound\/core\/hrtimer.c b\/sound\/core\/hrtimer.c\nindex f845ecf7e1729..656d9a9032dc2 100644\n--- a\/sound\/core\/hrtimer.c\n+++ b\/sound\/core\/hrtimer.c\n@@ -90,7 +90,7 @@ static int snd_hrtimer_start(struct snd_timer *t)\n \tstruct snd_hrtimer *stime = t->private_data;\n \n \tatomic_set(&stime->running, 0);\n-\thrtimer_cancel(&stime->hrt);\n+\thrtimer_try_to_cancel(&stime->hrt);\n \thrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),\n \t\t      HRTIMER_MODE_REL);\n \tatomic_set(&stime->running, 1);\n@@ -101,6 +101,7 @@ static int snd_hrtimer_stop(struct snd_timer *t)\n {\n \tstruct snd_hrtimer *stime = t->private_data;\n \tatomic_set(&stime->running, 0);\n+\thrtimer_try_to_cancel(&stime->hrt);\n \treturn 0;\n }\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-4611","CWE_ID":"20","category":"security","commit_id":"206204a1162b995e2185275167b22468c00d6b36","commit_message":"From 206204a1162b995e2185275167b22468c00d6b36 Mon Sep 17 00:00:00 2001\nFrom: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nDate: Fri, 20 Jun 2014 22:01:41 -0700\nSubject: [PATCH] lz4: ensure length does not wrap\n\nGiven some pathologically compressed data, lz4 could possibly decide to\nwrap a few internal variables, causing unknown things to happen.  Catch\nthis before the wrapping happens and abort the decompression.\n\nReported-by: \"Don A. Bailey\" <donb@securitymouse.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n lib\/lz4\/lz4_decompress.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/lib\/lz4\/lz4_decompress.c b\/lib\/lz4\/lz4_decompress.c\nindex df6839e3ce088..99a03acb7d470 100644\n--- a\/lib\/lz4\/lz4_decompress.c\n+++ b\/lib\/lz4\/lz4_decompress.c\n@@ -72,6 +72,8 @@ static int lz4_uncompress(const char *source, char *dest, int osize)\n \t\t\tlen = *ip++;\n \t\t\tfor (; len == 255; length += 255)\n \t\t\t\tlen = *ip++;\n+\t\t\tif (unlikely(length > (size_t)(length + len)))\n+\t\t\t\tgoto _output_error;\n \t\t\tlength += len;\n \t\t}\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-3525","CWE_ID":"20","category":"security","commit_id":"aabcffae560d5fd00cd1d2ffce5d760353cf0a4d","commit_message":"From aabcffae560d5fd00cd1d2ffce5d760353cf0a4d Mon Sep 17 00:00:00 2001\nFrom: Tomasz Sterna <tomek@xiaoka.com>\nDate: Mon, 6 Aug 2012 20:41:23 +0200\nSubject: [PATCH] Fixed possibility of Unsolicited Dialback Attacks\n\n---\n s2s\/out.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/s2s\/out.c b\/s2s\/out.c\nindex 0ed9b301..7b9f44ff 100644\n--- a\/s2s\/out.c\n+++ b\/s2s\/out.c\n@@ -1661,7 +1661,7 @@ static void _out_result(conn_t out, nad_t nad) {\n     rkeylen = strlen(rkey);\n \n     \/* key is valid *\/\n-    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0) {\n+    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0 && xhash_get(out->states, rkey) == (void*) conn_INPROGRESS) {\n         log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n \n         xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    \/* !!! small leak here *\/\n@@ -1749,7 +1749,7 @@ static void _out_verify(conn_t out, nad_t nad) {\n     rkey = s2s_route_key(NULL, to->domain, from->domain);\n \n     attr = nad_find_attr(nad, 0, -1, \"type\", \"valid\");\n-    if(attr >= 0) {\n+    if(attr >= 0 && xhash_get(in->states, rkey) == (void*) conn_INPROGRESS) {\n         xhash_put(in->states, pstrdup(xhash_pool(in->states), rkey), (void *) conn_VALID);\n         log_write(in->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] incoming route '%s' is now valid%s%s\", in->fd->fd, in->ip, in->port, rkey, (in->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", in->s->compressed ? \", ZLIB compression enabled\" : \"\");\n         valid = 1;\n","owner":"Jabberd2","repo":"jabberd2","source":"cve"},{"CVE_ID":"CVE-2017-0375","CWE_ID":"20","category":"security","commit_id":"79b59a2dfcb68897ee89d98587d09e55f07e68d7","commit_message":"From 79b59a2dfcb68897ee89d98587d09e55f07e68d7 Mon Sep 17 00:00:00 2001\nFrom: David Goulet <dgoulet@torproject.org>\nDate: Mon, 5 Jun 2017 09:35:03 -0400\nSubject: [PATCH] TROVE-2017-004: Fix assertion failure in\n relay_send_end_cell_from_edge_\n\nThis fixes an assertion failure in relay_send_end_cell_from_edge_() when an\norigin circuit and a cpath_layer = NULL were passed.\n\nA service rendezvous circuit could do such a thing when a malformed BEGIN cell\nis received but shouldn't in the first place because the service needs to send\nan END cell on the circuit for which it can not do without a cpath_layer.\n\nFixes #22493\n\nReported-by: Roger Dingledine <arma@torproject.org>\nSigned-off-by: David Goulet <dgoulet@torproject.org>\n---\n changes\/trove-2017-004   |  5 +++++\n src\/or\/connection_edge.c | 21 ++++++++++++++-------\n 2 files changed, 19 insertions(+), 7 deletions(-)\n create mode 100644 changes\/trove-2017-004\n\n","diff_code":"diff --git a\/changes\/trove-2017-004 b\/changes\/trove-2017-004\nnew file mode 100644\nindex 0000000000..106d3afcb5\n--- \/dev\/null\n+++ b\/changes\/trove-2017-004\n@@ -0,0 +1,5 @@\n+  o Major bugfixes (hidden service, relay):\n+    - Fix an assertion failure when an hidden service handles a malformed\n+      BEGIN cell. This bug resulted in the service crashing triggered by a\n+      tor_assert(). Part of TROVE-2017-004. Fixes bug 22493; bugfix on\n+      tor-0.3.0.1-alpha. Found by armadev.\ndiff --git a\/src\/or\/connection_edge.c b\/src\/or\/connection_edge.c\nindex dac0c01012..d9d9e73643 100644\n--- a\/src\/or\/connection_edge.c\n+++ b\/src\/or\/connection_edge.c\n@@ -3091,14 +3091,21 @@ connection_exit_begin_conn(cell_t *cell, circuit_t *circ)\n   char *address = NULL;\n   uint16_t port = 0;\n   or_circuit_t *or_circ = NULL;\n+  origin_circuit_t *origin_circ = NULL;\n+  crypt_path_t *layer_hint = NULL;\n   const or_options_t *options = get_options();\n   begin_cell_t bcell;\n   int rv;\n   uint8_t end_reason=0;\n \n   assert_circuit_ok(circ);\n-  if (!CIRCUIT_IS_ORIGIN(circ))\n+  if (!CIRCUIT_IS_ORIGIN(circ)) {\n     or_circ = TO_OR_CIRCUIT(circ);\n+  } else {\n+    tor_assert(circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED);\n+    origin_circ = TO_ORIGIN_CIRCUIT(circ);\n+    layer_hint = origin_circ->cpath->prev;\n+  }\n \n   relay_header_unpack(&rh, cell->payload);\n   if (rh.length > RELAY_PAYLOAD_SIZE)\n@@ -3123,7 +3130,7 @@ connection_exit_begin_conn(cell_t *cell, circuit_t *circ)\n     return -END_CIRC_REASON_TORPROTOCOL;\n   } else if (rv == -1) {\n     tor_free(bcell.address);\n-    relay_send_end_cell_from_edge(rh.stream_id, circ, end_reason, NULL);\n+    relay_send_end_cell_from_edge(rh.stream_id, circ, end_reason, layer_hint);\n     return 0;\n   }\n \n@@ -3160,7 +3167,7 @@ connection_exit_begin_conn(cell_t *cell, circuit_t *circ)\n     if (!directory_permits_begindir_requests(options) ||\n         circ->purpose != CIRCUIT_PURPOSE_OR) {\n       relay_send_end_cell_from_edge(rh.stream_id, circ,\n-                                    END_STREAM_REASON_NOTDIRECTORY, NULL);\n+                                  END_STREAM_REASON_NOTDIRECTORY, layer_hint);\n       return 0;\n     }\n     \/* Make sure to get the 'real' address of the previous hop: the\n@@ -3177,7 +3184,7 @@ connection_exit_begin_conn(cell_t *cell, circuit_t *circ)\n   } else {\n     log_warn(LD_BUG, \"Got an unexpected command %d\", (int)rh.command);\n     relay_send_end_cell_from_edge(rh.stream_id, circ,\n-                                  END_STREAM_REASON_INTERNAL, NULL);\n+                                  END_STREAM_REASON_INTERNAL, layer_hint);\n     return 0;\n   }\n \n@@ -3188,7 +3195,7 @@ connection_exit_begin_conn(cell_t *cell, circuit_t *circ)\n     if (bcell.flags & BEGIN_FLAG_IPV4_NOT_OK) {\n       tor_free(address);\n       relay_send_end_cell_from_edge(rh.stream_id, circ,\n-                                    END_STREAM_REASON_EXITPOLICY, NULL);\n+                                    END_STREAM_REASON_EXITPOLICY, layer_hint);\n       return 0;\n     }\n   }\n@@ -3211,7 +3218,7 @@ connection_exit_begin_conn(cell_t *cell, circuit_t *circ)\n   n_stream->deliver_window = STREAMWINDOW_START;\n \n   if (circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED) {\n-    origin_circuit_t *origin_circ = TO_ORIGIN_CIRCUIT(circ);\n+    tor_assert(origin_circ);\n     log_info(LD_REND,\"begin is for rendezvous. configuring stream.\");\n     n_stream->base_.address = tor_strdup(\"(rendezvous)\");\n     n_stream->base_.state = EXIT_CONN_STATE_CONNECTING;\n@@ -3231,7 +3238,7 @@ connection_exit_begin_conn(cell_t *cell, circuit_t *circ)\n        * the hidden service. *\/\n       relay_send_end_cell_from_edge(rh.stream_id, circ,\n                                     END_STREAM_REASON_DONE,\n-                                    origin_circ->cpath->prev);\n+                                    layer_hint);\n       connection_free(TO_CONN(n_stream));\n       tor_free(address);\n \n","owner":"torproject","repo":"tor","source":"cve"},{"CVE_ID":"CVE-2017-15951","CWE_ID":"20","category":"security","commit_id":"363b02dab09b3226f3bd1420dad9c72b79a42a76","commit_message":"From 363b02dab09b3226f3bd1420dad9c72b79a42a76 Mon Sep 17 00:00:00 2001\nFrom: David Howells <dhowells@redhat.com>\nDate: Wed, 4 Oct 2017 16:43:25 +0100\nSubject: KEYS: Fix race between updating and finding a negative key\n\nConsolidate KEY_FLAG_INSTANTIATED, KEY_FLAG_NEGATIVE and the rejection\nerror into one field such that:\n\n (1) The instantiation state can be modified\/read atomically.\n\n (2) The error can be accessed atomically with the state.\n\n (3) The error isn't stored unioned with the payload pointers.\n\nThis deals with the problem that the state is spread over three different\nobjects (two bits and a separate variable) and reading or updating them\natomically isn't practical, given that not only can uninstantiated keys\nchange into instantiated or rejected keys, but rejected keys can also turn\ninto instantiated keys - and someone accessing the key might not be using\nany locking.\n\nThe main side effect of this problem is that what was held in the payload\nmay change, depending on the state.  For instance, you might observe the\nkey to be in the rejected state.  You then read the cached error, but if\nthe key semaphore wasn't locked, the key might've become instantiated\nbetween the two reads - and you might now have something in hand that isn't\nactually an error code.\n\nThe state is now KEY_IS_UNINSTANTIATED, KEY_IS_POSITIVE or a negative error\ncode if the key is negatively instantiated.  The key_is_instantiated()\nfunction is replaced with key_is_positive() to avoid confusion as negative\nkeys are also 'instantiated'.\n\nAdditionally, barriering is included:\n\n (1) Order payload-set before state-set during instantiation.\n\n (2) Order state-read before payload-read when using the key.\n\nFurther separate barriering is necessary if RCU is being used to access the\npayload content after reading the payload pointers.\n\nFixes: 146aa8b1453b (\"KEYS: Merge the type-specific data with the payload data\")\nCc: stable@vger.kernel.org # v4.4+\nReported-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\nReviewed-by: Eric Biggers <ebiggers@google.com>\n---\n include\/linux\/key.h                      | 47 ++++++++++++++++++++------------\n net\/dns_resolver\/dns_key.c               |  2 +-\n security\/keys\/big_key.c                  |  4 +--\n security\/keys\/encrypted-keys\/encrypted.c |  2 +-\n security\/keys\/gc.c                       |  8 +++---\n security\/keys\/key.c                      | 31 +++++++++++++--------\n security\/keys\/keyctl.c                   |  9 +++---\n security\/keys\/keyring.c                  | 10 +++----\n security\/keys\/proc.c                     |  7 +++--\n security\/keys\/process_keys.c             |  2 +-\n security\/keys\/request_key.c              |  7 ++---\n security\/keys\/request_key_auth.c         |  2 +-\n security\/keys\/trusted.c                  |  2 +-\n security\/keys\/user_defined.c             |  4 +--\n 14 files changed, 80 insertions(+), 57 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/key.h b\/include\/linux\/key.h\nindex e315e16b6ff8..8a15cabe928d 100644\n--- a\/include\/linux\/key.h\n+++ b\/include\/linux\/key.h\n@@ -138,6 +138,11 @@ struct key_restriction {\n \tstruct key_type *keytype;\n };\n \n+enum key_state {\n+\tKEY_IS_UNINSTANTIATED,\n+\tKEY_IS_POSITIVE,\t\t\/* Positively instantiated *\/\n+};\n+\n \/*****************************************************************************\/\n \/*\n  * authentication token \/ access credential \/ keyring\n@@ -169,6 +174,7 @@ struct key {\n \t\t\t\t\t\t * - may not match RCU dereferenced payload\n \t\t\t\t\t\t * - payload should contain own length\n \t\t\t\t\t\t *\/\n+\tshort\t\t\tstate;\t\t\/* Key state (+) or rejection error (-) *\/\n \n #ifdef KEY_DEBUGGING\n \tunsigned\t\tmagic;\n@@ -176,18 +182,16 @@ struct key {\n #endif\n \n \tunsigned long\t\tflags;\t\t\/* status flags (change with bitops) *\/\n-#define KEY_FLAG_INSTANTIATED\t0\t\/* set if key has been instantiated *\/\n-#define KEY_FLAG_DEAD\t\t1\t\/* set if key type has been deleted *\/\n-#define KEY_FLAG_REVOKED\t2\t\/* set if key had been revoked *\/\n-#define KEY_FLAG_IN_QUOTA\t3\t\/* set if key consumes quota *\/\n-#define KEY_FLAG_USER_CONSTRUCT\t4\t\/* set if key is being constructed in userspace *\/\n-#define KEY_FLAG_NEGATIVE\t5\t\/* set if key is negative *\/\n-#define KEY_FLAG_ROOT_CAN_CLEAR\t6\t\/* set if key can be cleared by root without permission *\/\n-#define KEY_FLAG_INVALIDATED\t7\t\/* set if key has been invalidated *\/\n-#define KEY_FLAG_BUILTIN\t8\t\/* set if key is built in to the kernel *\/\n-#define KEY_FLAG_ROOT_CAN_INVAL\t9\t\/* set if key can be invalidated by root without permission *\/\n-#define KEY_FLAG_KEEP\t\t10\t\/* set if key should not be removed *\/\n-#define KEY_FLAG_UID_KEYRING\t11\t\/* set if key is a user or user session keyring *\/\n+#define KEY_FLAG_DEAD\t\t0\t\/* set if key type has been deleted *\/\n+#define KEY_FLAG_REVOKED\t1\t\/* set if key had been revoked *\/\n+#define KEY_FLAG_IN_QUOTA\t2\t\/* set if key consumes quota *\/\n+#define KEY_FLAG_USER_CONSTRUCT\t3\t\/* set if key is being constructed in userspace *\/\n+#define KEY_FLAG_ROOT_CAN_CLEAR\t4\t\/* set if key can be cleared by root without permission *\/\n+#define KEY_FLAG_INVALIDATED\t5\t\/* set if key has been invalidated *\/\n+#define KEY_FLAG_BUILTIN\t6\t\/* set if key is built in to the kernel *\/\n+#define KEY_FLAG_ROOT_CAN_INVAL\t7\t\/* set if key can be invalidated by root without permission *\/\n+#define KEY_FLAG_KEEP\t\t8\t\/* set if key should not be removed *\/\n+#define KEY_FLAG_UID_KEYRING\t9\t\/* set if key is a user or user session keyring *\/\n \n \t\/* the key type and key description string\n \t * - the desc is used to match a key against search criteria\n@@ -213,7 +217,6 @@ struct key {\n \t\t\tstruct list_head name_link;\n \t\t\tstruct assoc_array keys;\n \t\t};\n-\t\tint reject_error;\n \t};\n \n \t\/* This is set on a keyring to restrict the addition of a link to a key\n@@ -353,17 +356,27 @@ extern void key_set_timeout(struct key *, unsigned);\n #define\tKEY_NEED_SETATTR 0x20\t\/* Require permission to change attributes *\/\n #define\tKEY_NEED_ALL\t0x3f\t\/* All the above permissions *\/\n \n+static inline short key_read_state(const struct key *key)\n+{\n+\t\/* Barrier versus mark_key_instantiated(). *\/\n+\treturn smp_load_acquire(&key->state);\n+}\n+\n \/**\n- * key_is_instantiated - Determine if a key has been positively instantiated\n+ * key_is_positive - Determine if a key has been positively instantiated\n  * @key: The key to check.\n  *\n  * Return true if the specified key has been positively instantiated, false\n  * otherwise.\n  *\/\n-static inline bool key_is_instantiated(const struct key *key)\n+static inline bool key_is_positive(const struct key *key)\n+{\n+\treturn key_read_state(key) == KEY_IS_POSITIVE;\n+}\n+\n+static inline bool key_is_negative(const struct key *key)\n {\n-\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n-\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n+\treturn key_read_state(key) < 0;\n }\n \n #define dereference_key_rcu(KEY)\t\t\t\t\t\\\ndiff --git a\/net\/dns_resolver\/dns_key.c b\/net\/dns_resolver\/dns_key.c\nindex 8737412c7b27..e1d4d898a007 100644\n--- a\/net\/dns_resolver\/dns_key.c\n+++ b\/net\/dns_resolver\/dns_key.c\n@@ -224,7 +224,7 @@ static int dns_resolver_match_preparse(struct key_match_data *match_data)\n static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n {\n \tseq_puts(m, key->description);\n-\tif (key_is_instantiated(key)) {\n+\tif (key_is_positive(key)) {\n \t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n \n \t\tif (err)\ndiff --git a\/security\/keys\/big_key.c b\/security\/keys\/big_key.c\nindex e607830b6154..929e14978c42 100644\n--- a\/security\/keys\/big_key.c\n+++ b\/security\/keys\/big_key.c\n@@ -247,7 +247,7 @@ void big_key_revoke(struct key *key)\n \n \t\/* clear the quota *\/\n \tkey_payload_reserve(key, 0);\n-\tif (key_is_instantiated(key) &&\n+\tif (key_is_positive(key) &&\n \t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n \t\tvfs_truncate(path, 0);\n }\n@@ -279,7 +279,7 @@ void big_key_describe(const struct key *key, struct seq_file *m)\n \n \tseq_puts(m, key->description);\n \n-\tif (key_is_instantiated(key))\n+\tif (key_is_positive(key))\n \t\tseq_printf(m, \": %zu [%s]\",\n \t\t\t   datalen,\n \t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\ndiff --git a\/security\/keys\/encrypted-keys\/encrypted.c b\/security\/keys\/encrypted-keys\/encrypted.c\nindex 535db141f4da..d92cbf9687c3 100644\n--- a\/security\/keys\/encrypted-keys\/encrypted.c\n+++ b\/security\/keys\/encrypted-keys\/encrypted.c\n@@ -854,7 +854,7 @@ static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \n-\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\tif (key_is_negative(key))\n \t\treturn -ENOKEY;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\ndiff --git a\/security\/keys\/gc.c b\/security\/keys\/gc.c\nindex 87cb260e4890..f01d48cb3de1 100644\n--- a\/security\/keys\/gc.c\n+++ b\/security\/keys\/gc.c\n@@ -129,15 +129,15 @@ static noinline void key_gc_unused_keys(struct list_head *keys)\n \twhile (!list_empty(keys)) {\n \t\tstruct key *key =\n \t\t\tlist_entry(keys->next, struct key, graveyard_link);\n+\t\tshort state = key->state;\n+\n \t\tlist_del(&key->graveyard_link);\n \n \t\tkdebug(\"- %u\", key->serial);\n \t\tkey_check(key);\n \n \t\t\/* Throw away the key data if the key is instantiated *\/\n-\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n-\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n-\t\t    key->type->destroy)\n+\t\tif (state == KEY_IS_POSITIVE && key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n \t\tsecurity_key_free(key);\n@@ -151,7 +151,7 @@ static noinline void key_gc_unused_keys(struct list_head *keys)\n \t\t}\n \n \t\tatomic_dec(&key->user->nkeys);\n-\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n+\t\tif (state != KEY_IS_UNINSTANTIATED)\n \t\t\tatomic_dec(&key->user->nikeys);\n \n \t\tkey_user_put(key->user);\ndiff --git a\/security\/keys\/key.c b\/security\/keys\/key.c\nindex eb914a838840..9385e7cc710f 100644\n--- a\/security\/keys\/key.c\n+++ b\/security\/keys\/key.c\n@@ -401,6 +401,18 @@ int key_payload_reserve(struct key *key, size_t datalen)\n }\n EXPORT_SYMBOL(key_payload_reserve);\n \n+\/*\n+ * Change the key state to being instantiated.\n+ *\/\n+static void mark_key_instantiated(struct key *key, int reject_error)\n+{\n+\t\/* Commit the payload before setting the state; barrier versus\n+\t * key_read_state().\n+\t *\/\n+\tsmp_store_release(&key->state,\n+\t\t\t  (reject_error < 0) ? reject_error : KEY_IS_POSITIVE);\n+}\n+\n \/*\n  * Instantiate a key and link it into the target keyring atomically.  Must be\n  * called with the target keyring's semaphore writelocked.  The target key's\n@@ -424,14 +436,14 @@ static int __key_instantiate_and_link(struct key *key,\n \tmutex_lock(&key_construction_mutex);\n \n \t\/* can't instantiate twice *\/\n-\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n+\tif (key->state == KEY_IS_UNINSTANTIATED) {\n \t\t\/* instantiate the key *\/\n \t\tret = key->type->instantiate(key, prep);\n \n \t\tif (ret == 0) {\n \t\t\t\/* mark the key as being instantiated *\/\n \t\t\tatomic_inc(&key->user->nikeys);\n-\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n+\t\t\tmark_key_instantiated(key, 0);\n \n \t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n \t\t\t\tawaken = 1;\n@@ -577,13 +589,10 @@ int key_reject_and_link(struct key *key,\n \tmutex_lock(&key_construction_mutex);\n \n \t\/* can't instantiate twice *\/\n-\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n+\tif (key->state == KEY_IS_UNINSTANTIATED) {\n \t\t\/* mark the key as being negatively instantiated *\/\n \t\tatomic_inc(&key->user->nikeys);\n-\t\tkey->reject_error = -error;\n-\t\tsmp_wmb();\n-\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n-\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n+\t\tmark_key_instantiated(key, -error);\n \t\tnow = current_kernel_time();\n \t\tkey->expiry = now.tv_sec + timeout;\n \t\tkey_schedule_gc(key->expiry + key_gc_delay);\n@@ -752,8 +761,8 @@ static inline key_ref_t __key_update(key_ref_t key_ref,\n \n \tret = key->type->update(key, prep);\n \tif (ret == 0)\n-\t\t\/* updating a negative key instantiates it *\/\n-\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n+\t\t\/* Updating a negative key positively instantiates it *\/\n+\t\tmark_key_instantiated(key, 0);\n \n \tup_write(&key->sem);\n \n@@ -986,8 +995,8 @@ int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n \n \tret = key->type->update(key, &prep);\n \tif (ret == 0)\n-\t\t\/* updating a negative key instantiates it *\/\n-\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n+\t\t\/* Updating a negative key positively instantiates it *\/\n+\t\tmark_key_instantiated(key, 0);\n \n \tup_write(&key->sem);\n \ndiff --git a\/security\/keys\/keyctl.c b\/security\/keys\/keyctl.c\nindex 365ff85d7e27..76d22f726ae4 100644\n--- a\/security\/keys\/keyctl.c\n+++ b\/security\/keys\/keyctl.c\n@@ -766,10 +766,9 @@ long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n \n \tkey = key_ref_to_ptr(key_ref);\n \n-\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n-\t\tret = -ENOKEY;\n-\t\tgoto error2;\n-\t}\n+\tret = key_read_state(key);\n+\tif (ret < 0)\n+\t\tgoto error2; \/* Negatively instantiated *\/\n \n \t\/* see if we can read it directly *\/\n \tret = key_permission(key_ref, KEY_NEED_READ);\n@@ -901,7 +900,7 @@ long keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n \t\tatomic_dec(&key->user->nkeys);\n \t\tatomic_inc(&newowner->nkeys);\n \n-\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n+\t\tif (key->state != KEY_IS_UNINSTANTIATED) {\n \t\t\tatomic_dec(&key->user->nikeys);\n \t\t\tatomic_inc(&newowner->nikeys);\n \t\t}\ndiff --git a\/security\/keys\/keyring.c b\/security\/keys\/keyring.c\nindex 4fa82a8a9c0e..06173b091a74 100644\n--- a\/security\/keys\/keyring.c\n+++ b\/security\/keys\/keyring.c\n@@ -414,7 +414,7 @@ static void keyring_describe(const struct key *keyring, struct seq_file *m)\n \telse\n \t\tseq_puts(m, \"[anon]\");\n \n-\tif (key_is_instantiated(keyring)) {\n+\tif (key_is_positive(keyring)) {\n \t\tif (keyring->keys.nr_leaves_on_tree != 0)\n \t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n \t\telse\n@@ -553,7 +553,8 @@ static int keyring_search_iterator(const void *object, void *iterator_data)\n {\n \tstruct keyring_search_context *ctx = iterator_data;\n \tconst struct key *key = keyring_ptr_to_key(object);\n-\tunsigned long kflags = key->flags;\n+\tunsigned long kflags = READ_ONCE(key->flags);\n+\tshort state = READ_ONCE(key->state);\n \n \tkenter(\"{%d}\", key->serial);\n \n@@ -597,9 +598,8 @@ static int keyring_search_iterator(const void *object, void *iterator_data)\n \n \tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n \t\t\/* we set a different error code if we pass a negative key *\/\n-\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n-\t\t\tsmp_rmb();\n-\t\t\tctx->result = ERR_PTR(key->reject_error);\n+\t\tif (state < 0) {\n+\t\t\tctx->result = ERR_PTR(state);\n \t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n \t\t\tgoto skipped;\n \t\t}\ndiff --git a\/security\/keys\/proc.c b\/security\/keys\/proc.c\nindex de834309d100..4089ce1f7757 100644\n--- a\/security\/keys\/proc.c\n+++ b\/security\/keys\/proc.c\n@@ -182,6 +182,7 @@ static int proc_keys_show(struct seq_file *m, void *v)\n \tunsigned long timo;\n \tkey_ref_t key_ref, skey_ref;\n \tchar xbuf[16];\n+\tshort state;\n \tint rc;\n \n \tstruct keyring_search_context ctx = {\n@@ -236,17 +237,19 @@ static int proc_keys_show(struct seq_file *m, void *v)\n \t\t\tsprintf(xbuf, \"%luw\", timo \/ (60*60*24*7));\n \t}\n \n+\tstate = key_read_state(key);\n+\n #define showflag(KEY, LETTER, FLAG) \\\n \t(test_bit(FLAG,\t&(KEY)->flags) ? LETTER : '-')\n \n \tseq_printf(m, \"%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s \",\n \t\t   key->serial,\n-\t\t   showflag(key, 'I', KEY_FLAG_INSTANTIATED),\n+\t\t   state != KEY_IS_UNINSTANTIATED ? 'I' : '-',\n \t\t   showflag(key, 'R', KEY_FLAG_REVOKED),\n \t\t   showflag(key, 'D', KEY_FLAG_DEAD),\n \t\t   showflag(key, 'Q', KEY_FLAG_IN_QUOTA),\n \t\t   showflag(key, 'U', KEY_FLAG_USER_CONSTRUCT),\n-\t\t   showflag(key, 'N', KEY_FLAG_NEGATIVE),\n+\t\t   state < 0 ? 'N' : '-',\n \t\t   showflag(key, 'i', KEY_FLAG_INVALIDATED),\n \t\t   refcount_read(&key->usage),\n \t\t   xbuf,\ndiff --git a\/security\/keys\/process_keys.c b\/security\/keys\/process_keys.c\nindex 293d3598153b..740affd65ee9 100644\n--- a\/security\/keys\/process_keys.c\n+++ b\/security\/keys\/process_keys.c\n@@ -730,7 +730,7 @@ try_again:\n \n \tret = -EIO;\n \tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n-\t    !test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n+\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n \t\tgoto invalid_key;\n \n \t\/* check the permissions *\/\ndiff --git a\/security\/keys\/request_key.c b\/security\/keys\/request_key.c\nindex 63e63a42db3c..e8036cd0ad54 100644\n--- a\/security\/keys\/request_key.c\n+++ b\/security\/keys\/request_key.c\n@@ -595,10 +595,9 @@ int wait_for_key_construction(struct key *key, bool intr)\n \t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n \tif (ret)\n \t\treturn -ERESTARTSYS;\n-\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n-\t\tsmp_rmb();\n-\t\treturn key->reject_error;\n-\t}\n+\tret = key_read_state(key);\n+\tif (ret < 0)\n+\t\treturn ret;\n \treturn key_validate(key);\n }\n EXPORT_SYMBOL(wait_for_key_construction);\ndiff --git a\/security\/keys\/request_key_auth.c b\/security\/keys\/request_key_auth.c\nindex 6ebf1af8fce9..424e1d90412e 100644\n--- a\/security\/keys\/request_key_auth.c\n+++ b\/security\/keys\/request_key_auth.c\n@@ -73,7 +73,7 @@ static void request_key_auth_describe(const struct key *key,\n \n \tseq_puts(m, \"key:\");\n \tseq_puts(m, key->description);\n-\tif (key_is_instantiated(key))\n+\tif (key_is_positive(key))\n \t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n }\n \ndiff --git a\/security\/keys\/trusted.c b\/security\/keys\/trusted.c\nindex ddfaebf60fc8..bd85315cbfeb 100644\n--- a\/security\/keys\/trusted.c\n+++ b\/security\/keys\/trusted.c\n@@ -1066,7 +1066,7 @@ static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n \tchar *datablob;\n \tint ret = 0;\n \n-\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\tif (key_is_negative(key))\n \t\treturn -ENOKEY;\n \tp = key->payload.data[0];\n \tif (!p->migratable)\ndiff --git a\/security\/keys\/user_defined.c b\/security\/keys\/user_defined.c\nindex 3d8c68eba516..9f558bedba23 100644\n--- a\/security\/keys\/user_defined.c\n+++ b\/security\/keys\/user_defined.c\n@@ -114,7 +114,7 @@ int user_update(struct key *key, struct key_preparsed_payload *prep)\n \n \t\/* attach the new data, displacing the old *\/\n \tkey->expiry = prep->expiry;\n-\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n+\tif (key_is_positive(key))\n \t\tzap = dereference_key_locked(key);\n \trcu_assign_keypointer(key, prep->payload.data[0]);\n \tprep->payload.data[0] = NULL;\n@@ -162,7 +162,7 @@ EXPORT_SYMBOL_GPL(user_destroy);\n void user_describe(const struct key *key, struct seq_file *m)\n {\n \tseq_puts(m, key->description);\n-\tif (key_is_instantiated(key))\n+\tif (key_is_positive(key))\n \t\tseq_printf(m, \": %u\", key->datalen);\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-5328","CWE_ID":"20","category":"security","commit_id":"f20011457f41c11edb5ea5038ad0c8ea9f392023","commit_message":"From f20011457f41c11edb5ea5038ad0c8ea9f392023 Mon Sep 17 00:00:00 2001\nFrom: Oleg Nesterov <oleg@redhat.com>\nDate: Wed, 26 May 2010 14:44:10 -0700\nSubject: [PATCH] pids: init_struct_pid.tasks should never see the swapper\n process\n\n\"statically initialize struct pid for swapper\" commit 820e45db says:\n\n\tStatically initialize a struct pid for the swapper process (pid_t == 0)\n\tand attach it to init_task.  This is needed so task_pid(), task_pgrp()\n\tand task_session() interfaces work on the swapper process also.\n\nOK, but:\n\n\t- it doesn't make sense to add init_task.pids[].node into\n\t  init_struct_pid.tasks[], and in fact this just wrong.\n\n\t  idle threads are special, they shouldn't be visible on any\n\t  global list. In particular do_each_pid_task(init_struct_pid)\n\t  shouldn't see swapper.\n\n\t  This is the actual reason why kill(0, SIGKILL) from \/sbin\/init\n\t  (which starts with 0,0 special pids) crashes the kernel. The\n\t  signal sent to pgid\/sid == 0 must never see idle threads, even\n\t  if the previous patch fixed the crash itself.\n\n\t- we have other idle threads running on the non-boot CPUs, see\n\t  the next patch.\n\nChange INIT_STRUCT_PID\/INIT_PID_LINK to create the empty\/unhashed\nhlist_head\/hlist_node. Like any other idle thread swapper can never exit,\nso detach_pid()->__hlist_del() is not possible, but we could change\nINIT_PID_LINK() to set pprev = &next if needed.\n\nAll we need is the valid swapper->pids[].pid == &init_struct_pid.\n\nReported-by: Mathias Krause <mathias.krause@secunet.com>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nCc: Cedric Le Goater <clg@fr.ibm.com>\nCc: Dave Hansen <haveblue@us.ibm.com>\nCc: Eric Biederman <ebiederm@xmission.com>\nCc: Herbert Poetzl <herbert@13thfloor.at>\nCc: Mathias Krause <Mathias.Krause@secunet.com>\nAcked-by: Roland McGrath <roland@redhat.com>\nAcked-by: Serge Hallyn <serue@us.ibm.com>\nCc: Sukadev Bhattiprolu <sukadev@us.ibm.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n include\/linux\/init_task.h | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/init_task.h b\/include\/linux\/init_task.h\nindex 6deb1ba52fdb6..94fecb748a286 100644\n--- a\/include\/linux\/init_task.h\n+++ b\/include\/linux\/init_task.h\n@@ -45,9 +45,9 @@ extern struct group_info init_groups;\n #define INIT_STRUCT_PID {\t\t\t\t\t\t\\\n \t.count \t\t= ATOMIC_INIT(1),\t\t\t\t\\\n \t.tasks\t\t= {\t\t\t\t\t\t\\\n-\t\t{ .first = &init_task.pids[PIDTYPE_PID].node },\t\t\\\n-\t\t{ .first = &init_task.pids[PIDTYPE_PGID].node },\t\\\n-\t\t{ .first = &init_task.pids[PIDTYPE_SID].node },\t\t\\\n+\t\t{ .first = NULL },\t\t\t\t\t\\\n+\t\t{ .first = NULL },\t\t\t\t\t\\\n+\t\t{ .first = NULL },\t\t\t\t\t\\\n \t},\t\t\t\t\t\t\t\t\\\n \t.level\t\t= 0,\t\t\t\t\t\t\\\n \t.numbers\t= { {\t\t\t\t\t\t\\\n@@ -61,7 +61,7 @@ extern struct group_info init_groups;\n {\t\t\t\t\t\t\t\t\\\n \t.node = {\t\t\t\t\t\t\\\n \t\t.next = NULL,\t\t\t\t\t\\\n-\t\t.pprev = &init_struct_pid.tasks[type].first,\t\\\n+\t\t.pprev = NULL,\t\t\t\t\t\\\n \t},\t\t\t\t\t\t\t\\\n \t.pid = &init_struct_pid,\t\t\t\t\\\n }\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8219","CWE_ID":"20","category":"security","commit_id":"43492ff3ab68a343c1264801baa1d5a02de10167","commit_message":"From 43492ff3ab68a343c1264801baa1d5a02de10167 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sat, 7 Nov 2015 02:16:11 +0100\nSubject: [PATCH] avcodec\/jpeg2000dec: Clip all tile coordinates\n\nFixes out of array access\nFixes: b877a6b788a25c70e8b1d014f8628549\/asan_heap-oob_1da2c3f_2324_5a1b329b0b3c4bb6b1d775660ac56717.r3d\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/jpeg2000dec.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/jpeg2000dec.c b\/libavcodec\/jpeg2000dec.c\nindex c8b0daba88..31f3db8d68 100644\n--- a\/libavcodec\/jpeg2000dec.c\n+++ b\/libavcodec\/jpeg2000dec.c\n@@ -826,10 +826,10 @@ static int init_tile(Jpeg2000DecoderContext *s, int tileno)\n     if (!tile->comp)\n         return AVERROR(ENOMEM);\n \n-    tile->coord[0][0] = FFMAX(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x);\n-    tile->coord[0][1] = FFMIN((tilex + 1) * s->tile_width  + s->tile_offset_x, s->width);\n-    tile->coord[1][0] = FFMAX(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y);\n-    tile->coord[1][1] = FFMIN((tiley + 1) * s->tile_height + s->tile_offset_y, s->height);\n+    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n+    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);\n+    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n+    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);\n \n     for (compno = 0; compno < s->ncomponents; compno++) {\n         Jpeg2000Component *comp = tile->comp + compno;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8744","CWE_ID":"20","category":"security","commit_id":"a7278b36fcab9af469563bd7b9dadebe2ae25e48","commit_message":"From a7278b36fcab9af469563bd7b9dadebe2ae25e48 Mon Sep 17 00:00:00 2001\nFrom: Dana Rubin <dana.rubin@ravellosystems.com>\nDate: Tue, 18 Aug 2015 12:45:55 +0300\nSubject: [PATCH] net\/vmxnet3: Refine l2 header validation\n\nValidation of l2 header length assumed minimal packet size as\neth_header + 2 * vlan_header regardless of the actual protocol.\n\nThis caused crash for valid non-IP packets shorter than 22 bytes, as\n'tx_pkt->packet_type' hasn't been assigned for such packets, and\n'vmxnet3_on_tx_done_update_stats()' expects it to be properly set.\n\nRefine header length validation in 'vmxnet_tx_pkt_parse_headers'.\nCheck its return value during packet processing flow.\n\nAs a side effect, in case IPv4 and IPv6 header validation failure,\ncorrupt packets will be dropped.\n\nSigned-off-by: Dana Rubin <dana.rubin@ravellosystems.com>\nSigned-off-by: Shmulik Ladkani <shmulik.ladkani@ravellosystems.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\n---\n hw\/net\/vmxnet3.c       |  4 +---\n hw\/net\/vmxnet_tx_pkt.c | 19 ++++++++++++++++---\n 2 files changed, 17 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/hw\/net\/vmxnet3.c b\/hw\/net\/vmxnet3.c\nindex 04159c8..48ced71 100644\n--- a\/hw\/net\/vmxnet3.c\n+++ b\/hw\/net\/vmxnet3.c\n@@ -729,9 +729,7 @@ static void vmxnet3_process_tx_queue(VMXNET3State *s, int qidx)\n         }\n \n         if (txd.eop) {\n-            if (!s->skip_current_tx_pkt) {\n-                vmxnet_tx_pkt_parse(s->tx_pkt);\n-\n+            if (!s->skip_current_tx_pkt && vmxnet_tx_pkt_parse(s->tx_pkt)) {\n                 if (s->needs_vlan) {\n                     vmxnet_tx_pkt_setup_vlan_header(s->tx_pkt, s->tci);\n                 }\ndiff --git a\/hw\/net\/vmxnet_tx_pkt.c b\/hw\/net\/vmxnet_tx_pkt.c\nindex f7344c4..eb88ddf 100644\n--- a\/hw\/net\/vmxnet_tx_pkt.c\n+++ b\/hw\/net\/vmxnet_tx_pkt.c\n@@ -142,11 +142,24 @@ static bool vmxnet_tx_pkt_parse_headers(struct VmxnetTxPkt *pkt)\n \n     bytes_read = iov_to_buf(pkt->raw, pkt->raw_frags, 0, l2_hdr->iov_base,\n                             ETH_MAX_L2_HDR_LEN);\n-    if (bytes_read < ETH_MAX_L2_HDR_LEN) {\n+    if (bytes_read < sizeof(struct eth_header)) {\n+        l2_hdr->iov_len = 0;\n+        return false;\n+    }\n+\n+    l2_hdr->iov_len = sizeof(struct eth_header);\n+    switch (be16_to_cpu(PKT_GET_ETH_HDR(l2_hdr->iov_base)->h_proto)) {\n+    case ETH_P_VLAN:\n+        l2_hdr->iov_len += sizeof(struct vlan_header);\n+        break;\n+    case ETH_P_DVLAN:\n+        l2_hdr->iov_len += 2 * sizeof(struct vlan_header);\n+        break;\n+    }\n+\n+    if (bytes_read < l2_hdr->iov_len) {\n         l2_hdr->iov_len = 0;\n         return false;\n-    } else {\n-        l2_hdr->iov_len = eth_get_l2_hdr_length(l2_hdr->iov_base);\n     }\n \n     l3_proto = eth_get_l3_proto(l2_hdr->iov_base, l2_hdr->iov_len);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-9191","CWE_ID":"20","category":"security","commit_id":"93362fa47fe98b62e4a34ab408c4a418432e7939","commit_message":"From 93362fa47fe98b62e4a34ab408c4a418432e7939 Mon Sep 17 00:00:00 2001\nFrom: Zhou Chengming <zhouchengming1@huawei.com>\nDate: Fri, 6 Jan 2017 09:32:32 +0800\nSubject: [PATCH] sysctl: Drop reference added by grab_header in\n proc_sys_readdir\n\nFixes CVE-2016-9191, proc_sys_readdir doesn't drop reference\nadded by grab_header when return from !dir_emit_dots path.\nIt can cause any path called unregister_sysctl_table will\nwait forever.\n\nThe calltrace of CVE-2016-9191:\n\n[ 5535.960522] Call Trace:\n[ 5535.963265]  [<ffffffff817cdaaf>] schedule+0x3f\/0xa0\n[ 5535.968817]  [<ffffffff817d33fb>] schedule_timeout+0x3db\/0x6f0\n[ 5535.975346]  [<ffffffff817cf055>] ? wait_for_completion+0x45\/0x130\n[ 5535.982256]  [<ffffffff817cf0d3>] wait_for_completion+0xc3\/0x130\n[ 5535.988972]  [<ffffffff810d1fd0>] ? wake_up_q+0x80\/0x80\n[ 5535.994804]  [<ffffffff8130de64>] drop_sysctl_table+0xc4\/0xe0\n[ 5536.001227]  [<ffffffff8130de17>] drop_sysctl_table+0x77\/0xe0\n[ 5536.007648]  [<ffffffff8130decd>] unregister_sysctl_table+0x4d\/0xa0\n[ 5536.014654]  [<ffffffff8130deff>] unregister_sysctl_table+0x7f\/0xa0\n[ 5536.021657]  [<ffffffff810f57f5>] unregister_sched_domain_sysctl+0x15\/0x40\n[ 5536.029344]  [<ffffffff810d7704>] partition_sched_domains+0x44\/0x450\n[ 5536.036447]  [<ffffffff817d0761>] ? __mutex_unlock_slowpath+0x111\/0x1f0\n[ 5536.043844]  [<ffffffff81167684>] rebuild_sched_domains_locked+0x64\/0xb0\n[ 5536.051336]  [<ffffffff8116789d>] update_flag+0x11d\/0x210\n[ 5536.057373]  [<ffffffff817cf61f>] ? mutex_lock_nested+0x2df\/0x450\n[ 5536.064186]  [<ffffffff81167acb>] ? cpuset_css_offline+0x1b\/0x60\n[ 5536.070899]  [<ffffffff810fce3d>] ? trace_hardirqs_on+0xd\/0x10\n[ 5536.077420]  [<ffffffff817cf61f>] ? mutex_lock_nested+0x2df\/0x450\n[ 5536.084234]  [<ffffffff8115a9f5>] ? css_killed_work_fn+0x25\/0x220\n[ 5536.091049]  [<ffffffff81167ae5>] cpuset_css_offline+0x35\/0x60\n[ 5536.097571]  [<ffffffff8115aa2c>] css_killed_work_fn+0x5c\/0x220\n[ 5536.104207]  [<ffffffff810bc83f>] process_one_work+0x1df\/0x710\n[ 5536.110736]  [<ffffffff810bc7c0>] ? process_one_work+0x160\/0x710\n[ 5536.117461]  [<ffffffff810bce9b>] worker_thread+0x12b\/0x4a0\n[ 5536.123697]  [<ffffffff810bcd70>] ? process_one_work+0x710\/0x710\n[ 5536.130426]  [<ffffffff810c3f7e>] kthread+0xfe\/0x120\n[ 5536.135991]  [<ffffffff817d4baf>] ret_from_fork+0x1f\/0x40\n[ 5536.142041]  [<ffffffff810c3e80>] ? kthread_create_on_node+0x230\/0x230\n\nOne cgroup maintainer mentioned that \"cgroup is trying to offline\na cpuset css, which takes place under cgroup_mutex.  The offlining\nends up trying to drain active usages of a sysctl table which apprently\nis not happening.\"\nThe real reason is that proc_sys_readdir doesn't drop reference added\nby grab_header when return from !dir_emit_dots path. So this cpuset\noffline path will wait here forever.\n\nSee here for details: http:\/\/www.openwall.com\/lists\/oss-security\/2016\/11\/04\/13\n\nFixes: f0c3b5093add (\"[readdir] convert procfs\")\nCc: stable@vger.kernel.org\nReported-by: CAI Qian <caiqian@redhat.com>\nTested-by: Yang Shukui <yangshukui@huawei.com>\nSigned-off-by: Zhou Chengming <zhouchengming1@huawei.com>\nAcked-by: Al Viro <viro@ZenIV.linux.org.uk>\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>\n---\n fs\/proc\/proc_sysctl.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/proc\/proc_sysctl.c b\/fs\/proc\/proc_sysctl.c\nindex 55313d9948954..d4e37acd48217 100644\n--- a\/fs\/proc\/proc_sysctl.c\n+++ b\/fs\/proc\/proc_sysctl.c\n@@ -709,7 +709,7 @@ static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n \tctl_dir = container_of(head, struct ctl_dir, header);\n \n \tif (!dir_emit_dots(file, ctx))\n-\t\treturn 0;\n+\t\tgoto out;\n \n \tpos = 2;\n \n@@ -719,6 +719,7 @@ static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n \t\t\tbreak;\n \t\t}\n \t}\n+out:\n \tsysctl_head_finish(head);\n \treturn 0;\n }\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2017-6345","CWE_ID":"20","category":"security","commit_id":"8b74d439e1697110c5e5c600643e823eb1dd0762","commit_message":"From 8b74d439e1697110c5e5c600643e823eb1dd0762 Mon Sep 17 00:00:00 2001\nFrom: Eric Dumazet <edumazet@google.com>\nDate: Sun, 12 Feb 2017 14:03:52 -0800\nSubject: net\/llc: avoid BUG_ON() in skb_orphan()\n\nIt seems nobody used LLC since linux-3.12.\n\nFortunately fuzzers like syzkaller still know how to run this code,\notherwise it would be no fun.\n\nSetting skb->sk without skb->destructor leads to all kinds of\nbugs, we now prefer to be very strict about it.\n\nIdeally here we would use skb_set_owner() but this helper does not exist yet,\nonly CAN seems to have a private helper for that.\n\nFixes: 376c7311bdb6 (\"net: add a temporary sanity check in skb_orphan()\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/llc\/llc_conn.c | 3 +++\n net\/llc\/llc_sap.c  | 3 +++\n 2 files changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/net\/llc\/llc_conn.c b\/net\/llc\/llc_conn.c\nindex 3e821daf9dd4..8bc5a1bd2d45 100644\n--- a\/net\/llc\/llc_conn.c\n+++ b\/net\/llc\/llc_conn.c\n@@ -821,7 +821,10 @@ void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\n \t\t * another trick required to cope with how the PROCOM state\n \t\t * machine works. -acme\n \t\t *\/\n+\t\tskb_orphan(skb);\n+\t\tsock_hold(sk);\n \t\tskb->sk = sk;\n+\t\tskb->destructor = sock_efree;\n \t}\n \tif (!sock_owned_by_user(sk))\n \t\tllc_conn_rcv(sk, skb);\ndiff --git a\/net\/llc\/llc_sap.c b\/net\/llc\/llc_sap.c\nindex d0e1e804ebd7..5404d0d195cc 100644\n--- a\/net\/llc\/llc_sap.c\n+++ b\/net\/llc\/llc_sap.c\n@@ -290,7 +290,10 @@ static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n \n \tev->type   = LLC_SAP_EV_TYPE_PDU;\n \tev->reason = 0;\n+\tskb_orphan(skb);\n+\tsock_hold(sk);\n \tskb->sk = sk;\n+\tskb->destructor = sock_efree;\n \tllc_sap_state_process(sap, skb);\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-6826","CWE_ID":"20","category":"security","commit_id":"3197c0aa87a3b7190e17d49e6fbc7b554e4b3f0a","commit_message":"From 3197c0aa87a3b7190e17d49e6fbc7b554e4b3f0a Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sat, 18 Jul 2015 11:24:45 +0200\nSubject: [PATCH] avcodec\/rv34: Clear pointers in\n ff_rv34_decode_init_thread_copy()\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nAvoids leaving stale pointers\nFixes: signal_sigabrt_7ffff70eccc9_819_sabtriple.rm with memlimit 536870912\n\nFound-by: Samuel Gro\u00c3\u009f, Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/rv34.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/rv34.c b\/libavcodec\/rv34.c\nindex c109a9e003..51e0f4014f 100644\n--- a\/libavcodec\/rv34.c\n+++ b\/libavcodec\/rv34.c\n@@ -1534,7 +1534,14 @@ int ff_rv34_decode_init_thread_copy(AVCodecContext *avctx)\n \n     if (avctx->internal->is_copy) {\n         r->tmp_b_block_base = NULL;\n+        r->cbp_chroma       = NULL;\n+        r->cbp_luma         = NULL;\n+        r->deblock_coefs    = NULL;\n+        r->intra_types_hist = NULL;\n+        r->mb_type          = NULL;\n+\n         ff_mpv_idct_init(&r->s);\n+\n         if ((err = ff_mpv_common_init(&r->s)) < 0)\n             return err;\n         if ((err = rv34_decoder_alloc(r)) < 0) {\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4623","CWE_ID":"20","category":"security","commit_id":"1922a4e6aade7b1d685af19d4d9339ddb5c02859","commit_message":"From 1922a4e6aade7b1d685af19d4d9339ddb5c02859 Mon Sep 17 00:00:00 2001\nFrom: Paul Bakker <p.j.bakker@polarssl.org>\nDate: Thu, 6 Jun 2013 15:11:16 +0200\nSubject: [PATCH] ssl_parse_certificate() now calls x509parse_crt_der()\n directly\n\n---\n ChangeLog               |  3 +++\n include\/polarssl\/x509.h | 12 ++++++++++++\n library\/ssl_tls.c       |  4 ++--\n 3 files changed, 17 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 59be48bee8..7561aba9d7 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -10,6 +10,9 @@ Bugfix\n    * Fixed offset for cert_type list in ssl_parse_certificate_request()\n    * Fixed const correctness issues that have no impact on the ABI\n    * x509parse_crt() now better handles PEM error situations\n+   * ssl_parse_certificate() now calls x509parse_crt_der() directly\n+     instead of the x509parse_crt() wrapper that can also parse PEM\n+\t certificates\n \n = Version 1.2.7 released 2013-04-13\n Features\ndiff --git a\/include\/polarssl\/x509.h b\/include\/polarssl\/x509.h\nindex 87151c927e..296925f5eb 100644\n--- a\/include\/polarssl\/x509.h\n+++ b\/include\/polarssl\/x509.h\n@@ -424,6 +424,18 @@ extern \"C\" {\n  *\/\n \n \/** \\ingroup x509_module *\/\n+\/**\n+ * \\brief          Parse a single DER formatted certificate and add it\n+ *                 to the chained list.\n+ *\n+ * \\param chain    points to the start of the chain\n+ * \\param buf      buffer holding the certificate DER data\n+ * \\param buflen   size of the buffer\n+ *\n+ * \\return         0 if successful, or a specific X509 or PEM error code\n+ *\/\n+int x509parse_crt_der( x509_cert *chain, const unsigned char *buf, size_t buflen );\n+\n \/**\n  * \\brief          Parse one or more certificates and add them\n  *                 to the chained list. Parses permissively. If some\ndiff --git a\/library\/ssl_tls.c b\/library\/ssl_tls.c\nindex 9087ab4faf..e0cddf89fb 100644\n--- a\/library\/ssl_tls.c\n+++ b\/library\/ssl_tls.c\n@@ -2375,8 +2375,8 @@ int ssl_parse_certificate( ssl_context *ssl )\n             return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n         }\n \n-        ret = x509parse_crt( ssl->session_negotiate->peer_cert, ssl->in_msg + i,\n-                             n );\n+        ret = x509parse_crt_der( ssl->session_negotiate->peer_cert,\n+                                 ssl->in_msg + i, n );\n         if( ret != 0 )\n         {\n             SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n","owner":"polarssl","repo":"polarssl","source":"cve"},{"CVE_ID":"CVE-2016-10068","CWE_ID":"20","category":"security","commit_id":"56d6e20de489113617cbbddaf41e92600a34db22","commit_message":"From 56d6e20de489113617cbbddaf41e92600a34db22 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Wed, 2 Nov 2016 17:07:05 -0400\nSubject: [PATCH] Prevent fault in MSL interpreter\n\n---\n ChangeLog    | 2 ++\n coders\/msl.c | 2 ++\n 2 files changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 595efb4fd0..d86f86676e 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,6 +1,8 @@\n 2016-11-01  6.9.6-4 Cristy  <quetzlzacatenango@image...>\n   * Off by one memory allocation (reference\n     https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/296).\n+  * Prevent fault in MSL interpreter (reference\n+    https:\/\/www.imagemagick.org\/discourse-server\/viewtopic.php?f=3&t=30797).\n \n 2016-10-30  6.9.6-3 Cristy  <quetzlzacatenango@image...>\n   * Release ImageMagick version 6.9.6-3, GIT revision 11117:e857a26:20161030.\ndiff --git a\/coders\/msl.c b\/coders\/msl.c\nindex b30a7e5d8b..653ef630ee 100644\n--- a\/coders\/msl.c\n+++ b\/coders\/msl.c\n@@ -4999,6 +4999,8 @@ static void MSLStartElement(void *context,const xmlChar *tag,\n                     Image\n                       *image;\n \n+                    if (value == (char *) NULL)\n+                      break;\n                     (void) CopyMagickString(msl_info->image_info[n]->filename,\n                       value,MaxTextExtent);\n                     image=ReadImage(msl_info->image_info[n],exception);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2010-2226","CWE_ID":"20","category":"security","commit_id":"1817176a86352f65210139d4c794ad2d19fc6b63","commit_message":"From 1817176a86352f65210139d4c794ad2d19fc6b63 Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <dan.j.rosenberg@gmail.com>\nDate: Thu, 24 Jun 2010 12:07:47 +1000\nSubject: xfs: prevent swapext from operating on write-only files\n\nThis patch prevents user \"foo\" from using the SWAPEXT ioctl to swap\na write-only file owned by user \"bar\" into a file owned by \"foo\" and\nsubsequently reading it.  It does so by checking that the file\ndescriptors passed to the ioctl are also opened for reading.\n\nSigned-off-by: Dan Rosenberg <dan.j.rosenberg@gmail.com>\nReviewed-by: Christoph Hellwig <hch@lst.de>\n---\n fs\/xfs\/xfs_dfrag.c | 5 ++++-\n 1 file changed, 4 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/xfs\/xfs_dfrag.c b\/fs\/xfs\/xfs_dfrag.c\nindex 5bba29a07812..7f159d2a429a 100644\n--- a\/fs\/xfs\/xfs_dfrag.c\n+++ b\/fs\/xfs\/xfs_dfrag.c\n@@ -69,7 +69,9 @@ xfs_swapext(\n \t\tgoto out;\n \t}\n \n-\tif (!(file->f_mode & FMODE_WRITE) || (file->f_flags & O_APPEND)) {\n+\tif (!(file->f_mode & FMODE_WRITE) ||\n+\t    !(file->f_mode & FMODE_READ) ||\n+\t    (file->f_flags & O_APPEND)) {\n \t\terror = XFS_ERROR(EBADF);\n \t\tgoto out_put_file;\n \t}\n@@ -81,6 +83,7 @@ xfs_swapext(\n \t}\n \n \tif (!(tmp_file->f_mode & FMODE_WRITE) ||\n+\t    !(tmp_file->f_mode & FMODE_READ) ||\n \t    (tmp_file->f_flags & O_APPEND)) {\n \t\terror = XFS_ERROR(EBADF);\n \t\tgoto out_put_tmp_file;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8215","CWE_ID":"20","category":"security","commit_id":"77751427a1ff25b27d47a4c36b12c3c8667855ac","commit_message":"From 77751427a1ff25b27d47a4c36b12c3c8667855ac Mon Sep 17 00:00:00 2001\nFrom: Marcelo Leitner <mleitner@redhat.com>\nDate: Mon, 23 Feb 2015 11:17:13 -0300\nSubject: ipv6: addrconf: validate new MTU before applying it\n\nCurrently we don't check if the new MTU is valid or not and this allows\none to configure a smaller than minimum allowed by RFCs or even bigger\nthan interface own MTU, which is a problem as it may lead to packet\ndrops.\n\nIf you have a daemon like NetworkManager running, this may be exploited\nby remote attackers by forging RA packets with an invalid MTU, possibly\nleading to a DoS. (NetworkManager currently only validates for values\ntoo small, but not for too big ones.)\n\nThe fix is just to make sure the new value is valid. That is, between\nIPV6_MIN_MTU and interface's MTU.\n\nNote that similar check is already performed at\nndisc_router_discovery(), for when kernel itself parses the RA.\n\nSigned-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv6\/addrconf.c | 17 ++++++++++++++++-\n 1 file changed, 16 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/ipv6\/addrconf.c b\/net\/ipv6\/addrconf.c\nindex 98e4a63d72bb..b6030025f411 100644\n--- a\/net\/ipv6\/addrconf.c\n+++ b\/net\/ipv6\/addrconf.c\n@@ -4903,6 +4903,21 @@ int addrconf_sysctl_forward(struct ctl_table *ctl, int write,\n \treturn ret;\n }\n \n+static\n+int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,\n+\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n+{\n+\tstruct inet6_dev *idev = ctl->extra1;\n+\tint min_mtu = IPV6_MIN_MTU;\n+\tstruct ctl_table lctl;\n+\n+\tlctl = *ctl;\n+\tlctl.extra1 = &min_mtu;\n+\tlctl.extra2 = idev ? &idev->dev->mtu : NULL;\n+\n+\treturn proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);\n+}\n+\n static void dev_disable_change(struct inet6_dev *idev)\n {\n \tstruct netdev_notifier_info info;\n@@ -5054,7 +5069,7 @@ static struct addrconf_sysctl_table\n \t\t\t.data\t\t= &ipv6_devconf.mtu6,\n \t\t\t.maxlen\t\t= sizeof(int),\n \t\t\t.mode\t\t= 0644,\n-\t\t\t.proc_handler\t= proc_dointvec,\n+\t\t\t.proc_handler\t= addrconf_sysctl_mtu,\n \t\t},\n \t\t{\n \t\t\t.procname\t= \"accept_ra\",\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-8873","CWE_ID":"20","category":"security","commit_id":"4d2278143a08b7522de9471d0f014d7357c28fea","commit_message":"From 4d2278143a08b7522de9471d0f014d7357c28fea Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Mon, 27 Jul 2015 01:38:27 -0700\nSubject: [PATCH] Fix #69793 - limit what we accept when unserializing\n exception\n\n---\n Zend\/zend_exceptions.c                     | 28 ++++++++++++++++++++++++++++\n ext\/standard\/tests\/serialize\/bug69152.phpt |  1 +\n ext\/standard\/tests\/serialize\/bug69793.phpt | 17 +++++++++++++++++\n 3 files changed, 46 insertions(+)\n create mode 100644 ext\/standard\/tests\/serialize\/bug69793.phpt\n\n","diff_code":"diff --git a\/Zend\/zend_exceptions.c b\/Zend\/zend_exceptions.c\nindex 1a3ee8f..82b777a 100644\n--- a\/Zend\/zend_exceptions.c\n+++ b\/Zend\/zend_exceptions.c\n@@ -218,6 +218,33 @@ ZEND_METHOD(exception, __construct)\n }\n \/* }}} *\/\n \n+\/* {{{ proto Exception::__wakeup()\n+   Exception unserialize checks *\/\n+#define CHECK_EXC_TYPE(name, type) \\\n+\tvalue = zend_read_property(default_exception_ce, object, name, sizeof(name)-1, 0 TSRMLS_CC); \\\n+\tif(value && Z_TYPE_P(value) != type) { \\\n+\t\tzval *tmp; \\\n+\t\tMAKE_STD_ZVAL(tmp); \\\n+\t\tZVAL_STRINGL(tmp, name, sizeof(name)-1, 1); \\\n+\t\tZ_OBJ_HANDLER_P(object, unset_property)(object, tmp, 0 TSRMLS_CC); \\\n+\t\tzval_ptr_dtor(&tmp); \\\n+\t}\n+\n+ZEND_METHOD(exception, __wakeup)\n+{\n+\tzval *value;\n+\tzval *object = getThis();\n+\tHashTable *intern_ht = zend_std_get_properties(getThis() TSRMLS_CC);\n+\tCHECK_EXC_TYPE(\"message\", IS_STRING);\n+\tCHECK_EXC_TYPE(\"string\", IS_STRING);\n+\tCHECK_EXC_TYPE(\"code\", IS_LONG);\n+\tCHECK_EXC_TYPE(\"file\", IS_STRING);\n+\tCHECK_EXC_TYPE(\"line\", IS_LONG);\n+\tCHECK_EXC_TYPE(\"trace\", IS_ARRAY);\n+\tCHECK_EXC_TYPE(\"previous\", IS_OBJECT);\n+}\n+\/* }}} *\/\n+\n \/* {{{ proto ErrorException::__construct(string message, int code, int severity [, string filename [, int lineno [, Exception previous]]])\n    ErrorException constructor *\/\n ZEND_METHOD(error_exception, __construct)\n@@ -728,6 +755,7 @@ ZEND_END_ARG_INFO()\n const static zend_function_entry default_exception_functions[] = {\n \tZEND_ME(exception, __clone, NULL, ZEND_ACC_PRIVATE|ZEND_ACC_FINAL)\n \tZEND_ME(exception, __construct, arginfo_exception___construct, ZEND_ACC_PUBLIC)\n+\tZEND_ME(exception, __wakeup, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_FINAL)\n \tZEND_ME(exception, getMessage, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_FINAL)\n \tZEND_ME(exception, getCode, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_FINAL)\n \tZEND_ME(exception, getFile, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_FINAL)\ndiff --git a\/ext\/standard\/tests\/serialize\/bug69152.phpt b\/ext\/standard\/tests\/serialize\/bug69152.phpt\nindex 4e74168..bc2b302 100644\n--- a\/ext\/standard\/tests\/serialize\/bug69152.phpt\n+++ b\/ext\/standard\/tests\/serialize\/bug69152.phpt\n@@ -9,6 +9,7 @@ $x->test();\n \n ?>\n --EXPECTF--\n+Notice: Undefined property: Exception::$previous in %s on line %d\n exception 'Exception' in %s:%d\n Stack trace:\n #0 {main}\ndiff --git a\/ext\/standard\/tests\/serialize\/bug69793.phpt b\/ext\/standard\/tests\/serialize\/bug69793.phpt\nnew file mode 100644\nindex 0000000..134b4dd\n--- \/dev\/null\n+++ b\/ext\/standard\/tests\/serialize\/bug69793.phpt\n@@ -0,0 +1,17 @@\n+--TEST--\n+Bug #69793: Remotely triggerable stack exhaustion via recursive method calls\n+--FILE--\n+<?php\n+$e = unserialize('O:9:\"Exception\":7:{s:17:\"'.\"\\0\".'Exception'.\"\\0\".'string\";s:1:\"a\";s:7:\"'.\"\\0\".'*'.\"\\0\".'code\";i:0;s:7:\"'.\"\\0\".'*'.\"\\0\".'file\";R:1;s:7:\"'.\"\\0\".'*'.\"\\0\".'line\";i:1337;s:16:\"'.\"\\0\".'Exception'.\"\\0\".'trace\";a:0:{}s:19:\"'.\"\\0\".'Exception'.\"\\0\".'previous\";i:10;s:10:\"'.\"\\0\".'*'.\"\\0\".'message\";N;}');\n+\n+var_dump($e.\"\");\n+?>\n+--EXPECTF--\n+Notice: Undefined property: Exception::$message in %s\/bug69793.php on line %d\n+\n+Notice: Undefined property: Exception::$file in %s\/bug69793.php on line %d\n+\n+Notice: Undefined property: Exception::$previous in %s\/bug69793.php on line %d\n+string(53) \"exception 'Exception' in :1337\n+Stack trace:\n+#0 {main}\"\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-4256","CWE_ID":"20","category":"security","commit_id":"c66fb347946ebdd5b10908866ecc9fa05ee2cf3d","commit_message":"From c66fb347946ebdd5b10908866ecc9fa05ee2cf3d Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Sun, 28 Nov 2010 14:09:57 -0800\nSubject: Export 'get_pipe_info()' to other users\n\nAnd in particular, use it in 'pipe_fcntl()'.\n\nThe other pipe functions do not need to use the 'careful' version, since\nthey are only ever called for things that are already known to be pipes.\n\nThe normal read\/write\/ioctl functions are called through the file\noperations structures, so if a file isn't a pipe, they'd never get\ncalled.  But pipe_fcntl() is special, and called directly from the\ngeneric fcntl code, and needs to use the same careful function that the\nsplice code is using.\n\nCc: Jens Axboe <jaxboe@fusionio.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Dave Jones <davej@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/pipe.c                 |  2 +-\n fs\/splice.c               | 11 -----------\n include\/linux\/pipe_fs_i.h | 12 ++++++++++++\n 3 files changed, 13 insertions(+), 12 deletions(-)\n\n","diff_code":"diff --git a\/fs\/pipe.c b\/fs\/pipe.c\nindex a8012a955720..b8997f8c6324 100644\n--- a\/fs\/pipe.c\n+++ b\/fs\/pipe.c\n@@ -1204,7 +1204,7 @@ long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n \tstruct pipe_inode_info *pipe;\n \tlong ret;\n \n-\tpipe = file->f_path.dentry->d_inode->i_pipe;\n+\tpipe = get_pipe_info(file);\n \tif (!pipe)\n \t\treturn -EBADF;\n \ndiff --git a\/fs\/splice.c b\/fs\/splice.c\nindex 0d92dabcc576..ce2f02579e35 100644\n--- a\/fs\/splice.c\n+++ b\/fs\/splice.c\n@@ -1311,17 +1311,6 @@ long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n \t\t\t       struct pipe_inode_info *opipe,\n \t\t\t       size_t len, unsigned int flags);\n-\/*\n- * After the inode slimming patch, i_pipe\/i_bdev\/i_cdev share the same\n- * location, so checking ->i_pipe is not enough to verify that this is a\n- * pipe.\n- *\/\n-static inline struct pipe_inode_info *get_pipe_info(struct file *file)\n-{\n-\tstruct inode *i = file->f_path.dentry->d_inode;\n-\n-\treturn S_ISFIFO(i->i_mode) ? i->i_pipe : NULL;\n-}\n \n \/*\n  * Determine where to splice to\/from.\ndiff --git a\/include\/linux\/pipe_fs_i.h b\/include\/linux\/pipe_fs_i.h\nindex 445796945ac9..3c5ac3147428 100644\n--- a\/include\/linux\/pipe_fs_i.h\n+++ b\/include\/linux\/pipe_fs_i.h\n@@ -161,4 +161,16 @@ void generic_pipe_buf_release(struct pipe_inode_info *, struct pipe_buffer *);\n \/* for F_SETPIPE_SZ and F_GETPIPE_SZ *\/\n long pipe_fcntl(struct file *, unsigned int, unsigned long arg);\n \n+\/*\n+ * After the inode slimming patch, i_pipe\/i_bdev\/i_cdev share the same\n+ * location, so checking ->i_pipe is not enough to verify that this is a\n+ * pipe.\n+ *\/\n+static inline struct pipe_inode_info *get_pipe_info(struct file *file)\n+{\n+\tstruct inode *i = file->f_path.dentry->d_inode;\n+\n+\treturn S_ISFIFO(i->i_mode) ? i->i_pipe : NULL;\n+}\n+\n #endif\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5226","CWE_ID":"20","category":"security","commit_id":"d7fc532c42f0e9bf427923bab85433282b3e5117","commit_message":"From d7fc532c42f0e9bf427923bab85433282b3e5117 Mon Sep 17 00:00:00 2001\nFrom: Simon McVittie <smcv@debian.org>\nDate: Mon, 9 Jan 2017 17:46:07 +0000\nSubject: [PATCH] Call setsid() before executing sandboxed code (CVE-2017-5226)\n\nThis prevents the sandboxed code from getting a controlling tty,\nwhich in turn prevents it from accessing the TIOCSTI ioctl and hence\nfaking terminal input.\n\nFixes: #142\n\nCloses: #143\nApproved by: cgwalters\n---\n bubblewrap.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/bubblewrap.c b\/bubblewrap.c\nindex 6e04459..4b5b8e6 100644\n--- a\/bubblewrap.c\n+++ b\/bubblewrap.c\n@@ -2071,6 +2071,9 @@ main (int    argc,\n   \/* We want sigchild in the child *\/\n   unblock_sigchild ();\n \n+  if (setsid () == (pid_t) -1)\n+    die_with_error (\"setsid\");\n+\n   if (label_exec (opt_exec_label) == -1)\n     die_with_error (\"label_exec %s\", argv[0]);\n \n","owner":"projectatomic","repo":"bubblewrap","source":"cve"},{"CVE_ID":"CVE-2018-17456","CWE_ID":"20","category":"security","commit_id":"1a7fd1fb2998002da6e9ff2ee46e1bdd25ee8404","commit_message":"From 1a7fd1fb2998002da6e9ff2ee46e1bdd25ee8404 Mon Sep 17 00:00:00 2001\nFrom: Jeff King <peff@peff.net>\nDate: Mon, 24 Sep 2018 04:42:19 -0400\nSubject: [PATCH] fsck: detect submodule paths starting with dash\n\nAs with urls, submodule paths with dashes are ignored by\ngit, but may end up confusing older versions. Detecting them\nvia fsck lets us prevent modern versions of git from being a\nvector to spread broken .gitmodules to older versions.\n\nCompared to blocking leading-dash urls, though, this\ndetection may be less of a good idea:\n\n  1. While such paths provide confusing and broken results,\n     they don't seem to actually work as option injections\n     against anything except \"cd\". In particular, the\n     submodule code seems to canonicalize to an absolute\n     path before running \"git clone\" (so it passes\n     \/your\/clone\/-sub).\n\n  2. It's more likely that we may one day make such names\n     actually work correctly. Even after we revert this fsck\n     check, it will continue to be a hassle until hosting\n     servers are all updated.\n\nOn the other hand, it's not entirely clear that the behavior\nin older versions is safe. And if we do want to eventually\nallow this, we may end up doing so with a special syntax\nanyway (e.g., writing \".\/-sub\" in the .gitmodules file, and\nteaching the submodule code to canonicalize it when\ncomparing).\n\nSo on balance, this is probably a good protection.\n\nSigned-off-by: Jeff King <peff@peff.net>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>\n---\n fsck.c                        | 7 +++++++\n t\/t7417-submodule-path-url.sh | 8 ++++++++\n 2 files changed, 15 insertions(+)\n\n","diff_code":"diff --git a\/fsck.c b\/fsck.c\nindex c47285652723a..5d9b25fac0aeb 100644\n--- a\/fsck.c\n+++ b\/fsck.c\n@@ -65,6 +65,7 @@ static struct oidset gitmodules_done = OIDSET_INIT;\n \tFUNC(GITMODULES_NAME, ERROR) \\\n \tFUNC(GITMODULES_SYMLINK, ERROR) \\\n \tFUNC(GITMODULES_URL, ERROR) \\\n+\tFUNC(GITMODULES_PATH, ERROR) \\\n \t\/* warnings *\/ \\\n \tFUNC(BAD_FILEMODE, WARN) \\\n \tFUNC(EMPTY_NAME, WARN) \\\n@@ -952,6 +953,12 @@ static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n \t\t\t\t    FSCK_MSG_GITMODULES_URL,\n \t\t\t\t    \"disallowed submodule url: %s\",\n \t\t\t\t    value);\n+\tif (!strcmp(key, \"path\") && value &&\n+\t    looks_like_command_line_option(value))\n+\t\tdata->ret |= report(data->options, data->obj,\n+\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n+\t\t\t\t    \"disallowed submodule path: %s\",\n+\t\t\t\t    value);\n \tfree(name);\n \n \treturn 0;\ndiff --git a\/t\/t7417-submodule-path-url.sh b\/t\/t7417-submodule-path-url.sh\nindex 638293f0dab1c..756af8c4d6fbd 100755\n--- a\/t\/t7417-submodule-path-url.sh\n+++ b\/t\/t7417-submodule-path-url.sh\n@@ -17,4 +17,12 @@ test_expect_success 'clone rejects unprotected dash' '\n \ttest_i18ngrep ignoring err\n '\n \n+test_expect_success 'fsck rejects unprotected dash' '\n+\ttest_when_finished \"rm -rf dst\" &&\n+\tgit init --bare dst &&\n+\tgit -C dst config transfer.fsckObjects true &&\n+\ttest_must_fail git push dst HEAD 2>err &&\n+\tgrep gitmodulesPath err\n+'\n+\n test_done\n","owner":"git","repo":"git","source":"cve"},{"CVE_ID":"CVE-2016-8740","CWE_ID":"20","category":"security","commit_id":"29c63b786ae028d82405421585e91283c8fa0da3","commit_message":"From 29c63b786ae028d82405421585e91283c8fa0da3 Mon Sep 17 00:00:00 2001\nFrom: Stefan Eissing <icing@apache.org>\nDate: Sun, 4 Dec 2016 22:06:30 +0000\nSubject: [PATCH] SECURITY: CVE-2016-8740\n\nmod_http2: properly crafted, endless HTTP\/2 CONTINUATION frames could be used to exhaust all server's memory.\n\nReported by: Naveen Tiwari <naveen.tiwari@asu.edu> and CDF\/SEFCOM at Arizona State University\n\n\n\ngit-svn-id: https:\/\/svn.apache.org\/repos\/asf\/httpd\/httpd\/trunk@1772576 13f79535-47bb-0310-9956-ffa450edef68\n---\n CHANGES                    |  4 +++\n modules\/http2\/h2_session.c | 11 +++++--\n modules\/http2\/h2_stream.c  | 61 +++++++++++++++++++++-----------------\n 3 files changed, 46 insertions(+), 30 deletions(-)\n\n","diff_code":"diff --git a\/CHANGES b\/CHANGES\nindex bb840c0edde..bb92454986f 100644\n--- a\/CHANGES\n+++ b\/CHANGES\n@@ -1,6 +1,10 @@\n                                                          -*- coding: utf-8 -*-\n Changes with Apache 2.5.0\n \n+  *) mod_http2: CVE-2016-8740: Mitigate DoS memory exhaustion via endless\n+     CONTINUATION frames.\n+     [Naveen Tiwari <naveen.tiwari@asu.edu> and CDF\/SEFCOM at Arizona State University, Stefan Eissing]\n+\n   *) mod_lua: Fix default value of LuaInherit directive. It should be \n      'parent-first' instead of 'none', as per documentation.  PR 60419\n      [Christophe Jaillet]\ndiff --git a\/modules\/http2\/h2_session.c b\/modules\/http2\/h2_session.c\nindex 0a29a3b18cc..44eed633256 100644\n--- a\/modules\/http2\/h2_session.c\n+++ b\/modules\/http2\/h2_session.c\n@@ -394,7 +394,7 @@ static int on_header_cb(nghttp2_session *ngh2, const nghttp2_frame *frame,\n     (void)flags;\n     stream = get_stream(session, frame->hd.stream_id);\n     if (!stream) {\n-        ap_log_cerror(APLOG_MARK, APLOG_ERR, 0, session->c,\n+        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, session->c,\n                       APLOGNO(02920) \n                       \"h2_session:  stream(%ld-%d): on_header unknown stream\",\n                       session->id, (int)frame->hd.stream_id);\n@@ -403,7 +403,14 @@ static int on_header_cb(nghttp2_session *ngh2, const nghttp2_frame *frame,\n     \n     status = h2_stream_add_header(stream, (const char *)name, namelen,\n                                   (const char *)value, valuelen);\n-    if (status != APR_SUCCESS && !h2_stream_is_ready(stream)) {\n+    if (status == APR_ECONNRESET) {\n+        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, status, session->c,\n+                      \"h2-stream(%ld-%d): on_header, reset stream\",\n+                      session->id, stream->id);\n+        nghttp2_submit_rst_stream(ngh2, NGHTTP2_FLAG_NONE, stream->id,\n+                                  NGHTTP2_INTERNAL_ERROR);\n+    }\n+    else if (status != APR_SUCCESS && !h2_stream_is_ready(stream)) {\n         return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n     }\n     return 0;\ndiff --git a\/modules\/http2\/h2_stream.c b\/modules\/http2\/h2_stream.c\nindex 2d179d0b0fc..d31193909c7 100644\n--- a\/modules\/http2\/h2_stream.c\n+++ b\/modules\/http2\/h2_stream.c\n@@ -333,45 +333,50 @@ apr_status_t h2_stream_add_header(h2_stream *stream,\n                                   const char *name, size_t nlen,\n                                   const char *value, size_t vlen)\n {\n+    int error = 0;\n     ap_assert(stream);\n     \n-    if (!stream->has_response) {\n-        if (name[0] == ':') {\n-            if ((vlen) > stream->session->s->limit_req_line) {\n-                \/* pseudo header: approximation of request line size check *\/\n-                ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n-                              \"h2_stream(%ld-%d): pseudo header %s too long\", \n-                              stream->session->id, stream->id, name);\n-                return h2_stream_set_error(stream, \n-                                           HTTP_REQUEST_URI_TOO_LARGE);\n-            }\n-        }\n-        else if ((nlen + 2 + vlen) > stream->session->s->limit_req_fieldsize) {\n-            \/* header too long *\/\n+    if (stream->has_response) {\n+        return APR_EINVAL;    \n+    }\n+    ++stream->request_headers_added;\n+    if (name[0] == ':') {\n+        if ((vlen) > stream->session->s->limit_req_line) {\n+            \/* pseudo header: approximation of request line size check *\/\n             ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n-                          \"h2_stream(%ld-%d): header %s too long\", \n+                          \"h2_stream(%ld-%d): pseudo header %s too long\", \n                           stream->session->id, stream->id, name);\n-            return h2_stream_set_error(stream, \n-                                       HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE);\n+            error = HTTP_REQUEST_URI_TOO_LARGE;\n         }\n-        \n-        if (name[0] != ':') {\n-            ++stream->request_headers_added;\n-            if (stream->request_headers_added \n-                > stream->session->s->limit_req_fields) {\n-                \/* too many header lines *\/\n-                ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n-                              \"h2_stream(%ld-%d): too many header lines\", \n-                              stream->session->id, stream->id);\n-                return h2_stream_set_error(stream, \n-                                           HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE);\n-            }\n+    }\n+    else if ((nlen + 2 + vlen) > stream->session->s->limit_req_fieldsize) {\n+        \/* header too long *\/\n+        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n+                      \"h2_stream(%ld-%d): header %s too long\", \n+                      stream->session->id, stream->id, name);\n+        error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n+    }\n+    \n+    if (stream->request_headers_added \n+        > stream->session->s->limit_req_fields + 4) {\n+        \/* too many header lines, include 4 pseudo headers *\/\n+        if (stream->request_headers_added \n+            > stream->session->s->limit_req_fields + 4 + 100) {\n+            \/* yeah, right *\/\n+            return APR_ECONNRESET;\n         }\n+        ap_log_cerror(APLOG_MARK, APLOG_TRACE1, 0, stream->session->c,\n+                      \"h2_stream(%ld-%d): too many header lines\", \n+                      stream->session->id, stream->id);\n+        error = HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE;\n     }\n     \n     if (h2_stream_is_scheduled(stream)) {\n         return add_trailer(stream, name, nlen, value, vlen);\n     }\n+    else if (error) {\n+        return h2_stream_set_error(stream, error); \n+    }\n     else {\n         if (!stream->rtmp) {\n             stream->rtmp = h2_req_create(stream->id, stream->pool, \n","owner":"apache","repo":"httpd","source":"cve"},{"CVE_ID":"CVE-2013-7270","CWE_ID":"20","category":"security","commit_id":"f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","commit_message":"From f3d3342602f8bcbf37d7c46641cb9bca7618eb1c Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Thu, 21 Nov 2013 03:14:22 +0100\nSubject: net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include\/linux\/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec\/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n crypto\/algif_hash.c            |  2 --\n crypto\/algif_skcipher.c        |  1 -\n drivers\/isdn\/mISDN\/socket.c    | 13 ++++---------\n drivers\/net\/ppp\/pppoe.c        |  2 --\n include\/linux\/net.h            |  8 ++++++++\n net\/appletalk\/ddp.c            | 16 +++++++---------\n net\/atm\/common.c               |  2 --\n net\/ax25\/af_ax25.c             |  4 ++--\n net\/bluetooth\/af_bluetooth.c   |  9 ++-------\n net\/bluetooth\/hci_sock.c       |  2 --\n net\/bluetooth\/rfcomm\/sock.c    |  1 -\n net\/bluetooth\/sco.c            |  1 -\n net\/caif\/caif_socket.c         |  4 ----\n net\/compat.c                   |  3 ++-\n net\/core\/iovec.c               |  3 ++-\n net\/ipx\/af_ipx.c               |  3 +--\n net\/irda\/af_irda.c             |  4 ----\n net\/iucv\/af_iucv.c             |  2 --\n net\/key\/af_key.c               |  1 -\n net\/l2tp\/l2tp_ppp.c            |  2 --\n net\/llc\/af_llc.c               |  2 --\n net\/netlink\/af_netlink.c       |  2 --\n net\/netrom\/af_netrom.c         |  3 +--\n net\/nfc\/llcp_sock.c            |  2 --\n net\/nfc\/rawsock.c              |  2 --\n net\/packet\/af_packet.c         | 32 +++++++++++++++-----------------\n net\/rds\/recv.c                 |  2 --\n net\/rose\/af_rose.c             |  8 +++++---\n net\/rxrpc\/ar-recvmsg.c         |  9 ++++++---\n net\/socket.c                   | 19 +++++++++++--------\n net\/tipc\/socket.c              |  6 ------\n net\/unix\/af_unix.c             |  5 -----\n net\/vmw_vsock\/af_vsock.c       |  2 --\n net\/vmw_vsock\/vmci_transport.c |  2 --\n net\/x25\/af_x25.c               |  3 +--\n 35 files changed, 67 insertions(+), 115 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/algif_hash.c b\/crypto\/algif_hash.c\nindex 0262210cad38..ef5356cd280a 100644\n--- a\/crypto\/algif_hash.c\n+++ b\/crypto\/algif_hash.c\n@@ -161,8 +161,6 @@ static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\ndiff --git a\/crypto\/algif_skcipher.c b\/crypto\/algif_skcipher.c\nindex a1c4f0a55583..6a6dfc062d2a 100644\n--- a\/crypto\/algif_skcipher.c\n+++ b\/crypto\/algif_skcipher.c\n@@ -432,7 +432,6 @@ static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n \tlong copied = 0;\n \n \tlock_sock(sk);\n-\tmsg->msg_namelen = 0;\n \tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n \t     iovlen--, iov++) {\n \t\tunsigned long seglen = iov->iov_len;\ndiff --git a\/drivers\/isdn\/mISDN\/socket.c b\/drivers\/isdn\/mISDN\/socket.c\nindex e47dcb9d1e91..5cefb479c707 100644\n--- a\/drivers\/isdn\/mISDN\/socket.c\n+++ b\/drivers\/isdn\/mISDN\/socket.c\n@@ -117,7 +117,6 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sk_buff\t\t*skb;\n \tstruct sock\t\t*sk = sock->sk;\n-\tstruct sockaddr_mISDN\t*maddr;\n \n \tint\t\tcopied, err;\n \n@@ -135,9 +134,9 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n-\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_mISDN *maddr = msg->msg_name;\n+\n \t\tmaddr->family = AF_ISDN;\n \t\tmaddr->dev = _pms(sk)->dev->id;\n \t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n@@ -150,11 +149,7 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n \t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n \t\t}\n-\t} else {\n-\t\tif (msg->msg_namelen)\n-\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n-\t\t\t       __func__, msg->msg_namelen);\n-\t\tmsg->msg_namelen = 0;\n+\t\tmsg->msg_namelen = sizeof(*maddr);\n \t}\n \n \tcopied = skb->len + MISDN_HEADER_LEN;\ndiff --git a\/drivers\/net\/ppp\/pppoe.c b\/drivers\/net\/ppp\/pppoe.c\nindex 5f66e30d9823..82ee6ed954cb 100644\n--- a\/drivers\/net\/ppp\/pppoe.c\n+++ b\/drivers\/net\/ppp\/pppoe.c\n@@ -979,8 +979,6 @@ static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (error < 0)\n \t\tgoto end;\n \n-\tm->msg_namelen = 0;\n-\n \tif (skb) {\n \t\ttotal_len = min_t(size_t, total_len, skb->len);\n \t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\ndiff --git a\/include\/linux\/net.h b\/include\/linux\/net.h\nindex b292a0435571..4bcee94cef93 100644\n--- a\/include\/linux\/net.h\n+++ b\/include\/linux\/net.h\n@@ -164,6 +164,14 @@ struct proto_ops {\n #endif\n \tint\t\t(*sendmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len);\n+\t\/* Notes for implementing recvmsg:\n+\t * ===============================\n+\t * msg->msg_namelen should get updated by the recvmsg handlers\n+\t * iff msg_name != NULL. It is by default 0 to prevent\n+\t * returning uninitialized memory to user space.  The recvfrom\n+\t * handlers can assume that msg.msg_name is either NULL or has\n+\t * a minimum size of sizeof(struct sockaddr_storage).\n+\t *\/\n \tint\t\t(*recvmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len,\n \t\t\t\t      int flags);\ndiff --git a\/net\/appletalk\/ddp.c b\/net\/appletalk\/ddp.c\nindex 7fee50d637f9..7d424ac6e760 100644\n--- a\/net\/appletalk\/ddp.c\n+++ b\/net\/appletalk\/ddp.c\n@@ -1735,7 +1735,6 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n-\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n@@ -1764,14 +1763,13 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n \n-\tif (!err) {\n-\t\tif (sat) {\n-\t\t\tsat->sat_family      = AF_APPLETALK;\n-\t\t\tsat->sat_port        = ddp->deh_sport;\n-\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n-\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n-\t\t}\n-\t\tmsg->msg_namelen = sizeof(*sat);\n+\tif (!err && msg->msg_name) {\n+\t\tstruct sockaddr_at *sat = msg->msg_name;\n+\t\tsat->sat_family      = AF_APPLETALK;\n+\t\tsat->sat_port        = ddp->deh_sport;\n+\t\tsat->sat_addr.s_node = ddp->deh_snode;\n+\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n+\t\tmsg->msg_namelen     = sizeof(*sat);\n \t}\n \n \tskb_free_datagram(sk, skb);\t\/* Free the datagram. *\/\ndiff --git a\/net\/atm\/common.c b\/net\/atm\/common.c\nindex 737bef59ce89..7b491006eaf4 100644\n--- a\/net\/atm\/common.c\n+++ b\/net\/atm\/common.c\n@@ -531,8 +531,6 @@ int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n \ndiff --git a\/net\/ax25\/af_ax25.c b\/net\/ax25\/af_ax25.c\nindex a00123ebb0ae..7bb1605bdfd9 100644\n--- a\/net\/ax25\/af_ax25.c\n+++ b\/net\/ax25\/af_ax25.c\n@@ -1636,11 +1636,11 @@ static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (msg->msg_namelen != 0) {\n-\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n+\tif (msg->msg_name) {\n \t\tax25_digi digi;\n \t\tax25_address src;\n \t\tconst unsigned char *mac = skb_mac_header(skb);\n+\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n \n \t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n \t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\ndiff --git a\/net\/bluetooth\/af_bluetooth.c b\/net\/bluetooth\/af_bluetooth.c\nindex f6a1671ea2ff..56ca494621c6 100644\n--- a\/net\/bluetooth\/af_bluetooth.c\n+++ b\/net\/bluetooth\/af_bluetooth.c\n@@ -224,10 +224,9 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n-\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n-\t\t\tmsg->msg_namelen = 0;\n+\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n-\t\t}\n+\n \t\treturn err;\n \t}\n \n@@ -245,8 +244,6 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tif (bt_sk(sk)->skb_msg_name)\n \t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n \t\t\t\t\t\t&msg->msg_namelen);\n-\t\telse\n-\t\t\tmsg->msg_namelen = 0;\n \t}\n \n \tskb_free_datagram(sk, skb);\n@@ -295,8 +292,6 @@ int bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \tBT_DBG(\"sk %p size %zu\", sk, size);\n \n \tlock_sock(sk);\ndiff --git a\/net\/bluetooth\/hci_sock.c b\/net\/bluetooth\/hci_sock.c\nindex 71f0be173080..6a6c8bb4fd72 100644\n--- a\/net\/bluetooth\/hci_sock.c\n+++ b\/net\/bluetooth\/hci_sock.c\n@@ -856,8 +856,6 @@ static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/bluetooth\/rfcomm\/sock.c b\/net\/bluetooth\/rfcomm\/sock.c\nindex c4d3d423f89b..c80766f892c3 100644\n--- a\/net\/bluetooth\/rfcomm\/sock.c\n+++ b\/net\/bluetooth\/rfcomm\/sock.c\n@@ -615,7 +615,6 @@ static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n-\t\tmsg->msg_namelen = 0;\n \t\treturn 0;\n \t}\n \ndiff --git a\/net\/bluetooth\/sco.c b\/net\/bluetooth\/sco.c\nindex 12a0e51e21e1..24fa3964b3c8 100644\n--- a\/net\/bluetooth\/sco.c\n+++ b\/net\/bluetooth\/sco.c\n@@ -711,7 +711,6 @@ static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n \t\tsk->sk_state = BT_CONFIG;\n-\t\tmsg->msg_namelen = 0;\n \n \t\trelease_sock(sk);\n \t\treturn 0;\ndiff --git a\/net\/caif\/caif_socket.c b\/net\/caif\/caif_socket.c\nindex 05a41c7ec304..d6be3edb7a43 100644\n--- a\/net\/caif\/caif_socket.c\n+++ b\/net\/caif\/caif_socket.c\n@@ -286,8 +286,6 @@ static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (m->msg_flags&MSG_OOB)\n \t\tgoto read_error;\n \n-\tm->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n \tif (!skb)\n \t\tgoto read_error;\n@@ -361,8 +359,6 @@ static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/*\n \t * Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\ndiff --git a\/net\/compat.c b\/net\/compat.c\nindex 89032580bd1d..618c6a8a911b 100644\n--- a\/net\/compat.c\n+++ b\/net\/compat.c\n@@ -93,7 +93,8 @@ int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tkern_msg->msg_name = kern_address;\n+\t\tif (kern_msg->msg_name)\n+\t\t\tkern_msg->msg_name = kern_address;\n \t} else\n \t\tkern_msg->msg_name = NULL;\n \ndiff --git a\/net\/core\/iovec.c b\/net\/core\/iovec.c\nindex 4cdb7c48dad6..b61869429f4c 100644\n--- a\/net\/core\/iovec.c\n+++ b\/net\/core\/iovec.c\n@@ -48,7 +48,8 @@ int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *a\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tm->msg_name = address;\n+\t\tif (m->msg_name)\n+\t\t\tm->msg_name = address;\n \t} else {\n \t\tm->msg_name = NULL;\n \t}\ndiff --git a\/net\/ipx\/af_ipx.c b\/net\/ipx\/af_ipx.c\nindex 7a1e0fc1bd4d..e096025b477f 100644\n--- a\/net\/ipx\/af_ipx.c\n+++ b\/net\/ipx\/af_ipx.c\n@@ -1823,8 +1823,6 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n-\tmsg->msg_namelen = sizeof(*sipx);\n-\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n@@ -1832,6 +1830,7 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n+\t\tmsg->msg_namelen\t= sizeof(*sipx);\n \t}\n \trc = copied;\n \ndiff --git a\/net\/irda\/af_irda.c b\/net\/irda\/af_irda.c\nindex 0f676908d15b..de7db23049f1 100644\n--- a\/net\/irda\/af_irda.c\n+++ b\/net\/irda\/af_irda.c\n@@ -1385,8 +1385,6 @@ static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n \n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \n-\tmsg->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n@@ -1451,8 +1449,6 @@ static int irda_recvmsg_stream(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, noblock);\n \n-\tmsg->msg_namelen = 0;\n-\n \tdo {\n \t\tint chunk;\n \t\tstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\ndiff --git a\/net\/iucv\/af_iucv.c b\/net\/iucv\/af_iucv.c\nindex 168aff5e60de..c4b7218058b6 100644\n--- a\/net\/iucv\/af_iucv.c\n+++ b\/net\/iucv\/af_iucv.c\n@@ -1324,8 +1324,6 @@ static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint err = 0;\n \tu32 offset;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif ((sk->sk_state == IUCV_DISCONN) &&\n \t    skb_queue_empty(&iucv->backlog_skb_q) &&\n \t    skb_queue_empty(&sk->sk_receive_queue) &&\ndiff --git a\/net\/key\/af_key.c b\/net\/key\/af_key.c\nindex 911ef03bf8fb..545f047868ad 100644\n--- a\/net\/key\/af_key.c\n+++ b\/net\/key\/af_key.c\n@@ -3616,7 +3616,6 @@ static int pfkey_recvmsg(struct kiocb *kiocb,\n \tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n \tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n \tif (skb == NULL)\n \t\tgoto out;\ndiff --git a\/net\/l2tp\/l2tp_ppp.c b\/net\/l2tp\/l2tp_ppp.c\nindex ffda81ef1a70..be5fadf34739 100644\n--- a\/net\/l2tp\/l2tp_ppp.c\n+++ b\/net\/l2tp\/l2tp_ppp.c\n@@ -197,8 +197,6 @@ static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sk->sk_state & PPPOX_BOUND)\n \t\tgoto end;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = 0;\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\ndiff --git a\/net\/llc\/af_llc.c b\/net\/llc\/af_llc.c\nindex 6cba486353e8..7b01b9f5846c 100644\n--- a\/net\/llc\/af_llc.c\n+++ b\/net\/llc\/af_llc.c\n@@ -720,8 +720,6 @@ static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint target;\t\/* Read at least this many bytes *\/\n \tlong timeo;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tcopied = -ENOTCONN;\n \tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\ndiff --git a\/net\/netlink\/af_netlink.c b\/net\/netlink\/af_netlink.c\nindex f0176e1a5a81..bca50b95c182 100644\n--- a\/net\/netlink\/af_netlink.c\n+++ b\/net\/netlink\/af_netlink.c\n@@ -2335,8 +2335,6 @@ static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,\n \t}\n #endif\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = data_skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/netrom\/af_netrom.c b\/net\/netrom\/af_netrom.c\nindex 698814bfa7ad..53c19a35fc6d 100644\n--- a\/net\/netrom\/af_netrom.c\n+++ b\/net\/netrom\/af_netrom.c\n@@ -1179,10 +1179,9 @@ static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n+\t\tmsg->msg_namelen = sizeof(*sax);\n \t}\n \n-\tmsg->msg_namelen = sizeof(*sax);\n-\n \tskb_free_datagram(sk, skb);\n \n \trelease_sock(sk);\ndiff --git a\/net\/nfc\/llcp_sock.c b\/net\/nfc\/llcp_sock.c\nindex d308402b67d8..824c6056bf82 100644\n--- a\/net\/nfc\/llcp_sock.c\n+++ b\/net\/nfc\/llcp_sock.c\n@@ -807,8 +807,6 @@ static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tpr_debug(\"%p %zu\\n\", sk, len);\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state == LLCP_CLOSED &&\ndiff --git a\/net\/nfc\/rawsock.c b\/net\/nfc\/rawsock.c\nindex cd958b381f96..66bcd2eb5773 100644\n--- a\/net\/nfc\/rawsock.c\n+++ b\/net\/nfc\/rawsock.c\n@@ -244,8 +244,6 @@ static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn rc;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/packet\/af_packet.c b\/net\/packet\/af_packet.c\nindex 2e8286b47c28..61bd50adead1 100644\n--- a\/net\/packet\/af_packet.c\n+++ b\/net\/packet\/af_packet.c\n@@ -2660,7 +2660,6 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tstruct sock *sk = sock->sk;\n \tstruct sk_buff *skb;\n \tint copied, err;\n-\tstruct sockaddr_ll *sll;\n \tint vnet_hdr_len = 0;\n \n \terr = -EINVAL;\n@@ -2744,22 +2743,10 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tgoto out_free;\n \t}\n \n-\t\/*\n-\t *\tIf the address length field is there to be filled in, we fill\n-\t *\tit in now.\n-\t *\/\n-\n-\tsll = &PACKET_SKB_CB(skb)->sa.ll;\n-\tif (sock->type == SOCK_PACKET)\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n-\telse\n-\t\tmsg->msg_namelen = sll->sll_halen + offsetof(struct sockaddr_ll, sll_addr);\n-\n-\t\/*\n-\t *\tYou lose any data beyond the buffer you gave. If it worries a\n-\t *\tuser program they can ask the device for its MTU anyway.\n+\t\/* You lose any data beyond the buffer you gave. If it worries\n+\t * a user program they can ask the device for its MTU\n+\t * anyway.\n \t *\/\n-\n \tcopied = skb->len;\n \tif (copied > len) {\n \t\tcopied = len;\n@@ -2772,9 +2759,20 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n \n-\tif (msg->msg_name)\n+\tif (msg->msg_name) {\n+\t\t\/* If the address length field is there to be filled\n+\t\t * in, we fill it in now.\n+\t\t *\/\n+\t\tif (sock->type == SOCK_PACKET) {\n+\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n+\t\t} else {\n+\t\t\tstruct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;\n+\t\t\tmsg->msg_namelen = sll->sll_halen +\n+\t\t\t\toffsetof(struct sockaddr_ll, sll_addr);\n+\t\t}\n \t\tmemcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa,\n \t\t       msg->msg_namelen);\n+\t}\n \n \tif (pkt_sk(sk)->auxdata) {\n \t\tstruct tpacket_auxdata aux;\ndiff --git a\/net\/rds\/recv.c b\/net\/rds\/recv.c\nindex 9f0f17cf6bf9..de339b24ca14 100644\n--- a\/net\/rds\/recv.c\n+++ b\/net\/rds\/recv.c\n@@ -410,8 +410,6 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n \ndiff --git a\/net\/rose\/af_rose.c b\/net\/rose\/af_rose.c\nindex e98fcfbe6007..33af77246bfe 100644\n--- a\/net\/rose\/af_rose.c\n+++ b\/net\/rose\/af_rose.c\n@@ -1216,7 +1216,6 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sock *sk = sock->sk;\n \tstruct rose_sock *rose = rose_sk(sk);\n-\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n \tsize_t copied;\n \tunsigned char *asmptr;\n \tstruct sk_buff *skb;\n@@ -1252,8 +1251,11 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (srose != NULL) {\n-\t\tmemset(srose, 0, msg->msg_namelen);\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_rose *srose;\n+\n+\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n+\t\tsrose = msg->msg_name;\n \t\tsrose->srose_family = AF_ROSE;\n \t\tsrose->srose_addr   = rose->dest_addr;\n \t\tsrose->srose_call   = rose->dest_call;\ndiff --git a\/net\/rxrpc\/ar-recvmsg.c b\/net\/rxrpc\/ar-recvmsg.c\nindex 4b48687c3890..898492a8d61b 100644\n--- a\/net\/rxrpc\/ar-recvmsg.c\n+++ b\/net\/rxrpc\/ar-recvmsg.c\n@@ -143,10 +143,13 @@ int rxrpc_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \t\t\/* copy the peer address and timestamp *\/\n \t\tif (!continue_call) {\n-\t\t\tif (msg->msg_name && msg->msg_namelen > 0)\n+\t\t\tif (msg->msg_name) {\n+\t\t\t\tsize_t len =\n+\t\t\t\t\tsizeof(call->conn->trans->peer->srx);\n \t\t\t\tmemcpy(msg->msg_name,\n-\t\t\t\t       &call->conn->trans->peer->srx,\n-\t\t\t\t       sizeof(call->conn->trans->peer->srx));\n+\t\t\t\t       &call->conn->trans->peer->srx, len);\n+\t\t\t\tmsg->msg_namelen = len;\n+\t\t\t}\n \t\t\tsock_recv_ts_and_drops(msg, &rx->sk, skb);\n \t\t}\n \ndiff --git a\/net\/socket.c b\/net\/socket.c\nindex c226aceee65b..fc285564e49e 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -1840,8 +1840,10 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n \tmsg.msg_iov = &iov;\n \tiov.iov_len = size;\n \tiov.iov_base = ubuf;\n-\tmsg.msg_name = (struct sockaddr *)&address;\n-\tmsg.msg_namelen = sizeof(address);\n+\t\/* Save some cycles and don't copy the address if not needed *\/\n+\tmsg.msg_name = addr ? (struct sockaddr *)&address : NULL;\n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg.msg_namelen = 0;\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = sock_recvmsg(sock, &msg, size, flags);\n@@ -2221,16 +2223,14 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \t\t\tgoto out;\n \t}\n \n-\t\/*\n-\t *      Save the user-mode address (verify_iovec will change the\n-\t *      kernel msghdr to use the kernel address space)\n+\t\/* Save the user-mode address (verify_iovec will change the\n+\t * kernel msghdr to use the kernel address space)\n \t *\/\n-\n \tuaddr = (__force void __user *)msg_sys->msg_name;\n \tuaddr_len = COMPAT_NAMELEN(msg);\n-\tif (MSG_CMSG_COMPAT & flags) {\n+\tif (MSG_CMSG_COMPAT & flags)\n \t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n-\t} else\n+\telse\n \t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n \tif (err < 0)\n \t\tgoto out_freeiov;\n@@ -2239,6 +2239,9 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n \tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n \n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg_sys->msg_namelen = 0;\n+\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\ndiff --git a\/net\/tipc\/socket.c b\/net\/tipc\/socket.c\nindex 3906527259d1..3b61851bb927 100644\n--- a\/net\/tipc\/socket.c\n+++ b\/net\/tipc\/socket.c\n@@ -980,9 +980,6 @@ static int recv_msg(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n restart:\n \n@@ -1091,9 +1088,6 @@ static int recv_stream(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n \ndiff --git a\/net\/unix\/af_unix.c b\/net\/unix\/af_unix.c\nindex c1f403bed683..01625ccc3ae6 100644\n--- a\/net\/unix\/af_unix.c\n+++ b\/net\/unix\/af_unix.c\n@@ -1754,7 +1754,6 @@ static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n {\n \tstruct unix_sock *u = unix_sk(sk);\n \n-\tmsg->msg_namelen = 0;\n \tif (u->addr) {\n \t\tmsg->msg_namelen = u->addr->len;\n \t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n@@ -1778,8 +1777,6 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = mutex_lock_interruptible(&u->readlock);\n \tif (err) {\n \t\terr = sock_intr_errno(sock_rcvtimeo(sk, noblock));\n@@ -1924,8 +1921,6 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\n \t *\/\ndiff --git a\/net\/vmw_vsock\/af_vsock.c b\/net\/vmw_vsock\/af_vsock.c\nindex 545c08b8a1d4..5adfd94c5b85 100644\n--- a\/net\/vmw_vsock\/af_vsock.c\n+++ b\/net\/vmw_vsock\/af_vsock.c\n@@ -1662,8 +1662,6 @@ vsock_stream_recvmsg(struct kiocb *kiocb,\n \tvsk = vsock_sk(sk);\n \terr = 0;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state != SS_CONNECTED) {\ndiff --git a\/net\/vmw_vsock\/vmci_transport.c b\/net\/vmw_vsock\/vmci_transport.c\nindex 9d6986634e0b..687360da62d9 100644\n--- a\/net\/vmw_vsock\/vmci_transport.c\n+++ b\/net\/vmw_vsock\/vmci_transport.c\n@@ -1746,8 +1746,6 @@ static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Retrieve the head sk_buff from the socket's receive queue. *\/\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\ndiff --git a\/net\/x25\/af_x25.c b\/net\/x25\/af_x25.c\nindex 45a3ab5612c1..7622789d3750 100644\n--- a\/net\/x25\/af_x25.c\n+++ b\/net\/x25\/af_x25.c\n@@ -1340,10 +1340,9 @@ static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n+\t\tmsg->msg_namelen = sizeof(*sx25);\n \t}\n \n-\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n-\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-3735","CWE_ID":"20","category":"security","commit_id":"fb58e69a84f4fde603a630d2c9df2fa3be16d846","commit_message":"From fb58e69a84f4fde603a630d2c9df2fa3be16d846 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Mon, 20 May 2013 00:52:38 -0700\nSubject: [PATCH] fix bug #64660 - yyparse can return 2, not only 1\n\n---\n NEWS                         |  6 ++++--\n Zend\/tests\/bug64660.phpt     | 11 +++++++++++\n Zend\/zend_language_scanner.c |  6 +++---\n Zend\/zend_language_scanner.l |  4 ++--\n 4 files changed, 20 insertions(+), 7 deletions(-)\n create mode 100644 Zend\/tests\/bug64660.phpt\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex c7aff7f2af35..2dc8815f4d3a 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -4,6 +4,8 @@ PHP                                                                        NEWS\n \n - Core:\n   . Fixed bug #64729 (compilation failure on x32). (Gustavo)\n+  . Fixed bug #64660 (Segfault on memory exhaustion within function definition).\n+    (Stas)\n   . Fixed bug #64853 (Use of no longer available ini directives causes crash on\n     TS build). (Anatol)\n \n@@ -18,12 +20,12 @@ PHP                                                                        NEWS\n \n - SNMP:\n   . Fixed bug #64765 (Some IPv6 addresses get interpreted wrong).\n-\t(Boris Lytochkin)\n+    (Boris Lytochkin)\n   . Fixed bug #64159 (Truncated snmpget). (Boris Lytochkin)\n \n - Zend Engine:\n   . Fixed bug #64821 (Custom Exceptions crash when internal properties overridden).\n-      (Anatol)\n+    (Anatol)\n \n 09 May 2013, PHP 5.4.15\n - Core:\ndiff --git a\/Zend\/tests\/bug64660.phpt b\/Zend\/tests\/bug64660.phpt\nnew file mode 100644\nindex 000000000000..e2b89da1cdd2\n--- \/dev\/null\n+++ b\/Zend\/tests\/bug64660.phpt\n@@ -0,0 +1,11 @@\n+--TEST--\n+Bug #64660 (Segfault on memory exhaustion within function definition)\n+--FILE--\n+<?php\n+function a() {\n+        [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]\n+}\n+echo \"Done\\n\";\n+--EXPECTF--\n+\n+Parse error: memory exhausted in %s on line %d \ndiff --git a\/Zend\/zend_language_scanner.c b\/Zend\/zend_language_scanner.c\nindex 03cf334dbaf6..fa90342616cb 100644\n--- a\/Zend\/zend_language_scanner.c\n+++ b\/Zend\/zend_language_scanner.c\n@@ -1,4 +1,4 @@\n-\/* Generated by re2c 0.13.5 on Wed Mar 27 23:52:29 2013 *\/\n+\/* Generated by re2c 0.13.5 on Mon May 20 00:45:38 2013 *\/\n #line 1 \"Zend\/zend_language_scanner.l\"\n \/*\n    +----------------------------------------------------------------------+\n@@ -585,7 +585,7 @@ ZEND_API zend_op_array *compile_file(zend_file_handle *file_handle, int type TSR\n \t\tcompiler_result = zendparse(TSRMLS_C);\n \t\tzend_do_return(&retval_znode, 0 TSRMLS_CC);\n \t\tCG(in_compilation) = original_in_compilation;\n-\t\tif (compiler_result==1) { \/* parser error *\/\n+\t\tif (compiler_result != 0) { \/* parser error *\/\n \t\t\tzend_bailout();\n \t\t}\n \t\tcompilation_successful=1;\n@@ -760,7 +760,7 @@ zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n \t\t\tSCNG(script_filtered) = NULL;\n \t\t}\n \n-\t\tif (compiler_result==1) {\n+\t\tif (compiler_result != 0) {\n \t\t\tCG(active_op_array) = original_active_op_array;\n \t\t\tCG(unclean_shutdown)=1;\n \t\t\tdestroy_op_array(op_array TSRMLS_CC);\ndiff --git a\/Zend\/zend_language_scanner.l b\/Zend\/zend_language_scanner.l\nindex 97c938ebf6cf..7415d3372096 100644\n--- a\/Zend\/zend_language_scanner.l\n+++ b\/Zend\/zend_language_scanner.l\n@@ -583,7 +583,7 @@ ZEND_API zend_op_array *compile_file(zend_file_handle *file_handle, int type TSR\n \t\tcompiler_result = zendparse(TSRMLS_C);\n \t\tzend_do_return(&retval_znode, 0 TSRMLS_CC);\n \t\tCG(in_compilation) = original_in_compilation;\n-\t\tif (compiler_result==1) { \/* parser error *\/\n+\t\tif (compiler_result != 0) { \/* parser error *\/\n \t\t\tzend_bailout();\n \t\t}\n \t\tcompilation_successful=1;\n@@ -758,7 +758,7 @@ zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n \t\t\tSCNG(script_filtered) = NULL;\n \t\t}\n \n-\t\tif (compiler_result==1) {\n+\t\tif (compiler_result != 0) {\n \t\t\tCG(active_op_array) = original_active_op_array;\n \t\t\tCG(unclean_shutdown)=1;\n \t\t\tdestroy_op_array(op_array TSRMLS_CC);\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2016-4037","CWE_ID":"20","category":"security","commit_id":"1ae3f2f178087711f9591350abad133525ba93f2","commit_message":"From 1ae3f2f178087711f9591350abad133525ba93f2 Mon Sep 17 00:00:00 2001\nFrom: Gerd Hoffmann <kraxel@redhat.com>\nDate: Mon, 18 Apr 2016 09:11:38 +0200\nSubject: [PATCH] ehci: apply limit to iTD\/sidt descriptors\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nCommit \"156a2e4 ehci: make idt processing more robust\" tries to avoid a\nDoS by the guest (create a circular iTD queue and let qemu ehci\nemulation run in circles forever).  Unfortunately this has two problems:\nFirst it misses the case of siTDs, and second it reportedly breaks\nFreeBSD.\n\nSo lets go for a different approach: just count the number of iTDs and\nsiTDs we have seen per frame and apply a limit.  That should really\ncatch all cases now.\n\nReported-by: \u00e6\u009d\u009c\u00e5\u00b0\u0091\u00e5\u008d\u009a <dushaobo@360.cn>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/usb\/hcd-ehci.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/usb\/hcd-ehci.c b\/hw\/usb\/hcd-ehci.c\nindex 159f58d..d5c0e1c 100644\n--- a\/hw\/usb\/hcd-ehci.c\n+++ b\/hw\/usb\/hcd-ehci.c\n@@ -2011,6 +2011,7 @@ static int ehci_state_writeback(EHCIQueue *q)\n static void ehci_advance_state(EHCIState *ehci, int async)\n {\n     EHCIQueue *q = NULL;\n+    int itd_count = 0;\n     int again;\n \n     do {\n@@ -2035,10 +2036,12 @@ static void ehci_advance_state(EHCIState *ehci, int async)\n \n         case EST_FETCHITD:\n             again = ehci_state_fetchitd(ehci, async);\n+            itd_count++;\n             break;\n \n         case EST_FETCHSITD:\n             again = ehci_state_fetchsitd(ehci, async);\n+            itd_count++;\n             break;\n \n         case EST_ADVANCEQUEUE:\n@@ -2087,7 +2090,8 @@ static void ehci_advance_state(EHCIState *ehci, int async)\n             break;\n         }\n \n-        if (again < 0) {\n+        if (again < 0 || itd_count > 16) {\n+            \/* TODO: notify guest (raise HSE irq?) *\/\n             fprintf(stderr, \"processing error - resetting ehci HC\\n\");\n             ehci_reset(ehci);\n             again = 0;\n-- \n1.8.3.1\n\n","owner":"qemu","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2017-18221","CWE_ID":"20","category":"security","commit_id":"70feee0e1ef331b22cc51f383d532a0d043fbdcc","commit_message":"From 70feee0e1ef331b22cc51f383d532a0d043fbdcc Mon Sep 17 00:00:00 2001\nFrom: Yisheng Xie <xieyisheng1@huawei.com>\nDate: Fri, 2 Jun 2017 14:46:43 -0700\nSubject: mlock: fix mlock count can not decrease in race condition\n\nKefeng reported that when running the follow test, the mlock count in\nmeminfo will increase permanently:\n\n [1] testcase\n linux:~ # cat test_mlockal\n grep Mlocked \/proc\/meminfo\n  for j in `seq 0 10`\n  do\n \tfor i in `seq 4 15`\n \tdo\n \t\t.\/p_mlockall >> log &\n \tdone\n \tsleep 0.2\n done\n # wait some time to let mlock counter decrease and 5s may not enough\n sleep 5\n grep Mlocked \/proc\/meminfo\n\n linux:~ # cat p_mlockall.c\n #include <sys\/mman.h>\n #include <stdlib.h>\n #include <stdio.h>\n\n #define SPACE_LEN\t4096\n\n int main(int argc, char ** argv)\n {\n\t \tint ret;\n\t \tvoid *adr = malloc(SPACE_LEN);\n\t \tif (!adr)\n\t \t\treturn -1;\n\n\t \tret = mlockall(MCL_CURRENT | MCL_FUTURE);\n\t \tprintf(\"mlcokall ret = %d\\n\", ret);\n\n\t \tret = munlockall();\n\t \tprintf(\"munlcokall ret = %d\\n\", ret);\n\n\t \tfree(adr);\n\t \treturn 0;\n\t }\n\nIn __munlock_pagevec() we should decrement NR_MLOCK for each page where\nwe clear the PageMlocked flag.  Commit 1ebb7cc6a583 (\"mm: munlock: batch\nNR_MLOCK zone state updates\") has introduced a bug where we don't\ndecrement NR_MLOCK for pages where we clear the flag, but fail to\nisolate them from the lru list (e.g.  when the pages are on some other\ncpu's percpu pagevec).  Since PageMlocked stays cleared, the NR_MLOCK\naccounting gets permanently disrupted by this.\n\nFix it by counting the number of page whose PageMlock flag is cleared.\n\nFixes: 1ebb7cc6a583 (\" mm: munlock: batch NR_MLOCK zone state updates\")\nLink: http:\/\/lkml.kernel.org\/r\/1495678405-54569-1-git-send-email-xieyisheng1@huawei.com\nSigned-off-by: Yisheng Xie <xieyisheng1@huawei.com>\nReported-by: Kefeng Wang <wangkefeng.wang@huawei.com>\nTested-by: Kefeng Wang <wangkefeng.wang@huawei.com>\nCc: Vlastimil Babka <vbabka@suse.cz>\nCc: Joern Engel <joern@logfs.org>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Michel Lespinasse <walken@google.com>\nCc: Hugh Dickins <hughd@google.com>\nCc: Rik van Riel <riel@redhat.com>\nCc: Johannes Weiner <hannes@cmpxchg.org>\nCc: Michal Hocko <mhocko@suse.cz>\nCc: Xishi Qiu <qiuxishi@huawei.com>\nCc: zhongjiang <zhongjiang@huawei.com>\nCc: Hanjun Guo <guohanjun@huawei.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/mlock.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/mm\/mlock.c b\/mm\/mlock.c\nindex c483c5c20b4b..b562b5523a65 100644\n--- a\/mm\/mlock.c\n+++ b\/mm\/mlock.c\n@@ -284,7 +284,7 @@ static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n {\n \tint i;\n \tint nr = pagevec_count(pvec);\n-\tint delta_munlocked;\n+\tint delta_munlocked = -nr;\n \tstruct pagevec pvec_putback;\n \tint pgrescued = 0;\n \n@@ -304,6 +304,8 @@ static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n \t\t\t\tcontinue;\n \t\t\telse\n \t\t\t\t__munlock_isolation_failed(page);\n+\t\t} else {\n+\t\t\tdelta_munlocked++;\n \t\t}\n \n \t\t\/*\n@@ -315,7 +317,6 @@ static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n \t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n \t\tpvec->pages[i] = NULL;\n \t}\n-\tdelta_munlocked = -nr + pagevec_count(&pvec_putback);\n \t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n \tspin_unlock_irq(zone_lru_lock(zone));\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-13715","CWE_ID":"20","category":"security","commit_id":"a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0","commit_message":"From a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0 Mon Sep 17 00:00:00 2001\nFrom: Tom Herbert <tom@herbertland.com>\nDate: Tue, 1 Sep 2015 09:24:26 -0700\nSubject: [PATCH] flow_dissector: Jump to exit code in __skb_flow_dissect\n\nInstead of returning immediately (on a parsing failure for instance) we\njump to cleanup code. This always sets protocol values in key_control\n(even on a failure there is still valid information in the key_tags that\nwas set before the problem was hit).\n\nSigned-off-by: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/core\/flow_dissector.c | 51 +++++++++++++++++++--------------------\n 1 file changed, 25 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/net\/core\/flow_dissector.c b\/net\/core\/flow_dissector.c\nindex 151b6e48b81f1..22f3d768b4592 100644\n--- a\/net\/core\/flow_dissector.c\n+++ b\/net\/core\/flow_dissector.c\n@@ -130,6 +130,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \tstruct flow_dissector_key_tags *key_tags;\n \tstruct flow_dissector_key_keyid *key_keyid;\n \tu8 ip_proto = 0;\n+\tbool ret = false;\n \n \tif (!data) {\n \t\tdata = skb->data;\n@@ -171,7 +172,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n ip:\n \t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n \t\tif (!iph || iph->ihl < 5)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \t\tnhoff += iph->ihl * 4;\n \n \t\tip_proto = iph->protocol;\n@@ -197,7 +198,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n ipv6:\n \t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n \t\tif (!iph)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \n \t\tip_proto = iph->nexthdr;\n \t\tnhoff += sizeof(struct ipv6hdr);\n@@ -234,7 +235,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \n \t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n \t\tif (!vlan)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \n \t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n@@ -256,7 +257,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\t} *hdr, _hdr;\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \t\tproto = hdr->proto;\n \t\tnhoff += PPPOE_SES_HLEN;\n \t\tswitch (proto) {\n@@ -265,7 +266,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\tcase htons(PPP_IPV6):\n \t\t\tgoto ipv6;\n \t\tdefault:\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \t\t}\n \t}\n \tcase htons(ETH_P_TIPC): {\n@@ -275,9 +276,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\t} *hdr, _hdr;\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n-\t\t\treturn false;\n-\t\tkey_basic->n_proto = proto;\n-\t\tkey_control->thoff = (u16)nhoff;\n+\t\t\tgoto out_bad;\n \n \t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n@@ -287,7 +286,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n \t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n \t\t}\n-\t\treturn true;\n+\t\tgoto out_good;\n \t}\n \n \tcase htons(ETH_P_MPLS_UC):\n@@ -297,7 +296,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n \t\t\t\t\t   hlen, &_hdr);\n \t\tif (!hdr)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \n \t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n \t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n@@ -310,21 +309,17 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n \t\t\t}\n \n-\t\t\tkey_basic->n_proto = proto;\n-\t\t\tkey_basic->ip_proto = ip_proto;\n-\t\t\tkey_control->thoff = (u16)nhoff;\n-\n-\t\t\treturn true;\n+\t\t\tgoto out_good;\n \t\t}\n \n-\t\treturn true;\n+\t\tgoto out_good;\n \t}\n \n \tcase htons(ETH_P_FCOE):\n \t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n \t\t\/* fall through *\/\n \tdefault:\n-\t\treturn false;\n+\t\tgoto out_bad;\n \t}\n \n ip_proto_again:\n@@ -337,7 +332,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \t\t\/*\n \t\t * Only look inside GRE if version zero and no\n \t\t * routing\n@@ -357,7 +352,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\t\t\t\t\t     data, hlen, &_keyid);\n \n \t\t\tif (!keyid)\n-\t\t\t\treturn false;\n+\t\t\t\tgoto out_bad;\n \n \t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n@@ -378,7 +373,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\t\t\t\t\t   sizeof(_eth),\n \t\t\t\t\t\t   data, hlen, &_eth);\n \t\t\tif (!eth)\n-\t\t\t\treturn false;\n+\t\t\t\tgoto out_bad;\n \t\t\tproto = eth->h_proto;\n \t\t\tnhoff += sizeof(*eth);\n \t\t}\n@@ -395,7 +390,7 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n \t\t\t\t\t      data, hlen, &_opthdr);\n \t\tif (!opthdr)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \n \t\tip_proto = opthdr[0];\n \t\tnhoff += (opthdr[1] + 1) << 3;\n@@ -415,10 +410,6 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\tbreak;\n \t}\n \n-\tkey_basic->n_proto = proto;\n-\tkey_basic->ip_proto = ip_proto;\n-\tkey_control->thoff = (u16)nhoff;\n-\n \tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n \t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n@@ -428,7 +419,15 @@ bool __skb_flow_dissect(const struct sk_buff *skb,\n \t\t\t\t\t\t\tdata, hlen);\n \t}\n \n-\treturn true;\n+out_good:\n+\tret = true;\n+\n+out_bad:\n+\tkey_basic->n_proto = proto;\n+\tkey_basic->ip_proto = ip_proto;\n+\tkey_control->thoff = (u16)nhoff;\n+\n+\treturn ret;\n }\n EXPORT_SYMBOL(__skb_flow_dissect);\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-2547","CWE_ID":"20","category":"security","commit_id":"b5a663aa426f4884c71cd8580adae73f33570f0d","commit_message":"From b5a663aa426f4884c71cd8580adae73f33570f0d Mon Sep 17 00:00:00 2001\nFrom: Takashi Iwai <tiwai@suse.de>\nDate: Thu, 14 Jan 2016 16:30:58 +0100\nSubject: ALSA: timer: Harden slave timer list handling\n\nA slave timer instance might be still accessible in a racy way while\noperating the master instance as it lacks of locking.  Since the\nmaster operation is mostly protected with timer->lock, we should cope\nwith it while changing the slave instance, too.  Also, some linked\nlists (active_list and ack_list) of slave instances aren't unlinked\nimmediately at stopping or closing, and this may lead to unexpected\naccesses.\n\nThis patch tries to address these issues.  It adds spin lock of\ntimer->lock (either from master or slave, which is equivalent) in a\nfew places.  For avoiding a deadlock, we ensure that the global\nslave_active_lock is always locked at first before each timer lock.\n\nAlso, ack and active_list of slave instances are properly unlinked at\nsnd_timer_stop() and snd_timer_close().\n\nLast but not least, remove the superfluous call of _snd_timer_stop()\nat removing slave links.  This is a noop, and calling it may confuse\nreaders wrt locking.  Further cleanup will follow in a later patch.\n\nActually we've got reports of use-after-free by syzkaller fuzzer, and\nthis hopefully fixes these issues.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\n---\n sound\/core\/timer.c | 18 ++++++++++++++----\n 1 file changed, 14 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/sound\/core\/timer.c b\/sound\/core\/timer.c\nindex 3810ee8f1205..4e8d7bfffff6 100644\n--- a\/sound\/core\/timer.c\n+++ b\/sound\/core\/timer.c\n@@ -215,11 +215,13 @@ static void snd_timer_check_master(struct snd_timer_instance *master)\n \t\t    slave->slave_id == master->slave_id) {\n \t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n \t\t\tspin_lock_irq(&slave_active_lock);\n+\t\t\tspin_lock(&master->timer->lock);\n \t\t\tslave->master = master;\n \t\t\tslave->timer = master->timer;\n \t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n \t\t\t\tlist_add_tail(&slave->active_list,\n \t\t\t\t\t      &master->slave_active_head);\n+\t\t\tspin_unlock(&master->timer->lock);\n \t\t\tspin_unlock_irq(&slave_active_lock);\n \t\t}\n \t}\n@@ -346,15 +348,18 @@ int snd_timer_close(struct snd_timer_instance *timeri)\n \t\t    timer->hw.close)\n \t\t\ttimer->hw.close(timer);\n \t\t\/* remove slave links *\/\n+\t\tspin_lock_irq(&slave_active_lock);\n+\t\tspin_lock(&timer->lock);\n \t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n \t\t\t\t\t open_list) {\n-\t\t\tspin_lock_irq(&slave_active_lock);\n-\t\t\t_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);\n \t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n \t\t\tslave->master = NULL;\n \t\t\tslave->timer = NULL;\n-\t\t\tspin_unlock_irq(&slave_active_lock);\n+\t\t\tlist_del_init(&slave->ack_list);\n+\t\t\tlist_del_init(&slave->active_list);\n \t\t}\n+\t\tspin_unlock(&timer->lock);\n+\t\tspin_unlock_irq(&slave_active_lock);\n \t\tmutex_unlock(&register_mutex);\n \t}\n  out:\n@@ -441,9 +446,12 @@ static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n \n \tspin_lock_irqsave(&slave_active_lock, flags);\n \ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n-\tif (timeri->master)\n+\tif (timeri->master && timeri->timer) {\n+\t\tspin_lock(&timeri->timer->lock);\n \t\tlist_add_tail(&timeri->active_list,\n \t\t\t      &timeri->master->slave_active_head);\n+\t\tspin_unlock(&timeri->timer->lock);\n+\t}\n \tspin_unlock_irqrestore(&slave_active_lock, flags);\n \treturn 1; \/* delayed start *\/\n }\n@@ -489,6 +497,8 @@ static int _snd_timer_stop(struct snd_timer_instance * timeri,\n \t\tif (!keep_flag) {\n \t\t\tspin_lock_irqsave(&slave_active_lock, flags);\n \t\t\ttimeri->flags &= ~SNDRV_TIMER_IFLG_RUNNING;\n+\t\t\tlist_del_init(&timeri->ack_list);\n+\t\t\tlist_del_init(&timeri->active_list);\n \t\t\tspin_unlock_irqrestore(&slave_active_lock, flags);\n \t\t}\n \t\tgoto __end;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-4579","CWE_ID":"20","category":"security","commit_id":"a7eed17a0b2a1c09ef986f3b4b323cd31cea2b64","commit_message":"From a7eed17a0b2a1c09ef986f3b4b323cd31cea2b64 Mon Sep 17 00:00:00 2001\nFrom: Werner Koch <wk@gnupg.org>\nDate: Tue, 3 May 2016 14:10:04 +0200\nSubject: [PATCH] Fix possible read access beyond the buffer.\n\n* src\/ber-help.c (_ksba_ber_parse_tl): Add extra sanity check.\n* src\/cert.c (ksba_cert_get_cert_policies): Check TLV given length\nagainst buffer length.\n(ksba_cert_get_ext_key_usages): Ditto.\n* src\/ocsp.c (parse_asntime_into_isotime): Ditto.\n--\n\nThe returned length of the object from _ksba_ber_parse_tl (ti.length)\nwas not always checked against the actual buffer length, thus leading\nto a read access after the end of the buffer and thus a segv.\n\nGnuPG-bug-id: 2344\nReported-by: Pascal Cuoq\nSigned-off-by: Werner Koch <wk@gnupg.org>\n---\n src\/ber-help.c |  6 ++++++\n src\/cert.c     | 23 ++++++++++++++++++++++-\n src\/name.c     |  2 +-\n src\/ocsp.c     |  2 ++\n 4 files changed, 31 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/ber-help.c b\/src\/ber-help.c\nindex f6a6692..87109f3 100644\n--- a\/src\/ber-help.c\n+++ b\/src\/ber-help.c\n@@ -285,9 +285,15 @@ _ksba_ber_parse_tl (unsigned char const **buffer, size_t *size,\n           ti->buf[ti->nhdr++] = c;\n           len |= c & 0xff;\n         }\n+      \/* Sanity check for the length: This is done so that we can take\n+       * the value for malloc plus some additional bytes without\n+       * risking an overflow.  *\/\n+      if (len > (1 << 30))\n+        return gpg_error (GPG_ERR_BAD_BER);\n       ti->length = len;\n     }\n \n+\n   \/* Without this kludge some example certs can't be parsed *\/\n   if (ti->class == CLASS_UNIVERSAL && !ti->tag)\n     ti->length = 0;\ndiff --git a\/src\/cert.c b\/src\/cert.c\nindex 7f19dc1..f3ff6a1 100644\n--- a\/src\/cert.c\n+++ b\/src\/cert.c\n@@ -1335,9 +1335,15 @@ ksba_cert_get_cert_policies (ksba_cert_t cert, char **r_policies)\n                   err = gpg_error (GPG_ERR_NOT_DER_ENCODED);\n                   goto leave;\n                 }\n+              if (ti.length > derlen)\n+                {\n+                  err = gpg_error (GPG_ERR_BAD_BER);\n+                  goto leave;\n+                }\n               if (!ti.length)\n                 {\n-                  err = gpg_error (GPG_ERR_INV_CERT_OBJ); \/* no empty inner SEQ *\/\n+                  \/* We do not accept an empty inner SEQ *\/\n+                  err = gpg_error (GPG_ERR_INV_CERT_OBJ);\n                   goto leave;\n                 }\n               if (ti.nhdr+ti.length > seqlen)\n@@ -1356,6 +1362,11 @@ ksba_cert_get_cert_policies (ksba_cert_t cert, char **r_policies)\n                   err = gpg_error (GPG_ERR_INV_CERT_OBJ);\n                   goto leave;\n                 }\n+              if (ti.length > derlen)\n+                {\n+                  err = gpg_error (GPG_ERR_BAD_BER);\n+                  goto leave;\n+                }\n               if (ti.nhdr+ti.length > seqseqlen)\n                 {\n                   err = gpg_error (GPG_ERR_BAD_BER);\n@@ -1458,6 +1469,16 @@ ksba_cert_get_ext_key_usages (ksba_cert_t cert, char **result)\n                   err = gpg_error (GPG_ERR_INV_CERT_OBJ);\n                   goto leave;\n                 }\n+              if (ti.ndef)\n+                {\n+                  err = gpg_error (GPG_ERR_NOT_DER_ENCODED);\n+                  goto leave;\n+                }\n+              if (ti.length > derlen)\n+                {\n+                  err = gpg_error (GPG_ERR_BAD_BER);\n+                  goto leave;\n+                }\n \n               suboid = ksba_oid_to_str (der, ti.length);\n               if (!suboid)\ndiff --git a\/src\/name.c b\/src\/name.c\nindex c734199..371fc41 100644\n--- a\/src\/name.c\n+++ b\/src\/name.c\n@@ -113,7 +113,7 @@ _ksba_name_new_from_der (ksba_name_t *r_name,\n \n   *r_name = NULL;\n \n-  \/* count and check for encoding errors - we won;t do this again\n+  \/* Count and check for encoding errors - we won't do this again\n      during the second pass *\/\n   der = image;\n   derlen = imagelen;\ndiff --git a\/src\/ocsp.c b\/src\/ocsp.c\nindex 85679bb..c053b18 100644\n--- a\/src\/ocsp.c\n+++ b\/src\/ocsp.c\n@@ -231,6 +231,8 @@ parse_asntime_into_isotime (unsigned char const **buf, size_t *len,\n               && (ti.tag == TYPE_UTC_TIME || ti.tag == TYPE_GENERALIZED_TIME)\n               && !ti.is_constructed) )\n     err = gpg_error (GPG_ERR_INV_OBJ);\n+  else if (ti.length > *len)\n+    err = gpg_error (GPG_ERR_INV_BER);\n   else if (!(err = _ksba_asntime_to_iso (*buf, ti.length,\n                                          ti.tag == TYPE_UTC_TIME, isotime)))\n     parse_skip (buf, len, &ti);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-3640","CWE_ID":"20","category":"security","commit_id":"88c808fd42b53a7e01a2ac3253ef31fef74cb5af","commit_message":"From 88c808fd42b53a7e01a2ac3253ef31fef74cb5af Mon Sep 17 00:00:00 2001\nFrom: Avi Kivity <avi@redhat.com>\nDate: Mon, 17 Aug 2009 22:49:40 +0300\nSubject: KVM: Protect update_cr8_intercept() when running without an apic\n\nupdate_cr8_intercept() can be triggered from userspace while there\nis no apic present.\n\nSigned-off-by: Avi Kivity <avi@redhat.com>\n---\n arch\/x86\/kvm\/x86.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/x86.c b\/arch\/x86\/kvm\/x86.c\nindex 59a8ba4d56bd..35e7fc54de35 100644\n--- a\/arch\/x86\/kvm\/x86.c\n+++ b\/arch\/x86\/kvm\/x86.c\n@@ -3500,6 +3500,9 @@ static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n \tif (!kvm_x86_ops->update_cr8_intercept)\n \t\treturn;\n \n+\tif (!vcpu->arch.apic)\n+\t\treturn;\n+\n \tif (!vcpu->arch.apic->vapic_addr)\n \t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n \telse\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12180","CWE_ID":"20","category":"security","commit_id":"1b1d4c04695dced2463404174b50b3581dbd857b","commit_message":"From 1b1d4c04695dced2463404174b50b3581dbd857b Mon Sep 17 00:00:00 2001\nFrom: Nathan Kidd <nkidd@opentext.com>\nDate: Sun, 21 Dec 2014 01:10:03 -0500\nSubject: hw\/xfree86: unvalidated lengths\n\nThis addresses:\nCVE-2017-12180 in XFree86-VidModeExtension\nCVE-2017-12181 in XFree86-DGA\nCVE-2017-12182 in XFree86-DRI\n\nReviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Nathan Kidd <nkidd@opentext.com>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n Xext\/vidmode.c              | 129 ++++++++++++++++++++++++--------------------\n hw\/xfree86\/common\/xf86DGA.c |  81 ++++++++++++++++------------\n hw\/xfree86\/dri\/xf86dri.c    |   1 +\n 3 files changed, 117 insertions(+), 94 deletions(-)\n\n","diff_code":"diff --git a\/Xext\/vidmode.c b\/Xext\/vidmode.c\nindex 8ba919a..6e4a7c7 100644\n--- a\/Xext\/vidmode.c\n+++ b\/Xext\/vidmode.c\n@@ -454,6 +454,20 @@ ProcVidModeAddModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeAddModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeAddModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeAddModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeAddModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeAddModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -501,18 +515,6 @@ ProcVidModeAddModeLine(ClientPtr client)\n            stuff->after_vsyncend, stuff->after_vtotal,\n            (unsigned long) stuff->after_flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeAddModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeAddModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeAddModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeAddModeLineReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -622,6 +624,20 @@ ProcVidModeDeleteModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeDeleteModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeDeleteModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeDeleteModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeDeleteModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeDeleteModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -649,18 +665,6 @@ ProcVidModeDeleteModeLine(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,\n            (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeDeleteModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeDeleteModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeDeleteModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeDeleteModeLineReq));\n-    }\n     if (len != stuff->privsize) {\n         DebugF(\"req_len = %ld, sizeof(Req) = %d, privsize = %ld, \"\n                \"len = %d, length = %d\\n\",\n@@ -744,6 +748,20 @@ ProcVidModeModModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeModModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeModModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeModModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeModModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeModModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -768,18 +786,6 @@ ProcVidModeModModeLine(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend,\n            stuff->vtotal, (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeModModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeModModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeModModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeModModeLineReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -877,6 +883,19 @@ ProcVidModeValidateModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeValidateModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeValidateModeLineReq);\n+        len = client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeValidateModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeValidateModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeValidateModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -905,17 +924,6 @@ ProcVidModeValidateModeLine(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,\n            (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeValidateModeLineReq);\n-        len = client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeValidateModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeValidateModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeValidateModeLineReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -1027,6 +1035,20 @@ ProcVidModeSwitchToMode(ClientPtr client)\n     DEBUG_P(\"XF86VidModeSwitchToMode\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeSwitchToModeReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeSwitchToModeReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeSwitchToModeReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeSwitchToModeReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -1055,18 +1077,6 @@ ProcVidModeSwitchToMode(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,\n            (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeSwitchToModeReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeSwitchToModeReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeSwitchToModeReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeSwitchToModeReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -1457,6 +1467,7 @@ ProcVidModeSetGammaRamp(ClientPtr client)\n     VidModePtr pVidMode;\n \n     REQUEST(xXF86VidModeSetGammaRampReq);\n+    REQUEST_AT_LEAST_SIZE(xXF86VidModeSetGammaRampReq);\n \n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\ndiff --git a\/hw\/xfree86\/common\/xf86DGA.c b\/hw\/xfree86\/common\/xf86DGA.c\nindex 95434e8..505b019 100644\n--- a\/hw\/xfree86\/common\/xf86DGA.c\n+++ b\/hw\/xfree86\/common\/xf86DGA.c\n@@ -1272,13 +1272,14 @@ ProcXDGAOpenFramebuffer(ClientPtr client)\n     char *deviceName;\n     int nameSize;\n \n+    REQUEST_SIZE_MATCH(xXDGAOpenFramebufferReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n \n-    REQUEST_SIZE_MATCH(xXDGAOpenFramebufferReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1305,14 +1306,14 @@ ProcXDGACloseFramebuffer(ClientPtr client)\n {\n     REQUEST(xXDGACloseFramebufferReq);\n \n+    REQUEST_SIZE_MATCH(xXDGACloseFramebufferReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n \n-    REQUEST_SIZE_MATCH(xXDGACloseFramebufferReq);\n-\n     DGACloseFramebuffer(stuff->screen);\n \n     return Success;\n@@ -1328,10 +1329,11 @@ ProcXDGAQueryModes(ClientPtr client)\n     xXDGAModeInfo info;\n     XDGAModePtr mode;\n \n+    REQUEST_SIZE_MATCH(xXDGAQueryModesReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXDGAQueryModesReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.number = 0;\n@@ -1443,11 +1445,12 @@ ProcXDGASetMode(ClientPtr client)\n     ClientPtr owner;\n     int size;\n \n+    REQUEST_SIZE_MATCH(xXDGASetModeReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n     owner = DGA_GETCLIENT(stuff->screen);\n \n-    REQUEST_SIZE_MATCH(xXDGASetModeReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.offset = 0;\n@@ -1533,14 +1536,14 @@ ProcXDGASetViewport(ClientPtr client)\n {\n     REQUEST(xXDGASetViewportReq);\n \n+    REQUEST_SIZE_MATCH(xXDGASetViewportReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGASetViewportReq);\n-\n     DGASetViewport(stuff->screen, stuff->x, stuff->y, stuff->flags);\n \n     return Success;\n@@ -1554,14 +1557,14 @@ ProcXDGAInstallColormap(ClientPtr client)\n \n     REQUEST(xXDGAInstallColormapReq);\n \n+    REQUEST_SIZE_MATCH(xXDGAInstallColormapReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAInstallColormapReq);\n-\n     rc = dixLookupResourceByType((void **) &cmap, stuff->cmap, RT_COLORMAP,\n                                  client, DixInstallAccess);\n     if (rc != Success)\n@@ -1575,14 +1578,14 @@ ProcXDGASelectInput(ClientPtr client)\n {\n     REQUEST(xXDGASelectInputReq);\n \n+    REQUEST_SIZE_MATCH(xXDGASelectInputReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGASelectInputReq);\n-\n     if (DGA_GETCLIENT(stuff->screen) == client)\n         DGASelectInput(stuff->screen, client, stuff->mask);\n \n@@ -1594,14 +1597,14 @@ ProcXDGAFillRectangle(ClientPtr client)\n {\n     REQUEST(xXDGAFillRectangleReq);\n \n+    REQUEST_SIZE_MATCH(xXDGAFillRectangleReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAFillRectangleReq);\n-\n     if (Success != DGAFillRect(stuff->screen, stuff->x, stuff->y,\n                                stuff->width, stuff->height, stuff->color))\n         return BadMatch;\n@@ -1614,14 +1617,14 @@ ProcXDGACopyArea(ClientPtr client)\n {\n     REQUEST(xXDGACopyAreaReq);\n \n+    REQUEST_SIZE_MATCH(xXDGACopyAreaReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGACopyAreaReq);\n-\n     if (Success != DGABlitRect(stuff->screen, stuff->srcx, stuff->srcy,\n                                stuff->width, stuff->height, stuff->dstx,\n                                stuff->dsty))\n@@ -1635,14 +1638,14 @@ ProcXDGACopyTransparentArea(ClientPtr client)\n {\n     REQUEST(xXDGACopyTransparentAreaReq);\n \n+    REQUEST_SIZE_MATCH(xXDGACopyTransparentAreaReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGACopyTransparentAreaReq);\n-\n     if (Success != DGABlitTransRect(stuff->screen, stuff->srcx, stuff->srcy,\n                                     stuff->width, stuff->height, stuff->dstx,\n                                     stuff->dsty, stuff->key))\n@@ -1657,13 +1660,14 @@ ProcXDGAGetViewportStatus(ClientPtr client)\n     REQUEST(xXDGAGetViewportStatusReq);\n     xXDGAGetViewportStatusReply rep;\n \n+    REQUEST_SIZE_MATCH(xXDGAGetViewportStatusReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAGetViewportStatusReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1680,13 +1684,14 @@ ProcXDGASync(ClientPtr client)\n     REQUEST(xXDGASyncReq);\n     xXDGASyncReply rep;\n \n+    REQUEST_SIZE_MATCH(xXDGASyncReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGASyncReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1725,13 +1730,14 @@ ProcXDGAChangePixmapMode(ClientPtr client)\n     xXDGAChangePixmapModeReply rep;\n     int x, y;\n \n+    REQUEST_SIZE_MATCH(xXDGAChangePixmapModeReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAChangePixmapModeReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1755,14 +1761,14 @@ ProcXDGACreateColormap(ClientPtr client)\n     REQUEST(xXDGACreateColormapReq);\n     int result;\n \n+    REQUEST_SIZE_MATCH(xXDGACreateColormapReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGACreateColormapReq);\n-\n     if (!stuff->mode)\n         return BadValue;\n \n@@ -1791,10 +1797,11 @@ ProcXF86DGAGetVideoLL(ClientPtr client)\n     int num, offset, flags;\n     char *name;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAGetVideoLLReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAGetVideoLLReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1831,9 +1838,10 @@ ProcXF86DGADirectVideo(ClientPtr client)\n \n     REQUEST(xXF86DGADirectVideoReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGADirectVideoReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n-    REQUEST_SIZE_MATCH(xXF86DGADirectVideoReq);\n \n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n@@ -1889,10 +1897,11 @@ ProcXF86DGAGetViewPortSize(ClientPtr client)\n     REQUEST(xXF86DGAGetViewPortSizeReq);\n     xXF86DGAGetViewPortSizeReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAGetViewPortSizeReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAGetViewPortSizeReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1917,14 +1926,14 @@ ProcXF86DGASetViewPort(ClientPtr client)\n {\n     REQUEST(xXF86DGASetViewPortReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGASetViewPortReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXF86DGASetViewPortReq);\n-\n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n \n@@ -1944,10 +1953,11 @@ ProcXF86DGAGetVidPage(ClientPtr client)\n     REQUEST(xXF86DGAGetVidPageReq);\n     xXF86DGAGetVidPageReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAGetVidPageReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAGetVidPageReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1962,11 +1972,11 @@ ProcXF86DGASetVidPage(ClientPtr client)\n {\n     REQUEST(xXF86DGASetVidPageReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGASetVidPageReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGASetVidPageReq);\n-\n     \/* silently fail *\/\n \n     return Success;\n@@ -1980,14 +1990,14 @@ ProcXF86DGAInstallColormap(ClientPtr client)\n \n     REQUEST(xXF86DGAInstallColormapReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGAInstallColormapReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAInstallColormapReq);\n-\n     if (!DGAActive(stuff->screen))\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n@@ -2008,10 +2018,11 @@ ProcXF86DGAQueryDirectVideo(ClientPtr client)\n     REQUEST(xXF86DGAQueryDirectVideoReq);\n     xXF86DGAQueryDirectVideoReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAQueryDirectVideoReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAQueryDirectVideoReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -2030,14 +2041,14 @@ ProcXF86DGAViewPortChanged(ClientPtr client)\n     REQUEST(xXF86DGAViewPortChangedReq);\n     xXF86DGAViewPortChangedReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAViewPortChangedReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAViewPortChangedReq);\n-\n     if (!DGAActive(stuff->screen))\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \ndiff --git a\/hw\/xfree86\/dri\/xf86dri.c b\/hw\/xfree86\/dri\/xf86dri.c\nindex 8f3c2d6..d356db9 100644\n--- a\/hw\/xfree86\/dri\/xf86dri.c\n+++ b\/hw\/xfree86\/dri\/xf86dri.c\n@@ -570,6 +570,7 @@ static int _X_COLD\n SProcXF86DRIQueryDirectRenderingCapable(register ClientPtr client)\n {\n     REQUEST(xXF86DRIQueryDirectRenderingCapableReq);\n+    REQUEST_SIZE_MATCH(xXF86DRIQueryDirectRenderingCapableReq);\n     swaps(&stuff->length);\n     swapl(&stuff->screen);\n     return ProcXF86DRIQueryDirectRenderingCapable(client);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2008-2750","CWE_ID":"20","category":"security","commit_id":"6b6707a50c7598a83820077393f8823ab791abf8","commit_message":"From 6b6707a50c7598a83820077393f8823ab791abf8 Mon Sep 17 00:00:00 2001\nFrom: James Chapman <jchapman@katalix.com>\nDate: Tue, 10 Jun 2008 12:35:00 -0700\nSubject: l2tp: Fix potential memory corruption in pppol2tp_recvmsg()\n\nThis patch fixes a potential memory corruption in\npppol2tp_recvmsg(). If skb->len is bigger than the caller's buffer\nlength, memcpy_toiovec() will go into unintialized data on the kernel\nheap, interpret it as an iovec and start modifying memory.\n\nThe fix is to change the memcpy_toiovec() call to\nskb_copy_datagram_iovec() so that paged packets (rare for PPPOL2TP)\nare handled properly. Also check that the caller's buffer is big\nenough for the data and set the MSG_TRUNC flag if it is not so.\n\nReported-by: Ilja <ilja@netric.org>\nSigned-off-by: James Chapman <jchapman@katalix.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/pppol2tp.c | 20 ++++++++++++--------\n 1 file changed, 12 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/pppol2tp.c b\/drivers\/net\/pppol2tp.c\nindex 70cfdb46aa27..f9298827a76c 100644\n--- a\/drivers\/net\/pppol2tp.c\n+++ b\/drivers\/net\/pppol2tp.c\n@@ -783,14 +783,18 @@ static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n \terr = 0;\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n-\tif (skb) {\n-\t\terr = memcpy_toiovec(msg->msg_iov, (unsigned char *) skb->data,\n-\t\t\t\t     skb->len);\n-\t\tif (err < 0)\n-\t\t\tgoto do_skb_free;\n-\t\terr = skb->len;\n-\t}\n-do_skb_free:\n+\tif (!skb)\n+\t\tgoto end;\n+\n+\tif (len > skb->len)\n+\t\tlen = skb->len;\n+\telse if (len < skb->len)\n+\t\tmsg->msg_flags |= MSG_TRUNC;\n+\n+\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n+\tif (likely(err == 0))\n+\t\terr = len;\n+\n \tkfree_skb(skb);\n end:\n \treturn err;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-5358","CWE_ID":"20","category":"security","commit_id":"2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7","commit_message":"From 2c13e97d656c1c0ac4d76eb9d307664aae0e0cf7 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Sat, 14 May 2016 01:15:56 -0700\nSubject: [PATCH] The WTAP_ENCAP_ETHERNET dissector needs to be passed a struct\n eth_phdr.\n\nWe now require that.  Make it so.\n\nBug: 12440\nChange-Id: Iffee520976b013800699bde3c6092a3e86be0d76\nReviewed-on: https:\/\/code.wireshark.org\/review\/15424\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n---\n epan\/dissectors\/packet-pktap.c | 19 +++++++++++++++++--\n epan\/dissectors\/packet-ppi.c   | 19 +++++++++++++++++--\n epan\/dissectors\/packet-rpcap.c | 15 ++++++++++++++-\n 3 files changed, 48 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/epan\/dissectors\/packet-pktap.c b\/epan\/dissectors\/packet-pktap.c\nindex 6825cdb629..59a6d4c00f 100644\n--- a\/epan\/dissectors\/packet-pktap.c\n+++ b\/epan\/dissectors\/packet-pktap.c\n@@ -135,6 +135,9 @@ dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n \ttvbuff_t *next_tvb;\n \tint offset = 0;\n \tguint32 pkt_len, rectype, dlt;\n+\tint wtap_encap;\n+\tstruct eth_phdr eth;\n+\tvoid *phdr;\n \n \tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"PKTAP\");\n \tcol_clear(pinfo->cinfo, COL_INFO);\n@@ -202,8 +205,20 @@ dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n \n \tif (rectype == PKT_REC_PACKET) {\n \t\tnext_tvb = tvb_new_subset_remaining(tvb, pkt_len);\n-\t\tdissector_try_uint(wtap_encap_dissector_table,\n-\t\t    wtap_pcap_encap_to_wtap_encap(dlt), next_tvb, pinfo, tree);\n+\t\twtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);\n+\t\tswitch (wtap_encap) {\n+\n+\t\tcase WTAP_ENCAP_ETHERNET:\n+\t\t\teth.fcs_len = -1;    \/* Unknown whether we have an FCS *\/\n+\t\t\tphdr = &eth;\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tphdr = NULL;\n+\t\t\tbreak;\n+\t\t}\n+\t\tdissector_try_uint_new(wtap_encap_dissector_table,\n+\t\t    wtap_encap, next_tvb, pinfo, tree, TRUE, phdr);\n \t}\n }\n \ndiff --git a\/epan\/dissectors\/packet-ppi.c b\/epan\/dissectors\/packet-ppi.c\nindex 95693ca5e3..c8eb503adf 100644\n--- a\/epan\/dissectors\/packet-ppi.c\n+++ b\/epan\/dissectors\/packet-ppi.c\n@@ -857,6 +857,9 @@ dissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n     guint          last_frame  = 0;\n     gint len_remain, \/*pad_len = 0,*\/ ampdu_len = 0;\n     struct ieee_802_11_phdr phdr;\n+    int            wtap_encap;\n+    struct eth_phdr eth;\n+    void          *phdrp;\n \n     col_set_str(pinfo->cinfo, COL_PROTOCOL, \"PPI\");\n     col_clear(pinfo->cinfo, COL_INFO);\n@@ -1137,8 +1140,20 @@ dissect_ppi(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n         call_dissector_with_data(ieee80211_radio_handle, next_tvb, pinfo, tree, &phdr);\n     } else {\n         \/* Everything else.  This will pass a NULL data argument. *\/\n-        dissector_try_uint(wtap_encap_dissector_table,\n-            wtap_pcap_encap_to_wtap_encap(dlt), next_tvb, pinfo, tree);\n+        wtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);\n+        switch (wtap_encap) {\n+\n+        case WTAP_ENCAP_ETHERNET:\n+            eth.fcs_len = -1;    \/* Unknown whether we have an FCS *\/\n+            phdrp = &eth;\n+            break;\n+\n+        default:\n+            phdrp = NULL;\n+            break;\n+        }\n+        dissector_try_uint_new(wtap_encap_dissector_table,\n+            wtap_encap, next_tvb, pinfo, tree, TRUE, phdrp);\n     }\n }\n \ndiff --git a\/epan\/dissectors\/packet-rpcap.c b\/epan\/dissectors\/packet-rpcap.c\nindex 46a2e62c8b..673421a9fd 100644\n--- a\/epan\/dissectors\/packet-rpcap.c\n+++ b\/epan\/dissectors\/packet-rpcap.c\n@@ -838,6 +838,8 @@ dissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,\n   tvbuff_t *new_tvb;\n   guint caplen, len, frame_no;\n   gint reported_length_remaining;\n+  struct eth_phdr eth;\n+  void *phdr;\n \n   ti = proto_tree_add_item (parent_tree, hf_packet, tvb, offset, 20, ENC_NA);\n   tree = proto_item_add_subtree (ti, ett_packet);\n@@ -874,7 +876,18 @@ dissect_rpcap_packet (tvbuff_t *tvb, packet_info *pinfo, proto_tree *top_tree,\n \n   new_tvb = tvb_new_subset (tvb, offset, caplen, len);\n   if (decode_content && linktype != WTAP_ENCAP_UNKNOWN) {\n-    dissector_try_uint(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree);\n+    switch (linktype) {\n+\n+    case WTAP_ENCAP_ETHERNET:\n+      eth.fcs_len = -1;    \/* Unknown whether we have an FCS *\/\n+      phdr = &eth;\n+      break;\n+\n+    default:\n+      phdr = NULL;\n+      break;\n+    }\n+    dissector_try_uint_new(wtap_encap_dissector_table, linktype, new_tvb, pinfo, top_tree, TRUE, phdr);\n \n     if (!info_added) {\n       \/* Only indicate when not added before *\/\n","owner":"wireshark","repo":"wireshark","source":"cve"},{"CVE_ID":"CVE-2009-4031","CWE_ID":"20","category":"security","commit_id":"e42d9b8141d1f54ff72ad3850bb110c95a5f3b88","commit_message":"From e42d9b8141d1f54ff72ad3850bb110c95a5f3b88 Mon Sep 17 00:00:00 2001\nFrom: Avi Kivity <avi@redhat.com>\nDate: Tue, 24 Nov 2009 15:20:15 +0200\nSubject: KVM: x86 emulator: limit instructions to 15 bytes\n\nWhile we are never normally passed an instruction that exceeds 15 bytes,\nsmp games can cause us to attempt to interpret one, which will cause\nlarge latencies in non-preempt hosts.\n\nCc: stable@kernel.org\nSigned-off-by: Avi Kivity <avi@redhat.com>\n---\n arch\/x86\/include\/asm\/kvm_emulate.h | 2 +-\n arch\/x86\/kvm\/emulate.c             | 5 ++++-\n 2 files changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/kvm_emulate.h b\/arch\/x86\/include\/asm\/kvm_emulate.h\nindex b7ed2c423116..7c18e1230f54 100644\n--- a\/arch\/x86\/include\/asm\/kvm_emulate.h\n+++ b\/arch\/x86\/include\/asm\/kvm_emulate.h\n@@ -129,7 +129,7 @@ struct decode_cache {\n \tu8 seg_override;\n \tunsigned int d;\n \tunsigned long regs[NR_VCPU_REGS];\n-\tunsigned long eip;\n+\tunsigned long eip, eip_orig;\n \t\/* modrm *\/\n \tu8 modrm;\n \tu8 modrm_mod;\ndiff --git a\/arch\/x86\/kvm\/emulate.c b\/arch\/x86\/kvm\/emulate.c\nindex d226dff47d77..7e8faea4651e 100644\n--- a\/arch\/x86\/kvm\/emulate.c\n+++ b\/arch\/x86\/kvm\/emulate.c\n@@ -622,6 +622,9 @@ static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n {\n \tint rc = 0;\n \n+\t\/* x86 instructions are limited to 15 bytes. *\/\n+\tif (eip + size - ctxt->decode.eip_orig > 15)\n+\t\treturn X86EMUL_UNHANDLEABLE;\n \teip += ctxt->cs_base;\n \twhile (size--) {\n \t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n@@ -880,7 +883,7 @@ x86_decode_insn(struct x86_emulate_ctxt *ctxt, struct x86_emulate_ops *ops)\n \t\/* Shadow copy of register state. Committed on successful emulation. *\/\n \n \tmemset(c, 0, sizeof(struct decode_cache));\n-\tc->eip = kvm_rip_read(ctxt->vcpu);\n+\tc->eip = c->eip_orig = kvm_rip_read(ctxt->vcpu);\n \tctxt->cs_base = seg_base(ctxt, VCPU_SREG_CS);\n \tmemcpy(c->regs, ctxt->vcpu->arch.regs, sizeof c->regs);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-3804","CWE_ID":"20","category":"security","commit_id":"c51f6177576d7e12614c64d316cf0b67addd17c9","commit_message":"From c51f6177576d7e12614c64d316cf0b67addd17c9 Mon Sep 17 00:00:00 2001\nFrom: Stef Walter <stefw@redhat.com>\nDate: Thu, 13 Dec 2018 15:12:44 +0100\nSubject: [PATCH] ws: Fix bug parsing invalid base64 headers\n\nThe len parameter to g_base64_decode_inplace() is a inout\nparameter, and needs to be initialized. Lets just use\nthe simpler g_base64_decode() function. This fixes a segfault.\n\nCloses #10819\n---\n src\/ws\/cockpitauth.c | 13 ++++++++-----\n src\/ws\/test-auth.c   |  6 ++++++\n 2 files changed, 14 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/src\/ws\/cockpitauth.c b\/src\/ws\/cockpitauth.c\nindex b216c0e3923..8c7a595de53 100644\n--- a\/src\/ws\/cockpitauth.c\n+++ b\/src\/ws\/cockpitauth.c\n@@ -1190,16 +1190,19 @@ cockpit_auth_class_init (CockpitAuthClass *klass)\n   cockpit_authorize_logger (authorize_logger, 0);\n }\n \n-static char *\n+static gchar *\n base64_decode_string (const char *enc)\n {\n+  gchar *dec;\n+  gsize len;\n+\n   if (enc == NULL)\n     return NULL;\n \n-  char *dec = g_strdup (enc);\n-  gsize len;\n-  g_base64_decode_inplace (dec, &len);\n-  dec[len] = '\\0';\n+  dec = (gchar *)g_base64_decode (enc, &len);\n+  if (dec)\n+    dec[len] = '\\0';\n+\n   return dec;\n }\n \ndiff --git a\/src\/ws\/test-auth.c b\/src\/ws\/test-auth.c\nindex 6f84b01bfc4..57d9462eda9 100644\n--- a\/src\/ws\/test-auth.c\n+++ b\/src\/ws\/test-auth.c\n@@ -286,6 +286,12 @@ test_headers_bad (Test *test,\n   if (cockpit_auth_check_cookie (test->auth, \"\/cockpit\", headers))\n       g_assert_not_reached ();\n \n+  \/* Bad encoding *\/\n+  g_hash_table_remove_all (headers);\n+  g_hash_table_insert (headers, g_strdup (\"Cookie\"), g_strdup (\"cockpit=d\"));\n+  if (cockpit_auth_check_cookie (test->auth, \"\/cockpit\", headers))\n+      g_assert_not_reached ();\n+\n   g_hash_table_destroy (headers);\n }\n \n","owner":"cockpit-project","repo":"cockpit","source":"cve"},{"CVE_ID":"CVE-2016-6515","CWE_ID":"20","category":"security","commit_id":"fcd135c9df440bcd2d5870405ad3311743d78d97","commit_message":"From fcd135c9df440bcd2d5870405ad3311743d78d97 Mon Sep 17 00:00:00 2001\nFrom: \"dtucker@openbsd.org\" <dtucker@openbsd.org>\nDate: Thu, 21 Jul 2016 01:39:35 +0000\nSubject: [PATCH] upstream commit\n\nSkip passwords longer than 1k in length so clients can't\neasily DoS sshd by sending very long passwords, causing it to spend CPU\nhashing them. feedback djm@, ok markus@.\n\nBrought to our attention by tomas.kuthan at oracle.com, shilei-c at\n360.cn and coredump at autistici.org\n\nUpstream-ID: d0af7d4a2190b63ba1d38eec502bc4be0be9e333\n---\n auth-passwd.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/auth-passwd.c b\/auth-passwd.c\nindex 530b5d4f7..996c2cf71 100644\n--- a\/auth-passwd.c\n+++ b\/auth-passwd.c\n@@ -1,4 +1,4 @@\n-\/* $OpenBSD: auth-passwd.c,v 1.44 2014\/07\/15 15:54:14 millert Exp $ *\/\n+\/* $OpenBSD: auth-passwd.c,v 1.45 2016\/07\/21 01:39:35 dtucker Exp $ *\/\n \/*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -66,6 +66,8 @@ extern login_cap_t *lc;\n #define DAY\t\t(24L * 60 * 60) \/* 1 day in seconds *\/\n #define TWO_WEEKS\t(2L * 7 * DAY)\t\/* 2 weeks in seconds *\/\n \n+#define MAX_PASSWORD_LEN\t1024\n+\n void\n disable_forwarding(void)\n {\n@@ -87,6 +89,9 @@ auth_password(Authctxt *authctxt, const char *password)\n \tstatic int expire_checked = 0;\n #endif\n \n+\tif (strlen(password) > MAX_PASSWORD_LEN)\n+\t\treturn 0;\n+\n #ifndef HAVE_CYGWIN\n \tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n \t\tok = 0;\n","owner":"openssh","repo":"openssh-portable","source":"cve"},{"CVE_ID":"CVE-2009-0859","CWE_ID":"20","category":"security","commit_id":"a68e61e8ff2d46327a37b69056998b47745db6fa","commit_message":"From a68e61e8ff2d46327a37b69056998b47745db6fa Mon Sep 17 00:00:00 2001\nFrom: Tony Battersby <tonyb@cybernetics.com>\nDate: Wed, 4 Feb 2009 15:12:04 -0800\nSubject: shm: fix shmctl(SHM_INFO) lockup with !CONFIG_SHMEM\n\nshm_get_stat() assumes that the inode is a \"struct shmem_inode_info\",\nwhich is incorrect for !CONFIG_SHMEM (see fs\/ramfs\/inode.c:\nramfs_get_inode() vs.  mm\/shmem.c: shmem_get_inode()).\n\nThis bad assumption can cause shmctl(SHM_INFO) to lockup when\nshm_get_stat() tries to spin_lock(&info->lock).  Users of !CONFIG_SHMEM\nmay encounter this lockup simply by invoking the 'ipcs' command.\n\nReported by Jiri Olsa back in February 2008:\nhttp:\/\/lkml.org\/lkml\/2008\/2\/29\/74\n\nSigned-off-by: Tony Battersby <tonyb@cybernetics.com>\nCc: Jiri Kosina <jkosina@suse.cz>\nReported-by: Jiri Olsa <olsajiri@gmail.com>\nCc: Hugh Dickins <hugh@veritas.com>\nCc: <stable@kernel.org>\t\t[2.6.everything]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n ipc\/shm.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/ipc\/shm.c b\/ipc\/shm.c\nindex c0a021f7f41a..f8f69fad3a27 100644\n--- a\/ipc\/shm.c\n+++ b\/ipc\/shm.c\n@@ -565,11 +565,15 @@ static void shm_get_stat(struct ipc_namespace *ns, unsigned long *rss,\n \t\t\tstruct hstate *h = hstate_file(shp->shm_file);\n \t\t\t*rss += pages_per_huge_page(h) * mapping->nrpages;\n \t\t} else {\n+#ifdef CONFIG_SHMEM\n \t\t\tstruct shmem_inode_info *info = SHMEM_I(inode);\n \t\t\tspin_lock(&info->lock);\n \t\t\t*rss += inode->i_mapping->nrpages;\n \t\t\t*swp += info->swapped;\n \t\t\tspin_unlock(&info->lock);\n+#else\n+\t\t\t*rss += inode->i_mapping->nrpages;\n+#endif\n \t\t}\n \n \t\ttotal++;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-5353","CWE_ID":"20","category":"security","commit_id":"7d7190695ce2ff269fdffb04e87139995cde21f4","commit_message":"From 7d7190695ce2ff269fdffb04e87139995cde21f4 Mon Sep 17 00:00:00 2001\nFrom: Evan Huus <eapache@gmail.com>\nDate: Sat, 4 Jun 2016 13:56:57 -0400\nSubject: [PATCH] UMTS_FP: fix handling reserved C\/T value\n\nThe spec puts the reserved value at 0xf but our internal table has 'unknown' at\n0; since all the other values seem to be offset-by-one, just take the modulus\n0xf to avoid running off the end of the table.\n\nBug: 12191\nChange-Id: I83c8fb66797bbdee52a2246fb1eea6e37cbc7eb0\nReviewed-on: https:\/\/code.wireshark.org\/review\/15722\nReviewed-by: Evan Huus <eapache@gmail.com>\nPetri-Dish: Evan Huus <eapache@gmail.com>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Michael Mann <mmann78@netscape.net>\n---\n epan\/dissectors\/packet-umts_fp.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/epan\/dissectors\/packet-umts_fp.c b\/epan\/dissectors\/packet-umts_fp.c\nindex b1178865a0..5552e0ccee 100644\n--- a\/epan\/dissectors\/packet-umts_fp.c\n+++ b\/epan\/dissectors\/packet-umts_fp.c\n@@ -4098,11 +4098,11 @@ fp_set_per_packet_inf_from_conv(umts_fp_conversation_info_t *p_conv_data,\n \n                                 \/* Peek at C\/T, different RLC params for different logical channels *\/\n                                 \/*C\/T is 4 bits according to 3GPP TS 25.321, paragraph 9.2.1, from MAC header (not FP)*\/\n-                                c_t = tvb_get_bits8(tvb, tb_bit_off\/*(2+p_conv_data->num_dch_in_flow)*8*\/, 4);    \/* c_t = tvb_get_guint8(tvb, offset);*\/\n-                                macinf->lchid[j+chan] = c_t+1;\n+                                c_t = (tvb_get_bits8(tvb, tb_bit_off\/*(2+p_conv_data->num_dch_in_flow)*8*\/, 4) + 1) % 0xf;    \/* c_t = tvb_get_guint8(tvb, offset);*\/\n+                                macinf->lchid[j+chan] = c_t;\n \n-                                macinf->content[j+chan] = lchId_type_table[c_t+1];    \/*Base MAC content on logical channel id (Table is in packet-nbap.h)*\/\n-                                rlcinf->mode[j+chan] = lchId_rlc_map[c_t+1];    \/*Based RLC mode on logical channel id*\/\n+                                macinf->content[j+chan] = lchId_type_table[c_t];    \/*Base MAC content on logical channel id (Table is in packet-nbap.h)*\/\n+                                rlcinf->mode[j+chan] = lchId_rlc_map[c_t];    \/*Based RLC mode on logical channel id*\/\n                             }\n                         } else {\n                             fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]);\n","owner":"wireshark","repo":"wireshark","source":"cve"},{"CVE_ID":"CVE-2010-3904","CWE_ID":"20","category":"security","commit_id":"799c10559d60f159ab2232203f222f18fa3c4a5f","commit_message":"From 799c10559d60f159ab2232203f222f18fa3c4a5f Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Fri, 15 Oct 2010 11:09:28 -0700\nSubject: De-pessimize rds_page_copy_user\n\nDon't try to \"optimize\" rds_page_copy_user() by using kmap_atomic() and\nthe unsafe atomic user mode accessor functions.  It's actually slower\nthan the straightforward code on any reasonable modern CPU.\n\nBack when the code was written (although probably not by the time it was\nactually merged, though), 32-bit x86 may have been the dominant\narchitecture.  And there kmap_atomic() can be a lot faster than kmap()\n(unless you have very good locality, in which case the virtual address\ncaching by kmap() can overcome all the downsides).\n\nBut these days, x86-64 may not be more populous, but it's getting there\n(and if you care about performance, it's definitely already there -\nyou'd have upgraded your CPU's already in the last few years).  And on\nx86-64, the non-kmap_atomic() version is faster, simply because the code\nis simpler and doesn't have the \"re-try page fault\" case.\n\nPeople with old hardware are not likely to care about RDS anyway, and\nthe optimization for the 32-bit case is simply buggy, since it doesn't\nverify the user addresses properly.\n\nReported-by: Dan Rosenberg <drosenberg@vsecurity.com>\nAcked-by: Andrew Morton <akpm@linux-foundation.org>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n net\/rds\/page.c | 27 +++++++--------------------\n 1 file changed, 7 insertions(+), 20 deletions(-)\n\n","diff_code":"diff --git a\/net\/rds\/page.c b\/net\/rds\/page.c\nindex 595a952d4b17..1dfbfea12e9b 100644\n--- a\/net\/rds\/page.c\n+++ b\/net\/rds\/page.c\n@@ -57,30 +57,17 @@ int rds_page_copy_user(struct page *page, unsigned long offset,\n \tunsigned long ret;\n \tvoid *addr;\n \n-\tif (to_user)\n+\taddr = kmap(page);\n+\tif (to_user) {\n \t\trds_stats_add(s_copy_to_user, bytes);\n-\telse\n+\t\tret = copy_to_user(ptr, addr + offset, bytes);\n+\t} else {\n \t\trds_stats_add(s_copy_from_user, bytes);\n-\n-\taddr = kmap_atomic(page, KM_USER0);\n-\tif (to_user)\n-\t\tret = __copy_to_user_inatomic(ptr, addr + offset, bytes);\n-\telse\n-\t\tret = __copy_from_user_inatomic(addr + offset, ptr, bytes);\n-\tkunmap_atomic(addr, KM_USER0);\n-\n-\tif (ret) {\n-\t\taddr = kmap(page);\n-\t\tif (to_user)\n-\t\t\tret = copy_to_user(ptr, addr + offset, bytes);\n-\t\telse\n-\t\t\tret = copy_from_user(addr + offset, ptr, bytes);\n-\t\tkunmap(page);\n-\t\tif (ret)\n-\t\t\treturn -EFAULT;\n+\t\tret = copy_from_user(addr + offset, ptr, bytes);\n \t}\n+\tkunmap(page);\n \n-\treturn 0;\n+\treturn ret ? -EFAULT : 0;\n }\n EXPORT_SYMBOL_GPL(rds_page_copy_user);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-3675","CWE_ID":"20","category":"security","commit_id":"9dd04f6d8cdd1c10c28b2cb4252c1a41df581915","commit_message":"From 9dd04f6d8cdd1c10c28b2cb4252c1a41df581915 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 7 May 2013 21:58:27 +0200\nSubject: [PATCH] sanm: Check dimensions before use\n\nFixes integer overflow and out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/sanm.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/sanm.c b\/libavcodec\/sanm.c\nindex f217ef36bb..e6e866ef8e 100644\n--- a\/libavcodec\/sanm.c\n+++ b\/libavcodec\/sanm.c\n@@ -732,6 +732,11 @@ static int process_frame_obj(SANMVideoContext *ctx)\n     w     = bytestream2_get_le16u(&ctx->gb);\n     h     = bytestream2_get_le16u(&ctx->gb);\n \n+    if (!w || !h) {\n+        av_log(ctx->avctx, AV_LOG_ERROR, \"dimensions are invalid\\n\");\n+        return AVERROR_INVALIDDATA;\n+    }\n+\n     if (ctx->width < left + w || ctx->height < top + h) {\n         if (av_image_check_size(FFMAX(left + w, ctx->width),\n                                 FFMAX(top  + h, ctx->height), 0, ctx->avctx) < 0)\n-- \n2.11.0\n\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2015-5685","CWE_ID":"20","category":"security","commit_id":"e809ea80e3527e32c40756eddd8b2ae44bc3af1a","commit_message":"From e809ea80e3527e32c40756eddd8b2ae44bc3af1a Mon Sep 17 00:00:00 2001\nFrom: xercesblue <francisco@bittorrent.com>\nDate: Mon, 29 Jun 2015 14:45:09 -0700\nSubject: [PATCH] Check for out-of-bounds bencoded lengths before advancing\n buffer pointer\n\n---\n lazy_bdecode.cpp | 10 ++++++++--\n 1 file changed, 8 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/lazy_bdecode.cpp b\/lazy_bdecode.cpp\nindex 0f7b292..fe6cb67 100644\n--- a\/lazy_bdecode.cpp\n+++ b\/lazy_bdecode.cpp\n@@ -150,7 +150,9 @@ namespace libtorrent\n \t\t\t\t\tif (e)\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n \n-\t\t\t\t\tif (start + len + 1 > end)\n+\t\t\t\t\t\/\/ remaining buffer size excluding ':'\n+\t\t\t\t\tconst ptrdiff_t buff_size = end - start - 1;\n+\t\t\t\t\tif (len > buff_size)\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \n \t\t\t\t\tif (len < 0)\n@@ -216,12 +218,16 @@ namespace libtorrent\n \t\t\t\t\tstart = parse_int(start, end, ':', len, e);\n \t\t\t\t\tif (e)\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(e);\n-\t\t\t\t\tif (start + len + 1 > end)\n+\n+\t\t\t\t\t\/\/ remaining buffer size excluding ':'\n+\t\t\t\t\tconst ptrdiff_t buff_size = end - start - 1;\n+\t\t\t\t\tif (len > buff_size)\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \t\t\t\t\tif (len < 0)\n \t\t\t\t\t\tTORRENT_FAIL_BDECODE(bdecode_errors::overflow);\n \n \t\t\t\t\t++start;\n+\t\t\t\t\tif (start == end) TORRENT_FAIL_BDECODE(bdecode_errors::unexpected_eof);\n \t\t\t\t\ttop->construct_string(start, int(len));\n \t\t\t\t\tstack.pop_back();\n \t\t\t\t\tstart += len;\n","owner":"bittorrent","repo":"bootstrap-dht","source":"cve"},{"CVE_ID":"CVE-2014-3480","CWE_ID":"20","category":"security","commit_id":"40bade80cbe2af1d0b2cd0420cebd5d5905a2382","commit_message":"From 40bade80cbe2af1d0b2cd0420cebd5d5905a2382 Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Wed, 4 Jun 2014 17:23:19 +0000\nSubject: [PATCH] Fix incorrect bounds check for sector count. (Francisco\n Alonso and Jan Kaluza at RedHat)\n\n---\n src\/cdf.c | 9 +++++----\n 1 file changed, 5 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/src\/cdf.c b\/src\/cdf.c\nindex 375406c37..6652581c2 100644\n--- a\/src\/cdf.c\n+++ b\/src\/cdf.c\n@@ -35,7 +35,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: cdf.c,v 1.59 2014\/05\/14 23:22:48 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: cdf.c,v 1.60 2014\/05\/21 13:04:38 christos Exp $\")\n #endif\n \n #include <assert.h>\n@@ -455,7 +455,8 @@ size_t\n cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n {\n \tsize_t i, j;\n-\tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * size);\n+\tcdf_secid_t maxsector = (cdf_secid_t)((sat->sat_len * size)\n+\t    \/ sizeof(maxsector));\n \n \tDPRINTF((\"Chain:\"));\n \tfor (j = i = 0; sid >= 0; i++, j++) {\n@@ -465,8 +466,8 @@ cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n \t\t\terrno = EFTYPE;\n \t\t\treturn (size_t)-1;\n \t\t}\n-\t\tif (sid > maxsector) {\n-\t\t\tDPRINTF((\"Sector %d > %d\\n\", sid, maxsector));\n+\t\tif (sid >= maxsector) {\n+\t\t\tDPRINTF((\"Sector %d >= %d\\n\", sid, maxsector));\n \t\t\terrno = EFTYPE;\n \t\t\treturn (size_t)-1;\n \t\t}\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2016-5351","CWE_ID":"20","category":"security","commit_id":"9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4","commit_message":"From 9b0b20b8d5f8c9f7839d58ff6c5900f7e19283b4 Mon Sep 17 00:00:00 2001\nFrom: Michael Mann <mmann78@netscape.net>\nDate: Sun, 22 May 2016 20:21:17 -0400\nSubject: [PATCH] Make sure EAPOL body is big enough for a EAPOL_RSN_KEY.\n\nA pointer to a EAPOL_RSN_KEY is set on the packet presuming the\nwhole EAPOL_RSN_KEY is there.  That's not always the case for\nfuzzed\/malicious captures.\n\nBug: 11585\nChange-Id: Ib94b8aceef444c7820e43b969596efdb8dbecccd\nReviewed-on: https:\/\/code.wireshark.org\/review\/15540\nReviewed-by: Michael Mann <mmann78@netscape.net>\nPetri-Dish: Michael Mann <mmann78@netscape.net>\nTested-by: Petri Dish Buildbot <buildbot-no-reply@wireshark.org>\nReviewed-by: Anders Broman <a.broman58@gmail.com>\n---\n epan\/crypt\/airpdcap.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/epan\/crypt\/airpdcap.c b\/epan\/crypt\/airpdcap.c\nindex dd948a0d1d..1212cdde7c 100644\n--- a\/epan\/crypt\/airpdcap.c\n+++ b\/epan\/crypt\/airpdcap.c\n@@ -571,7 +571,7 @@ static INT AirPDcapScanForKeys(\n \n         \/* get and check the body length (IEEE 802.1X-2004, pg. 25) *\/\n         bodyLength=pntoh16(data+offset+2);\n-        if ((tot_len-offset-4) < bodyLength) { \/* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 *\/\n+        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { \/* Only check if frame is long enough for eapol header, ignore tailing garbage, see bug 9065 *\/\n             AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapScanForKeys\", \"EAPOL body too short\", AIRPDCAP_DEBUG_LEVEL_3);\n             return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n         }\n","owner":"wireshark","repo":"wireshark","source":"cve"},{"CVE_ID":"CVE-2018-15822","CWE_ID":"20","category":"security","commit_id":"6b67d7f05918f7a1ee8fc6ff21355d7e8736aa10","commit_message":"From 6b67d7f05918f7a1ee8fc6ff21355d7e8736aa10 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Sat, 28 Jul 2018 15:03:50 +0200\nSubject: [PATCH] avformat\/flvenc: Check audio packet size\n\nFixes: Assertion failure\nFixes: assert_flvenc.c:941_1.swf\n\nFound-by: #CHEN HONGXU# <HCHEN017@e.ntu.edu.sg>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavformat\/flvenc.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/libavformat\/flvenc.c b\/libavformat\/flvenc.c\nindex 1c552a3e6b9..e4863f1fc73 100644\n--- a\/libavformat\/flvenc.c\n+++ b\/libavformat\/flvenc.c\n@@ -883,6 +883,11 @@ static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)\n     int flags = -1, flags_size, ret;\n     int64_t cur_offset = avio_tell(pb);\n \n+    if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {\n+        av_log(s, AV_LOG_WARNING, \"Empty audio Packet\\n\");\n+        return AVERROR(EINVAL);\n+    }\n+\n     if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||\n         par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)\n         flags_size = 2;\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2010-4254","CWE_ID":"20","category":"security","commit_id":"65292a69c837b8a5f7a392d34db63de592153358","commit_message":"From 65292a69c837b8a5f7a392d34db63de592153358 Mon Sep 17 00:00:00 2001\nFrom: Rodrigo Kumpera <kumpera@gmail.com>\nDate: Thu, 25 Nov 2010 14:23:31 -0200\nSubject: [PATCH] Handle invalid instantiation of generic methods.\n\n\t* verify.c: Add new function to internal verifier API to check\n\tmethod instantiations.\n\n\t* reflection.c (mono_reflection_bind_generic_method_parameters):\n\tCheck the instantiation before returning it.\n\n\tFixes #655847\n---\n mono\/metadata\/reflection.c       |  3 +++\n mono\/metadata\/verify-internals.h |  1 +\n mono\/metadata\/verify.c           | 15 +++++++++++++++\n 3 files changed, 19 insertions(+)\n\n","diff_code":"diff --git a\/mono\/metadata\/reflection.c b\/mono\/metadata\/reflection.c\nindex 7a4e70009db4..2d4b40160bbc 100644\n--- a\/mono\/metadata\/reflection.c\n+++ b\/mono\/metadata\/reflection.c\n@@ -10539,6 +10539,9 @@ mono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, M\n \t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n \t\tmono_loader_unlock ();\n \t}\n+\n+\tif (!mono_verifier_is_method_valid_generic_instantiation (inflated))\n+\t\tmono_raise_exception (mono_get_exception_argument (\"typeArguments\", \"Invalid generic arguments\"));\n \t\n \treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);\n }\ndiff --git a\/mono\/metadata\/verify-internals.h b\/mono\/metadata\/verify-internals.h\nindex 17fd857ea838..91a812988cb8 100644\n--- a\/mono\/metadata\/verify-internals.h\n+++ b\/mono\/metadata\/verify-internals.h\n@@ -22,6 +22,7 @@ gboolean mono_verifier_is_enabled_for_class (MonoClass *klass) MONO_INTERNAL;\n gboolean mono_verifier_is_method_full_trust (MonoMethod *method) MONO_INTERNAL;\n gboolean mono_verifier_is_class_full_trust (MonoClass *klass) MONO_INTERNAL;\n gboolean mono_verifier_class_is_valid_generic_instantiation (MonoClass *class) MONO_INTERNAL;\n+gboolean mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method) MONO_INTERNAL;\n \n gboolean mono_verifier_verify_class (MonoClass *klass) MONO_INTERNAL;\n \ndiff --git a\/mono\/metadata\/verify.c b\/mono\/metadata\/verify.c\nindex 7c922455aa17..dacb0e9a0f82 100644\n--- a\/mono\/metadata\/verify.c\n+++ b\/mono\/metadata\/verify.c\n@@ -5958,6 +5958,14 @@ mono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n \treturn mono_class_is_valid_generic_instantiation (NULL, class);\n }\n \n+gboolean\n+mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method)\n+{\n+\tif (!method->is_inflated)\n+\t\treturn TRUE;\n+\treturn mono_method_is_valid_generic_instantiation (NULL, method);\n+}\n+\n #else\n \n gboolean\n@@ -6029,5 +6037,12 @@ mono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n \treturn TRUE;\n }\n \n+gboolean\n+mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method)\n+{\n+\treturn TRUE;\n+}\n+\n+\n \n #endif\n","owner":"mono","repo":"mono","source":"cve"},{"CVE_ID":"CVE-2014-2241","CWE_ID":"20","category":"security","commit_id":"135c3faebb96f8f550bd4f318716f2e1e095a969","commit_message":"From 135c3faebb96f8f550bd4f318716f2e1e095a969 Mon Sep 17 00:00:00 2001\nFrom: Dave Arnold <darnold@adobe.com>\nDate: Fri, 28 Feb 2014 07:42:42 +0100\nSubject: Fix Savannah bug #41697, part 2.\n\n* src\/cff\/cf2ft.c (cf2_initLocalRegionBuffer,\ncf2_initGlobalRegionBuffer): It is possible for a charstring to call\na subroutine if no subroutines exist.  This is an error but should\nnot trigger an assert.  Split the assert to account for this.\n---\n ChangeLog       | 9 +++++++++\n src\/cff\/cf2ft.c | 8 ++++++--\n 2 files changed, 15 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 1f48e24..164aa6b 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,14 @@\n 2014-02-28  Dave Arnold  <darnold@adobe.com>\n \n+\t[cff] Fix Savannah bug #41697, part 2.\n+\n+\t* src\/cff\/cf2ft.c (cf2_initLocalRegionBuffer,\n+\tcf2_initGlobalRegionBuffer): It is possible for a charstring to call\n+\ta subroutine if no subroutines exist.  This is an error but should\n+\tnot trigger an assert.  Split the assert to account for this.\n+\n+2014-02-28  Dave Arnold  <darnold@adobe.com>\n+\n \t[cff] Fix Savannah bug #41697, part 1.\n \n \t* src\/cff\/cf2hints.c (cf2_hintmap_build): Return when `hintMask' is\ndiff --git a\/src\/cff\/cf2ft.c b\/src\/cff\/cf2ft.c\nindex df5f8fb..82bac75 100644\n--- a\/src\/cff\/cf2ft.c\n+++ b\/src\/cff\/cf2ft.c\n@@ -521,7 +521,7 @@\n                               CF2_UInt      idx,\n                               CF2_Buffer    buf )\n   {\n-    FT_ASSERT( decoder && decoder->globals );\n+    FT_ASSERT( decoder );\n \n     FT_ZERO( buf );\n \n@@ -529,6 +529,8 @@\n     if ( idx >= decoder->num_globals )\n       return TRUE;     \/* error *\/\n \n+    FT_ASSERT( decoder->globals );\n+\n     buf->start =\n     buf->ptr   = decoder->globals[idx];\n     buf->end   = decoder->globals[idx + 1];\n@@ -594,7 +596,7 @@\n                              CF2_UInt      idx,\n                              CF2_Buffer    buf )\n   {\n-    FT_ASSERT( decoder && decoder->locals );\n+    FT_ASSERT( decoder );\n \n     FT_ZERO( buf );\n \n@@ -602,6 +604,8 @@\n     if ( idx >= decoder->num_locals )\n       return TRUE;     \/* error *\/\n \n+    FT_ASSERT( decoder->locals );\n+\n     buf->start =\n     buf->ptr   = decoder->locals[idx];\n     buf->end   = decoder->locals[idx + 1];\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-1108","CWE_ID":"20","category":"security","commit_id":"b3646a07348ffa276ea41a9dae03ddc63ea6c532","commit_message":"From b3646a07348ffa276ea41a9dae03ddc63ea6c532 Mon Sep 17 00:00:00 2001\nFrom: Frank Lai <frank.franklai@gmail.com>\nDate: Thu, 9 Jun 2011 18:44:54 +0200\nSubject: [PATCH] Be more careful when parsing Vorbis Comments\n\n---\n taglib\/ogg\/xiphcomment.cpp | 16 +++++++++++++---\n 1 file changed, 13 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/taglib\/ogg\/xiphcomment.cpp b\/taglib\/ogg\/xiphcomment.cpp\nindex 344d9cfca..e7e8fa915 100644\n--- a\/taglib\/ogg\/xiphcomment.cpp\n+++ b\/taglib\/ogg\/xiphcomment.cpp\n@@ -295,21 +295,31 @@ void Ogg::XiphComment::parse(const ByteVector &data)\n \n   \/\/ Next the number of fields in the comment vector.\n \n-  int commentFields = data.mid(pos, 4).toUInt(false);\n+  uint commentFields = data.mid(pos, 4).toUInt(false);\n   pos += 4;\n \n-  for(int i = 0; i < commentFields; i++) {\n+  if(commentFields > (data.size() - 8) \/ 4) {\n+    return;\n+  }\n+\n+  for(uint i = 0; i < commentFields; i++) {\n \n     \/\/ Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n     \/\/ 4 bytes before the text starts that gives the length.\n \n-    int commentLength = data.mid(pos, 4).toUInt(false);\n+    uint commentLength = data.mid(pos, 4).toUInt(false);\n     pos += 4;\n \n     String comment = String(data.mid(pos, commentLength), String::UTF8);\n     pos += commentLength;\n+    if(pos > data.size()) {\n+      break;\n+    }\n \n     int commentSeparatorPosition = comment.find(\"=\");\n+    if(commentSeparatorPosition == -1) {\n+      break;\n+    }\n \n     String key = comment.substr(0, commentSeparatorPosition);\n     String value = comment.substr(commentSeparatorPosition + 1);\n","owner":"taglib","repo":"taglib","source":"cve"},{"CVE_ID":"CVE-2015-5296","CWE_ID":"20","category":"security","commit_id":"d724f835acb9f4886c0001af32cd325dbbf1f895","commit_message":"From d724f835acb9f4886c0001af32cd325dbbf1f895 Mon Sep 17 00:00:00 2001\nFrom: Stefan Metzmacher <metze@samba.org>\nDate: Wed, 30 Sep 2015 21:17:02 +0200\nSubject: [PATCH] CVE-2015-5296: s3:libsmb: force signing when requiring\n encryption in do_connect()\n\nBUG: https:\/\/bugzilla.samba.org\/show_bug.cgi?id=11536\n\nSigned-off-by: Stefan Metzmacher <metze@samba.org>\nReviewed-by: Jeremy Allison <jra@samba.org>\n---\n source3\/libsmb\/clidfs.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/source3\/libsmb\/clidfs.c b\/source3\/libsmb\/clidfs.c\nindex 2121ad09f34..d3b0580230b 100644\n--- a\/source3\/libsmb\/clidfs.c\n+++ b\/source3\/libsmb\/clidfs.c\n@@ -114,6 +114,11 @@ static NTSTATUS do_connect(TALLOC_CTX *ctx,\n \tconst char *domain;\n \tNTSTATUS status;\n \tint flags = 0;\n+\tint signing_state = get_cmdline_auth_info_signing_state(auth_info);\n+\n+\tif (force_encrypt) {\n+\t\tsigning_state = SMB_SIGNING_REQUIRED;\n+\t}\n \n \t\/* make a copy so we don't modify the global string 'service' *\/\n \tservicename = talloc_strdup(ctx,share);\n@@ -152,7 +157,7 @@ static NTSTATUS do_connect(TALLOC_CTX *ctx,\n \n \tstatus = cli_connect_nb(\n \t\tserver, NULL, port, name_type, NULL,\n-\t\tget_cmdline_auth_info_signing_state(auth_info),\n+\t\tsigning_state,\n \t\tflags, &c);\n \n \tif (!NT_STATUS_IS_OK(status)) {\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0856","CWE_ID":"20","category":"security","commit_id":"fd4f4923cce6a2cbf4f48640b4ac706e614a1594","commit_message":"From fd4f4923cce6a2cbf4f48640b4ac706e614a1594 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Sat, 10 Nov 2012 17:14:04 +0100\nSubject: [PATCH] alac: fix nb_samples < order case\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/alac.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/alac.c b\/libavcodec\/alac.c\nindex 5653e9aff5..f032ceb9cc 100644\n--- a\/libavcodec\/alac.c\n+++ b\/libavcodec\/alac.c\n@@ -224,7 +224,7 @@ static void lpc_prediction(int32_t *error_buffer, int32_t *buffer_out,\n     }\n \n     \/* read warm-up samples *\/\n-    for (i = 1; i <= lpc_order; i++)\n+    for (i = 1; i <= lpc_order && i < nb_samples; i++)\n         buffer_out[i] = sign_extend(buffer_out[i - 1] + error_buffer[i], bps);\n \n     \/* NOTE: 4 and 8 are very common cases that could be optimized. *\/\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3710","CWE_ID":"20","category":"security","commit_id":"1803228597e82218a8c105e67975bc50e6f5bf0d","commit_message":"From 1803228597e82218a8c105e67975bc50e6f5bf0d Mon Sep 17 00:00:00 2001\nFrom: Remi Collet <remi@php.net>\nDate: Wed, 22 Oct 2014 15:37:04 +0200\nSubject: [PATCH] Fix bug #68283: fileinfo: out-of-bounds read in elf note\n headers\n\nUpstream commit\nhttps:\/\/github.com\/file\/file\/commit\/39c7ac1106be844a5296d3eb5971946cc09ffda0\n\nCVE -2014-3710\n---\n ext\/fileinfo\/libmagic\/readelf.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/ext\/fileinfo\/libmagic\/readelf.c b\/ext\/fileinfo\/libmagic\/readelf.c\nindex 1c3845f..bb6f70f 100644\n--- a\/ext\/fileinfo\/libmagic\/readelf.c\n+++ b\/ext\/fileinfo\/libmagic\/readelf.c\n@@ -372,6 +372,13 @@ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n \tuint32_t namesz, descsz;\n \tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n \n+\tif (xnh_sizeof + offset > size) {\n+\t\t\/*\n+\t\t * We're out of note headers.\n+\t\t *\/\n+\t\treturn xnh_sizeof + offset;\n+\t}\n+\n \t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n \toffset += xnh_sizeof;\n \n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-5328","CWE_ID":"20","category":"security","commit_id":"f106eee10038c2ee5b6056aaf3f6d5229be6dcdd","commit_message":"From f106eee10038c2ee5b6056aaf3f6d5229be6dcdd Mon Sep 17 00:00:00 2001\nFrom: Oleg Nesterov <oleg@redhat.com>\nDate: Wed, 26 May 2010 14:44:11 -0700\nSubject: pids: fix fork_idle() to setup ->pids correctly\n\ncopy_process(pid => &init_struct_pid) doesn't do attach_pid\/etc.\n\nIt shouldn't, but this means that the idle threads run with the wrong\npids copied from the caller's task_struct. In x86 case the caller is\neither kernel_init() thread or keventd.\n\nIn particular, this means that after the series of cpu_up\/cpu_down an\nidle thread (which never exits) can run with .pid pointing to nowhere.\n\nChange fork_idle() to initialize idle->pids[] correctly. We only set\n.pid = &init_struct_pid but do not add .node to list, INIT_TASK() does\nthe same for the boot-cpu idle thread (swapper).\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nCc: Cedric Le Goater <clg@fr.ibm.com>\nCc: Dave Hansen <haveblue@us.ibm.com>\nCc: Eric Biederman <ebiederm@xmission.com>\nCc: Herbert Poetzl <herbert@13thfloor.at>\nCc: Mathias Krause <Mathias.Krause@secunet.com>\nAcked-by: Roland McGrath <roland@redhat.com>\nAcked-by: Serge Hallyn <serue@us.ibm.com>\nCc: Sukadev Bhattiprolu <sukadev@us.ibm.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n kernel\/fork.c | 14 +++++++++++++-\n 1 file changed, 13 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/kernel\/fork.c b\/kernel\/fork.c\nindex d32410bd4be7..bf9fef6d1bfe 100644\n--- a\/kernel\/fork.c\n+++ b\/kernel\/fork.c\n@@ -1338,6 +1338,16 @@ noinline struct pt_regs * __cpuinit __attribute__((weak)) idle_regs(struct pt_re\n \treturn regs;\n }\n \n+static inline void init_idle_pids(struct pid_link *links)\n+{\n+\tenum pid_type type;\n+\n+\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n+\t\tINIT_HLIST_NODE(&links[type].node); \/* not really needed *\/\n+\t\tlinks[type].pid = &init_struct_pid;\n+\t}\n+}\n+\n struct task_struct * __cpuinit fork_idle(int cpu)\n {\n \tstruct task_struct *task;\n@@ -1345,8 +1355,10 @@ struct task_struct * __cpuinit fork_idle(int cpu)\n \n \ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n \t\t\t    &init_struct_pid, 0);\n-\tif (!IS_ERR(task))\n+\tif (!IS_ERR(task)) {\n+\t\tinit_idle_pids(task->pids);\n \t\tinit_idle(task, cpu);\n+\t}\n \n \treturn task;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2012-1177","CWE_ID":"20","category":"security","commit_id":"6799f2c525a584dc998821a6ce897e463dad7840","commit_message":"From 6799f2c525a584dc998821a6ce897e463dad7840 Mon Sep 17 00:00:00 2001\nFrom: Philip Withnall <philip@tecnocode.co.uk>\nDate: Thu, 8 Mar 2012 00:09:08 +0000\nSubject: [PATCH] core: Validate SSL certificates for all connections\n\nThis prevents MitM attacks which use spoofed SSL certificates.\n\nNote that this bumps our libsoup requirement to 2.37.91.\n\nCloses: https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=671535\n---\n configure.ac          | 2 +-\n gdata\/gdata-service.c | 2 +-\n 2 files changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/configure.ac b\/configure.ac\nindex a624296b..78b0c301 100644\n--- a\/configure.ac\n+++ b\/configure.ac\n@@ -33,7 +33,7 @@ AC_PATH_PROG([GLIB_MKENUMS],[glib-mkenums])\n # Requirements\n GLIB_REQS=2.30.0\n GIO_REQS=2.17.3\n-SOUP_REQS=2.26.1\n+SOUP_REQS=2.37.91\n OAUTH_REQS=0.9.4\n GTK_REQS=2.91.2\n \ndiff --git a\/gdata\/gdata-service.c b\/gdata\/gdata-service.c\nindex 93ac8fb8..de9f020f 100644\n--- a\/gdata\/gdata-service.c\n+++ b\/gdata\/gdata-service.c\n@@ -2134,7 +2134,7 @@ _gdata_service_get_log_level (void)\n SoupSession *\n _gdata_service_build_session (void)\n {\n-\tSoupSession *session = soup_session_sync_new ();\n+\tSoupSession *session = soup_session_sync_new_with_options (SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE, TRUE, NULL);\n \n #ifdef HAVE_GNOME\n \tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-3552","CWE_ID":"20","category":"security","commit_id":"c5d6e07588cd03061bc54d451a7fa6e84883d62b","commit_message":"From c5d6e07588cd03061bc54d451a7fa6e84883d62b Mon Sep 17 00:00:00 2001\nFrom: Stepan Palamarchuk <stepan@fb.com>\nDate: Thu, 14 Feb 2019 13:37:15 -0800\nSubject: [PATCH] Throw on bad types during skipping data\n\nSummary:\nThe current code silently returns on bad types. In case when we have an invalid data, we may get a container of a large size with a bad type, this would lead to us running long loop doing nothing (though we already can say that the data is invalid).\n\nThe new code would throw an exception as soon as we try to skip a value of invalid type.\n\nFixes CVE-2019-3552\n\nReviewed By: yfeldblum, stevegury\n\nDifferential Revision: D8344920\n\nfbshipit-source-id: f12e8f3442f7ad5e1a81d822380701e929b80f0d\n---\n ...\/lib\/cpp\/protocol\/TProtocolException.cpp   |  8 +++\n thrift\/lib\/cpp\/protocol\/TProtocolException.h  |  2 +\n thrift\/lib\/cpp2\/protocol\/Protocol.h           |  5 +-\n thrift\/lib\/py\/protocol\/TProtocol.py           |  9 ++-\n thrift\/test\/ProtocolSkipTest.cpp              | 68 +++++++++++++++++++\n 5 files changed, 87 insertions(+), 5 deletions(-)\n create mode 100644 thrift\/test\/ProtocolSkipTest.cpp\n\n","diff_code":"diff --git a\/thrift\/lib\/cpp\/protocol\/TProtocolException.cpp b\/thrift\/lib\/cpp\/protocol\/TProtocolException.cpp\nindex d0ad89450..ab84de2a7 100644\n--- a\/thrift\/lib\/cpp\/protocol\/TProtocolException.cpp\n+++ b\/thrift\/lib\/cpp\/protocol\/TProtocolException.cpp\n@@ -57,4 +57,12 @@ namespace apache { namespace thrift { namespace protocol {\n           \"Attempt to interpret value {} as bool, probably the data is corrupted\",\n           value));\n }\n+\n+[[noreturn]] void TProtocolException::throwInvalidSkipType(TType type) {\n+  throw TProtocolException(\n+      TProtocolException::INVALID_DATA,\n+      folly::sformat(\n+          \"Encountered invalid field\/element type ({}) during skipping\",\n+          static_cast<uint8_t>(type)));\n+}\n }}}\ndiff --git a\/thrift\/lib\/cpp\/protocol\/TProtocolException.h b\/thrift\/lib\/cpp\/protocol\/TProtocolException.h\nindex 874654fa4..193d25d78 100644\n--- a\/thrift\/lib\/cpp\/protocol\/TProtocolException.h\n+++ b\/thrift\/lib\/cpp\/protocol\/TProtocolException.h\n@@ -23,6 +23,7 @@\n #define _THRIFT_PROTOCOL_TPROTOCOLEXCEPTION_H_ 1\n \n #include <thrift\/lib\/cpp\/Thrift.h>\n+#include <thrift\/lib\/cpp\/protocol\/TType.h>\n \n #include <string>\n \n@@ -106,6 +107,7 @@ class TProtocolException : public apache::thrift::TLibraryException {\n       folly::StringPiece field,\n       folly::StringPiece type);\n   [[noreturn]] static void throwBoolValueOutOfRange(uint8_t value);\n+  [[noreturn]] static void throwInvalidSkipType(TType type);\n \n  protected:\n   \/**\ndiff --git a\/thrift\/lib\/cpp2\/protocol\/Protocol.h b\/thrift\/lib\/cpp2\/protocol\/Protocol.h\nindex d1cc63ed6..033668ac7 100644\n--- a\/thrift\/lib\/cpp2\/protocol\/Protocol.h\n+++ b\/thrift\/lib\/cpp2\/protocol\/Protocol.h\n@@ -176,8 +176,9 @@ void skip(Protocol_& prot, TType arg_type) {\n       prot.readListEnd();\n       return;\n     }\n-    default:\n-      return;\n+    default: {\n+      TProtocolException::throwInvalidSkipType(arg_type);\n+    }\n   }\n }\n \ndiff --git a\/thrift\/lib\/py\/protocol\/TProtocol.py b\/thrift\/lib\/py\/protocol\/TProtocol.py\nindex a229eb025..252b53db4 100644\n--- a\/thrift\/lib\/py\/protocol\/TProtocol.py\n+++ b\/thrift\/lib\/py\/protocol\/TProtocol.py\n@@ -177,9 +177,7 @@ def readString(self):\n         pass\n \n     def skip(self, type):\n-        if type == TType.STOP:\n-            return\n-        elif type == TType.BOOL:\n+        if type == TType.BOOL:\n             self.readBool()\n         elif type == TType.BYTE:\n             self.readByte()\n@@ -220,6 +218,11 @@ def skip(self, type):\n             for _ in range(size):\n                 self.skip(etype)\n             self.readListEnd()\n+        else:\n+            raise TProtocolException(\n+                TProtocolException.INVALID_DATA,\n+                \"Unexpected type for skipping {}\".format(type)\n+            )\n \n     def readIntegral(self, type):\n         if type == TType.BOOL:\ndiff --git a\/thrift\/test\/ProtocolSkipTest.cpp b\/thrift\/test\/ProtocolSkipTest.cpp\nnew file mode 100644\nindex 000000000..762ec64a8\n--- \/dev\/null\n+++ b\/thrift\/test\/ProtocolSkipTest.cpp\n@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright 2004-present Facebook, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\n+#include <gtest\/gtest.h>\n+\n+#include <thrift\/lib\/cpp2\/protocol\/CompactProtocol.h>\n+\n+using namespace apache::thrift;\n+\n+TEST(ProtocolSkipTest, SkipInt) {\n+  IOBufQueue queue;\n+  CompactProtocolWriter writer;\n+  writer.setOutput(&queue);\n+  writer.writeI32(123);\n+  auto buf = queue.move();\n+  CompactProtocolReader reader;\n+  reader.setInput(buf.get());\n+  reader.skip(TType::T_I32);\n+}\n+\n+TEST(ProtocolSkipTest, SkipStop) {\n+  IOBufQueue queue;\n+  CompactProtocolWriter writer;\n+  writer.setOutput(&queue);\n+  writer.writeFieldStop();\n+  auto buf = queue.move();\n+  CompactProtocolReader reader;\n+  reader.setInput(buf.get());\n+  bool thrown = false;\n+  try {\n+    reader.skip(TType::T_STOP);\n+  } catch (const TProtocolException& ex) {\n+    EXPECT_EQ(TProtocolException::INVALID_DATA, ex.getType());\n+    thrown = true;\n+  }\n+  EXPECT_TRUE(thrown);\n+}\n+\n+TEST(ProtocolSkipTest, SkipStopInContainer) {\n+  IOBufQueue queue;\n+  CompactProtocolWriter writer;\n+  writer.setOutput(&queue);\n+  writer.writeListBegin(TType::T_STOP, 1u << 30);\n+  auto buf = queue.move();\n+  CompactProtocolReader reader;\n+  reader.setInput(buf.get());\n+  bool thrown = false;\n+  try {\n+    reader.skip(TType::T_LIST);\n+  } catch (const TProtocolException& ex) {\n+    EXPECT_EQ(TProtocolException::INVALID_DATA, ex.getType());\n+    thrown = true;\n+  }\n+  EXPECT_TRUE(thrown);\n+}\n","owner":"facebook","repo":"fbthrift","source":"cve"},{"CVE_ID":"CVE-2015-7558","CWE_ID":"20","category":"security","commit_id":"a51919f7e1ca9c535390a746fbf6e28c8402dc61","commit_message":"From a51919f7e1ca9c535390a746fbf6e28c8402dc61 Mon Sep 17 00:00:00 2001\nFrom: Benjamin Otte <otte@redhat.com>\nDate: Wed, 7 Oct 2015 08:45:37 +0200\nSubject: [PATCH] rsvg: Add rsvg_acquire_node()\n\nThis function does proper recursion checks when looking up resources\nfrom URLs and thereby helps avoiding infinite loops when cyclic\nreferences span multiple types of elements.\n---\n rsvg-base.c         | 55 +++++++++++++++++++++++++++++++++++++++++++++\n rsvg-cairo-draw.c   | 15 +++++++++----\n rsvg-cairo-render.c |  1 +\n rsvg-filter.c       |  9 ++++++--\n rsvg-private.h      |  5 +++++\n 5 files changed, 79 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/rsvg-base.c b\/rsvg-base.c\nindex be170abc..17cbb02e 100644\n--- a\/rsvg-base.c\n+++ b\/rsvg-base.c\n@@ -1236,6 +1236,8 @@ rsvg_drawing_ctx_free (RsvgDrawingCtx * handle)\n \tg_slist_free (handle->drawsub_stack);\n \n     g_slist_free (handle->ptrs);\n+    g_warn_if_fail (handle->acquired_nodes == NULL);\n+    g_slist_free (handle->acquired_nodes);\n \t\n     if (handle->base_uri)\n         g_free (handle->base_uri);\n@@ -2018,6 +2020,59 @@ rsvg_push_discrete_layer (RsvgDrawingCtx * ctx)\n     ctx->render->push_discrete_layer (ctx);\n }\n \n+\/*\n+ * rsvg_acquire_node:\n+ * @ctx: The drawing context in use\n+ * @url: The IRI to lookup\n+ *\n+ * Use this function when looking up urls to other nodes. This\n+ * function does proper recursion checking and thereby avoids\n+ * infinite loops.\n+ *\n+ * Nodes acquired by this function must be released using\n+ * rsvg_release_node() in reverse acquiring order.\n+ *\n+ * Returns: The node referenced by @url or %NULL if the @url\n+ *          does not reference a node.\n+ *\/\n+RsvgNode *\n+rsvg_acquire_node (RsvgDrawingCtx * ctx, const char *url)\n+{\n+  RsvgNode *node;\n+\n+  node = rsvg_defs_lookup (ctx->defs, url);\n+  if (node == NULL)\n+    return NULL;\n+\n+  if (g_slist_find (ctx->acquired_nodes, node))\n+    return NULL;\n+\n+  ctx->acquired_nodes = g_slist_prepend (ctx->acquired_nodes, node);\n+\n+  return node;\n+}\n+\n+\/*\n+ * rsvg_release_node:\n+ * @ctx: The drawing context the node was acquired from\n+ * @node: Node to release\n+ *\n+ * Releases a node previously acquired via rsvg_acquire_node().\n+ *\n+ * if @node is %NULL, this function does nothing.\n+ *\/\n+void\n+rsvg_release_node (RsvgDrawingCtx * ctx, RsvgNode *node)\n+{\n+  if (node == NULL)\n+    return;\n+\n+  g_return_if_fail (ctx->acquired_nodes != NULL);\n+  g_return_if_fail (ctx->acquired_nodes->data == node);\n+\n+  ctx->acquired_nodes = g_slist_remove (ctx->acquired_nodes, node);\n+}\n+\n void\n rsvg_render_path (RsvgDrawingCtx * ctx, const cairo_path_t *path)\n {\ndiff --git a\/rsvg-cairo-draw.c b\/rsvg-cairo-draw.c\nindex 816235c9..a8aea82e 100644\n--- a\/rsvg-cairo-draw.c\n+++ b\/rsvg-cairo-draw.c\n@@ -730,7 +730,7 @@ rsvg_cairo_push_render_stack (RsvgDrawingCtx * ctx)\n \n     if (rsvg_current_state (ctx)->clip_path) {\n         RsvgNode *node;\n-        node = rsvg_defs_lookup (ctx->defs, rsvg_current_state (ctx)->clip_path);\n+        node = rsvg_acquire_node (ctx, rsvg_current_state (ctx)->clip_path);\n         if (node && RSVG_NODE_TYPE (node) == RSVG_NODE_TYPE_CLIP_PATH) {\n             RsvgClipPath *clip_path = (RsvgClipPath *) node;\n \n@@ -748,6 +748,8 @@ rsvg_cairo_push_render_stack (RsvgDrawingCtx * ctx)\n             }\n \n         }\n+        \n+        rsvg_release_node (ctx, node);\n     }\n \n     if (state->opacity == 0xFF\n@@ -807,10 +809,12 @@ rsvg_cairo_pop_render_stack (RsvgDrawingCtx * ctx)\n \n     if (rsvg_current_state (ctx)->clip_path) {\n         RsvgNode *node;\n-        node = rsvg_defs_lookup (ctx->defs, rsvg_current_state (ctx)->clip_path);\n+        node = rsvg_acquire_node (ctx, rsvg_current_state (ctx)->clip_path);\n         if (node && RSVG_NODE_TYPE (node) == RSVG_NODE_TYPE_CLIP_PATH\n             && ((RsvgClipPath *) node)->units == objectBoundingBox)\n             lateclip = (RsvgClipPath *) node;\n+        else\n+            rsvg_release_node (ctx, node);\n     }\n \n     if (state->opacity == 0xFF\n@@ -840,17 +844,20 @@ rsvg_cairo_pop_render_stack (RsvgDrawingCtx * ctx)\n                               nest ? 0 : render->offset_x,\n                               nest ? 0 : render->offset_y);\n \n-    if (lateclip)\n+    if (lateclip) {\n         rsvg_cairo_clip (ctx, lateclip, &render->bbox);\n+        rsvg_release_node (ctx, (RsvgNode *) lateclip);\n+    }\n \n     cairo_set_operator (render->cr, state->comp_op);\n \n     if (state->mask) {\n         RsvgNode *mask;\n \n-        mask = rsvg_defs_lookup (ctx->defs, state->mask);\n+        mask = rsvg_acquire_node (ctx, state->mask);\n         if (mask && RSVG_NODE_TYPE (mask) == RSVG_NODE_TYPE_MASK)\n           rsvg_cairo_generate_mask (render->cr, (RsvgMask *) mask, ctx, &render->bbox);\n+        rsvg_release_node (ctx, mask);\n     } else if (state->opacity != 0xFF)\n         cairo_paint_with_alpha (render->cr, (double) state->opacity \/ 255.0);\n     else\ndiff --git a\/rsvg-cairo-render.c b\/rsvg-cairo-render.c\nindex 0d51dde8..0dd11625 100644\n--- a\/rsvg-cairo-render.c\n+++ b\/rsvg-cairo-render.c\n@@ -155,6 +155,7 @@ rsvg_cairo_new_drawing_ctx (cairo_t * cr, RsvgHandle * handle)\n     draw->pango_context = NULL;\n     draw->drawsub_stack = NULL;\n     draw->ptrs = NULL;\n+    draw->acquired_nodes = NULL;\n \n     rsvg_state_push (draw);\n     state = rsvg_current_state (draw);\ndiff --git a\/rsvg-filter.c b\/rsvg-filter.c\nindex b4eedec2..a8f6a27c 100644\n--- a\/rsvg-filter.c\n+++ b\/rsvg-filter.c\n@@ -3928,6 +3928,7 @@ rsvg_filter_primitive_image_render_in (RsvgFilterPrimitive * self, RsvgFilterCon\n     RsvgDrawingCtx *ctx;\n     RsvgFilterPrimitiveImage *upself;\n     RsvgNode *drawable;\n+    cairo_surface_t *result;\n \n     ctx = context->ctx;\n \n@@ -3936,13 +3937,17 @@ rsvg_filter_primitive_image_render_in (RsvgFilterPrimitive * self, RsvgFilterCon\n     if (!upself->href)\n         return NULL;\n \n-    drawable = rsvg_defs_lookup (ctx->defs, upself->href->str);\n+    drawable = rsvg_acquire_node (ctx, upself->href->str);\n     if (!drawable)\n         return NULL;\n \n     rsvg_current_state (ctx)->affine = context->paffine;\n \n-    return rsvg_get_surface_of_node (ctx, drawable, context->width, context->height);\n+    result = rsvg_get_surface_of_node (ctx, drawable, context->width, context->height);\n+\n+    rsvg_release_node (ctx, drawable);\n+\n+    return result;\n }\n \n static cairo_surface_t *\ndiff --git a\/rsvg-private.h b\/rsvg-private.h\nindex 651e2f64..fd1c1c49 100644\n--- a\/rsvg-private.h\n+++ b\/rsvg-private.h\n@@ -200,6 +200,7 @@ struct RsvgDrawingCtx {\n     GSList *vb_stack;\n     GSList *drawsub_stack;\n     GSList *ptrs;\n+    GSList *acquired_nodes;\n };\n \n \/*Abstract base class for context for our backends (one as yet)*\/\n@@ -360,6 +361,10 @@ void rsvg_pop_discrete_layer    (RsvgDrawingCtx * ctx);\n G_GNUC_INTERNAL\n void rsvg_push_discrete_layer   (RsvgDrawingCtx * ctx);\n G_GNUC_INTERNAL\n+RsvgNode *rsvg_acquire_node     (RsvgDrawingCtx * ctx, const char *url);\n+G_GNUC_INTERNAL\n+void rsvg_release_node          (RsvgDrawingCtx * ctx, RsvgNode *node);\n+G_GNUC_INTERNAL\n void rsvg_render_path           (RsvgDrawingCtx * ctx, const cairo_path_t *path);\n G_GNUC_INTERNAL\n void rsvg_render_surface        (RsvgDrawingCtx * ctx, cairo_surface_t *surface,\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-2248","CWE_ID":"20","category":"security","commit_id":"6513a81e9325d712f1bfb9a1d7b750134e49ff18","commit_message":"From 6513a81e9325d712f1bfb9a1d7b750134e49ff18 Mon Sep 17 00:00:00 2001\nFrom: Suresh Jayaraman <sjayaraman@suse.de>\nDate: Wed, 31 Mar 2010 12:00:03 +0530\nSubject: cifs: Fix a kernel BUG with remote OS\/2 server (try #3)\n\nWhile chasing a bug report involving a OS\/2 server, I noticed the server sets\npSMBr->CountHigh to a incorrect value even in case of normal writes. This\nresults in 'nbytes' being computed wrongly and triggers a kernel BUG at\nmm\/filemap.c.\n\nvoid iov_iter_advance(struct iov_iter *i, size_t bytes)\n{\n        BUG_ON(i->count < bytes);    <--- BUG here\n\nWhy the server is setting 'CountHigh' is not clear but only does so after\nwriting 64k bytes. Though this looks like the server bug, the client side\ncrash may not be acceptable.\n\nThe workaround is to mask off high 16 bits if the number of bytes written as\nreturned by the server is greater than the bytes requested by the client as\nsuggested by Jeff Layton.\n\nCC: Stable <stable@kernel.org>\nReviewed-by: Jeff Layton <jlayton@samba.org>\nSigned-off-by: Suresh Jayaraman <sjayaraman@suse.de>\nSigned-off-by: Steve French <sfrench@us.ibm.com>\n---\n fs\/cifs\/cifssmb.c | 16 ++++++++++++++++\n 1 file changed, 16 insertions(+)\n\n","diff_code":"diff --git a\/fs\/cifs\/cifssmb.c b\/fs\/cifs\/cifssmb.c\nindex e1f90a3a0162..f213b8ae43c1 100644\n--- a\/fs\/cifs\/cifssmb.c\n+++ b\/fs\/cifs\/cifssmb.c\n@@ -1518,6 +1518,14 @@ CIFSSMBWrite(const int xid, struct cifsTconInfo *tcon,\n \t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n \t\t*nbytes = (*nbytes) << 16;\n \t\t*nbytes += le16_to_cpu(pSMBr->Count);\n+\n+\t\t\/*\n+\t\t * Mask off high 16 bits when bytes written as returned by the\n+\t\t * server is greater than bytes requested by the client. Some\n+\t\t * OS\/2 servers are known to set incorrect CountHigh values.\n+\t\t *\/\n+\t\tif (*nbytes > count)\n+\t\t\t*nbytes &= 0xFFFF;\n \t}\n \n \tcifs_buf_release(pSMB);\n@@ -1606,6 +1614,14 @@ CIFSSMBWrite2(const int xid, struct cifsTconInfo *tcon,\n \t\t*nbytes = le16_to_cpu(pSMBr->CountHigh);\n \t\t*nbytes = (*nbytes) << 16;\n \t\t*nbytes += le16_to_cpu(pSMBr->Count);\n+\n+\t\t\/*\n+\t\t * Mask off high 16 bits when bytes written as returned by the\n+\t\t * server is greater than bytes requested by the client. OS\/2\n+\t\t * servers are known to set incorrect CountHigh values.\n+\t\t *\/\n+\t\tif (*nbytes > count)\n+\t\t\t*nbytes &= 0xFFFF;\n \t}\n \n \/*\tcifs_small_buf_release(pSMB); *\/ \/* Freed earlier now in SendReceive2 *\/\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-6821","CWE_ID":"20","category":"security","commit_id":"b160fc290cf49b516c5b6ee0730fd9da7fc623b1","commit_message":"From b160fc290cf49b516c5b6ee0730fd9da7fc623b1 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Thu, 9 Jul 2015 22:16:15 +0200\nSubject: [PATCH] avcodec\/mpegvideo: Clear pointers in ff_mpv_common_init()\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nThis ensures that no stale pointers leak through on any path\n\nFixes: signal_sigsegv_c3097a_991_xtrem_e2_m64q15_a32sxx.3gp\n\nFound-by: Samuel Gro\u00c3\u009f, Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/mpegvideo.c | 82 +++++++++++++++++++++++++++++++++++++++++++++++---\n 1 file changed, 78 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/mpegvideo.c b\/libavcodec\/mpegvideo.c\nindex 99d85779e0..637b5695a5 100644\n--- a\/libavcodec\/mpegvideo.c\n+++ b\/libavcodec\/mpegvideo.c\n@@ -785,6 +785,82 @@ fail:\n     return AVERROR(ENOMEM);\n }\n \n+static void clear_context(MpegEncContext *s)\n+{\n+    int i, j, k;\n+\n+    memset(&s->next_picture, 0, sizeof(s->next_picture));\n+    memset(&s->last_picture, 0, sizeof(s->last_picture));\n+    memset(&s->current_picture, 0, sizeof(s->current_picture));\n+    memset(&s->new_picture, 0, sizeof(s->new_picture));\n+\n+    memset(s->thread_context, 0, sizeof(s->thread_context));\n+\n+    s->me.map = NULL;\n+    s->me.score_map = NULL;\n+    s->dct_error_sum = NULL;\n+    s->block = NULL;\n+    s->blocks = NULL;\n+    memset(s->pblocks, 0, sizeof(s->pblocks));\n+    s->ac_val_base = NULL;\n+    s->ac_val[0] =\n+    s->ac_val[1] =\n+    s->ac_val[2] =NULL;\n+    s->sc.edge_emu_buffer = NULL;\n+    s->me.scratchpad = NULL;\n+    s->me.temp =\n+    s->sc.rd_scratchpad =\n+    s->sc.b_scratchpad =\n+    s->sc.obmc_scratchpad = NULL;\n+\n+    s->parse_context.buffer = NULL;\n+    s->parse_context.buffer_size = 0;\n+    s->bitstream_buffer = NULL;\n+    s->allocated_bitstream_buffer_size = 0;\n+    s->picture          = NULL;\n+    s->mb_type          = NULL;\n+    s->p_mv_table_base  = NULL;\n+    s->b_forw_mv_table_base = NULL;\n+    s->b_back_mv_table_base = NULL;\n+    s->b_bidir_forw_mv_table_base = NULL;\n+    s->b_bidir_back_mv_table_base = NULL;\n+    s->b_direct_mv_table_base = NULL;\n+    s->p_mv_table            = NULL;\n+    s->b_forw_mv_table       = NULL;\n+    s->b_back_mv_table       = NULL;\n+    s->b_bidir_forw_mv_table = NULL;\n+    s->b_bidir_back_mv_table = NULL;\n+    s->b_direct_mv_table     = NULL;\n+    for (i = 0; i < 2; i++) {\n+        for (j = 0; j < 2; j++) {\n+            for (k = 0; k < 2; k++) {\n+                s->b_field_mv_table_base[i][j][k] = NULL;\n+                s->b_field_mv_table[i][j][k] = NULL;\n+            }\n+            s->b_field_select_table[i][j] = NULL;\n+            s->p_field_mv_table_base[i][j] = NULL;\n+            s->p_field_mv_table[i][j] = NULL;\n+        }\n+        s->p_field_select_table[i] = NULL;\n+    }\n+\n+    s->dc_val_base = NULL;\n+    s->coded_block_base = NULL;\n+    s->mbintra_table = NULL;\n+    s->cbp_table = NULL;\n+    s->pred_dir_table = NULL;\n+\n+    s->mbskip_table = NULL;\n+\n+    s->er.error_status_table = NULL;\n+    s->er.er_temp_buffer = NULL;\n+    s->mb_index2xy = NULL;\n+    s->lambda_table = NULL;\n+\n+    s->cplx_tab = NULL;\n+    s->bits_tab = NULL;\n+}\n+\n \/**\n  * init common structure for both encoder and decoder.\n  * this assumes that some variables like width\/height are already set\n@@ -796,6 +872,8 @@ av_cold int ff_mpv_common_init(MpegEncContext *s)\n                      s->avctx->active_thread_type & FF_THREAD_SLICE) ?\n                     s->avctx->thread_count : 1;\n \n+    clear_context(s);\n+\n     if (s->encoding && s->avctx->slices)\n         nb_slices = s->avctx->slices;\n \n@@ -840,10 +918,6 @@ av_cold int ff_mpv_common_init(MpegEncContext *s)\n         if (!s->picture[i].f)\n             goto fail;\n     }\n-    memset(&s->next_picture, 0, sizeof(s->next_picture));\n-    memset(&s->last_picture, 0, sizeof(s->last_picture));\n-    memset(&s->current_picture, 0, sizeof(s->current_picture));\n-    memset(&s->new_picture, 0, sizeof(s->new_picture));\n     s->next_picture.f = av_frame_alloc();\n     if (!s->next_picture.f)\n         goto fail;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-3620","CWE_ID":"20","category":"security","commit_id":"7dc482dfeeeefcfd000d4271c4626937406756d7","commit_message":"From 7dc482dfeeeefcfd000d4271c4626937406756d7 Mon Sep 17 00:00:00 2001\nFrom: Ben Hutchings <ben@decadent.org.uk>\nDate: Sun, 23 Aug 2009 16:59:04 +0100\nSubject: drm\/r128: Add test for initialisation to all ioctls that require it\n\nAlmost all r128's private ioctls require that the CCE state has\nalready been initialised.  However, most do not test that this has\nbeen done, and will proceed to dereference a null pointer.  This may\nresult in a security vulnerability, since some ioctls are\nunprivileged.\n\nThis adds a macro for the common initialisation test and changes all\nioctl implementations that require prior initialisation to use that\nmacro.\n\nAlso, r128_do_init_cce() does not test that the CCE state has not\nbeen initialised already.  Repeated initialisation may lead to a crash\nor resource leak.  This adds that test.\n\nSigned-off-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n drivers\/gpu\/drm\/r128\/r128_cce.c   | 18 ++++++++++++++----\n drivers\/gpu\/drm\/r128\/r128_drv.h   |  8 ++++++++\n drivers\/gpu\/drm\/r128\/r128_state.c | 36 +++++++++++++++++++-----------------\n 3 files changed, 41 insertions(+), 21 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/gpu\/drm\/r128\/r128_cce.c b\/drivers\/gpu\/drm\/r128\/r128_cce.c\nindex 15252f60bbd3..4c39a407aa4a 100644\n--- a\/drivers\/gpu\/drm\/r128\/r128_cce.c\n+++ b\/drivers\/gpu\/drm\/r128\/r128_cce.c\n@@ -346,6 +346,11 @@ static int r128_do_init_cce(struct drm_device * dev, drm_r128_init_t * init)\n \n \tDRM_DEBUG(\"\\n\");\n \n+\tif (dev->dev_private) {\n+\t\tDRM_DEBUG(\"called when already initialized\\n\");\n+\t\treturn -EINVAL;\n+\t}\n+\n \tdev_priv = kzalloc(sizeof(drm_r128_private_t), GFP_KERNEL);\n \tif (dev_priv == NULL)\n \t\treturn -ENOMEM;\n@@ -647,6 +652,8 @@ int r128_cce_start(struct drm_device *dev, void *data, struct drm_file *file_pri\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n+\n \tif (dev_priv->cce_running || dev_priv->cce_mode == R128_PM4_NONPM4) {\n \t\tDRM_DEBUG(\"while CCE running\\n\");\n \t\treturn 0;\n@@ -669,6 +676,8 @@ int r128_cce_stop(struct drm_device *dev, void *data, struct drm_file *file_priv\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n+\n \t\/* Flush any pending CCE commands.  This ensures any outstanding\n \t * commands are exectuted by the engine before we turn it off.\n \t *\/\n@@ -706,10 +715,7 @@ int r128_cce_reset(struct drm_device *dev, void *data, struct drm_file *file_pri\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n-\tif (!dev_priv) {\n-\t\tDRM_DEBUG(\"called before init done\\n\");\n-\t\treturn -EINVAL;\n-\t}\n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n \n \tr128_do_cce_reset(dev_priv);\n \n@@ -726,6 +732,8 @@ int r128_cce_idle(struct drm_device *dev, void *data, struct drm_file *file_priv\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n+\n \tif (dev_priv->cce_running) {\n \t\tr128_do_cce_flush(dev_priv);\n \t}\n@@ -739,6 +747,8 @@ int r128_engine_reset(struct drm_device *dev, void *data, struct drm_file *file_\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n+\tDEV_INIT_TEST_WITH_RETURN(dev->dev_private);\n+\n \treturn r128_do_engine_reset(dev);\n }\n \ndiff --git a\/drivers\/gpu\/drm\/r128\/r128_drv.h b\/drivers\/gpu\/drm\/r128\/r128_drv.h\nindex 797a26c42dab..3c60829d82e9 100644\n--- a\/drivers\/gpu\/drm\/r128\/r128_drv.h\n+++ b\/drivers\/gpu\/drm\/r128\/r128_drv.h\n@@ -422,6 +422,14 @@ static __inline__ void r128_update_ring_snapshot(drm_r128_private_t * dev_priv)\n  * Misc helper macros\n  *\/\n \n+#define DEV_INIT_TEST_WITH_RETURN(_dev_priv)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+\tif (!_dev_priv) {\t\t\t\t\t\t\\\n+\t\tDRM_ERROR(\"called with no initialization\\n\");\t\t\\\n+\t\treturn -EINVAL;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n #define RING_SPACE_TEST_WITH_RETURN( dev_priv )\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n \tdrm_r128_ring_buffer_t *ring = &dev_priv->ring; int i;\t\t\\\ndiff --git a\/drivers\/gpu\/drm\/r128\/r128_state.c b\/drivers\/gpu\/drm\/r128\/r128_state.c\nindex 026a48c95c8f..af2665cf4718 100644\n--- a\/drivers\/gpu\/drm\/r128\/r128_state.c\n+++ b\/drivers\/gpu\/drm\/r128\/r128_state.c\n@@ -1244,14 +1244,18 @@ static void r128_cce_dispatch_stipple(struct drm_device * dev, u32 * stipple)\n static int r128_cce_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)\n {\n \tdrm_r128_private_t *dev_priv = dev->dev_private;\n-\tdrm_r128_sarea_t *sarea_priv = dev_priv->sarea_priv;\n+\tdrm_r128_sarea_t *sarea_priv;\n \tdrm_r128_clear_t *clear = data;\n \tDRM_DEBUG(\"\\n\");\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n+\n \tRING_SPACE_TEST_WITH_RETURN(dev_priv);\n \n+\tsarea_priv = dev_priv->sarea_priv;\n+\n \tif (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)\n \t\tsarea_priv->nbox = R128_NR_SAREA_CLIPRECTS;\n \n@@ -1312,6 +1316,8 @@ static int r128_cce_flip(struct drm_device *dev, void *data, struct drm_file *fi\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n+\n \tRING_SPACE_TEST_WITH_RETURN(dev_priv);\n \n \tif (!dev_priv->page_flipping)\n@@ -1331,6 +1337,8 @@ static int r128_cce_swap(struct drm_device *dev, void *data, struct drm_file *fi\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n+\n \tRING_SPACE_TEST_WITH_RETURN(dev_priv);\n \n \tif (sarea_priv->nbox > R128_NR_SAREA_CLIPRECTS)\n@@ -1354,10 +1362,7 @@ static int r128_cce_vertex(struct drm_device *dev, void *data, struct drm_file *\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n-\tif (!dev_priv) {\n-\t\tDRM_ERROR(\"called with no initialization\\n\");\n-\t\treturn -EINVAL;\n-\t}\n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n \n \tDRM_DEBUG(\"pid=%d index=%d count=%d discard=%d\\n\",\n \t\t  DRM_CURRENTPID, vertex->idx, vertex->count, vertex->discard);\n@@ -1410,10 +1415,7 @@ static int r128_cce_indices(struct drm_device *dev, void *data, struct drm_file\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n-\tif (!dev_priv) {\n-\t\tDRM_ERROR(\"called with no initialization\\n\");\n-\t\treturn -EINVAL;\n-\t}\n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n \n \tDRM_DEBUG(\"pid=%d buf=%d s=%d e=%d d=%d\\n\", DRM_CURRENTPID,\n \t\t  elts->idx, elts->start, elts->end, elts->discard);\n@@ -1476,6 +1478,8 @@ static int r128_cce_blit(struct drm_device *dev, void *data, struct drm_file *fi\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n+\n \tDRM_DEBUG(\"pid=%d index=%d\\n\", DRM_CURRENTPID, blit->idx);\n \n \tif (blit->idx < 0 || blit->idx >= dma->buf_count) {\n@@ -1501,6 +1505,8 @@ static int r128_cce_depth(struct drm_device *dev, void *data, struct drm_file *f\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n+\n \tRING_SPACE_TEST_WITH_RETURN(dev_priv);\n \n \tret = -EINVAL;\n@@ -1531,6 +1537,8 @@ static int r128_cce_stipple(struct drm_device *dev, void *data, struct drm_file\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n+\n \tif (DRM_COPY_FROM_USER(&mask, stipple->mask, 32 * sizeof(u32)))\n \t\treturn -EFAULT;\n \n@@ -1555,10 +1563,7 @@ static int r128_cce_indirect(struct drm_device *dev, void *data, struct drm_file\n \n \tLOCK_TEST_WITH_RETURN(dev, file_priv);\n \n-\tif (!dev_priv) {\n-\t\tDRM_ERROR(\"called with no initialization\\n\");\n-\t\treturn -EINVAL;\n-\t}\n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n \n \tDRM_DEBUG(\"idx=%d s=%d e=%d d=%d\\n\",\n \t\t  indirect->idx, indirect->start, indirect->end,\n@@ -1620,10 +1625,7 @@ static int r128_getparam(struct drm_device *dev, void *data, struct drm_file *fi\n \tdrm_r128_getparam_t *param = data;\n \tint value;\n \n-\tif (!dev_priv) {\n-\t\tDRM_ERROR(\"called with no initialization\\n\");\n-\t\treturn -EINVAL;\n-\t}\n+\tDEV_INIT_TEST_WITH_RETURN(dev_priv);\n \n \tDRM_DEBUG(\"pid=%d\\n\", DRM_CURRENTPID);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9375","CWE_ID":"20","category":"security","commit_id":"96d87bdda3919bb16f754b3d3fd1227e1f38f13c","commit_message":"From 96d87bdda3919bb16f754b3d3fd1227e1f38f13c Mon Sep 17 00:00:00 2001\nFrom: Gerd Hoffmann <kraxel@redhat.com>\nDate: Thu, 2 Feb 2017 12:36:12 +0100\nSubject: [PATCH] xhci: guard xhci_kick_epctx against recursive calls\n\nTrack xhci_kick_epctx processing being active in a variable.  Check the\nvariable before calling xhci_kick_epctx from xhci_kick_ep.  Add an\nassert to make sure we don't call recursively into xhci_kick_epctx.\n\nCc: 1653384@bugs.launchpad.net\nFixes: 94b037f2a451b3dc855f9f2c346e5049a361bd55\nReported-by: Fabian Lesniak <fabian@lesniak-it.de>\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\nMessage-id: 1486035372-3621-1-git-send-email-kraxel@redhat.com\nMessage-id: 1485790607-31399-5-git-send-email-kraxel@redhat.com\n---\n hw\/usb\/hcd-xhci.c | 7 +++++++\n 1 file changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/hw\/usb\/hcd-xhci.c b\/hw\/usb\/hcd-xhci.c\nindex f89d8da..1878dad 100644\n--- a\/hw\/usb\/hcd-xhci.c\n+++ b\/hw\/usb\/hcd-xhci.c\n@@ -390,6 +390,7 @@ struct XHCIEPContext {\n     dma_addr_t pctx;\n     unsigned int max_psize;\n     uint32_t state;\n+    uint32_t kick_active;\n \n     \/* streams *\/\n     unsigned int max_pstreams;\n@@ -2131,6 +2132,9 @@ static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n         return;\n     }\n \n+    if (epctx->kick_active) {\n+        return;\n+    }\n     xhci_kick_epctx(epctx, streamid);\n }\n \n@@ -2146,6 +2150,7 @@ static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n     int i;\n \n     trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n+    assert(!epctx->kick_active);\n \n     \/* If the device has been detached, but the guest has not noticed this\n        yet the 2 above checks will succeed, but we must NOT continue *\/\n@@ -2217,6 +2222,7 @@ static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n     }\n     assert(ring->dequeue != 0);\n \n+    epctx->kick_active++;\n     while (1) {\n         length = xhci_ring_chain_length(xhci, ring);\n         if (length <= 0) {\n@@ -2253,6 +2259,7 @@ static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n             break;\n         }\n     }\n+    epctx->kick_active--;\n \n     ep = xhci_epid_to_usbep(epctx);\n     if (ep) {\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-4072","CWE_ID":"20","category":"security","commit_id":"1e9b175204e3286d64dfd6c9f09151c31b5e099a","commit_message":"From 1e9b175204e3286d64dfd6c9f09151c31b5e099a Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 20 Mar 2016 20:54:09 -0700\nSubject: [PATCH] Fix bug #71860: Require valid paths for phar filenames\n\n---\n ext\/phar\/phar.c                              |  4 +++\n ext\/phar\/phar_object.c                       | 40 ++++++++++++++--------------\n ext\/phar\/tests\/badparameters.phpt            | 18 ++++++-------\n ext\/phar\/tests\/bug64931\/bug64931.phpt        |  5 ++--\n ext\/phar\/tests\/create_path_error.phpt        |  3 +--\n ext\/phar\/tests\/phar_extract.phpt             |  2 +-\n ext\/phar\/tests\/phar_isvalidpharfilename.phpt |  2 +-\n ext\/phar\/tests\/phar_unlinkarchive.phpt       |  2 +-\n ext\/phar\/tests\/pharfileinfo_construct.phpt   |  2 +-\n 9 files changed, 41 insertions(+), 37 deletions(-)\n\n","diff_code":"diff --git a\/ext\/phar\/phar.c b\/ext\/phar\/phar.c\nindex 18feace..08f480d 100644\n--- a\/ext\/phar\/phar.c\n+++ b\/ext\/phar\/phar.c\n@@ -2196,6 +2196,10 @@ int phar_split_fname(const char *filename, int filename_len, char **arch, int *a\n #endif\n \tint ext_len;\n \n+\tif (CHECK_NULL_PATH(filename, filename_len)) {\n+\t\treturn FAILURE;\n+\t}\n+\n \tif (!strncasecmp(filename, \"phar:\/\/\", 7)) {\n \t\tfilename += 7;\n \t\tfilename_len -= 7;\ndiff --git a\/ext\/phar\/phar_object.c b\/ext\/phar\/phar_object.c\nindex 22404dd..7c9c335 100644\n--- a\/ext\/phar\/phar_object.c\n+++ b\/ext\/phar\/phar_object.c\n@@ -459,7 +459,7 @@ PHP_METHOD(Phar, mount)\n \tsize_t path_len, actual_len;\n \tphar_archive_data *pphar;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &path, &path_len, &actual, &actual_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"pp\", &path, &path_len, &actual, &actual_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -938,7 +938,7 @@ PHP_METHOD(Phar, createDefaultStub)\n \tzend_string *stub;\n \tsize_t index_len = 0, webindex_len = 0;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|ss\", &index, &index_len, &webindex, &webindex_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"|pp\", &index, &index_len, &webindex, &webindex_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -982,7 +982,7 @@ PHP_METHOD(Phar, loadPhar)\n \tchar *fname, *alias = NULL, *error;\n \tsize_t fname_len, alias_len = 0;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|s!\", &fname, &fname_len, &alias, &alias_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p|s!\", &fname, &fname_len, &alias, &alias_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -1062,7 +1062,7 @@ PHP_METHOD(Phar, isValidPharFilename)\n \tint ext_len, is_executable;\n \tzend_bool executable = 1;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|b\", &fname, &fname_len, &executable) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p|b\", &fname, &fname_len, &executable) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -1134,11 +1134,11 @@ PHP_METHOD(Phar, __construct)\n \tis_data = instanceof_function(Z_OBJCE_P(zobj), phar_ce_data);\n \n \tif (is_data) {\n-\t\tif (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"s|ls!l\", &fname, &fname_len, &flags, &alias, &alias_len, &format) == FAILURE) {\n+\t\tif (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"p|ls!l\", &fname, &fname_len, &flags, &alias, &alias_len, &format) == FAILURE) {\n \t\t\treturn;\n \t\t}\n \t} else {\n-\t\tif (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"s|ls!\", &fname, &fname_len, &flags, &alias, &alias_len) == FAILURE) {\n+\t\tif (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"p|ls!\", &fname, &fname_len, &flags, &alias, &alias_len) == FAILURE) {\n \t\t\treturn;\n \t\t}\n \t}\n@@ -1307,7 +1307,7 @@ PHP_METHOD(Phar, unlinkArchive)\n \tint zname_len, arch_len, entry_len;\n \tphar_archive_data *phar;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &fname, &fname_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &fname, &fname_len) == FAILURE) {\n \t\tRETURN_FALSE;\n \t}\n \n@@ -1739,7 +1739,7 @@ PHP_METHOD(Phar, buildFromDirectory)\n \t\treturn;\n \t}\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|s\", &dir, &dir_len, &regex, &regex_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p|s\", &dir, &dir_len, &regex, &regex_len) == FAILURE) {\n \t\tRETURN_FALSE;\n \t}\n \n@@ -2586,7 +2586,7 @@ PHP_METHOD(Phar, delete)\n \t\treturn;\n \t}\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &fname, &fname_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &fname, &fname_len) == FAILURE) {\n \t\tRETURN_FALSE;\n \t}\n \n@@ -3400,7 +3400,7 @@ PHP_METHOD(Phar, copy)\n \n \tPHAR_ARCHIVE_OBJECT();\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &oldfile, &oldfile_len, &newfile, &newfile_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"pp\", &oldfile, &oldfile_len, &newfile, &newfile_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -3500,7 +3500,7 @@ PHP_METHOD(Phar, offsetExists)\n \n \tPHAR_ARCHIVE_OBJECT();\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &fname, &fname_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &fname, &fname_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -3538,7 +3538,7 @@ PHP_METHOD(Phar, offsetGet)\n \tzend_string *sfname;\n \tPHAR_ARCHIVE_OBJECT();\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &fname, &fname_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &fname, &fname_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -3685,8 +3685,8 @@ PHP_METHOD(Phar, offsetSet)\n \t\treturn;\n \t}\n \n-\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS(), \"sr\", &fname, &fname_len, &zresource) == FAILURE\n-\t&& zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &fname, &fname_len, &cont_str, &cont_len) == FAILURE) {\n+\tif (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS(), \"pr\", &fname, &fname_len, &zresource) == FAILURE\n+\t&& zend_parse_parameters(ZEND_NUM_ARGS(), \"ps\", &fname, &fname_len, &cont_str, &cont_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -3724,7 +3724,7 @@ PHP_METHOD(Phar, offsetUnset)\n \t\treturn;\n \t}\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &fname, &fname_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &fname, &fname_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -3771,7 +3771,7 @@ PHP_METHOD(Phar, addEmptyDir)\n \n \tPHAR_ARCHIVE_OBJECT();\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &dirname, &dirname_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &dirname, &dirname_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -3796,7 +3796,7 @@ PHP_METHOD(Phar, addFile)\n \n \tPHAR_ARCHIVE_OBJECT();\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|s\", &fname, &fname_len, &localname, &localname_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p|s\", &fname, &fname_len, &localname, &localname_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -3838,7 +3838,7 @@ PHP_METHOD(Phar, addFromString)\n \n \tPHAR_ARCHIVE_OBJECT();\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ss\", &localname, &localname_len, &cont_str, &cont_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"ps\", &localname, &localname_len, &cont_str, &cont_len) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -4264,7 +4264,7 @@ PHP_METHOD(Phar, extractTo)\n \n \tPHAR_ARCHIVE_OBJECT();\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s|z!b\", &pathto, &pathto_len, &zval_files, &overwrite) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p|z!b\", &pathto, &pathto_len, &zval_files, &overwrite) == FAILURE) {\n \t\treturn;\n \t}\n \n@@ -4396,7 +4396,7 @@ PHP_METHOD(PharFileInfo, __construct)\n \tphar_archive_data *phar_data;\n \tzval *zobj = getThis(), arg1;\n \n-\tif (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"s\", &fname, &fname_len) == FAILURE) {\n+\tif (zend_parse_parameters_throw(ZEND_NUM_ARGS(), \"p\", &fname, &fname_len) == FAILURE) {\n \t\treturn;\n \t}\n \ndiff --git a\/ext\/phar\/tests\/badparameters.phpt b\/ext\/phar\/tests\/badparameters.phpt\nindex a1a9fb7..4d0887f 100644\n--- a\/ext\/phar\/tests\/badparameters.phpt\n+++ b\/ext\/phar\/tests\/badparameters.phpt\n@@ -147,19 +147,19 @@ echo $e->getMessage() . \"\\n\";\n --EXPECTF--\n Warning: Phar::mungServer() expects parameter 1 to be array, %string given in %sbadparameters.php on line %d\n \n-Warning: Phar::createDefaultStub() expects parameter 1 to be %string, array given in %sbadparameters.php on line %d\n+Warning: Phar::createDefaultStub() expects parameter 1 to be a valid path, array given in %sbadparameters.php on line %d\n \n-Warning: Phar::loadPhar() expects parameter 1 to be %string, array given in %sbadparameters.php on line %d\n+Warning: Phar::loadPhar() expects parameter 1 to be a valid path, array given in %sbadparameters.php on line %d\n \n Warning: Phar::canCompress() expects parameter 1 to be integer, %string given in %sbadparameters.php on line %d\n \n-Exception: Phar::__construct() expects parameter 1 to be %string, array given in %sbadparameters.php on line %d\n+Exception: Phar::__construct() expects parameter 1 to be a valid path, array given in %sbadparameters.php on line %d\n \n Warning: Phar::convertToExecutable() expects parameter 1 to be integer, array given in %sbadparameters.php on line %d\n \n Warning: Phar::convertToData() expects parameter 1 to be integer, array given in %sbadparameters.php on line %d\n \n-Warning: PharData::delete() expects parameter 1 to be %string, array given in %sbadparameters.php on line %d\n+Warning: PharData::delete() expects parameter 1 to be a valid path, array given in %sbadparameters.php on line %d\n Cannot write out phar archive, phar is read-only\n Entry oops does not exist and cannot be deleted\n %sfiles\/frontcontroller10.phar\n@@ -186,18 +186,18 @@ Phar is readonly, cannot change compression\n Warning: Phar::copy() expects exactly 2 parameters, 1 given in %sbadparameters.php on line %d\n Cannot copy \"a\" to \"b\", phar is read-only\n \n-Warning: Phar::offsetExists() expects parameter 1 to be %string, array given in %sbadparameters.php on line %d\n+Warning: Phar::offsetExists() expects parameter 1 to be a valid path, array given in %sbadparameters.php on line %d\n \n-Warning: Phar::offsetGet() expects parameter 1 to be %string, array given in %sbadparameters.php on line %d\n+Warning: Phar::offsetGet() expects parameter 1 to be a valid path, array given in %sbadparameters.php on line %d\n \n Warning: Phar::offsetSet() expects exactly 2 parameters, 1 given in %sbadparameters.php on line %d\n \n-Warning: PharData::offsetUnset() expects parameter 1 to be %string, array given in %sbadparameters.php on line %d\n+Warning: PharData::offsetUnset() expects parameter 1 to be a valid path, array given in %sbadparameters.php on line %d\n Write operations disabled by the php.ini setting phar.readonly\n \n-Warning: Phar::addEmptyDir() expects parameter 1 to be %string, array given in %sbadparameters.php on line %d\n+Warning: Phar::addEmptyDir() expects parameter 1 to be a valid path, array given in %sbadparameters.php on line %d\n \n-Warning: Phar::addFile() expects parameter 1 to be %string, array given in %sbadparameters.php on line %d\n+Warning: Phar::addFile() expects parameter 1 to be a valid path, array given in %sbadparameters.php on line %d\n \n Warning: Phar::addFromString() expects exactly 2 parameters, 1 given in %sbadparameters.php on line %d\n Write operations disabled by the php.ini setting phar.readonly\ndiff --git a\/ext\/phar\/tests\/bug64931\/bug64931.phpt b\/ext\/phar\/tests\/bug64931\/bug64931.phpt\nindex 9c1f9dc..29e0c7b 100644\n--- a\/ext\/phar\/tests\/bug64931\/bug64931.phpt\n+++ b\/ext\/phar\/tests\/bug64931\/bug64931.phpt\n@@ -48,11 +48,12 @@ try {\n <?php\n @unlink(__DIR__.\"\/bug64931.phar\");\n ?>\n---EXPECT--\n+--EXPECTF--\n Test\n CAUGHT: Cannot create any files in magic \".phar\" directory\n CAUGHT: Cannot create any files in magic \".phar\" directory\n CAUGHT: Cannot create any files in magic \".phar\" directory\n CAUGHT: Cannot create any files in magic \".phar\" directory\n-CAUGHT: Cannot create any files in magic \".phar\" directory\n+\n+Warning: Phar::addFromString() expects parameter 1 to be a valid path, string given in %s\/bug64931.php on line %d\n ===DONE===\n\\ No newline at end of file\ndiff --git a\/ext\/phar\/tests\/create_path_error.phpt b\/ext\/phar\/tests\/create_path_error.phpt\nindex fe2cd3e..3449b07 100644\n--- a\/ext\/phar\/tests\/create_path_error.phpt\n+++ b\/ext\/phar\/tests\/create_path_error.phpt\n@@ -80,6 +80,5 @@ string(5) \"query\"\n 11:Error: file_put_contents(phar:\/\/%s): failed to open stream: phar error: invalid path \"%s\" contains illegal character\n 12:Error: file_put_contents(phar:\/\/%s): failed to open stream: phar error: invalid path \"%s\" contains illegal character\n 13:Error: file_put_contents(phar:\/\/%s): failed to open stream: phar error: invalid path \"%s\" contains illegal character\n-Exception: Entry a does not exist and cannot be created: phar error: invalid path \"a\" contains illegal character\n-===DONE===\n+Error: Phar::offsetSet() expects parameter 1 to be a valid path, string given===DONE===\n \ndiff --git a\/ext\/phar\/tests\/phar_extract.phpt b\/ext\/phar\/tests\/phar_extract.phpt\nindex bc54523..f7d1403 100644\n--- a\/ext\/phar\/tests\/phar_extract.phpt\n+++ b\/ext\/phar\/tests\/phar_extract.phpt\n@@ -138,7 +138,7 @@ string(3) \"hi2\"\n bool(false)\n Invalid argument, expected a filename (string) or array of filenames\n \n-Warning: Phar::extractTo() expects parameter 1 to be %string, array given in %sphar_extract.php on line %d\n+Warning: Phar::extractTo() expects parameter 1 to be a valid path, array given in %sphar_extract.php on line %d\n Invalid argument, extraction path must be non-zero length\n Unable to use path \"%soops\" for extraction, it is a file, must be a directory\n Invalid argument, array of filenames to extract contains non-string value\ndiff --git a\/ext\/phar\/tests\/phar_isvalidpharfilename.phpt b\/ext\/phar\/tests\/phar_isvalidpharfilename.phpt\nindex dee9b7d..da07bec 100644\n--- a\/ext\/phar\/tests\/phar_isvalidpharfilename.phpt\n+++ b\/ext\/phar\/tests\/phar_isvalidpharfilename.phpt\n@@ -76,7 +76,7 @@ var_dump(Phar::isValidPharFilename('dir.phar.php', false));\n <?php\n rmdir(dirname(__FILE__) . '\/.phar');\n --EXPECTF--\n-Warning: Phar::isValidPharFilename() expects parameter 1 to be %string, array given in %sphar_isvalidpharfilename.php on line %d\n+Warning: Phar::isValidPharFilename() expects parameter 1 to be a valid path, array given in %sphar_isvalidpharfilename.php on line %d\n *\n bool(false)\n bool(false)\ndiff --git a\/ext\/phar\/tests\/phar_unlinkarchive.phpt b\/ext\/phar\/tests\/phar_unlinkarchive.phpt\nindex 4800c52..2f441ba 100644\n--- a\/ext\/phar\/tests\/phar_unlinkarchive.phpt\n+++ b\/ext\/phar\/tests\/phar_unlinkarchive.phpt\n@@ -90,7 +90,7 @@ Unknown phar archive \"\"\n Unknown phar archive \"%sphar_unlinkarchive.phar\"\n Unknown phar archive \"%sphar_unlinkarchive.phar.tar\": internal corruption of phar \"%sphar_unlinkarchive.phar.tar\" (truncated entry)\n \n-Warning: Phar::unlinkArchive() expects parameter 1 to be %string, array given in %sphar_unlinkarchive.php on line %d\n+Warning: Phar::unlinkArchive() expects parameter 1 to be a valid path, array given in %sphar_unlinkarchive.php on line %d\n bool(false)\n string(48) \"<?php echo \"first stub\\n\"; __HALT_COMPILER(); ?>\"\n phar archive \"%sphar_unlinkarchive.phar\" has open file handles or objects.  fclose() all file handles, and unset() all objects prior to calling unlinkArchive()\ndiff --git a\/ext\/phar\/tests\/pharfileinfo_construct.phpt b\/ext\/phar\/tests\/pharfileinfo_construct.phpt\nindex 1f4f617..53ee514 100644\n--- a\/ext\/phar\/tests\/pharfileinfo_construct.phpt\n+++ b\/ext\/phar\/tests\/pharfileinfo_construct.phpt\n@@ -50,7 +50,7 @@ echo $e->getMessage() . \"\\n\";\n <?php unlink(dirname(__FILE__) . '\/' . basename(__FILE__, '.clean.php') . '.phar'); ?>\n --EXPECTF--\n Cannot open phar file 'phar:\/\/%spharfileinfo_construct.phar\/oops': internal corruption of phar \"%spharfileinfo_construct.phar\" (truncated entry)\n-PharFileInfo::__construct() expects parameter 1 to be string, array given\n+PharFileInfo::__construct() expects parameter 1 to be a valid path, array given\n Cannot access phar file entry '%s' in archive '%s'\n Cannot call constructor twice\n '%s' is not a valid phar archive URL (must have at least phar:\/\/filename.phar)\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12178","CWE_ID":"20","category":"security","commit_id":"859b08d523307eebde7724fd1a0789c44813e821","commit_message":"From 859b08d523307eebde7724fd1a0789c44813e821 Mon Sep 17 00:00:00 2001\nFrom: Nathan Kidd <nkidd@opentext.com>\nDate: Wed, 24 Dec 2014 16:22:18 -0500\nSubject: Xi: fix wrong extra length check in ProcXIChangeHierarchy\n (CVE-2017-12178)\n\nReviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>\nReviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Nathan Kidd <nkidd@opentext.com>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n Xi\/xichangehierarchy.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/Xi\/xichangehierarchy.c b\/Xi\/xichangehierarchy.c\nindex 87f191f..cbdd912 100644\n--- a\/Xi\/xichangehierarchy.c\n+++ b\/Xi\/xichangehierarchy.c\n@@ -423,7 +423,7 @@ ProcXIChangeHierarchy(ClientPtr client)\n     if (!stuff->num_changes)\n         return rc;\n \n-    len = ((size_t)stuff->length << 2) - sizeof(xXIAnyHierarchyChangeInfo);\n+    len = ((size_t)stuff->length << 2) - sizeof(xXIChangeHierarchyReq);\n \n     any = (xXIAnyHierarchyChangeInfo *) &stuff[1];\n     while (stuff->num_changes--) {\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-2962","CWE_ID":"20","category":"security","commit_id":"ce9d419dbecc292cc3e06e8b1d6d123d3fa813a4","commit_message":"From ce9d419dbecc292cc3e06e8b1d6d123d3fa813a4 Mon Sep 17 00:00:00 2001\nFrom: Chris Wilson <chris@chris-wilson.co.uk>\nDate: Sun, 26 Sep 2010 20:50:05 +0100\nSubject: drm\/i915: Sanity check pread\/pwrite\n\nMove the access control up from the fast paths, which are no longer\nuniversally taken first, up into the caller. This then duplicates some\nsanity checking along the slow paths, but is much simpler.\nTracked as CVE-2010-2962.\n\nReported-by: Kees Cook <kees@ubuntu.com>\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: stable@kernel.org\n---\n drivers\/gpu\/drm\/i915\/i915_gem.c | 28 ++++++++++++++++++++--------\n 1 file changed, 20 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/gpu\/drm\/i915\/i915_gem.c b\/drivers\/gpu\/drm\/i915\/i915_gem.c\nindex cfe597865f5d..7749e78a7300 100644\n--- a\/drivers\/gpu\/drm\/i915\/i915_gem.c\n+++ b\/drivers\/gpu\/drm\/i915\/i915_gem.c\n@@ -477,8 +477,15 @@ i915_gem_pread_ioctl(struct drm_device *dev, void *data,\n \t *\/\n \tif (args->offset > obj->size || args->size > obj->size ||\n \t    args->offset + args->size > obj->size) {\n-\t\tdrm_gem_object_unreference_unlocked(obj);\n-\t\treturn -EINVAL;\n+\t\tret = -EINVAL;\n+\t\tgoto err;\n+\t}\n+\n+\tif (!access_ok(VERIFY_WRITE,\n+\t\t       (char __user *)(uintptr_t)args->data_ptr,\n+\t\t       args->size)) {\n+\t\tret = -EFAULT;\n+\t\tgoto err;\n \t}\n \n \tif (i915_gem_object_needs_bit17_swizzle(obj)) {\n@@ -490,8 +497,8 @@ i915_gem_pread_ioctl(struct drm_device *dev, void *data,\n \t\t\t\t\t\t\tfile_priv);\n \t}\n \n+err:\n \tdrm_gem_object_unreference_unlocked(obj);\n-\n \treturn ret;\n }\n \n@@ -580,8 +587,6 @@ i915_gem_gtt_pwrite_fast(struct drm_device *dev, struct drm_gem_object *obj,\n \n \tuser_data = (char __user *) (uintptr_t) args->data_ptr;\n \tremain = args->size;\n-\tif (!access_ok(VERIFY_READ, user_data, remain))\n-\t\treturn -EFAULT;\n \n \n \tmutex_lock(&dev->struct_mutex);\n@@ -940,8 +945,15 @@ i915_gem_pwrite_ioctl(struct drm_device *dev, void *data,\n \t *\/\n \tif (args->offset > obj->size || args->size > obj->size ||\n \t    args->offset + args->size > obj->size) {\n-\t\tdrm_gem_object_unreference_unlocked(obj);\n-\t\treturn -EINVAL;\n+\t\tret = -EINVAL;\n+\t\tgoto err;\n+\t}\n+\n+\tif (!access_ok(VERIFY_READ,\n+\t\t       (char __user *)(uintptr_t)args->data_ptr,\n+\t\t       args->size)) {\n+\t\tret = -EFAULT;\n+\t\tgoto err;\n \t}\n \n \t\/* We can only do the GTT pwrite on untiled buffers, as otherwise\n@@ -975,8 +987,8 @@ i915_gem_pwrite_ioctl(struct drm_device *dev, void *data,\n \t\tDRM_INFO(\"pwrite failed %d\\n\", ret);\n #endif\n \n+err:\n \tdrm_gem_object_unreference_unlocked(obj);\n-\n \treturn ret;\n }\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12182","CWE_ID":"20","category":"security","commit_id":"1b1d4c04695dced2463404174b50b3581dbd857b","commit_message":"From 1b1d4c04695dced2463404174b50b3581dbd857b Mon Sep 17 00:00:00 2001\nFrom: Nathan Kidd <nkidd@opentext.com>\nDate: Sun, 21 Dec 2014 01:10:03 -0500\nSubject: hw\/xfree86: unvalidated lengths\n\nThis addresses:\nCVE-2017-12180 in XFree86-VidModeExtension\nCVE-2017-12181 in XFree86-DGA\nCVE-2017-12182 in XFree86-DRI\n\nReviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Nathan Kidd <nkidd@opentext.com>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n Xext\/vidmode.c              | 129 ++++++++++++++++++++++++--------------------\n hw\/xfree86\/common\/xf86DGA.c |  81 ++++++++++++++++------------\n hw\/xfree86\/dri\/xf86dri.c    |   1 +\n 3 files changed, 117 insertions(+), 94 deletions(-)\n\n","diff_code":"diff --git a\/Xext\/vidmode.c b\/Xext\/vidmode.c\nindex 8ba919a..6e4a7c7 100644\n--- a\/Xext\/vidmode.c\n+++ b\/Xext\/vidmode.c\n@@ -454,6 +454,20 @@ ProcVidModeAddModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeAddModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeAddModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeAddModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeAddModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeAddModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -501,18 +515,6 @@ ProcVidModeAddModeLine(ClientPtr client)\n            stuff->after_vsyncend, stuff->after_vtotal,\n            (unsigned long) stuff->after_flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeAddModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeAddModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeAddModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeAddModeLineReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -622,6 +624,20 @@ ProcVidModeDeleteModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeDeleteModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeDeleteModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeDeleteModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeDeleteModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeDeleteModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -649,18 +665,6 @@ ProcVidModeDeleteModeLine(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,\n            (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeDeleteModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeDeleteModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeDeleteModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeDeleteModeLineReq));\n-    }\n     if (len != stuff->privsize) {\n         DebugF(\"req_len = %ld, sizeof(Req) = %d, privsize = %ld, \"\n                \"len = %d, length = %d\\n\",\n@@ -744,6 +748,20 @@ ProcVidModeModModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeModModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeModModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeModModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeModModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeModModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -768,18 +786,6 @@ ProcVidModeModModeLine(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend,\n            stuff->vtotal, (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeModModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeModModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeModModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeModModeLineReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -877,6 +883,19 @@ ProcVidModeValidateModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeValidateModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeValidateModeLineReq);\n+        len = client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeValidateModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeValidateModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeValidateModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -905,17 +924,6 @@ ProcVidModeValidateModeLine(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,\n            (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeValidateModeLineReq);\n-        len = client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeValidateModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeValidateModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeValidateModeLineReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -1027,6 +1035,20 @@ ProcVidModeSwitchToMode(ClientPtr client)\n     DEBUG_P(\"XF86VidModeSwitchToMode\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeSwitchToModeReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeSwitchToModeReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeSwitchToModeReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeSwitchToModeReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -1055,18 +1077,6 @@ ProcVidModeSwitchToMode(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,\n            (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeSwitchToModeReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeSwitchToModeReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeSwitchToModeReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeSwitchToModeReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -1457,6 +1467,7 @@ ProcVidModeSetGammaRamp(ClientPtr client)\n     VidModePtr pVidMode;\n \n     REQUEST(xXF86VidModeSetGammaRampReq);\n+    REQUEST_AT_LEAST_SIZE(xXF86VidModeSetGammaRampReq);\n \n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\ndiff --git a\/hw\/xfree86\/common\/xf86DGA.c b\/hw\/xfree86\/common\/xf86DGA.c\nindex 95434e8..505b019 100644\n--- a\/hw\/xfree86\/common\/xf86DGA.c\n+++ b\/hw\/xfree86\/common\/xf86DGA.c\n@@ -1272,13 +1272,14 @@ ProcXDGAOpenFramebuffer(ClientPtr client)\n     char *deviceName;\n     int nameSize;\n \n+    REQUEST_SIZE_MATCH(xXDGAOpenFramebufferReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n \n-    REQUEST_SIZE_MATCH(xXDGAOpenFramebufferReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1305,14 +1306,14 @@ ProcXDGACloseFramebuffer(ClientPtr client)\n {\n     REQUEST(xXDGACloseFramebufferReq);\n \n+    REQUEST_SIZE_MATCH(xXDGACloseFramebufferReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n \n-    REQUEST_SIZE_MATCH(xXDGACloseFramebufferReq);\n-\n     DGACloseFramebuffer(stuff->screen);\n \n     return Success;\n@@ -1328,10 +1329,11 @@ ProcXDGAQueryModes(ClientPtr client)\n     xXDGAModeInfo info;\n     XDGAModePtr mode;\n \n+    REQUEST_SIZE_MATCH(xXDGAQueryModesReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXDGAQueryModesReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.number = 0;\n@@ -1443,11 +1445,12 @@ ProcXDGASetMode(ClientPtr client)\n     ClientPtr owner;\n     int size;\n \n+    REQUEST_SIZE_MATCH(xXDGASetModeReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n     owner = DGA_GETCLIENT(stuff->screen);\n \n-    REQUEST_SIZE_MATCH(xXDGASetModeReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.offset = 0;\n@@ -1533,14 +1536,14 @@ ProcXDGASetViewport(ClientPtr client)\n {\n     REQUEST(xXDGASetViewportReq);\n \n+    REQUEST_SIZE_MATCH(xXDGASetViewportReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGASetViewportReq);\n-\n     DGASetViewport(stuff->screen, stuff->x, stuff->y, stuff->flags);\n \n     return Success;\n@@ -1554,14 +1557,14 @@ ProcXDGAInstallColormap(ClientPtr client)\n \n     REQUEST(xXDGAInstallColormapReq);\n \n+    REQUEST_SIZE_MATCH(xXDGAInstallColormapReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAInstallColormapReq);\n-\n     rc = dixLookupResourceByType((void **) &cmap, stuff->cmap, RT_COLORMAP,\n                                  client, DixInstallAccess);\n     if (rc != Success)\n@@ -1575,14 +1578,14 @@ ProcXDGASelectInput(ClientPtr client)\n {\n     REQUEST(xXDGASelectInputReq);\n \n+    REQUEST_SIZE_MATCH(xXDGASelectInputReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGASelectInputReq);\n-\n     if (DGA_GETCLIENT(stuff->screen) == client)\n         DGASelectInput(stuff->screen, client, stuff->mask);\n \n@@ -1594,14 +1597,14 @@ ProcXDGAFillRectangle(ClientPtr client)\n {\n     REQUEST(xXDGAFillRectangleReq);\n \n+    REQUEST_SIZE_MATCH(xXDGAFillRectangleReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAFillRectangleReq);\n-\n     if (Success != DGAFillRect(stuff->screen, stuff->x, stuff->y,\n                                stuff->width, stuff->height, stuff->color))\n         return BadMatch;\n@@ -1614,14 +1617,14 @@ ProcXDGACopyArea(ClientPtr client)\n {\n     REQUEST(xXDGACopyAreaReq);\n \n+    REQUEST_SIZE_MATCH(xXDGACopyAreaReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGACopyAreaReq);\n-\n     if (Success != DGABlitRect(stuff->screen, stuff->srcx, stuff->srcy,\n                                stuff->width, stuff->height, stuff->dstx,\n                                stuff->dsty))\n@@ -1635,14 +1638,14 @@ ProcXDGACopyTransparentArea(ClientPtr client)\n {\n     REQUEST(xXDGACopyTransparentAreaReq);\n \n+    REQUEST_SIZE_MATCH(xXDGACopyTransparentAreaReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGACopyTransparentAreaReq);\n-\n     if (Success != DGABlitTransRect(stuff->screen, stuff->srcx, stuff->srcy,\n                                     stuff->width, stuff->height, stuff->dstx,\n                                     stuff->dsty, stuff->key))\n@@ -1657,13 +1660,14 @@ ProcXDGAGetViewportStatus(ClientPtr client)\n     REQUEST(xXDGAGetViewportStatusReq);\n     xXDGAGetViewportStatusReply rep;\n \n+    REQUEST_SIZE_MATCH(xXDGAGetViewportStatusReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAGetViewportStatusReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1680,13 +1684,14 @@ ProcXDGASync(ClientPtr client)\n     REQUEST(xXDGASyncReq);\n     xXDGASyncReply rep;\n \n+    REQUEST_SIZE_MATCH(xXDGASyncReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGASyncReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1725,13 +1730,14 @@ ProcXDGAChangePixmapMode(ClientPtr client)\n     xXDGAChangePixmapModeReply rep;\n     int x, y;\n \n+    REQUEST_SIZE_MATCH(xXDGAChangePixmapModeReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAChangePixmapModeReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1755,14 +1761,14 @@ ProcXDGACreateColormap(ClientPtr client)\n     REQUEST(xXDGACreateColormapReq);\n     int result;\n \n+    REQUEST_SIZE_MATCH(xXDGACreateColormapReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGACreateColormapReq);\n-\n     if (!stuff->mode)\n         return BadValue;\n \n@@ -1791,10 +1797,11 @@ ProcXF86DGAGetVideoLL(ClientPtr client)\n     int num, offset, flags;\n     char *name;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAGetVideoLLReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAGetVideoLLReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1831,9 +1838,10 @@ ProcXF86DGADirectVideo(ClientPtr client)\n \n     REQUEST(xXF86DGADirectVideoReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGADirectVideoReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n-    REQUEST_SIZE_MATCH(xXF86DGADirectVideoReq);\n \n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n@@ -1889,10 +1897,11 @@ ProcXF86DGAGetViewPortSize(ClientPtr client)\n     REQUEST(xXF86DGAGetViewPortSizeReq);\n     xXF86DGAGetViewPortSizeReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAGetViewPortSizeReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAGetViewPortSizeReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1917,14 +1926,14 @@ ProcXF86DGASetViewPort(ClientPtr client)\n {\n     REQUEST(xXF86DGASetViewPortReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGASetViewPortReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXF86DGASetViewPortReq);\n-\n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n \n@@ -1944,10 +1953,11 @@ ProcXF86DGAGetVidPage(ClientPtr client)\n     REQUEST(xXF86DGAGetVidPageReq);\n     xXF86DGAGetVidPageReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAGetVidPageReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAGetVidPageReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1962,11 +1972,11 @@ ProcXF86DGASetVidPage(ClientPtr client)\n {\n     REQUEST(xXF86DGASetVidPageReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGASetVidPageReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGASetVidPageReq);\n-\n     \/* silently fail *\/\n \n     return Success;\n@@ -1980,14 +1990,14 @@ ProcXF86DGAInstallColormap(ClientPtr client)\n \n     REQUEST(xXF86DGAInstallColormapReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGAInstallColormapReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAInstallColormapReq);\n-\n     if (!DGAActive(stuff->screen))\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n@@ -2008,10 +2018,11 @@ ProcXF86DGAQueryDirectVideo(ClientPtr client)\n     REQUEST(xXF86DGAQueryDirectVideoReq);\n     xXF86DGAQueryDirectVideoReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAQueryDirectVideoReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAQueryDirectVideoReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -2030,14 +2041,14 @@ ProcXF86DGAViewPortChanged(ClientPtr client)\n     REQUEST(xXF86DGAViewPortChangedReq);\n     xXF86DGAViewPortChangedReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAViewPortChangedReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAViewPortChangedReq);\n-\n     if (!DGAActive(stuff->screen))\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \ndiff --git a\/hw\/xfree86\/dri\/xf86dri.c b\/hw\/xfree86\/dri\/xf86dri.c\nindex 8f3c2d6..d356db9 100644\n--- a\/hw\/xfree86\/dri\/xf86dri.c\n+++ b\/hw\/xfree86\/dri\/xf86dri.c\n@@ -570,6 +570,7 @@ static int _X_COLD\n SProcXF86DRIQueryDirectRenderingCapable(register ClientPtr client)\n {\n     REQUEST(xXF86DRIQueryDirectRenderingCapableReq);\n+    REQUEST_SIZE_MATCH(xXF86DRIQueryDirectRenderingCapableReq);\n     swaps(&stuff->length);\n     swapl(&stuff->screen);\n     return ProcXF86DRIQueryDirectRenderingCapable(client);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-14230","CWE_ID":"20","category":"security","commit_id":"6bd33275368edfa71ae117de895488584678ac79","commit_message":"From 6bd33275368edfa71ae117de895488584678ac79 Mon Sep 17 00:00:00 2001\nFrom: Bron Gondwana <brong@fastmail.fm>\nDate: Thu, 31 Aug 2017 12:43:09 +1000\nSubject: [PATCH] mboxlist: fix uninitialised memory use where pattern is\n \"Other Users\"\n\n---\n imap\/mboxlist.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/imap\/mboxlist.c b\/imap\/mboxlist.c\nindex 413cdcebe..dbee06c0f 100644\n--- a\/imap\/mboxlist.c\n+++ b\/imap\/mboxlist.c\n@@ -2851,7 +2851,7 @@ static int mboxlist_do_find(struct find_rock *rock, const strarray_t *patterns)\n         if (len) len--; \/\/ trailing separator\n \n         if (!strncmp(rock->namespace->prefix[NAMESPACE_USER], commonpat, MIN(len, prefixlen))) {\n-            if (prefixlen < len) {\n+            if (prefixlen <= len) {\n                 \/* we match all users *\/\n                 strlcpy(domainpat+domainlen, \"user.\", sizeof(domainpat)-domainlen);\n             }\n","owner":"cyrusimap","repo":"cyrus-imapd","source":"cve"},{"CVE_ID":"CVE-2019-9917","CWE_ID":"20","category":"security","commit_id":"64613bc8b6b4adf1e32231f9844d99cd512b8973","commit_message":"From 64613bc8b6b4adf1e32231f9844d99cd512b8973 Mon Sep 17 00:00:00 2001\nFrom: Alexey Sokolov <alexey+znc@asokolov.org>\nDate: Fri, 15 Mar 2019 20:34:10 +0000\nSubject: [PATCH] Don't crash if user specified invalid encoding.\n\nThis is CVE-2019-9917\n---\n modules\/controlpanel.cpp             |  2 +-\n src\/IRCNetwork.cpp                   |  4 ++--\n src\/User.cpp                         |  4 ++--\n src\/znc.cpp                          | 26 ++++++++++++++++++++++----\n test\/integration\/tests\/scripting.cpp |  7 +++++++\n 5 files changed, 34 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/modules\/controlpanel.cpp b\/modules\/controlpanel.cpp\nindex 139c2aefa..109f8c6b0 100644\n--- a\/modules\/controlpanel.cpp\n+++ b\/modules\/controlpanel.cpp\n@@ -495,7 +495,7 @@ class CAdminMod : public CModule {\n #ifdef HAVE_ICU\n         else if (sVar == \"clientencoding\") {\n             pUser->SetClientEncoding(sValue);\n-            PutModule(\"ClientEncoding = \" + sValue);\n+            PutModule(\"ClientEncoding = \" + pUser->GetClientEncoding());\n         }\n #endif\n         else\ndiff --git a\/src\/IRCNetwork.cpp b\/src\/IRCNetwork.cpp\nindex 0284dc53e..0e1d6e2a3 100644\n--- a\/src\/IRCNetwork.cpp\n+++ b\/src\/IRCNetwork.cpp\n@@ -1482,9 +1482,9 @@ void CIRCNetwork::SetBindHost(const CString& s) {\n }\n \n void CIRCNetwork::SetEncoding(const CString& s) {\n-    m_sEncoding = s;\n+    m_sEncoding = CZNC::Get().FixupEncoding(s);\n     if (GetIRCSock()) {\n-        GetIRCSock()->SetEncoding(s);\n+        GetIRCSock()->SetEncoding(m_sEncoding);\n     }\n }\n \ndiff --git a\/src\/User.cpp b\/src\/User.cpp\nindex 3fd532a7c..c44cf6070 100644\n--- a\/src\/User.cpp\n+++ b\/src\/User.cpp\n@@ -1253,9 +1253,9 @@ void CUser::SetAdmin(bool b) { m_bAdmin = b; }\n void CUser::SetDenySetBindHost(bool b) { m_bDenySetBindHost = b; }\n void CUser::SetDefaultChanModes(const CString& s) { m_sDefaultChanModes = s; }\n void CUser::SetClientEncoding(const CString& s) {\n-    m_sClientEncoding = s;\n+    m_sClientEncoding = CZNC::Get().FixupEncoding(s);\n     for (CClient* pClient : GetAllClients()) {\n-        pClient->SetEncoding(s);\n+        pClient->SetEncoding(m_sClientEncoding);\n     }\n }\n void CUser::SetQuitMsg(const CString& s) { m_sQuitMsg = s; }\ndiff --git a\/src\/znc.cpp b\/src\/znc.cpp\nindex 4e7216ee1..3f4dd2e07 100644\n--- a\/src\/znc.cpp\n+++ b\/src\/znc.cpp\n@@ -2092,18 +2092,36 @@ void CZNC::ForceEncoding() {\n     m_uiForceEncoding++;\n #ifdef HAVE_ICU\n     for (Csock* pSock : GetManager()) {\n-        if (pSock->GetEncoding().empty()) {\n-            pSock->SetEncoding(\"UTF-8\");\n-        }\n+        pSock->SetEncoding(FixupEncoding(pSock->GetEncoding()));\n     }\n #endif\n }\n void CZNC::UnforceEncoding() { m_uiForceEncoding--; }\n bool CZNC::IsForcingEncoding() const { return m_uiForceEncoding; }\n CString CZNC::FixupEncoding(const CString& sEncoding) const {\n-    if (sEncoding.empty() && m_uiForceEncoding) {\n+    if (!m_uiForceEncoding) {\n+        return sEncoding;\n+    }\n+    if (sEncoding.empty()) {\n+        return \"UTF-8\";\n+    }\n+    const char* sRealEncoding = sEncoding.c_str();\n+    if (sEncoding[0] == '*' || sEncoding[0] == '^') {\n+        sRealEncoding++;\n+    }\n+    if (!*sRealEncoding) {\n         return \"UTF-8\";\n     }\n+#ifdef HAVE_ICU\n+    UErrorCode e = U_ZERO_ERROR;\n+    UConverter* cnv = ucnv_open(sRealEncoding, &e);\n+    if (cnv) {\n+        ucnv_close(cnv);\n+    }\n+    if (U_FAILURE(e)) {\n+        return \"UTF-8\";\n+    }\n+#endif\n     return sEncoding;\n }\n \ndiff --git a\/test\/integration\/tests\/scripting.cpp b\/test\/integration\/tests\/scripting.cpp\nindex 9dd68d8fa..8f809f50c 100644\n--- a\/test\/integration\/tests\/scripting.cpp\n+++ b\/test\/integration\/tests\/scripting.cpp\n@@ -55,6 +55,13 @@ TEST_F(ZNCTest, Modpython) {\n     ircd.Write(\":n!u@h PRIVMSG nick :Hi\\xF0, github issue #1229\");\n     \/\/ \"replacement character\"\n     client.ReadUntil(\"Hi\\xEF\\xBF\\xBD, github issue\");\n+\n+    \/\/ Non-existing encoding\n+    client.Write(\"PRIVMSG *controlpanel :Set ClientEncoding $me Western\");\n+    client.Write(\"JOIN #a\\342\");\n+    client.ReadUntil(\n+        \":*controlpanel!znc@znc.in PRIVMSG nick :ClientEncoding = UTF-8\");\n+    ircd.ReadUntil(\"JOIN #a\\xEF\\xBF\\xBD\");\n }\n \n TEST_F(ZNCTest, ModpythonSocket) {\n","owner":"znc","repo":"znc","source":"cve"},{"CVE_ID":"CVE-2013-0873","CWE_ID":"20","category":"security","commit_id":"4f1279154ee9baf2078241bf5619774970d18b25","commit_message":"From 4f1279154ee9baf2078241bf5619774970d18b25 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Wed, 13 Feb 2013 01:03:30 +0100\nSubject: [PATCH] shorten: dont leave invalid channel counts in the context.\n\nFixes freeing invalid addresses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/shorten.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/libavcodec\/shorten.c b\/libavcodec\/shorten.c\nindex 804dac7558..3dda56f766 100644\n--- a\/libavcodec\/shorten.c\n+++ b\/libavcodec\/shorten.c\n@@ -343,6 +343,7 @@ static int read_header(ShortenContext *s)\n     s->channels = get_uint(s, CHANSIZE);\n     if (s->channels <= 0 || s->channels > MAX_CHANNELS) {\n         av_log(s->avctx, AV_LOG_ERROR, \"too many channels: %d\\n\", s->channels);\n+        s->channels = 0;\n         return AVERROR_INVALIDDATA;\n     }\n     s->avctx->channels = s->channels;\n-- \n2.11.0\n\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2017-7272","CWE_ID":"20","category":"security","commit_id":"bab0b99f376dac9170ac81382a5ed526938d595a","commit_message":"From bab0b99f376dac9170ac81382a5ed526938d595a Mon Sep 17 00:00:00 2001\nFrom: Sara Golemon <pollita@php.net>\nDate: Tue, 7 Mar 2017 11:27:46 -0800\nSubject: [PATCH] Detect invalid port in xp_socket parse ip address\n\nFor historical reasons, fsockopen() accepts the port and hostname\nseparately: fsockopen('127.0.0.1', 80)\n\nHowever, with the introdcution of stream transports in PHP 4.3,\nit became possible to include the port in the hostname specifier:\n\nfsockopen('127.0.0.1:80')\nOr more formally: fsockopen('tcp:\/\/127.0.0.1:80')\n\nConfusing results when these two forms are combined, however.\nfsockopen('127.0.0.1:80', 443) results in fsockopen() attempting\nto connect to '127.0.0.1:80:443' which any reasonable stack would\nconsider invalid.\n\nUnfortunately, PHP parses the address looking for the first colon\n(with special handling for IPv6, don't worry) and calls atoi()\nfrom there.  atoi() in turn, simply stops parsing at the first\nnon-numeric character and returns the value so far.\n\nThe end result is that the explicitly supplied port is treated\nas ignored garbage, rather than producing an error.\n\nThis diff replaces atoi() with strtol() and inspects the\nstop character.  If additional \"garbage\" of any kind is found,\nit fails and returns an error.\n---\n ext\/standard\/tests\/streams\/parseip-001.phpt | 37 +++++++++++++++++++++\n main\/streams\/xp_socket.c                    | 29 ++++++++++------\n 2 files changed, 55 insertions(+), 11 deletions(-)\n create mode 100644 ext\/standard\/tests\/streams\/parseip-001.phpt\n\n","diff_code":"diff --git a\/ext\/standard\/tests\/streams\/parseip-001.phpt b\/ext\/standard\/tests\/streams\/parseip-001.phpt\nnew file mode 100644\nindex 000000000000..594756db6b7c\n--- \/dev\/null\n+++ b\/ext\/standard\/tests\/streams\/parseip-001.phpt\n@@ -0,0 +1,37 @@\n+--TEST--\n+Use of double-port in fsockopen()\n+--FILE--\n+<?php\n+\n+$try = [\n+  '127.0.0.1:80',\n+  'tcp:\/\/127.0.0.1:80',\n+  '[::1]:80',\n+  'tcp:\/\/[::1]:80',\n+  'localhost:80',\n+  'tcp:\/\/localhost:80',\n+];\n+\n+foreach ($try as $addr) {\n+  echo \"== $addr ==\\n\";\n+  var_dump(@fsockopen($addr, 81, $errno, $errstr), $errstr);\n+}\n+--EXPECTF--\n+== 127.0.0.1:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"127.0.0.1:80:81\"\"\n+== tcp:\/\/127.0.0.1:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"127.0.0.1:80:81\"\"\n+== [::1]:80 ==\n+bool(false)\n+string(37) \"Failed to parse address \"[::1]:80:81\"\"\n+== tcp:\/\/[::1]:80 ==\n+bool(false)\n+string(37) \"Failed to parse address \"[::1]:80:81\"\"\n+== localhost:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"localhost:80:81\"\"\n+== tcp:\/\/localhost:80 ==\n+bool(false)\n+string(41) \"Failed to parse address \"localhost:80:81\"\"\n\\ No newline at end of file\ndiff --git a\/main\/streams\/xp_socket.c b\/main\/streams\/xp_socket.c\nindex 701a993ccc1d..3ff64787aa14 100644\n--- a\/main\/streams\/xp_socket.c\n+++ b\/main\/streams\/xp_socket.c\n@@ -571,37 +571,44 @@ static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *po\n \tchar *host = NULL;\n \n #ifdef HAVE_IPV6\n-\tchar *p;\n-\n \tif (*(str) == '[' && str_len > 1) {\n \t\t\/* IPV6 notation to specify raw address with port (i.e. [fe80::1]:80) *\/\n-\t\tp = memchr(str + 1, ']', str_len - 2);\n+\t\tchar *p = memchr(str + 1, ']', str_len - 2), *e = NULL;\n \t\tif (!p || *(p + 1) != ':') {\n \t\t\tif (get_err) {\n \t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n \t\t\t}\n \t\t\treturn NULL;\n \t\t}\n-\t\t*portno = atoi(p + 2);\n+\t\t*portno = strtol(p + 2, &e, 10);\n+\t\tif (e && *e) {\n+\t\t\tif (get_err) {\n+\t\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n+\t\t\t}\n+\t\t\treturn NULL;\n+\t\t}\n \t\treturn estrndup(str + 1, p - str - 1);\n \t}\n #endif\n+\n \tif (str_len) {\n \t\tcolon = memchr(str, ':', str_len - 1);\n \t} else {\n \t\tcolon = NULL;\n \t}\n+\n \tif (colon) {\n-\t\t*portno = atoi(colon + 1);\n-\t\thost = estrndup(str, colon - str);\n-\t} else {\n-\t\tif (get_err) {\n-\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n+\t\tchar *e = NULL;\n+\t\t*portno = strtol(colon + 1, &e, 10);\n+\t\tif (!e || !*e) {\n+\t\t\treturn estrndup(str, colon - str);\n \t\t}\n-\t\treturn NULL;\n \t}\n \n-\treturn host;\n+\tif (get_err) {\n+\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n+\t}\n+\treturn NULL;\n }\n \n static inline char *parse_ip_address(php_stream_xport_param *xparam, int *portno)\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2015-5194","CWE_ID":"20","category":"security","commit_id":"553f2fa65865c31c5e3c48812cfd46176cffdd27","commit_message":"From 553f2fa65865c31c5e3c48812cfd46176cffdd27 Mon Sep 17 00:00:00 2001\nFrom:  <davehart@shiny.ad.hartbrothers.com>\nDate: Wed, 28 Jul 2010 05:33:53 +0000\nSubject: [PATCH] [Bug 1593] ntpd abort in free() with logconfig syntax error.\n\n---\n ChangeLog         |   1 +\n ntpd\/ntp_parser.c | 114 +++++++++++++++++++++++++---------------------\n ntpd\/ntp_parser.y |  24 +++++++---\n 3 files changed, 80 insertions(+), 59 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 46a78503a..fd88a307e 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,4 @@\n+* [Bug 1593] ntpd abort in free() with logconfig syntax error.\n * [Bug 1581] from 4.2.6p3-beta1: ntp_intres.c size_t printf format\n   string mismatch.\n * [Bug 1586] ntpd 4.2.7p40 doesn't write to syslog after fork on QNX.\ndiff --git a\/ntpd\/ntp_parser.c b\/ntpd\/ntp_parser.c\nindex d7b395963..e71de8de9 100644\n--- a\/ntpd\/ntp_parser.c\n+++ b\/ntpd\/ntp_parser.c\n@@ -937,12 +937,12 @@ static const yytype_uint16 yyrline[] =\n      875,   876,   877,   878,   879,   880,   889,   890,   906,   912,\n      914,   916,   918,   920,   923,   925,   936,   938,   940,   950,\n      952,   954,   956,   958,   963,   965,   969,   973,   975,   980,\n-     982,   986,   987,   991,   992,   996,  1011,  1016,  1024,  1025,\n-    1029,  1030,  1031,  1032,  1036,  1037,  1038,  1048,  1049,  1053,\n-    1055,  1060,  1062,  1066,  1071,  1072,  1076,  1077,  1081,  1090,\n-    1091,  1095,  1096,  1105,  1120,  1124,  1125,  1129,  1130,  1134,\n-    1135,  1139,  1144,  1148,  1152,  1153,  1157,  1162,  1163,  1167,\n-    1169,  1171,  1173,  1175\n+     982,   986,   987,   991,   992,   996,  1021,  1026,  1034,  1035,\n+    1039,  1040,  1041,  1042,  1046,  1047,  1048,  1058,  1059,  1063,\n+    1065,  1070,  1072,  1076,  1081,  1082,  1086,  1087,  1091,  1100,\n+    1101,  1105,  1106,  1115,  1130,  1134,  1135,  1139,  1140,  1144,\n+    1145,  1149,  1154,  1158,  1162,  1163,  1167,  1172,  1173,  1177,\n+    1179,  1181,  1183,  1185\n };\n #endif\n \n@@ -3530,14 +3530,24 @@ yyparse ()\n \/* Line 1455 of yacc.c  *\/\n #line 997 \"ntp_parser.y\"\n     {\n-\t\t\tchar prefix = (yyvsp[(1) - (1)].String)[0];\n-\t\t\tchar *type = (yyvsp[(1) - (1)].String) + 1;\n+\t\t\tchar\tprefix;\n+\t\t\tchar *\ttype;\n \t\t\t\n-\t\t\tif (prefix != '+' && prefix != '-' && prefix != '=') {\n-\t\t\t\tyyerror(\"Logconfig prefix is not '+', '-' or '='\\n\");\n-\t\t\t}\n-\t\t\telse\n-\t\t\t\t(yyval.Attr_val) = create_attr_sval(prefix, estrdup(type));\n+\t\t\tswitch ((yyvsp[(1) - (1)].String)[0]) {\n+\t\t\t\n+\t\t\tcase '+':\n+\t\t\tcase '-':\n+\t\t\tcase '=':\n+\t\t\t\tprefix = (yyvsp[(1) - (1)].String)[0];\n+\t\t\t\ttype = (yyvsp[(1) - (1)].String) + 1;\n+\t\t\t\tbreak;\n+\t\t\t\t\n+\t\t\tdefault:\n+\t\t\t\tprefix = '=';\n+\t\t\t\ttype = (yyvsp[(1) - (1)].String);\n+\t\t\t}\t\n+\t\t\t\n+\t\t\t(yyval.Attr_val) = create_attr_sval(prefix, estrdup(type));\n \t\t\tYYFREE((yyvsp[(1) - (1)].String));\n \t\t}\n     break;\n@@ -3545,7 +3555,7 @@ yyparse ()\n   case 216:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1012 \"ntp_parser.y\"\n+#line 1022 \"ntp_parser.y\"\n     {\n \t\t\tenqueue(cfgt.nic_rules,\n \t\t\t\tcreate_nic_rule_node((yyvsp[(3) - (3)].Integer), NULL, (yyvsp[(2) - (3)].Integer)));\n@@ -3555,7 +3565,7 @@ yyparse ()\n   case 217:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1017 \"ntp_parser.y\"\n+#line 1027 \"ntp_parser.y\"\n     {\n \t\t\tenqueue(cfgt.nic_rules,\n \t\t\t\tcreate_nic_rule_node(0, (yyvsp[(3) - (3)].String), (yyvsp[(2) - (3)].Integer)));\n@@ -3565,77 +3575,77 @@ yyparse ()\n   case 227:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1048 \"ntp_parser.y\"\n+#line 1058 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), create_ival((yyvsp[(2) - (2)].Integer))); }\n     break;\n \n   case 228:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1049 \"ntp_parser.y\"\n+#line 1059 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue(create_ival((yyvsp[(1) - (1)].Integer))); }\n     break;\n \n   case 229:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1054 \"ntp_parser.y\"\n+#line 1064 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Attr_val)); }\n     break;\n \n   case 230:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1056 \"ntp_parser.y\"\n+#line 1066 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Attr_val)); }\n     break;\n \n   case 231:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1061 \"ntp_parser.y\"\n+#line 1071 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_ival('i', (yyvsp[(1) - (1)].Integer)); }\n     break;\n \n   case 233:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1067 \"ntp_parser.y\"\n+#line 1077 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_shorts('-', (yyvsp[(2) - (5)].Integer), (yyvsp[(4) - (5)].Integer)); }\n     break;\n \n   case 234:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1071 \"ntp_parser.y\"\n+#line 1081 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), create_pval((yyvsp[(2) - (2)].String))); }\n     break;\n \n   case 235:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1072 \"ntp_parser.y\"\n+#line 1082 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue(create_pval((yyvsp[(1) - (1)].String))); }\n     break;\n \n   case 236:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1076 \"ntp_parser.y\"\n+#line 1086 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Address_node)); }\n     break;\n \n   case 237:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1077 \"ntp_parser.y\"\n+#line 1087 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Address_node)); }\n     break;\n \n   case 238:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1082 \"ntp_parser.y\"\n+#line 1092 \"ntp_parser.y\"\n     {\n \t\t\tif ((yyvsp[(1) - (1)].Integer) != 0 && (yyvsp[(1) - (1)].Integer) != 1) {\n \t\t\t\tyyerror(\"Integer value is not boolean (0 or 1). Assuming 1\");\n@@ -3649,28 +3659,28 @@ yyparse ()\n   case 239:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1090 \"ntp_parser.y\"\n+#line 1100 \"ntp_parser.y\"\n     { (yyval.Integer) = 1; }\n     break;\n \n   case 240:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1091 \"ntp_parser.y\"\n+#line 1101 \"ntp_parser.y\"\n     { (yyval.Integer) = 0; }\n     break;\n \n   case 241:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1095 \"ntp_parser.y\"\n+#line 1105 \"ntp_parser.y\"\n     { (yyval.Double) = (double)(yyvsp[(1) - (1)].Integer); }\n     break;\n \n   case 243:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1106 \"ntp_parser.y\"\n+#line 1116 \"ntp_parser.y\"\n     {\n \t\t\tcfgt.sim_details = create_sim_node((yyvsp[(3) - (5)].Queue), (yyvsp[(4) - (5)].Queue));\n \n@@ -3682,147 +3692,147 @@ yyparse ()\n   case 244:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1120 \"ntp_parser.y\"\n+#line 1130 \"ntp_parser.y\"\n     { old_config_style = 0; }\n     break;\n \n   case 245:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1124 \"ntp_parser.y\"\n+#line 1134 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (3)].Queue), (yyvsp[(2) - (3)].Attr_val)); }\n     break;\n \n   case 246:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1125 \"ntp_parser.y\"\n+#line 1135 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (2)].Attr_val)); }\n     break;\n \n   case 247:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1129 \"ntp_parser.y\"\n+#line 1139 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 248:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1130 \"ntp_parser.y\"\n+#line 1140 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 249:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1134 \"ntp_parser.y\"\n+#line 1144 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Sim_server)); }\n     break;\n \n   case 250:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1135 \"ntp_parser.y\"\n+#line 1145 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Sim_server)); }\n     break;\n \n   case 251:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1140 \"ntp_parser.y\"\n+#line 1150 \"ntp_parser.y\"\n     { (yyval.Sim_server) = create_sim_server((yyvsp[(1) - (5)].Address_node), (yyvsp[(3) - (5)].Double), (yyvsp[(4) - (5)].Queue)); }\n     break;\n \n   case 252:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1144 \"ntp_parser.y\"\n+#line 1154 \"ntp_parser.y\"\n     { (yyval.Double) = (yyvsp[(3) - (4)].Double); }\n     break;\n \n   case 253:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1148 \"ntp_parser.y\"\n+#line 1158 \"ntp_parser.y\"\n     { (yyval.Address_node) = (yyvsp[(3) - (3)].Address_node); }\n     break;\n \n   case 254:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1152 \"ntp_parser.y\"\n+#line 1162 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (2)].Queue), (yyvsp[(2) - (2)].Sim_script)); }\n     break;\n \n   case 255:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1153 \"ntp_parser.y\"\n+#line 1163 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (1)].Sim_script)); }\n     break;\n \n   case 256:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1158 \"ntp_parser.y\"\n+#line 1168 \"ntp_parser.y\"\n     { (yyval.Sim_script) = create_sim_script_info((yyvsp[(3) - (6)].Double), (yyvsp[(5) - (6)].Queue)); }\n     break;\n \n   case 257:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1162 \"ntp_parser.y\"\n+#line 1172 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue((yyvsp[(1) - (3)].Queue), (yyvsp[(2) - (3)].Attr_val)); }\n     break;\n \n   case 258:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1163 \"ntp_parser.y\"\n+#line 1173 \"ntp_parser.y\"\n     { (yyval.Queue) = enqueue_in_new_queue((yyvsp[(1) - (2)].Attr_val)); }\n     break;\n \n   case 259:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1168 \"ntp_parser.y\"\n+#line 1178 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 260:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1170 \"ntp_parser.y\"\n+#line 1180 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 261:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1172 \"ntp_parser.y\"\n+#line 1182 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 262:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1174 \"ntp_parser.y\"\n+#line 1184 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n   case 263:\n \n \/* Line 1455 of yacc.c  *\/\n-#line 1176 \"ntp_parser.y\"\n+#line 1186 \"ntp_parser.y\"\n     { (yyval.Attr_val) = create_attr_dval((yyvsp[(1) - (3)].Integer), (yyvsp[(3) - (3)].Double)); }\n     break;\n \n \n \n \/* Line 1455 of yacc.c  *\/\n-#line 3826 \"ntp_parser.c\"\n+#line 3836 \"ntp_parser.c\"\n       default: break;\n     }\n   YY_SYMBOL_PRINT (\"-> $$ =\", yyr1[yyn], &yyval, &yyloc);\n@@ -4034,7 +4044,7 @@ yyparse ()\n \n \n \/* Line 1675 of yacc.c  *\/\n-#line 1180 \"ntp_parser.y\"\n+#line 1190 \"ntp_parser.y\"\n \n \n void yyerror (char *msg)\ndiff --git a\/ntpd\/ntp_parser.y b\/ntpd\/ntp_parser.y\nindex b3f7ac3d3..cf8942f03 100644\n--- a\/ntpd\/ntp_parser.y\n+++ b\/ntpd\/ntp_parser.y\n@@ -995,14 +995,24 @@ log_config_list\n log_config_command\n \t:\tT_String\n \t\t{\n-\t\t\tchar prefix = $1[0];\n-\t\t\tchar *type = $1 + 1;\n+\t\t\tchar\tprefix;\n+\t\t\tchar *\ttype;\n \t\t\t\n-\t\t\tif (prefix != '+' && prefix != '-' && prefix != '=') {\n-\t\t\t\tyyerror(\"Logconfig prefix is not '+', '-' or '='\\n\");\n-\t\t\t}\n-\t\t\telse\n-\t\t\t\t$$ = create_attr_sval(prefix, estrdup(type));\n+\t\t\tswitch ($1[0]) {\n+\t\t\t\n+\t\t\tcase '+':\n+\t\t\tcase '-':\n+\t\t\tcase '=':\n+\t\t\t\tprefix = $1[0];\n+\t\t\t\ttype = $1 + 1;\n+\t\t\t\tbreak;\n+\t\t\t\t\n+\t\t\tdefault:\n+\t\t\t\tprefix = '=';\n+\t\t\t\ttype = $1;\n+\t\t\t}\t\n+\t\t\t\n+\t\t\t$$ = create_attr_sval(prefix, estrdup(type));\n \t\t\tYYFREE($1);\n \t\t}\n \t;\n","owner":"ntp-project","repo":"ntp","source":"cve"},{"CVE_ID":"CVE-2010-2937","CWE_ID":"20","category":"security","commit_id":"22a22e356c9d93993086810b2e25b59b55925b3a","commit_message":"From 22a22e356c9d93993086810b2e25b59b55925b3a Mon Sep 17 00:00:00 2001\nFrom: =?utf8?q?Luk=C3=A1=C5=A1=20Lalinsk=C3=BD?= <lalinsky@gmail.com>\nDate: Wed, 11 Aug 2010 22:02:30 +0300\nSubject: [PATCH] taglib: fix NULL deferences after dynamic cast\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nReported-by: FortiGuard Lab\nSigned-off-by: R\u00c3\u00a9mi Denis-Courmont <remi@remlab.net>\n(cherry picked from commit 0a3d05b4058fe683e2ef49da8ece9214ade01870)\n---\n modules\/meta_engine\/taglib.cpp | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/modules\/meta_engine\/taglib.cpp b\/modules\/meta_engine\/taglib.cpp\nindex 43ac697460..9faf922a58 100644\n--- a\/modules\/meta_engine\/taglib.cpp\n+++ b\/modules\/meta_engine\/taglib.cpp\n@@ -120,6 +120,8 @@ static void ReadMetaFromId3v2( ID3v2::Tag* tag, demux_t* p_demux, demux_meta_t*\n     {\n         ID3v2::UniqueFileIdentifierFrame* p_ufid =\n                 dynamic_cast<ID3v2::UniqueFileIdentifierFrame*>(*iter);\n+        if( !p_ufid )\n+            continue;\n         const char *owner = p_ufid->owner().toCString();\n         if (!strcmp( owner, \"http:\/\/musicbrainz.org\" ))\n         {\n@@ -140,6 +142,8 @@ static void ReadMetaFromId3v2( ID3v2::Tag* tag, demux_t* p_demux, demux_meta_t*\n     {\n         ID3v2::UserTextIdentificationFrame* p_txxx =\n                 dynamic_cast<ID3v2::UserTextIdentificationFrame*>(*iter);\n+        if( !p_txxx )\n+            continue;\n         vlc_meta_AddExtra( p_meta, p_txxx->description().toCString( true ),\n                            p_txxx->fieldList().toString().toCString( true ) );\n     }\n@@ -196,6 +200,8 @@ static void ReadMetaFromId3v2( ID3v2::Tag* tag, demux_t* p_demux, demux_meta_t*\n     {\n         ID3v2::AttachedPictureFrame* p_apic =\n             dynamic_cast<ID3v2::AttachedPictureFrame*>(*iter);\n+        if( !p_apic )\n+            continue;\n         input_attachment_t *p_attachment;\n \n         const char *psz_mime;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-12168","CWE_ID":"20","category":"security","commit_id":"9e3f7a29694049edd728e2400ab57ad7553e5aa9","commit_message":"From 9e3f7a29694049edd728e2400ab57ad7553e5aa9 Mon Sep 17 00:00:00 2001\nFrom: Wei Huang <wei@redhat.com>\nDate: Wed, 16 Nov 2016 09:20:57 +0000\nSubject: [PATCH] arm64: KVM: pmu: Fix AArch32 cycle counter access\n\nWe're missing the handling code for the cycle counter accessed\nfrom a 32bit guest, leading to unexpected results.\n\nCc: stable@vger.kernel.org # 4.6+\nSigned-off-by: Wei Huang <wei@redhat.com>\nSigned-off-by: Marc Zyngier <marc.zyngier@arm.com>\n---\n arch\/arm64\/kvm\/sys_regs.c | 10 ++++++++--\n 1 file changed, 8 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm64\/kvm\/sys_regs.c b\/arch\/arm64\/kvm\/sys_regs.c\nindex f302fdb3a030b..87e7e6608cd8a 100644\n--- a\/arch\/arm64\/kvm\/sys_regs.c\n+++ b\/arch\/arm64\/kvm\/sys_regs.c\n@@ -597,8 +597,14 @@ static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n \n \t\t\tidx = ARMV8_PMU_CYCLE_IDX;\n \t\t} else {\n-\t\t\tBUG();\n+\t\t\treturn false;\n \t\t}\n+\t} else if (r->CRn == 0 && r->CRm == 9) {\n+\t\t\/* PMCCNTR *\/\n+\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n+\t\t\treturn false;\n+\n+\t\tidx = ARMV8_PMU_CYCLE_IDX;\n \t} else if (r->CRn == 14 && (r->CRm & 12) == 8) {\n \t\t\/* PMEVCNTRn_EL0 *\/\n \t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n@@ -606,7 +612,7 @@ static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n \n \t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n \t} else {\n-\t\tBUG();\n+\t\treturn false;\n \t}\n \n \tif (!pmu_counter_idx_valid(vcpu, idx))\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-2038","CWE_ID":"20","category":"security","commit_id":"263b4509ec4d47e0da3e753f85a39ea12d1eff24","commit_message":"From 263b4509ec4d47e0da3e753f85a39ea12d1eff24 Mon Sep 17 00:00:00 2001\nFrom: Scott Mayhew <smayhew@redhat.com>\nDate: Fri, 17 Jan 2014 15:12:05 -0500\nSubject: nfs: always make sure page is up-to-date before extending a write to\n cover the entire page\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nWe should always make sure the cached page is up-to-date when we're\ndetermining whether we can extend a write to cover the full page -- even\nif we've received a write delegation from the server.\n\nCommit c7559663 added logic to skip this check if we have a write\ndelegation, which can lead to data corruption such as the following\nscenario if client B receives a write delegation from the NFS server:\n\nClient A:\n    # echo 123456789 > \/mnt\/file\n\nClient B:\n    # echo abcdefghi >> \/mnt\/file\n    # cat \/mnt\/file\n    0\ufffdD0\ufffdabcdefghi\n\nJust because we hold a write delegation doesn't mean that we've read in\nthe entire page contents.\n\nCc: <stable@vger.kernel.org> # v3.11+\nSigned-off-by: Scott Mayhew <smayhew@redhat.com>\nSigned-off-by: Trond Myklebust <trond.myklebust@primarydata.com>\n---\n fs\/nfs\/write.c | 11 ++++++-----\n 1 file changed, 6 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/fs\/nfs\/write.c b\/fs\/nfs\/write.c\nindex 77a00c66c7d9..a44a87268a6e 100644\n--- a\/fs\/nfs\/write.c\n+++ b\/fs\/nfs\/write.c\n@@ -922,19 +922,20 @@ out:\n  * extend the write to cover the entire page in order to avoid fragmentation\n  * inefficiencies.\n  *\n- * If the file is opened for synchronous writes or if we have a write delegation\n- * from the server then we can just skip the rest of the checks.\n+ * If the file is opened for synchronous writes then we can just skip the rest\n+ * of the checks.\n  *\/\n static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n {\n \tif (file->f_flags & O_DSYNC)\n \t\treturn 0;\n+\tif (!nfs_write_pageuptodate(page, inode))\n+\t\treturn 0;\n \tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n \t\treturn 1;\n-\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n-\t\t\t(inode->i_flock->fl_start == 0 &&\n+\tif (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 &&\n \t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n-\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n+\t\t\tinode->i_flock->fl_type != F_RDLCK))\n \t\treturn 1;\n \treturn 0;\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-0155","CWE_ID":"20","category":"security","commit_id":"5678de3f15010b9022ee45673f33bcfc71d47b60","commit_message":"From 5678de3f15010b9022ee45673f33bcfc71d47b60 Mon Sep 17 00:00:00 2001\nFrom: Paolo Bonzini <pbonzini@redhat.com>\nDate: Fri, 28 Mar 2014 20:41:50 +0100\nSubject: KVM: ioapic: fix assignment of ioapic->rtc_status.pending_eoi\n (CVE-2014-0155)\n\nQE reported that they got the BUG_ON in ioapic_service to trigger.\nI cannot reproduce it, but there are two reasons why this could happen.\n\nThe less likely but also easiest one, is when kvm_irq_delivery_to_apic\ndoes not deliver to any APIC and returns -1.\n\nBecause irqe.shorthand == 0, the kvm_for_each_vcpu loop in that\nfunction is never reached.  However, you can target the similar loop in\nkvm_irq_delivery_to_apic_fast; just program a zero logical destination\naddress into the IOAPIC, or an out-of-range physical destination address.\n\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n virt\/kvm\/ioapic.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/virt\/kvm\/ioapic.c b\/virt\/kvm\/ioapic.c\nindex d4b601547f1f..d98d107efb05 100644\n--- a\/virt\/kvm\/ioapic.c\n+++ b\/virt\/kvm\/ioapic.c\n@@ -356,7 +356,7 @@ static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n \t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n \t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n \t\t\t\tioapic->rtc_status.dest_map);\n-\t\tioapic->rtc_status.pending_eoi = ret;\n+\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n \t} else\n \t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-0741","CWE_ID":"20","category":"security","commit_id":"184bd0484533b725194fa517ddc271ffd74da7c9","commit_message":"From 184bd0484533b725194fa517ddc271ffd74da7c9 Mon Sep 17 00:00:00 2001\nFrom: Dustin Kirkland <kirkland@canonical.com>\nDate: Thu, 29 Oct 2009 10:34:15 -0500\nSubject: whitelist host virtio networking features\n\nThis patch is a followup to 8eca6b1bc770982595db2f7207c65051572436cb,\nfixing crashes when guests with 2.6.25 virtio drivers have saturated\nvirtio network connections.\n\nhttps:\/\/bugs.edge.launchpad.net\/ubuntu\/+source\/qemu-kvm\/+bug\/458521\n\nThat patch should have been whitelisting *_HOST_* rather than the the\n*_GUEST_* features.\n\nI tested this by running an Ubuntu 8.04 Hardy guest (2.6.24 kernel +\n2.6.25-virtio driver).  I saturated both the incoming, and outgoing\nnetwork connection with nc, seeing sustained 6MB\/s up and 6MB\/s down\nbitrates for ~20 minutes.  Previously, this crashed immediately.  Now,\nthe guest does not crash and maintains network connectivity throughout\nthe test.\n\nSigned-off-by: Dustin Kirkland <kirkland@canonical.com>\nSigned-off-by: Mark McLoughlin <markmc@redhat.com>\nSigned-off-by: Anthony Liguori <aliguori@us.ibm.com>\n---\n hw\/virtio-net.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/hw\/virtio-net.c b\/hw\/virtio-net.c\nindex 4b09a930ef..2f147e5226 100644\n--- a\/hw\/virtio-net.c\n+++ b\/hw\/virtio-net.c\n@@ -187,10 +187,10 @@ static uint32_t virtio_net_bad_features(VirtIODevice *vdev)\n     \/* Linux kernel 2.6.25.  It understood MAC (as everyone must),\n      * but also these: *\/\n     features |= (1 << VIRTIO_NET_F_MAC);\n-    features |= (1 << VIRTIO_NET_F_GUEST_CSUM);\n-    features |= (1 << VIRTIO_NET_F_GUEST_TSO4);\n-    features |= (1 << VIRTIO_NET_F_GUEST_TSO6);\n-    features |= (1 << VIRTIO_NET_F_GUEST_ECN);\n+    features |= (1 << VIRTIO_NET_F_CSUM);\n+    features |= (1 << VIRTIO_NET_F_HOST_TSO4);\n+    features |= (1 << VIRTIO_NET_F_HOST_TSO6);\n+    features |= (1 << VIRTIO_NET_F_HOST_ECN);\n \n     return features & virtio_net_get_features(vdev);\n }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-2855","CWE_ID":"20","category":"security","commit_id":"0dedfbce2c1b851684ba658861fe9d620636c56a","commit_message":"From 0dedfbce2c1b851684ba658861fe9d620636c56a Mon Sep 17 00:00:00 2001\nFrom: Wayne Davison <wayned@samba.org>\nDate: Sun, 13 Apr 2014 13:44:58 -0700\nSubject: [PATCH] Avoid infinite wait reading secrets file.\n\n---\n authenticate.c | 24 +++++++++++++-----------\n 1 file changed, 13 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/authenticate.c b\/authenticate.c\nindex 3381b8c7..c92746c6 100644\n--- a\/authenticate.c\n+++ b\/authenticate.c\n@@ -102,15 +102,16 @@ static const char *check_secret(int module, const char *user, const char *group,\n \tchar pass2[MAX_DIGEST_LEN*2];\n \tconst char *fname = lp_secrets_file(module);\n \tSTRUCT_STAT st;\n-\tint fd, ok = 1;\n+\tint ok = 1;\n \tint user_len = strlen(user);\n \tint group_len = group ? strlen(group) : 0;\n \tchar *err;\n+\tFILE *fh;\n \n-\tif (!fname || !*fname || (fd = open(fname, O_RDONLY)) < 0)\n+\tif (!fname || !*fname || (fh = fopen(fname, \"r\")) == NULL)\n \t\treturn \"no secrets file\";\n \n-\tif (do_fstat(fd, &st) == -1) {\n+\tif (do_fstat(fileno(fh), &st) == -1) {\n \t\trsyserr(FLOG, errno, \"fstat(%s)\", fname);\n \t\tok = 0;\n \t} else if (lp_strict_modes(module)) {\n@@ -123,29 +124,30 @@ static const char *check_secret(int module, const char *user, const char *group,\n \t\t}\n \t}\n \tif (!ok) {\n-\t\tclose(fd);\n+\t\tfclose(fh);\n \t\treturn \"ignoring secrets file\";\n \t}\n \n \tif (*user == '#') {\n \t\t\/* Reject attempt to match a comment. *\/\n-\t\tclose(fd);\n+\t\tfclose(fh);\n \t\treturn \"invalid username\";\n \t}\n \n \t\/* Try to find a line that starts with the user (or @group) name and a ':'. *\/\n \terr = \"secret not found\";\n-\twhile ((user || group) && read_line_old(fd, line, sizeof line, 1)) {\n-\t\tconst char **ptr, *s;\n+\twhile ((user || group) && fgets(line, sizeof line, fh) != NULL) {\n+\t\tconst char **ptr, *s = strtok(line, \"\\n\\r\");\n \t\tint len;\n-\t\tif (*line == '@') {\n+\t\tif (!s)\n+\t\t\tcontinue;\n+\t\tif (*s == '@') {\n \t\t\tptr = &group;\n \t\t\tlen = group_len;\n-\t\t\ts = line+1;\n+\t\t\ts++;\n \t\t} else {\n \t\t\tptr = &user;\n \t\t\tlen = user_len;\n-\t\t\ts = line;\n \t\t}\n \t\tif (!*ptr || strncmp(s, *ptr, len) != 0 || s[len] != ':')\n \t\t\tcontinue;\n@@ -158,7 +160,7 @@ static const char *check_secret(int module, const char *user, const char *group,\n \t\t*ptr = NULL; \/* Don't look for name again. *\/\n \t}\n \n-\tclose(fd);\n+\tfclose(fh);\n \n \tmemset(line, 0, sizeof line);\n \tmemset(pass2, 0, sizeof pass2);\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2002-2443","CWE_ID":"20","category":"security","commit_id":"cf1a0c411b2668c57c41e9c4efd15ba17b6b322c","commit_message":"From cf1a0c411b2668c57c41e9c4efd15ba17b6b322c Mon Sep 17 00:00:00 2001\nFrom: Tom Yu <tlyu@mit.edu>\nDate: Fri, 3 May 2013 16:26:46 -0400\nSubject: [PATCH] Fix kpasswd UDP ping-pong [CVE-2002-2443]\n\nThe kpasswd service provided by kadmind was vulnerable to a UDP\n\"ping-pong\" attack [CVE-2002-2443].  Don't respond to packets unless\nthey pass some basic validation, and don't respond to our own error\npackets.\n\nSome authors use CVE-1999-0103 to refer to the kpasswd UDP ping-pong\nattack or UDP ping-pong attacks in general, but there is discussion\nleading toward narrowing the definition of CVE-1999-0103 to the echo,\nchargen, or other similar built-in inetd services.\n\nThanks to Vincent Danen for alerting us to this issue.\n\nCVSSv2: AV:N\/AC:L\/Au:N\/C:N\/I:N\/A:P\/E:P\/RL:O\/RC:C\n\nticket: 7637 (new)\ntarget_version: 1.11.3\ntags: pullup\n---\n src\/kadmin\/server\/schpw.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/src\/kadmin\/server\/schpw.c b\/src\/kadmin\/server\/schpw.c\nindex 15b0ab5a38..7f455d8640 100644\n--- a\/src\/kadmin\/server\/schpw.c\n+++ b\/src\/kadmin\/server\/schpw.c\n@@ -52,7 +52,7 @@ process_chpw_request(krb5_context context, void *server_handle, char *realm,\n         ret = KRB5KRB_AP_ERR_MODIFIED;\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated\", sizeof(strresult));\n-        goto chpwfail;\n+        goto bailout;\n     }\n \n     ptr = req->data;\n@@ -67,7 +67,7 @@ process_chpw_request(krb5_context context, void *server_handle, char *realm,\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request length was inconsistent\",\n                 sizeof(strresult));\n-        goto chpwfail;\n+        goto bailout;\n     }\n \n     \/* verify version number *\/\n@@ -80,7 +80,7 @@ process_chpw_request(krb5_context context, void *server_handle, char *realm,\n         numresult = KRB5_KPASSWD_BAD_VERSION;\n         snprintf(strresult, sizeof(strresult),\n                  \"Request contained unknown protocol version number %d\", vno);\n-        goto chpwfail;\n+        goto bailout;\n     }\n \n     \/* read, check ap-req length *\/\n@@ -93,7 +93,7 @@ process_chpw_request(krb5_context context, void *server_handle, char *realm,\n         numresult = KRB5_KPASSWD_MALFORMED;\n         strlcpy(strresult, \"Request was truncated in AP-REQ\",\n                 sizeof(strresult));\n-        goto chpwfail;\n+        goto bailout;\n     }\n \n     \/* verify ap_req *\/\n","owner":"krb5","repo":"krb5","source":"cve"},{"CVE_ID":"CVE-2017-12185","CWE_ID":"20","category":"security","commit_id":"cad5a1050b7184d828aef9c1dd151c3ab649d37e","commit_message":"From cad5a1050b7184d828aef9c1dd151c3ab649d37e Mon Sep 17 00:00:00 2001\nFrom: Nathan Kidd <nkidd@opentext.com>\nDate: Fri, 9 Jan 2015 09:57:23 -0500\nSubject: Unvalidated lengths\n\nv2: Add overflow check and remove unnecessary check (Julien Cristau)\n\nThis addresses:\nCVE-2017-12184 in XINERAMA\nCVE-2017-12185 in MIT-SCREEN-SAVER\nCVE-2017-12186 in X-Resource\nCVE-2017-12187 in RENDER\n\nReviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Nathan Kidd <nkidd@opentext.com>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n Xext\/panoramiX.c          | 3 ++-\n Xext\/saver.c              | 2 ++\n Xext\/xres.c               | 4 +++-\n Xext\/xvdisp.c             | 4 +++-\n hw\/dmx\/dmxpict.c          | 2 ++\n pseudoramiX\/pseudoramiX.c | 3 ++-\n render\/render.c           | 3 +++\n 7 files changed, 17 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/Xext\/panoramiX.c b\/Xext\/panoramiX.c\nindex 209df29..844ea49 100644\n--- a\/Xext\/panoramiX.c\n+++ b\/Xext\/panoramiX.c\n@@ -988,10 +988,11 @@ ProcPanoramiXGetScreenSize(ClientPtr client)\n     xPanoramiXGetScreenSizeReply rep;\n     int rc;\n \n+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n+\n     if (stuff->screen >= PanoramiXNumScreens)\n         return BadMatch;\n \n-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n     rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n     if (rc != Success)\n         return rc;\ndiff --git a\/Xext\/saver.c b\/Xext\/saver.c\nindex 0949761..f6090d8 100644\n--- a\/Xext\/saver.c\n+++ b\/Xext\/saver.c\n@@ -1186,6 +1186,8 @@ ProcScreenSaverUnsetAttributes(ClientPtr client)\n         PanoramiXRes *draw;\n         int rc, i;\n \n+        REQUEST_SIZE_MATCH(xScreenSaverUnsetAttributesReq);\n+\n         rc = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n         if (rc != Success)\ndiff --git a\/Xext\/xres.c b\/Xext\/xres.c\nindex 21239f5..0242158 100644\n--- a\/Xext\/xres.c\n+++ b\/Xext\/xres.c\n@@ -947,6 +947,8 @@ ProcXResQueryResourceBytes (ClientPtr client)\n     ConstructResourceBytesCtx    ctx;\n \n     REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);\n+    if (stuff->numSpecs > UINT32_MAX \/ sizeof(ctx.specs[0]))\n+        return BadLength;\n     REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,\n                        stuff->numSpecs * sizeof(ctx.specs[0]));\n \n@@ -1052,8 +1054,8 @@ SProcXResQueryResourceBytes (ClientPtr client)\n     int c;\n     xXResResourceIdSpec *specs = (void*) ((char*) stuff + sizeof(*stuff));\n \n-    swapl(&stuff->numSpecs);\n     REQUEST_AT_LEAST_SIZE(xXResQueryResourceBytesReq);\n+    swapl(&stuff->numSpecs);\n     REQUEST_FIXED_SIZE(xXResQueryResourceBytesReq,\n                        stuff->numSpecs * sizeof(specs[0]));\n \ndiff --git a\/Xext\/xvdisp.c b\/Xext\/xvdisp.c\nindex d99d3d4..5232b37 100644\n--- a\/Xext\/xvdisp.c\n+++ b\/Xext\/xvdisp.c\n@@ -1493,12 +1493,14 @@ XineramaXvShmPutImage(ClientPtr client)\n {\n     REQUEST(xvShmPutImageReq);\n     PanoramiXRes *draw, *gc, *port;\n-    Bool send_event = stuff->send_event;\n+    Bool send_event;\n     Bool isRoot;\n     int result, i, x, y;\n \n     REQUEST_SIZE_MATCH(xvShmPutImageReq);\n \n+    send_event = stuff->send_event;\n+\n     result = dixLookupResourceByClass((void **) &draw, stuff->drawable,\n                                       XRC_DRAWABLE, client, DixWriteAccess);\n     if (result != Success)\ndiff --git a\/hw\/dmx\/dmxpict.c b\/hw\/dmx\/dmxpict.c\nindex 1f1022e..63caec9 100644\n--- a\/hw\/dmx\/dmxpict.c\n+++ b\/hw\/dmx\/dmxpict.c\n@@ -716,6 +716,8 @@ dmxProcRenderSetPictureFilter(ClientPtr client)\n         filter = (char *) (stuff + 1);\n         params = (XFixed *) (filter + ((stuff->nbytes + 3) & ~3));\n         nparams = ((XFixed *) stuff + client->req_len) - params;\n+        if (nparams < 0)\n+            return BadLength;\n \n         XRenderSetPictureFilter(dmxScreen->beDisplay,\n                                 pPictPriv->pict, filter, params, nparams);\ndiff --git a\/pseudoramiX\/pseudoramiX.c b\/pseudoramiX\/pseudoramiX.c\nindex d8b2593..95f6e10 100644\n--- a\/pseudoramiX\/pseudoramiX.c\n+++ b\/pseudoramiX\/pseudoramiX.c\n@@ -297,10 +297,11 @@ ProcPseudoramiXGetScreenSize(ClientPtr client)\n \n     TRACE;\n \n+    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n+\n     if (stuff->screen >= pseudoramiXNumScreens)\n       return BadMatch;\n \n-    REQUEST_SIZE_MATCH(xPanoramiXGetScreenSizeReq);\n     rc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n     if (rc != Success)\n         return rc;\ndiff --git a\/render\/render.c b\/render\/render.c\nindex ccae49a..7d94bd5 100644\n--- a\/render\/render.c\n+++ b\/render\/render.c\n@@ -1757,6 +1757,9 @@ ProcRenderSetPictureFilter(ClientPtr client)\n     name = (char *) (stuff + 1);\n     params = (xFixed *) (name + pad_to_int32(stuff->nbytes));\n     nparams = ((xFixed *) stuff + client->req_len) - params;\n+    if (nparams < 0)\n+\treturn BadLength;\n+\n     result = SetPictureFilter(pPicture, name, stuff->nbytes, params, nparams);\n     return result;\n }\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6059","CWE_ID":"20","category":"security","commit_id":"612e309bfffd6f9b8ad7cdccda3019fc0865f3b4","commit_message":"From 612e309bfffd6f9b8ad7cdccda3019fc0865f3b4 Mon Sep 17 00:00:00 2001\nFrom: Hans Zandbelt <hzandbelt@pingidentity.com>\nDate: Thu, 19 Jan 2017 00:03:37 +0100\nSubject: [PATCH] don't echo query params on invalid requests to redirect URI;\n closes #212\n\nthanks @LukasReschke; I'm sure there's some OWASP guideline that warns\nagainst this\n---\n ChangeLog              | 3 +++\n src\/mod_auth_openidc.c | 4 ++--\n 2 files changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 4010fb39..b046b8d5 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,6 @@\n+01\/18\/2017\n+- don't echo the query parameters on the error page when an invalid request is made to the Redirect URI; closes #212; thanks @LukasReschke\n+\n 01\/14\/2017\n - use dynamic memory buffer for writing HTTP call responses; solves curl\/mpm-event interference; see #207\n - bump to 2.1.4rc1\ndiff --git a\/src\/mod_auth_openidc.c b\/src\/mod_auth_openidc.c\nindex fea57754..1a2fc55f 100644\n--- a\/src\/mod_auth_openidc.c\n+++ b\/src\/mod_auth_openidc.c\n@@ -2845,8 +2845,8 @@ int oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n \t\/* something went wrong *\/\n \treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n \t\t\tapr_psprintf(r->pool,\n-\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request: %s\",\n-\t\t\t\t\tr->args), HTTP_INTERNAL_SERVER_ERROR);\n+\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request\"),\n+\t\t\t\t\tHTTP_INTERNAL_SERVER_ERROR);\n }\n \n \/*\n","owner":"pingidentity","repo":"mod_auth_openidc","source":"cve"},{"CVE_ID":"CVE-2011-2707","CWE_ID":"20","category":"security","commit_id":"0d0138ebe24b94065580bd2601f8bb7eb6152f56","commit_message":"From 0d0138ebe24b94065580bd2601f8bb7eb6152f56 Mon Sep 17 00:00:00 2001\nFrom: Dan Rosenberg <drosenberg@vsecurity.com>\nDate: Mon, 25 Jul 2011 17:11:53 -0700\nSubject: xtensa: prevent arbitrary read in ptrace\n\nPrevent an arbitrary kernel read.  Check the user pointer with access_ok()\nbefore copying data in.\n\n[akpm@linux-foundation.org: s\/EIO\/EFAULT\/]\nSigned-off-by: Dan Rosenberg <drosenberg@vsecurity.com>\nCc: Christian Zankel <chris@zankel.net>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n arch\/xtensa\/kernel\/ptrace.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/arch\/xtensa\/kernel\/ptrace.c b\/arch\/xtensa\/kernel\/ptrace.c\nindex c72c9473ef99..a0d042aa2967 100644\n--- a\/arch\/xtensa\/kernel\/ptrace.c\n+++ b\/arch\/xtensa\/kernel\/ptrace.c\n@@ -147,6 +147,9 @@ int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n \telf_xtregs_t *xtregs = uregs;\n \tint ret = 0;\n \n+\tif (!access_ok(VERIFY_READ, uregs, sizeof(elf_xtregs_t)))\n+\t\treturn -EFAULT;\n+\n #if XTENSA_HAVE_COPROCESSORS\n \t\/* Flush all coprocessors before we overwrite them. *\/\n \tcoprocessor_flush_all(ti);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-11449","CWE_ID":"20","category":"security","commit_id":"529ff26b68febb2ac03062c58452ea0b4c6edbc1","commit_message":"From 529ff26b68febb2ac03062c58452ea0b4c6edbc1 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Thu, 6 Jul 2017 06:43:32 -0400\nSubject: [PATCH] ...\n\n---\n coders\/mpc.c | 1 -\n 1 file changed, 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/mpc.c b\/coders\/mpc.c\nindex 092367a78f..ed45eac320 100644\n--- a\/coders\/mpc.c\n+++ b\/coders\/mpc.c\n@@ -1008,7 +1008,6 @@ ModuleExport size_t RegisterMPCImage(void)\n   entry=SetMagickInfo(\"CACHE\");\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n-  entry->seekable_stream=MagickTrue;\n   entry->stealth=MagickTrue;\n   (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"MPC\");\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2012-4462","CWE_ID":"20","category":"security","commit_id":"8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84","commit_message":"From 8f9b304c4f6c0a98dafa61b2c0e4beb3b70e4c84 Mon Sep 17 00:00:00 2001\nFrom: Peter MacKinnon <pmackinn@redhat.com>\nDate: Fri, 28 Sep 2012 00:35:42 -0400\nSubject: [PATCH] Fixed job id parse check in aviary job control ops\n\n---\n src\/condor_contrib\/aviary\/src\/AviaryScheddPlugin.cpp |  2 +-\n src\/condor_contrib\/aviary\/src\/SchedulerObject.cpp    | 12 ++++++------\n 2 files changed, 7 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/src\/condor_contrib\/aviary\/src\/AviaryScheddPlugin.cpp b\/src\/condor_contrib\/aviary\/src\/AviaryScheddPlugin.cpp\nindex 981a2ef..9f7325e 100644\n--- a\/src\/condor_contrib\/aviary\/src\/AviaryScheddPlugin.cpp\n+++ b\/src\/condor_contrib\/aviary\/src\/AviaryScheddPlugin.cpp\n@@ -268,7 +268,7 @@ AviaryScheddPlugin::processJob(const char *key,\n \/\/\tdprintf(D_FULLDEBUG, \"Processing: %s\\n\", key);\n \n \tid = getProcByString(key);\n-\tif (id.cluster < 0 || id.proc < 0) {\n+\tif (id.cluster <= 0 || id.proc < 0) {\n \t\tdprintf(D_FULLDEBUG, \"Failed to parse key: %s - skipping\\n\", key);\n \t\treturn false;\n \t}\ndiff --git a\/src\/condor_contrib\/aviary\/src\/SchedulerObject.cpp b\/src\/condor_contrib\/aviary\/src\/SchedulerObject.cpp\nindex 89d4a85..4d00667 100644\n--- a\/src\/condor_contrib\/aviary\/src\/SchedulerObject.cpp\n+++ b\/src\/condor_contrib\/aviary\/src\/SchedulerObject.cpp\n@@ -263,7 +263,7 @@ SchedulerObject::setAttribute(std::string key,\n \t\t\t\t\t\t\t  std::string &text)\n {\n \tPROC_ID id = getProcByString(key.c_str());\n-\tif (id.cluster < 0 || id.proc < 0) {\n+\tif (id.cluster <= 0 || id.proc < 0) {\n \t\tdprintf(D_FULLDEBUG, \"SetAttribute: Failed to parse id: %s\\n\", key.c_str());\n \t\ttext = \"Invalid Id\";\n \t\treturn false;\n@@ -303,7 +303,7 @@ bool\n SchedulerObject::hold(std::string key, std::string &reason, std::string &text)\n {\n \tPROC_ID id = getProcByString(key.c_str());\n-\tif (id.cluster < 0 || id.proc < 0) {\n+\tif (id.cluster <= 0 || id.proc < 0) {\n \t\tdprintf(D_FULLDEBUG, \"Hold: Failed to parse id: %s\\n\", key.c_str());\n \t\ttext = \"Invalid Id\";\n \t\treturn false;\n@@ -329,7 +329,7 @@ bool\n SchedulerObject::release(std::string key, std::string &reason, std::string &text)\n {\n \tPROC_ID id = getProcByString(key.c_str());\n-\tif (id.cluster < 0 || id.proc < 0) {\n+\tif (id.cluster <= 0 || id.proc < 0) {\n \t\tdprintf(D_FULLDEBUG, \"Release: Failed to parse id: %s\\n\", key.c_str());\n \t\ttext = \"Invalid Id\";\n \t\treturn false;\n@@ -353,7 +353,7 @@ bool\n SchedulerObject::remove(std::string key, std::string &reason, std::string &text)\n {\n \tPROC_ID id = getProcByString(key.c_str());\n-\tif (id.cluster < 0 || id.proc < 0) {\n+\tif (id.cluster <= 0 || id.proc < 0) {\n \t\tdprintf(D_FULLDEBUG, \"Remove: Failed to parse id: %s\\n\", key.c_str());\n \t\ttext = \"Invalid Id\";\n \t\treturn false;\n@@ -375,7 +375,7 @@ bool\n SchedulerObject::suspend(std::string key, std::string &\/*reason*\/, std::string &text)\n {\n \tPROC_ID id = getProcByString(key.c_str());\n-\tif (id.cluster < 0 || id.proc < 0) {\n+\tif (id.cluster <= 0 || id.proc < 0) {\n \t\tdprintf(D_FULLDEBUG, \"Remove: Failed to parse id: %s\\n\", key.c_str());\n \t\ttext = \"Invalid Id\";\n \t\treturn false;\n@@ -390,7 +390,7 @@ bool\n SchedulerObject::_continue(std::string key, std::string &\/*reason*\/, std::string &text)\n {\n \tPROC_ID id = getProcByString(key.c_str());\n-\tif (id.cluster < 0 || id.proc < 0) {\n+\tif (id.cluster <= 0 || id.proc < 0) {\n \t\tdprintf(D_FULLDEBUG, \"Remove: Failed to parse id: %s\\n\", key.c_str());\n \t\ttext = \"Invalid Id\";\n \t\treturn false;\n-- \n1.7.12.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-10060","CWE_ID":"20","category":"security","commit_id":"933e96f01a8c889c7bf5ffd30020e86a02a046e7","commit_message":"From 933e96f01a8c889c7bf5ffd30020e86a02a046e7 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Fri, 3 Jun 2016 20:10:45 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/196\n\n---\n MagickWand\/magick-cli.c | 33 +++++++++++++++++++--------------\n 1 file changed, 19 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/MagickWand\/magick-cli.c b\/MagickWand\/magick-cli.c\nindex b4ad33bded..c28dd71696 100644\n--- a\/MagickWand\/magick-cli.c\n+++ b\/MagickWand\/magick-cli.c\n@@ -636,12 +636,15 @@ static void MagickUsage(MagickBooleanType verbose)\n    however the last argument provides the output filename.\n *\/\n static MagickBooleanType ConcatenateImages(int argc,char **argv,\n-     ExceptionInfo *exception )\n+  ExceptionInfo *exception )\n {\n   FILE\n     *input,\n     *output;\n \n+  MagickBooleanType\n+    status;\n+\n   int\n     c;\n \n@@ -650,29 +653,31 @@ static MagickBooleanType ConcatenateImages(int argc,char **argv,\n \n   if (ExpandFilenames(&argc,&argv) == MagickFalse)\n     ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n-         GetExceptionMessage(errno));\n-\n+      GetExceptionMessage(errno));\n   output=fopen_utf8(argv[argc-1],\"wb\");\n-  if (output == (FILE *) NULL) {\n-    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n-    return(MagickFalse);\n-  }\n-  for (i=2; i < (ssize_t) (argc-1); i++) {\n-#if 0\n-    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n-#endif\n+  if (output == (FILE *) NULL)\n+    {\n+      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n+        argv[argc-1]);\n+      return(MagickFalse);\n+    }\n+  status=MagickTrue;\n+  for (i=2; i < (ssize_t) (argc-1); i++)\n+  {\n     input=fopen_utf8(argv[i],\"rb\");\n-    if (input == (FILE *) NULL) {\n+    if (input == (FILE *) NULL)\n+      {\n         ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n         continue;\n       }\n     for (c=fgetc(input); c != EOF; c=fgetc(input))\n-      (void) fputc((char) c,output);\n+      if (fputc((char) c,output) != c)\n+        status=MagickFalse;\n     (void) fclose(input);\n     (void) remove_utf8(argv[i]);\n   }\n   (void) fclose(output);\n-  return(MagickTrue);\n+  return(status);\n }\n \n WandExport MagickBooleanType MagickImageCommand(ImageInfo *image_info,int argc,\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2014-2957","CWE_ID":"20","category":"security","commit_id":"5b7a7c051c9ab9ee7c924a611f90ef2be03e0ad0","commit_message":"From 5b7a7c051c9ab9ee7c924a611f90ef2be03e0ad0 Mon Sep 17 00:00:00 2001\nFrom: Todd Lyons <tlyons@exim.org>\nDate: Mon, 26 May 2014 12:14:16 -0700\nSubject: [PATCH] SECURITY: DMARC uses From header untrusted data\n\nCVE-2014-2957\n\nTo find the sending domain, expand_string() was used to directly parse\n  the contents of the From header. This passes untrusted data directly\n  into an internal function. Convert to use standard internal parsing\n  functions.\n---\n src\/src\/dmarc.c | 43 ++++++++++++++++++++++++-------------------\n 1 file changed, 24 insertions(+), 19 deletions(-)\n\n","diff_code":"diff --git a\/src\/src\/dmarc.c b\/src\/src\/dmarc.c\nindex 6e51652..c619061 100644\n--- a\/src\/src\/dmarc.c\n+++ b\/src\/src\/dmarc.c\n@@ -168,26 +168,31 @@ int dmarc_process() {\n     dmarc_abort = TRUE;\n   else\n   {\n-    \/* I strongly encourage anybody who can make this better to contact me directly!\n-     * <cannonball> Is this an insane way to extract the email address from the From: header?\n-     * <jgh_hm> it's sure a horrid layer-crossing....\n-     * <cannonball> I'm not denying that :-\/\n-     * <jgh_hm> there may well be no better though\n-     *\/\n-    header_from_sender = expand_string(\n-                           string_sprintf(\"${domain:${extract{1}{:}{${addresses:%s}}}}\",\n-                             from_header->text) );\n-    \/* The opendmarc library extracts the domain from the email address, but\n-     * only try to store it if it's not empty.  Otherwise, skip out of DMARC. *\/\n-    if (strcmp( CCS header_from_sender, \"\") == 0)\n-      dmarc_abort = TRUE;\n-    libdm_status = (dmarc_abort == TRUE) ?\n-\t           DMARC_PARSE_OKAY :\n-\t\t   opendmarc_policy_store_from_domain(dmarc_pctx, header_from_sender);\n-    if (libdm_status != DMARC_PARSE_OKAY)\n+  uschar * errormsg;\n+  int dummy, domain;\n+  uschar * p;\n+  uschar saveend;\n+\n+  parse_allow_group = TRUE;\n+  p = parse_find_address_end(from_header->text, FALSE);\n+  saveend = *p; *p = '\\0';\n+  if ((header_from_sender = parse_extract_address(from_header->text, &errormsg,\n+                              &dummy, &dummy, &domain, FALSE)))\n+    header_from_sender += domain;\n+  *p = saveend;\n+\n+  \/* The opendmarc library extracts the domain from the email address, but\n+   * only try to store it if it's not empty.  Otherwise, skip out of DMARC. *\/\n+  if (!header_from_sender || (strcmp( CCS header_from_sender, \"\") == 0))\n+    dmarc_abort = TRUE;\n+  libdm_status = dmarc_abort ?\n+    DMARC_PARSE_OKAY :\n+    opendmarc_policy_store_from_domain(dmarc_pctx, header_from_sender);\n+  if (libdm_status != DMARC_PARSE_OKAY)\n     {\n-      log_write(0, LOG_MAIN|LOG_PANIC, \"failure to store header From: in DMARC: %s, header was '%s'\",\n-                           opendmarc_policy_status_to_str(libdm_status), from_header->text);\n+      log_write(0, LOG_MAIN|LOG_PANIC,\n+                \"failure to store header From: in DMARC: %s, header was '%s'\",\n+                opendmarc_policy_status_to_str(libdm_status), from_header->text);\n       dmarc_abort = TRUE;\n     }\n   }\n-- \n1.9.1\n\n","owner":"Exim","repo":"exim","source":"cve"},{"CVE_ID":"CVE-2017-13145","CWE_ID":"20","category":"security","commit_id":"b0c5222ce31e8f941fa02ff9c7a040fb2db30dbc","commit_message":"From b0c5222ce31e8f941fa02ff9c7a040fb2db30dbc Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 28 May 2017 06:43:22 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/501\n\n---\n coders\/jp2.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/jp2.c b\/coders\/jp2.c\nindex 2d519e692e..25b1798fdc 100644\n--- a\/coders\/jp2.c\n+++ b\/coders\/jp2.c\n@@ -393,7 +393,7 @@ static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n         (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||\n         (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||\n         (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd) ||\n-        (jp2_image->comps[i].data == NULL))\n+        ((image->ping == MagickFalse) && (jp2_image->comps[i].data == NULL)))\n       {\n         opj_destroy_codec(jp2_codec);\n         opj_image_destroy(jp2_image);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-6490","CWE_ID":"20","category":"security","commit_id":"1e7aed70144b4673fc26e73062064b6724795e5f","commit_message":"From 1e7aed70144b4673fc26e73062064b6724795e5f Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Wed, 27 Jul 2016 21:07:56 +0530\nSubject: [PATCH] virtio: check vring descriptor buffer length\n\nvirtio back end uses set of buffers to facilitate I\/O operations.\nAn infinite loop unfolds in virtqueue_pop() if a buffer was\nof zero size. Add check to avoid it.\n\nReported-by: Li Qiang <liqiang6-s@360.cn>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nReviewed-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Stefan Hajnoczi <stefanha@redhat.com>\n---\n hw\/virtio\/virtio.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/hw\/virtio\/virtio.c b\/hw\/virtio\/virtio.c\nindex 752b271..b4d0511 100644\n--- a\/hw\/virtio\/virtio.c\n+++ b\/hw\/virtio\/virtio.c\n@@ -458,6 +458,11 @@ static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iove\n     unsigned num_sg = *p_num_sg;\n     assert(num_sg <= max_num_sg);\n \n+    if (!sz) {\n+        error_report(\"virtio: zero sized buffers are not allowed\");\n+        exit(1);\n+    }\n+\n     while (sz) {\n         hwaddr len = sz;\n \n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-3363","CWE_ID":"20","category":"security","commit_id":"70945643722ffeac779d2529a348f99567fa5c33","commit_message":"From 70945643722ffeac779d2529a348f99567fa5c33 Mon Sep 17 00:00:00 2001\nFrom: Jeff Layton <jlayton@redhat.com>\nDate: Mon, 14 Mar 2011 13:48:08 -0400\nSubject: [PATCH] cifs: always do is_path_accessible check in cifs_mount\n\nCurrently, we skip doing the is_path_accessible check in cifs_mount if\nthere is no prefixpath. I have a report of at least one server however\nthat allows a TREE_CONNECT to a share that has a DFS referral at its\nroot. The reporter in this case was using a UNC that had no prefixpath,\nso the is_path_accessible check was not triggered and the box later hit\na BUG() because we were chasing a DFS referral on the root dentry for\nthe mount.\n\nThis patch fixes this by removing the check for a zero-length\nprefixpath.  That should make the is_path_accessible check be done in\nthis situation and should allow the client to chase the DFS referral at\nmount time instead.\n\nCc: stable@kernel.org\nReported-and-Tested-by: Yogesh Sharma <ysharma@cymer.com>\nSigned-off-by: Jeff Layton <jlayton@redhat.com>\nSigned-off-by: Steve French <sfrench@us.ibm.com>\n---\n fs\/cifs\/connect.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/fs\/cifs\/connect.c b\/fs\/cifs\/connect.c\nindex 94a05a681f841..5eacb89d4a4f9 100644\n--- a\/fs\/cifs\/connect.c\n+++ b\/fs\/cifs\/connect.c\n@@ -2831,7 +2831,7 @@ cifs_mount(struct super_block *sb, struct cifs_sb_info *cifs_sb,\n \n remote_path_check:\n \t\/* check if a whole path (including prepath) is not remote *\/\n-\tif (!rc && cifs_sb->prepathlen && tcon) {\n+\tif (!rc && tcon) {\n \t\t\/* build_path_to_root works only when we have a valid tcon *\/\n \t\tfull_path = cifs_build_path_to_root(cifs_sb, tcon);\n \t\tif (full_path == NULL) {\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2018-14656","CWE_ID":"20","category":"security","commit_id":"342db04ae71273322f0011384a9ed414df8bdae4","commit_message":"From 342db04ae71273322f0011384a9ed414df8bdae4 Mon Sep 17 00:00:00 2001\nFrom: Jann Horn <jannh@google.com>\nDate: Tue, 28 Aug 2018 17:49:01 +0200\nSubject: x86\/dumpstack: Don't dump kernel memory based on usermode RIP\n\nshow_opcodes() is used both for dumping kernel instructions and for dumping\nuser instructions. If userspace causes #PF by jumping to a kernel address,\nshow_opcodes() can be reached with regs->ip controlled by the user,\npointing to kernel code. Make sure that userspace can't trick us into\ndumping kernel memory into dmesg.\n\nFixes: 7cccf0725cf7 (\"x86\/dumpstack: Add a show_ip() function\")\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nReviewed-by: Kees Cook <keescook@chromium.org>\nReviewed-by: Borislav Petkov <bp@suse.de>\nCc: \"H. Peter Anvin\" <hpa@zytor.com>\nCc: Andy Lutomirski <luto@kernel.org>\nCc: security@kernel.org\nCc: stable@vger.kernel.org\nLink: https:\/\/lkml.kernel.org\/r\/20180828154901.112726-1-jannh@google.com\n---\n arch\/x86\/include\/asm\/stacktrace.h |  2 +-\n arch\/x86\/kernel\/dumpstack.c       | 16 +++++++++++++---\n arch\/x86\/mm\/fault.c               |  2 +-\n 3 files changed, 15 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/stacktrace.h b\/arch\/x86\/include\/asm\/stacktrace.h\nindex b6dc698f992a..f335aad404a4 100644\n--- a\/arch\/x86\/include\/asm\/stacktrace.h\n+++ b\/arch\/x86\/include\/asm\/stacktrace.h\n@@ -111,6 +111,6 @@ static inline unsigned long caller_frame_pointer(void)\n \treturn (unsigned long)frame;\n }\n \n-void show_opcodes(u8 *rip, const char *loglvl);\n+void show_opcodes(struct pt_regs *regs, const char *loglvl);\n void show_ip(struct pt_regs *regs, const char *loglvl);\n #endif \/* _ASM_X86_STACKTRACE_H *\/\ndiff --git a\/arch\/x86\/kernel\/dumpstack.c b\/arch\/x86\/kernel\/dumpstack.c\nindex 1596e6bfea6f..f56895106ccf 100644\n--- a\/arch\/x86\/kernel\/dumpstack.c\n+++ b\/arch\/x86\/kernel\/dumpstack.c\n@@ -90,14 +90,24 @@ static void printk_stack_address(unsigned long address, int reliable,\n  * Thus, the 2\/3rds prologue and 64 byte OPCODE_BUFSIZE is just a random\n  * guesstimate in attempt to achieve all of the above.\n  *\/\n-void show_opcodes(u8 *rip, const char *loglvl)\n+void show_opcodes(struct pt_regs *regs, const char *loglvl)\n {\n #define PROLOGUE_SIZE 42\n #define EPILOGUE_SIZE 21\n #define OPCODE_BUFSIZE (PROLOGUE_SIZE + 1 + EPILOGUE_SIZE)\n \tu8 opcodes[OPCODE_BUFSIZE];\n+\tunsigned long prologue = regs->ip - PROLOGUE_SIZE;\n+\tbool bad_ip;\n \n-\tif (probe_kernel_read(opcodes, rip - PROLOGUE_SIZE, OPCODE_BUFSIZE)) {\n+\t\/*\n+\t * Make sure userspace isn't trying to trick us into dumping kernel\n+\t * memory by pointing the userspace instruction pointer at it.\n+\t *\/\n+\tbad_ip = user_mode(regs) &&\n+\t\t__chk_range_not_ok(prologue, OPCODE_BUFSIZE, TASK_SIZE_MAX);\n+\n+\tif (bad_ip || probe_kernel_read(opcodes, (u8 *)prologue,\n+\t\t\t\t\tOPCODE_BUFSIZE)) {\n \t\tprintk(\"%sCode: Bad RIP value.\\n\", loglvl);\n \t} else {\n \t\tprintk(\"%sCode: %\" __stringify(PROLOGUE_SIZE) \"ph <%02x> %\"\n@@ -113,7 +123,7 @@ void show_ip(struct pt_regs *regs, const char *loglvl)\n #else\n \tprintk(\"%sRIP: %04x:%pS\\n\", loglvl, (int)regs->cs, (void *)regs->ip);\n #endif\n-\tshow_opcodes((u8 *)regs->ip, loglvl);\n+\tshow_opcodes(regs, loglvl);\n }\n \n void show_iret_regs(struct pt_regs *regs)\ndiff --git a\/arch\/x86\/mm\/fault.c b\/arch\/x86\/mm\/fault.c\nindex b9123c497e0a..47bebfe6efa7 100644\n--- a\/arch\/x86\/mm\/fault.c\n+++ b\/arch\/x86\/mm\/fault.c\n@@ -837,7 +837,7 @@ show_signal_msg(struct pt_regs *regs, unsigned long error_code,\n \n \tprintk(KERN_CONT \"\\n\");\n \n-\tshow_opcodes((u8 *)regs->ip, loglvl);\n+\tshow_opcodes(regs, loglvl);\n }\n \n static void\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-3330","CWE_ID":"20","category":"security","commit_id":"809610f5ea38a83b284e1125d1fff129bdd615e7","commit_message":"From 809610f5ea38a83b284e1125d1fff129bdd615e7 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sat, 4 Apr 2015 15:03:46 -0700\nSubject: [PATCH] Fix bug #68486 and bug #69218 (segfault in apache2handler\n with apache 2.4)\n\n---\n sapi\/apache2handler\/sapi_apache2.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/sapi\/apache2handler\/sapi_apache2.c b\/sapi\/apache2handler\/sapi_apache2.c\nindex e97f11c..cfebc5f 100644\n--- a\/sapi\/apache2handler\/sapi_apache2.c\n+++ b\/sapi\/apache2handler\/sapi_apache2.c\n@@ -688,6 +688,7 @@ zend_first_try {\n } zend_end_try();\n \t\t}\n \t\tapr_brigade_cleanup(brigade);\n+\t\tapr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);\n \t} else {\n \t\tctx->r = parent_req;\n \t}\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-2672","CWE_ID":"20","category":"security","commit_id":"06c8173eb92bbfc03a0fe8bb64315857d0badd06","commit_message":"From 06c8173eb92bbfc03a0fe8bb64315857d0badd06 Mon Sep 17 00:00:00 2001\nFrom: Quentin Casasnovas <quentin.casasnovas@oracle.com>\nDate: Thu, 5 Mar 2015 13:19:22 +0100\nSubject: [PATCH] x86\/fpu\/xsaves: Fix improper uses of __ex_table\n\nCommit:\n\n  f31a9f7c7169 (\"x86\/xsaves: Use xsaves\/xrstors to save and restore xsave area\")\n\nintroduced alternative instructions for XSAVES\/XRSTORS and commit:\n\n  adb9d526e982 (\"x86\/xsaves: Add xsaves and xrstors support for booting time\")\n\nadded support for the XSAVES\/XRSTORS instructions at boot time.\n\nUnfortunately both failed to properly protect them against faulting:\n\nThe 'xstate_fault' macro will use the closest label named '1'\nbackward and that ends up in the .altinstr_replacement section\nrather than in .text. This means that the kernel will never find\nin the __ex_table the .text address where this instruction might\nfault, leading to serious problems if userspace manages to\ntrigger the fault.\n\nSigned-off-by: Quentin Casasnovas <quentin.casasnovas@oracle.com>\nSigned-off-by: Jamie Iles <jamie.iles@oracle.com>\n[ Improved the changelog, fixed some whitespace noise. ]\nAcked-by: Borislav Petkov <bp@alien8.de>\nAcked-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: <stable@vger.kernel.org>\nCc: Allan Xavier <mr.a.xavier@gmail.com>\nCc: H. Peter Anvin <hpa@zytor.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nFixes: adb9d526e982 (\"x86\/xsaves: Add xsaves and xrstors support for booting time\")\nFixes: f31a9f7c7169 (\"x86\/xsaves: Use xsaves\/xrstors to save and restore xsave area\")\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\n---\n arch\/x86\/include\/asm\/xsave.h | 28 +++++++++++-----------------\n 1 file changed, 11 insertions(+), 17 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/xsave.h b\/arch\/x86\/include\/asm\/xsave.h\nindex 5fa9770035dc9..c9a6d68b8d623 100644\n--- a\/arch\/x86\/include\/asm\/xsave.h\n+++ b\/arch\/x86\/include\/asm\/xsave.h\n@@ -82,18 +82,15 @@ static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)\n \tif (boot_cpu_has(X86_FEATURE_XSAVES))\n \t\tasm volatile(\"1:\"XSAVES\"\\n\\t\"\n \t\t\t\"2:\\n\\t\"\n-\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n+\t\t\t     xstate_fault\n+\t\t\t: \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n \t\t\t:   \"memory\");\n \telse\n \t\tasm volatile(\"1:\"XSAVE\"\\n\\t\"\n \t\t\t\"2:\\n\\t\"\n-\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n+\t\t\t     xstate_fault\n+\t\t\t: \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n \t\t\t:   \"memory\");\n-\n-\tasm volatile(xstate_fault\n-\t\t     : \"0\" (0)\n-\t\t     : \"memory\");\n-\n \treturn err;\n }\n \n@@ -112,18 +109,15 @@ static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n \tif (boot_cpu_has(X86_FEATURE_XSAVES))\n \t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n \t\t\t\"2:\\n\\t\"\n-\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n+\t\t\t     xstate_fault\n+\t\t\t: \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n \t\t\t:   \"memory\");\n \telse\n \t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n \t\t\t\"2:\\n\\t\"\n-\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n+\t\t\t     xstate_fault\n+\t\t\t: \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n \t\t\t:   \"memory\");\n-\n-\tasm volatile(xstate_fault\n-\t\t     : \"0\" (0)\n-\t\t     : \"memory\");\n-\n \treturn err;\n }\n \n@@ -149,9 +143,9 @@ static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n \t *\/\n \talternative_input_2(\n \t\t\"1:\"XSAVE,\n-\t\t\"1:\"XSAVEOPT,\n+\t\tXSAVEOPT,\n \t\tX86_FEATURE_XSAVEOPT,\n-\t\t\"1:\"XSAVES,\n+\t\tXSAVES,\n \t\tX86_FEATURE_XSAVES,\n \t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n \t\t\"memory\");\n@@ -178,7 +172,7 @@ static inline int xrstor_state(struct xsave_struct *fx, u64 mask)\n \t *\/\n \talternative_input(\n \t\t\"1: \" XRSTOR,\n-\t\t\"1: \" XRSTORS,\n+\t\tXRSTORS,\n \t\tX86_FEATURE_XSAVES,\n \t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n \t\t: \"memory\");\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2013-4544","CWE_ID":"20","category":"security","commit_id":"9878d173f574df74bde0ff50b2f81009fbee81bb","commit_message":"From 9878d173f574df74bde0ff50b2f81009fbee81bb Mon Sep 17 00:00:00 2001\nFrom: Dmitry Fleytman <dmitry@daynix.com>\nDate: Fri, 4 Apr 2014 12:45:20 +0300\nSubject: [PATCH] vmxnet3: validate queues configuration coming from guest\n\nCVE-2013-4544\n\nSigned-off-by: Dmitry Fleytman <dmitry@daynix.com>\nReported-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Dr. David Alan Gilbert <dgilbert@redhat.com>\nMessage-id: 1396604722-11902-3-git-send-email-dmitry@daynix.com\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>\n---\n hw\/net\/vmxnet3.c | 19 ++++++++++++++++++-\n 1 file changed, 18 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/net\/vmxnet3.c b\/hw\/net\/vmxnet3.c\nindex 0b317f8..4fefc7b 100644\n--- a\/hw\/net\/vmxnet3.c\n+++ b\/hw\/net\/vmxnet3.c\n@@ -1336,6 +1336,23 @@ static void vmxnet3_validate_interrupts(VMXNET3State *s)\n     }\n }\n \n+static void vmxnet3_validate_queues(VMXNET3State *s)\n+{\n+    \/*\n+    * txq_num and rxq_num are total number of queues\n+    * configured by guest. These numbers must not\n+    * exceed corresponding maximal values.\n+    *\/\n+\n+    if (s->txq_num > VMXNET3_DEVICE_MAX_TX_QUEUES) {\n+        hw_error(\"Bad TX queues number: %d\\n\", s->txq_num);\n+    }\n+\n+    if (s->rxq_num > VMXNET3_DEVICE_MAX_RX_QUEUES) {\n+        hw_error(\"Bad RX queues number: %d\\n\", s->rxq_num);\n+    }\n+}\n+\n static void vmxnet3_activate_device(VMXNET3State *s)\n {\n     int i;\n@@ -1382,7 +1399,7 @@ static void vmxnet3_activate_device(VMXNET3State *s)\n         VMXNET3_READ_DRV_SHARED8(s->drv_shmem, devRead.misc.numRxQueues);\n \n     VMW_CFPRN(\"Number of TX\/RX queues %u\/%u\", s->txq_num, s->rxq_num);\n-    assert(s->txq_num <= VMXNET3_DEVICE_MAX_TX_QUEUES);\n+    vmxnet3_validate_queues(s);\n \n     qdescr_table_pa =\n         VMXNET3_READ_DRV_SHARED64(s->drv_shmem, devRead.misc.queueDescPA);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-1152","CWE_ID":"20","category":"security","commit_id":"d9cd01ede97f4145af9781d448c62a3318952719","commit_message":"From d9cd01ede97f4145af9781d448c62a3318952719 Mon Sep 17 00:00:00 2001\nFrom: Tomash Brechko <tomash.brechko@gmail.com>\nDate: Mon, 2 Nov 2009 18:15:54 +0100\nSubject: [PATCH] Use strncmp when checking for large ascii multigets.\n\n---\n memcached.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/memcached.c b\/memcached.c\nindex ed67eb06e..3e2e9c59e 100644\n--- a\/memcached.c\n+++ b\/memcached.c\n@@ -3148,7 +3148,9 @@ static int try_read_command(conn *c) {\n                     ++ptr;\n                 }\n \n-                if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {\n+                if (ptr - c->rcurr > 100 ||\n+                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n+\n                     conn_set_state(c, conn_closing);\n                     return 1;\n                 }\n","owner":"memcached","repo":"memcached","source":"cve"},{"CVE_ID":"CVE-2017-13658","CWE_ID":"20","category":"security","commit_id":"e5c063a1007506ba69e97a35effcdef944421c89","commit_message":"From e5c063a1007506ba69e97a35effcdef944421c89 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 23 Jul 2017 10:39:31 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/598\n\n---\n coders\/mat.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/mat.c b\/coders\/mat.c\nindex 1f4a5af73e..be646a0081 100644\n--- a\/coders\/mat.c\n+++ b\/coders\/mat.c\n@@ -937,7 +937,8 @@ static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n     {\n MATLAB_KO:\n-      clone_info=DestroyImageInfo(clone_info);\n+      if (clone_info != (ImageInfo *) NULL)\n+        clone_info=DestroyImageInfo(clone_info);\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     }\n \n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-1943","CWE_ID":"20","category":"security","commit_id":"fa3d315a4ce2c0891cdde262562e710d95fba19e","commit_message":"From fa3d315a4ce2c0891cdde262562e710d95fba19e Mon Sep 17 00:00:00 2001\nFrom: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nDate: Sat, 7 May 2011 16:35:38 +0900\nSubject: KVM: Validate userspace_addr of memslot when registered\n\nThis way, we can avoid checking the user space address many times when\nwe read the guest memory.\n\nAlthough we can do the same for write if we check which slots are\nwritable, we do not care write now: reading the guest memory happens\nmore often than writing.\n\n[avi: change VERIFY_READ to VERIFY_WRITE]\n\nSigned-off-by: Takuya Yoshikawa <yoshikawa.takuya@oss.ntt.co.jp>\nSigned-off-by: Avi Kivity <avi@redhat.com>\n---\n arch\/x86\/kvm\/paging_tmpl.h | 2 +-\n virt\/kvm\/kvm_main.c        | 7 +++++--\n 2 files changed, 6 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/paging_tmpl.h b\/arch\/x86\/kvm\/paging_tmpl.h\nindex 88ca456ccd68..e3f81418797e 100644\n--- a\/arch\/x86\/kvm\/paging_tmpl.h\n+++ b\/arch\/x86\/kvm\/paging_tmpl.h\n@@ -185,7 +185,7 @@ walk:\n \t\t}\n \n \t\tptep_user = (pt_element_t __user *)((void *)host_addr + offset);\n-\t\tif (unlikely(copy_from_user(&pte, ptep_user, sizeof(pte)))) {\n+\t\tif (unlikely(__copy_from_user(&pte, ptep_user, sizeof(pte)))) {\n \t\t\tpresent = false;\n \t\t\tbreak;\n \t\t}\ndiff --git a\/virt\/kvm\/kvm_main.c b\/virt\/kvm\/kvm_main.c\nindex 58146457bf97..ed3c4e7c1008 100644\n--- a\/virt\/kvm\/kvm_main.c\n+++ b\/virt\/kvm\/kvm_main.c\n@@ -648,7 +648,10 @@ int __kvm_set_memory_region(struct kvm *kvm,\n \t\tgoto out;\n \tif (mem->guest_phys_addr & (PAGE_SIZE - 1))\n \t\tgoto out;\n-\tif (user_alloc && (mem->userspace_addr & (PAGE_SIZE - 1)))\n+\t\/* We can read the guest memory with __xxx_user() later on. *\/\n+\tif (user_alloc &&\n+\t    ((mem->userspace_addr & (PAGE_SIZE - 1)) ||\n+\t     !access_ok(VERIFY_WRITE, mem->userspace_addr, mem->memory_size)))\n \t\tgoto out;\n \tif (mem->slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)\n \t\tgoto out;\n@@ -1283,7 +1286,7 @@ int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n \taddr = gfn_to_hva(kvm, gfn);\n \tif (kvm_is_error_hva(addr))\n \t\treturn -EFAULT;\n-\tr = copy_from_user(data, (void __user *)addr + offset, len);\n+\tr = __copy_from_user(data, (void __user *)addr + offset, len);\n \tif (r)\n \t\treturn -EFAULT;\n \treturn 0;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-3952","CWE_ID":"20","category":"security","commit_id":"386741f887714d3e46c9e8fe577e326a7964037b","commit_message":"From 386741f887714d3e46c9e8fe577e326a7964037b Mon Sep 17 00:00:00 2001\nFrom: Alex Converse <alex.converse@gmail.com>\nDate: Thu, 26 Jan 2012 17:30:49 +0100\nSubject: [PATCH] kmvc: Check palsize.\n\nFixes: CVE-2011-3952\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nBased on fix by Michael Niedermayer\n---\n libavcodec\/kmvc.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/libavcodec\/kmvc.c b\/libavcodec\/kmvc.c\nindex 2b54b84..a6bb13b 100644\n--- a\/libavcodec\/kmvc.c\n+++ b\/libavcodec\/kmvc.c\n@@ -33,6 +33,7 @@\n #define KMVC_KEYFRAME 0x80\n #define KMVC_PALETTE  0x40\n #define KMVC_METHOD   0x0F\n+#define MAX_PALSIZE   256\n \n \/*\n  * Decoder context\n@@ -43,7 +44,7 @@ typedef struct KmvcContext {\n \n     int setpal;\n     int palsize;\n-    uint32_t pal[256];\n+    uint32_t pal[MAX_PALSIZE];\n     uint8_t *cur, *prev;\n     uint8_t *frm0, *frm1;\n     GetByteContext g;\n@@ -380,6 +381,10 @@ static av_cold int decode_init(AVCodecContext * avctx)\n         c->palsize = 127;\n     } else {\n         c->palsize = AV_RL16(avctx->extradata + 10);\n+        if (c->palsize >= MAX_PALSIZE) {\n+            av_log(avctx, AV_LOG_ERROR, \"KMVC palette too large\\n\");\n+            return AVERROR_INVALIDDATA;\n+        }\n     }\n \n     if (avctx->extradata_size == 1036) {        \/\/ palette in extradata\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-9317","CWE_ID":"20","category":"security","commit_id":"1846f48e5fcdde996e7c27a4bbac5d0aef183e4b","commit_message":"From 1846f48e5fcdde996e7c27a4bbac5d0aef183e4b Mon Sep 17 00:00:00 2001\nFrom: \"Christoph M. Becker\" <cmbecker69@gmx.de>\nDate: Sat, 12 Nov 2016 15:00:31 +0100\nSubject: [PATCH] Fix #340: System frozen\n\ngdImageCreate() doesn't check for oversized images and as such is prone\nto DoS vulnerabilities. We fix that by applying the same overflow check\nthat is already in place for gdImageCreateTrueColor().\n\nCVE-2016-9317\n---\n src\/gd.c                           |  1 +\n tests\/CMakeLists.txt               |  1 +\n tests\/Makefile.am                  |  1 +\n tests\/gdimagecreate\/.gitignore     |  1 +\n tests\/gdimagecreate\/CMakeLists.txt |  5 +++++\n tests\/gdimagecreate\/Makemodule.am  |  5 +++++\n tests\/gdimagecreate\/bug00340.c     | 33 ++++++++++++++++++++++++++++++\n 7 files changed, 47 insertions(+)\n create mode 100644 tests\/gdimagecreate\/.gitignore\n create mode 100644 tests\/gdimagecreate\/CMakeLists.txt\n create mode 100644 tests\/gdimagecreate\/Makemodule.am\n create mode 100644 tests\/gdimagecreate\/bug00340.c\n\n","diff_code":"diff --git a\/src\/gd.c b\/src\/gd.c\nindex f0cfacdc..d5d1a7ec 100644\n--- a\/src\/gd.c\n+++ b\/src\/gd.c\n@@ -188,6 +188,7 @@ BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n \tif (overflow2(sx, sy)) {\n \t\treturn NULL;\n \t}\n+\n \tif (overflow2(sizeof (unsigned char *), sy)) {\n \t\treturn NULL;\n \t}\ndiff --git a\/tests\/CMakeLists.txt b\/tests\/CMakeLists.txt\nindex c4fa9ca9..7eef4bf4 100644\n--- a\/tests\/CMakeLists.txt\n+++ b\/tests\/CMakeLists.txt\n@@ -38,6 +38,7 @@ if (BUILD_TEST)\n \t\tgdimagecopy\n \t\tgdimagecopyresampled\n \t\tgdimagecopyrotated\n+\t\tgdimagecreate\n \t\tgdimagecrop\n \t\tgdimagefile\n \t\tgdimagefill\ndiff --git a\/tests\/Makefile.am b\/tests\/Makefile.am\nindex fc5ed2b0..5f8b624b 100644\n--- a\/tests\/Makefile.am\n+++ b\/tests\/Makefile.am\n@@ -33,6 +33,7 @@ include gdimageconvolution\/Makemodule.am\n include gdimagecopy\/Makemodule.am\n include gdimagecopyresampled\/Makemodule.am\n include gdimagecopyrotated\/Makemodule.am\n+include gdimagecreate\/Makemodule.am\n include gdimagecrop\/Makemodule.am\n include gdimagefile\/Makemodule.am\n include gdimagefill\/Makemodule.am\ndiff --git a\/tests\/gdimagecreate\/.gitignore b\/tests\/gdimagecreate\/.gitignore\nnew file mode 100644\nindex 00000000..6300aed1\n--- \/dev\/null\n+++ b\/tests\/gdimagecreate\/.gitignore\n@@ -0,0 +1 @@\n+\/bug00340\ndiff --git a\/tests\/gdimagecreate\/CMakeLists.txt b\/tests\/gdimagecreate\/CMakeLists.txt\nnew file mode 100644\nindex 00000000..905e79c5\n--- \/dev\/null\n+++ b\/tests\/gdimagecreate\/CMakeLists.txt\n@@ -0,0 +1,5 @@\n+SET(TESTS_FILES\n+\tbug00340\n+)\n+\n+ADD_GD_TESTS()\ndiff --git a\/tests\/gdimagecreate\/Makemodule.am b\/tests\/gdimagecreate\/Makemodule.am\nnew file mode 100644\nindex 00000000..88660869\n--- \/dev\/null\n+++ b\/tests\/gdimagecreate\/Makemodule.am\n@@ -0,0 +1,5 @@\n+libgd_test_programs += \\\n+\tgdimagecreate\/bug00340\n+\n+EXTRA_DIST += \\\n+\tgdimagecreate\/CMakeLists.txt\ndiff --git a\/tests\/gdimagecreate\/bug00340.c b\/tests\/gdimagecreate\/bug00340.c\nnew file mode 100644\nindex 00000000..5babcaab\n--- \/dev\/null\n+++ b\/tests\/gdimagecreate\/bug00340.c\n@@ -0,0 +1,33 @@\n+\/**\n+ * Regression test for <https:\/\/github.com\/libgd\/libgd\/issues\/340>\n+ *\n+ * We're testing that trying to create an oversized image fails early,\n+ * triggering an appropriate warning.\n+ *\/\n+\n+\n+#include <string.h>\n+#include \"gd.h\"\n+#include \"gd_errors.h\"\n+#include \"gdtest.h\"\n+\n+\n+#define MSG \"product of memory allocation multiplication would exceed INT_MAX, failing operation gracefully\\n\"\n+\n+\n+void error_handler(int priority, const char *format, ...)\n+{\n+    gdTestAssert(priority == GD_WARNING);\n+    gdTestAssert(!strcmp(format, MSG));\n+}\n+\n+\n+int main()\n+{\n+    gdImagePtr im;\n+\n+    im = gdImageCreate(64970, 65111);\n+    gdTestAssert(im == NULL);\n+\n+    return gdNumFailures();\n+}\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2017-12181","CWE_ID":"20","category":"security","commit_id":"1b1d4c04695dced2463404174b50b3581dbd857b","commit_message":"From 1b1d4c04695dced2463404174b50b3581dbd857b Mon Sep 17 00:00:00 2001\nFrom: Nathan Kidd <nkidd@opentext.com>\nDate: Sun, 21 Dec 2014 01:10:03 -0500\nSubject: hw\/xfree86: unvalidated lengths\n\nThis addresses:\nCVE-2017-12180 in XFree86-VidModeExtension\nCVE-2017-12181 in XFree86-DGA\nCVE-2017-12182 in XFree86-DRI\n\nReviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Nathan Kidd <nkidd@opentext.com>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n Xext\/vidmode.c              | 129 ++++++++++++++++++++++++--------------------\n hw\/xfree86\/common\/xf86DGA.c |  81 ++++++++++++++++------------\n hw\/xfree86\/dri\/xf86dri.c    |   1 +\n 3 files changed, 117 insertions(+), 94 deletions(-)\n\n","diff_code":"diff --git a\/Xext\/vidmode.c b\/Xext\/vidmode.c\nindex 8ba919a..6e4a7c7 100644\n--- a\/Xext\/vidmode.c\n+++ b\/Xext\/vidmode.c\n@@ -454,6 +454,20 @@ ProcVidModeAddModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeAddModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeAddModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeAddModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeAddModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeAddModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -501,18 +515,6 @@ ProcVidModeAddModeLine(ClientPtr client)\n            stuff->after_vsyncend, stuff->after_vtotal,\n            (unsigned long) stuff->after_flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeAddModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeAddModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeAddModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeAddModeLineReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -622,6 +624,20 @@ ProcVidModeDeleteModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeDeleteModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeDeleteModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeDeleteModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeDeleteModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeDeleteModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -649,18 +665,6 @@ ProcVidModeDeleteModeLine(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,\n            (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeDeleteModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeDeleteModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeDeleteModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeDeleteModeLineReq));\n-    }\n     if (len != stuff->privsize) {\n         DebugF(\"req_len = %ld, sizeof(Req) = %d, privsize = %ld, \"\n                \"len = %d, length = %d\\n\",\n@@ -744,6 +748,20 @@ ProcVidModeModModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeModModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeModModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeModModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeModModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeModModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -768,18 +786,6 @@ ProcVidModeModModeLine(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend,\n            stuff->vtotal, (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeModModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeModModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeModModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeModModeLineReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -877,6 +883,19 @@ ProcVidModeValidateModeLine(ClientPtr client)\n     DEBUG_P(\"XF86VidModeValidateModeline\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeValidateModeLineReq);\n+        len = client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeValidateModeLineReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeValidateModeLineReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeValidateModeLineReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -905,17 +924,6 @@ ProcVidModeValidateModeLine(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,\n            (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeValidateModeLineReq);\n-        len = client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeValidateModeLineReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeValidateModeLineReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeValidateModeLineReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -1027,6 +1035,20 @@ ProcVidModeSwitchToMode(ClientPtr client)\n     DEBUG_P(\"XF86VidModeSwitchToMode\");\n \n     ver = ClientMajorVersion(client);\n+\n+    if (ver < 2) {\n+        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeSwitchToModeReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86OldVidModeSwitchToModeReq));\n+    }\n+    else {\n+        REQUEST_AT_LEAST_SIZE(xXF86VidModeSwitchToModeReq);\n+        len =\n+            client->req_len -\n+            bytes_to_int32(sizeof(xXF86VidModeSwitchToModeReq));\n+    }\n+\n     if (ver < 2) {\n         \/* convert from old format *\/\n         stuff = &newstuff;\n@@ -1055,18 +1077,6 @@ ProcVidModeSwitchToMode(ClientPtr client)\n            stuff->vdisplay, stuff->vsyncstart, stuff->vsyncend, stuff->vtotal,\n            (unsigned long) stuff->flags);\n \n-    if (ver < 2) {\n-        REQUEST_AT_LEAST_SIZE(xXF86OldVidModeSwitchToModeReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86OldVidModeSwitchToModeReq));\n-    }\n-    else {\n-        REQUEST_AT_LEAST_SIZE(xXF86VidModeSwitchToModeReq);\n-        len =\n-            client->req_len -\n-            bytes_to_int32(sizeof(xXF86VidModeSwitchToModeReq));\n-    }\n     if (len != stuff->privsize)\n         return BadLength;\n \n@@ -1457,6 +1467,7 @@ ProcVidModeSetGammaRamp(ClientPtr client)\n     VidModePtr pVidMode;\n \n     REQUEST(xXF86VidModeSetGammaRampReq);\n+    REQUEST_AT_LEAST_SIZE(xXF86VidModeSetGammaRampReq);\n \n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\ndiff --git a\/hw\/xfree86\/common\/xf86DGA.c b\/hw\/xfree86\/common\/xf86DGA.c\nindex 95434e8..505b019 100644\n--- a\/hw\/xfree86\/common\/xf86DGA.c\n+++ b\/hw\/xfree86\/common\/xf86DGA.c\n@@ -1272,13 +1272,14 @@ ProcXDGAOpenFramebuffer(ClientPtr client)\n     char *deviceName;\n     int nameSize;\n \n+    REQUEST_SIZE_MATCH(xXDGAOpenFramebufferReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n \n-    REQUEST_SIZE_MATCH(xXDGAOpenFramebufferReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1305,14 +1306,14 @@ ProcXDGACloseFramebuffer(ClientPtr client)\n {\n     REQUEST(xXDGACloseFramebufferReq);\n \n+    REQUEST_SIZE_MATCH(xXDGACloseFramebufferReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n \n-    REQUEST_SIZE_MATCH(xXDGACloseFramebufferReq);\n-\n     DGACloseFramebuffer(stuff->screen);\n \n     return Success;\n@@ -1328,10 +1329,11 @@ ProcXDGAQueryModes(ClientPtr client)\n     xXDGAModeInfo info;\n     XDGAModePtr mode;\n \n+    REQUEST_SIZE_MATCH(xXDGAQueryModesReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXDGAQueryModesReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.number = 0;\n@@ -1443,11 +1445,12 @@ ProcXDGASetMode(ClientPtr client)\n     ClientPtr owner;\n     int size;\n \n+    REQUEST_SIZE_MATCH(xXDGASetModeReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n     owner = DGA_GETCLIENT(stuff->screen);\n \n-    REQUEST_SIZE_MATCH(xXDGASetModeReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.offset = 0;\n@@ -1533,14 +1536,14 @@ ProcXDGASetViewport(ClientPtr client)\n {\n     REQUEST(xXDGASetViewportReq);\n \n+    REQUEST_SIZE_MATCH(xXDGASetViewportReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGASetViewportReq);\n-\n     DGASetViewport(stuff->screen, stuff->x, stuff->y, stuff->flags);\n \n     return Success;\n@@ -1554,14 +1557,14 @@ ProcXDGAInstallColormap(ClientPtr client)\n \n     REQUEST(xXDGAInstallColormapReq);\n \n+    REQUEST_SIZE_MATCH(xXDGAInstallColormapReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAInstallColormapReq);\n-\n     rc = dixLookupResourceByType((void **) &cmap, stuff->cmap, RT_COLORMAP,\n                                  client, DixInstallAccess);\n     if (rc != Success)\n@@ -1575,14 +1578,14 @@ ProcXDGASelectInput(ClientPtr client)\n {\n     REQUEST(xXDGASelectInputReq);\n \n+    REQUEST_SIZE_MATCH(xXDGASelectInputReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGASelectInputReq);\n-\n     if (DGA_GETCLIENT(stuff->screen) == client)\n         DGASelectInput(stuff->screen, client, stuff->mask);\n \n@@ -1594,14 +1597,14 @@ ProcXDGAFillRectangle(ClientPtr client)\n {\n     REQUEST(xXDGAFillRectangleReq);\n \n+    REQUEST_SIZE_MATCH(xXDGAFillRectangleReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAFillRectangleReq);\n-\n     if (Success != DGAFillRect(stuff->screen, stuff->x, stuff->y,\n                                stuff->width, stuff->height, stuff->color))\n         return BadMatch;\n@@ -1614,14 +1617,14 @@ ProcXDGACopyArea(ClientPtr client)\n {\n     REQUEST(xXDGACopyAreaReq);\n \n+    REQUEST_SIZE_MATCH(xXDGACopyAreaReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGACopyAreaReq);\n-\n     if (Success != DGABlitRect(stuff->screen, stuff->srcx, stuff->srcy,\n                                stuff->width, stuff->height, stuff->dstx,\n                                stuff->dsty))\n@@ -1635,14 +1638,14 @@ ProcXDGACopyTransparentArea(ClientPtr client)\n {\n     REQUEST(xXDGACopyTransparentAreaReq);\n \n+    REQUEST_SIZE_MATCH(xXDGACopyTransparentAreaReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGACopyTransparentAreaReq);\n-\n     if (Success != DGABlitTransRect(stuff->screen, stuff->srcx, stuff->srcy,\n                                     stuff->width, stuff->height, stuff->dstx,\n                                     stuff->dsty, stuff->key))\n@@ -1657,13 +1660,14 @@ ProcXDGAGetViewportStatus(ClientPtr client)\n     REQUEST(xXDGAGetViewportStatusReq);\n     xXDGAGetViewportStatusReply rep;\n \n+    REQUEST_SIZE_MATCH(xXDGAGetViewportStatusReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAGetViewportStatusReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1680,13 +1684,14 @@ ProcXDGASync(ClientPtr client)\n     REQUEST(xXDGASyncReq);\n     xXDGASyncReply rep;\n \n+    REQUEST_SIZE_MATCH(xXDGASyncReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGASyncReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1725,13 +1730,14 @@ ProcXDGAChangePixmapMode(ClientPtr client)\n     xXDGAChangePixmapModeReply rep;\n     int x, y;\n \n+    REQUEST_SIZE_MATCH(xXDGAChangePixmapModeReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGAChangePixmapModeReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1755,14 +1761,14 @@ ProcXDGACreateColormap(ClientPtr client)\n     REQUEST(xXDGACreateColormapReq);\n     int result;\n \n+    REQUEST_SIZE_MATCH(xXDGACreateColormapReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXDGACreateColormapReq);\n-\n     if (!stuff->mode)\n         return BadValue;\n \n@@ -1791,10 +1797,11 @@ ProcXF86DGAGetVideoLL(ClientPtr client)\n     int num, offset, flags;\n     char *name;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAGetVideoLLReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAGetVideoLLReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1831,9 +1838,10 @@ ProcXF86DGADirectVideo(ClientPtr client)\n \n     REQUEST(xXF86DGADirectVideoReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGADirectVideoReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n-    REQUEST_SIZE_MATCH(xXF86DGADirectVideoReq);\n \n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n@@ -1889,10 +1897,11 @@ ProcXF86DGAGetViewPortSize(ClientPtr client)\n     REQUEST(xXF86DGAGetViewPortSizeReq);\n     xXF86DGAGetViewPortSizeReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAGetViewPortSizeReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAGetViewPortSizeReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1917,14 +1926,14 @@ ProcXF86DGASetViewPort(ClientPtr client)\n {\n     REQUEST(xXF86DGASetViewPortReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGASetViewPortReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXF86DGASetViewPortReq);\n-\n     if (!DGAAvailable(stuff->screen))\n         return DGAErrorBase + XF86DGANoDirectVideoMode;\n \n@@ -1944,10 +1953,11 @@ ProcXF86DGAGetVidPage(ClientPtr client)\n     REQUEST(xXF86DGAGetVidPageReq);\n     xXF86DGAGetVidPageReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAGetVidPageReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAGetVidPageReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -1962,11 +1972,11 @@ ProcXF86DGASetVidPage(ClientPtr client)\n {\n     REQUEST(xXF86DGASetVidPageReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGASetVidPageReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGASetVidPageReq);\n-\n     \/* silently fail *\/\n \n     return Success;\n@@ -1980,14 +1990,14 @@ ProcXF86DGAInstallColormap(ClientPtr client)\n \n     REQUEST(xXF86DGAInstallColormapReq);\n \n+    REQUEST_SIZE_MATCH(xXF86DGAInstallColormapReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAInstallColormapReq);\n-\n     if (!DGAActive(stuff->screen))\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n@@ -2008,10 +2018,11 @@ ProcXF86DGAQueryDirectVideo(ClientPtr client)\n     REQUEST(xXF86DGAQueryDirectVideoReq);\n     xXF86DGAQueryDirectVideoReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAQueryDirectVideoReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAQueryDirectVideoReq);\n     rep.type = X_Reply;\n     rep.length = 0;\n     rep.sequenceNumber = client->sequence;\n@@ -2030,14 +2041,14 @@ ProcXF86DGAViewPortChanged(ClientPtr client)\n     REQUEST(xXF86DGAViewPortChangedReq);\n     xXF86DGAViewPortChangedReply rep;\n \n+    REQUEST_SIZE_MATCH(xXF86DGAViewPortChangedReq);\n+\n     if (stuff->screen >= screenInfo.numScreens)\n         return BadValue;\n \n     if (DGA_GETCLIENT(stuff->screen) != client)\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \n-    REQUEST_SIZE_MATCH(xXF86DGAViewPortChangedReq);\n-\n     if (!DGAActive(stuff->screen))\n         return DGAErrorBase + XF86DGADirectNotActivated;\n \ndiff --git a\/hw\/xfree86\/dri\/xf86dri.c b\/hw\/xfree86\/dri\/xf86dri.c\nindex 8f3c2d6..d356db9 100644\n--- a\/hw\/xfree86\/dri\/xf86dri.c\n+++ b\/hw\/xfree86\/dri\/xf86dri.c\n@@ -570,6 +570,7 @@ static int _X_COLD\n SProcXF86DRIQueryDirectRenderingCapable(register ClientPtr client)\n {\n     REQUEST(xXF86DRIQueryDirectRenderingCapableReq);\n+    REQUEST_SIZE_MATCH(xXF86DRIQueryDirectRenderingCapableReq);\n     swaps(&stuff->length);\n     swapl(&stuff->screen);\n     return ProcXF86DRIQueryDirectRenderingCapable(client);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-4248","CWE_ID":"20","category":"security","commit_id":"2874696a5a8d46639d261571f915c493cd875897","commit_message":"From 2874696a5a8d46639d261571f915c493cd875897 Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Tue, 13 Aug 2013 22:20:33 -0700\nSubject: [PATCH] Fix CVE-2013-4073 - handling of certs with null bytes\n\n---\n NEWS                                |  4 ++\n ext\/openssl\/openssl.c               | 86 ++++++++++++++++++++++++++++++++++++-\n ext\/openssl\/tests\/cve2013_4073.pem  | 28 ++++++++++++\n ext\/openssl\/tests\/cve2013_4073.phpt | 19 ++++++++\n 4 files changed, 135 insertions(+), 2 deletions(-)\n create mode 100644 ext\/openssl\/tests\/cve2013_4073.pem\n create mode 100644 ext\/openssl\/tests\/cve2013_4073.phpt\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex cd9dc91..4b75071 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -101,6 +101,10 @@ PHP                                                                        NEWS\n   . Fixed bug #61387 (NULL valued anonymous column causes segfault in \n     odbc_fetch_array). (Brandon Kirsch)\n \n+- Openssl:\n+  . Fixed handling null bytes in subjectAltName (CVE-2013-4073). \n+    (Christian Heimes)\n+\n - PDO:\n   . Allowed PDO_OCI to compile with Oracle Database 12c client libraries.\n     (Chris Jones)\ndiff --git a\/ext\/openssl\/openssl.c b\/ext\/openssl\/openssl.c\nindex d7ac117..c32748c 100644\n--- a\/ext\/openssl\/openssl.c\n+++ b\/ext\/openssl\/openssl.c\n@@ -1398,6 +1398,74 @@ PHP_FUNCTION(openssl_x509_check_private_key)\n }\n \/* }}} *\/\n \n+\/* Special handling of subjectAltName, see CVE-2013-4073\n+ * Christian Heimes\n+ *\/\n+\n+static int openssl_x509v3_subjectAltName(BIO *bio, X509_EXTENSION *extension)\n+{\n+\tGENERAL_NAMES *names;\n+\tconst X509V3_EXT_METHOD *method = NULL;\n+\tlong i, length, num;\n+\tconst unsigned char *p;\n+\n+\tmethod = X509V3_EXT_get(extension);\n+\tif (method == NULL) {\n+\t\treturn -1;\n+\t}\n+\n+\tp = extension->value->data;\n+\tlength = extension->value->length;\n+\tif (method->it) {\n+\t\tnames = (GENERAL_NAMES*)(ASN1_item_d2i(NULL, &p, length,\n+\t\t\t\t\t\t       ASN1_ITEM_ptr(method->it)));\n+\t} else {\n+\t\tnames = (GENERAL_NAMES*)(method->d2i(NULL, &p, length));\n+\t}\n+\tif (names == NULL) {\n+\t\treturn -1;\n+\t}\n+\n+\tnum = sk_GENERAL_NAME_num(names);\n+\tfor (i = 0; i < num; i++) {\n+\t\t\tGENERAL_NAME *name;\n+\t\t\tASN1_STRING *as;\n+\t\t\tname = sk_GENERAL_NAME_value(names, i);\n+\t\t\tswitch (name->type) {\n+\t\t\t\tcase GEN_EMAIL:\n+\t\t\t\t\tBIO_puts(bio, \"email:\");\n+\t\t\t\t\tas = name->d.rfc822Name;\n+\t\t\t\t\tBIO_write(bio, ASN1_STRING_data(as),\n+\t\t\t\t\t\t  ASN1_STRING_length(as));\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase GEN_DNS:\n+\t\t\t\t\tBIO_puts(bio, \"DNS:\");\n+\t\t\t\t\tas = name->d.dNSName;\n+\t\t\t\t\tBIO_write(bio, ASN1_STRING_data(as),\n+\t\t\t\t\t\t  ASN1_STRING_length(as));\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase GEN_URI:\n+\t\t\t\t\tBIO_puts(bio, \"URI:\");\n+\t\t\t\t\tas = name->d.uniformResourceIdentifier;\n+\t\t\t\t\tBIO_write(bio, ASN1_STRING_data(as),\n+\t\t\t\t\t\t  ASN1_STRING_length(as));\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\t\/* use builtin print for GEN_OTHERNAME, GEN_X400,\n+\t\t\t\t\t * GEN_EDIPARTY, GEN_DIRNAME, GEN_IPADD and GEN_RID\n+\t\t\t\t\t *\/\n+\t\t\t\t\tGENERAL_NAME_print(bio, name);\n+\t\t\t}\n+\t\t\t\/* trailing ', ' except for last element *\/\n+\t\t\tif (i < (num - 1)) {\n+\t\t\t\tBIO_puts(bio, \", \");\n+\t\t\t}\n+\t}\n+\tsk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);\n+\n+\treturn 0;\n+}\n+\n \/* {{{ proto array openssl_x509_parse(mixed x509 [, bool shortnames=true])\n    Returns an array of the fields\/values of the CERT *\/\n PHP_FUNCTION(openssl_x509_parse)\n@@ -1494,15 +1562,29 @@ PHP_FUNCTION(openssl_x509_parse)\n \n \n \tfor (i = 0; i < X509_get_ext_count(cert); i++) {\n+\t\tint nid;\n \t\textension = X509_get_ext(cert, i);\n-\t\tif (OBJ_obj2nid(X509_EXTENSION_get_object(extension)) != NID_undef) {\n+\t\tnid = OBJ_obj2nid(X509_EXTENSION_get_object(extension));\n+\t\tif (nid != NID_undef) {\n \t\t\textname = (char *)OBJ_nid2sn(OBJ_obj2nid(X509_EXTENSION_get_object(extension)));\n \t\t} else {\n \t\t\tOBJ_obj2txt(buf, sizeof(buf)-1, X509_EXTENSION_get_object(extension), 1);\n \t\t\textname = buf;\n \t\t}\n \t\tbio_out = BIO_new(BIO_s_mem());\n-\t\tif (X509V3_EXT_print(bio_out, extension, 0, 0)) {\n+\t\tif (nid == NID_subject_alt_name) {\n+\t\t\tif (openssl_x509v3_subjectAltName(bio_out, extension) == 0) {\n+\t\t\t\tadd_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);\n+\t\t\t} else {\n+\t\t\t\tzval_dtor(return_value);\n+\t\t\t\tif (certresource == -1 && cert) {\n+\t\t\t\t\tX509_free(cert);\n+\t\t\t\t}\n+\t\t\t\tBIO_free(bio_out);\n+\t\t\t\tRETURN_FALSE;\n+\t\t\t}\n+\t\t}\n+\t\telse if (X509V3_EXT_print(bio_out, extension, 0, 0)) {\n \t\t\tBIO_get_mem_ptr(bio_out, &bio_buf);\n \t\t\tadd_assoc_stringl(subitem, extname, bio_buf->data, bio_buf->length, 1);\n \t\t} else {\ndiff --git a\/ext\/openssl\/tests\/cve2013_4073.pem b\/ext\/openssl\/tests\/cve2013_4073.pem\nnew file mode 100644\nindex 0000000..7ebb994\n--- \/dev\/null\n+++ b\/ext\/openssl\/tests\/cve2013_4073.pem\n@@ -0,0 +1,28 @@\n+-----BEGIN CERTIFICATE-----\n+MIIE2DCCA8CgAwIBAgIBADANBgkqhkiG9w0BAQUFADCBxTELMAkGA1UEBhMCVVMx\n+DzANBgNVBAgMBk9yZWdvbjESMBAGA1UEBwwJQmVhdmVydG9uMSMwIQYDVQQKDBpQ\n+eXRob24gU29mdHdhcmUgRm91bmRhdGlvbjEgMB4GA1UECwwXUHl0aG9uIENvcmUg\n+RGV2ZWxvcG1lbnQxJDAiBgNVBAMMG251bGwucHl0aG9uLm9yZwBleGFtcGxlLm9y\n+ZzEkMCIGCSqGSIb3DQEJARYVcHl0aG9uLWRldkBweXRob24ub3JnMB4XDTEzMDgw\n+NzEzMTE1MloXDTEzMDgwNzEzMTI1MlowgcUxCzAJBgNVBAYTAlVTMQ8wDQYDVQQI\n+DAZPcmVnb24xEjAQBgNVBAcMCUJlYXZlcnRvbjEjMCEGA1UECgwaUHl0aG9uIFNv\n+ZnR3YXJlIEZvdW5kYXRpb24xIDAeBgNVBAsMF1B5dGhvbiBDb3JlIERldmVsb3Bt\n+ZW50MSQwIgYDVQQDDBtudWxsLnB5dGhvbi5vcmcAZXhhbXBsZS5vcmcxJDAiBgkq\n+hkiG9w0BCQEWFXB5dGhvbi1kZXZAcHl0aG9uLm9yZzCCASIwDQYJKoZIhvcNAQEB\n+BQADggEPADCCAQoCggEBALXq7cn7Rn1vO3aA3TrzA5QLp6bb7B3f\/yN0CJ2XFj+j\n+pHs+Gw6WWSUDpybiiKnPec33BFawq3kyblnBMjBU61ioy5HwQqVkJ8vUVjGIUq3P\n+vX\/wBmQfzCe4o4uM89gpHyUL9UYGG8oCRa17dgqcv7u5rg0Wq2B1rgY+nHwx3JIv\n+KRrgSwyRkGzpN8WQ1yrXlxWjgI9de0mPVDDUlywcWze1q2kwaEPTM3hLAmD1PESA\n+oY\/n8A\/RXoeeRs9i\/Pm\/DGUS8ZPINXk\/yOzsR\/XvvkTVroIeLZqfmFpnZeF0cHzL\n+08LODkVJJ9zjLdT7SA4vnne4FEbAxDbKAq5qkYzaL4UCAwEAAaOB0DCBzTAMBgNV\n+HRMBAf8EAjAAMB0GA1UdDgQWBBSIWlXAUv9hzVKjNQ\/qWpwkOCL3XDALBgNVHQ8E\n+BAMCBeAwgZAGA1UdEQSBiDCBhYIeYWx0bnVsbC5weXRob24ub3JnAGV4YW1wbGUu\n+Y29tgSBudWxsQHB5dGhvbi5vcmcAdXNlckBleGFtcGxlLm9yZ4YpaHR0cDovL251\n+bGwucHl0aG9uLm9yZwBodHRwOi8vZXhhbXBsZS5vcmeHBMAAAgGHECABDbgAAAAA\n+AAAAAAAAAAEwDQYJKoZIhvcNAQEFBQADggEBAKxPRe99SaghcI6IWT7UNkJw9aO9\n+i9eo0Fj2MUqxpKbdb9noRDy2CnHWf7EIYZ1gznXPdwzSN4YCjV5d+Q9xtBaowT0j\n+HPERs1ZuytCNNJTmhyqZ8q6uzMLoht4IqH\/FBfpvgaeC5tBTnTT0rD5A\/olXeimk\n+kX4LxlEx5RAvpGB2zZVRGr6LobD9rVK91xuHYNIxxxfEGE8tCCWjp0+3ksri9SXx\n+VHWBnbM9YaL32u3hxm8sYB\/Yb8WSBavJCWJJqRStVRHM1koZlJmXNx2BX4vPo6iW\n+RFEIPQsFZRLrtnCAiEhyT8bC2s\/Njlu6ly9gtJZWSV46Q3ZjBL4q9sHKqZQ=\n+-----END CERTIFICATE-----\ndiff --git a\/ext\/openssl\/tests\/cve2013_4073.phpt b\/ext\/openssl\/tests\/cve2013_4073.phpt\nnew file mode 100644\nindex 0000000..e676ddf\n--- \/dev\/null\n+++ b\/ext\/openssl\/tests\/cve2013_4073.phpt\n@@ -0,0 +1,19 @@\n+--TEST--\n+CVE 2013-4073: Null-byte certificate handling\n+--SKIPIF--\n+<?php \n+if (!extension_loaded(\"openssl\")) die(\"skip\");\n+--FILE--\n+<?php\n+$cert = file_get_contents(__DIR__ . '\/cve2013_4073.pem');\n+$info = openssl_x509_parse($cert);\n+var_export($info['extensions']);\n+\n+--EXPECTF--\n+array (\n+  'basicConstraints' => 'CA:FALSE',\n+  'subjectKeyIdentifier' => '88:5A:55:C0:52:FF:61:CD:52:A3:35:0F:EA:5A:9C:24:38:22:F7:5C',\n+  'keyUsage' => 'Digital Signature, Non Repudiation, Key Encipherment',\n+  'subjectAltName' => 'DNS:altnull.python.org' . \"\\0\" . 'example.com, email:null@python.org' . \"\\0\" . 'user@example.org, URI:http:\/\/null.python.org' . \"\\0\" . 'http:\/\/example.org, IP Address:192.0.2.1, IP Address:2001:DB8:0:0:0:0:0:1\n+',\n+)\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5590","CWE_ID":"20","category":"security","commit_id":"a340b4bb519227d89f85f2716a10a197a65d4856","commit_message":"From a340b4bb519227d89f85f2716a10a197a65d4856 Mon Sep 17 00:00:00 2001\nFrom: David Chiles <david@davidchiles.org>\nDate: Mon, 23 Jan 2017 13:16:45 -0800\nSubject: [PATCH] Changed to using carbon module delegate methods\n\n---\n ...\/Classes\/Controllers\/XMPP\/OTRXMPPManager.m |  9 ++---\n ...\/XMPP\/OTRXMPPMessageYapStroage.h           |  1 +\n ...\/XMPP\/OTRXMPPMessageYapStroage.m           | 35 +++++++++----------\n 3 files changed, 22 insertions(+), 23 deletions(-)\n\n","diff_code":"diff --git a\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPManager.m b\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPManager.m\nindex 8e266f2cd..c16770cce 100644\n--- a\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPManager.m\n+++ b\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPManager.m\n@@ -219,14 +219,15 @@ - (void)setupStream\n     [self.xmppCapabilities addDelegate:self delegateQueue:self.workQueue];\n     [self.xmppvCardTempModule addDelegate:self delegateQueue:self.workQueue];\n     \n-    \/\/ Message Carbons\n-    _messageCarbons = [[XMPPMessageCarbons alloc] init];\n-    [self.messageCarbons activate:self.xmppStream];\n-    \n     \/\/ Message storage\n     _messageStorage = [[OTRXMPPMessageYapStroage alloc] initWithDatabaseConnection:self.databaseConnection];\n     [self.messageStorage activate:self.xmppStream];\n     \n+    \/\/ Message Carbons\n+    _messageCarbons = [[XMPPMessageCarbons alloc] init];\n+    [self.messageCarbons addDelegate:self.messageStorage delegateQueue:self.messageStorage.moduleDelegateQueue];\n+    [self.messageCarbons activate:self.xmppStream];\n+    \n     \/\/Stream Management\n     _streamManagementDelegate = [[OTRStreamManagementDelegate alloc] initWithDatabaseConnection:self.databaseConnection];\n     \ndiff --git a\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPMessageYapStroage.h b\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPMessageYapStroage.h\nindex 8c161edf8..b372fead1 100644\n--- a\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPMessageYapStroage.h\n+++ b\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPMessageYapStroage.h\n@@ -14,6 +14,7 @@ NS_ASSUME_NONNULL_BEGIN\n @interface OTRXMPPMessageYapStroage : XMPPModule\n \n @property (nonatomic, strong, readonly) YapDatabaseConnection *databaseConnection;\n+@property (nonatomic, readonly) dispatch_queue_t moduleDelegateQueue;\n \n \/** This connection is only used for readWrites *\/\n - (instancetype)initWithDatabaseConnection:(YapDatabaseConnection *)databaseConnection;\ndiff --git a\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPMessageYapStroage.m b\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPMessageYapStroage.m\nindex 5c649250f..d00fa0d59 100644\n--- a\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPMessageYapStroage.m\n+++ b\/ChatSecure\/Classes\/Controllers\/XMPP\/OTRXMPPMessageYapStroage.m\n@@ -25,23 +25,11 @@ - (instancetype)initWithDatabaseConnection:(YapDatabaseConnection *)connection\n {\n     if (self = [self init]) {\n         _databaseConnection = connection;\n+        _moduleDelegateQueue = dispatch_queue_create(\"OTRXMPPMessageYapStroage-delegateQueue\", 0);\n     }\n     return self;\n }\n \n-- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)xmppMessage\n-{\n-    [self storeMessage:xmppMessage stream:sender incoming:YES];\n-}\n-\n-- (void)storeMessage:(XMPPMessage *)xmppMessage stream:(XMPPStream *)stream incoming:(BOOL)incoming\n-{\n-    if ([xmppMessage isMessageCarbon]) {\n-        [self handleCarbonMessage:xmppMessage stream:stream];\n-    } else {\n-        [self handleMessage:xmppMessage stream:stream incoming:incoming];\n-    }\n-}\n \n - (OTRXMPPBuddy *)buddyForUsername:(NSString *)username stream:(XMPPStream *)stream transaction:(YapDatabaseReadTransaction *)transaction\n {\n@@ -76,7 +64,7 @@ - (OTRIncomingMessage *)incomingMessageFromXMPPMessage:(XMPPMessage *)xmppMessag\n     return (OTRIncomingMessage *)[self baseMessageFromXMPPMessage:xmppMessage buddyId:buddyId class:[OTRIncomingMessage class]];\n }\n \n-- (void)handleMessage:(XMPPMessage *)xmppMessage stream:(XMPPStream *)stream incoming:(BOOL)incoming;\n+- (void)xmppStream:(XMPPStream *)stream didReceiveMessage:(XMPPMessage *)xmppMessage\n {\n     \/\/ We don't handle incoming group chat messages here\n     \/\/ Check out OTRXMPPRoomYapStorage instead\n@@ -86,6 +74,10 @@ - (void)handleMessage:(XMPPMessage *)xmppMessage stream:(XMPPStream *)stream inc\n         return;\n     }\n     \n+    if ([xmppMessage isMessageCarbon]) {\n+        return;\n+    }\n+    \n     [self.databaseConnection asyncReadWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {\n         if ([stream.tag isKindOfClass:[NSString class]]) {\n             NSString *username = [[xmppMessage from] bare];\n@@ -184,18 +176,16 @@ - (BOOL)duplicateMessage:(XMPPMessage *)message buddyUniqueId:(NSString *)buddyU\n     return result;\n }\n \n-- (void)handleCarbonMessage:(XMPPMessage *)xmppMessage stream:(XMPPStream *)stream\n+- (void)handleCarbonMessage:(XMPPMessage *)forwardedMessage stream:(XMPPStream *)stream outgoing:(BOOL)isOutgoing\n {\n     \/\/Sent Message Carbons are sent by our account to another\n     \/\/So from is our JID and to is buddy\n-    BOOL incoming = NO;\n-    XMPPMessage *forwardedMessage = [xmppMessage messageCarbonForwardedMessage];\n+    BOOL incoming = !isOutgoing;\n     \n     \n     NSString *username = nil;\n-    if ([xmppMessage isReceivedMessageCarbon]) {\n+    if (incoming) {\n         username = [[forwardedMessage from] bare];\n-        incoming = YES;\n     } else {\n         username = [[forwardedMessage to] bare];\n     }\n@@ -230,4 +220,11 @@ - (void)handleCarbonMessage:(XMPPMessage *)xmppMessage stream:(XMPPStream *)stre\n     }];\n }\n \n+#pragma - mark XMPPMessageCarbonsDelegate\n+\n+- (void)xmppMessageCarbons:(XMPPMessageCarbons *)xmppMessageCarbons didReceiveMessage:(XMPPMessage *)message outgoing:(BOOL)isOutgoing\n+{\n+    [self handleCarbonMessage:message stream:xmppMessageCarbons.xmppStream outgoing:isOutgoing];\n+}\n+\n @end\n","owner":"ChatSecure","repo":"ChatSecure-iOS","source":"cve"},{"CVE_ID":"CVE-2014-3645","CWE_ID":"20","category":"security","commit_id":"bfd0a56b90005f8c8a004baf407ad90045c2b11e","commit_message":"From bfd0a56b90005f8c8a004baf407ad90045c2b11e Mon Sep 17 00:00:00 2001\nFrom: Nadav Har'El <nyh@il.ibm.com>\nDate: Mon, 5 Aug 2013 11:07:17 +0300\nSubject: nEPT: Nested INVEPT\n\nIf we let L1 use EPT, we should probably also support the INVEPT instruction.\n\nIn our current nested EPT implementation, when L1 changes its EPT table\nfor L2 (i.e., EPT12), L0 modifies the shadow EPT table (EPT02), and in\nthe course of this modification already calls INVEPT. But if last level\nof shadow page is unsync not all L1's changes to EPT12 are intercepted,\nwhich means roots need to be synced when L1 calls INVEPT. Global INVEPT\nshould not be different since roots are synced by kvm_mmu_load() each\ntime EPTP02 changes.\n\nReviewed-by: Xiao Guangrong <xiaoguangrong@linux.vnet.ibm.com>\nSigned-off-by: Nadav Har'El <nyh@il.ibm.com>\nSigned-off-by: Jun Nakajima <jun.nakajima@intel.com>\nSigned-off-by: Xinhao Xu <xinhao.xu@intel.com>\nSigned-off-by: Yang Zhang <yang.z.zhang@Intel.com>\nSigned-off-by: Gleb Natapov <gleb@redhat.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/include\/asm\/vmx.h      |  2 ++\n arch\/x86\/include\/uapi\/asm\/vmx.h |  1 +\n arch\/x86\/kvm\/mmu.c              |  2 ++\n arch\/x86\/kvm\/vmx.c              | 72 +++++++++++++++++++++++++++++++++++++++++\n 4 files changed, 77 insertions(+)\n\n","diff_code":"diff --git a\/arch\/x86\/include\/asm\/vmx.h b\/arch\/x86\/include\/asm\/vmx.h\nindex f3e01a2cbaa1..966502d4682e 100644\n--- a\/arch\/x86\/include\/asm\/vmx.h\n+++ b\/arch\/x86\/include\/asm\/vmx.h\n@@ -387,6 +387,7 @@ enum vmcs_field {\n #define VMX_EPT_EXTENT_INDIVIDUAL_ADDR\t\t0\n #define VMX_EPT_EXTENT_CONTEXT\t\t\t1\n #define VMX_EPT_EXTENT_GLOBAL\t\t\t2\n+#define VMX_EPT_EXTENT_SHIFT\t\t\t24\n \n #define VMX_EPT_EXECUTE_ONLY_BIT\t\t(1ull)\n #define VMX_EPT_PAGE_WALK_4_BIT\t\t\t(1ull << 6)\n@@ -394,6 +395,7 @@ enum vmcs_field {\n #define VMX_EPTP_WB_BIT\t\t\t\t(1ull << 14)\n #define VMX_EPT_2MB_PAGE_BIT\t\t\t(1ull << 16)\n #define VMX_EPT_1GB_PAGE_BIT\t\t\t(1ull << 17)\n+#define VMX_EPT_INVEPT_BIT\t\t\t(1ull << 20)\n #define VMX_EPT_AD_BIT\t\t\t\t    (1ull << 21)\n #define VMX_EPT_EXTENT_CONTEXT_BIT\t\t(1ull << 25)\n #define VMX_EPT_EXTENT_GLOBAL_BIT\t\t(1ull << 26)\ndiff --git a\/arch\/x86\/include\/uapi\/asm\/vmx.h b\/arch\/x86\/include\/uapi\/asm\/vmx.h\nindex d651082c7cf7..7a34e8fe54bd 100644\n--- a\/arch\/x86\/include\/uapi\/asm\/vmx.h\n+++ b\/arch\/x86\/include\/uapi\/asm\/vmx.h\n@@ -65,6 +65,7 @@\n #define EXIT_REASON_EOI_INDUCED         45\n #define EXIT_REASON_EPT_VIOLATION       48\n #define EXIT_REASON_EPT_MISCONFIG       49\n+#define EXIT_REASON_INVEPT              50\n #define EXIT_REASON_PREEMPTION_TIMER    52\n #define EXIT_REASON_WBINVD              54\n #define EXIT_REASON_XSETBV              55\ndiff --git a\/arch\/x86\/kvm\/mmu.c b\/arch\/x86\/kvm\/mmu.c\nindex 992fde984e25..9651c9937588 100644\n--- a\/arch\/x86\/kvm\/mmu.c\n+++ b\/arch\/x86\/kvm\/mmu.c\n@@ -3182,6 +3182,7 @@ void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n \tmmu_sync_roots(vcpu);\n \tspin_unlock(&vcpu->kvm->mmu_lock);\n }\n+EXPORT_SYMBOL_GPL(kvm_mmu_sync_roots);\n \n static gpa_t nonpaging_gva_to_gpa(struct kvm_vcpu *vcpu, gva_t vaddr,\n \t\t\t\t  u32 access, struct x86_exception *exception)\n@@ -3451,6 +3452,7 @@ void kvm_mmu_flush_tlb(struct kvm_vcpu *vcpu)\n \t++vcpu->stat.tlb_flush;\n \tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n }\n+EXPORT_SYMBOL_GPL(kvm_mmu_flush_tlb);\n \n static void paging_new_cr3(struct kvm_vcpu *vcpu)\n {\ndiff --git a\/arch\/x86\/kvm\/vmx.c b\/arch\/x86\/kvm\/vmx.c\nindex 2ae0aa4461e8..5129ba3766c4 100644\n--- a\/arch\/x86\/kvm\/vmx.c\n+++ b\/arch\/x86\/kvm\/vmx.c\n@@ -712,6 +712,7 @@ static void nested_release_page_clean(struct page *page)\n \tkvm_release_page_clean(page);\n }\n \n+static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\n static u64 construct_eptp(unsigned long root_hpa);\n static void kvm_cpu_vmxon(u64 addr);\n static void kvm_cpu_vmxoff(void);\n@@ -2161,6 +2162,7 @@ static u32 nested_vmx_pinbased_ctls_low, nested_vmx_pinbased_ctls_high;\n static u32 nested_vmx_exit_ctls_low, nested_vmx_exit_ctls_high;\n static u32 nested_vmx_entry_ctls_low, nested_vmx_entry_ctls_high;\n static u32 nested_vmx_misc_low, nested_vmx_misc_high;\n+static u32 nested_vmx_ept_caps;\n static __init void nested_vmx_setup_ctls_msrs(void)\n {\n \t\/*\n@@ -6279,6 +6281,74 @@ static int handle_vmptrst(struct kvm_vcpu *vcpu)\n \treturn 1;\n }\n \n+\/* Emulate the INVEPT instruction *\/\n+static int handle_invept(struct kvm_vcpu *vcpu)\n+{\n+\tu32 vmx_instruction_info, types;\n+\tunsigned long type;\n+\tgva_t gva;\n+\tstruct x86_exception e;\n+\tstruct {\n+\t\tu64 eptp, gpa;\n+\t} operand;\n+\tu64 eptp_mask = ((1ull << 51) - 1) & PAGE_MASK;\n+\n+\tif (!(nested_vmx_secondary_ctls_high & SECONDARY_EXEC_ENABLE_EPT) ||\n+\t    !(nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n+\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n+\t\treturn 1;\n+\t}\n+\n+\tif (!nested_vmx_check_permission(vcpu))\n+\t\treturn 1;\n+\n+\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n+\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n+\t\treturn 1;\n+\t}\n+\n+\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n+\ttype = kvm_register_read(vcpu, (vmx_instruction_info >> 28) & 0xf);\n+\n+\ttypes = (nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n+\n+\tif (!(types & (1UL << type))) {\n+\t\tnested_vmx_failValid(vcpu,\n+\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n+\t\treturn 1;\n+\t}\n+\n+\t\/* According to the Intel VMX instruction reference, the memory\n+\t * operand is read even if it isn't needed (e.g., for type==global)\n+\t *\/\n+\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n+\t\t\tvmx_instruction_info, &gva))\n+\t\treturn 1;\n+\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n+\t\t\t\tsizeof(operand), &e)) {\n+\t\tkvm_inject_page_fault(vcpu, &e);\n+\t\treturn 1;\n+\t}\n+\n+\tswitch (type) {\n+\tcase VMX_EPT_EXTENT_CONTEXT:\n+\t\tif ((operand.eptp & eptp_mask) !=\n+\t\t\t\t(nested_ept_get_cr3(vcpu) & eptp_mask))\n+\t\t\tbreak;\n+\tcase VMX_EPT_EXTENT_GLOBAL:\n+\t\tkvm_mmu_sync_roots(vcpu);\n+\t\tkvm_mmu_flush_tlb(vcpu);\n+\t\tnested_vmx_succeed(vcpu);\n+\t\tbreak;\n+\tdefault:\n+\t\tBUG_ON(1);\n+\t\tbreak;\n+\t}\n+\n+\tskip_emulated_instruction(vcpu);\n+\treturn 1;\n+}\n+\n \/*\n  * The exit handlers return 1 if the exit was handled fully and guest execution\n  * may resume.  Otherwise they set the kvm_run parameter to indicate what needs\n@@ -6323,6 +6393,7 @@ static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n \t[EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,\n \t[EXIT_REASON_MWAIT_INSTRUCTION]\t      = handle_invalid_op,\n \t[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,\n+\t[EXIT_REASON_INVEPT]                  = handle_invept,\n };\n \n static const int kvm_vmx_max_exit_handlers =\n@@ -6549,6 +6620,7 @@ static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)\n \tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:\n \tcase EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:\n \tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n+\tcase EXIT_REASON_INVEPT:\n \t\t\/*\n \t\t * VMX instructions trap unconditionally. This allows L1 to\n \t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-0726","CWE_ID":"20","category":"security","commit_id":"5883f57ca0008ffc93e09cbb9847a1928e50c6f3","commit_message":"From 5883f57ca0008ffc93e09cbb9847a1928e50c6f3 Mon Sep 17 00:00:00 2001\nFrom: Kees Cook <kees.cook@canonical.com>\nDate: Wed, 23 Mar 2011 16:42:53 -0700\nSubject: proc: protect mm start_code\/end_code in \/proc\/pid\/stat\n\nWhile mm->start_stack was protected from cross-uid viewing (commit\nf83ce3e6b02d5 (\"proc: avoid information leaks to non-privileged\nprocesses\")), the start_code and end_code values were not.  This would\nallow the text location of a PIE binary to leak, defeating ASLR.\n\nNote that the value \"1\" is used instead of \"0\" for a protected value since\n\"ps\", \"killall\", and likely other readers of \/proc\/pid\/stat, take\nstart_code of \"0\" to mean a kernel thread and will misbehave.  Thanks to\nBrad Spengler for pointing this out.\n\nAddresses CVE-2011-0726\n\nSigned-off-by: Kees Cook <kees.cook@canonical.com>\nCc: <stable@kernel.org>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: David Howells <dhowells@redhat.com>\nCc: Eugene Teo <eugeneteo@kernel.sg>\nCc: Martin Schwidefsky <schwidefsky@de.ibm.com>\nCc: Brad Spengler <spender@grsecurity.net>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/proc\/array.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/proc\/array.c b\/fs\/proc\/array.c\nindex 7c99c1cf7e5c..5e4f776b0917 100644\n--- a\/fs\/proc\/array.c\n+++ b\/fs\/proc\/array.c\n@@ -489,8 +489,8 @@ static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,\n \t\tvsize,\n \t\tmm ? get_mm_rss(mm) : 0,\n \t\trsslim,\n-\t\tmm ? mm->start_code : 0,\n-\t\tmm ? mm->end_code : 0,\n+\t\tmm ? (permitted ? mm->start_code : 1) : 0,\n+\t\tmm ? (permitted ? mm->end_code : 1) : 0,\n \t\t(permitted && mm) ? mm->start_stack : 0,\n \t\tesp,\n \t\teip,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-8650","CWE_ID":"20","category":"security","commit_id":"f5527fffff3f002b0a6b376163613b82f69de073","commit_message":"From f5527fffff3f002b0a6b376163613b82f69de073 Mon Sep 17 00:00:00 2001\nFrom: Andrey Ryabinin <aryabinin@virtuozzo.com>\nDate: Thu, 24 Nov 2016 13:23:10 +0000\nSubject: mpi: Fix NULL ptr dereference in mpi_powm() [ver #3]\n\nThis fixes CVE-2016-8650.\n\nIf mpi_powm() is given a zero exponent, it wants to immediately return\neither 1 or 0, depending on the modulus.  However, if the result was\ninitalised with zero limb space, no limbs space is allocated and a\nNULL-pointer exception ensues.\n\nFix this by allocating a minimal amount of limb space for the result when\nthe 0-exponent case when the result is 1 and not touching the limb space\nwhen the result is 0.\n\nThis affects the use of RSA keys and X.509 certificates that carry them.\n\nBUG: unable to handle kernel NULL pointer dereference at           (null)\nIP: [<ffffffff8138ce5d>] mpi_powm+0x32\/0x7e6\nPGD 0\nOops: 0002 [#1] SMP\nModules linked in:\nCPU: 3 PID: 3014 Comm: keyctl Not tainted 4.9.0-rc6-fscache+ #278\nHardware name: ASUS All Series\/H97-PLUS, BIOS 2306 10\/09\/2014\ntask: ffff8804011944c0 task.stack: ffff880401294000\nRIP: 0010:[<ffffffff8138ce5d>]  [<ffffffff8138ce5d>] mpi_powm+0x32\/0x7e6\nRSP: 0018:ffff880401297ad8  EFLAGS: 00010212\nRAX: 0000000000000000 RBX: ffff88040868bec0 RCX: ffff88040868bba0\nRDX: ffff88040868b260 RSI: ffff88040868bec0 RDI: ffff88040868bee0\nRBP: ffff880401297ba8 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000047 R11: ffffffff8183b210 R12: 0000000000000000\nR13: ffff8804087c7600 R14: 000000000000001f R15: ffff880401297c50\nFS:  00007f7a7918c700(0000) GS:ffff88041fb80000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000000 CR3: 0000000401250000 CR4: 00000000001406e0\nStack:\n ffff88040868bec0 0000000000000020 ffff880401297b00 ffffffff81376cd4\n 0000000000000100 ffff880401297b10 ffffffff81376d12 ffff880401297b30\n ffffffff81376f37 0000000000000100 0000000000000000 ffff880401297ba8\nCall Trace:\n [<ffffffff81376cd4>] ? __sg_page_iter_next+0x43\/0x66\n [<ffffffff81376d12>] ? sg_miter_get_next_page+0x1b\/0x5d\n [<ffffffff81376f37>] ? sg_miter_next+0x17\/0xbd\n [<ffffffff8138ba3a>] ? mpi_read_raw_from_sgl+0xf2\/0x146\n [<ffffffff8132a95c>] rsa_verify+0x9d\/0xee\n [<ffffffff8132acca>] ? pkcs1pad_sg_set_buf+0x2e\/0xbb\n [<ffffffff8132af40>] pkcs1pad_verify+0xc0\/0xe1\n [<ffffffff8133cb5e>] public_key_verify_signature+0x1b0\/0x228\n [<ffffffff8133d974>] x509_check_for_self_signed+0xa1\/0xc4\n [<ffffffff8133cdde>] x509_cert_parse+0x167\/0x1a1\n [<ffffffff8133d609>] x509_key_preparse+0x21\/0x1a1\n [<ffffffff8133c3d7>] asymmetric_key_preparse+0x34\/0x61\n [<ffffffff812fc9f3>] key_create_or_update+0x145\/0x399\n [<ffffffff812fe227>] SyS_add_key+0x154\/0x19e\n [<ffffffff81001c2b>] do_syscall_64+0x80\/0x191\n [<ffffffff816825e4>] entry_SYSCALL64_slow_path+0x25\/0x25\nCode: 56 41 55 41 54 53 48 81 ec a8 00 00 00 44 8b 71 04 8b 42 04 4c 8b 67 18 45 85 f6 89 45 80 0f 84 b4 06 00 00 85 c0 75 2f 41 ff ce <49> c7 04 24 01 00 00 00 b0 01 75 0b 48 8b 41 18 48 83 38 01 0f\nRIP  [<ffffffff8138ce5d>] mpi_powm+0x32\/0x7e6\n RSP <ffff880401297ad8>\nCR2: 0000000000000000\n---[ end trace d82015255d4a5d8d ]---\n\nBasically, this is a backport of a libgcrypt patch:\n\n\thttp:\/\/git.gnupg.org\/cgi-bin\/gitweb.cgi?p=libgcrypt.git;a=patch;h=6e1adb05d290aeeb1c230c763970695f4a538526\n\nFixes: cdec9cb5167a (\"crypto: GnuPG based MPI lib - source files (part 1)\")\nSigned-off-by: Andrey Ryabinin <aryabinin@virtuozzo.com>\nSigned-off-by: David Howells <dhowells@redhat.com>\ncc: Dmitry Kasatkin <dmitry.kasatkin@gmail.com>\ncc: linux-ima-devel@lists.sourceforge.net\ncc: stable@vger.kernel.org\nSigned-off-by: James Morris <james.l.morris@oracle.com>\n---\n lib\/mpi\/mpi-pow.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/lib\/mpi\/mpi-pow.c b\/lib\/mpi\/mpi-pow.c\nindex 5464c8744ea9..e24388a863a7 100644\n--- a\/lib\/mpi\/mpi-pow.c\n+++ b\/lib\/mpi\/mpi-pow.c\n@@ -64,8 +64,13 @@ int mpi_powm(MPI res, MPI base, MPI exp, MPI mod)\n \tif (!esize) {\n \t\t\/* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0\n \t\t * depending on if MOD equals 1.  *\/\n-\t\trp[0] = 1;\n \t\tres->nlimbs = (msize == 1 && mod->d[0] == 1) ? 0 : 1;\n+\t\tif (res->nlimbs) {\n+\t\t\tif (mpi_resize(res, 1) < 0)\n+\t\t\t\tgoto enomem;\n+\t\t\trp = res->d;\n+\t\t\trp[0] = 1;\n+\t\t}\n \t\tres->sign = 0;\n \t\tgoto leave;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-6282","CWE_ID":"20","category":"security","commit_id":"8404663f81d212918ff85f493649a7991209fa04","commit_message":"From 8404663f81d212918ff85f493649a7991209fa04 Mon Sep 17 00:00:00 2001\nFrom: Russell King <rmk+kernel@arm.linux.org.uk>\nDate: Fri, 7 Sep 2012 18:22:28 +0100\nSubject: ARM: 7527\/1: uaccess: explicitly check __user pointer when\n !CPU_USE_DOMAINS\n\nThe {get,put}_user macros don't perform range checking on the provided\n__user address when !CPU_HAS_DOMAINS.\n\nThis patch reworks the out-of-line assembly accessors to check the user\naddress against a specified limit, returning -EFAULT if is is out of\nrange.\n\n[will: changed get_user register allocation to match put_user]\n[rmk: fixed building on older ARM architectures]\n\nReported-by: Catalin Marinas <catalin.marinas@arm.com>\nSigned-off-by: Will Deacon <will.deacon@arm.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Russell King <rmk+kernel@arm.linux.org.uk>\n---\n arch\/arm\/include\/asm\/assembler.h |  8 ++++++++\n arch\/arm\/include\/asm\/uaccess.h   | 40 +++++++++++++++++++++++++++-------------\n arch\/arm\/lib\/getuser.S           | 23 +++++++++++++++--------\n arch\/arm\/lib\/putuser.S           |  6 ++++++\n 4 files changed, 56 insertions(+), 21 deletions(-)\n\n","diff_code":"diff --git a\/arch\/arm\/include\/asm\/assembler.h b\/arch\/arm\/include\/asm\/assembler.h\nindex 03fb93621d0d..5c8b3bf4d825 100644\n--- a\/arch\/arm\/include\/asm\/assembler.h\n+++ b\/arch\/arm\/include\/asm\/assembler.h\n@@ -320,4 +320,12 @@\n \t.size \\name , . - \\name\n \t.endm\n \n+\t.macro check_uaccess, addr:req, size:req, limit:req, tmp:req, bad:req\n+#ifndef CONFIG_CPU_USE_DOMAINS\n+\tadds\t\\tmp, \\addr, #\\size - 1\n+\tsbcccs\t\\tmp, \\tmp, \\limit\n+\tbcs\t\\bad\n+#endif\n+\t.endm\n+\n #endif \/* __ASM_ASSEMBLER_H__ *\/\ndiff --git a\/arch\/arm\/include\/asm\/uaccess.h b\/arch\/arm\/include\/asm\/uaccess.h\nindex 479a6352e0b5..6f83ad6e4d3d 100644\n--- a\/arch\/arm\/include\/asm\/uaccess.h\n+++ b\/arch\/arm\/include\/asm\/uaccess.h\n@@ -101,28 +101,39 @@ extern int __get_user_1(void *);\n extern int __get_user_2(void *);\n extern int __get_user_4(void *);\n \n-#define __get_user_x(__r2,__p,__e,__s,__i...)\t\t\t\t\\\n+#define __GUP_CLOBBER_1\t\"lr\", \"cc\"\n+#ifdef CONFIG_CPU_USE_DOMAINS\n+#define __GUP_CLOBBER_2\t\"ip\", \"lr\", \"cc\"\n+#else\n+#define __GUP_CLOBBER_2 \"lr\", \"cc\"\n+#endif\n+#define __GUP_CLOBBER_4\t\"lr\", \"cc\"\n+\n+#define __get_user_x(__r2,__p,__e,__l,__s)\t\t\t\t\\\n \t   __asm__ __volatile__ (\t\t\t\t\t\\\n \t\t__asmeq(\"%0\", \"r0\") __asmeq(\"%1\", \"r2\")\t\t\t\\\n+\t\t__asmeq(\"%3\", \"r1\")\t\t\t\t\t\\\n \t\t\"bl\t__get_user_\" #__s\t\t\t\t\\\n \t\t: \"=&r\" (__e), \"=r\" (__r2)\t\t\t\t\\\n-\t\t: \"0\" (__p)\t\t\t\t\t\t\\\n-\t\t: __i, \"cc\")\n+\t\t: \"0\" (__p), \"r\" (__l)\t\t\t\t\t\\\n+\t\t: __GUP_CLOBBER_##__s)\n \n #define get_user(x,p)\t\t\t\t\t\t\t\\\n \t({\t\t\t\t\t\t\t\t\\\n+\t\tunsigned long __limit = current_thread_info()->addr_limit - 1; \\\n \t\tregister const typeof(*(p)) __user *__p asm(\"r0\") = (p);\\\n \t\tregister unsigned long __r2 asm(\"r2\");\t\t\t\\\n+\t\tregister unsigned long __l asm(\"r1\") = __limit;\t\t\\\n \t\tregister int __e asm(\"r0\");\t\t\t\t\\\n \t\tswitch (sizeof(*(__p))) {\t\t\t\t\\\n \t\tcase 1:\t\t\t\t\t\t\t\\\n-\t\t\t__get_user_x(__r2, __p, __e, 1, \"lr\");\t\t\\\n-\t       \t\tbreak;\t\t\t\t\t\t\\\n+\t\t\t__get_user_x(__r2, __p, __e, __l, 1);\t\t\\\n+\t\t\tbreak;\t\t\t\t\t\t\\\n \t\tcase 2:\t\t\t\t\t\t\t\\\n-\t\t\t__get_user_x(__r2, __p, __e, 2, \"r3\", \"lr\");\t\\\n+\t\t\t__get_user_x(__r2, __p, __e, __l, 2);\t\t\\\n \t\t\tbreak;\t\t\t\t\t\t\\\n \t\tcase 4:\t\t\t\t\t\t\t\\\n-\t       \t\t__get_user_x(__r2, __p, __e, 4, \"lr\");\t\t\\\n+\t\t\t__get_user_x(__r2, __p, __e, __l, 4);\t\t\\\n \t\t\tbreak;\t\t\t\t\t\t\\\n \t\tdefault: __e = __get_user_bad(); break;\t\t\t\\\n \t\t}\t\t\t\t\t\t\t\\\n@@ -135,31 +146,34 @@ extern int __put_user_2(void *, unsigned int);\n extern int __put_user_4(void *, unsigned int);\n extern int __put_user_8(void *, unsigned long long);\n \n-#define __put_user_x(__r2,__p,__e,__s)\t\t\t\t\t\\\n+#define __put_user_x(__r2,__p,__e,__l,__s)\t\t\t\t\\\n \t   __asm__ __volatile__ (\t\t\t\t\t\\\n \t\t__asmeq(\"%0\", \"r0\") __asmeq(\"%2\", \"r2\")\t\t\t\\\n+\t\t__asmeq(\"%3\", \"r1\")\t\t\t\t\t\\\n \t\t\"bl\t__put_user_\" #__s\t\t\t\t\\\n \t\t: \"=&r\" (__e)\t\t\t\t\t\t\\\n-\t\t: \"0\" (__p), \"r\" (__r2)\t\t\t\t\t\\\n+\t\t: \"0\" (__p), \"r\" (__r2), \"r\" (__l)\t\t\t\\\n \t\t: \"ip\", \"lr\", \"cc\")\n \n #define put_user(x,p)\t\t\t\t\t\t\t\\\n \t({\t\t\t\t\t\t\t\t\\\n+\t\tunsigned long __limit = current_thread_info()->addr_limit - 1; \\\n \t\tregister const typeof(*(p)) __r2 asm(\"r2\") = (x);\t\\\n \t\tregister const typeof(*(p)) __user *__p asm(\"r0\") = (p);\\\n+\t\tregister unsigned long __l asm(\"r1\") = __limit;\t\t\\\n \t\tregister int __e asm(\"r0\");\t\t\t\t\\\n \t\tswitch (sizeof(*(__p))) {\t\t\t\t\\\n \t\tcase 1:\t\t\t\t\t\t\t\\\n-\t\t\t__put_user_x(__r2, __p, __e, 1);\t\t\\\n+\t\t\t__put_user_x(__r2, __p, __e, __l, 1);\t\t\\\n \t\t\tbreak;\t\t\t\t\t\t\\\n \t\tcase 2:\t\t\t\t\t\t\t\\\n-\t\t\t__put_user_x(__r2, __p, __e, 2);\t\t\\\n+\t\t\t__put_user_x(__r2, __p, __e, __l, 2);\t\t\\\n \t\t\tbreak;\t\t\t\t\t\t\\\n \t\tcase 4:\t\t\t\t\t\t\t\\\n-\t\t\t__put_user_x(__r2, __p, __e, 4);\t\t\\\n+\t\t\t__put_user_x(__r2, __p, __e, __l, 4);\t\t\\\n \t\t\tbreak;\t\t\t\t\t\t\\\n \t\tcase 8:\t\t\t\t\t\t\t\\\n-\t\t\t__put_user_x(__r2, __p, __e, 8);\t\t\\\n+\t\t\t__put_user_x(__r2, __p, __e, __l, 8);\t\t\\\n \t\t\tbreak;\t\t\t\t\t\t\\\n \t\tdefault: __e = __put_user_bad(); break;\t\t\t\\\n \t\t}\t\t\t\t\t\t\t\\\ndiff --git a\/arch\/arm\/lib\/getuser.S b\/arch\/arm\/lib\/getuser.S\nindex 11093a7c3e32..9b06bb41fca6 100644\n--- a\/arch\/arm\/lib\/getuser.S\n+++ b\/arch\/arm\/lib\/getuser.S\n@@ -16,8 +16,9 @@\n  * __get_user_X\n  *\n  * Inputs:\tr0 contains the address\n+ *\t\tr1 contains the address limit, which must be preserved\n  * Outputs:\tr0 is the error code\n- *\t\tr2, r3 contains the zero-extended value\n+ *\t\tr2 contains the zero-extended value\n  *\t\tlr corrupted\n  *\n  * No other registers must be altered.  (see <asm\/uaccess.h>\n@@ -27,33 +28,39 @@\n  * Note also that it is intended that __get_user_bad is not global.\n  *\/\n #include <linux\/linkage.h>\n+#include <asm\/assembler.h>\n #include <asm\/errno.h>\n #include <asm\/domain.h>\n \n ENTRY(__get_user_1)\n+\tcheck_uaccess r0, 1, r1, r2, __get_user_bad\n 1: TUSER(ldrb)\tr2, [r0]\n \tmov\tr0, #0\n \tmov\tpc, lr\n ENDPROC(__get_user_1)\n \n ENTRY(__get_user_2)\n-#ifdef CONFIG_THUMB2_KERNEL\n-2: TUSER(ldrb)\tr2, [r0]\n-3: TUSER(ldrb)\tr3, [r0, #1]\n+\tcheck_uaccess r0, 2, r1, r2, __get_user_bad\n+#ifdef CONFIG_CPU_USE_DOMAINS\n+rb\t.req\tip\n+2:\tldrbt\tr2, [r0], #1\n+3:\tldrbt\trb, [r0], #0\n #else\n-2: TUSER(ldrb)\tr2, [r0], #1\n-3: TUSER(ldrb)\tr3, [r0]\n+rb\t.req\tr0\n+2:\tldrb\tr2, [r0]\n+3:\tldrb\trb, [r0, #1]\n #endif\n #ifndef __ARMEB__\n-\torr\tr2, r2, r3, lsl #8\n+\torr\tr2, r2, rb, lsl #8\n #else\n-\torr\tr2, r3, r2, lsl #8\n+\torr\tr2, rb, r2, lsl #8\n #endif\n \tmov\tr0, #0\n \tmov\tpc, lr\n ENDPROC(__get_user_2)\n \n ENTRY(__get_user_4)\n+\tcheck_uaccess r0, 4, r1, r2, __get_user_bad\n 4: TUSER(ldr)\tr2, [r0]\n \tmov\tr0, #0\n \tmov\tpc, lr\ndiff --git a\/arch\/arm\/lib\/putuser.S b\/arch\/arm\/lib\/putuser.S\nindex 7db25990c589..3d73dcb959b0 100644\n--- a\/arch\/arm\/lib\/putuser.S\n+++ b\/arch\/arm\/lib\/putuser.S\n@@ -16,6 +16,7 @@\n  * __put_user_X\n  *\n  * Inputs:\tr0 contains the address\n+ *\t\tr1 contains the address limit, which must be preserved\n  *\t\tr2, r3 contains the value\n  * Outputs:\tr0 is the error code\n  *\t\tlr corrupted\n@@ -27,16 +28,19 @@\n  * Note also that it is intended that __put_user_bad is not global.\n  *\/\n #include <linux\/linkage.h>\n+#include <asm\/assembler.h>\n #include <asm\/errno.h>\n #include <asm\/domain.h>\n \n ENTRY(__put_user_1)\n+\tcheck_uaccess r0, 1, r1, ip, __put_user_bad\n 1: TUSER(strb)\tr2, [r0]\n \tmov\tr0, #0\n \tmov\tpc, lr\n ENDPROC(__put_user_1)\n \n ENTRY(__put_user_2)\n+\tcheck_uaccess r0, 2, r1, ip, __put_user_bad\n \tmov\tip, r2, lsr #8\n #ifdef CONFIG_THUMB2_KERNEL\n #ifndef __ARMEB__\n@@ -60,12 +64,14 @@ ENTRY(__put_user_2)\n ENDPROC(__put_user_2)\n \n ENTRY(__put_user_4)\n+\tcheck_uaccess r0, 4, r1, ip, __put_user_bad\n 4: TUSER(str)\tr2, [r0]\n \tmov\tr0, #0\n \tmov\tpc, lr\n ENDPROC(__put_user_4)\n \n ENTRY(__put_user_8)\n+\tcheck_uaccess r0, 8, r1, ip, __put_user_bad\n #ifdef CONFIG_THUMB2_KERNEL\n 5: TUSER(str)\tr2, [r0]\n 6: TUSER(str)\tr3, [r0, #4]\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-17456","CWE_ID":"20","category":"security","commit_id":"a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46","commit_message":"From a124133e1e6ab5c7a9fef6d0e6bcb084e3455b46 Mon Sep 17 00:00:00 2001\nFrom: Jeff King <peff@peff.net>\nDate: Mon, 24 Sep 2018 04:37:17 -0400\nSubject: [PATCH] fsck: detect submodule urls starting with dash\n\nUrls with leading dashes can cause mischief on older\nversions of Git. We should detect them so that they can be\nrejected by receive.fsckObjects, preventing modern versions\nof git from being a vector by which attacks can spread.\n\nSigned-off-by: Jeff King <peff@peff.net>\nSigned-off-by: Junio C Hamano <gitster@pobox.com>\n---\n fsck.c                        |  7 +++++++\n t\/t7416-submodule-dash-url.sh | 15 +++++++++++++++\n 2 files changed, 22 insertions(+)\n\n","diff_code":"diff --git a\/fsck.c b\/fsck.c\nindex 9339f31513178..c47285652723a 100644\n--- a\/fsck.c\n+++ b\/fsck.c\n@@ -64,6 +64,7 @@ static struct oidset gitmodules_done = OIDSET_INIT;\n \tFUNC(GITMODULES_PARSE, ERROR) \\\n \tFUNC(GITMODULES_NAME, ERROR) \\\n \tFUNC(GITMODULES_SYMLINK, ERROR) \\\n+\tFUNC(GITMODULES_URL, ERROR) \\\n \t\/* warnings *\/ \\\n \tFUNC(BAD_FILEMODE, WARN) \\\n \tFUNC(EMPTY_NAME, WARN) \\\n@@ -945,6 +946,12 @@ static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n \t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n \t\t\t\t    \"disallowed submodule name: %s\",\n \t\t\t\t    name);\n+\tif (!strcmp(key, \"url\") && value &&\n+\t    looks_like_command_line_option(value))\n+\t\tdata->ret |= report(data->options, data->obj,\n+\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n+\t\t\t\t    \"disallowed submodule url: %s\",\n+\t\t\t\t    value);\n \tfree(name);\n \n \treturn 0;\ndiff --git a\/t\/t7416-submodule-dash-url.sh b\/t\/t7416-submodule-dash-url.sh\nindex 459193c976506..1cd2c1c1ea2d7 100755\n--- a\/t\/t7416-submodule-dash-url.sh\n+++ b\/t\/t7416-submodule-dash-url.sh\n@@ -20,6 +20,13 @@ test_expect_success 'clone can recurse submodule' '\n \ttest_cmp expect actual\n '\n \n+test_expect_success 'fsck accepts protected dash' '\n+\ttest_when_finished \"rm -rf dst\" &&\n+\tgit init --bare dst &&\n+\tgit -C dst config transfer.fsckObjects true &&\n+\tgit push dst HEAD\n+'\n+\n test_expect_success 'remove .\/ protection from .gitmodules url' '\n \tperl -i -pe \"s{\\.\/}{}\" .gitmodules &&\n \tgit commit -am \"drop protection\"\n@@ -31,4 +38,12 @@ test_expect_success 'clone rejects unprotected dash' '\n \ttest_i18ngrep ignoring err\n '\n \n+test_expect_success 'fsck rejects unprotected dash' '\n+\ttest_when_finished \"rm -rf dst\" &&\n+\tgit init --bare dst &&\n+\tgit -C dst config transfer.fsckObjects true &&\n+\ttest_must_fail git push dst HEAD 2>err &&\n+\tgrep gitmodulesUrl err\n+'\n+\n test_done\n","owner":"git","repo":"git","source":"cve"},{"CVE_ID":"CVE-2017-11450","CWE_ID":"20","category":"security","commit_id":"948356eec65aea91995d4b7cc487d197d2c5f602","commit_message":"From 948356eec65aea91995d4b7cc487d197d2c5f602 Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 2 Jul 2017 20:38:07 -0400\nSubject: [PATCH] ...\n\n---\n coders\/jpeg.c | 10 ++++++++++\n 1 file changed, 10 insertions(+)\n\n","diff_code":"diff --git a\/coders\/jpeg.c b\/coders\/jpeg.c\nindex 74006a49c4..9b94e7252c 100644\n--- a\/coders\/jpeg.c\n+++ b\/coders\/jpeg.c\n@@ -1030,6 +1030,11 @@ static Image *ReadJPEGImage(const ImageInfo *image_info,\n       image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n+  \/*\n+    Verify that file size large enough to contain a JPEG datastream.\n+  *\/\n+  if (GetBlobSize(image) < 107)\n+    ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n   \/*\n     Initialize JPEG parameters.\n   *\/\n@@ -1504,6 +1509,7 @@ ModuleExport size_t RegisterJPEGImage(void)\n #endif\n   entry->magick=(IsImageFormatHandler *) IsJPEG;\n   entry->adjoin=MagickFalse;\n+  entry->seekable_stream=MagickTrue;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n@@ -1520,6 +1526,7 @@ ModuleExport size_t RegisterJPEGImage(void)\n #endif\n   entry->magick=(IsImageFormatHandler *) IsJPEG;\n   entry->adjoin=MagickFalse;\n+  entry->seekable_stream=MagickTrue;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n@@ -1535,6 +1542,7 @@ ModuleExport size_t RegisterJPEGImage(void)\n   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->adjoin=MagickFalse;\n+  entry->seekable_stream=MagickTrue;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n@@ -1550,6 +1558,7 @@ ModuleExport size_t RegisterJPEGImage(void)\n   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->adjoin=MagickFalse;\n+  entry->seekable_stream=MagickTrue;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n@@ -1565,6 +1574,7 @@ ModuleExport size_t RegisterJPEGImage(void)\n   entry->encoder=(EncodeImageHandler *) WriteJPEGImage;\n #endif\n   entry->adjoin=MagickFalse;\n+  entry->seekable_stream=MagickTrue;\n   entry->description=ConstantString(description);\n   if (*version != '\\0')\n     entry->version=ConstantString(version);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-7271","CWE_ID":"20","category":"security","commit_id":"f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","commit_message":"From f3d3342602f8bcbf37d7c46641cb9bca7618eb1c Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Thu, 21 Nov 2013 03:14:22 +0100\nSubject: [PATCH] net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include\/linux\/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec\/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n crypto\/algif_hash.c            |  2 --\n crypto\/algif_skcipher.c        |  1 -\n drivers\/isdn\/mISDN\/socket.c    | 13 ++++---------\n drivers\/net\/ppp\/pppoe.c        |  2 --\n include\/linux\/net.h            |  8 ++++++++\n net\/appletalk\/ddp.c            | 16 +++++++---------\n net\/atm\/common.c               |  2 --\n net\/ax25\/af_ax25.c             |  4 ++--\n net\/bluetooth\/af_bluetooth.c   |  9 ++-------\n net\/bluetooth\/hci_sock.c       |  2 --\n net\/bluetooth\/rfcomm\/sock.c    |  1 -\n net\/bluetooth\/sco.c            |  1 -\n net\/caif\/caif_socket.c         |  4 ----\n net\/compat.c                   |  3 ++-\n net\/core\/iovec.c               |  3 ++-\n net\/ipx\/af_ipx.c               |  3 +--\n net\/irda\/af_irda.c             |  4 ----\n net\/iucv\/af_iucv.c             |  2 --\n net\/key\/af_key.c               |  1 -\n net\/l2tp\/l2tp_ppp.c            |  2 --\n net\/llc\/af_llc.c               |  2 --\n net\/netlink\/af_netlink.c       |  2 --\n net\/netrom\/af_netrom.c         |  3 +--\n net\/nfc\/llcp_sock.c            |  2 --\n net\/nfc\/rawsock.c              |  2 --\n net\/packet\/af_packet.c         | 32 +++++++++++++++-----------------\n net\/rds\/recv.c                 |  2 --\n net\/rose\/af_rose.c             |  8 +++++---\n net\/rxrpc\/ar-recvmsg.c         |  9 ++++++---\n net\/socket.c                   | 19 +++++++++++--------\n net\/tipc\/socket.c              |  6 ------\n net\/unix\/af_unix.c             |  5 -----\n net\/vmw_vsock\/af_vsock.c       |  2 --\n net\/vmw_vsock\/vmci_transport.c |  2 --\n net\/x25\/af_x25.c               |  3 +--\n 35 files changed, 67 insertions(+), 115 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/algif_hash.c b\/crypto\/algif_hash.c\nindex 0262210cad386..ef5356cd280a5 100644\n--- a\/crypto\/algif_hash.c\n+++ b\/crypto\/algif_hash.c\n@@ -161,8 +161,6 @@ static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\ndiff --git a\/crypto\/algif_skcipher.c b\/crypto\/algif_skcipher.c\nindex a1c4f0a555832..6a6dfc062d2a4 100644\n--- a\/crypto\/algif_skcipher.c\n+++ b\/crypto\/algif_skcipher.c\n@@ -432,7 +432,6 @@ static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n \tlong copied = 0;\n \n \tlock_sock(sk);\n-\tmsg->msg_namelen = 0;\n \tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n \t     iovlen--, iov++) {\n \t\tunsigned long seglen = iov->iov_len;\ndiff --git a\/drivers\/isdn\/mISDN\/socket.c b\/drivers\/isdn\/mISDN\/socket.c\nindex e47dcb9d1e91d..5cefb479c7072 100644\n--- a\/drivers\/isdn\/mISDN\/socket.c\n+++ b\/drivers\/isdn\/mISDN\/socket.c\n@@ -117,7 +117,6 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sk_buff\t\t*skb;\n \tstruct sock\t\t*sk = sock->sk;\n-\tstruct sockaddr_mISDN\t*maddr;\n \n \tint\t\tcopied, err;\n \n@@ -135,9 +134,9 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n-\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_mISDN *maddr = msg->msg_name;\n+\n \t\tmaddr->family = AF_ISDN;\n \t\tmaddr->dev = _pms(sk)->dev->id;\n \t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n@@ -150,11 +149,7 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n \t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n \t\t}\n-\t} else {\n-\t\tif (msg->msg_namelen)\n-\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n-\t\t\t       __func__, msg->msg_namelen);\n-\t\tmsg->msg_namelen = 0;\n+\t\tmsg->msg_namelen = sizeof(*maddr);\n \t}\n \n \tcopied = skb->len + MISDN_HEADER_LEN;\ndiff --git a\/drivers\/net\/ppp\/pppoe.c b\/drivers\/net\/ppp\/pppoe.c\nindex 5f66e30d98239..82ee6ed954cb8 100644\n--- a\/drivers\/net\/ppp\/pppoe.c\n+++ b\/drivers\/net\/ppp\/pppoe.c\n@@ -979,8 +979,6 @@ static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (error < 0)\n \t\tgoto end;\n \n-\tm->msg_namelen = 0;\n-\n \tif (skb) {\n \t\ttotal_len = min_t(size_t, total_len, skb->len);\n \t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\ndiff --git a\/include\/linux\/net.h b\/include\/linux\/net.h\nindex b292a04355717..4bcee94cef931 100644\n--- a\/include\/linux\/net.h\n+++ b\/include\/linux\/net.h\n@@ -164,6 +164,14 @@ struct proto_ops {\n #endif\n \tint\t\t(*sendmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len);\n+\t\/* Notes for implementing recvmsg:\n+\t * ===============================\n+\t * msg->msg_namelen should get updated by the recvmsg handlers\n+\t * iff msg_name != NULL. It is by default 0 to prevent\n+\t * returning uninitialized memory to user space.  The recvfrom\n+\t * handlers can assume that msg.msg_name is either NULL or has\n+\t * a minimum size of sizeof(struct sockaddr_storage).\n+\t *\/\n \tint\t\t(*recvmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len,\n \t\t\t\t      int flags);\ndiff --git a\/net\/appletalk\/ddp.c b\/net\/appletalk\/ddp.c\nindex 7fee50d637f95..7d424ac6e760b 100644\n--- a\/net\/appletalk\/ddp.c\n+++ b\/net\/appletalk\/ddp.c\n@@ -1735,7 +1735,6 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n-\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n@@ -1764,14 +1763,13 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n \n-\tif (!err) {\n-\t\tif (sat) {\n-\t\t\tsat->sat_family      = AF_APPLETALK;\n-\t\t\tsat->sat_port        = ddp->deh_sport;\n-\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n-\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n-\t\t}\n-\t\tmsg->msg_namelen = sizeof(*sat);\n+\tif (!err && msg->msg_name) {\n+\t\tstruct sockaddr_at *sat = msg->msg_name;\n+\t\tsat->sat_family      = AF_APPLETALK;\n+\t\tsat->sat_port        = ddp->deh_sport;\n+\t\tsat->sat_addr.s_node = ddp->deh_snode;\n+\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n+\t\tmsg->msg_namelen     = sizeof(*sat);\n \t}\n \n \tskb_free_datagram(sk, skb);\t\/* Free the datagram. *\/\ndiff --git a\/net\/atm\/common.c b\/net\/atm\/common.c\nindex 737bef59ce899..7b491006eaf40 100644\n--- a\/net\/atm\/common.c\n+++ b\/net\/atm\/common.c\n@@ -531,8 +531,6 @@ int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n \ndiff --git a\/net\/ax25\/af_ax25.c b\/net\/ax25\/af_ax25.c\nindex a00123ebb0ae0..7bb1605bdfd99 100644\n--- a\/net\/ax25\/af_ax25.c\n+++ b\/net\/ax25\/af_ax25.c\n@@ -1636,11 +1636,11 @@ static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (msg->msg_namelen != 0) {\n-\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n+\tif (msg->msg_name) {\n \t\tax25_digi digi;\n \t\tax25_address src;\n \t\tconst unsigned char *mac = skb_mac_header(skb);\n+\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n \n \t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n \t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\ndiff --git a\/net\/bluetooth\/af_bluetooth.c b\/net\/bluetooth\/af_bluetooth.c\nindex f6a1671ea2ff7..56ca494621c66 100644\n--- a\/net\/bluetooth\/af_bluetooth.c\n+++ b\/net\/bluetooth\/af_bluetooth.c\n@@ -224,10 +224,9 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n-\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n-\t\t\tmsg->msg_namelen = 0;\n+\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n-\t\t}\n+\n \t\treturn err;\n \t}\n \n@@ -245,8 +244,6 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tif (bt_sk(sk)->skb_msg_name)\n \t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n \t\t\t\t\t\t&msg->msg_namelen);\n-\t\telse\n-\t\t\tmsg->msg_namelen = 0;\n \t}\n \n \tskb_free_datagram(sk, skb);\n@@ -295,8 +292,6 @@ int bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \tBT_DBG(\"sk %p size %zu\", sk, size);\n \n \tlock_sock(sk);\ndiff --git a\/net\/bluetooth\/hci_sock.c b\/net\/bluetooth\/hci_sock.c\nindex 71f0be1730801..6a6c8bb4fd72d 100644\n--- a\/net\/bluetooth\/hci_sock.c\n+++ b\/net\/bluetooth\/hci_sock.c\n@@ -856,8 +856,6 @@ static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/bluetooth\/rfcomm\/sock.c b\/net\/bluetooth\/rfcomm\/sock.c\nindex c4d3d423f89b8..c80766f892c36 100644\n--- a\/net\/bluetooth\/rfcomm\/sock.c\n+++ b\/net\/bluetooth\/rfcomm\/sock.c\n@@ -615,7 +615,6 @@ static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n-\t\tmsg->msg_namelen = 0;\n \t\treturn 0;\n \t}\n \ndiff --git a\/net\/bluetooth\/sco.c b\/net\/bluetooth\/sco.c\nindex 12a0e51e21e13..24fa3964b3c84 100644\n--- a\/net\/bluetooth\/sco.c\n+++ b\/net\/bluetooth\/sco.c\n@@ -711,7 +711,6 @@ static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n \t\tsk->sk_state = BT_CONFIG;\n-\t\tmsg->msg_namelen = 0;\n \n \t\trelease_sock(sk);\n \t\treturn 0;\ndiff --git a\/net\/caif\/caif_socket.c b\/net\/caif\/caif_socket.c\nindex 05a41c7ec304e..d6be3edb7a434 100644\n--- a\/net\/caif\/caif_socket.c\n+++ b\/net\/caif\/caif_socket.c\n@@ -286,8 +286,6 @@ static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (m->msg_flags&MSG_OOB)\n \t\tgoto read_error;\n \n-\tm->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n \tif (!skb)\n \t\tgoto read_error;\n@@ -361,8 +359,6 @@ static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/*\n \t * Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\ndiff --git a\/net\/compat.c b\/net\/compat.c\nindex 89032580bd1d8..618c6a8a911b6 100644\n--- a\/net\/compat.c\n+++ b\/net\/compat.c\n@@ -93,7 +93,8 @@ int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tkern_msg->msg_name = kern_address;\n+\t\tif (kern_msg->msg_name)\n+\t\t\tkern_msg->msg_name = kern_address;\n \t} else\n \t\tkern_msg->msg_name = NULL;\n \ndiff --git a\/net\/core\/iovec.c b\/net\/core\/iovec.c\nindex 4cdb7c48dad6c..b61869429f4ce 100644\n--- a\/net\/core\/iovec.c\n+++ b\/net\/core\/iovec.c\n@@ -48,7 +48,8 @@ int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *a\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tm->msg_name = address;\n+\t\tif (m->msg_name)\n+\t\t\tm->msg_name = address;\n \t} else {\n \t\tm->msg_name = NULL;\n \t}\ndiff --git a\/net\/ipx\/af_ipx.c b\/net\/ipx\/af_ipx.c\nindex 7a1e0fc1bd4dd..e096025b477f3 100644\n--- a\/net\/ipx\/af_ipx.c\n+++ b\/net\/ipx\/af_ipx.c\n@@ -1823,8 +1823,6 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n-\tmsg->msg_namelen = sizeof(*sipx);\n-\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n@@ -1832,6 +1830,7 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n+\t\tmsg->msg_namelen\t= sizeof(*sipx);\n \t}\n \trc = copied;\n \ndiff --git a\/net\/irda\/af_irda.c b\/net\/irda\/af_irda.c\nindex 0f676908d15b6..de7db23049f14 100644\n--- a\/net\/irda\/af_irda.c\n+++ b\/net\/irda\/af_irda.c\n@@ -1385,8 +1385,6 @@ static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n \n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \n-\tmsg->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n@@ -1451,8 +1449,6 @@ static int irda_recvmsg_stream(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, noblock);\n \n-\tmsg->msg_namelen = 0;\n-\n \tdo {\n \t\tint chunk;\n \t\tstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\ndiff --git a\/net\/iucv\/af_iucv.c b\/net\/iucv\/af_iucv.c\nindex 168aff5e60de5..c4b7218058b64 100644\n--- a\/net\/iucv\/af_iucv.c\n+++ b\/net\/iucv\/af_iucv.c\n@@ -1324,8 +1324,6 @@ static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint err = 0;\n \tu32 offset;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif ((sk->sk_state == IUCV_DISCONN) &&\n \t    skb_queue_empty(&iucv->backlog_skb_q) &&\n \t    skb_queue_empty(&sk->sk_receive_queue) &&\ndiff --git a\/net\/key\/af_key.c b\/net\/key\/af_key.c\nindex 911ef03bf8fbf..545f047868ad8 100644\n--- a\/net\/key\/af_key.c\n+++ b\/net\/key\/af_key.c\n@@ -3616,7 +3616,6 @@ static int pfkey_recvmsg(struct kiocb *kiocb,\n \tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n \tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n \tif (skb == NULL)\n \t\tgoto out;\ndiff --git a\/net\/l2tp\/l2tp_ppp.c b\/net\/l2tp\/l2tp_ppp.c\nindex ffda81ef1a709..be5fadf347394 100644\n--- a\/net\/l2tp\/l2tp_ppp.c\n+++ b\/net\/l2tp\/l2tp_ppp.c\n@@ -197,8 +197,6 @@ static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sk->sk_state & PPPOX_BOUND)\n \t\tgoto end;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = 0;\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\ndiff --git a\/net\/llc\/af_llc.c b\/net\/llc\/af_llc.c\nindex 6cba486353e8a..7b01b9f5846c8 100644\n--- a\/net\/llc\/af_llc.c\n+++ b\/net\/llc\/af_llc.c\n@@ -720,8 +720,6 @@ static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint target;\t\/* Read at least this many bytes *\/\n \tlong timeo;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tcopied = -ENOTCONN;\n \tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\ndiff --git a\/net\/netlink\/af_netlink.c b\/net\/netlink\/af_netlink.c\nindex f0176e1a5a81a..bca50b95c1823 100644\n--- a\/net\/netlink\/af_netlink.c\n+++ b\/net\/netlink\/af_netlink.c\n@@ -2335,8 +2335,6 @@ static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,\n \t}\n #endif\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = data_skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/netrom\/af_netrom.c b\/net\/netrom\/af_netrom.c\nindex 698814bfa7adf..53c19a35fc6dc 100644\n--- a\/net\/netrom\/af_netrom.c\n+++ b\/net\/netrom\/af_netrom.c\n@@ -1179,10 +1179,9 @@ static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n+\t\tmsg->msg_namelen = sizeof(*sax);\n \t}\n \n-\tmsg->msg_namelen = sizeof(*sax);\n-\n \tskb_free_datagram(sk, skb);\n \n \trelease_sock(sk);\ndiff --git a\/net\/nfc\/llcp_sock.c b\/net\/nfc\/llcp_sock.c\nindex d308402b67d80..824c6056bf823 100644\n--- a\/net\/nfc\/llcp_sock.c\n+++ b\/net\/nfc\/llcp_sock.c\n@@ -807,8 +807,6 @@ static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tpr_debug(\"%p %zu\\n\", sk, len);\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state == LLCP_CLOSED &&\ndiff --git a\/net\/nfc\/rawsock.c b\/net\/nfc\/rawsock.c\nindex cd958b381f961..66bcd2eb57737 100644\n--- a\/net\/nfc\/rawsock.c\n+++ b\/net\/nfc\/rawsock.c\n@@ -244,8 +244,6 @@ static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn rc;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/packet\/af_packet.c b\/net\/packet\/af_packet.c\nindex 2e8286b47c28e..61bd50adead1c 100644\n--- a\/net\/packet\/af_packet.c\n+++ b\/net\/packet\/af_packet.c\n@@ -2660,7 +2660,6 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tstruct sock *sk = sock->sk;\n \tstruct sk_buff *skb;\n \tint copied, err;\n-\tstruct sockaddr_ll *sll;\n \tint vnet_hdr_len = 0;\n \n \terr = -EINVAL;\n@@ -2744,22 +2743,10 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tgoto out_free;\n \t}\n \n-\t\/*\n-\t *\tIf the address length field is there to be filled in, we fill\n-\t *\tit in now.\n-\t *\/\n-\n-\tsll = &PACKET_SKB_CB(skb)->sa.ll;\n-\tif (sock->type == SOCK_PACKET)\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n-\telse\n-\t\tmsg->msg_namelen = sll->sll_halen + offsetof(struct sockaddr_ll, sll_addr);\n-\n-\t\/*\n-\t *\tYou lose any data beyond the buffer you gave. If it worries a\n-\t *\tuser program they can ask the device for its MTU anyway.\n+\t\/* You lose any data beyond the buffer you gave. If it worries\n+\t * a user program they can ask the device for its MTU\n+\t * anyway.\n \t *\/\n-\n \tcopied = skb->len;\n \tif (copied > len) {\n \t\tcopied = len;\n@@ -2772,9 +2759,20 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n \n-\tif (msg->msg_name)\n+\tif (msg->msg_name) {\n+\t\t\/* If the address length field is there to be filled\n+\t\t * in, we fill it in now.\n+\t\t *\/\n+\t\tif (sock->type == SOCK_PACKET) {\n+\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n+\t\t} else {\n+\t\t\tstruct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;\n+\t\t\tmsg->msg_namelen = sll->sll_halen +\n+\t\t\t\toffsetof(struct sockaddr_ll, sll_addr);\n+\t\t}\n \t\tmemcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa,\n \t\t       msg->msg_namelen);\n+\t}\n \n \tif (pkt_sk(sk)->auxdata) {\n \t\tstruct tpacket_auxdata aux;\ndiff --git a\/net\/rds\/recv.c b\/net\/rds\/recv.c\nindex 9f0f17cf6bf9b..de339b24ca140 100644\n--- a\/net\/rds\/recv.c\n+++ b\/net\/rds\/recv.c\n@@ -410,8 +410,6 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n \ndiff --git a\/net\/rose\/af_rose.c b\/net\/rose\/af_rose.c\nindex e98fcfbe60079..33af77246bfeb 100644\n--- a\/net\/rose\/af_rose.c\n+++ b\/net\/rose\/af_rose.c\n@@ -1216,7 +1216,6 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sock *sk = sock->sk;\n \tstruct rose_sock *rose = rose_sk(sk);\n-\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n \tsize_t copied;\n \tunsigned char *asmptr;\n \tstruct sk_buff *skb;\n@@ -1252,8 +1251,11 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (srose != NULL) {\n-\t\tmemset(srose, 0, msg->msg_namelen);\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_rose *srose;\n+\n+\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n+\t\tsrose = msg->msg_name;\n \t\tsrose->srose_family = AF_ROSE;\n \t\tsrose->srose_addr   = rose->dest_addr;\n \t\tsrose->srose_call   = rose->dest_call;\ndiff --git a\/net\/rxrpc\/ar-recvmsg.c b\/net\/rxrpc\/ar-recvmsg.c\nindex 4b48687c3890f..898492a8d61be 100644\n--- a\/net\/rxrpc\/ar-recvmsg.c\n+++ b\/net\/rxrpc\/ar-recvmsg.c\n@@ -143,10 +143,13 @@ int rxrpc_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \t\t\/* copy the peer address and timestamp *\/\n \t\tif (!continue_call) {\n-\t\t\tif (msg->msg_name && msg->msg_namelen > 0)\n+\t\t\tif (msg->msg_name) {\n+\t\t\t\tsize_t len =\n+\t\t\t\t\tsizeof(call->conn->trans->peer->srx);\n \t\t\t\tmemcpy(msg->msg_name,\n-\t\t\t\t       &call->conn->trans->peer->srx,\n-\t\t\t\t       sizeof(call->conn->trans->peer->srx));\n+\t\t\t\t       &call->conn->trans->peer->srx, len);\n+\t\t\t\tmsg->msg_namelen = len;\n+\t\t\t}\n \t\t\tsock_recv_ts_and_drops(msg, &rx->sk, skb);\n \t\t}\n \ndiff --git a\/net\/socket.c b\/net\/socket.c\nindex c226aceee65b8..fc285564e49ec 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -1840,8 +1840,10 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n \tmsg.msg_iov = &iov;\n \tiov.iov_len = size;\n \tiov.iov_base = ubuf;\n-\tmsg.msg_name = (struct sockaddr *)&address;\n-\tmsg.msg_namelen = sizeof(address);\n+\t\/* Save some cycles and don't copy the address if not needed *\/\n+\tmsg.msg_name = addr ? (struct sockaddr *)&address : NULL;\n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg.msg_namelen = 0;\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = sock_recvmsg(sock, &msg, size, flags);\n@@ -2221,16 +2223,14 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \t\t\tgoto out;\n \t}\n \n-\t\/*\n-\t *      Save the user-mode address (verify_iovec will change the\n-\t *      kernel msghdr to use the kernel address space)\n+\t\/* Save the user-mode address (verify_iovec will change the\n+\t * kernel msghdr to use the kernel address space)\n \t *\/\n-\n \tuaddr = (__force void __user *)msg_sys->msg_name;\n \tuaddr_len = COMPAT_NAMELEN(msg);\n-\tif (MSG_CMSG_COMPAT & flags) {\n+\tif (MSG_CMSG_COMPAT & flags)\n \t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n-\t} else\n+\telse\n \t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n \tif (err < 0)\n \t\tgoto out_freeiov;\n@@ -2239,6 +2239,9 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n \tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n \n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg_sys->msg_namelen = 0;\n+\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\ndiff --git a\/net\/tipc\/socket.c b\/net\/tipc\/socket.c\nindex 3906527259d19..3b61851bb9276 100644\n--- a\/net\/tipc\/socket.c\n+++ b\/net\/tipc\/socket.c\n@@ -980,9 +980,6 @@ static int recv_msg(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n restart:\n \n@@ -1091,9 +1088,6 @@ static int recv_stream(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n \ndiff --git a\/net\/unix\/af_unix.c b\/net\/unix\/af_unix.c\nindex c1f403bed683e..01625ccc3ae64 100644\n--- a\/net\/unix\/af_unix.c\n+++ b\/net\/unix\/af_unix.c\n@@ -1754,7 +1754,6 @@ static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n {\n \tstruct unix_sock *u = unix_sk(sk);\n \n-\tmsg->msg_namelen = 0;\n \tif (u->addr) {\n \t\tmsg->msg_namelen = u->addr->len;\n \t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n@@ -1778,8 +1777,6 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = mutex_lock_interruptible(&u->readlock);\n \tif (err) {\n \t\terr = sock_intr_errno(sock_rcvtimeo(sk, noblock));\n@@ -1924,8 +1921,6 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\n \t *\/\ndiff --git a\/net\/vmw_vsock\/af_vsock.c b\/net\/vmw_vsock\/af_vsock.c\nindex 545c08b8a1d48..5adfd94c5b85d 100644\n--- a\/net\/vmw_vsock\/af_vsock.c\n+++ b\/net\/vmw_vsock\/af_vsock.c\n@@ -1662,8 +1662,6 @@ vsock_stream_recvmsg(struct kiocb *kiocb,\n \tvsk = vsock_sk(sk);\n \terr = 0;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state != SS_CONNECTED) {\ndiff --git a\/net\/vmw_vsock\/vmci_transport.c b\/net\/vmw_vsock\/vmci_transport.c\nindex 9d6986634e0bf..687360da62d9f 100644\n--- a\/net\/vmw_vsock\/vmci_transport.c\n+++ b\/net\/vmw_vsock\/vmci_transport.c\n@@ -1746,8 +1746,6 @@ static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Retrieve the head sk_buff from the socket's receive queue. *\/\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\ndiff --git a\/net\/x25\/af_x25.c b\/net\/x25\/af_x25.c\nindex 45a3ab5612c13..7622789d37501 100644\n--- a\/net\/x25\/af_x25.c\n+++ b\/net\/x25\/af_x25.c\n@@ -1340,10 +1340,9 @@ static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n+\t\tmsg->msg_namelen = sizeof(*sx25);\n \t}\n \n-\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n-\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-7840","CWE_ID":"20","category":"security","commit_id":"0be839a2701369f669532ea5884c15bead1c6e08","commit_message":"From 0be839a2701369f669532ea5884c15bead1c6e08 Mon Sep 17 00:00:00 2001\nFrom: \"Michael S. Tsirkin\" <mst@redhat.com>\nDate: Wed, 12 Nov 2014 11:44:39 +0200\nSubject: [PATCH] migration: fix parameter validation on ram load\n\nDuring migration, the values read from migration stream during ram load\nare not validated. Especially offset in host_from_stream_offset() and\nalso the length of the writes in the callers of said function.\n\nTo fix this, we need to make sure that the [offset, offset + length]\nrange fits into one of the allocated memory regions.\n\nValidating addr < len should be sufficient since data seems to always be\nmanaged in TARGET_PAGE_SIZE chunks.\n\nFixes: CVE-2014-7840\n\nNote: follow-up patches add extra checks on each block->host access.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Paolo Bonzini <pbonzini@redhat.com>\nReviewed-by: Dr. David Alan Gilbert <dgilbert@redhat.com>\nSigned-off-by: Amit Shah <amit.shah@redhat.com>\n---\n arch_init.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/arch_init.c b\/arch_init.c\nindex 88a5ba0..593a990 100644\n--- a\/arch_init.c\n+++ b\/arch_init.c\n@@ -1006,7 +1006,7 @@ static inline void *host_from_stream_offset(QEMUFile *f,\n     uint8_t len;\n \n     if (flags & RAM_SAVE_FLAG_CONTINUE) {\n-        if (!block) {\n+        if (!block || block->length <= offset) {\n             error_report(\"Ack, bad migration stream!\");\n             return NULL;\n         }\n@@ -1019,8 +1019,9 @@ static inline void *host_from_stream_offset(QEMUFile *f,\n     id[len] = 0;\n \n     QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n-        if (!strncmp(id, block->idstr, sizeof(id)))\n+        if (!strncmp(id, block->idstr, sizeof(id)) && block->length > offset) {\n             return memory_region_get_ram_ptr(block->mr) + offset;\n+        }\n     }\n \n     error_report(\"Can't find block %s!\", id);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-1000849","CWE_ID":"20","category":"security","commit_id":"6484ed9849f03971eb48ee1fdc21a2f128247eb1","commit_message":"From 6484ed9849f03971eb48ee1fdc21a2f128247eb1 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Timo=20Ter=C3=A4s?= <timo.teras@iki.fi>\nDate: Wed, 5 Sep 2018 19:49:22 +0300\nSubject: rework unpacking of packages and harden package file format\n requirements\n\nA crafted .apk file could to trick apk writing unverified data to\nan unexpected file during temporary file creation due to bugs in handling\nlong link target name and the way a regular file is extracted.\n\nSeveral hardening steps are implemented to avoid this:\n - the temporary file is now always first unlinked (apk thus reserved\n   all filenames .apk.* to be it's working files)\n - the temporary file is after that created with O_EXCL to avoid races\n - the temporary file is no longer directly the archive entry name\n   and thus directly controlled by potentially untrusted data\n - long file names and link target names are now rejected\n - hard link targets are now more rigorously checked\n - various additional checks added for the extraction process to\n   error out early in case of malformed (or old legacy) file\n\nReported-by: Max Justicz <max@justi.cz>\n---\n src\/apk_archive.h |   3 +-\n src\/archive.c     |  34 +++++-------\n src\/commit.c      |   4 +-\n src\/database.c    | 160 ++++++++++++++++++++++++++++++++++++------------------\n src\/gunzip.c      |  35 +++++-------\n src\/package.c     |  11 ++--\n 6 files changed, 142 insertions(+), 105 deletions(-)\n\n","diff_code":"diff --git a\/src\/apk_archive.h b\/src\/apk_archive.h\nindex 6d1916d..7436dd3 100644\n--- a\/src\/apk_archive.h\n+++ b\/src\/apk_archive.h\n@@ -28,7 +28,8 @@ int apk_tar_write_entry(struct apk_ostream *, const struct apk_file_info *ae,\n int apk_tar_write_padding(struct apk_ostream *, const struct apk_file_info *ae);\n \n int apk_archive_entry_extract(int atfd, const struct apk_file_info *ae,\n-\t\t\t      const char *suffix, struct apk_istream *is,\n+\t\t\t      const char *extract_name, const char *hardlink_name,\n+\t\t\t      struct apk_istream *is,\n \t\t\t      apk_progress_cb cb, void *cb_ctx);\n \n #endif\ndiff --git a\/src\/archive.c b\/src\/archive.c\nindex bc36ce7..9a184fd 100644\n--- a\/src\/archive.c\n+++ b\/src\/archive.c\n@@ -317,6 +317,12 @@ int apk_tar_parse(struct apk_istream *is, apk_archive_entry_parser parser,\n \t\t\tbreak;\n \t\t}\n \n+\t\tif (strnlen(entry.name, PATH_MAX) >= PATH_MAX-10 ||\n+\t\t    (entry.link_target && strnlen(entry.link_target, PATH_MAX) >= PATH_MAX-10)) {\n+\t\t\tr = -ENAMETOOLONG;\n+\t\t\tgoto err;\n+\t\t}\n+\n \t\tteis.bytes_left = entry.size;\n \t\tif (entry.mode & S_IFMT) {\n \t\t\t\/* callback parser function *\/\n@@ -428,23 +434,15 @@ int apk_tar_write_padding(struct apk_ostream *os, const struct apk_file_info *ae\n }\n \n int apk_archive_entry_extract(int atfd, const struct apk_file_info *ae,\n-\t\t\t      const char *suffix, struct apk_istream *is,\n+\t\t\t      const char *extract_name, const char *link_target,\n+\t\t\t      struct apk_istream *is,\n \t\t\t      apk_progress_cb cb, void *cb_ctx)\n {\n \tstruct apk_xattr *xattr;\n-\tchar *fn = ae->name;\n+\tconst char *fn = extract_name ?: ae->name;\n \tint fd, r = -1, atflags = 0, ret = 0;\n \n-\tif (suffix != NULL) {\n-\t\tfn = alloca(PATH_MAX);\n-\t\tsnprintf(fn, PATH_MAX, \"%s%s\", ae->name, suffix);\n-\t}\n-\n-\tif ((!S_ISDIR(ae->mode) && !S_ISREG(ae->mode)) ||\n-\t    (ae->link_target != NULL)) {\n-\t\t\/* non-standard entries need to be deleted first *\/\n-\t\tunlinkat(atfd, fn, 0);\n-\t}\n+\tif (unlinkat(atfd, fn, 0) != 0 && errno != ENOENT) return -errno;\n \n \tswitch (ae->mode & S_IFMT) {\n \tcase S_IFDIR:\n@@ -454,7 +452,7 @@ int apk_archive_entry_extract(int atfd, const struct apk_file_info *ae,\n \t\tbreak;\n \tcase S_IFREG:\n \t\tif (ae->link_target == NULL) {\n-\t\t\tint flags = O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC;\n+\t\t\tint flags = O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC | O_EXCL;\n \n \t\t\tfd = openat(atfd, fn, flags, ae->mode & 07777);\n \t\t\tif (fd < 0) {\n@@ -465,18 +463,12 @@ int apk_archive_entry_extract(int atfd, const struct apk_file_info *ae,\n \t\t\tif (r != ae->size) ret = r < 0 ? r : -ENOSPC;\n \t\t\tclose(fd);\n \t\t} else {\n-\t\t\tchar *link_target = ae->link_target;\n-\t\t\tif (suffix != NULL) {\n-\t\t\t\tlink_target = alloca(PATH_MAX);\n-\t\t\t\tsnprintf(link_target, PATH_MAX, \"%s%s\",\n-\t\t\t\t\t ae->link_target, suffix);\n-\t\t\t}\n-\t\t\tr = linkat(atfd, link_target, atfd, fn, 0);\n+\t\t\tr = linkat(atfd, link_target ?: ae->link_target, atfd, fn, 0);\n \t\t\tif (r < 0) ret = -errno;\n \t\t}\n \t\tbreak;\n \tcase S_IFLNK:\n-\t\tr = symlinkat(ae->link_target, atfd, fn);\n+\t\tr = symlinkat(link_target ?: ae->link_target, atfd, fn);\n \t\tif (r < 0) ret = -errno;\n \t\tatflags |= AT_SYMLINK_NOFOLLOW;\n \t\tbreak;\ndiff --git a\/src\/commit.c b\/src\/commit.c\nindex e82537f..ac6d7a5 100644\n--- a\/src\/commit.c\n+++ b\/src\/commit.c\n@@ -232,8 +232,8 @@ static int run_commit_hook(void *ctx, int dirfd, const char *file)\n \tstruct apk_database *db = hook->db;\n \tchar fn[PATH_MAX], *argv[] = { fn, (char *) commit_hook_str[hook->type], NULL };\n \n-\tif ((apk_flags & (APK_NO_SCRIPTS | APK_SIMULATE)) != 0)\n-\t\treturn 0;\n+\tif (file[0] == '.') return 0;\n+\tif ((apk_flags & (APK_NO_SCRIPTS | APK_SIMULATE)) != 0) return 0;\n \n \tsnprintf(fn, sizeof(fn), \"etc\/apk\/commit_hooks.d\" \"\/%s\", file);\n \tif ((apk_flags & APK_NO_COMMIT_HOOKS) != 0) {\ndiff --git a\/src\/database.c b\/src\/database.c\nindex eea7177..8cf63b2 100644\n--- a\/src\/database.c\n+++ b\/src\/database.c\n@@ -828,8 +828,9 @@ int apk_db_index_read(struct apk_database *db, struct apk_bstream *bs, int repo)\n \t\tcase 'F':\n \t\t\tif (diri) apk_db_dir_apply_diri_permissions(diri);\n \t\t\tif (pkg->name == NULL) goto bad_entry;\n-\t\t\tdiri = apk_db_diri_new(db, pkg, l, &diri_node);\n-\t\t\tfile_diri_node = &diri->owned_files.first;\n+\t\t\tdiri = find_diri(ipkg, l, NULL, &diri_node);\n+\t\t\tif (!diri) diri = apk_db_diri_new(db, pkg, l, &diri_node);\n+\t\t\tfile_diri_node = hlist_tail_ptr(&diri->owned_files);\n \t\t\tbreak;\n \t\tcase 'a':\n \t\t\tif (file == NULL) goto bad_entry;\n@@ -2358,6 +2359,31 @@ static struct apk_db_dir_instance *apk_db_install_directory_entry(struct install\n \treturn diri;\n }\n \n+#define TMPNAME_MAX\t(PATH_MAX + 64)\n+\n+static const char *format_tmpname(struct apk_package *pkg, struct apk_db_file *f, char tmpname[static TMPNAME_MAX])\n+{\n+\tEVP_MD_CTX mdctx;\n+\tunsigned char md[EVP_MAX_MD_SIZE];\n+\tapk_blob_t b = APK_BLOB_PTR_LEN(tmpname, TMPNAME_MAX);\n+\n+\tif (!f) return NULL;\n+\n+\tEVP_DigestInit(&mdctx, EVP_sha256());\n+\tEVP_DigestUpdate(&mdctx, pkg->name->name, strlen(pkg->name->name) + 1);\n+\tEVP_DigestUpdate(&mdctx, f->diri->dir->name, f->diri->dir->namelen);\n+\tEVP_DigestUpdate(&mdctx, \"\/\", 1);\n+\tEVP_DigestUpdate(&mdctx, f->name, f->namelen);\n+\tEVP_DigestFinal(&mdctx, md, NULL);\n+\n+\tapk_blob_push_blob(&b, APK_BLOB_PTR_LEN(f->diri->dir->name, f->diri->dir->namelen));\n+\tapk_blob_push_blob(&b, APK_BLOB_STR(\"\/.apk.\"));\n+\tapk_blob_push_hexdump(&b, APK_BLOB_PTR_LEN((char *)md, 24));\n+\tapk_blob_push_blob(&b, APK_BLOB_PTR_LEN(\"\", 1));\n+\n+\treturn tmpname;\n+}\n+\n static int apk_db_install_archive_entry(void *_ctx,\n \t\t\t\t\tconst struct apk_file_info *ae,\n \t\t\t\t\tstruct apk_istream *is)\n@@ -2369,8 +2395,9 @@ static int apk_db_install_archive_entry(void *_ctx,\n \tstruct apk_installed_package *ipkg = pkg->ipkg;\n \tapk_blob_t name = APK_BLOB_STR(ae->name), bdir, bfile;\n \tstruct apk_db_dir_instance *diri = ctx->diri;\n-\tstruct apk_db_file *file;\n+\tstruct apk_db_file *file, *link_target_file = NULL;\n \tint ret = 0, r, type = APK_SCRIPT_INVALID;\n+\tchar tmpname_file[TMPNAME_MAX], tmpname_link_target[TMPNAME_MAX];\n \n \tr = apk_sign_ctx_process_file(&ctx->sctx, ae, is);\n \tif (r <= 0)\n@@ -2437,6 +2464,40 @@ static int apk_db_install_archive_entry(void *_ctx,\n \t\t\tdiri = apk_db_install_directory_entry(ctx, bdir);\n \t\t}\n \n+\t\t\/* Check hard link target to exist in this package *\/\n+\t\tif (S_ISREG(ae->mode) && ae->link_target) {\n+\t\t\tdo {\n+\t\t\t\tstruct apk_db_file *lfile;\n+\t\t\t\tstruct apk_db_dir_instance *ldiri;\n+\t\t\t\tstruct hlist_node *n;\n+\t\t\t\tapk_blob_t hldir, hlfile;\n+\n+\t\t\t\tif (!apk_blob_rsplit(APK_BLOB_STR(ae->link_target),\n+\t\t\t\t\t\t     '\/', &hldir, &hlfile))\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\tldiri = find_diri(ipkg, hldir, diri, NULL);\n+\t\t\t\tif (ldiri == NULL)\n+\t\t\t\t\tbreak;\n+\n+\t\t\t\thlist_for_each_entry(lfile, n, &ldiri->owned_files,\n+\t\t\t\t\t\t     diri_files_list) {\n+\t\t\t\t\tif (apk_blob_compare(APK_BLOB_PTR_LEN(lfile->name, lfile->namelen),\n+\t\t\t\t\t\t\t     hlfile) == 0) {\n+\t\t\t\t\t\tlink_target_file = lfile;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} while (0);\n+\n+\t\t\tif (!link_target_file) {\n+\t\t\t\tapk_error(PKG_VER_FMT\": \"BLOB_FMT\": no hard link target (%s) in archive\",\n+\t\t\t\t\t  PKG_VER_PRINTF(pkg), BLOB_PRINTF(name), ae->link_target);\n+\t\t\t\tipkg->broken_files = 1;\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\n \t\topkg = NULL;\n \t\tfile = apk_db_file_query(db, bdir, bfile);\n \t\tif (file != NULL) {\n@@ -2495,41 +2556,21 @@ static int apk_db_install_archive_entry(void *_ctx,\n \t\tif (apk_verbosity >= 3)\n \t\t\tapk_message(\"%s\", ae->name);\n \n-\t\t\/* Extract the file as name.apk-new *\/\n+\t\t\/* Extract the file with temporary name *\/\n \t\tfile->acl = apk_db_acl_atomize(ae->mode, ae->uid, ae->gid, &ae->xattr_csum);\n-\t\tr = apk_archive_entry_extract(db->root_fd, ae, \".apk-new\", is,\n-\t\t\t\t\t      extract_cb, ctx);\n+\t\tr = apk_archive_entry_extract(\n+\t\t\t\tdb->root_fd, ae,\n+\t\t\t\tformat_tmpname(pkg, file, tmpname_file),\n+\t\t\t\tformat_tmpname(pkg, link_target_file, tmpname_link_target),\n+\t\t\t\tis, extract_cb, ctx);\n \n \t\tswitch (r) {\n \t\tcase 0:\n \t\t\t\/* Hardlinks need special care for checksum *\/\n-\t\t\tif (ae->csum.type == APK_CHECKSUM_NONE &&\n-\t\t\t    ae->link_target != NULL) {\n-\t\t\t\tdo {\n-\t\t\t\t\tstruct apk_db_file *lfile;\n-\t\t\t\t\tstruct apk_db_dir_instance *ldiri;\n-\t\t\t\t\tstruct hlist_node *n;\n-\n-\t\t\t\t\tif (!apk_blob_rsplit(APK_BLOB_STR(ae->link_target),\n-\t\t\t\t\t\t\t     '\/', &bdir, &bfile))\n-\t\t\t\t\t\tbreak;\n-\n-\t\t\t\t\tldiri = find_diri(ipkg, bdir, diri, NULL);\n-\t\t\t\t\tif (ldiri == NULL)\n-\t\t\t\t\t\tbreak;\n-\n-\t\t\t\t\thlist_for_each_entry(lfile, n, &ldiri->owned_files,\n-\t\t\t\t\t\t\t     diri_files_list) {\n-\t\t\t\t\t\tif (apk_blob_compare(APK_BLOB_PTR_LEN(lfile->name, lfile->namelen),\n-\t\t\t\t\t\t\t\t     bfile) == 0) {\n-\t\t\t\t\t\t\tmemcpy(&file->csum, &lfile->csum,\n-\t\t\t\t\t\t\t       sizeof(file->csum));\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} while (0);\n-\t\t\t} else\n-\t\t\t\tmemcpy(&file->csum, &ae->csum, sizeof(file->csum));\n+\t\t\tif (link_target_file)\n+\t\t\t\tmemcpy(&file->csum, &link_target_file->csum, sizeof file->csum);\n+\t\t\telse\n+\t\t\t\tmemcpy(&file->csum, &ae->csum, sizeof file->csum);\n \t\t\tbreak;\n \t\tcase -ENOTSUP:\n \t\t\tipkg->broken_xattr = 1;\n@@ -2547,8 +2588,11 @@ static int apk_db_install_archive_entry(void *_ctx,\n \t\tif (name.ptr[name.len-1] == '\/')\n \t\t\tname.len--;\n \n-\t\tdiri = apk_db_install_directory_entry(ctx, name);\n-\t\tapk_db_dir_prepare(db, diri->dir, ae->mode);\n+\t\tdiri = ctx->diri = find_diri(ipkg, name, NULL, &ctx->file_diri_node);\n+\t\tif (!diri) {\n+\t\t\tdiri = apk_db_install_directory_entry(ctx, name);\n+\t\t\tapk_db_dir_prepare(db, diri->dir, ae->mode);\n+\t\t}\n \t\tapk_db_diri_set(diri, apk_db_acl_atomize(ae->mode, ae->uid, ae->gid, &ae->xattr_csum));\n \t}\n \tctx->installed_size += ctx->current_file_size;\n@@ -2558,7 +2602,7 @@ static int apk_db_install_archive_entry(void *_ctx,\n \n static void apk_db_purge_pkg(struct apk_database *db,\n \t\t\t     struct apk_installed_package *ipkg,\n-\t\t\t     const char *exten)\n+\t\t\t     int is_installed)\n {\n \tstruct apk_db_dir_instance *diri;\n \tstruct apk_db_file *file;\n@@ -2566,17 +2610,16 @@ static void apk_db_purge_pkg(struct apk_database *db,\n \tstruct apk_file_info fi;\n \tstruct hlist_node *dc, *dn, *fc, *fn;\n \tunsigned long hash;\n-\tchar name[PATH_MAX];\n+\tchar name[TMPNAME_MAX];\n \n \thlist_for_each_entry_safe(diri, dc, dn, &ipkg->owned_dirs, pkg_dirs_list) {\n-\t\tif (exten == NULL)\n-\t\t\tdiri->dir->modified = 1;\n+\t\tif (is_installed) diri->dir->modified = 1;\n \n \t\thlist_for_each_entry_safe(file, fc, fn, &diri->owned_files, diri_files_list) {\n-\t\t\tsnprintf(name, sizeof(name),\n-\t\t\t\t DIR_FILE_FMT \"%s\",\n-\t\t\t\t DIR_FILE_PRINTF(diri->dir, file),\n-\t\t\t\t exten ?: \"\");\n+\t\t\tif (is_installed)\n+\t\t\t\tsnprintf(name, sizeof name, DIR_FILE_FMT, DIR_FILE_PRINTF(diri->dir, file));\n+\t\t\telse\n+\t\t\t\tformat_tmpname(ipkg->pkg, file, name);\n \n \t\t\tkey = (struct apk_db_file_hash_key) {\n \t\t\t\t.dirname = APK_BLOB_PTR_LEN(diri->dir->name, diri->dir->namelen),\n@@ -2592,7 +2635,7 @@ static void apk_db_purge_pkg(struct apk_database *db,\n \t\t\tif (apk_verbosity >= 3)\n \t\t\t\tapk_message(\"%s\", name);\n \t\t\t__hlist_del(fc, &diri->owned_files.first);\n-\t\t\tif (exten == NULL) {\n+\t\t\tif (is_installed) {\n \t\t\t\tapk_hash_delete_hashed(&db->installed.files, APK_BLOB_BUF(&key), hash);\n \t\t\t\tdb->installed.stats.files--;\n \t\t\t}\n@@ -2613,7 +2656,7 @@ static void apk_db_migrate_files(struct apk_database *db,\n \tstruct apk_file_info fi;\n \tstruct hlist_node *dc, *dn, *fc, *fn;\n \tunsigned long hash;\n-\tchar name[PATH_MAX], tmpname[PATH_MAX];\n+\tchar name[PATH_MAX], tmpname[TMPNAME_MAX];\n \tint cstype, r;\n \n \thlist_for_each_entry_safe(diri, dc, dn, &ipkg->owned_dirs, pkg_dirs_list) {\n@@ -2621,10 +2664,8 @@ static void apk_db_migrate_files(struct apk_database *db,\n \t\tdir->modified = 1;\n \n \t\thlist_for_each_entry_safe(file, fc, fn, &diri->owned_files, diri_files_list) {\n-\t\t\tsnprintf(name, sizeof(name), DIR_FILE_FMT,\n-\t\t\t\t DIR_FILE_PRINTF(diri->dir, file));\n-\t\t\tsnprintf(tmpname, sizeof(tmpname), DIR_FILE_FMT \".apk-new\",\n-\t\t\t\t DIR_FILE_PRINTF(diri->dir, file));\n+\t\t\tsnprintf(name, sizeof(name), DIR_FILE_FMT, DIR_FILE_PRINTF(diri->dir, file));\n+\t\t\tformat_tmpname(ipkg->pkg, file, tmpname);\n \n \t\t\tkey = (struct apk_db_file_hash_key) {\n \t\t\t\t.dirname = APK_BLOB_PTR_LEN(dir->name, dir->namelen),\n@@ -2665,8 +2706,21 @@ static void apk_db_migrate_files(struct apk_database *db,\n \t\t\t\t\t\tAPK_FI_NOFOLLOW | file->csum.type, &fi);\n \t\t\t\tif ((apk_flags & APK_CLEAN_PROTECTED) ||\n \t\t\t\t    (file->csum.type != APK_CHECKSUM_NONE &&\n-\t\t\t\t     apk_checksum_compare(&file->csum, &fi.csum) == 0))\n+\t\t\t\t     apk_checksum_compare(&file->csum, &fi.csum) == 0)) {\n \t\t\t\t\tunlinkat(db->root_fd, tmpname, 0);\n+\t\t\t\t} else {\n+\t\t\t\t\tsnprintf(name, sizeof name,\n+\t\t\t\t\t\t DIR_FILE_FMT \".apk-new\",\n+\t\t\t\t\t\t DIR_FILE_PRINTF(diri->dir, file));\n+\t\t\t\t\tif (renameat(db->root_fd, tmpname,\n+\t\t\t\t\t\t     db->root_fd, name) != 0) {\n+\t\t\t\t\t\tapk_error(PKG_VER_FMT\": failed to rename %s to %s.\",\n+\t\t\t\t\t\t\t  PKG_VER_PRINTF(ipkg->pkg),\n+\t\t\t\t\t\t\t  tmpname, name);\n+\t\t\t\t\t\tipkg->broken_files = 1;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n \t\t\t} else {\n \t\t\t\t\/* Overwrite the old file *\/\n \t\t\t\tif (renameat(db->root_fd, tmpname,\n@@ -2799,7 +2853,7 @@ int apk_db_install_pkg(struct apk_database *db, struct apk_package *oldpkg,\n \t\tif (ipkg == NULL)\n \t\t\tgoto ret_r;\n \t\tapk_ipkg_run_script(ipkg, db, APK_SCRIPT_PRE_DEINSTALL, script_args);\n-\t\tapk_db_purge_pkg(db, ipkg, NULL);\n+\t\tapk_db_purge_pkg(db, ipkg, TRUE);\n \t\tapk_ipkg_run_script(ipkg, db, APK_SCRIPT_POST_DEINSTALL, script_args);\n \t\tapk_pkg_uninstall(db, oldpkg);\n \t\tgoto ret_r;\n@@ -2822,7 +2876,7 @@ int apk_db_install_pkg(struct apk_database *db, struct apk_package *oldpkg,\n \t\t\t\t      cb, cb_ctx, script_args);\n \t\tif (r != 0) {\n \t\t\tif (oldpkg != newpkg)\n-\t\t\t\tapk_db_purge_pkg(db, ipkg, \".apk-new\");\n+\t\t\t\tapk_db_purge_pkg(db, ipkg, FALSE);\n \t\t\tapk_pkg_uninstall(db, newpkg);\n \t\t\tgoto ret_r;\n \t\t}\n@@ -2830,7 +2884,7 @@ int apk_db_install_pkg(struct apk_database *db, struct apk_package *oldpkg,\n \t}\n \n \tif (oldpkg != NULL && oldpkg != newpkg && oldpkg->ipkg != NULL) {\n-\t\tapk_db_purge_pkg(db, oldpkg->ipkg, NULL);\n+\t\tapk_db_purge_pkg(db, oldpkg->ipkg, TRUE);\n \t\tapk_pkg_uninstall(db, oldpkg);\n \t}\n \ndiff --git a\/src\/gunzip.c b\/src\/gunzip.c\nindex 4fac9fa..2de841b 100644\n--- a\/src\/gunzip.c\n+++ b\/src\/gunzip.c\n@@ -37,6 +37,16 @@ static void gzi_get_meta(void *stream, struct apk_file_meta *meta)\n \tapk_bstream_get_meta(gis->bs, meta);\n }\n \n+static int gzi_boundary_change(struct apk_gzip_istream *gis)\n+{\n+\tint r;\n+\n+\tr = gis->cb(gis->cbctx, gis->err ? APK_MPART_END : APK_MPART_BOUNDARY, gis->cbarg);\n+\tif (r > 0) r = -ECANCELED;\n+\tif (r != 0) gis->err = r;\n+\treturn r;\n+}\n+\n static ssize_t gzi_read(void *stream, void *ptr, size_t size)\n {\n \tstruct apk_gzip_istream *gis =\n@@ -57,15 +67,8 @@ static ssize_t gzi_read(void *stream, void *ptr, size_t size)\n \n \twhile (gis->zs.avail_out != 0 && gis->err == 0) {\n \t\tif (!APK_BLOB_IS_NULL(gis->cbarg)) {\n-\t\t\tr = gis->cb(gis->cbctx,\n-\t\t\t\t    gis->err ? APK_MPART_END : APK_MPART_BOUNDARY,\n-\t\t\t\t    gis->cbarg);\n-\t\t\tif (r > 0)\n-\t\t\t\tr = -ECANCELED;\n-\t\t\tif (r != 0) {\n-\t\t\t\tgis->err = r;\n+\t\t\tif (gzi_boundary_change(gis))\n \t\t\t\tgoto ret;\n-\t\t\t}\n \t\t\tgis->cbarg = APK_BLOB_NULL;\n \t\t}\n \t\tif (gis->zs.avail_in == 0) {\n@@ -86,14 +89,8 @@ static ssize_t gzi_read(void *stream, void *ptr, size_t size)\n \t\t\t\tgoto ret;\n \t\t\t} else if (gis->zs.avail_in == 0) {\n \t\t\t\tgis->err = 1;\n-\t\t\t\tif (gis->cb != NULL) {\n-\t\t\t\t\tr = gis->cb(gis->cbctx, APK_MPART_END,\n-\t\t\t\t\t\t    APK_BLOB_NULL);\n-\t\t\t\t\tif (r > 0)\n-\t\t\t\t\t\tr = -ECANCELED;\n-\t\t\t\t\tif (r != 0)\n-\t\t\t\t\t\tgis->err = r;\n-\t\t\t\t}\n+\t\t\t\tgis->cbarg = APK_BLOB_NULL;\n+\t\t\t\tgzi_boundary_change(gis);\n \t\t\t\tgoto ret;\n \t\t\t}\n \t\t}\n@@ -115,11 +112,7 @@ static ssize_t gzi_read(void *stream, void *ptr, size_t size)\n \t\t\t * For boundaries it should be postponed to not\n \t\t\t * be called until next gzip read is started. *\/\n \t\t\tif (gis->err) {\n-\t\t\t\tr = gis->cb(gis->cbctx,\n-\t\t\t\t\t    gis->err ? APK_MPART_END : APK_MPART_BOUNDARY,\n-\t\t\t\t\t    gis->cbarg);\n-\t\t\t\tif (r > 0)\n-\t\t\t\t\tr = -ECANCELED;\n+\t\t\t\tgzi_boundary_change(gis);\n \t\t\t\tgoto ret;\n \t\t\t}\n \t\t\tinflateEnd(&gis->zs);\ndiff --git a\/src\/package.c b\/src\/package.c\nindex 3be8b84..e19250a 100644\n--- a\/src\/package.c\n+++ b\/src\/package.c\n@@ -476,13 +476,7 @@ void apk_sign_ctx_init(struct apk_sign_ctx *ctx, int action,\n \t\tctx->md = EVP_md_null();\n \t\tbreak;\n \tcase APK_SIGN_VERIFY_IDENTITY:\n-\t\tif (identity->type == APK_CHECKSUM_MD5) {\n-\t\t\tctx->md = EVP_md5();\n-\t\t\tctx->control_started = 1;\n-\t\t\tctx->data_started = 1;\n-\t\t} else {\n-\t\t\tctx->md = EVP_sha1();\n-\t\t}\n+\t\tctx->md = EVP_sha1();\n \t\tmemcpy(&ctx->identity, identity, sizeof(ctx->identity));\n \t\tbreak;\n \tcase APK_SIGN_GENERATE:\n@@ -552,6 +546,9 @@ int apk_sign_ctx_process_file(struct apk_sign_ctx *ctx,\n \t\t * style .PKGINFO *\/\n \t\tif (ctx->has_data_checksum)\n \t\t\treturn -ENOMSG;\n+\t\t\/* Error out early if identity part is missing *\/\n+\t\tif (ctx->action == APK_SIGN_VERIFY_IDENTITY)\n+\t\t\treturn -EKEYREJECTED;\n \t\tctx->data_started = 1;\n \t\tctx->control_started = 1;\n \t\tr = check_signing_key_trust(ctx);\n-- \ncgit v1.2.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-0623","CWE_ID":"20","category":"security","commit_id":"5ecb01cfdf96c5f465192bdb2a4fd4a61a24c6cc","commit_message":"From 5ecb01cfdf96c5f465192bdb2a4fd4a61a24c6cc Mon Sep 17 00:00:00 2001\nFrom: Mikael Pettersson <mikpe@it.uu.se>\nDate: Sat, 23 Jan 2010 22:36:29 +0100\nSubject: futex_lock_pi() key refcnt fix\n\nThis fixes a futex key reference count bug in futex_lock_pi(),\nwhere a key's reference count is incremented twice but decremented\nonly once, causing the backing object to not be released.\n\nIf the futex is created in a temporary file in an ext3 file system,\nthis bug causes the file's inode to become an \"undead\" orphan,\nwhich causes an oops from a BUG_ON() in ext3_put_super() when the\nfile system is unmounted. glibc's test suite is known to trigger this,\nsee <http:\/\/bugzilla.kernel.org\/show_bug.cgi?id=14256>.\n\nThe bug is a regression from 2.6.28-git3, namely Peter Zijlstra's\n38d47c1b7075bd7ec3881141bb3629da58f88dab \"[PATCH] futex: rely on\nget_user_pages() for shared futexes\". That commit made get_futex_key()\nalso increment the reference count of the futex key, and updated its\ncallers to decrement the key's reference count before returning.\nUnfortunately the normal exit path in futex_lock_pi() wasn't corrected:\nthe reference count is incremented by get_futex_key() and queue_lock(),\nbut the normal exit path only decrements once, via unqueue_me_pi().\nThe fix is to put_futex_key() after unqueue_me_pi(), since 2.6.31\nthis is easily done by 'goto out_put_key' rather than 'goto out'.\n\nSigned-off-by: Mikael Pettersson <mikpe@it.uu.se>\nAcked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>\nAcked-by: Darren Hart <dvhltc@us.ibm.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: <stable@kernel.org>\n---\n kernel\/futex.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/kernel\/futex.c b\/kernel\/futex.c\nindex d9b3a2228f9d..17828033a639 100644\n--- a\/kernel\/futex.c\n+++ b\/kernel\/futex.c\n@@ -1971,7 +1971,7 @@ retry_private:\n \t\/* Unqueue and drop the lock *\/\n \tunqueue_me_pi(&q);\n \n-\tgoto out;\n+\tgoto out_put_key;\n \n out_unlock_put_key:\n \tqueue_unlock(&q, hb);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9141","CWE_ID":"20","category":"security","commit_id":"f5910e91b0778e03ded45b9022be8eb8f77942cd","commit_message":"From f5910e91b0778e03ded45b9022be8eb8f77942cd Mon Sep 17 00:00:00 2001\nFrom: Dirk Lemstra <dirk@git.imagemagick.org>\nDate: Mon, 15 May 2017 21:10:19 +0200\nSubject: [PATCH] Added check to prevent image being 0x0 (reported in #489).\n\n---\n coders\/dds.c | 6 ++++--\n 1 file changed, 4 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/coders\/dds.c b\/coders\/dds.c\nindex 9733de17a2..abe010572f 100644\n--- a\/coders\/dds.c\n+++ b\/coders\/dds.c\n@@ -1673,9 +1673,8 @@ static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   \/*\n     Initialize image structure.\n   *\/\n-  if (ReadDDSInfo(image, &dds_info) != MagickTrue) {\n+  if (ReadDDSInfo(image, &dds_info) != MagickTrue)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n-  }\n \n   if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)\n     cubemap = MagickTrue;\n@@ -1772,6 +1771,9 @@ static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   if (volume)\n     num_images = dds_info.depth;\n \n+  if (num_images < 1)\n+    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+\n   for (n = 0; n < num_images; n++)\n   {\n     if (n != 0)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-4544","CWE_ID":"20","category":"security","commit_id":"f12d048a523780dbda702027d4a91b62af1a08d7","commit_message":"From f12d048a523780dbda702027d4a91b62af1a08d7 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Fleytman <dmitry@daynix.com>\nDate: Fri, 4 Apr 2014 12:45:22 +0300\nSubject: [PATCH] vmxnet3: validate queues configuration read on migration\n\nCVE-2013-4544\n\nSigned-off-by: Dmitry Fleytman <dmitry@daynix.com>\nReported-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Dr. David Alan Gilbert <dgilbert@redhat.com>\nMessage-id: 1396604722-11902-5-git-send-email-dmitry@daynix.com\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>\n---\n hw\/net\/vmxnet3.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/hw\/net\/vmxnet3.c b\/hw\/net\/vmxnet3.c\nindex a0723c0..ddcee4b 100644\n--- a\/hw\/net\/vmxnet3.c\n+++ b\/hw\/net\/vmxnet3.c\n@@ -2391,6 +2391,7 @@ static int vmxnet3_post_load(void *opaque, int version_id)\n         }\n     }\n \n+    vmxnet3_validate_queues(s);\n     vmxnet3_validate_interrupts(s);\n \n     return 0;\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9584","CWE_ID":"20","category":"security","commit_id":"4e2024624e678f0ebb916e6192bd23c1f9fdf696","commit_message":"From 4e2024624e678f0ebb916e6192bd23c1f9fdf696 Mon Sep 17 00:00:00 2001\nFrom: Jan Kara <jack@suse.cz>\nDate: Thu, 18 Dec 2014 17:26:10 +0100\nSubject: [PATCH] isofs: Fix unchecked printing of ER records\n\nWe didn't check length of rock ridge ER records before printing them.\nThus corrupted isofs image can cause us to access and print some memory\nbehind the buffer with obvious consequences.\n\nReported-and-tested-by: Carl Henrik Lunde <chlunde@ping.uio.no>\nCC: stable@vger.kernel.org\nSigned-off-by: Jan Kara <jack@suse.cz>\n---\n fs\/isofs\/rock.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/fs\/isofs\/rock.c b\/fs\/isofs\/rock.c\nindex bb63254ed8486..735d7522a3a91 100644\n--- a\/fs\/isofs\/rock.c\n+++ b\/fs\/isofs\/rock.c\n@@ -362,6 +362,9 @@ parse_rock_ridge_inode_internal(struct iso_directory_record *de,\n \t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n \t\t\tbreak;\n \t\tcase SIG('E', 'R'):\n+\t\t\t\/* Invalid length of ER tag id? *\/\n+\t\t\tif (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)\n+\t\t\t\tgoto out;\n \t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n \t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n \t\t\t{\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-0216","CWE_ID":"20","category":"security","commit_id":"48856286b64e4b66ec62b94e504d0b29c1ade664","commit_message":"From 48856286b64e4b66ec62b94e504d0b29c1ade664 Mon Sep 17 00:00:00 2001\nFrom: Ian Campbell <Ian.Campbell@citrix.com>\nDate: Wed, 6 Feb 2013 23:41:35 +0000\nSubject: [PATCH] xen\/netback: shutdown the ring if it contains garbage.\n\nA buggy or malicious frontend should not be able to confuse netback.\nIf we spot anything which is not as it should be then shutdown the\ndevice and don't try to continue with the ring in a potentially\nhostile state. Well behaved and non-hostile frontends will not be\npenalised.\n\nAs well as making the existing checks for such errors fatal also add a\nnew check that ensures that there isn't an insane number of requests\non the ring (i.e. more than would fit in the ring). If the ring\ncontains garbage then previously is was possible to loop over this\ninsane number, getting an error each time and therefore not generating\nany more pending requests and therefore not exiting the loop in\nxen_netbk_tx_build_gops for an externded period.\n\nAlso turn various netdev_dbg calls which no precipitate a fatal error\ninto netdev_err, they are rate limited because the device is shutdown\nafterwards.\n\nThis fixes at least one known DoS\/softlockup of the backend domain.\n\nSigned-off-by: Ian Campbell <ian.campbell@citrix.com>\nReviewed-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>\nAcked-by: Jan Beulich <JBeulich@suse.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/xen-netback\/common.h    |  3 ++\n drivers\/net\/xen-netback\/interface.c | 23 ++++++-----\n drivers\/net\/xen-netback\/netback.c   | 62 +++++++++++++++++++++--------\n 3 files changed, 62 insertions(+), 26 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/xen-netback\/common.h b\/drivers\/net\/xen-netback\/common.h\nindex 94b79c3338c42..9d7f1723dd8f7 100644\n--- a\/drivers\/net\/xen-netback\/common.h\n+++ b\/drivers\/net\/xen-netback\/common.h\n@@ -151,6 +151,9 @@ void xen_netbk_queue_tx_skb(struct xenvif *vif, struct sk_buff *skb);\n \/* Notify xenvif that ring now has space to send an skb to the frontend *\/\n void xenvif_notify_tx_completion(struct xenvif *vif);\n \n+\/* Prevent the device from generating any further traffic. *\/\n+void xenvif_carrier_off(struct xenvif *vif);\n+\n \/* Returns number of ring slots required to send an skb to the frontend *\/\n unsigned int xen_netbk_count_skb_slots(struct xenvif *vif, struct sk_buff *skb);\n \ndiff --git a\/drivers\/net\/xen-netback\/interface.c b\/drivers\/net\/xen-netback\/interface.c\nindex b7d41f8c338a8..b8c5193bd4200 100644\n--- a\/drivers\/net\/xen-netback\/interface.c\n+++ b\/drivers\/net\/xen-netback\/interface.c\n@@ -343,17 +343,22 @@ int xenvif_connect(struct xenvif *vif, unsigned long tx_ring_ref,\n \treturn err;\n }\n \n-void xenvif_disconnect(struct xenvif *vif)\n+void xenvif_carrier_off(struct xenvif *vif)\n {\n \tstruct net_device *dev = vif->dev;\n-\tif (netif_carrier_ok(dev)) {\n-\t\trtnl_lock();\n-\t\tnetif_carrier_off(dev); \/* discard queued packets *\/\n-\t\tif (netif_running(dev))\n-\t\t\txenvif_down(vif);\n-\t\trtnl_unlock();\n-\t\txenvif_put(vif);\n-\t}\n+\n+\trtnl_lock();\n+\tnetif_carrier_off(dev); \/* discard queued packets *\/\n+\tif (netif_running(dev))\n+\t\txenvif_down(vif);\n+\trtnl_unlock();\n+\txenvif_put(vif);\n+}\n+\n+void xenvif_disconnect(struct xenvif *vif)\n+{\n+\tif (netif_carrier_ok(vif->dev))\n+\t\txenvif_carrier_off(vif);\n \n \tatomic_dec(&vif->refcnt);\n \twait_event(vif->waiting_to_free, atomic_read(&vif->refcnt) == 0);\ndiff --git a\/drivers\/net\/xen-netback\/netback.c b\/drivers\/net\/xen-netback\/netback.c\nindex f2d6b78d901d9..c2e3336b4f98a 100644\n--- a\/drivers\/net\/xen-netback\/netback.c\n+++ b\/drivers\/net\/xen-netback\/netback.c\n@@ -888,6 +888,13 @@ static void netbk_tx_err(struct xenvif *vif,\n \txenvif_put(vif);\n }\n \n+static void netbk_fatal_tx_err(struct xenvif *vif)\n+{\n+\tnetdev_err(vif->dev, \"fatal error; disabling device\\n\");\n+\txenvif_carrier_off(vif);\n+\txenvif_put(vif);\n+}\n+\n static int netbk_count_requests(struct xenvif *vif,\n \t\t\t\tstruct xen_netif_tx_request *first,\n \t\t\t\tstruct xen_netif_tx_request *txp,\n@@ -901,19 +908,22 @@ static int netbk_count_requests(struct xenvif *vif,\n \n \tdo {\n \t\tif (frags >= work_to_do) {\n-\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n+\t\t\tnetdev_err(vif->dev, \"Need more frags\\n\");\n+\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\treturn -frags;\n \t\t}\n \n \t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n-\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n+\t\t\tnetdev_err(vif->dev, \"Too many frags\\n\");\n+\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\treturn -frags;\n \t\t}\n \n \t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n \t\t       sizeof(*txp));\n \t\tif (txp->size > first->size) {\n-\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n+\t\t\tnetdev_err(vif->dev, \"Frag is bigger than frame.\\n\");\n+\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\treturn -frags;\n \t\t}\n \n@@ -921,8 +931,9 @@ static int netbk_count_requests(struct xenvif *vif,\n \t\tfrags++;\n \n \t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n-\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n+\t\t\tnetdev_err(vif->dev, \"txp->offset: %x, size: %u\\n\",\n \t\t\t\t txp->offset, txp->size);\n+\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\treturn -frags;\n \t\t}\n \t} while ((txp++)->flags & XEN_NETTXF_more_data);\n@@ -1095,7 +1106,8 @@ static int xen_netbk_get_extras(struct xenvif *vif,\n \n \tdo {\n \t\tif (unlikely(work_to_do-- <= 0)) {\n-\t\t\tnetdev_dbg(vif->dev, \"Missing extra info\\n\");\n+\t\t\tnetdev_err(vif->dev, \"Missing extra info\\n\");\n+\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\treturn -EBADR;\n \t\t}\n \n@@ -1104,8 +1116,9 @@ static int xen_netbk_get_extras(struct xenvif *vif,\n \t\tif (unlikely(!extra.type ||\n \t\t\t     extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\n \t\t\tvif->tx.req_cons = ++cons;\n-\t\t\tnetdev_dbg(vif->dev,\n+\t\t\tnetdev_err(vif->dev,\n \t\t\t\t   \"Invalid extra type: %d\\n\", extra.type);\n+\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\treturn -EINVAL;\n \t\t}\n \n@@ -1121,13 +1134,15 @@ static int netbk_set_skb_gso(struct xenvif *vif,\n \t\t\t     struct xen_netif_extra_info *gso)\n {\n \tif (!gso->u.gso.size) {\n-\t\tnetdev_dbg(vif->dev, \"GSO size must not be zero.\\n\");\n+\t\tnetdev_err(vif->dev, \"GSO size must not be zero.\\n\");\n+\t\tnetbk_fatal_tx_err(vif);\n \t\treturn -EINVAL;\n \t}\n \n \t\/* Currently only TCPv4 S.O. is supported. *\/\n \tif (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) {\n-\t\tnetdev_dbg(vif->dev, \"Bad GSO type %d.\\n\", gso->u.gso.type);\n+\t\tnetdev_err(vif->dev, \"Bad GSO type %d.\\n\", gso->u.gso.type);\n+\t\tnetbk_fatal_tx_err(vif);\n \t\treturn -EINVAL;\n \t}\n \n@@ -1264,9 +1279,25 @@ static unsigned xen_netbk_tx_build_gops(struct xen_netbk *netbk)\n \n \t\t\/* Get a netif from the list with work to do. *\/\n \t\tvif = poll_net_schedule_list(netbk);\n+\t\t\/* This can sometimes happen because the test of\n+\t\t * list_empty(net_schedule_list) at the top of the\n+\t\t * loop is unlocked.  Just go back and have another\n+\t\t * look.\n+\t\t *\/\n \t\tif (!vif)\n \t\t\tcontinue;\n \n+\t\tif (vif->tx.sring->req_prod - vif->tx.req_cons >\n+\t\t    XEN_NETIF_TX_RING_SIZE) {\n+\t\t\tnetdev_err(vif->dev,\n+\t\t\t\t   \"Impossible number of requests. \"\n+\t\t\t\t   \"req_prod %d, req_cons %d, size %ld\\n\",\n+\t\t\t\t   vif->tx.sring->req_prod, vif->tx.req_cons,\n+\t\t\t\t   XEN_NETIF_TX_RING_SIZE);\n+\t\t\tnetbk_fatal_tx_err(vif);\n+\t\t\tcontinue;\n+\t\t}\n+\n \t\tRING_FINAL_CHECK_FOR_REQUESTS(&vif->tx, work_to_do);\n \t\tif (!work_to_do) {\n \t\t\txenvif_put(vif);\n@@ -1294,17 +1325,14 @@ static unsigned xen_netbk_tx_build_gops(struct xen_netbk *netbk)\n \t\t\twork_to_do = xen_netbk_get_extras(vif, extras,\n \t\t\t\t\t\t\t  work_to_do);\n \t\t\tidx = vif->tx.req_cons;\n-\t\t\tif (unlikely(work_to_do < 0)) {\n-\t\t\t\tnetbk_tx_err(vif, &txreq, idx);\n+\t\t\tif (unlikely(work_to_do < 0))\n \t\t\t\tcontinue;\n-\t\t\t}\n \t\t}\n \n \t\tret = netbk_count_requests(vif, &txreq, txfrags, work_to_do);\n-\t\tif (unlikely(ret < 0)) {\n-\t\t\tnetbk_tx_err(vif, &txreq, idx - ret);\n+\t\tif (unlikely(ret < 0))\n \t\t\tcontinue;\n-\t\t}\n+\n \t\tidx += ret;\n \n \t\tif (unlikely(txreq.size < ETH_HLEN)) {\n@@ -1316,11 +1344,11 @@ static unsigned xen_netbk_tx_build_gops(struct xen_netbk *netbk)\n \n \t\t\/* No crossing a page as the payload mustn't fragment. *\/\n \t\tif (unlikely((txreq.offset + txreq.size) > PAGE_SIZE)) {\n-\t\t\tnetdev_dbg(vif->dev,\n+\t\t\tnetdev_err(vif->dev,\n \t\t\t\t   \"txreq.offset: %x, size: %u, end: %lu\\n\",\n \t\t\t\t   txreq.offset, txreq.size,\n \t\t\t\t   (txreq.offset&~PAGE_MASK) + txreq.size);\n-\t\t\tnetbk_tx_err(vif, &txreq, idx);\n+\t\t\tnetbk_fatal_tx_err(vif);\n \t\t\tcontinue;\n \t\t}\n \n@@ -1348,8 +1376,8 @@ static unsigned xen_netbk_tx_build_gops(struct xen_netbk *netbk)\n \t\t\tgso = &extras[XEN_NETIF_EXTRA_TYPE_GSO - 1];\n \n \t\t\tif (netbk_set_skb_gso(vif, skb, gso)) {\n+\t\t\t\t\/* Failure in netbk_set_skb_gso is fatal. *\/\n \t\t\t\tkfree_skb(skb);\n-\t\t\t\tnetbk_tx_err(vif, &txreq, idx);\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2019-10672","CWE_ID":"20","category":"security","commit_id":"d39a171e9c6a1c44dbdf43f9db6c3fbd887e38c1","commit_message":"From d39a171e9c6a1c44dbdf43f9db6c3fbd887e38c1 Mon Sep 17 00:00:00 2001\nFrom: Christian Hoene <christian.hoene@symonics.com>\nDate: Sun, 31 Mar 2019 15:57:14 +0200\nSubject: [PATCH] Fixed security issue 1\n\n---\n src\/hdf\/btree.c | 12 ++++++------\n 1 file changed, 6 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/src\/hdf\/btree.c b\/src\/hdf\/btree.c\nindex 41eb1ea..543da48 100644\n--- a\/src\/hdf\/btree.c\n+++ b\/src\/hdf\/btree.c\n@@ -307,8 +307,8 @@ int treeRead(struct READER *reader, struct DATAOBJECT *data) {\n \t\t\t\tfor (i = 0; i < olen; i++) {\n \t\t\t\t\tb = i \/ elements;\n \t\t\t\t\tx = i % elements + start[0];\n-\t\t\t\t\tif (x < sx) {\n-\t\t\t\t\t\tj = x * size + b;\n+\t\t\t\t\tj = x * size + b;\n+\t\t\t\t\tif (j>=0 && j < elements * size) {\n \t\t\t\t\t\t((char*)data->data)[j] = output[i];\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -319,8 +319,8 @@ int treeRead(struct READER *reader, struct DATAOBJECT *data) {\n \t\t\t\t\tx = i % elements;\n \t\t\t\t\ty = x % dy + start[1];\n \t\t\t\t\tx = x \/ dy + start[0];\n-\t\t\t\t\tif (y < sy && x < sx) {\n-\t\t\t\t\t\tj = ((x * sy + y) * size) + b;\n+\t\t\t\t\tj = ((x * sy + y) * size) + b;\n+\t\t\t\t\tif (j>=0 && j < elements * size) {\n \t\t\t\t\t\t((char*)data->data)[j] = output[i];\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -332,8 +332,8 @@ int treeRead(struct READER *reader, struct DATAOBJECT *data) {\n \t\t\t\t\tz = x % dz + start[2];\n \t\t\t\t\ty = (x \/ dz) % dy + start[1];\n \t\t\t\t\tx = (x \/ dzy) + start[0];\n-\t\t\t\t\tif (z < sz && y < sy && x < sx) {\n-\t\t\t\t\t\tj = (x * szy + y * sz + z) * size + b;\n+\t\t\t\t\tj = (x * szy + y * sz + z) * size + b;\n+\t\t\t\t\tif (j>=0 && j < elements * size) {\n \t\t\t\t\t\t((char*)data->data)[j] = output[i];\n \t\t\t\t\t}\n \t\t\t\t}\n","owner":"hoene","repo":"libmysofa","source":"cve"},{"CVE_ID":"CVE-2016-7417","CWE_ID":"20","category":"security","commit_id":"ecb7f58a069be0dec4a6131b6351a761f808f22e","commit_message":"From ecb7f58a069be0dec4a6131b6351a761f808f22e Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sun, 11 Sep 2016 20:24:13 -0700\nSubject: [PATCH] Fix bug #73029 - Missing type check when unserializing\n SplArray\n\n---\n ext\/spl\/spl_array.c         | 10 ++++++----\n ext\/spl\/tests\/bug73029.phpt | 16 ++++++++++++++++\n 2 files changed, 22 insertions(+), 4 deletions(-)\n create mode 100644 ext\/spl\/tests\/bug73029.phpt\n\n","diff_code":"diff --git a\/ext\/spl\/spl_array.c b\/ext\/spl\/spl_array.c\nindex 42a8e7aa4498..700d6093dd51 100644\n--- a\/ext\/spl\/spl_array.c\n+++ b\/ext\/spl\/spl_array.c\n@@ -308,7 +308,7 @@ static zval **spl_array_get_dimension_ptr_ptr(int check_inherited, zval *object,\n \tlong index;\n \tHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n \n-\tif (!offset) {\n+\tif (!offset || !ht) {\n \t\treturn &EG(uninitialized_zval_ptr);\n \t}\n \n@@ -626,7 +626,7 @@ static int spl_array_has_dimension_ex(int check_inherited, zval *object, zval *o\n \t\tHashTable *ht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n \n \t\tswitch(Z_TYPE_P(offset)) {\n-\t\t\tcase IS_STRING: \n+\t\t\tcase IS_STRING:\n \t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, (void **) &tmp) != FAILURE) {\n \t\t\t\t\tif (check_empty == 2) {\n \t\t\t\t\t\treturn 1;\n@@ -638,7 +638,7 @@ static int spl_array_has_dimension_ex(int check_inherited, zval *object, zval *o\n \n \t\t\tcase IS_DOUBLE:\n \t\t\tcase IS_RESOURCE:\n-\t\t\tcase IS_BOOL: \n+\t\t\tcase IS_BOOL:\n \t\t\tcase IS_LONG:\n \t\t\t\tif (offset->type == IS_DOUBLE) {\n \t\t\t\t\tindex = (long)Z_DVAL_P(offset);\n@@ -1810,7 +1810,9 @@ SPL_METHOD(Array, unserialize)\n \t\tintern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;\n \t\tzval_ptr_dtor(&intern->array);\n \t\tALLOC_INIT_ZVAL(intern->array);\n-\t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n+\t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)\n+\t\t\t\t|| (Z_TYPE_P(intern->array) != IS_ARRAY && Z_TYPE_P(intern->array) != IS_OBJECT)) {\n+\t\t\tzval_ptr_dtor(&intern->array);\n \t\t\tgoto outexcept;\n \t\t}\n \t\tvar_push_dtor(&var_hash, &intern->array);\ndiff --git a\/ext\/spl\/tests\/bug73029.phpt b\/ext\/spl\/tests\/bug73029.phpt\nnew file mode 100644\nindex 000000000000..a379f8005e48\n--- \/dev\/null\n+++ b\/ext\/spl\/tests\/bug73029.phpt\n@@ -0,0 +1,16 @@\n+--TEST--\n+Bug #73029: Missing type check when unserializing SplArray\n+--FILE--\n+<?php\n+try {\n+$a = 'C:11:\"ArrayObject\":19:0x:i:0;r:2;;m:a:0:{}}';\n+$m = unserialize($a);\n+$x = $m[2];\n+} catch(UnexpectedValueException $e) {\n+\tprint $e->getMessage() . \"\\n\";\n+}\n+?>\n+DONE\n+--EXPECTF--\n+Error at offset 10 of 19 bytes\n+DONE\n","owner":"php","repo":"php-src","source":"cve"},{"CVE_ID":"CVE-2013-4129","CWE_ID":"20","category":"security","commit_id":"c7e8e8a8f7a70b343ca1e0f90a31e35ab2d16de1","commit_message":"From c7e8e8a8f7a70b343ca1e0f90a31e35ab2d16de1 Mon Sep 17 00:00:00 2001\nFrom: Cong Wang <amwang@redhat.com>\nDate: Fri, 5 Jul 2013 19:36:17 +0800\nSubject: bridge: fix some kernel warning in multicast timer\n\nSeveral people reported the warning: \"kernel BUG at kernel\/timer.c:729!\"\nand the stack trace is:\n\n\t#7 [ffff880214d25c10] mod_timer+501 at ffffffff8106d905\n\t#8 [ffff880214d25c50] br_multicast_del_pg.isra.20+261 at ffffffffa0731d25 [bridge]\n\t#9 [ffff880214d25c80] br_multicast_disable_port+88 at ffffffffa0732948 [bridge]\n\t#10 [ffff880214d25cb0] br_stp_disable_port+154 at ffffffffa072bcca [bridge]\n\t#11 [ffff880214d25ce8] br_device_event+520 at ffffffffa072a4e8 [bridge]\n\t#12 [ffff880214d25d18] notifier_call_chain+76 at ffffffff8164aafc\n\t#13 [ffff880214d25d50] raw_notifier_call_chain+22 at ffffffff810858f6\n\t#14 [ffff880214d25d60] call_netdevice_notifiers+45 at ffffffff81536aad\n\t#15 [ffff880214d25d80] dev_close_many+183 at ffffffff81536d17\n\t#16 [ffff880214d25dc0] rollback_registered_many+168 at ffffffff81537f68\n\t#17 [ffff880214d25de8] rollback_registered+49 at ffffffff81538101\n\t#18 [ffff880214d25e10] unregister_netdevice_queue+72 at ffffffff815390d8\n\t#19 [ffff880214d25e30] __tun_detach+272 at ffffffffa074c2f0 [tun]\n\t#20 [ffff880214d25e88] tun_chr_close+45 at ffffffffa074c4bd [tun]\n\t#21 [ffff880214d25ea8] __fput+225 at ffffffff8119b1f1\n\t#22 [ffff880214d25ef0] ____fput+14 at ffffffff8119b3fe\n\t#23 [ffff880214d25f00] task_work_run+159 at ffffffff8107cf7f\n\t#24 [ffff880214d25f30] do_notify_resume+97 at ffffffff810139e1\n\t#25 [ffff880214d25f50] int_signal+18 at ffffffff8164f292\n\nthis is due to I forgot to check if mp->timer is armed in\nbr_multicast_del_pg(). This bug is introduced by\ncommit 9f00b2e7cf241fa389733d41b6 (bridge: only expire the mdb entry\nwhen query is received).\n\nSame for __br_mdb_del().\n\nTested-by: poma <pomidorabelisima@gmail.com>\nReported-by: LiYonghua <809674045@qq.com>\nReported-by: Robert Hancock <hancockrwd@gmail.com>\nCc: Herbert Xu <herbert@gondor.apana.org.au>\nCc: Stephen Hemminger <stephen@networkplumber.org>\nCc: \"David S. Miller\" <davem@davemloft.net>\nSigned-off-by: Cong Wang <amwang@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/bridge\/br_mdb.c       | 2 +-\n net\/bridge\/br_multicast.c | 2 +-\n 2 files changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/net\/bridge\/br_mdb.c b\/net\/bridge\/br_mdb.c\nindex 19942e38fd2d..0daae3ec2355 100644\n--- a\/net\/bridge\/br_mdb.c\n+++ b\/net\/bridge\/br_mdb.c\n@@ -447,7 +447,7 @@ static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n \t\terr = 0;\n \n-\t\tif (!mp->ports && !mp->mglist &&\n+\t\tif (!mp->ports && !mp->mglist && mp->timer_armed &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n \t\tbreak;\ndiff --git a\/net\/bridge\/br_multicast.c b\/net\/bridge\/br_multicast.c\nindex 81befac015e1..69af490cce44 100644\n--- a\/net\/bridge\/br_multicast.c\n+++ b\/net\/bridge\/br_multicast.c\n@@ -270,7 +270,7 @@ static void br_multicast_del_pg(struct net_bridge *br,\n \t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n \n-\t\tif (!mp->ports && !mp->mglist &&\n+\t\tif (!mp->ports && !mp->mglist && mp->timer_armed &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2018-14641","CWE_ID":"20","category":"security","commit_id":"5d407b071dc369c26a38398326ee2be53651cfe4","commit_message":"From 5d407b071dc369c26a38398326ee2be53651cfe4 Mon Sep 17 00:00:00 2001\nFrom: Taehee Yoo <ap420073@gmail.com>\nDate: Mon, 10 Sep 2018 02:47:05 +0900\nSubject: ip: frags: fix crash in ip_do_fragment()\n\nA kernel crash occurrs when defragmented packet is fragmented\nin ip_do_fragment().\nIn defragment routine, skb_orphan() is called and\nskb->ip_defrag_offset is set. but skb->sk and\nskb->ip_defrag_offset are same union member. so that\nfrag->sk is not NULL.\nHence crash occurrs in skb->sk check routine in ip_do_fragment() when\ndefragmented packet is fragmented.\n\ntest commands:\n   %iptables -t nat -I POSTROUTING -j MASQUERADE\n   %hping3 192.168.4.2 -s 1000 -p 2000 -d 60000\n\nsplat looks like:\n[  261.069429] kernel BUG at net\/ipv4\/ip_output.c:636!\n[  261.075753] invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI\n[  261.083854] CPU: 1 PID: 1349 Comm: hping3 Not tainted 4.19.0-rc2+ #3\n[  261.100977] RIP: 0010:ip_do_fragment+0x1613\/0x2600\n[  261.106945] Code: e8 e2 38 e3 fe 4c 8b 44 24 18 48 8b 74 24 08 e9 92 f6 ff ff 80 3c 02 00 0f 85 da 07 00 00 48 8b b5 d0 00 00 00 e9 25 f6 ff ff <0f> 0b 0f 0b 44 8b 54 24 58 4c 8b 4c 24 18 4c 8b 5c 24 60 4c 8b 6c\n[  261.127015] RSP: 0018:ffff8801031cf2c0 EFLAGS: 00010202\n[  261.134156] RAX: 1ffff1002297537b RBX: ffffed0020639e6e RCX: 0000000000000004\n[  261.142156] RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff880114ba9bd8\n[  261.150157] RBP: ffff880114ba8a40 R08: ffffed0022975395 R09: ffffed0022975395\n[  261.158157] R10: 0000000000000001 R11: ffffed0022975394 R12: ffff880114ba9ca4\n[  261.166159] R13: 0000000000000010 R14: ffff880114ba9bc0 R15: dffffc0000000000\n[  261.174169] FS:  00007fbae2199700(0000) GS:ffff88011b400000(0000) knlGS:0000000000000000\n[  261.183012] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  261.189013] CR2: 00005579244fe000 CR3: 0000000119bf4000 CR4: 00000000001006e0\n[  261.198158] Call Trace:\n[  261.199018]  ? dst_output+0x180\/0x180\n[  261.205011]  ? save_trace+0x300\/0x300\n[  261.209018]  ? ip_copy_metadata+0xb00\/0xb00\n[  261.213034]  ? sched_clock_local+0xd4\/0x140\n[  261.218158]  ? kill_l4proto+0x120\/0x120 [nf_conntrack]\n[  261.223014]  ? rt_cpu_seq_stop+0x10\/0x10\n[  261.227014]  ? find_held_lock+0x39\/0x1c0\n[  261.233008]  ip_finish_output+0x51d\/0xb50\n[  261.237006]  ? ip_fragment.constprop.56+0x220\/0x220\n[  261.243011]  ? nf_ct_l4proto_register_one+0x5b0\/0x5b0 [nf_conntrack]\n[  261.250152]  ? rcu_is_watching+0x77\/0x120\n[  261.255010]  ? nf_nat_ipv4_out+0x1e\/0x2b0 [nf_nat_ipv4]\n[  261.261033]  ? nf_hook_slow+0xb1\/0x160\n[  261.265007]  ip_output+0x1c7\/0x710\n[  261.269005]  ? ip_mc_output+0x13f0\/0x13f0\n[  261.273002]  ? __local_bh_enable_ip+0xe9\/0x1b0\n[  261.278152]  ? ip_fragment.constprop.56+0x220\/0x220\n[  261.282996]  ? nf_hook_slow+0xb1\/0x160\n[  261.287007]  raw_sendmsg+0x21f9\/0x4420\n[  261.291008]  ? dst_output+0x180\/0x180\n[  261.297003]  ? sched_clock_cpu+0x126\/0x170\n[  261.301003]  ? find_held_lock+0x39\/0x1c0\n[  261.306155]  ? stop_critical_timings+0x420\/0x420\n[  261.311004]  ? check_flags.part.36+0x450\/0x450\n[  261.315005]  ? _raw_spin_unlock_irq+0x29\/0x40\n[  261.320995]  ? _raw_spin_unlock_irq+0x29\/0x40\n[  261.326142]  ? cyc2ns_read_end+0x10\/0x10\n[  261.330139]  ? raw_bind+0x280\/0x280\n[  261.334138]  ? sched_clock_cpu+0x126\/0x170\n[  261.338995]  ? check_flags.part.36+0x450\/0x450\n[  261.342991]  ? __lock_acquire+0x4500\/0x4500\n[  261.348994]  ? inet_sendmsg+0x11c\/0x500\n[  261.352989]  ? dst_output+0x180\/0x180\n[  261.357012]  inet_sendmsg+0x11c\/0x500\n[ ... ]\n\nv2:\n - clear skb->sk at reassembly routine.(Eric Dumarzet)\n\nFixes: fa0f527358bd (\"ip: use rb trees for IP frag queue.\")\nSuggested-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: Taehee Yoo <ap420073@gmail.com>\nReviewed-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/ipv4\/ip_fragment.c                  | 1 +\n net\/ipv6\/netfilter\/nf_conntrack_reasm.c | 1 +\n 2 files changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/net\/ipv4\/ip_fragment.c b\/net\/ipv4\/ip_fragment.c\nindex 88281fbce88c..e7227128df2c 100644\n--- a\/net\/ipv4\/ip_fragment.c\n+++ b\/net\/ipv4\/ip_fragment.c\n@@ -599,6 +599,7 @@ static int ip_frag_reasm(struct ipq *qp, struct sk_buff *skb,\n \t\t\tnextp = &fp->next;\n \t\t\tfp->prev = NULL;\n \t\t\tmemset(&fp->rbnode, 0, sizeof(fp->rbnode));\n+\t\t\tfp->sk = NULL;\n \t\t\thead->data_len += fp->len;\n \t\t\thead->len += fp->len;\n \t\t\tif (head->ip_summed != fp->ip_summed)\ndiff --git a\/net\/ipv6\/netfilter\/nf_conntrack_reasm.c b\/net\/ipv6\/netfilter\/nf_conntrack_reasm.c\nindex 2a14d8b65924..8f68a518d9db 100644\n--- a\/net\/ipv6\/netfilter\/nf_conntrack_reasm.c\n+++ b\/net\/ipv6\/netfilter\/nf_conntrack_reasm.c\n@@ -445,6 +445,7 @@ nf_ct_frag6_reasm(struct frag_queue *fq, struct sk_buff *prev,  struct net_devic\n \t\telse if (head->ip_summed == CHECKSUM_COMPLETE)\n \t\t\thead->csum = csum_add(head->csum, fp->csum);\n \t\thead->truesize += fp->truesize;\n+\t\tfp->sk = NULL;\n \t}\n \tsub_frag_mem_limit(fq->q.net, head->truesize);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-5932","CWE_ID":"20","category":"security","commit_id":"4f747edc625815f449048579f6e65869914dd715","commit_message":"From 4f747edc625815f449048579f6e65869914dd715 Mon Sep 17 00:00:00 2001\nFrom: Chet Ramey <chet.ramey@case.edu>\nDate: Fri, 20 Jan 2017 11:47:55 -0500\nSubject: Bash-4.4 patch 7\n\n---\n bashline.c   | 22 ++++++++++++----------\n patchlevel.h |  2 +-\n subst.c      |  4 ++++\n 3 files changed, 17 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/bashline.c b\/bashline.c\nindex f4fe9f1..0275844 100644\n--- a\/bashline.c\n+++ b\/bashline.c\n@@ -142,7 +142,7 @@ static int executable_completion __P((const char *, int));\n static rl_icppfunc_t *save_directory_hook __P((void));\n static void restore_directory_hook __P((rl_icppfunc_t));\n \n-static int directory_exists __P((const char *));\n+static int directory_exists __P((const char *, int));\n \n static void cleanup_expansion_error __P((void));\n static void maybe_make_readline_line __P((char *));\n@@ -3102,18 +3102,20 @@ restore_directory_hook (hookf)\n     rl_directory_rewrite_hook = hookf;\n }\n \n-\/* Check whether not the (dequoted) version of DIRNAME, with any trailing slash\n-   removed, exists. *\/\n+\/* Check whether not DIRNAME, with any trailing slash removed, exists.  If\n+   SHOULD_DEQUOTE is non-zero, we dequote the directory name first. *\/\n static int\n-directory_exists (dirname)\n+directory_exists (dirname, should_dequote)\n      const char *dirname;\n+     int should_dequote;\n {\n   char *new_dirname;\n   int dirlen, r;\n   struct stat sb;\n \n-  \/* First, dequote the directory name *\/\n-  new_dirname = bash_dequote_filename ((char *)dirname, rl_completion_quote_character);\n+  \/* We save the string and chop the trailing slash because stat\/lstat behave\n+     inconsistently if one is present. *\/\n+  new_dirname = should_dequote ? bash_dequote_filename ((char *)dirname, rl_completion_quote_character) : savestring (dirname);\n   dirlen = STRLEN (new_dirname);\n   if (new_dirname[dirlen - 1] == '\/')\n     new_dirname[dirlen - 1] = '\\0';\n@@ -3145,7 +3147,7 @@ bash_filename_stat_hook (dirname)\n   else if (t = mbschr (local_dirname, '`'))\t\/* XXX *\/\n     should_expand_dirname = '`';\n \n-  if (should_expand_dirname && directory_exists (local_dirname))\n+  if (should_expand_dirname && directory_exists (local_dirname, 0))\n     should_expand_dirname = 0;\n   \n   if (should_expand_dirname)  \n@@ -3155,7 +3157,7 @@ bash_filename_stat_hook (dirname)\n \t have to worry about restoring this setting. *\/\n       global_nounset = unbound_vars_is_error;\n       unbound_vars_is_error = 0;\n-      wl = expand_prompt_string (new_dirname, 0, W_NOCOMSUB|W_COMPLETE);\t\/* does the right thing *\/\n+      wl = expand_prompt_string (new_dirname, 0, W_NOCOMSUB|W_NOPROCSUB|W_COMPLETE);\t\/* does the right thing *\/\n       unbound_vars_is_error = global_nounset;\n       if (wl)\n \t{\n@@ -3244,13 +3246,13 @@ bash_directory_completion_hook (dirname)\n \tshould_expand_dirname = '`';\n     }\n \n-  if (should_expand_dirname && directory_exists (local_dirname))\n+  if (should_expand_dirname && directory_exists (local_dirname, 1))\n     should_expand_dirname = 0;\n \n   if (should_expand_dirname)  \n     {\n       new_dirname = savestring (local_dirname);\n-      wl = expand_prompt_string (new_dirname, 0, W_NOCOMSUB|W_COMPLETE);\t\/* does the right thing *\/\n+      wl = expand_prompt_string (new_dirname, 0, W_NOCOMSUB|W_NOPROCSUB|W_COMPLETE);\t\/* does the right thing *\/\n       if (wl)\n \t{\n \t  *dirname = string_list (wl);\ndiff --git a\/patchlevel.h b\/patchlevel.h\nindex 14bff9f..deb9c5b 100644\n--- a\/patchlevel.h\n+++ b\/patchlevel.h\n@@ -25,6 +25,6 @@\n    regexp `^#define[ \t]*PATCHLEVEL', since that's what support\/mkversion.sh\n    looks for to find the patch level (for the sccs version string). *\/\n \n-#define PATCHLEVEL 6\n+#define PATCHLEVEL 7\n \n #endif \/* _PATCHLEVEL_H_ *\/\ndiff --git a\/subst.c b\/subst.c\nindex 298187d..027a13e 100644\n--- a\/subst.c\n+++ b\/subst.c\n@@ -9458,6 +9458,10 @@ add_twochars:\n \t\ttword->flags |= word->flags & (W_ASSIGNARG|W_ASSIGNRHS);\t\/* affects $@ *\/\n \t      if (word->flags & W_COMPLETE)\n \t\ttword->flags |= W_COMPLETE;\t\/* for command substitutions *\/\n+\t      if (word->flags & W_NOCOMSUB)\n+\t\ttword->flags |= W_NOCOMSUB;\n+\t      if (word->flags & W_NOPROCSUB)\n+\t\ttword->flags |= W_NOPROCSUB;\n \n \t      temp = (char *)NULL;\n \n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-3513","CWE_ID":"20","category":"security","commit_id":"2b0532f3984324ebe1236a63d15893792384328d","commit_message":"From 2b0532f3984324ebe1236a63d15893792384328d Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Wed, 15 Oct 2014 01:20:38 +0100\nSubject: [PATCH] Fix for SRTP Memory Leak\n\nCVE-2014-3513\n\nThis issue was reported to OpenSSL on 26th September 2014, based on an origi\nissue and patch developed by the LibreSSL project. Further analysis of the i\nwas performed by the OpenSSL team.\n\nThe fix was developed by the OpenSSL team.\n\nReviewed-by: Tim Hudson <tjh@openssl.org>\n---\n ssl\/d1_srtp.c | 93 +++++++++++++++++----------------------------------\n ssl\/t1_lib.c  |  9 ++---\n 2 files changed, 36 insertions(+), 66 deletions(-)\n\n","diff_code":"diff --git a\/ssl\/d1_srtp.c b\/ssl\/d1_srtp.c\nindex ab9c41922c..535539ba3b 100644\n--- a\/ssl\/d1_srtp.c\n+++ b\/ssl\/d1_srtp.c\n@@ -168,25 +168,6 @@ static int find_profile_by_name(char *profile_name,\n \treturn 1;\n \t}\n \n-static int find_profile_by_num(unsigned profile_num,\n-\t\t\t       SRTP_PROTECTION_PROFILE **pptr)\n-\t{\n-\tSRTP_PROTECTION_PROFILE *p;\n-\n-\tp=srtp_known_profiles;\n-\twhile(p->name)\n-\t\t{\n-\t\tif(p->id == profile_num)\n-\t\t\t{\n-\t\t\t*pptr=p;\n-\t\t\treturn 0;\n-\t\t\t}\n-\t\tp++;\n-\t\t}\n-\n-\treturn 1;\n-\t}\n-\n static int ssl_ctx_make_profiles(const char *profiles_string,STACK_OF(SRTP_PROTECTION_PROFILE) **out)\n \t{\n \tSTACK_OF(SRTP_PROTECTION_PROFILE) *profiles;\n@@ -209,11 +190,19 @@ static int ssl_ctx_make_profiles(const char *profiles_string,STACK_OF(SRTP_PROTE\n \t\tif(!find_profile_by_name(ptr,&p,\n \t\t\t\t\t col ? col-ptr : (int)strlen(ptr)))\n \t\t\t{\n+\t\t\tif (sk_SRTP_PROTECTION_PROFILE_find(profiles,p) >= 0)\n+\t\t\t\t{\n+\t\t\t\tSSLerr(SSL_F_SSL_CTX_MAKE_PROFILES,SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST);\n+\t\t\t\tsk_SRTP_PROTECTION_PROFILE_free(profiles);\n+\t\t\t\treturn 1;\n+\t\t\t\t}\n+\n \t\t\tsk_SRTP_PROTECTION_PROFILE_push(profiles,p);\n \t\t\t}\n \t\telse\n \t\t\t{\n \t\t\tSSLerr(SSL_F_SSL_CTX_MAKE_PROFILES,SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE);\n+\t\t\tsk_SRTP_PROTECTION_PROFILE_free(profiles);\n \t\t\treturn 1;\n \t\t\t}\n \n@@ -305,13 +294,12 @@ int ssl_add_clienthello_use_srtp_ext(SSL *s, unsigned char *p, int *len, int max\n \n int ssl_parse_clienthello_use_srtp_ext(SSL *s, unsigned char *d, int len,int *al)\n \t{\n-\tSRTP_PROTECTION_PROFILE *cprof,*sprof;\n-\tSTACK_OF(SRTP_PROTECTION_PROFILE) *clnt=0,*srvr;\n+\tSRTP_PROTECTION_PROFILE *sprof;\n+\tSTACK_OF(SRTP_PROTECTION_PROFILE) *srvr;\n         int ct;\n         int mki_len;\n-\tint i,j;\n-\tint id;\n-\tint ret;\n+\tint i, srtp_pref;\n+\tunsigned int id;\n \n          \/* Length value + the MKI length *\/\n         if(len < 3)\n@@ -341,22 +329,32 @@ int ssl_parse_clienthello_use_srtp_ext(SSL *s, unsigned char *d, int len,int *al\n \t\treturn 1;\n \t\t}\n \n+\tsrvr=SSL_get_srtp_profiles(s);\n+\ts->srtp_profile = NULL;\n+\t\/* Search all profiles for a match initially *\/\n+\tsrtp_pref = sk_SRTP_PROTECTION_PROFILE_num(srvr);\n         \n-\tclnt=sk_SRTP_PROTECTION_PROFILE_new_null();\n-\n \twhile(ct)\n \t\t{\n \t\tn2s(d,id);\n \t\tct-=2;\n                 len-=2;\n \n-\t\tif(!find_profile_by_num(id,&cprof))\n+\t\t\/*\n+\t\t * Only look for match in profiles of higher preference than\n+\t\t * current match.\n+\t\t * If no profiles have been have been configured then this\n+\t\t * does nothing.\n+\t\t *\/\n+\t\tfor (i = 0; i < srtp_pref; i++)\n \t\t\t{\n-\t\t\tsk_SRTP_PROTECTION_PROFILE_push(clnt,cprof);\n-\t\t\t}\n-\t\telse\n-\t\t\t{\n-\t\t\t; \/* Ignore *\/\n+\t\t\tsprof = sk_SRTP_PROTECTION_PROFILE_value(srvr, i);\n+\t\t\tif (sprof->id == id)\n+\t\t\t\t{\n+\t\t\t\ts->srtp_profile = sprof;\n+\t\t\t\tsrtp_pref = i;\n+\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n@@ -371,36 +369,7 @@ int ssl_parse_clienthello_use_srtp_ext(SSL *s, unsigned char *d, int len,int *al\n \t\treturn 1;\n \t\t}\n \n-\tsrvr=SSL_get_srtp_profiles(s);\n-\n-\t\/* Pick our most preferred profile. If no profiles have been\n-\t configured then the outer loop doesn't run \n-\t (sk_SRTP_PROTECTION_PROFILE_num() = -1)\n-\t and so we just return without doing anything *\/\n-\tfor(i=0;i<sk_SRTP_PROTECTION_PROFILE_num(srvr);i++)\n-\t\t{\n-\t\tsprof=sk_SRTP_PROTECTION_PROFILE_value(srvr,i);\n-\n-\t\tfor(j=0;j<sk_SRTP_PROTECTION_PROFILE_num(clnt);j++)\n-\t\t\t{\n-\t\t\tcprof=sk_SRTP_PROTECTION_PROFILE_value(clnt,j);\n-            \n-\t\t\tif(cprof->id==sprof->id)\n-\t\t\t\t{\n-\t\t\t\ts->srtp_profile=sprof;\n-\t\t\t\t*al=0;\n-\t\t\t\tret=0;\n-\t\t\t\tgoto done;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\tret=0;\n-    \n-done:\n-\tif(clnt) sk_SRTP_PROTECTION_PROFILE_free(clnt);\n-\n-\treturn ret;\n+\treturn 0;\n \t}\n \n int ssl_add_serverhello_use_srtp_ext(SSL *s, unsigned char *p, int *len, int maxlen)\ndiff --git a\/ssl\/t1_lib.c b\/ssl\/t1_lib.c\nindex 022a4fb289..12ee3c9a10 100644\n--- a\/ssl\/t1_lib.c\n+++ b\/ssl\/t1_lib.c\n@@ -643,7 +643,7 @@ unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf, unsigned c\n #endif\n \n #ifndef OPENSSL_NO_SRTP\n-        if(SSL_get_srtp_profiles(s))\n+\tif(SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s))\n                 {\n                 int el;\n \n@@ -806,7 +806,7 @@ unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *buf, unsigned c\n #endif\n \n #ifndef OPENSSL_NO_SRTP\n-        if(s->srtp_profile)\n+\tif(SSL_IS_DTLS(s) && s->srtp_profile)\n                 {\n                 int el;\n \n@@ -1444,7 +1444,8 @@ int ssl_parse_clienthello_tlsext(SSL *s, unsigned char **p, unsigned char *d, in\n \n \t\t\/* session ticket processed earlier *\/\n #ifndef OPENSSL_NO_SRTP\n-\t\telse if (type == TLSEXT_TYPE_use_srtp)\n+\t\telse if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)\n+\t\t\t && type == TLSEXT_TYPE_use_srtp)\n \t\t\t{\n \t\t\tif(ssl_parse_clienthello_use_srtp_ext(s, data, size,\n \t\t\t\t\t\t\t      al))\n@@ -1698,7 +1699,7 @@ int ssl_parse_serverhello_tlsext(SSL *s, unsigned char **p, unsigned char *d, in\n \t\t\t}\n #endif\n #ifndef OPENSSL_NO_SRTP\n-\t\telse if (type == TLSEXT_TYPE_use_srtp)\n+\t\telse if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp)\n \t\t\t{\n                         if(ssl_parse_serverhello_use_srtp_ext(s, data, size,\n \t\t\t\t\t\t\t      al))\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9501","CWE_ID":"20","category":"security","commit_id":"01843366d6a7b96e22ad7bb67f3df7d9fd4d5d74","commit_message":"From 01843366d6a7b96e22ad7bb67f3df7d9fd4d5d74 Mon Sep 17 00:00:00 2001\nFrom: Dirk Lemstra <dirk@git.imagemagick.org>\nDate: Mon, 15 May 2017 21:24:24 +0200\nSubject: [PATCH] Fixed incorrect call to DestroyImage reported in #491.\n\n---\n magick\/image.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/magick\/image.c b\/magick\/image.c\nindex 09cbb64456..24ec768b49 100644\n--- a\/magick\/image.c\n+++ b\/magick\/image.c\n@@ -833,7 +833,7 @@ MagickExport Image *CloneImage(const Image *image,const size_t columns,\n         sizeof(*clone_image->colormap));\n       if (clone_image->colormap == (PixelPacket *) NULL)\n         {\n-          clone_image=DestroyImage(clone_image);\n+          image=(Image *) RelinquishMagickMemory(image);\n           ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n         }\n       (void) CopyMagickMemory(clone_image->colormap,image->colormap,length*\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2014-5336","CWE_ID":"20","category":"security","commit_id":"b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd","commit_message":"From b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd Mon Sep 17 00:00:00 2001\nFrom: Eduardo Silva <eduardo@monkey.io>\nDate: Sat, 16 Aug 2014 11:55:28 -0600\nSubject: [PATCH] Request: new request session flag to mark those files opened\n by FDT\n\nThis patch aims to fix a potential DDoS problem that can be caused\nin the server quering repetitive non-existent resources.\n\nWhen serving a static file, the core use Vhost FDT mechanism, but if\nit sends a static error page it does a direct open(2). When closing\nthe resources for the same request it was just calling mk_vhost_close()\nwhich did not clear properly the file descriptor.\n\nThis patch adds a new field on the struct session_request called 'fd_is_fdt',\nwhich contains MK_TRUE or MK_FALSE depending of how fd_file was opened.\n\nThanks to Matthew Daley <mattd@bugfuzz.com> for report and troubleshoot this\nproblem.\n\nSigned-off-by: Eduardo Silva <eduardo@monkey.io>\n---\n include\/monkey\/mk_request.h | 12 +++++++++++-\n src\/mk_request.c            | 10 ++++++++--\n src\/mk_vhost.c              |  2 +-\n 3 files changed, 20 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/include\/monkey\/mk_request.h b\/include\/monkey\/mk_request.h\nindex 40acbe72..9d0213ff 100644\n--- a\/include\/monkey\/mk_request.h\n+++ b\/include\/monkey\/mk_request.h\n@@ -159,8 +159,18 @@ struct session_request\n     long port;\n     \/*------------*\/\n \n-    \/* file descriptors *\/\n+    \/*\n+     * Static file file descriptor: the following twp fields represents an\n+     * opened file in the file system and a flag saying which mechanism\n+     * was used to open it.\n+     *\n+     *  - fd_file  : common file descriptor\n+     *  - fd_is_fdt: set to MK_TRUE if fd_file was opened using Vhost FDT, or\n+     *               MK_FALSE for the opposite case.\n+     *\/\n     int fd_file;\n+    int fd_is_fdt;\n+\n \n     int headers_len;\n \ndiff --git a\/src\/mk_request.c b\/src\/mk_request.c\nindex adce9ff1..94ffdf8e 100644\n--- a\/src\/mk_request.c\n+++ b\/src\/mk_request.c\n@@ -99,7 +99,12 @@ static inline void mk_request_init(struct session_request *request)\n void mk_request_free(struct session_request *sr)\n {\n     if (sr->fd_file > 0) {\n-        mk_vhost_close(sr);\n+        if (sr->fd_is_fdt == MK_TRUE) {\n+            mk_vhost_close(sr);\n+        }\n+        else {\n+            close(sr->fd_file);\n+        }\n     }\n \n     if (sr->headers.location) {\n@@ -841,7 +846,8 @@ int mk_request_error(int http_status, struct client_session *cs,\n                 break;\n             }\n \n-            sr->fd_file = fd;\n+            sr->fd_file   = fd;\n+            sr->fd_is_fdt = MK_FALSE;\n             sr->bytes_to_send = finfo.size;\n             sr->headers.content_length = finfo.size;\n             sr->headers.real_length    = finfo.size;\ndiff --git a\/src\/mk_vhost.c b\/src\/mk_vhost.c\nindex cd89582f..4807faf0 100644\n--- a\/src\/mk_vhost.c\n+++ b\/src\/mk_vhost.c\n@@ -220,6 +220,7 @@ static inline int mk_vhost_fdt_open(int id, unsigned int hash,\n \n             sr->vhost_fdt_id   = id;\n             sr->vhost_fdt_hash = hash;\n+            sr->fd_is_fdt      = MK_TRUE;\n \n             return fd;\n         }\n@@ -262,7 +263,6 @@ static inline int mk_vhost_fdt_close(struct session_request *sr)\n             return 0;\n         }\n     }\n-\n     return close(sr->fd_file);\n }\n \n","owner":"monkey","repo":"monkey","source":"cve"},{"CVE_ID":"CVE-2016-10069","CWE_ID":"20","category":"security","commit_id":"8a370f9ab120faf182aa160900ba692ba8e2bcf0","commit_message":"From 8a370f9ab120faf182aa160900ba692ba8e2bcf0 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Sun, 29 May 2016 08:15:48 +0200\nSubject: [PATCH] Added check for invalid number of frames.\n\n---\n coders\/mat.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/mat.c b\/coders\/mat.c\nindex 28ab856d2a..564e745ecd 100644\n--- a\/coders\/mat.c\n+++ b\/coders\/mat.c\n@@ -942,7 +942,9 @@ MATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       case 16: z2=z = ReadBlobXXXLong(image2);  \/* 4D matrix animation *\/\n          if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n-          Frames = ReadBlobXXXLong(image2);\n+         Frames = ReadBlobXXXLong(image2);\n+         if (Frames == 0)\n+           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          break;\n       default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n     }\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2016-4071","CWE_ID":"20","category":"security","commit_id":"6e25966544fb1d2f3d7596e060ce9c9269bbdcf8","commit_message":"From 6e25966544fb1d2f3d7596e060ce9c9269bbdcf8 Mon Sep 17 00:00:00 2001\nFrom: Anatol Belski <ab@php.net>\nDate: Wed, 16 Mar 2016 09:48:40 +0100\nSubject: [PATCH] Fixed bug #71704 php_snmp_error() Format String Vulnerability\n\n---\n ext\/snmp\/snmp.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ext\/snmp\/snmp.c b\/ext\/snmp\/snmp.c\nindex be8888c..67e39f1 100644\n--- a\/ext\/snmp\/snmp.c\n+++ b\/ext\/snmp\/snmp.c\n@@ -530,7 +530,7 @@ static void php_snmp_error(zval *object, const char *docref, int type, const cha\n \t}\n \n \tif (object && (snmp_object->exceptions_enabled & type)) {\n-\t\tzend_throw_exception_ex(php_snmp_exception_ce, type, snmp_object->snmp_errstr);\n+\t\tzend_throw_exception_ex(php_snmp_exception_ce, type, \"%s\", snmp_object->snmp_errstr);\n \t} else {\n \t\tva_start(args, format);\n \t\tphp_verror(docref, \"\", E_WARNING, format, args);\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-13135","CWE_ID":"20","category":"security","commit_id":"cdb383749ef7b68a38891440af8cc23e0115306d","commit_message":"From cdb383749ef7b68a38891440af8cc23e0115306d Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Tue, 18 Jun 2019 11:44:39 -0400\nSubject: [PATCH] https:\/\/github.com\/ImageMagick\/ImageMagick\/issues\/1599\n\n---\n coders\/cut.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/coders\/cut.c b\/coders\/cut.c\nindex 69f236276b..c4f2768cbe 100644\n--- a\/coders\/cut.c\n+++ b\/coders\/cut.c\n@@ -552,6 +552,7 @@ static Image *ReadCUTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk,\n     sizeof(*BImgBuff));  \/*Ldblk was set in the check phase*\/\n   if(BImgBuff==NULL) goto NoMemory;\n+  (void) memset(BImgBuff,0,(size_t) ldblk*sizeof(*BImgBuff));\n \n   offset=SeekBlob(image,6 \/*sizeof(Header)*\/,SEEK_SET);\n   if (offset < 0)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2018-6343","CWE_ID":"20","category":"security","commit_id":"0600ebe59c3e82cd012def77ca9ca1918da74a71","commit_message":"From 0600ebe59c3e82cd012def77ca9ca1918da74a71 Mon Sep 17 00:00:00 2001\nFrom: Kyle Nekritz <knekritz@fb.com>\nDate: Mon, 12 Nov 2018 15:36:38 -0800\nSubject: [PATCH] Check that a secondary auth manager is set before\n dereferencing.\n\nSummary: CVE-2018-6343\n\nReviewed By: mingtaoy\n\nDifferential Revision: D12994423\n\nfbshipit-source-id: 9229ec11da8085f1fa153595e8e5353e19d06fb7\n---\n proxygen\/lib\/http\/session\/HTTPSession.cpp | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\n","diff_code":"diff --git a\/proxygen\/lib\/http\/session\/HTTPSession.cpp b\/proxygen\/lib\/http\/session\/HTTPSession.cpp\nindex 71152b24f..95b34c6e4 100644\n--- a\/proxygen\/lib\/http\/session\/HTTPSession.cpp\n+++ b\/proxygen\/lib\/http\/session\/HTTPSession.cpp\n@@ -1349,6 +1349,10 @@ void HTTPSession::onCertificateRequest(uint16_t requestId,\n   DestructorGuard dg(this);\n   VLOG(4) << \"CERTIFICATE_REQUEST on\" << *this << \", requestId=\" << requestId;\n \n+  if (!secondAuthManager_) {\n+    return;\n+  }\n+\n   std::pair<uint16_t, std::unique_ptr<folly::IOBuf>> authenticator;\n   auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n   if (fizzBase) {\n@@ -1382,6 +1386,10 @@ void HTTPSession::onCertificate(uint16_t certId,\n   DestructorGuard dg(this);\n   VLOG(4) << \"CERTIFICATE on\" << *this << \", certId=\" << certId;\n \n+  if (!secondAuthManager_) {\n+    return;\n+  }\n+\n   bool isValid = false;\n   auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n   if (fizzBase) {\n","owner":"facebook","repo":"proxygen","source":"cve"},{"CVE_ID":"CVE-2017-18248","CWE_ID":"20","category":"security","commit_id":"49fa4983f25b64ec29d548ffa3b9782426007df3","commit_message":"From 49fa4983f25b64ec29d548ffa3b9782426007df3 Mon Sep 17 00:00:00 2001\nFrom: Michael Sweet <michael.r.sweet@gmail.com>\nDate: Mon, 23 Oct 2017 16:23:43 -0400\nSubject: [PATCH] DBUS notifications could crash the scheduler (Issue #5143)\n\n- scheduler\/ipp.c: Make sure requesting-user-name string is valid UTF-8.\n---\n CHANGES.md      |  5 +++--\n scheduler\/ipp.c | 12 ++++++++++--\n 2 files changed, 13 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/CHANGES.md b\/CHANGES.md\nindex 2fdf93e32..86eb1dbdc 100644\n--- a\/CHANGES.md\n+++ b\/CHANGES.md\n@@ -1,12 +1,13 @@\n-CHANGES - 2.2.6 - 2017-10-19\n+CHANGES - 2.2.6 - 2017-10-23\n ============================\n \n \n Changes in CUPS v2.2.6\n ----------------------\n \n+- DBUS notifications could crash the scheduler (Issue #5143)\n - Added USB quirks rules for Canon MP540 and Samsung ML-2160 (Issue #5148)\n-- Fixed TLS cipher suite selection with GNU TLS (Issue #5145)\n+- Fixed TLS cipher suite selection with GNU TLS (Issue #5145, Issue #5150)\n \n \n Changes in CUPS v2.2.5\ndiff --git a\/scheduler\/ipp.c b\/scheduler\/ipp.c\nindex e6743cdcb..5cf980ab3 100644\n--- a\/scheduler\/ipp.c\n+++ b\/scheduler\/ipp.c\n@@ -1597,6 +1597,16 @@ add_job(cupsd_client_t  *con,\t\t\/* I - Client connection *\/\n     return (NULL);\n   }\n \n+  attr = ippFindAttribute(con->request, \"requesting-user-name\", IPP_TAG_NAME);\n+\n+  if (attr && !ippValidateAttribute(attr))\n+  {\n+    send_ipp_status(con, IPP_ATTRIBUTES, _(\"Bad requesting-user-name value: %s\"), cupsLastErrorString());\n+    if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL)\n+      attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP;\n+    return (NULL);\n+  }\n+\n   if ((job = cupsdAddJob(priority, printer->name)) == NULL)\n   {\n     send_ipp_status(con, IPP_INTERNAL_ERROR,\n@@ -1615,8 +1625,6 @@ add_job(cupsd_client_t  *con,\t\t\/* I - Client connection *\/\n   add_job_uuid(job);\n   apply_printer_defaults(printer, job);\n \n-  attr = ippFindAttribute(job->attrs, \"requesting-user-name\", IPP_TAG_NAME);\n-\n   if (con->username[0])\n   {\n     cupsdSetString(&job->username, con->username);\n","owner":"apple","repo":"cups","source":"cve"},{"CVE_ID":"CVE-2011-2512","CWE_ID":"20","category":"security","commit_id":"7157e2e23e89adcd436caeab31fdd6b47eded377","commit_message":"From 7157e2e23e89adcd436caeab31fdd6b47eded377 Mon Sep 17 00:00:00 2001\nFrom: Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>\nDate: Sun, 8 May 2011 22:29:07 +0100\nSubject: virtio: guard against negative vq notifies\n\nThe virtio_queue_notify() function checks that the virtqueue number is\nless than the maximum number of virtqueues.  A signed comparison is used\nbut the virtqueue number could be negative if a buggy or malicious guest\nis run.  This results in memory accesses outside of the virtqueue array.\n\nIt is risky doing input validation in common code instead of at the\nguest<->host boundary.  Note that virtio_queue_set_addr(),\nvirtio_queue_get_addr(), virtio_queue_get_num(), and many other virtio\nfunctions do *not* validate the virtqueue number argument.\n\nInstead of fixing the comparison in virtio_queue_notify(), move the\ncomparison to the virtio bindings (just like VIRTIO_PCI_QUEUE_SEL) where\nwe have a uint32_t value and can avoid ever calling into common virtio\ncode if the virtqueue number is invalid.\n\nSigned-off-by: Stefan Hajnoczi <stefanha@linux.vnet.ibm.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\n---\n hw\/syborg_virtio.c | 4 +++-\n hw\/virtio-pci.c    | 4 +++-\n hw\/virtio.c        | 4 +---\n 3 files changed, 7 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/hw\/syborg_virtio.c b\/hw\/syborg_virtio.c\nindex 2f3e6da4e2..00c7be8c8f 100644\n--- a\/hw\/syborg_virtio.c\n+++ b\/hw\/syborg_virtio.c\n@@ -146,7 +146,9 @@ static void syborg_virtio_writel(void *opaque, target_phys_addr_t offset,\n             vdev->queue_sel = value;\n         break;\n     case SYBORG_VIRTIO_QUEUE_NOTIFY:\n-        virtio_queue_notify(vdev, value);\n+        if (value < VIRTIO_PCI_QUEUE_MAX) {\n+            virtio_queue_notify(vdev, value);\n+        }\n         break;\n     case SYBORG_VIRTIO_STATUS:\n         virtio_set_status(vdev, value & 0xFF);\ndiff --git a\/hw\/virtio-pci.c b\/hw\/virtio-pci.c\nindex 270e2c7438..b86c441623 100644\n--- a\/hw\/virtio-pci.c\n+++ b\/hw\/virtio-pci.c\n@@ -348,7 +348,9 @@ static void virtio_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n             vdev->queue_sel = val;\n         break;\n     case VIRTIO_PCI_QUEUE_NOTIFY:\n-        virtio_queue_notify(vdev, val);\n+        if (val < VIRTIO_PCI_QUEUE_MAX) {\n+            virtio_queue_notify(vdev, val);\n+        }\n         break;\n     case VIRTIO_PCI_STATUS:\n         if (!(val & VIRTIO_CONFIG_S_DRIVER_OK)) {\ndiff --git a\/hw\/virtio.c b\/hw\/virtio.c\nindex 6e8814cb64..a6518606c3 100644\n--- a\/hw\/virtio.c\n+++ b\/hw\/virtio.c\n@@ -585,9 +585,7 @@ void virtio_queue_notify_vq(VirtQueue *vq)\n \n void virtio_queue_notify(VirtIODevice *vdev, int n)\n {\n-    if (n < VIRTIO_PCI_QUEUE_MAX) {\n-        virtio_queue_notify_vq(&vdev->vq[n]);\n-    }\n+    virtio_queue_notify_vq(&vdev->vq[n]);\n }\n \n uint16_t virtio_queue_vector(VirtIODevice *vdev, int n)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-8934","CWE_ID":"20","category":"security","commit_id":"bc8c3d871e9ecc67c47ff002b68cf049793faf08","commit_message":"From bc8c3d871e9ecc67c47ff002b68cf049793faf08 Mon Sep 17 00:00:00 2001\nFrom: Andriy Grytsenko <andrej@rep.kiev.ua>\nDate: Sun, 14 May 2017 21:35:40 +0300\nSubject: [PATCH] Fix potential access violation, use runtime user dir instead\n of tmp dir.\n\n---\n NEWS              | 4 ++++\n src\/single-inst.c | 7 ++++++-\n 2 files changed, 10 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/NEWS b\/NEWS\nindex 8c2049a..876f7f3 100644\n--- a\/NEWS\n+++ b\/NEWS\n@@ -1,3 +1,7 @@\n+* Fixed potential access violation, use runtime user dir instead of tmp dir\n+    for single instance socket.\n+\n+\n Changes on 1.2.5 since 1.2.4:\n \n * Removed options to Cut, Remove and Rename from context menu on mounted\ndiff --git a\/src\/single-inst.c b\/src\/single-inst.c\nindex 62c37b3..aaf84ab 100644\n--- a\/src\/single-inst.c\n+++ b\/src\/single-inst.c\n@@ -2,7 +2,7 @@\n  *      single-inst.c: simple IPC mechanism for single instance app\n  *\n  *      Copyright 2010 Hong Jen Yee (PCMan) <pcman.tw@gmail.com>\n- *      Copyright 2012 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>\n+ *      Copyright 2012-2017 Andriy Grytsenko (LStranger) <andrej@rep.kiev.ua>\n  *\n  *      This program is free software; you can redistribute it and\/or modify\n  *      it under the terms of the GNU General Public License as published by\n@@ -404,11 +404,16 @@ static void get_socket_name(SingleInstData* data, char* buf, int len)\n     }\n     else\n         dpynum = 0;\n+#if GLIB_CHECK_VERSION(2, 28, 0)\n+    g_snprintf(buf, len, \"%s\/%s-socket-%s-%d\", g_get_user_runtime_dir(),\n+               data->prog_name, host ? host : \"\", dpynum);\n+#else\n     g_snprintf(buf, len, \"%s\/.%s-socket-%s-%d-%s\",\n                 g_get_tmp_dir(),\n                 data->prog_name,\n                 host ? host : \"\",\n                 dpynum,\n                 g_get_user_name());\n+#endif\n }\n \n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-3619","CWE_ID":"20","category":"security","commit_id":"a5b2c5b2ad5853591a6cac6134cd0f599a720865","commit_message":"From a5b2c5b2ad5853591a6cac6134cd0f599a720865 Mon Sep 17 00:00:00 2001\nFrom: Kees Cook <kees.cook@canonical.com>\nDate: Tue, 31 May 2011 11:31:41 -0700\nSubject: AppArmor: fix oops in apparmor_setprocattr\n\nWhen invalid parameters are passed to apparmor_setprocattr a NULL deref\noops occurs when it tries to record an audit message. This is because\nit is passing NULL for the profile parameter for aa_audit. But aa_audit\nnow requires that the profile passed is not NULL.\n\nFix this by passing the current profile on the task that is trying to\nsetprocattr.\n\nSigned-off-by: Kees Cook <kees@ubuntu.com>\nSigned-off-by: John Johansen <john.johansen@canonical.com>\nCc: stable@kernel.org\nSigned-off-by: James Morris <jmorris@namei.org>\n---\n security\/apparmor\/lsm.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/security\/apparmor\/lsm.c b\/security\/apparmor\/lsm.c\nindex ae3a698415e6..ec1bcecf2cda 100644\n--- a\/security\/apparmor\/lsm.c\n+++ b\/security\/apparmor\/lsm.c\n@@ -593,7 +593,8 @@ static int apparmor_setprocattr(struct task_struct *task, char *name,\n \t\t\tsa.aad.op = OP_SETPROCATTR;\n \t\t\tsa.aad.info = name;\n \t\t\tsa.aad.error = -EINVAL;\n-\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n+\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED,\n+\t\t\t\t\t__aa_current_profile(), GFP_KERNEL,\n \t\t\t\t\t&sa, NULL);\n \t\t}\n \t} else if (strcmp(name, \"exec\") == 0) {\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2010-2495","CWE_ID":"20","category":"security","commit_id":"3feec9095d12e311b7d4eb7fe7e5dfa75d4a72a5","commit_message":"From 3feec9095d12e311b7d4eb7fe7e5dfa75d4a72a5 Mon Sep 17 00:00:00 2001\nFrom: James Chapman <jchapman@katalix.com>\nDate: Tue, 16 Mar 2010 06:46:31 +0000\nSubject: l2tp: Fix oops in pppol2tp_xmit\n\nWhen transmitting L2TP frames, we derive the outgoing interface's UDP\nchecksum hardware assist capabilities from the tunnel dst dev. This\ncan sometimes be NULL, especially when routing protocols are used and\nrouting changes occur. This patch just checks for NULL dst or dev\npointers when checking for netdev hardware assist features.\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000c\nIP: [<f89d074c>] pppol2tp_xmit+0x341\/0x4da [pppol2tp]\n*pde = 00000000\nOops: 0000 [#1] SMP\nlast sysfs file: \/sys\/class\/net\/lo\/operstate\nModules linked in: pppol2tp pppox ppp_generic slhc ipv6 dummy loop snd_hda_codec_atihdmi snd_hda_intel snd_hda_codec snd_pcm snd_timer snd soundcore snd_page_alloc evdev psmouse serio_raw processor button i2c_piix4 i2c_core ati_agp agpgart pcspkr ext3 jbd mbcache sd_mod ide_pci_generic atiixp ide_core ahci ata_generic floppy ehci_hcd ohci_hcd libata e1000e scsi_mod usbcore nls_base thermal fan thermal_sys [last unloaded: scsi_wait_scan]\n\nPid: 0, comm: swapper Not tainted (2.6.32.8 #1)\nEIP: 0060:[<f89d074c>] EFLAGS: 00010297 CPU: 3\nEIP is at pppol2tp_xmit+0x341\/0x4da [pppol2tp]\nEAX: 00000000 EBX: f64d1680 ECX: 000005b9 EDX: 00000000\nESI: f6b91850 EDI: f64d16ac EBP: f6a0c4c0 ESP: f70a9cac\n DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068\nProcess swapper (pid: 0, ti=f70a8000 task=f70a31c0 task.ti=f70a8000)\nStack:\n 000005a9 000005b9 f734c400 f66652c0 f7352e00 f67dc800 00000000 f6b91800\n<0> 000005a3 f70ef6c4 f67dcda9 000005a3 f89b192e 00000246 000005a3 f64d1680\n<0> f63633e0 f6363320 f64d1680 f65a7320 f65a7364 f65856c0 f64d1680 f679f02f\nCall Trace:\n [<f89b192e>] ? ppp_push+0x459\/0x50e [ppp_generic]\n [<f89b217f>] ? ppp_xmit_process+0x3b6\/0x430 [ppp_generic]\n [<f89b2306>] ? ppp_start_xmit+0x10d\/0x120 [ppp_generic]\n [<c11c15cb>] ? dev_hard_start_xmit+0x21f\/0x2b2\n [<c11d0947>] ? sch_direct_xmit+0x48\/0x10e\n [<c11c19a0>] ? dev_queue_xmit+0x263\/0x3a6\n [<c11e2a9f>] ? ip_finish_output+0x1f7\/0x221\n [<c11df682>] ? ip_forward_finish+0x2e\/0x30\n [<c11de645>] ? ip_rcv_finish+0x295\/0x2a9\n [<c11c0b19>] ? netif_receive_skb+0x3e9\/0x404\n [<f814b791>] ? e1000_clean_rx_irq+0x253\/0x2fc [e1000e]\n [<f814cb7a>] ? e1000_clean+0x63\/0x1fc [e1000e]\n [<c1047eff>] ? sched_clock_local+0x15\/0x11b\n [<c11c1095>] ? net_rx_action+0x96\/0x195\n [<c1035750>] ? __do_softirq+0xaa\/0x151\n [<c1035828>] ? do_softirq+0x31\/0x3c\n [<c10358fe>] ? irq_exit+0x26\/0x58\n [<c1004b21>] ? do_IRQ+0x78\/0x89\n [<c1003729>] ? common_interrupt+0x29\/0x30\n [<c101ac28>] ? native_safe_halt+0x2\/0x3\n [<c1008c54>] ? default_idle+0x55\/0x75\n [<c1009045>] ? c1e_idle+0xd2\/0xd5\n [<c100233c>] ? cpu_idle+0x46\/0x62\nCode: 8d 45 08 f0 ff 45 08 89 6b 08 c7 43 68 7e fb 9c f8 8a 45 24 83 e0 0c 3c 04 75 09 80 63 64 f3 e9 b4 00 00 00 8b 43 18 8b 4c 24 04 <8b> 40 0c 8d 79 11 f6 40 44 0e 8a 43 64 75 51 6a 00 8b 4c 24 08\nEIP: [<f89d074c>] pppol2tp_xmit+0x341\/0x4da [pppol2tp] SS:ESP 0068:f70a9cac\nCR2: 000000000000000c\n\nSigned-off-by: James Chapman <jchapman@katalix.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/pppol2tp.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/drivers\/net\/pppol2tp.c b\/drivers\/net\/pppol2tp.c\nindex 9fbb2eba9a06..5861ee9599a2 100644\n--- a\/drivers\/net\/pppol2tp.c\n+++ b\/drivers\/net\/pppol2tp.c\n@@ -1180,7 +1180,8 @@ static int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb)\n \t\/* Calculate UDP checksum if configured to do so *\/\n \tif (sk_tun->sk_no_check == UDP_CSUM_NOXMIT)\n \t\tskb->ip_summed = CHECKSUM_NONE;\n-\telse if (!(skb_dst(skb)->dev->features & NETIF_F_V4_CSUM)) {\n+\telse if ((skb_dst(skb) && skb_dst(skb)->dev) &&\n+\t\t (!(skb_dst(skb)->dev->features & NETIF_F_V4_CSUM))) {\n \t\tskb->ip_summed = CHECKSUM_COMPLETE;\n \t\tcsum = skb_checksum(skb, 0, udp_len, 0);\n \t\tuh->check = csum_tcpudp_magic(inet->inet_saddr,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-17205","CWE_ID":"20","category":"security","commit_id":"0befd1f3745055c32940f5faf9559be6a14395e6","commit_message":"From 0befd1f3745055c32940f5faf9559be6a14395e6 Mon Sep 17 00:00:00 2001\nFrom: Vishal Deep Ajmera <vishal.deep.ajmera@ericsson.com>\nDate: Sun, 17 Jun 2018 05:20:30 +0530\nSubject: [PATCH] ofproto: Fix OVS crash when reverting old flows in bundle\n commit\n\nDuring bundle commit flows which are added in bundle are applied\nto ofproto in-order. In case if a flow cannot be added (e.g. flow\naction is go-to group id which does not exist), OVS tries to\nrevert back all previous flows which were successfully applied\nfrom the same bundle. This is possible since OVS maintains list\nof old flows which were replaced by flows from the bundle.\n\nWhile reinserting old flows ovs asserts due to check on rule\nstate != RULE_INITIALIZED.  This will work only for new flows, but\nfor old flow the rule state will be RULE_REMOVED. This is causing\nan assert and OVS crash.\n\nThe ovs assert check should be modified to != RULE_INSERTED to prevent\nany existing rule being re-inserted and allow new rules and old rules\n(in case of revert) to get inserted.\n\nHere is an example to trigger the assert:\n\n$ ovs-vsctl add-br br-test -- set Bridge br-test datapath_type=netdev\n\n$ cat flows.txt\nflow add table=1,priority=0,in_port=2,actions=NORMAL\nflow add table=1,priority=0,in_port=3,actions=NORMAL\n\n$ ovs-ofctl dump-flows -OOpenflow13 br-test\n cookie=0x0, duration=2.465s, table=1, n_packets=0, n_bytes=0, priority=0,in_port=2 actions=NORMAL\n cookie=0x0, duration=2.465s, table=1, n_packets=0, n_bytes=0, priority=0,in_port=3 actions=NORMAL\n\n$ cat flow-modify.txt\nflow modify table=1,priority=0,in_port=2,actions=drop\nflow modify table=1,priority=0,in_port=3,actions=group:10\n\n$ ovs-ofctl bundle br-test flow-modify.txt -OOpenflow13\n\nFirst flow rule will be modified since it is a valid rule. However second\nrule is invalid since no group with id 10 exists. Bundle commit tries to\nrevert (insert) the first rule to old flow which results in ovs_assert at\nofproto_rule_insert__() since old rule->state = RULE_REMOVED.\n\nSigned-off-by: Vishal Deep Ajmera <vishal.deep.ajmera@ericsson.com>\nSigned-off-by: Ben Pfaff <blp@ovn.org>\n---\n ofproto\/ofproto.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ofproto\/ofproto.c b\/ofproto\/ofproto.c\nindex 0f827b9060..50df9dc9c0 100644\n--- a\/ofproto\/ofproto.c\n+++ b\/ofproto\/ofproto.c\n@@ -8465,7 +8465,7 @@ ofproto_rule_insert__(struct ofproto *ofproto, struct rule *rule)\n     const struct rule_actions *actions = rule_get_actions(rule);\n \n     \/* A rule may not be reinserted. *\/\n-    ovs_assert(rule->state == RULE_INITIALIZED);\n+    ovs_assert(rule->state != RULE_INSERTED);\n \n     if (rule->hard_timeout || rule->idle_timeout) {\n         ovs_list_insert(&ofproto->expirable, &rule->expirable);\n","owner":"openvswitch","repo":"ovs","source":"cve"},{"CVE_ID":"CVE-2015-5195","CWE_ID":"20","category":"security","commit_id":"52e977d79a0c4ace997e5c74af429844da2f27be","commit_message":"From 52e977d79a0c4ace997e5c74af429844da2f27be Mon Sep 17 00:00:00 2001\nFrom:  <davehart@shiny.ad.hartbrothers.com>\nDate: Thu, 6 Jan 2011 04:02:24 +0000\nSubject: [PATCH] [Bug 1773] openssl not detected during .\/configure. [Bug\n 1774] Segfaults if cryptostats enabled and built without OpenSSL.\n\n---\n ChangeLog         |  2 ++\n m4\/ntp_openssl.m4 | 38 ++++++++++++++++----------------------\n ntpd\/ntp_config.c | 12 ++++++++++++\n ntpd\/ntp_util.c   | 12 ++----------\n 4 files changed, 32 insertions(+), 32 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 6896b34fd..e56e89998 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,5 @@\n+* [Bug 1773] openssl not detected during .\/configure.\n+* [Bug 1774] Segfaults if cryptostats enabled and built without OpenSSL.\n (4.2.7p111) 2011\/01\/05 Released by Harlan Stenn <stenn@ntp.org>\n * [Bug 1772] refclock_open() return value check wrong for ACTS.\n * Default --with-openssl-libdir and --with-openssl-incdir to the values\ndiff --git a\/m4\/ntp_openssl.m4 b\/m4\/ntp_openssl.m4\nindex a57c55c03..192538964 100644\n--- a\/m4\/ntp_openssl.m4\n+++ b\/m4\/ntp_openssl.m4\n@@ -31,23 +31,20 @@ case \"$ans\" in\n      '')\n \t;;\n      *)\n-\tpkgans=`$PKG_CONFIG --libs-only-L openssl | sed -e 's\/^-L\/\/'`\n-\tcase \"$pkgans\" in\n-\t '')\n-\t    # Look in:\n-\t    ans=\"\/usr\/lib \/usr\/lib\/openssl \/usr\/sfw\/lib\"\n-\t    ans=\"$ans \/usr\/local\/lib \/usr\/local\/ssl\/lib \/lib\"\n-\t    ;;\n-\t *)\n-\t    ans=\"$pkgans\"\n-\t    ;;\n-\tesac\n+\tpkgans=\"`$PKG_CONFIG --libs-only-L openssl | sed -e 's\/^-L\/\/'`\" 2>\/dev\/null\n+\ttest -f \"${pkgans}\/pkgconfig\/openssl.pc\" && ans=\"$pkgans\"\n \t;;\n     esac\n     ;;\n  *) # Look where they said\n     ;;\n esac\n+case \"$ans\" in\n+ yes)\n+    # Look in:\n+    ans=\"\/usr\/lib \/usr\/lib\/openssl \/usr\/sfw\/lib\"\n+    ans=\"$ans \/usr\/local\/lib \/usr\/local\/ssl\/lib \/lib\"\n+esac\n case \"$ans\" in\n  no)\n     ;;\n@@ -100,23 +97,20 @@ case \"$ans\" in\n      '')\n \t;;\n      *)\n-\tpkgans=`$PKG_CONFIG --cflags-only-I openssl | sed -e 's\/^-I\/\/'`\n-\tcase \"$pkgans\" in\n-\t '')\n-\t    # Look in:\n-\t    ans=\"\/usr\/include \/usr\/sfw\/include \/usr\/local\/include\"\n-\t    ans=\"$ans \/usr\/local\/ssl\/include\"\n-\t    ;;\n-\t *)\n-\t    ans=\"$pkgans\"\n-\t    ;;\n-\tesac\n+\tpkgans=\"`$PKG_CONFIG --cflags-only-I openssl | sed -e 's\/^-I\/\/'`\" 2>\/dev\/null\n+\ttest -f \"${pkgans}\/pkgconfig\/openssl.pc\" && ans=\"$pkgans\"\n \t;;\n     esac\n     ;;\n  *) # Look where they said\n     ;;\n esac\n+case \"$ans\" in\n+ yes)\n+    # Look in:\n+    ans=\"\/usr\/include \/usr\/sfw\/include \/usr\/local\/include\"\n+    ans=\"$ans \/usr\/local\/ssl\/include\"\n+esac\n case \"$ans\" in\n  no)\n     ;;\ndiff --git a\/ntpd\/ntp_config.c b\/ntpd\/ntp_config.c\nindex ca17b39ae..e6a61f083 100644\n--- a\/ntpd\/ntp_config.c\n+++ b\/ntpd\/ntp_config.c\n@@ -2015,6 +2015,12 @@ config_monitor(\n \tfor (; pfilegen_token != NULL; pfilegen_token = pfilegen_token->link) {\n \t\tfilegen_string = keyword(pfilegen_token->i);\n \t\tfilegen = filegen_get(filegen_string);\n+\t\tif (NULL == filegen) {\n+\t\t\tmsyslog(LOG_ERR,\n+\t\t\t\t\"stats %s unrecognized\",\n+\t\t\t\tfilegen_string);\n+\t\t\tcontinue;\n+\t\t}\n \t\tDPRINTF(4, (\"enabling filegen for %s statistics '%s%s'\\n\",\n \t\t\t    filegen_string, filegen->prefix, \n \t\t\t    filegen->basename));\n@@ -2026,6 +2032,12 @@ config_monitor(\n \tfor (; my_node != NULL; my_node = my_node->link) {\n \t\tfilegen_file = keyword(my_node->filegen_token);\n \t\tfilegen = filegen_get(filegen_file);\n+\t\tif (NULL == filegen) {\n+\t\t\tmsyslog(LOG_ERR,\n+\t\t\t\t\"filegen category '%s' unrecognized\",\n+\t\t\t\tfilegen_file);\n+\t\t\tcontinue;\n+\t\t}\n \n \t\t\/* Initialize the filegen variables to their pre-configuration states *\/\n \t\tfilegen_flag = filegen->flag;\ndiff --git a\/ntpd\/ntp_util.c b\/ntpd\/ntp_util.c\nindex db8bf80f6..d63156d11 100644\n--- a\/ntpd\/ntp_util.c\n+++ b\/ntpd\/ntp_util.c\n@@ -80,12 +80,6 @@ double\twander_threshold = 1e-7;\t\/* initial frequency threshold *\/\n # define MAXPATHLEN 256\n #endif\n \n-#ifdef DEBUG_TIMING\n-static FILEGEN timingstats;\n-#endif\n-#ifdef AUTOKEY\n-static FILEGEN cryptostats;\n-#endif\t\/* AUTOKEY *\/\n \n static\tchar statsdir[MAXPATHLEN] = NTP_VAR;\n static FILEGEN peerstats;\n@@ -94,6 +88,8 @@ static FILEGEN clockstats;\n static FILEGEN rawstats;\n static FILEGEN sysstats;\n static FILEGEN protostats;\n+static FILEGEN cryptostats;\n+static FILEGEN timingstats;\n \n \/*\n  * This controls whether stats are written to the fileset. Provided\n@@ -173,12 +169,8 @@ init_util(void)\n \tfilegen_register(statsdir, \"rawstats\",\t  &rawstats);\n \tfilegen_register(statsdir, \"sysstats\",\t  &sysstats);\n \tfilegen_register(statsdir, \"protostats\",  &protostats);\n-#ifdef AUTOKEY\n \tfilegen_register(statsdir, \"cryptostats\", &cryptostats);\n-#endif\t\/* AUTOKEY *\/\n-#ifdef DEBUG_TIMING\n \tfilegen_register(statsdir, \"timingstats\", &timingstats);\n-#endif\t\/* DEBUG_TIMING *\/\n \t\/*\n \t * register with libntp ntp_set_tod() to call us back\n \t * when time is stepped.\n","owner":"ntp-project","repo":"ntp","source":"cve"},{"CVE_ID":"CVE-2013-1848","CWE_ID":"20","category":"security","commit_id":"8d0c2d10dd72c5292eda7a06231056a4c972e4cc","commit_message":"From 8d0c2d10dd72c5292eda7a06231056a4c972e4cc Mon Sep 17 00:00:00 2001\nFrom: Lars-Peter Clausen <lars@metafoo.de>\nDate: Sat, 9 Mar 2013 15:28:44 +0100\nSubject: ext3: Fix format string issues\n\next3_msg() takes the printk prefix as the second parameter and the\nformat string as the third parameter. Two callers of ext3_msg omit the\nprefix and pass the format string as the second parameter and the first\nparameter to the format string as the third parameter. In both cases\nthis string comes from an arbitrary source. Which means the string may\ncontain format string characters, which will\nlead to undefined and potentially harmful behavior.\n\nThe issue was introduced in commit 4cf46b67eb(\"ext3: Unify log messages\nin ext3\") and is fixed by this patch.\n\nCC: stable@vger.kernel.org\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nSigned-off-by: Jan Kara <jack@suse.cz>\n---\n fs\/ext3\/super.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext3\/super.c b\/fs\/ext3\/super.c\nindex 1d6e2ed85322..fb5120a5505c 100644\n--- a\/fs\/ext3\/super.c\n+++ b\/fs\/ext3\/super.c\n@@ -353,7 +353,7 @@ static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n \treturn bdev;\n \n fail:\n-\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n+\text3_msg(sb, KERN_ERR, \"error: failed to open journal device %s: %ld\",\n \t\t__bdevname(dev, b), PTR_ERR(bdev));\n \n \treturn NULL;\n@@ -887,7 +887,7 @@ static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n \t\/*todo: use simple_strtoll with >32bit ext3 *\/\n \tsb_block = simple_strtoul(options, &options, 0);\n \tif (*options && *options != ',') {\n-\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n+\t\text3_msg(sb, KERN_ERR, \"error: invalid sb specification: %s\",\n \t\t       (char *) *data);\n \t\treturn 1;\n \t}\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1748","CWE_ID":"20","category":"security","commit_id":"10022a6c66e199d8f61d9044543f38785713cbbd","commit_message":"From 10022a6c66e199d8f61d9044543f38785713cbbd Mon Sep 17 00:00:00 2001\nFrom: Oliver Hartkopp <socketcan@hartkopp.net>\nDate: Wed, 20 Apr 2011 01:57:15 +0000\nSubject: can: add missing socket check in can\/raw release\n\nv2: added space after 'if' according code style.\n\nWe can get here with a NULL socket argument passed from userspace,\nso we need to handle it accordingly.\n\nThanks to Dave Jones pointing at this issue in net\/can\/bcm.c\n\nSigned-off-by: Oliver Hartkopp <socketcan@hartkopp.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/can\/raw.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/can\/raw.c b\/net\/can\/raw.c\nindex 649acfa7c70a..0eb39a7fdf64 100644\n--- a\/net\/can\/raw.c\n+++ b\/net\/can\/raw.c\n@@ -305,7 +305,12 @@ static int raw_init(struct sock *sk)\n static int raw_release(struct socket *sock)\n {\n \tstruct sock *sk = sock->sk;\n-\tstruct raw_sock *ro = raw_sk(sk);\n+\tstruct raw_sock *ro;\n+\n+\tif (!sk)\n+\t\treturn 0;\n+\n+\tro = raw_sk(sk);\n \n \tunregister_netdevice_notifier(&ro->notifier);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2019-12439","CWE_ID":"20","category":"security","commit_id":"efc89e3b939b4bde42c10f065f6b7b02958ed50e","commit_message":"From efc89e3b939b4bde42c10f065f6b7b02958ed50e Mon Sep 17 00:00:00 2001\nFrom: Simon McVittie <smcv@debian.org>\nDate: Sat, 2 Mar 2019 12:09:03 +0000\nSubject: [PATCH] Don't create our own temporary mount point for pivot_root\n\nAn attacker could pre-create \/tmp\/.bubblewrap-$UID and make it a\nnon-directory, non-symlink (in which case mounting our tmpfs would fail,\ncausing denial of service), or make it a symlink under their control\n(potentially allowing bad things if the protected_symlinks sysctl is\nnot enabled).\n\nInstead, temporarily mount the tmpfs on a directory that we are sure\nexists and is not attacker-controlled. \/tmp (the directory itself, not\na subdirectory) will do.\n\nFixes: #304\nBug-Debian: https:\/\/bugs.debian.org\/cgi-bin\/bugreport.cgi?bug=923557\nSigned-off-by: Simon McVittie <smcv@debian.org>\n\nCloses: #305\nApproved by: cgwalters\n---\n bubblewrap.c | 20 +++++++++-----------\n 1 file changed, 9 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/bubblewrap.c b\/bubblewrap.c\nindex a3fd61f..96cf2d5 100644\n--- a\/bubblewrap.c\n+++ b\/bubblewrap.c\n@@ -2046,7 +2046,7 @@ main (int    argc,\n       char **argv)\n {\n   mode_t old_umask;\n-  cleanup_free char *base_path = NULL;\n+  const char *base_path = NULL;\n   int clone_flags;\n   char *old_cwd = NULL;\n   pid_t pid;\n@@ -2187,15 +2187,12 @@ main (int    argc,\n     die_with_error (\"Can't open \/proc\");\n \n   \/* We need *some* mountpoint where we can mount the root tmpfs.\n-     We first try in \/run, and if that fails, try in \/tmp. *\/\n-  base_path = xasprintf (\"\/run\/user\/%d\/.bubblewrap\", real_uid);\n-  if (ensure_dir (base_path, 0755))\n-    {\n-      free (base_path);\n-      base_path = xasprintf (\"\/tmp\/.bubblewrap-%d\", real_uid);\n-      if (ensure_dir (base_path, 0755))\n-        die_with_error (\"Creating root mountpoint failed\");\n-    }\n+   * Because we use pivot_root, it won't appear to be mounted from\n+   * the perspective of the sandboxed process, so we can use anywhere\n+   * that is sure to exist, that is sure to not be a symlink controlled\n+   * by someone malicious, and that we won't immediately need to\n+   * access ourselves. *\/\n+  base_path = \"\/tmp\";\n \n   __debug__ ((\"creating new namespace\\n\"));\n \n@@ -2400,7 +2397,8 @@ main (int    argc,\n   \/* We create a subdir \"$base_path\/newroot\" for the new root, that\n    * way we can pivot_root to base_path, and put the old root at\n    * \"$base_path\/oldroot\". This avoids problems accessing the oldroot\n-   * dir if the user requested to bind mount something over \/ *\/\n+   * dir if the user requested to bind mount something over \/ (or\n+   * over \/tmp, now that we use that for base_path). *\/\n \n   if (mkdir (\"newroot\", 0755))\n     die_with_error (\"Creating newroot failed\");\n","owner":"projectatomic","repo":"bubblewrap","source":"cve"},{"CVE_ID":"CVE-2012-2669","CWE_ID":"20","category":"security","commit_id":"bcc2c9c3fff859e0eb019fe6fec26f9b8eba795c","commit_message":"From bcc2c9c3fff859e0eb019fe6fec26f9b8eba795c Mon Sep 17 00:00:00 2001\nFrom: Olaf Hering <olaf@aepfle.de>\nDate: Thu, 31 May 2012 16:40:06 +0200\nSubject: [PATCH] Tools: hv: verify origin of netlink connector message\n\nThe SuSE security team suggested to use recvfrom instead of recv to be\ncertain that the connector message is originated from kernel.\n\nCVE-2012-2669\n\nSigned-off-by: Olaf Hering <olaf@aepfle.de>\nSigned-off-by: Marcus Meissner <meissner@suse.de>\nSigned-off-by: Sebastian Krahmer <krahmer@suse.de>\nSigned-off-by: K. Y. Srinivasan <kys@microsoft.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n tools\/hv\/hv_kvp_daemon.c | 10 +++++++---\n 1 file changed, 7 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/tools\/hv\/hv_kvp_daemon.c b\/tools\/hv\/hv_kvp_daemon.c\nindex 146fd6147e84b..d9834b3629437 100644\n--- a\/tools\/hv\/hv_kvp_daemon.c\n+++ b\/tools\/hv\/hv_kvp_daemon.c\n@@ -701,14 +701,18 @@ int main(void)\n \tpfd.fd = fd;\n \n \twhile (1) {\n+\t\tstruct sockaddr *addr_p = (struct sockaddr *) &addr;\n+\t\tsocklen_t addr_l = sizeof(addr);\n \t\tpfd.events = POLLIN;\n \t\tpfd.revents = 0;\n \t\tpoll(&pfd, 1, -1);\n \n-\t\tlen = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0);\n+\t\tlen = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,\n+\t\t\t\taddr_p, &addr_l);\n \n-\t\tif (len < 0) {\n-\t\t\tsyslog(LOG_ERR, \"recv failed; error:%d\", len);\n+\t\tif (len < 0 || addr.nl_pid) {\n+\t\t\tsyslog(LOG_ERR, \"recvfrom failed; pid:%u error:%d %s\",\n+\t\t\t\t\taddr.nl_pid, errno, strerror(errno));\n \t\t\tclose(fd);\n \t\t\treturn -1;\n \t\t}\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1016","CWE_ID":"20","category":"security","commit_id":"fff1ce4dc6113b6fdc4e3a815ca5fd229408f8ef","commit_message":"From fff1ce4dc6113b6fdc4e3a815ca5fd229408f8ef Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Marek=20Ol=C5=A1=C3=A1k?= <maraeo@gmail.com>\nDate: Mon, 14 Feb 2011 01:01:10 +0100\nSubject: drm\/radeon\/kms: check AA resolve registers on r300\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nThis is an important security fix because we allowed arbitrary values\nto be passed to AARESOLVE_OFFSET. This also puts the right buffer address\nin the register.\n\nSigned-off-by: Marek Ol\u0161\u00e1k <maraeo@gmail.com>\nSigned-off-by: Dave Airlie <airlied@redhat.com>\n---\n drivers\/gpu\/drm\/radeon\/r100.c         | 23 +++++++++++++++++++++++\n drivers\/gpu\/drm\/radeon\/r100_track.h   |  4 +++-\n drivers\/gpu\/drm\/radeon\/r300.c         | 21 +++++++++++++++++++++\n drivers\/gpu\/drm\/radeon\/r300_reg.h     |  2 ++\n drivers\/gpu\/drm\/radeon\/reg_srcs\/r300  |  3 ---\n drivers\/gpu\/drm\/radeon\/reg_srcs\/r420  |  3 ---\n drivers\/gpu\/drm\/radeon\/reg_srcs\/rs600 |  3 ---\n drivers\/gpu\/drm\/radeon\/reg_srcs\/rv515 |  3 ---\n 8 files changed, 49 insertions(+), 13 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/gpu\/drm\/radeon\/r100.c b\/drivers\/gpu\/drm\/radeon\/r100.c\nindex fdf4bc67ae58..56deae5bf02e 100644\n--- a\/drivers\/gpu\/drm\/radeon\/r100.c\n+++ b\/drivers\/gpu\/drm\/radeon\/r100.c\n@@ -3381,6 +3381,26 @@ int r100_cs_track_check(struct radeon_device *rdev, struct r100_cs_track *track)\n \t}\n \ttrack->zb_dirty = false;\n \n+\tif (track->aa_dirty && track->aaresolve) {\n+\t\tif (track->aa.robj == NULL) {\n+\t\t\tDRM_ERROR(\"[drm] No buffer for AA resolve buffer %d !\\n\", i);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t\t\/* I believe the format comes from colorbuffer0. *\/\n+\t\tsize = track->aa.pitch * track->cb[0].cpp * track->maxy;\n+\t\tsize += track->aa.offset;\n+\t\tif (size > radeon_bo_size(track->aa.robj)) {\n+\t\t\tDRM_ERROR(\"[drm] Buffer too small for AA resolve buffer %d \"\n+\t\t\t\t  \"(need %lu have %lu) !\\n\", i, size,\n+\t\t\t\t  radeon_bo_size(track->aa.robj));\n+\t\t\tDRM_ERROR(\"[drm] AA resolve buffer %d (%u %u %u %u)\\n\",\n+\t\t\t\t  i, track->aa.pitch, track->cb[0].cpp,\n+\t\t\t\t  track->aa.offset, track->maxy);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t}\n+\ttrack->aa_dirty = false;\n+\n \tprim_walk = (track->vap_vf_cntl >> 4) & 0x3;\n \tif (track->vap_vf_cntl & (1 << 14)) {\n \t\tnverts = track->vap_alt_nverts;\n@@ -3455,6 +3475,7 @@ void r100_cs_track_clear(struct radeon_device *rdev, struct r100_cs_track *track\n \ttrack->cb_dirty = true;\n \ttrack->zb_dirty = true;\n \ttrack->tex_dirty = true;\n+\ttrack->aa_dirty = true;\n \n \tif (rdev->family < CHIP_R300) {\n \t\ttrack->num_cb = 1;\n@@ -3469,6 +3490,8 @@ void r100_cs_track_clear(struct radeon_device *rdev, struct r100_cs_track *track\n \t\ttrack->num_texture = 16;\n \t\ttrack->maxy = 4096;\n \t\ttrack->separate_cube = 0;\n+\t\ttrack->aaresolve = true;\n+\t\ttrack->aa.robj = NULL;\n \t}\n \n \tfor (i = 0; i < track->num_cb; i++) {\ndiff --git a\/drivers\/gpu\/drm\/radeon\/r100_track.h b\/drivers\/gpu\/drm\/radeon\/r100_track.h\nindex ee85c4a1fc08..2fef9de7f363 100644\n--- a\/drivers\/gpu\/drm\/radeon\/r100_track.h\n+++ b\/drivers\/gpu\/drm\/radeon\/r100_track.h\n@@ -66,15 +66,17 @@ struct r100_cs_track {\n \tstruct r100_cs_track_array\tarrays[11];\n \tstruct r100_cs_track_cb \tcb[R300_MAX_CB];\n \tstruct r100_cs_track_cb \tzb;\n+\tstruct r100_cs_track_cb \taa;\n \tstruct r100_cs_track_texture\ttextures[R300_TRACK_MAX_TEXTURE];\n \tbool\t\t\t\tz_enabled;\n \tbool                            separate_cube;\n \tbool\t\t\t\tzb_cb_clear;\n \tbool\t\t\t\tblend_read_enable;\n-\n \tbool\t\t\t\tcb_dirty;\n \tbool\t\t\t\tzb_dirty;\n \tbool\t\t\t\ttex_dirty;\n+\tbool\t\t\t\taa_dirty;\n+\tbool\t\t\t\taaresolve;\n };\n \n int r100_cs_track_check(struct radeon_device *rdev, struct r100_cs_track *track);\ndiff --git a\/drivers\/gpu\/drm\/radeon\/r300.c b\/drivers\/gpu\/drm\/radeon\/r300.c\nindex 862b61742b82..768c60ee4ab6 100644\n--- a\/drivers\/gpu\/drm\/radeon\/r300.c\n+++ b\/drivers\/gpu\/drm\/radeon\/r300.c\n@@ -1104,6 +1104,27 @@ static int r300_packet0_check(struct radeon_cs_parser *p,\n \t\ttrack->blend_read_enable = !!(idx_value & (1 << 2));\n \t\ttrack->cb_dirty = true;\n \t\tbreak;\n+\tcase R300_RB3D_AARESOLVE_OFFSET:\n+\t\tr = r100_cs_packet_next_reloc(p, &reloc);\n+\t\tif (r) {\n+\t\t\tDRM_ERROR(\"No reloc for ib[%d]=0x%04X\\n\",\n+\t\t\t\t  idx, reg);\n+\t\t\tr100_cs_dump_packet(p, pkt);\n+\t\t\treturn r;\n+\t\t}\n+\t\ttrack->aa.robj = reloc->robj;\n+\t\ttrack->aa.offset = idx_value;\n+\t\ttrack->aa_dirty = true;\n+\t\tib[idx] = idx_value + ((u32)reloc->lobj.gpu_offset);\n+\t\tbreak;\n+\tcase R300_RB3D_AARESOLVE_PITCH:\n+\t\ttrack->aa.pitch = idx_value & 0x3FFE;\n+\t\ttrack->aa_dirty = true;\n+\t\tbreak;\n+\tcase R300_RB3D_AARESOLVE_CTL:\n+\t\ttrack->aaresolve = idx_value & 0x1;\n+\t\ttrack->aa_dirty = true;\n+\t\tbreak;\n \tcase 0x4f30: \/* ZB_MASK_OFFSET *\/\n \tcase 0x4f34: \/* ZB_ZMASK_PITCH *\/\n \tcase 0x4f44: \/* ZB_HIZ_OFFSET *\/\ndiff --git a\/drivers\/gpu\/drm\/radeon\/r300_reg.h b\/drivers\/gpu\/drm\/radeon\/r300_reg.h\nindex 1a0d5362cd79..f0bce399c9f3 100644\n--- a\/drivers\/gpu\/drm\/radeon\/r300_reg.h\n+++ b\/drivers\/gpu\/drm\/radeon\/r300_reg.h\n@@ -1371,6 +1371,8 @@\n #define R300_RB3D_COLORPITCH2               0x4E40 \/* GUESS *\/\n #define R300_RB3D_COLORPITCH3               0x4E44 \/* GUESS *\/\n \n+#define R300_RB3D_AARESOLVE_OFFSET          0x4E80\n+#define R300_RB3D_AARESOLVE_PITCH           0x4E84\n #define R300_RB3D_AARESOLVE_CTL             0x4E88\n \/* gap *\/\n \ndiff --git a\/drivers\/gpu\/drm\/radeon\/reg_srcs\/r300 b\/drivers\/gpu\/drm\/radeon\/reg_srcs\/r300\nindex 13a94e2ee03b..e8a1786b6426 100644\n--- a\/drivers\/gpu\/drm\/radeon\/reg_srcs\/r300\n+++ b\/drivers\/gpu\/drm\/radeon\/reg_srcs\/r300\n@@ -704,9 +704,6 @@ r300 0x4f60\n 0x4E74 RB3D_CMASK_WRINDEX\n 0x4E78 RB3D_CMASK_DWORD\n 0x4E7C RB3D_CMASK_RDINDEX\n-0x4E80 RB3D_AARESOLVE_OFFSET\n-0x4E84 RB3D_AARESOLVE_PITCH\n-0x4E88 RB3D_AARESOLVE_CTL\n 0x4EA0 RB3D_DISCARD_SRC_PIXEL_LTE_THRESHOLD\n 0x4EA4 RB3D_DISCARD_SRC_PIXEL_GTE_THRESHOLD\n 0x4F04 ZB_ZSTENCILCNTL\ndiff --git a\/drivers\/gpu\/drm\/radeon\/reg_srcs\/r420 b\/drivers\/gpu\/drm\/radeon\/reg_srcs\/r420\nindex 5c95cf87f7f2..722074e21e2f 100644\n--- a\/drivers\/gpu\/drm\/radeon\/reg_srcs\/r420\n+++ b\/drivers\/gpu\/drm\/radeon\/reg_srcs\/r420\n@@ -770,9 +770,6 @@ r420 0x4f60\n 0x4E74 RB3D_CMASK_WRINDEX\n 0x4E78 RB3D_CMASK_DWORD\n 0x4E7C RB3D_CMASK_RDINDEX\n-0x4E80 RB3D_AARESOLVE_OFFSET\n-0x4E84 RB3D_AARESOLVE_PITCH\n-0x4E88 RB3D_AARESOLVE_CTL\n 0x4EA0 RB3D_DISCARD_SRC_PIXEL_LTE_THRESHOLD\n 0x4EA4 RB3D_DISCARD_SRC_PIXEL_GTE_THRESHOLD\n 0x4F04 ZB_ZSTENCILCNTL\ndiff --git a\/drivers\/gpu\/drm\/radeon\/reg_srcs\/rs600 b\/drivers\/gpu\/drm\/radeon\/reg_srcs\/rs600\nindex 263109c1d0c8..d9f62866bbc1 100644\n--- a\/drivers\/gpu\/drm\/radeon\/reg_srcs\/rs600\n+++ b\/drivers\/gpu\/drm\/radeon\/reg_srcs\/rs600\n@@ -770,9 +770,6 @@ rs600 0x6d40\n 0x4E74 RB3D_CMASK_WRINDEX\n 0x4E78 RB3D_CMASK_DWORD\n 0x4E7C RB3D_CMASK_RDINDEX\n-0x4E80 RB3D_AARESOLVE_OFFSET\n-0x4E84 RB3D_AARESOLVE_PITCH\n-0x4E88 RB3D_AARESOLVE_CTL\n 0x4EA0 RB3D_DISCARD_SRC_PIXEL_LTE_THRESHOLD\n 0x4EA4 RB3D_DISCARD_SRC_PIXEL_GTE_THRESHOLD\n 0x4F04 ZB_ZSTENCILCNTL\ndiff --git a\/drivers\/gpu\/drm\/radeon\/reg_srcs\/rv515 b\/drivers\/gpu\/drm\/radeon\/reg_srcs\/rv515\nindex eeed003f14c7..911a8fbd32bb 100644\n--- a\/drivers\/gpu\/drm\/radeon\/reg_srcs\/rv515\n+++ b\/drivers\/gpu\/drm\/radeon\/reg_srcs\/rv515\n@@ -481,9 +481,6 @@ rv515 0x6d40\n 0x4E74 RB3D_CMASK_WRINDEX\n 0x4E78 RB3D_CMASK_DWORD\n 0x4E7C RB3D_CMASK_RDINDEX\n-0x4E80 RB3D_AARESOLVE_OFFSET\n-0x4E84 RB3D_AARESOLVE_PITCH\n-0x4E88 RB3D_AARESOLVE_CTL\n 0x4EA0 RB3D_DISCARD_SRC_PIXEL_LTE_THRESHOLD\n 0x4EA4 RB3D_DISCARD_SRC_PIXEL_GTE_THRESHOLD\n 0x4EF8 RB3D_CONSTANT_COLOR_AR\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-1819","CWE_ID":"20","category":"security","commit_id":"eb178619f930fa2ba2348de332a1ff1c66a31424","commit_message":"From eb178619f930fa2ba2348de332a1ff1c66a31424 Mon Sep 17 00:00:00 2001\nFrom: Dave Chinner <dchinner@redhat.com>\nDate: Mon, 21 Jan 2013 23:53:52 +1100\nSubject: xfs: fix _xfs_buf_find oops on blocks beyond the filesystem end\n\nWhen _xfs_buf_find is passed an out of range address, it will fail\nto find a relevant struct xfs_perag and oops with a null\ndereference. This can happen when trying to walk a filesystem with a\nmetadata inode that has a partially corrupted extent map (i.e. the\nblock number returned is corrupt, but is otherwise intact) and we\ntry to read from the corrupted block address.\n\nIn this case, just fail the lookup. If it is readahead being issued,\nit will simply not be done, but if it is real read that fails we\nwill get an error being reported.  Ideally this case should result\nin an EFSCORRUPTED error being reported, but we cannot return an\nerror through xfs_buf_read() or xfs_buf_get() so this lookup failure\nmay result in ENOMEM or EIO errors being reported instead.\n\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Brian Foster <bfoster@redhat.com>\nReviewed-by: Ben Myers <bpm@sgi.com>\nSigned-off-by: Ben Myers <bpm@sgi.com>\n---\n fs\/xfs\/xfs_buf.c | 18 ++++++++++++++++++\n 1 file changed, 18 insertions(+)\n\n","diff_code":"diff --git a\/fs\/xfs\/xfs_buf.c b\/fs\/xfs\/xfs_buf.c\nindex 56d1614760cf..689d72655ea6 100644\n--- a\/fs\/xfs\/xfs_buf.c\n+++ b\/fs\/xfs\/xfs_buf.c\n@@ -487,6 +487,7 @@ _xfs_buf_find(\n \tstruct rb_node\t\t*parent;\n \txfs_buf_t\t\t*bp;\n \txfs_daddr_t\t\tblkno = map[0].bm_bn;\n+\txfs_daddr_t\t\teofs;\n \tint\t\t\tnumblks = 0;\n \tint\t\t\ti;\n \n@@ -498,6 +499,23 @@ _xfs_buf_find(\n \tASSERT(!(numbytes < (1 << btp->bt_sshift)));\n \tASSERT(!(BBTOB(blkno) & (xfs_off_t)btp->bt_smask));\n \n+\t\/*\n+\t * Corrupted block numbers can get through to here, unfortunately, so we\n+\t * have to check that the buffer falls within the filesystem bounds.\n+\t *\/\n+\teofs = XFS_FSB_TO_BB(btp->bt_mount, btp->bt_mount->m_sb.sb_dblocks);\n+\tif (blkno >= eofs) {\n+\t\t\/*\n+\t\t * XXX (dgc): we should really be returning EFSCORRUPTED here,\n+\t\t * but none of the higher level infrastructure supports\n+\t\t * returning a specific error on buffer lookup failures.\n+\t\t *\/\n+\t\txfs_alert(btp->bt_mount,\n+\t\t\t  \"%s: Block out of range: block 0x%llx, EOFS 0x%llx \",\n+\t\t\t  __func__, blkno, eofs);\n+\t\treturn NULL;\n+\t}\n+\n \t\/* get tree root *\/\n \tpag = xfs_perag_get(btp->bt_mount,\n \t\t\t\txfs_daddr_to_agno(btp->bt_mount, blkno));\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-6368","CWE_ID":"20","category":"security","commit_id":"fda4e2e85589191b123d31cdc21fd33ee70f50fd","commit_message":"From fda4e2e85589191b123d31cdc21fd33ee70f50fd Mon Sep 17 00:00:00 2001\nFrom: Andy Honig <ahonig@google.com>\nDate: Wed, 20 Nov 2013 10:23:22 -0800\nSubject: [PATCH] KVM: x86: Convert vapic synchronization to _cached functions\n (CVE-2013-6368)\n\nIn kvm_lapic_sync_from_vapic and kvm_lapic_sync_to_vapic there is the\npotential to corrupt kernel memory if userspace provides an address that\nis at the end of a page.  This patches concerts those functions to use\nkvm_write_guest_cached and kvm_read_guest_cached.  It also checks the\nvapic_address specified by userspace during ioctl processing and returns\nan error to userspace if the address is not a valid GPA.\n\nThis is generally not guest triggerable, because the required write is\ndone by firmware that runs before the guest.  Also, it only affects AMD\nprocessors and oldish Intel that do not have the FlexPriority feature\n(unless you disable FlexPriority, of course; then newer processors are\nalso affected).\n\nFixes: b93463aa59d6 ('KVM: Accelerated apic support')\n\nReported-by: Andrew Honig <ahonig@google.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Andrew Honig <ahonig@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n arch\/x86\/kvm\/lapic.c | 27 +++++++++++++++------------\n arch\/x86\/kvm\/lapic.h |  4 ++--\n arch\/x86\/kvm\/x86.c   | 40 +---------------------------------------\n 3 files changed, 18 insertions(+), 53 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/lapic.c b\/arch\/x86\/kvm\/lapic.c\nindex 89b52ec7d09c5..b8bec45c1610d 100644\n--- a\/arch\/x86\/kvm\/lapic.c\n+++ b\/arch\/x86\/kvm\/lapic.c\n@@ -1692,7 +1692,6 @@ static void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n {\n \tu32 data;\n-\tvoid *vapic;\n \n \tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n \t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n@@ -1700,9 +1699,8 @@ void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n \tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n \t\treturn;\n \n-\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n-\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n-\tkunmap_atomic(vapic);\n+\tkvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n+\t\t\t\tsizeof(u32));\n \n \tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n }\n@@ -1738,7 +1736,6 @@ void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n \tu32 data, tpr;\n \tint max_irr, max_isr;\n \tstruct kvm_lapic *apic = vcpu->arch.apic;\n-\tvoid *vapic;\n \n \tapic_sync_pv_eoi_to_guest(vcpu, apic);\n \n@@ -1754,18 +1751,24 @@ void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n \t\tmax_isr = 0;\n \tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n \n-\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n-\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n-\tkunmap_atomic(vapic);\n+\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n+\t\t\t\tsizeof(u32));\n }\n \n-void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n+int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n {\n-\tvcpu->arch.apic->vapic_addr = vapic_addr;\n-\tif (vapic_addr)\n+\tif (vapic_addr) {\n+\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n+\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n+\t\t\t\t\tvapic_addr, sizeof(u32)))\n+\t\t\treturn -EINVAL;\n \t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n-\telse\n+\t} else {\n \t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n+\t}\n+\n+\tvcpu->arch.apic->vapic_addr = vapic_addr;\n+\treturn 0;\n }\n \n int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\ndiff --git a\/arch\/x86\/kvm\/lapic.h b\/arch\/x86\/kvm\/lapic.h\nindex c730ac9fe8018..c8b0d0d2da5ce 100644\n--- a\/arch\/x86\/kvm\/lapic.h\n+++ b\/arch\/x86\/kvm\/lapic.h\n@@ -34,7 +34,7 @@ struct kvm_lapic {\n \t *\/\n \tvoid *regs;\n \tgpa_t vapic_addr;\n-\tstruct page *vapic_page;\n+\tstruct gfn_to_hva_cache vapic_cache;\n \tunsigned long pending_events;\n \tunsigned int sipi_vector;\n };\n@@ -76,7 +76,7 @@ void kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data);\n void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset);\n void kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector);\n \n-void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr);\n+int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr);\n void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu);\n void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu);\n \ndiff --git a\/arch\/x86\/kvm\/x86.c b\/arch\/x86\/kvm\/x86.c\nindex 21ef1ba184ae8..5d004da1e35da 100644\n--- a\/arch\/x86\/kvm\/x86.c\n+++ b\/arch\/x86\/kvm\/x86.c\n@@ -3214,8 +3214,7 @@ long kvm_arch_vcpu_ioctl(struct file *filp,\n \t\tr = -EFAULT;\n \t\tif (copy_from_user(&va, argp, sizeof va))\n \t\t\tgoto out;\n-\t\tr = 0;\n-\t\tkvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n+\t\tr = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n \t\tbreak;\n \t}\n \tcase KVM_X86_SETUP_MCE: {\n@@ -5739,36 +5738,6 @@ static void post_kvm_run_save(struct kvm_vcpu *vcpu)\n \t\t\t!kvm_event_needs_reinjection(vcpu);\n }\n \n-static int vapic_enter(struct kvm_vcpu *vcpu)\n-{\n-\tstruct kvm_lapic *apic = vcpu->arch.apic;\n-\tstruct page *page;\n-\n-\tif (!apic || !apic->vapic_addr)\n-\t\treturn 0;\n-\n-\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n-\tif (is_error_page(page))\n-\t\treturn -EFAULT;\n-\n-\tvcpu->arch.apic->vapic_page = page;\n-\treturn 0;\n-}\n-\n-static void vapic_exit(struct kvm_vcpu *vcpu)\n-{\n-\tstruct kvm_lapic *apic = vcpu->arch.apic;\n-\tint idx;\n-\n-\tif (!apic || !apic->vapic_addr)\n-\t\treturn;\n-\n-\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n-\tkvm_release_page_dirty(apic->vapic_page);\n-\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n-\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n-}\n-\n static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n {\n \tint max_irr, tpr;\n@@ -6069,11 +6038,6 @@ static int __vcpu_run(struct kvm_vcpu *vcpu)\n \tstruct kvm *kvm = vcpu->kvm;\n \n \tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n-\tr = vapic_enter(vcpu);\n-\tif (r) {\n-\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n-\t\treturn r;\n-\t}\n \n \tr = 1;\n \twhile (r > 0) {\n@@ -6132,8 +6096,6 @@ static int __vcpu_run(struct kvm_vcpu *vcpu)\n \n \tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n \n-\tvapic_exit(vcpu);\n-\n \treturn r;\n }\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-9310","CWE_ID":"20","category":"security","commit_id":"4154c7e03fa55b4cf52509a83d50d6c09d743b77","commit_message":"From 4154c7e03fa55b4cf52509a83d50d6c09d743b77 Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liq3ea@gmail.com>\nDate: Thu, 9 Feb 2017 18:19:19 -0800\nSubject: [PATCH] net: e1000e: fix an infinite loop issue\n\nThis issue is like the issue in e1000 network card addressed in\nthis commit:\ne1000: eliminate infinite loops on out-of-bounds transfer start.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nReviewed-by: Dmitry Fleytman <dmitry@daynix.com>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\n---\n hw\/net\/e1000e_core.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/net\/e1000e_core.c b\/hw\/net\/e1000e_core.c\nindex c99e2fb..28c5be1 100644\n--- a\/hw\/net\/e1000e_core.c\n+++ b\/hw\/net\/e1000e_core.c\n@@ -806,7 +806,8 @@ typedef struct E1000E_RingInfo_st {\n static inline bool\n e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n {\n-    return core->mac[r->dh] == core->mac[r->dt];\n+    return core->mac[r->dh] == core->mac[r->dt] ||\n+                core->mac[r->dt] >= core->mac[r->dlen] \/ E1000_RING_DESC_LEN;\n }\n \n static inline uint64_t\n@@ -1522,6 +1523,10 @@ e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n             desc_size = core->rx_desc_buf_size;\n         }\n \n+        if (e1000e_ring_empty(core, rxi)) {\n+            return;\n+        }\n+\n         base = e1000e_ring_head_descr(core, rxi);\n \n         pci_dma_read(d, base, &desc, core->rx_desc_len);\n-- \n1.8.3.1\n\n","owner":"qemu","repo":"qemu","source":"cve"},{"CVE_ID":"CVE-2014-8324","CWE_ID":"20","category":"security","commit_id":"88702a3ce4c28a973bf69023cd0312f412f6193e","commit_message":"From 88702a3ce4c28a973bf69023cd0312f412f6193e Mon Sep 17 00:00:00 2001\nFrom: Thomas d'Otreppe <tdotreppe@aircrack-ng.org>\nDate: Fri, 3 Oct 2014 02:00:34 +0000\nSubject: [PATCH] OSdep: Fixed segmentation fault that happens with a malicious\n server sending a negative length (Closes #16 on GitHub).\n\ngit-svn-id: http:\/\/svn.aircrack-ng.org\/trunk@2419 28c6078b-6c39-48e3-add9-af49d547ecab\n---\n src\/osdep\/network.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/osdep\/network.c b\/src\/osdep\/network.c\nindex 4f0f8b23..4ebfaf41 100644\n--- a\/src\/osdep\/network.c\n+++ b\/src\/osdep\/network.c\n@@ -131,7 +131,7 @@ int net_get(int s, void *arg, int *len)\n \tif (!(plen <= *len))\n \t\tprintf(\"PLEN %d type %d len %d\\n\",\n \t\t\tplen, nh.nh_type, *len);\n-\tassert(plen <= *len); \/* XXX *\/\n+\tassert(plen <= *len && plen > 0); \/* XXX *\/\n \n \t*len = plen;\n \tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n","owner":"aircrack-ng","repo":"aircrack-ng","source":"cve"},{"CVE_ID":"CVE-2016-6129","CWE_ID":"20","category":"security","commit_id":"5eb9743410ce4657e9d54fef26a2ee31a1b5dd09","commit_message":"From 5eb9743410ce4657e9d54fef26a2ee31a1b5dd09 Mon Sep 17 00:00:00 2001\nFrom: Steffen Jaeckel <s@jaeckel.eu>\nDate: Wed, 6 Aug 2014 15:03:46 +0200\nSubject: [PATCH] rsa_verify_hash: fix possible bleichenbacher signature attack\n\n---\n src\/pk\/rsa\/rsa_verify_hash.c | 10 ++++++++--\n 1 file changed, 8 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/src\/pk\/rsa\/rsa_verify_hash.c b\/src\/pk\/rsa\/rsa_verify_hash.c\nindex 5639cd46f..fc000dee2 100644\n--- a\/src\/pk\/rsa\/rsa_verify_hash.c\n+++ b\/src\/pk\/rsa\/rsa_verify_hash.c\n@@ -103,7 +103,7 @@ int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n   } else {\n     \/* PKCS #1 v1.5 decode it *\/\n     unsigned char *out;\n-    unsigned long outlen, loid[16];\n+    unsigned long outlen, loid[16], reallen;\n     int           decoded;\n     ltc_asn1_list digestinfo[2], siginfo[2];\n \n@@ -145,8 +145,14 @@ int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen,\n        goto bail_2;\n     }\n \n+    if ((err = der_length_sequence(siginfo, 2, &reallen)) != CRYPT_OK) {\n+       XFREE(out);\n+       goto bail_2;\n+    }\n+\n     \/* test OID *\/\n-    if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n+    if ((reallen == outlen) &&\n+        (digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) &&\n         (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) &&\n         (siginfo[1].size == hashlen) &&\n         (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) {\n","owner":"libtom","repo":"libtomcrypt","source":"cve"},{"CVE_ID":"CVE-2013-1417","CWE_ID":"20","category":"security","commit_id":"4c023ba43c16396f0d199e2df1cfa59b88b62acc","commit_message":"From 4c023ba43c16396f0d199e2df1cfa59b88b62acc Mon Sep 17 00:00:00 2001\nFrom: Tom Yu <tlyu@mit.edu>\nDate: Fri, 21 Jun 2013 17:58:25 -0400\nSubject: [PATCH] KDC null deref due to referrals [CVE-2013-1417]\n\nAn authenticated remote client can cause a KDC to crash by making a\nvalid TGS-REQ to a KDC serving a realm with a single-component name.\nThe process_tgs_req() function dereferences a null pointer because an\nunusual failure condition causes a helper function to return success.\n\nWhile attempting to provide cross-realm referrals for host-based\nservice principals, the find_referral_tgs() function could return a\nTGS principal for a zero-length realm name (indicating that the\nhostname in the service principal has no known realm associated with\nit).\n\nSubsequently, the find_alternate_tgs() function would attempt to\nconstruct a path to this empty-string realm, and return success along\nwith a null pointer in its output parameter.  This happens because\nkrb5_walk_realm_tree() returns a list of length one when it attempts\nto construct a transit path between a single-component realm and the\nempty-string realm.  This list causes a loop in find_alternate_tgs()\nto iterate over zero elements, resulting in the unexpected output of a\nnull pointer, which process_tgs_req() proceeds to dereference because\nthere is no error condition.\n\nAdd an error condition to find_referral_tgs() when\nkrb5_get_host_realm() returns an empty realm name.  Also add an error\ncondition to find_alternate_tgs() to handle the length-one output from\nkrb5_walk_realm_tree().\n\nThe vulnerable configuration is not likely to arise in practice.\n(Realm names that have a single component are likely to be test\nrealms.)  Releases prior to krb5-1.11 are not vulnerable.\n\nThanks to Sol Jerome for reporting this problem.\n\nCVSSv2: AV:N\/AC:M\/Au:S\/C:N\/I:N\/A:P\/E:H\/RL:O\/RC:C\n\n(cherry picked from commit 3c7f1c21ffaaf6c90f1045f0f5440303c766acc0)\n\nticket: 7668\nversion_fixed: 1.11.4\nstatus: resolved\n---\n src\/kdc\/do_tgs_req.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/src\/kdc\/do_tgs_req.c b\/src\/kdc\/do_tgs_req.c\nindex d41bc5d4ee..745a48e984 100644\n--- a\/src\/kdc\/do_tgs_req.c\n+++ b\/src\/kdc\/do_tgs_req.c\n@@ -1057,6 +1057,8 @@ find_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n         goto cleanup;\n     }\n cleanup:\n+    if (retval == 0 && server_ptr == NULL)\n+        retval = KRB5_KDB_NOENTRY;\n     if (retval != 0)\n         *status = \"UNKNOWN_SERVER\";\n \n@@ -1149,7 +1151,7 @@ find_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n         goto cleanup;\n     }\n     \/* Don't return a referral to the empty realm or the service realm. *\/\n-    if (realms == NULL || realms[0] == '\\0' ||\n+    if (realms == NULL || realms[0] == NULL || *realms[0] == '\\0' ||\n         data_eq_string(srealm, realms[0])) {\n         retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n         goto cleanup;\n","owner":"krb5","repo":"krb5","source":"cve"},{"CVE_ID":"CVE-2013-7019","CWE_ID":"20","category":"security","commit_id":"a1b9004b768bef606ee98d417bceb9392ceb788d","commit_message":"From a1b9004b768bef606ee98d417bceb9392ceb788d Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 15 Oct 2013 13:15:47 +0200\nSubject: [PATCH] avcodec\/jpeg2000dec: fix context consistency with too large\n lowres\n\nFixes out of array accesses\nFixes Ticket2898\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/jpeg2000dec.c | 15 +++++++++++----\n 1 file changed, 11 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/jpeg2000dec.c b\/libavcodec\/jpeg2000dec.c\nindex ef63d37f0c6..80bc335507f 100644\n--- a\/libavcodec\/jpeg2000dec.c\n+++ b\/libavcodec\/jpeg2000dec.c\n@@ -370,11 +370,18 @@ static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)\n         return AVERROR_INVALIDDATA;\n     }\n \n+    if (c->nreslevels <= s->reduction_factor) {\n+        \/* we are forced to update reduction_factor as its requested value is\n+           not compatible with this bitstream, and as we might have used it\n+           already in setup earlier we have to fail this frame until\n+           reinitialization is implemented *\/\n+        av_log(s->avctx, AV_LOG_ERROR, \"reduction_factor too large for this bitstream, max is %d\\n\", c->nreslevels - 1);\n+        s->reduction_factor = c->nreslevels - 1;\n+        return AVERROR(EINVAL);\n+    }\n+\n     \/* compute number of resolution levels to decode *\/\n-    if (c->nreslevels < s->reduction_factor)\n-        c->nreslevels2decode = 1;\n-    else\n-        c->nreslevels2decode = c->nreslevels - s->reduction_factor;\n+    c->nreslevels2decode = c->nreslevels - s->reduction_factor;\n \n     c->log2_cblk_width  = (bytestream2_get_byteu(&s->g) & 15) + 2; \/\/ cblk width\n     c->log2_cblk_height = (bytestream2_get_byteu(&s->g) & 15) + 2; \/\/ cblk height\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2019-1010293","CWE_ID":"20","category":"security","commit_id":"95f36d661f2b75887772ea28baaad904bde96970","commit_message":"From 95f36d661f2b75887772ea28baaad904bde96970 Mon Sep 17 00:00:00 2001\nFrom: Jens Wiklander <jens.wiklander@linaro.org>\nDate: Mon, 19 Nov 2018 13:34:23 +0100\nSubject: [PATCH] core: tee_mmu_check_access_rights() check all pages\n\nPrior to this patch tee_mmu_check_access_rights() checks an address in\neach page of a supplied range. If both the start and length of that\nrange is unaligned the last page in the range is sometimes not checked.\nWith this patch the first address of each page in the range is checked\nto simplify the logic of checking each page and the range and also to\ncover the last page under all circumstances.\n\nFixes: OP-TEE-2018-0005: \"tee_mmu_check_access_rights does not check\nfinal page of TA buffer\"\n\nSigned-off-by: Jens Wiklander <jens.wiklander@linaro.org>\nTested-by: Joakim Bech <joakim.bech@linaro.org> (QEMU v7, v8)\nReviewed-by: Joakim Bech <joakim.bech@linaro.org>\nReported-by: Riscure <inforequest@riscure.com>\nReported-by: Alyssa Milburn <a.a.milburn@vu.nl>\nAcked-by: Etienne Carriere <etienne.carriere@linaro.org>\n---\n core\/arch\/arm\/mm\/tee_mmu.c | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/core\/arch\/arm\/mm\/tee_mmu.c b\/core\/arch\/arm\/mm\/tee_mmu.c\nindex 8de6c8db10..4bc2aba5ce 100644\n--- a\/core\/arch\/arm\/mm\/tee_mmu.c\n+++ b\/core\/arch\/arm\/mm\/tee_mmu.c\n@@ -757,10 +757,11 @@ TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n+\tuaddr_t end_addr = 0;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n \n-\tif (ADD_OVERFLOW(uaddr, len, &a))\n+\tif (ADD_OVERFLOW(uaddr, len, &end_addr))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n@@ -775,7 +776,7 @@ TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \n-\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n+\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n \n","owner":"OP-TEE","repo":"optee_os","source":"cve"},{"CVE_ID":"CVE-2015-4604","CWE_ID":"20","category":"security","commit_id":"f938112c495b0d26572435c0be73ac0bfe642ecd","commit_message":"From f938112c495b0d26572435c0be73ac0bfe642ecd Mon Sep 17 00:00:00 2001\nFrom: Stanislav Malyshev <stas@php.net>\nDate: Sat, 4 Apr 2015 15:01:37 -0700\nSubject: [PATCH] Fix bug #68819 (Fileinfo on specific file causes spurious OOM\n and\/or segfault)\n\n---\n ext\/fileinfo\/libmagic\/softmagic.c    |  3 +++\n ext\/fileinfo\/tests\/bug68819_001.phpt | 18 ++++++++++++++++++\n ext\/fileinfo\/tests\/bug68819_002.phpt | 26 ++++++++++++++++++++++++++\n 3 files changed, 47 insertions(+)\n create mode 100644 ext\/fileinfo\/tests\/bug68819_001.phpt\n create mode 100644 ext\/fileinfo\/tests\/bug68819_002.phpt\n\n","diff_code":"diff --git a\/ext\/fileinfo\/libmagic\/softmagic.c b\/ext\/fileinfo\/libmagic\/softmagic.c\nindex e7b7855..54c1a03 100644\n--- a\/ext\/fileinfo\/libmagic\/softmagic.c\n+++ b\/ext\/fileinfo\/libmagic\/softmagic.c\n@@ -1037,6 +1037,9 @@ mcopy(struct magic_set *ms, union VALUETYPE *p, int type, int indir,\n \t\t\tif (bytecnt > nbytes) {\n \t\t\t\tbytecnt = nbytes;\n \t\t\t}\n+\t\t\tif (offset > bytecnt) {\n+\t\t\t\toffset = bytecnt;\n+\t\t\t}\n \t\t\tif (s == NULL) {\n \t\t\t\tms->search.s_len = 0;\n \t\t\t\tms->search.s = NULL;\ndiff --git a\/ext\/fileinfo\/tests\/bug68819_001.phpt b\/ext\/fileinfo\/tests\/bug68819_001.phpt\nnew file mode 100644\nindex 0000000..ce39ee6\n--- \/dev\/null\n+++ b\/ext\/fileinfo\/tests\/bug68819_001.phpt\n@@ -0,0 +1,18 @@\n+--TEST--\n+Bug #68819 Fileinfo on specific file causes spurious OOM and\/or segfault, var 1\n+--SKIPIF--\n+<?php require_once(dirname(__FILE__) . '\/skipif.inc'); ?>\n+--FILE--\n+<?php\n+\n+$string = <<<HERE\n+----a-----'''---------a---------------a--------a-----a-----a---------a-----as-------a----a--a-------------a--as-----s---------------a---------a---a--s-a-----a-----------asy---------a-----a-----------a----s--------a-------------a-------a--------a----s------------a-----a----------------a----s-----------------\\r\\n-------------------a-------a-a-------a-----a----a----s----s--------a-----------------------a----a----s-------------a------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a----s----s--------a----------a----------------------a----a----s-------------a----------------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n------a-------a-a-------a-----a----a---a-----a-----------------------a----a---a-----a------------------s-------a----a---a-----a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s------\\r\\n-------------------a-------a-a-------a-----a----a---a-------a------------------------a----a---a-----''--a-------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a-------s-----a---a-------------------------a----a-------------a---a-------------------s-------a----a-------------a---a-----as-a--------------a-----a--s----s---------y------------a-----a-s---a-------''----a---s--a-''------''----s------------a-y----------------s------a-----y--a-s--a-s------s--a-s----------''----------------------------a---s--a----a---------a-s---a-s--------s--------a---------s--a-y-------------as----a----a-------------a------a---s--a-s------a--------a----s----y--as--a----a-s---------------a-----a--------------------------------------\\r\\n-------------------a-------a-a-------a-----a----a-----------s--------a-----------------------a----a--------------------a------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a-----------s--------a----------a----------------------a----a--------------------a------------------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a---a-----------------------a----a---a------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a---a----------a----------------------a----a---a------------------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-----a-a-----------a-------a-a-------a-----a----a----a---s-----a-----------------------a----a----a---------a-----------------s-------a----a----a---------a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a--------a----a-----------------------a----a----------a----a------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-----a-------------a-------a-a-------a-----a----a--------s-----a---a-------------------------a----a--------------a---a-------------------s-------------a---------------a----a---a---a-----as-a--------------a-----a--s----s---------y------------a-----a-s---a-------''----a---s--a-''------''----s------------a-y----------------s------a-----y--a-s--a-s------s--a-s----------''----------------------------a---s--a----a---------a-s---a-s--------s--------a---------s--a-y-------------as----a----a-------------a------a---s--a-s------a--------a----s----y--as--a----a-s---------------a-----a--------------------------------------\\r\\n-------------------a-------a-a-------a-----a----a----------------a-----------------------a----a----------------a------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a-------a-----a----a----------------a----------a----------------------a----a----------------a-----------------------------s-------a----a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n---a---------------a-------a-a-------a-----as------------------------a--a--s------------------a-s------------------------a-----s--a-----'''----------a-s---------------------------------------------a-----s--a-----------------a---------a---a--s-a-----a-----------asy---------a-----a-----------a----s----------------------a----s--a-------------a-------a--------a----s------------a-----a----------------a----s------------------\\r\\n-a-----------------a-------a-a-------a--y---------a------------------y---------a-----'''-------y------a-y--a-------------------------a---------a---a----------as-a---a--s-a-----a-----------asy---------a-----a-----------a----s--------a-------------a-------a--------a----s---------a-----a----------------a----s------------------\\r\\n-a-----------------a-------a-a-------a--y-------------a------------------y-------------a-----'''-------y----------a-y--a-------------------------a---------a---a----------as-a---a--s-a-----a-----------asy---------a-----a-----------a----s--------a-------------a-------a--------a----s---------a-----a----------------a----s------------------\\r\\n-------------------a-------a-a-------a--a----a-----a------------------a----a-----a-----'''----------a----s----a----a-------s---a------------------a-----------a--s-a-----a---------------------a------a----s-a-----a-------s-s-------a----s--------a-------------a-------a--------a----s---------a-----a----------------a----s------------------\\r\\n------aa-----------a-------a-a------------s-a--s---------a---a------------------------a------------a---a------------------s--------a------------a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a------------------------s-----s--a----a-----------------------------------------s--a----a------------------s---------------------------------s--a----a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s--------------a-----a----------a----------s--a----------s-----------------\\r\\n-------------------a-------a-a--------------s-a---a--------------------------a---a------------------s----------a---a------as---s-a--------------s-----a------a-y--a-------a-----a--a--------a----s--------a-------------a-------a--------a----s---------------a-----a----------a----------s--a----------s-----------------\\r\\nsay-------a------------s-----''------a----s--------a-------------a-\\r\\n\n+HERE;\n+\n+$finfo = new finfo();\n+$type = $finfo->buffer($string);\n+\n+var_dump($type);\n+?>\n+--EXPECT--\n+string(60) \"ASCII text, with very long lines, with CRLF line terminators\"\ndiff --git a\/ext\/fileinfo\/tests\/bug68819_002.phpt b\/ext\/fileinfo\/tests\/bug68819_002.phpt\nnew file mode 100644\nindex 0000000..cec238d\n--- \/dev\/null\n+++ b\/ext\/fileinfo\/tests\/bug68819_002.phpt\n@@ -0,0 +1,26 @@\n+--TEST--\n+Bug #68819 Fileinfo on specific file causes spurious OOM and\/or segfault, var 2\n+--SKIPIF--\n+<?php require_once(dirname(__FILE__) . '\/skipif.inc'); ?>\n+--FILE--\n+<?php\n+\n+$string = '';\n+\n+\/\/ These two in any order\n+$string .= \"\\r\\n\";\n+$string .= \"''''\";\n+\n+\/\/ Total string length > 8192\n+$string .= str_repeat(chr(rand(32, 127)), 8184);\n+\n+\/\/ Ending in this string\n+$string .= \"say\";\n+\n+$finfo = new finfo();\n+$type = $finfo->buffer($string);\n+var_dump($type);\n+\n+?>\n+--EXPECT--\n+string(60) \"ASCII text, with very long lines, with CRLF line terminators\"\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-6305","CWE_ID":"20","category":"security","commit_id":"63658103d4441924f8dbfc517b99bb54758a98b9","commit_message":"From 63658103d4441924f8dbfc517b99bb54758a98b9 Mon Sep 17 00:00:00 2001\nFrom: Matt Caswell <matt@openssl.org>\nDate: Sat, 10 Sep 2016 21:24:40 +0100\nSubject: [PATCH] Fix a hang with SSL_peek()\n\nIf while calling SSL_peek() we read an empty record then we go into an\ninfinite loop, continually trying to read data from the empty record and\nnever making any progress. This could be exploited by a malicious peer in\na Denial Of Service attack.\n\nCVE-2016-6305\n\nGitHub Issue #1563\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n---\n ssl\/record\/rec_layer_s3.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ssl\/record\/rec_layer_s3.c b\/ssl\/record\/rec_layer_s3.c\nindex abde9d4a73..0775095b9a 100644\n--- a\/ssl\/record\/rec_layer_s3.c\n+++ b\/ssl\/record\/rec_layer_s3.c\n@@ -1133,7 +1133,11 @@ int ssl3_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,\n \n             memcpy(buf, &(rr->data[rr->off]), n);\n             buf += n;\n-            if (!peek) {\n+            if (peek) {\n+                \/* Mark any zero length record as consumed CVE-2016-6305 *\/\n+                if (SSL3_RECORD_get_length(rr) == 0)\n+                    SSL3_RECORD_set_read(rr);\n+            } else {\n                 SSL3_RECORD_sub_length(rr, n);\n                 SSL3_RECORD_add_off(rr, n);\n                 if (SSL3_RECORD_get_length(rr) == 0) {\n-- \n2.17.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-2928","CWE_ID":"20","category":"security","commit_id":"338d0f0a6fbc82407864606f5b64b75aeb3c70f2","commit_message":"From 338d0f0a6fbc82407864606f5b64b75aeb3c70f2 Mon Sep 17 00:00:00 2001\nFrom: Timo Warns <Warns@pre-sense.de>\nDate: Wed, 17 Aug 2011 17:59:56 +0200\nSubject: befs: Validate length of long symbolic links.\n\nSigned-off-by: Timo Warns <warns@pre-sense.de>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/befs\/linuxvfs.c | 23 ++++++++++++++---------\n 1 file changed, 14 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/fs\/befs\/linuxvfs.c b\/fs\/befs\/linuxvfs.c\nindex 54b8c28bebc8..720d885e8dca 100644\n--- a\/fs\/befs\/linuxvfs.c\n+++ b\/fs\/befs\/linuxvfs.c\n@@ -474,17 +474,22 @@ befs_follow_link(struct dentry *dentry, struct nameidata *nd)\n \t\tbefs_data_stream *data = &befs_ino->i_data.ds;\n \t\tbefs_off_t len = data->size;\n \n-\t\tbefs_debug(sb, \"Follow long symlink\");\n-\n-\t\tlink = kmalloc(len, GFP_NOFS);\n-\t\tif (!link) {\n-\t\t\tlink = ERR_PTR(-ENOMEM);\n-\t\t} else if (befs_read_lsymlink(sb, data, link, len) != len) {\n-\t\t\tkfree(link);\n-\t\t\tbefs_error(sb, \"Failed to read entire long symlink\");\n+\t\tif (len == 0) {\n+\t\t\tbefs_error(sb, \"Long symlink with illegal length\");\n \t\t\tlink = ERR_PTR(-EIO);\n \t\t} else {\n-\t\t\tlink[len - 1] = '\\0';\n+\t\t\tbefs_debug(sb, \"Follow long symlink\");\n+\n+\t\t\tlink = kmalloc(len, GFP_NOFS);\n+\t\t\tif (!link) {\n+\t\t\t\tlink = ERR_PTR(-ENOMEM);\n+\t\t\t} else if (befs_read_lsymlink(sb, data, link, len) != len) {\n+\t\t\t\tkfree(link);\n+\t\t\t\tbefs_error(sb, \"Failed to read entire long symlink\");\n+\t\t\t\tlink = ERR_PTR(-EIO);\n+\t\t\t} else {\n+\t\t\t\tlink[len - 1] = '\\0';\n+\t\t\t}\n \t\t}\n \t} else {\n \t\tlink = befs_ino->i_data.symlink;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-13145","CWE_ID":"20","category":"security","commit_id":"acee073df34aa4d491bf5cb74d3a15fc80f0a3aa","commit_message":"From acee073df34aa4d491bf5cb74d3a15fc80f0a3aa Mon Sep 17 00:00:00 2001\nFrom: Cristy <urban-warrior@imagemagick.org>\nDate: Sun, 21 May 2017 10:54:16 -0400\nSubject: [PATCH] ...\n\n---\n coders\/jp2.c | 6 +++++-\n 1 file changed, 5 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/coders\/jp2.c b\/coders\/jp2.c\nindex 20a5960672..fe2ea13db5 100644\n--- a\/coders\/jp2.c\n+++ b\/coders\/jp2.c\n@@ -388,7 +388,11 @@ static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception)\n   opj_stream_destroy(jp2_stream);\n   for (i=0; i < (ssize_t) jp2_image->numcomps; i++)\n   {\n-    if ((jp2_image->comps[i].dx == 0) || (jp2_image->comps[i].dy == 0))\n+    if ((jp2_image->comps[0].dx == 0) || (jp2_image->comps[0].dy == 0) ||\n+        (jp2_image->comps[0].dx != jp2_image->comps[i].dx) ||\n+        (jp2_image->comps[0].dy != jp2_image->comps[i].dy) ||\n+        (jp2_image->comps[0].prec != jp2_image->comps[i].prec) ||\n+        (jp2_image->comps[0].sgnd != jp2_image->comps[i].sgnd))\n       {\n         opj_destroy_codec(jp2_codec);\n         opj_image_destroy(jp2_image);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2011-3936","CWE_ID":"20","category":"security","commit_id":"2d1c0dea5f6b91bec7f5fa53ec050913d851e366","commit_message":"From 2d1c0dea5f6b91bec7f5fa53ec050913d851e366 Mon Sep 17 00:00:00 2001\nFrom: Alex Converse <alex.converse@gmail.com>\nDate: Thu, 26 Jan 2012 15:08:26 -0800\nSubject: [PATCH] dv: Fix small stack overread related to CVE-2011-3929 and\n CVE-2011-3936.\n\nFound with asan.\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Alex Converse <alex.converse@gmail.com>\n---\n libavformat\/dv.c | 11 +++++------\n 1 file changed, 5 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/libavformat\/dv.c b\/libavformat\/dv.c\nindex 5e1c798..5be6118 100644\n--- a\/libavformat\/dv.c\n+++ b\/libavformat\/dv.c\n@@ -127,10 +127,14 @@ static int dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4],\n     \/* We work with 720p frames split in half, thus even frames have\n      * channels 0,1 and odd 2,3. *\/\n     ipcm = (sys->height == 720 && !(frame[1] & 0x0C)) ? 2 : 0;\n-    pcm  = ppcm[ipcm++];\n \n     \/* for each DIF channel *\/\n     for (chan = 0; chan < sys->n_difchan; chan++) {\n+        \/* next stereo channel (50Mbps and 100Mbps only) *\/\n+        pcm = ppcm[ipcm++];\n+        if (!pcm)\n+            break;\n+\n         \/* for each DIF segment *\/\n         for (i = 0; i < sys->difseg_size; i++) {\n             frame += 6 * 80; \/* skip DIF segment header *\/\n@@ -178,11 +182,6 @@ static int dv_extract_audio(uint8_t* frame, uint8_t* ppcm[4],\n                 frame += 16 * 80; \/* 15 Video DIFs + 1 Audio DIF *\/\n             }\n         }\n-\n-        \/* next stereo channel (50Mbps and 100Mbps only) *\/\n-        pcm = ppcm[ipcm++];\n-        if (!pcm)\n-            break;\n     }\n \n     return size;\n-- \n2.1.4\n\n","owner":"FFmpeg","repo":"FFmpeg","source":"cve"},{"CVE_ID":"CVE-2016-9435","CWE_ID":"20","category":"security","commit_id":"33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd","commit_message":"From 33509cc81ec5f2ba44eb6fd98bd5c1b5873e46bd Mon Sep 17 00:00:00 2001\nFrom: Tatsuya Kinoshita <tats@debian.org>\nDate: Sat, 20 Aug 2016 07:12:41 +0900\nSubject: [PATCH] Fix uninitialised values for <i> and <dd>\n\nBug-Debian: https:\/\/github.com\/tats\/w3m\/issues\/16\n---\n file.c      | 6 ++++++\n parsetagx.c | 1 +\n 2 files changed, 7 insertions(+)\n\n","diff_code":"diff --git a\/file.c b\/file.c\nindex de916bc..b66f8c8 100644\n--- a\/file.c\n+++ b\/file.c\n@@ -4686,6 +4686,12 @@ HTMLtagproc1(struct parsed_tag *tag, struct html_feed_environ *h_env)\n     case HTML_DD:\n \tCLOSE_A;\n \tCLOSE_DT;\n+\tif (h_env->envc == 0 ||\n+\t    (h_env->envc_real < h_env->nenv &&\n+\t     envs[h_env->envc].env != HTML_DL &&\n+\t     envs[h_env->envc].env != HTML_DL_COMPACT)) {\n+\t    PUSH_ENV(HTML_DL);\n+\t}\n \tif (envs[h_env->envc].env == HTML_DL_COMPACT) {\n \t    if (obuf->pos > envs[h_env->envc].indent)\n \t\tflushline(h_env, obuf, envs[h_env->envc].indent, 0,\ndiff --git a\/parsetagx.c b\/parsetagx.c\nindex 3435f9f..1cc7048 100644\n--- a\/parsetagx.c\n+++ b\/parsetagx.c\n@@ -120,6 +120,7 @@ parse_tag(char **s, int internal)\n     int i, attr_id = 0, nattr;\n \n     \/* Parse tag name *\/\n+    tagname[0] = '\\0';\n     q = (*s) + 1;\n     p = tagname;\n     if (*q == '\/') {\n","owner":"tats","repo":"w3m","source":"cve"},{"CVE_ID":"CVE-2013-2146","CWE_ID":"20","category":"security","commit_id":"f1923820c447e986a9da0fc6bf60c1dccdf0408e","commit_message":"From f1923820c447e986a9da0fc6bf60c1dccdf0408e Mon Sep 17 00:00:00 2001\nFrom: Stephane Eranian <eranian@google.com>\nDate: Tue, 16 Apr 2013 13:51:43 +0200\nSubject: [PATCH] perf\/x86: Fix offcore_rsp valid mask for SNB\/IVB\n\nThe valid mask for both offcore_response_0 and\noffcore_response_1 was wrong for SNB\/SNB-EP,\nIVB\/IVB-EP. It was possible to write to\nreserved bit and cause a GP fault crashing\nthe kernel.\n\nThis patch fixes the problem by correctly marking the\nreserved bits in the valid mask for all the processors\nmentioned above.\n\nA distinction between desktop and server parts is introduced\nbecause bits 24-30 are only available on the server parts.\n\nThis version of the  patch is just a rebase to perf\/urgent tree\nand should apply to older kernels as well.\n\nSigned-off-by: Stephane Eranian <eranian@google.com>\nCc: peterz@infradead.org\nCc: jolsa@redhat.com\nCc: gregkh@linuxfoundation.org\nCc: security@kernel.org\nCc: ak@linux.intel.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\n---\n arch\/x86\/kernel\/cpu\/perf_event_intel.c | 20 ++++++++++++++++----\n 1 file changed, 16 insertions(+), 4 deletions(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kernel\/cpu\/perf_event_intel.c b\/arch\/x86\/kernel\/cpu\/perf_event_intel.c\nindex dab7580c47aee..cc45deb791b01 100644\n--- a\/arch\/x86\/kernel\/cpu\/perf_event_intel.c\n+++ b\/arch\/x86\/kernel\/cpu\/perf_event_intel.c\n@@ -153,8 +153,14 @@ static struct event_constraint intel_gen_event_constraints[] __read_mostly =\n };\n \n static struct extra_reg intel_snb_extra_regs[] __read_mostly = {\n-\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3fffffffffull, RSP_0),\n-\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3fffffffffull, RSP_1),\n+\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3f807f8fffull, RSP_0),\n+\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3f807f8fffull, RSP_1),\n+\tEVENT_EXTRA_END\n+};\n+\n+static struct extra_reg intel_snbep_extra_regs[] __read_mostly = {\n+\tINTEL_EVENT_EXTRA_REG(0xb7, MSR_OFFCORE_RSP_0, 0x3fffff8fffull, RSP_0),\n+\tINTEL_EVENT_EXTRA_REG(0xbb, MSR_OFFCORE_RSP_1, 0x3fffff8fffull, RSP_1),\n \tEVENT_EXTRA_END\n };\n \n@@ -2097,7 +2103,10 @@ __init int intel_pmu_init(void)\n \t\tx86_pmu.event_constraints = intel_snb_event_constraints;\n \t\tx86_pmu.pebs_constraints = intel_snb_pebs_event_constraints;\n \t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n-\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n+\t\tif (boot_cpu_data.x86_model == 45)\n+\t\t\tx86_pmu.extra_regs = intel_snbep_extra_regs;\n+\t\telse\n+\t\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n \t\t\/* all extra regs are per-cpu when HT is on *\/\n \t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n \t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n@@ -2123,7 +2132,10 @@ __init int intel_pmu_init(void)\n \t\tx86_pmu.event_constraints = intel_ivb_event_constraints;\n \t\tx86_pmu.pebs_constraints = intel_ivb_pebs_event_constraints;\n \t\tx86_pmu.pebs_aliases = intel_pebs_aliases_snb;\n-\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n+\t\tif (boot_cpu_data.x86_model == 62)\n+\t\t\tx86_pmu.extra_regs = intel_snbep_extra_regs;\n+\t\telse\n+\t\t\tx86_pmu.extra_regs = intel_snb_extra_regs;\n \t\t\/* all extra regs are per-cpu when HT is on *\/\n \t\tx86_pmu.er_flags |= ERF_HAS_RSP_1;\n \t\tx86_pmu.er_flags |= ERF_NO_HT_SHARING;\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2014-9907","CWE_ID":"20","category":"security","commit_id":"d7325bac173492b358417a0ad49fabad44447d52","commit_message":"From d7325bac173492b358417a0ad49fabad44447d52 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Mon, 29 Dec 2014 21:00:14 +0000\nSubject: [PATCH] Added extra EOF check and some minor refactoring.\n\n---\n coders\/dds.c | 180 ++++++++++++++++++---------------------------------\n 1 file changed, 63 insertions(+), 117 deletions(-)\n\n","diff_code":"diff --git a\/coders\/dds.c b\/coders\/dds.c\nindex 404a78a939..c5016b2d0e 100644\n--- a\/coders\/dds.c\n+++ b\/coders\/dds.c\n@@ -726,9 +726,9 @@ static const DDSSingleColourLookup*\n if (min > max) \\\n   min = max; \\\n if (max - min < steps) \\\n-  max = Min(min + steps, 255); \\\n+  max = MagickMin(min + steps, 255); \\\n if (max - min < steps) \\\n-  min = Max(min - steps, 0)\n+  min = MagickMax(min - steps, 0)\n \n #define Dot(left, right) (left.x*right.x) + (left.y*right.y) + (left.z*right.z)\n \n@@ -743,90 +743,30 @@ if (max - min < steps) \\\n   Forward declarations\n *\/\n static MagickBooleanType\n-  ConstructOrdering(const size_t, const DDSVector4 *, const DDSVector3,\n-    DDSVector4 *, DDSVector4 *, unsigned char *, size_t);\n-\n-static MagickBooleanType\n-  ReadDDSInfo(Image *, DDSInfo *);\n-\n-static MagickBooleanType\n-  ReadDXT1(Image *, DDSInfo *, ExceptionInfo *);\n-\n-static MagickBooleanType\n-  ReadDXT3(Image *, DDSInfo *, ExceptionInfo *);\n-\n-static MagickBooleanType\n-  ReadDXT5(Image *, DDSInfo *, ExceptionInfo *);\n-\n-static MagickBooleanType\n-  ReadUncompressedRGB(Image *, DDSInfo *, ExceptionInfo *);\n-\n-static MagickBooleanType\n-  ReadUncompressedRGBA(Image *, DDSInfo *, ExceptionInfo *);\n-\n-static void\n-  RemapIndices(const ssize_t *, const unsigned char *, unsigned char *);\n-\n-static void\n-  SkipDXTMipmaps(Image *, DDSInfo *, int);\n-\n-static void\n-  SkipRGBMipmaps(Image *, DDSInfo *, int);\n-\n-static\n-  MagickBooleanType WriteDDSImage(const ImageInfo *, Image *);\n-\n-static void\n-  WriteDDSInfo(Image *, const size_t, const size_t, const size_t);\n-\n-static void\n-  WriteFourCC(Image *, const size_t, const MagickBooleanType,\n-    const MagickBooleanType, ExceptionInfo *);\n+  ConstructOrdering(const size_t,const DDSVector4 *,const DDSVector3,\n+    DDSVector4 *,DDSVector4 *,unsigned char *,size_t),\n+  ReadDDSInfo(Image *,DDSInfo *),\n+  ReadDXT1(Image *,DDSInfo *,ExceptionInfo *),\n+  ReadDXT3(Image *,DDSInfo *,ExceptionInfo *),\n+  ReadDXT5(Image *,DDSInfo *,ExceptionInfo *),\n+  ReadUncompressedRGB(Image *,DDSInfo *,ExceptionInfo *),\n+  ReadUncompressedRGBA(Image *,DDSInfo *,ExceptionInfo *),\n+  SkipDXTMipmaps(Image *,DDSInfo *,int,ExceptionInfo *),\n+  SkipRGBMipmaps(Image *,DDSInfo *,int,ExceptionInfo *),\n+  WriteDDSImage(const ImageInfo *,Image *),\n+  WriteMipmaps(Image *,const size_t,const size_t,const size_t,\n+    const MagickBooleanType,const MagickBooleanType,ExceptionInfo *);\n \n static void\n-  WriteImageData(Image *, const size_t, const size_t, const MagickBooleanType,\n-    const MagickBooleanType, ExceptionInfo *);\n-\n-static void\n-  WriteIndices(Image *, const DDSVector3, const DDSVector3, unsigned char *);\n-\n-static MagickBooleanType\n-  WriteMipmaps(Image *, const size_t, const size_t, const size_t,\n-    const MagickBooleanType, const MagickBooleanType, ExceptionInfo *);\n-\n-static void\n-  WriteSingleColorFit(Image *, const DDSVector4 *, const ssize_t *);\n-\n-static void\n-  WriteUncompressed(Image *, ExceptionInfo *);\n-\n-static inline size_t Max(size_t one, size_t two)\n-{\n-  if (one > two)\n-    return one;\n-  return two;\n-}\n-\n-static inline float MaxF(float one, float two)\n-{\n-  if (one > two)\n-    return one;\n-  return two;\n-}\n-\n-static inline size_t Min(size_t one, size_t two)\n-{\n-  if (one < two)\n-    return one;\n-  return two;\n-}\n-\n-static inline float MinF(float one, float two)\n-{\n-  if (one < two)\n-    return one;\n-  return two;\n-}\n+  RemapIndices(const ssize_t *,const unsigned char *,unsigned char *),\n+  WriteDDSInfo(Image *,const size_t,const size_t,const size_t),\n+  WriteFourCC(Image *,const size_t,const MagickBooleanType,\n+    const MagickBooleanType,ExceptionInfo *),\n+  WriteImageData(Image *,const size_t,const size_t,const MagickBooleanType,\n+    const MagickBooleanType,ExceptionInfo *),\n+  WriteIndices(Image *,const DDSVector3,const DDSVector3, unsigned char *),\n+  WriteSingleColorFit(Image *,const DDSVector4 *,const ssize_t *),\n+  WriteUncompressed(Image *,ExceptionInfo *);\n \n static inline void VectorAdd(const DDSVector4 left, const DDSVector4 right,\n   DDSVector4 *destination)\n@@ -839,17 +779,17 @@ static inline void VectorAdd(const DDSVector4 left, const DDSVector4 right,\n \n static inline void VectorClamp(DDSVector4 *value)\n {\n-  value->x = MinF(1.0f,MaxF(0.0f,value->x));\n-  value->y = MinF(1.0f,MaxF(0.0f,value->y));\n-  value->z = MinF(1.0f,MaxF(0.0f,value->z));\n-  value->w = MinF(1.0f,MaxF(0.0f,value->w));\n+  value->x = MagickMin(1.0f,MagickMax(0.0f,value->x));\n+  value->y = MagickMin(1.0f,MagickMax(0.0f,value->y));\n+  value->z = MagickMin(1.0f,MagickMax(0.0f,value->z));\n+  value->w = MagickMin(1.0f,MagickMax(0.0f,value->w));\n }\n \n static inline void VectorClamp3(DDSVector3 *value)\n {\n-  value->x = MinF(1.0f,MaxF(0.0f,value->x));\n-  value->y = MinF(1.0f,MaxF(0.0f,value->y));\n-  value->z = MinF(1.0f,MaxF(0.0f,value->z));\n+  value->x = MagickMin(1.0f,MagickMax(0.0f,value->x));\n+  value->y = MagickMin(1.0f,MagickMax(0.0f,value->y));\n+  value->z = MagickMin(1.0f,MagickMax(0.0f,value->z));\n }\n \n static inline void VectorCopy43(const DDSVector4 source,\n@@ -1474,7 +1414,7 @@ static void ComputePrincipleComponent(const float *covariance,\n     w.z = (row2.z * v.z) + w.z;\n     w.w = (row2.w * v.z) + w.w;\n \n-    a = 1.0f \/ MaxF(w.x,MaxF(w.y,w.z));\n+    a = 1.0f \/ MagickMax(w.x,MagickMax(w.y,w.z));\n \n     v.x = w.x * a;\n     v.y = w.y * a;\n@@ -1961,8 +1901,8 @@ static MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,\n     for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n     {\n       \/* Get 4x4 patch of pixels to write on *\/\n-      q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),\n-        Min(4, dds_info->height - y),exception);\n+      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),\n+        MagickMin(4, dds_info->height - y),exception);\n \n       if (q == (PixelPacket *) NULL)\n         return MagickFalse;\n@@ -1999,9 +1939,7 @@ static MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,\n     }\n   }\n \n-  SkipDXTMipmaps(image, dds_info, 8);\n-\n-  return MagickTrue;\n+  return(SkipDXTMipmaps(image,dds_info,8,exception));\n }\n \n static MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,\n@@ -2039,8 +1977,8 @@ static MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,\n     for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n     {\n       \/* Get 4x4 patch of pixels to write on *\/\n-      q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),\n-                         Min(4, dds_info->height - y),exception);\n+      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),\n+                         MagickMin(4, dds_info->height - y),exception);\n \n       if (q == (PixelPacket *) NULL)\n         return MagickFalse;\n@@ -2086,9 +2024,7 @@ static MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,\n     }\n   }\n \n-  SkipDXTMipmaps(image, dds_info, 16);\n-\n-  return MagickTrue;\n+  return(SkipDXTMipmaps(image,dds_info,16,exception));\n }\n \n static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,\n@@ -2130,8 +2066,8 @@ static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,\n     for (x = 0; x < (ssize_t) dds_info->width; x += 4)\n     {\n       \/* Get 4x4 patch of pixels to write on *\/\n-      q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),\n-                         Min(4, dds_info->height - y),exception);\n+      q = QueueAuthenticPixels(image, x, y, MagickMin(4, dds_info->width - x),\n+                         MagickMin(4, dds_info->height - y),exception);\n \n       if (q == (PixelPacket *) NULL)\n         return MagickFalse;\n@@ -2187,9 +2123,7 @@ static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,\n     }\n   }\n \n-  SkipDXTMipmaps(image, dds_info, 16);\n-\n-  return MagickTrue;\n+  return(SkipDXTMipmaps(image,dds_info,16,exception));\n }\n \n static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,\n@@ -2251,9 +2185,7 @@ static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,\n       return MagickFalse;\n   }\n \n-  SkipRGBMipmaps(image, dds_info, 3);\n-\n-  return MagickTrue;\n+  return(SkipRGBMipmaps(image,dds_info,3,exception));\n }\n \n static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,\n@@ -2345,9 +2277,7 @@ static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,\n       return MagickFalse;\n   }\n \n-  SkipRGBMipmaps(image, dds_info, 4);\n-\n-  return MagickTrue;\n+  return(SkipRGBMipmaps(image,dds_info,4,exception));\n }\n \f\n \/*\n@@ -2423,7 +2353,8 @@ static void RemapIndices(const ssize_t *map, const unsigned char *source,\n \/*\n   Skip the mipmap images for compressed (DXTn) dds files\n *\/\n-static void SkipDXTMipmaps(Image *image, DDSInfo *dds_info, int texel_size)\n+static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n+  int texel_size,ExceptionInfo *exception)\n {\n   register ssize_t\n     i;\n@@ -2442,6 +2373,12 @@ static void SkipDXTMipmaps(Image *image, DDSInfo *dds_info, int texel_size)\n       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n     {\n+      if (EOFBlob(image) != MagickFalse)\n+        {\n+          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n+            image->filename);\n+          return(MagickFalse);\n+        }\n       w = DIV2(dds_info->width);\n       h = DIV2(dds_info->height);\n \n@@ -2457,12 +2394,14 @@ static void SkipDXTMipmaps(Image *image, DDSInfo *dds_info, int texel_size)\n         h = DIV2(h);\n       }\n     }\n+  return(MagickTrue);\n }\n \n \/*\n   Skip the mipmap images for uncompressed (RGB or RGBA) dds files\n *\/\n-static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)\n+static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n+  int pixel_size,ExceptionInfo *exception)\n {\n   MagickOffsetType\n     offset;\n@@ -2481,6 +2420,12 @@ static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)\n       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n     {\n+      if (EOFBlob(image) != MagickFalse)\n+        {\n+          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n+            image->filename);\n+          return(MagickFalse);\n+        }\n       w = DIV2(dds_info->width);\n       h = DIV2(dds_info->height);\n \n@@ -2496,6 +2441,7 @@ static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)\n         h = DIV2(h);\n       }\n     }\n+  return(MagickTrue);\n }\n \n \/*\n@@ -2779,10 +2725,10 @@ static void WriteDDSInfo(Image *image, const size_t pixelFormat,\n \n   if (compression == FOURCC_DXT1)\n     (void) WriteBlobLSBLong(image,\n-             (unsigned int) (Max(1,(image->columns+3)\/4) * 8));\n+             (unsigned int) (MagickMax(1,(image->columns+3)\/4) * 8));\n   else\n     (void) WriteBlobLSBLong(image,\n-             (unsigned int) (Max(1,(image->columns+3)\/4) * 16));\n+             (unsigned int) (MagickMax(1,(image->columns+3)\/4) * 16));\n \n   (void) WriteBlobLSBLong(image,0x00);\n   (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2013-4544","CWE_ID":"20","category":"security","commit_id":"8c6c0478996e8f77374e69b6df68655b0b4ba689","commit_message":"From 8c6c0478996e8f77374e69b6df68655b0b4ba689 Mon Sep 17 00:00:00 2001\nFrom: Dmitry Fleytman <dmitry@daynix.com>\nDate: Fri, 4 Apr 2014 12:45:19 +0300\nSubject: [PATCH] vmxnet3: validate interrupt indices coming from guest\n\nCVE-2013-4544\n\nSigned-off-by: Dmitry Fleytman <dmitry@daynix.com>\nReported-by: Michael S. Tsirkin <mst@redhat.com>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nReviewed-by: Dr. David Alan Gilbert <dgilbert@redhat.com>\nMessage-id: 1396604722-11902-2-git-send-email-dmitry@daynix.com\nSigned-off-by: Peter Maydell <peter.maydell@linaro.org>\n---\n hw\/net\/vmxnet3.c | 36 ++++++++++++++++++++++++++++++++++--\n 1 file changed, 34 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/hw\/net\/vmxnet3.c b\/hw\/net\/vmxnet3.c\nindex 5be807c..0b317f8 100644\n--- a\/hw\/net\/vmxnet3.c\n+++ b\/hw\/net\/vmxnet3.c\n@@ -52,6 +52,9 @@\n #define VMXNET3_DEVICE_VERSION    0x1\n #define VMXNET3_DEVICE_REVISION   0x1\n \n+\/* Number of interrupt vectors for non-MSIx modes *\/\n+#define VMXNET3_MAX_NMSIX_INTRS   (1)\n+\n \/* Macros for rings descriptors access *\/\n #define VMXNET3_READ_TX_QUEUE_DESCR8(dpa, field) \\\n     (vmw_shmem_ld8(dpa + offsetof(struct Vmxnet3_TxQueueDesc, field)))\n@@ -1305,6 +1308,34 @@ static bool vmxnet3_verify_intx(VMXNET3State *s, int intx)\n            (pci_get_byte(s->parent_obj.config + PCI_INTERRUPT_PIN) - 1));\n }\n \n+static void vmxnet3_validate_interrupt_idx(bool is_msix, int idx)\n+{\n+    int max_ints = is_msix ? VMXNET3_MAX_INTRS : VMXNET3_MAX_NMSIX_INTRS;\n+    if (idx >= max_ints) {\n+        hw_error(\"Bad interrupt index: %d\\n\", idx);\n+    }\n+}\n+\n+static void vmxnet3_validate_interrupts(VMXNET3State *s)\n+{\n+    int i;\n+\n+    VMW_CFPRN(\"Verifying event interrupt index (%d)\", s->event_int_idx);\n+    vmxnet3_validate_interrupt_idx(s->msix_used, s->event_int_idx);\n+\n+    for (i = 0; i < s->txq_num; i++) {\n+        int idx = s->txq_descr[i].intr_idx;\n+        VMW_CFPRN(\"Verifying TX queue %d interrupt index (%d)\", i, idx);\n+        vmxnet3_validate_interrupt_idx(s->msix_used, idx);\n+    }\n+\n+    for (i = 0; i < s->rxq_num; i++) {\n+        int idx = s->rxq_descr[i].intr_idx;\n+        VMW_CFPRN(\"Verifying RX queue %d interrupt index (%d)\", i, idx);\n+        vmxnet3_validate_interrupt_idx(s->msix_used, idx);\n+    }\n+}\n+\n static void vmxnet3_activate_device(VMXNET3State *s)\n {\n     int i;\n@@ -1447,6 +1478,8 @@ static void vmxnet3_activate_device(VMXNET3State *s)\n                sizeof(s->rxq_descr[i].rxq_stats));\n     }\n \n+    vmxnet3_validate_interrupts(s);\n+\n     \/* Make sure everything is in place before device activation *\/\n     smp_wmb();\n \n@@ -2005,7 +2038,6 @@ vmxnet3_cleanup_msix(VMXNET3State *s)\n     }\n }\n \n-#define VMXNET3_MSI_NUM_VECTORS   (1)\n #define VMXNET3_MSI_OFFSET        (0x50)\n #define VMXNET3_USE_64BIT         (true)\n #define VMXNET3_PER_VECTOR_MASK   (false)\n@@ -2016,7 +2048,7 @@ vmxnet3_init_msi(VMXNET3State *s)\n     PCIDevice *d = PCI_DEVICE(s);\n     int res;\n \n-    res = msi_init(d, VMXNET3_MSI_OFFSET, VMXNET3_MSI_NUM_VECTORS,\n+    res = msi_init(d, VMXNET3_MSI_OFFSET, VMXNET3_MAX_NMSIX_INTRS,\n                    VMXNET3_USE_64BIT, VMXNET3_PER_VECTOR_MASK);\n     if (0 > res) {\n         VMW_WRPRN(\"Failed to initialize MSI, error %d\", res);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-7268","CWE_ID":"20","category":"security","commit_id":"f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","commit_message":"From f3d3342602f8bcbf37d7c46641cb9bca7618eb1c Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Thu, 21 Nov 2013 03:14:22 +0100\nSubject: net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include\/linux\/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec\/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n crypto\/algif_hash.c            |  2 --\n crypto\/algif_skcipher.c        |  1 -\n drivers\/isdn\/mISDN\/socket.c    | 13 ++++---------\n drivers\/net\/ppp\/pppoe.c        |  2 --\n include\/linux\/net.h            |  8 ++++++++\n net\/appletalk\/ddp.c            | 16 +++++++---------\n net\/atm\/common.c               |  2 --\n net\/ax25\/af_ax25.c             |  4 ++--\n net\/bluetooth\/af_bluetooth.c   |  9 ++-------\n net\/bluetooth\/hci_sock.c       |  2 --\n net\/bluetooth\/rfcomm\/sock.c    |  1 -\n net\/bluetooth\/sco.c            |  1 -\n net\/caif\/caif_socket.c         |  4 ----\n net\/compat.c                   |  3 ++-\n net\/core\/iovec.c               |  3 ++-\n net\/ipx\/af_ipx.c               |  3 +--\n net\/irda\/af_irda.c             |  4 ----\n net\/iucv\/af_iucv.c             |  2 --\n net\/key\/af_key.c               |  1 -\n net\/l2tp\/l2tp_ppp.c            |  2 --\n net\/llc\/af_llc.c               |  2 --\n net\/netlink\/af_netlink.c       |  2 --\n net\/netrom\/af_netrom.c         |  3 +--\n net\/nfc\/llcp_sock.c            |  2 --\n net\/nfc\/rawsock.c              |  2 --\n net\/packet\/af_packet.c         | 32 +++++++++++++++-----------------\n net\/rds\/recv.c                 |  2 --\n net\/rose\/af_rose.c             |  8 +++++---\n net\/rxrpc\/ar-recvmsg.c         |  9 ++++++---\n net\/socket.c                   | 19 +++++++++++--------\n net\/tipc\/socket.c              |  6 ------\n net\/unix\/af_unix.c             |  5 -----\n net\/vmw_vsock\/af_vsock.c       |  2 --\n net\/vmw_vsock\/vmci_transport.c |  2 --\n net\/x25\/af_x25.c               |  3 +--\n 35 files changed, 67 insertions(+), 115 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/algif_hash.c b\/crypto\/algif_hash.c\nindex 0262210cad38..ef5356cd280a 100644\n--- a\/crypto\/algif_hash.c\n+++ b\/crypto\/algif_hash.c\n@@ -161,8 +161,6 @@ static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\ndiff --git a\/crypto\/algif_skcipher.c b\/crypto\/algif_skcipher.c\nindex a1c4f0a55583..6a6dfc062d2a 100644\n--- a\/crypto\/algif_skcipher.c\n+++ b\/crypto\/algif_skcipher.c\n@@ -432,7 +432,6 @@ static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n \tlong copied = 0;\n \n \tlock_sock(sk);\n-\tmsg->msg_namelen = 0;\n \tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n \t     iovlen--, iov++) {\n \t\tunsigned long seglen = iov->iov_len;\ndiff --git a\/drivers\/isdn\/mISDN\/socket.c b\/drivers\/isdn\/mISDN\/socket.c\nindex e47dcb9d1e91..5cefb479c707 100644\n--- a\/drivers\/isdn\/mISDN\/socket.c\n+++ b\/drivers\/isdn\/mISDN\/socket.c\n@@ -117,7 +117,6 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sk_buff\t\t*skb;\n \tstruct sock\t\t*sk = sock->sk;\n-\tstruct sockaddr_mISDN\t*maddr;\n \n \tint\t\tcopied, err;\n \n@@ -135,9 +134,9 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n-\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_mISDN *maddr = msg->msg_name;\n+\n \t\tmaddr->family = AF_ISDN;\n \t\tmaddr->dev = _pms(sk)->dev->id;\n \t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n@@ -150,11 +149,7 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n \t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n \t\t}\n-\t} else {\n-\t\tif (msg->msg_namelen)\n-\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n-\t\t\t       __func__, msg->msg_namelen);\n-\t\tmsg->msg_namelen = 0;\n+\t\tmsg->msg_namelen = sizeof(*maddr);\n \t}\n \n \tcopied = skb->len + MISDN_HEADER_LEN;\ndiff --git a\/drivers\/net\/ppp\/pppoe.c b\/drivers\/net\/ppp\/pppoe.c\nindex 5f66e30d9823..82ee6ed954cb 100644\n--- a\/drivers\/net\/ppp\/pppoe.c\n+++ b\/drivers\/net\/ppp\/pppoe.c\n@@ -979,8 +979,6 @@ static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (error < 0)\n \t\tgoto end;\n \n-\tm->msg_namelen = 0;\n-\n \tif (skb) {\n \t\ttotal_len = min_t(size_t, total_len, skb->len);\n \t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\ndiff --git a\/include\/linux\/net.h b\/include\/linux\/net.h\nindex b292a0435571..4bcee94cef93 100644\n--- a\/include\/linux\/net.h\n+++ b\/include\/linux\/net.h\n@@ -164,6 +164,14 @@ struct proto_ops {\n #endif\n \tint\t\t(*sendmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len);\n+\t\/* Notes for implementing recvmsg:\n+\t * ===============================\n+\t * msg->msg_namelen should get updated by the recvmsg handlers\n+\t * iff msg_name != NULL. It is by default 0 to prevent\n+\t * returning uninitialized memory to user space.  The recvfrom\n+\t * handlers can assume that msg.msg_name is either NULL or has\n+\t * a minimum size of sizeof(struct sockaddr_storage).\n+\t *\/\n \tint\t\t(*recvmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len,\n \t\t\t\t      int flags);\ndiff --git a\/net\/appletalk\/ddp.c b\/net\/appletalk\/ddp.c\nindex 7fee50d637f9..7d424ac6e760 100644\n--- a\/net\/appletalk\/ddp.c\n+++ b\/net\/appletalk\/ddp.c\n@@ -1735,7 +1735,6 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n-\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n@@ -1764,14 +1763,13 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n \n-\tif (!err) {\n-\t\tif (sat) {\n-\t\t\tsat->sat_family      = AF_APPLETALK;\n-\t\t\tsat->sat_port        = ddp->deh_sport;\n-\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n-\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n-\t\t}\n-\t\tmsg->msg_namelen = sizeof(*sat);\n+\tif (!err && msg->msg_name) {\n+\t\tstruct sockaddr_at *sat = msg->msg_name;\n+\t\tsat->sat_family      = AF_APPLETALK;\n+\t\tsat->sat_port        = ddp->deh_sport;\n+\t\tsat->sat_addr.s_node = ddp->deh_snode;\n+\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n+\t\tmsg->msg_namelen     = sizeof(*sat);\n \t}\n \n \tskb_free_datagram(sk, skb);\t\/* Free the datagram. *\/\ndiff --git a\/net\/atm\/common.c b\/net\/atm\/common.c\nindex 737bef59ce89..7b491006eaf4 100644\n--- a\/net\/atm\/common.c\n+++ b\/net\/atm\/common.c\n@@ -531,8 +531,6 @@ int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n \ndiff --git a\/net\/ax25\/af_ax25.c b\/net\/ax25\/af_ax25.c\nindex a00123ebb0ae..7bb1605bdfd9 100644\n--- a\/net\/ax25\/af_ax25.c\n+++ b\/net\/ax25\/af_ax25.c\n@@ -1636,11 +1636,11 @@ static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (msg->msg_namelen != 0) {\n-\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n+\tif (msg->msg_name) {\n \t\tax25_digi digi;\n \t\tax25_address src;\n \t\tconst unsigned char *mac = skb_mac_header(skb);\n+\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n \n \t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n \t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\ndiff --git a\/net\/bluetooth\/af_bluetooth.c b\/net\/bluetooth\/af_bluetooth.c\nindex f6a1671ea2ff..56ca494621c6 100644\n--- a\/net\/bluetooth\/af_bluetooth.c\n+++ b\/net\/bluetooth\/af_bluetooth.c\n@@ -224,10 +224,9 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n-\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n-\t\t\tmsg->msg_namelen = 0;\n+\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n-\t\t}\n+\n \t\treturn err;\n \t}\n \n@@ -245,8 +244,6 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tif (bt_sk(sk)->skb_msg_name)\n \t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n \t\t\t\t\t\t&msg->msg_namelen);\n-\t\telse\n-\t\t\tmsg->msg_namelen = 0;\n \t}\n \n \tskb_free_datagram(sk, skb);\n@@ -295,8 +292,6 @@ int bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \tBT_DBG(\"sk %p size %zu\", sk, size);\n \n \tlock_sock(sk);\ndiff --git a\/net\/bluetooth\/hci_sock.c b\/net\/bluetooth\/hci_sock.c\nindex 71f0be173080..6a6c8bb4fd72 100644\n--- a\/net\/bluetooth\/hci_sock.c\n+++ b\/net\/bluetooth\/hci_sock.c\n@@ -856,8 +856,6 @@ static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/bluetooth\/rfcomm\/sock.c b\/net\/bluetooth\/rfcomm\/sock.c\nindex c4d3d423f89b..c80766f892c3 100644\n--- a\/net\/bluetooth\/rfcomm\/sock.c\n+++ b\/net\/bluetooth\/rfcomm\/sock.c\n@@ -615,7 +615,6 @@ static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n-\t\tmsg->msg_namelen = 0;\n \t\treturn 0;\n \t}\n \ndiff --git a\/net\/bluetooth\/sco.c b\/net\/bluetooth\/sco.c\nindex 12a0e51e21e1..24fa3964b3c8 100644\n--- a\/net\/bluetooth\/sco.c\n+++ b\/net\/bluetooth\/sco.c\n@@ -711,7 +711,6 @@ static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n \t\tsk->sk_state = BT_CONFIG;\n-\t\tmsg->msg_namelen = 0;\n \n \t\trelease_sock(sk);\n \t\treturn 0;\ndiff --git a\/net\/caif\/caif_socket.c b\/net\/caif\/caif_socket.c\nindex 05a41c7ec304..d6be3edb7a43 100644\n--- a\/net\/caif\/caif_socket.c\n+++ b\/net\/caif\/caif_socket.c\n@@ -286,8 +286,6 @@ static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (m->msg_flags&MSG_OOB)\n \t\tgoto read_error;\n \n-\tm->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n \tif (!skb)\n \t\tgoto read_error;\n@@ -361,8 +359,6 @@ static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/*\n \t * Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\ndiff --git a\/net\/compat.c b\/net\/compat.c\nindex 89032580bd1d..618c6a8a911b 100644\n--- a\/net\/compat.c\n+++ b\/net\/compat.c\n@@ -93,7 +93,8 @@ int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tkern_msg->msg_name = kern_address;\n+\t\tif (kern_msg->msg_name)\n+\t\t\tkern_msg->msg_name = kern_address;\n \t} else\n \t\tkern_msg->msg_name = NULL;\n \ndiff --git a\/net\/core\/iovec.c b\/net\/core\/iovec.c\nindex 4cdb7c48dad6..b61869429f4c 100644\n--- a\/net\/core\/iovec.c\n+++ b\/net\/core\/iovec.c\n@@ -48,7 +48,8 @@ int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *a\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tm->msg_name = address;\n+\t\tif (m->msg_name)\n+\t\t\tm->msg_name = address;\n \t} else {\n \t\tm->msg_name = NULL;\n \t}\ndiff --git a\/net\/ipx\/af_ipx.c b\/net\/ipx\/af_ipx.c\nindex 7a1e0fc1bd4d..e096025b477f 100644\n--- a\/net\/ipx\/af_ipx.c\n+++ b\/net\/ipx\/af_ipx.c\n@@ -1823,8 +1823,6 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n-\tmsg->msg_namelen = sizeof(*sipx);\n-\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n@@ -1832,6 +1830,7 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n+\t\tmsg->msg_namelen\t= sizeof(*sipx);\n \t}\n \trc = copied;\n \ndiff --git a\/net\/irda\/af_irda.c b\/net\/irda\/af_irda.c\nindex 0f676908d15b..de7db23049f1 100644\n--- a\/net\/irda\/af_irda.c\n+++ b\/net\/irda\/af_irda.c\n@@ -1385,8 +1385,6 @@ static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n \n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \n-\tmsg->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n@@ -1451,8 +1449,6 @@ static int irda_recvmsg_stream(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, noblock);\n \n-\tmsg->msg_namelen = 0;\n-\n \tdo {\n \t\tint chunk;\n \t\tstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\ndiff --git a\/net\/iucv\/af_iucv.c b\/net\/iucv\/af_iucv.c\nindex 168aff5e60de..c4b7218058b6 100644\n--- a\/net\/iucv\/af_iucv.c\n+++ b\/net\/iucv\/af_iucv.c\n@@ -1324,8 +1324,6 @@ static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint err = 0;\n \tu32 offset;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif ((sk->sk_state == IUCV_DISCONN) &&\n \t    skb_queue_empty(&iucv->backlog_skb_q) &&\n \t    skb_queue_empty(&sk->sk_receive_queue) &&\ndiff --git a\/net\/key\/af_key.c b\/net\/key\/af_key.c\nindex 911ef03bf8fb..545f047868ad 100644\n--- a\/net\/key\/af_key.c\n+++ b\/net\/key\/af_key.c\n@@ -3616,7 +3616,6 @@ static int pfkey_recvmsg(struct kiocb *kiocb,\n \tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n \tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n \tif (skb == NULL)\n \t\tgoto out;\ndiff --git a\/net\/l2tp\/l2tp_ppp.c b\/net\/l2tp\/l2tp_ppp.c\nindex ffda81ef1a70..be5fadf34739 100644\n--- a\/net\/l2tp\/l2tp_ppp.c\n+++ b\/net\/l2tp\/l2tp_ppp.c\n@@ -197,8 +197,6 @@ static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sk->sk_state & PPPOX_BOUND)\n \t\tgoto end;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = 0;\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\ndiff --git a\/net\/llc\/af_llc.c b\/net\/llc\/af_llc.c\nindex 6cba486353e8..7b01b9f5846c 100644\n--- a\/net\/llc\/af_llc.c\n+++ b\/net\/llc\/af_llc.c\n@@ -720,8 +720,6 @@ static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint target;\t\/* Read at least this many bytes *\/\n \tlong timeo;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tcopied = -ENOTCONN;\n \tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\ndiff --git a\/net\/netlink\/af_netlink.c b\/net\/netlink\/af_netlink.c\nindex f0176e1a5a81..bca50b95c182 100644\n--- a\/net\/netlink\/af_netlink.c\n+++ b\/net\/netlink\/af_netlink.c\n@@ -2335,8 +2335,6 @@ static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,\n \t}\n #endif\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = data_skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/netrom\/af_netrom.c b\/net\/netrom\/af_netrom.c\nindex 698814bfa7ad..53c19a35fc6d 100644\n--- a\/net\/netrom\/af_netrom.c\n+++ b\/net\/netrom\/af_netrom.c\n@@ -1179,10 +1179,9 @@ static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n+\t\tmsg->msg_namelen = sizeof(*sax);\n \t}\n \n-\tmsg->msg_namelen = sizeof(*sax);\n-\n \tskb_free_datagram(sk, skb);\n \n \trelease_sock(sk);\ndiff --git a\/net\/nfc\/llcp_sock.c b\/net\/nfc\/llcp_sock.c\nindex d308402b67d8..824c6056bf82 100644\n--- a\/net\/nfc\/llcp_sock.c\n+++ b\/net\/nfc\/llcp_sock.c\n@@ -807,8 +807,6 @@ static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tpr_debug(\"%p %zu\\n\", sk, len);\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state == LLCP_CLOSED &&\ndiff --git a\/net\/nfc\/rawsock.c b\/net\/nfc\/rawsock.c\nindex cd958b381f96..66bcd2eb5773 100644\n--- a\/net\/nfc\/rawsock.c\n+++ b\/net\/nfc\/rawsock.c\n@@ -244,8 +244,6 @@ static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn rc;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/packet\/af_packet.c b\/net\/packet\/af_packet.c\nindex 2e8286b47c28..61bd50adead1 100644\n--- a\/net\/packet\/af_packet.c\n+++ b\/net\/packet\/af_packet.c\n@@ -2660,7 +2660,6 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tstruct sock *sk = sock->sk;\n \tstruct sk_buff *skb;\n \tint copied, err;\n-\tstruct sockaddr_ll *sll;\n \tint vnet_hdr_len = 0;\n \n \terr = -EINVAL;\n@@ -2744,22 +2743,10 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tgoto out_free;\n \t}\n \n-\t\/*\n-\t *\tIf the address length field is there to be filled in, we fill\n-\t *\tit in now.\n-\t *\/\n-\n-\tsll = &PACKET_SKB_CB(skb)->sa.ll;\n-\tif (sock->type == SOCK_PACKET)\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n-\telse\n-\t\tmsg->msg_namelen = sll->sll_halen + offsetof(struct sockaddr_ll, sll_addr);\n-\n-\t\/*\n-\t *\tYou lose any data beyond the buffer you gave. If it worries a\n-\t *\tuser program they can ask the device for its MTU anyway.\n+\t\/* You lose any data beyond the buffer you gave. If it worries\n+\t * a user program they can ask the device for its MTU\n+\t * anyway.\n \t *\/\n-\n \tcopied = skb->len;\n \tif (copied > len) {\n \t\tcopied = len;\n@@ -2772,9 +2759,20 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n \n-\tif (msg->msg_name)\n+\tif (msg->msg_name) {\n+\t\t\/* If the address length field is there to be filled\n+\t\t * in, we fill it in now.\n+\t\t *\/\n+\t\tif (sock->type == SOCK_PACKET) {\n+\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n+\t\t} else {\n+\t\t\tstruct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;\n+\t\t\tmsg->msg_namelen = sll->sll_halen +\n+\t\t\t\toffsetof(struct sockaddr_ll, sll_addr);\n+\t\t}\n \t\tmemcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa,\n \t\t       msg->msg_namelen);\n+\t}\n \n \tif (pkt_sk(sk)->auxdata) {\n \t\tstruct tpacket_auxdata aux;\ndiff --git a\/net\/rds\/recv.c b\/net\/rds\/recv.c\nindex 9f0f17cf6bf9..de339b24ca14 100644\n--- a\/net\/rds\/recv.c\n+++ b\/net\/rds\/recv.c\n@@ -410,8 +410,6 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n \ndiff --git a\/net\/rose\/af_rose.c b\/net\/rose\/af_rose.c\nindex e98fcfbe6007..33af77246bfe 100644\n--- a\/net\/rose\/af_rose.c\n+++ b\/net\/rose\/af_rose.c\n@@ -1216,7 +1216,6 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sock *sk = sock->sk;\n \tstruct rose_sock *rose = rose_sk(sk);\n-\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n \tsize_t copied;\n \tunsigned char *asmptr;\n \tstruct sk_buff *skb;\n@@ -1252,8 +1251,11 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (srose != NULL) {\n-\t\tmemset(srose, 0, msg->msg_namelen);\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_rose *srose;\n+\n+\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n+\t\tsrose = msg->msg_name;\n \t\tsrose->srose_family = AF_ROSE;\n \t\tsrose->srose_addr   = rose->dest_addr;\n \t\tsrose->srose_call   = rose->dest_call;\ndiff --git a\/net\/rxrpc\/ar-recvmsg.c b\/net\/rxrpc\/ar-recvmsg.c\nindex 4b48687c3890..898492a8d61b 100644\n--- a\/net\/rxrpc\/ar-recvmsg.c\n+++ b\/net\/rxrpc\/ar-recvmsg.c\n@@ -143,10 +143,13 @@ int rxrpc_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \t\t\/* copy the peer address and timestamp *\/\n \t\tif (!continue_call) {\n-\t\t\tif (msg->msg_name && msg->msg_namelen > 0)\n+\t\t\tif (msg->msg_name) {\n+\t\t\t\tsize_t len =\n+\t\t\t\t\tsizeof(call->conn->trans->peer->srx);\n \t\t\t\tmemcpy(msg->msg_name,\n-\t\t\t\t       &call->conn->trans->peer->srx,\n-\t\t\t\t       sizeof(call->conn->trans->peer->srx));\n+\t\t\t\t       &call->conn->trans->peer->srx, len);\n+\t\t\t\tmsg->msg_namelen = len;\n+\t\t\t}\n \t\t\tsock_recv_ts_and_drops(msg, &rx->sk, skb);\n \t\t}\n \ndiff --git a\/net\/socket.c b\/net\/socket.c\nindex c226aceee65b..fc285564e49e 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -1840,8 +1840,10 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n \tmsg.msg_iov = &iov;\n \tiov.iov_len = size;\n \tiov.iov_base = ubuf;\n-\tmsg.msg_name = (struct sockaddr *)&address;\n-\tmsg.msg_namelen = sizeof(address);\n+\t\/* Save some cycles and don't copy the address if not needed *\/\n+\tmsg.msg_name = addr ? (struct sockaddr *)&address : NULL;\n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg.msg_namelen = 0;\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = sock_recvmsg(sock, &msg, size, flags);\n@@ -2221,16 +2223,14 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \t\t\tgoto out;\n \t}\n \n-\t\/*\n-\t *      Save the user-mode address (verify_iovec will change the\n-\t *      kernel msghdr to use the kernel address space)\n+\t\/* Save the user-mode address (verify_iovec will change the\n+\t * kernel msghdr to use the kernel address space)\n \t *\/\n-\n \tuaddr = (__force void __user *)msg_sys->msg_name;\n \tuaddr_len = COMPAT_NAMELEN(msg);\n-\tif (MSG_CMSG_COMPAT & flags) {\n+\tif (MSG_CMSG_COMPAT & flags)\n \t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n-\t} else\n+\telse\n \t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n \tif (err < 0)\n \t\tgoto out_freeiov;\n@@ -2239,6 +2239,9 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n \tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n \n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg_sys->msg_namelen = 0;\n+\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\ndiff --git a\/net\/tipc\/socket.c b\/net\/tipc\/socket.c\nindex 3906527259d1..3b61851bb927 100644\n--- a\/net\/tipc\/socket.c\n+++ b\/net\/tipc\/socket.c\n@@ -980,9 +980,6 @@ static int recv_msg(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n restart:\n \n@@ -1091,9 +1088,6 @@ static int recv_stream(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n \ndiff --git a\/net\/unix\/af_unix.c b\/net\/unix\/af_unix.c\nindex c1f403bed683..01625ccc3ae6 100644\n--- a\/net\/unix\/af_unix.c\n+++ b\/net\/unix\/af_unix.c\n@@ -1754,7 +1754,6 @@ static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n {\n \tstruct unix_sock *u = unix_sk(sk);\n \n-\tmsg->msg_namelen = 0;\n \tif (u->addr) {\n \t\tmsg->msg_namelen = u->addr->len;\n \t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n@@ -1778,8 +1777,6 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = mutex_lock_interruptible(&u->readlock);\n \tif (err) {\n \t\terr = sock_intr_errno(sock_rcvtimeo(sk, noblock));\n@@ -1924,8 +1921,6 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\n \t *\/\ndiff --git a\/net\/vmw_vsock\/af_vsock.c b\/net\/vmw_vsock\/af_vsock.c\nindex 545c08b8a1d4..5adfd94c5b85 100644\n--- a\/net\/vmw_vsock\/af_vsock.c\n+++ b\/net\/vmw_vsock\/af_vsock.c\n@@ -1662,8 +1662,6 @@ vsock_stream_recvmsg(struct kiocb *kiocb,\n \tvsk = vsock_sk(sk);\n \terr = 0;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state != SS_CONNECTED) {\ndiff --git a\/net\/vmw_vsock\/vmci_transport.c b\/net\/vmw_vsock\/vmci_transport.c\nindex 9d6986634e0b..687360da62d9 100644\n--- a\/net\/vmw_vsock\/vmci_transport.c\n+++ b\/net\/vmw_vsock\/vmci_transport.c\n@@ -1746,8 +1746,6 @@ static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Retrieve the head sk_buff from the socket's receive queue. *\/\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\ndiff --git a\/net\/x25\/af_x25.c b\/net\/x25\/af_x25.c\nindex 45a3ab5612c1..7622789d3750 100644\n--- a\/net\/x25\/af_x25.c\n+++ b\/net\/x25\/af_x25.c\n@@ -1340,10 +1340,9 @@ static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n+\t\tmsg->msg_namelen = sizeof(*sx25);\n \t}\n \n-\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n-\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-3672","CWE_ID":"20","category":"security","commit_id":"7fa6db2545643efb4fe2e0bb501fa50af35a6330","commit_message":"From 7fa6db2545643efb4fe2e0bb501fa50af35a6330 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Thu, 2 May 2013 21:52:08 +0200\nSubject: [PATCH] mmvideo\/mm_decode_inter: check horizontal coordinate too\n\nFixes out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit 8d3c99e825317b7efda5fd12e69896b47c700303)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/mmvideo.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/mmvideo.c b\/libavcodec\/mmvideo.c\nindex c61cd576e4..4214eeb964 100644\n--- a\/libavcodec\/mmvideo.c\n+++ b\/libavcodec\/mmvideo.c\n@@ -151,6 +151,8 @@ static int mm_decode_inter(MmContext * s, int half_horiz, int half_vert)\n             int replace_array = bytestream2_get_byte(&s->gb);\n             for(j=0; j<8; j++) {\n                 int replace = (replace_array >> (7-j)) & 1;\n+                if (x + half_horiz >= s->avctx->width)\n+                    return AVERROR_INVALIDDATA;\n                 if (replace) {\n                     int color = bytestream2_get_byte(&data_ptr);\n                     s->frame.data[0][y*s->frame.linesize[0] + x] = color;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-0879","CWE_ID":"20","category":"security","commit_id":"61cc74fbb87af6aa551a06a370590c9bc07e29d9","commit_message":"From 61cc74fbb87af6aa551a06a370590c9bc07e29d9 Mon Sep 17 00:00:00 2001\nFrom: Louis Rilling <louis.rilling@kerlabs.com>\nDate: Fri, 4 Dec 2009 14:52:41 +0100\nSubject: block: Fix io_context leak after clone with CLONE_IO\n\nWith CLONE_IO, copy_io() increments both ioc->refcount and ioc->nr_tasks.\nHowever exit_io_context() only decrements ioc->refcount if ioc->nr_tasks\nreaches 0.\n\nAlways call put_io_context() in exit_io_context().\n\nSigned-off-by: Louis Rilling <louis.rilling@kerlabs.com>\nSigned-off-by: Jens Axboe <jens.axboe@oracle.com>\n---\n block\/blk-ioc.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/block\/blk-ioc.c b\/block\/blk-ioc.c\nindex d4ed6000147d..dcd041290b28 100644\n--- a\/block\/blk-ioc.c\n+++ b\/block\/blk-ioc.c\n@@ -80,8 +80,8 @@ void exit_io_context(void)\n \t\t\tioc->aic->exit(ioc->aic);\n \t\tcfq_exit(ioc);\n \n-\t\tput_io_context(ioc);\n \t}\n+\tput_io_context(ioc);\n }\n \n struct io_context *alloc_io_context(gfp_t gfp_flags, int node)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-7539","CWE_ID":"20","category":"security","commit_id":"2b0bbc4f8809c972bad134bc1a2570dbb01dea0b","commit_message":"From 2b0bbc4f8809c972bad134bc1a2570dbb01dea0b Mon Sep 17 00:00:00 2001\nFrom: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>\nDate: Fri, 2 Jun 2017 18:01:41 +0300\nSubject: [PATCH] nbd\/server: get rid of nbd_negotiate_read and friends\n\nFunctions nbd_negotiate_{read,write,drop_sync} were introduced in\n1a6245a5b, when nbd_rwv (was nbd_wr_sync) was working through\nqemu_co_sendv_recvv (the path is nbd_wr_sync -> qemu_co_{recv\/send} ->\nqemu_co_send_recv -> qemu_co_sendv_recvv), which just yields, without\nsetting any handlers. But starting from ff82911cd nbd_rwv (was\nnbd_wr_syncv) works through qio_channel_yield() which sets handlers, so\nwatchers are redundant in nbd_negotiate_{read,write,drop_sync}, then,\nlet's just use nbd_{read,write,drop} functions.\n\nFunctions nbd_{read,write,drop} has errp parameter, which is unused in\nthis patch. This will be fixed later.\n\nSigned-off-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>\nReviewed-by: Eric Blake <eblake@redhat.com>\nMessage-Id: <20170602150150.258222-4-vsementsov@virtuozzo.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n nbd\/server.c | 107 ++++++++++++-----------------------------------------------\n 1 file changed, 22 insertions(+), 85 deletions(-)\n\n","diff_code":"diff --git a\/nbd\/server.c b\/nbd\/server.c\nindex d8bd927..7f44ef0 100644\n--- a\/nbd\/server.c\n+++ b\/nbd\/server.c\n@@ -104,69 +104,6 @@ struct NBDClient {\n \n static void nbd_client_receive_next_request(NBDClient *client);\n \n-static gboolean nbd_negotiate_continue(QIOChannel *ioc,\n-                                       GIOCondition condition,\n-                                       void *opaque)\n-{\n-    qemu_coroutine_enter(opaque);\n-    return TRUE;\n-}\n-\n-static int nbd_negotiate_read(QIOChannel *ioc, void *buffer, size_t size)\n-{\n-    ssize_t ret;\n-    guint watch;\n-\n-    assert(qemu_in_coroutine());\n-    \/* Negotiation are always in main loop. *\/\n-    watch = qio_channel_add_watch(ioc,\n-                                  G_IO_IN,\n-                                  nbd_negotiate_continue,\n-                                  qemu_coroutine_self(),\n-                                  NULL);\n-    ret = nbd_read(ioc, buffer, size, NULL);\n-    g_source_remove(watch);\n-    return ret;\n-\n-}\n-\n-static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n-{\n-    ssize_t ret;\n-    guint watch;\n-\n-    assert(qemu_in_coroutine());\n-    \/* Negotiation are always in main loop. *\/\n-    watch = qio_channel_add_watch(ioc,\n-                                  G_IO_OUT,\n-                                  nbd_negotiate_continue,\n-                                  qemu_coroutine_self(),\n-                                  NULL);\n-    ret = nbd_write(ioc, buffer, size, NULL);\n-    g_source_remove(watch);\n-    return ret;\n-}\n-\n-static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)\n-{\n-    ssize_t ret;\n-    uint8_t *buffer = g_malloc(MIN(65536, size));\n-\n-    while (size > 0) {\n-        size_t count = MIN(65536, size);\n-        ret = nbd_negotiate_read(ioc, buffer, count);\n-        if (ret < 0) {\n-            g_free(buffer);\n-            return ret;\n-        }\n-\n-        size -= count;\n-    }\n-\n-    g_free(buffer);\n-    return 0;\n-}\n-\n \/* Basic flow for negotiation\n \n    Server         Client\n@@ -205,22 +142,22 @@ static int nbd_negotiate_send_rep_len(QIOChannel *ioc, uint32_t type,\n           type, opt, len);\n \n     magic = cpu_to_be64(NBD_REP_MAGIC);\n-    if (nbd_negotiate_write(ioc, &magic, sizeof(magic)) < 0) {\n+    if (nbd_write(ioc, &magic, sizeof(magic), NULL) < 0) {\n         LOG(\"write failed (rep magic)\");\n         return -EINVAL;\n     }\n     opt = cpu_to_be32(opt);\n-    if (nbd_negotiate_write(ioc, &opt, sizeof(opt)) < 0) {\n+    if (nbd_write(ioc, &opt, sizeof(opt), NULL) < 0) {\n         LOG(\"write failed (rep opt)\");\n         return -EINVAL;\n     }\n     type = cpu_to_be32(type);\n-    if (nbd_negotiate_write(ioc, &type, sizeof(type)) < 0) {\n+    if (nbd_write(ioc, &type, sizeof(type), NULL) < 0) {\n         LOG(\"write failed (rep type)\");\n         return -EINVAL;\n     }\n     len = cpu_to_be32(len);\n-    if (nbd_negotiate_write(ioc, &len, sizeof(len)) < 0) {\n+    if (nbd_write(ioc, &len, sizeof(len), NULL) < 0) {\n         LOG(\"write failed (rep data length)\");\n         return -EINVAL;\n     }\n@@ -255,7 +192,7 @@ nbd_negotiate_send_rep_err(QIOChannel *ioc, uint32_t type,\n     if (ret < 0) {\n         goto out;\n     }\n-    if (nbd_negotiate_write(ioc, msg, len) < 0) {\n+    if (nbd_write(ioc, msg, len, NULL) < 0) {\n         LOG(\"write failed (error message)\");\n         ret = -EIO;\n     } else {\n@@ -286,15 +223,15 @@ static int nbd_negotiate_send_rep_list(QIOChannel *ioc, NBDExport *exp)\n     }\n \n     len = cpu_to_be32(name_len);\n-    if (nbd_negotiate_write(ioc, &len, sizeof(len)) < 0) {\n+    if (nbd_write(ioc, &len, sizeof(len), NULL) < 0) {\n         LOG(\"write failed (name length)\");\n         return -EINVAL;\n     }\n-    if (nbd_negotiate_write(ioc, name, name_len) < 0) {\n+    if (nbd_write(ioc, name, name_len, NULL) < 0) {\n         LOG(\"write failed (name buffer)\");\n         return -EINVAL;\n     }\n-    if (nbd_negotiate_write(ioc, desc, desc_len) < 0) {\n+    if (nbd_write(ioc, desc, desc_len, NULL) < 0) {\n         LOG(\"write failed (description buffer)\");\n         return -EINVAL;\n     }\n@@ -308,7 +245,7 @@ static int nbd_negotiate_handle_list(NBDClient *client, uint32_t length)\n     NBDExport *exp;\n \n     if (length) {\n-        if (nbd_negotiate_drop_sync(client->ioc, length) < 0) {\n+        if (nbd_drop(client->ioc, length, NULL) < 0) {\n             return -EIO;\n         }\n         return nbd_negotiate_send_rep_err(client->ioc,\n@@ -339,7 +276,7 @@ static int nbd_negotiate_handle_export_name(NBDClient *client, uint32_t length)\n         LOG(\"Bad length received\");\n         goto fail;\n     }\n-    if (nbd_negotiate_read(client->ioc, name, length) < 0) {\n+    if (nbd_read(client->ioc, name, length, NULL) < 0) {\n         LOG(\"read failed\");\n         goto fail;\n     }\n@@ -372,7 +309,7 @@ static QIOChannel *nbd_negotiate_handle_starttls(NBDClient *client,\n     TRACE(\"Setting up TLS\");\n     ioc = client->ioc;\n     if (length) {\n-        if (nbd_negotiate_drop_sync(ioc, length) < 0) {\n+        if (nbd_drop(ioc, length, NULL) < 0) {\n             return NULL;\n         }\n         nbd_negotiate_send_rep_err(ioc, NBD_REP_ERR_INVALID, NBD_OPT_STARTTLS,\n@@ -436,7 +373,7 @@ static int nbd_negotiate_options(NBDClient *client)\n         ...           Rest of request\n     *\/\n \n-    if (nbd_negotiate_read(client->ioc, &flags, sizeof(flags)) < 0) {\n+    if (nbd_read(client->ioc, &flags, sizeof(flags), NULL) < 0) {\n         LOG(\"read failed\");\n         return -EIO;\n     }\n@@ -462,7 +399,7 @@ static int nbd_negotiate_options(NBDClient *client)\n         uint32_t clientflags, length;\n         uint64_t magic;\n \n-        if (nbd_negotiate_read(client->ioc, &magic, sizeof(magic)) < 0) {\n+        if (nbd_read(client->ioc, &magic, sizeof(magic), NULL) < 0) {\n             LOG(\"read failed\");\n             return -EINVAL;\n         }\n@@ -472,15 +409,15 @@ static int nbd_negotiate_options(NBDClient *client)\n             return -EINVAL;\n         }\n \n-        if (nbd_negotiate_read(client->ioc, &clientflags,\n-                               sizeof(clientflags)) < 0)\n+        if (nbd_read(client->ioc, &clientflags,\n+                      sizeof(clientflags), NULL) < 0)\n         {\n             LOG(\"read failed\");\n             return -EINVAL;\n         }\n         clientflags = be32_to_cpu(clientflags);\n \n-        if (nbd_negotiate_read(client->ioc, &length, sizeof(length)) < 0) {\n+        if (nbd_read(client->ioc, &length, sizeof(length), NULL) < 0) {\n             LOG(\"read failed\");\n             return -EINVAL;\n         }\n@@ -510,7 +447,7 @@ static int nbd_negotiate_options(NBDClient *client)\n                 return -EINVAL;\n \n             default:\n-                if (nbd_negotiate_drop_sync(client->ioc, length) < 0) {\n+                if (nbd_drop(client->ioc, length, NULL) < 0) {\n                     return -EIO;\n                 }\n                 ret = nbd_negotiate_send_rep_err(client->ioc,\n@@ -548,7 +485,7 @@ static int nbd_negotiate_options(NBDClient *client)\n                 return nbd_negotiate_handle_export_name(client, length);\n \n             case NBD_OPT_STARTTLS:\n-                if (nbd_negotiate_drop_sync(client->ioc, length) < 0) {\n+                if (nbd_drop(client->ioc, length, NULL) < 0) {\n                     return -EIO;\n                 }\n                 if (client->tlscreds) {\n@@ -567,7 +504,7 @@ static int nbd_negotiate_options(NBDClient *client)\n                 }\n                 break;\n             default:\n-                if (nbd_negotiate_drop_sync(client->ioc, length) < 0) {\n+                if (nbd_drop(client->ioc, length, NULL) < 0) {\n                     return -EIO;\n                 }\n                 ret = nbd_negotiate_send_rep_err(client->ioc,\n@@ -656,12 +593,12 @@ static coroutine_fn int nbd_negotiate(NBDClientNewData *data)\n             TRACE(\"TLS cannot be enabled with oldstyle protocol\");\n             goto fail;\n         }\n-        if (nbd_negotiate_write(client->ioc, buf, sizeof(buf)) < 0) {\n+        if (nbd_write(client->ioc, buf, sizeof(buf), NULL) < 0) {\n             LOG(\"write failed\");\n             goto fail;\n         }\n     } else {\n-        if (nbd_negotiate_write(client->ioc, buf, 18) < 0) {\n+        if (nbd_write(client->ioc, buf, 18, NULL) < 0) {\n             LOG(\"write failed\");\n             goto fail;\n         }\n@@ -676,7 +613,7 @@ static coroutine_fn int nbd_negotiate(NBDClientNewData *data)\n         stq_be_p(buf + 18, client->exp->size);\n         stw_be_p(buf + 26, client->exp->nbdflags | myflags);\n         len = client->no_zeroes ? 10 : sizeof(buf) - 18;\n-        if (nbd_negotiate_write(client->ioc, buf + 18, len) < 0) {\n+        if (nbd_write(client->ioc, buf + 18, len, NULL) < 0) {\n             LOG(\"write failed\");\n             goto fail;\n         }\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-2963","CWE_ID":"20","category":"security","commit_id":"3e645d6b485446c54c6745c5e2cf5c528fe4deec","commit_message":"From 3e645d6b485446c54c6745c5e2cf5c528fe4deec Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Fri, 15 Oct 2010 11:12:38 -0700\nSubject: v4l1: fix 32-bit compat microcode loading translation\n\nThe compat code for the VIDIOCSMICROCODE ioctl is totally buggered.\nIt's only used by the VIDEO_STRADIS driver, and that one is scheduled to\nstaging and eventually removed unless somebody steps up to maintain it\n(at which point it should use request_firmware() rather than some magic\nioctl).  So we'll get rid of it eventually.\n\nBut in the meantime, the compatibility ioctl code is broken, and this\ntries to get it to at least limp along (even if Mauro suggested just\ndeleting it entirely, which may be the right thing to do - I don't think\nthe compatibility translation code has ever worked unless you were very\nlucky).\n\nReported-by: Kees Cook <kees.cook@canonical.com>\nCc: Mauro Carvalho Chehab <mchehab@infradead.org>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n drivers\/media\/video\/v4l2-compat-ioctl32.c | 32 ++++++++++++++++++++-----------\n 1 file changed, 21 insertions(+), 11 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/media\/video\/v4l2-compat-ioctl32.c b\/drivers\/media\/video\/v4l2-compat-ioctl32.c\nindex 073f01390cdd..86294ed35c9b 100644\n--- a\/drivers\/media\/video\/v4l2-compat-ioctl32.c\n+++ b\/drivers\/media\/video\/v4l2-compat-ioctl32.c\n@@ -193,17 +193,24 @@ static int put_video_window32(struct video_window *kp, struct video_window32 __u\n struct video_code32 {\n \tchar\t\tloadwhat[16];\t\/* name or tag of file being passed *\/\n \tcompat_int_t\tdatasize;\n-\tunsigned char\t*data;\n+\tcompat_uptr_t\tdata;\n };\n \n-static int get_microcode32(struct video_code *kp, struct video_code32 __user *up)\n+static struct video_code __user *get_microcode32(struct video_code32 *kp)\n {\n-\tif (!access_ok(VERIFY_READ, up, sizeof(struct video_code32)) ||\n-\t\tcopy_from_user(kp->loadwhat, up->loadwhat, sizeof(up->loadwhat)) ||\n-\t\tget_user(kp->datasize, &up->datasize) ||\n-\t\tcopy_from_user(kp->data, up->data, up->datasize))\n-\t\t\treturn -EFAULT;\n-\treturn 0;\n+\tstruct video_code __user *up;\n+\n+\tup = compat_alloc_user_space(sizeof(*up));\n+\n+\t\/*\n+\t * NOTE! We don't actually care if these fail. If the\n+\t * user address is invalid, the native ioctl will do\n+\t * the error handling for us\n+\t *\/\n+\t(void) copy_to_user(up->loadwhat, kp->loadwhat, sizeof(up->loadwhat));\n+\t(void) put_user(kp->datasize, &up->datasize);\n+\t(void) put_user(compat_ptr(kp->data), &up->data);\n+\treturn up;\n }\n \n #define VIDIOCGTUNER32\t\t_IOWR('v', 4, struct video_tuner32)\n@@ -739,7 +746,7 @@ static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long ar\n \t\tstruct video_tuner vt;\n \t\tstruct video_buffer vb;\n \t\tstruct video_window vw;\n-\t\tstruct video_code vc;\n+\t\tstruct video_code32 vc;\n \t\tstruct video_audio va;\n #endif\n \t\tstruct v4l2_format v2f;\n@@ -818,8 +825,11 @@ static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long ar\n \t\tbreak;\n \n \tcase VIDIOCSMICROCODE:\n-\t\terr = get_microcode32(&karg.vc, up);\n-\t\tcompatible_arg = 0;\n+\t\t\/* Copy the 32-bit \"video_code32\" to kernel space *\/\n+\t\tif (copy_from_user(&karg.vc, up, sizeof(karg.vc)))\n+\t\t\treturn -EFAULT;\n+\t\t\/* Convert the 32-bit version to a 64-bit version in user space *\/\n+\t\tup = get_microcode32(&karg.vc);\n \t\tbreak;\n \n \tcase VIDIOCSFREQ:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"mjg59","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1079","CWE_ID":"20","category":"security","commit_id":"43629f8f5ea32a998d06d1bb41eefa0e821ff573","commit_message":"From 43629f8f5ea32a998d06d1bb41eefa0e821ff573 Mon Sep 17 00:00:00 2001\nFrom: Vasiliy Kulikov <segoon@openwall.com>\nDate: Mon, 14 Feb 2011 13:54:31 +0300\nSubject: [PATCH] Bluetooth: bnep: fix buffer overflow\n\nStruct ca is copied from userspace.  It is not checked whether the \"device\"\nfield is NULL terminated.  This potentially leads to BUG() inside of\nalloc_netdev_mqs() and\/or information leak by creating a device with a name\nmade of contents of kernel stack.\n\nSigned-off-by: Vasiliy Kulikov <segoon@openwall.com>\nSigned-off-by: Gustavo F. Padovan <padovan@profusion.mobi>\n---\n net\/bluetooth\/bnep\/sock.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/net\/bluetooth\/bnep\/sock.c b\/net\/bluetooth\/bnep\/sock.c\nindex 2862f53b66b15..d935da71ab3b5 100644\n--- a\/net\/bluetooth\/bnep\/sock.c\n+++ b\/net\/bluetooth\/bnep\/sock.c\n@@ -88,6 +88,7 @@ static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long\n \t\t\tsockfd_put(nsock);\n \t\t\treturn -EBADFD;\n \t\t}\n+\t\tca.device[sizeof(ca.device)-1] = 0;\n \n \t\terr = bnep_add_connection(&ca, nsock);\n \t\tif (!err) {\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-12183","CWE_ID":"20","category":"security","commit_id":"55caa8b08c84af2b50fbc936cf334a5a93dd7db5","commit_message":"From 55caa8b08c84af2b50fbc936cf334a5a93dd7db5 Mon Sep 17 00:00:00 2001\nFrom: Nathan Kidd <nkidd@opentext.com>\nDate: Fri, 9 Jan 2015 11:43:05 -0500\nSubject: xfixes: unvalidated lengths (CVE-2017-12183)\n\nv2: Use before swap (Jeremy Huddleston Sequoia)\n\nv3: Fix wrong XFixesCopyRegion checks (Alan Coopersmith)\n\nReviewed-by: Alan Coopersmith <alan.coopersmith@oracle.com>\nReviewed-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>\nReviewed-by: Julien Cristau <jcristau@debian.org>\nSigned-off-by: Jeremy Huddleston Sequoia <jeremyhu@apple.com>\nSigned-off-by: Nathan Kidd <nkidd@opentext.com>\nSigned-off-by: Julien Cristau <jcristau@debian.org>\n---\n xfixes\/cursor.c  | 5 ++++-\n xfixes\/region.c  | 3 ++-\n xfixes\/saveset.c | 1 +\n xfixes\/xfixes.c  | 1 +\n 4 files changed, 8 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/xfixes\/cursor.c b\/xfixes\/cursor.c\nindex c1ab3be..dc447ed 100644\n--- a\/xfixes\/cursor.c\n+++ b\/xfixes\/cursor.c\n@@ -281,6 +281,7 @@ int _X_COLD\n SProcXFixesSelectCursorInput(ClientPtr client)\n {\n     REQUEST(xXFixesSelectCursorInputReq);\n+    REQUEST_SIZE_MATCH(xXFixesSelectCursorInputReq);\n \n     swaps(&stuff->length);\n     swapl(&stuff->window);\n@@ -414,7 +415,7 @@ ProcXFixesSetCursorName(ClientPtr client)\n     REQUEST(xXFixesSetCursorNameReq);\n     Atom atom;\n \n-    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);\n+    REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);\n     VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);\n     tchar = (char *) &stuff[1];\n     atom = MakeAtom(tchar, stuff->nbytes, TRUE);\n@@ -1007,6 +1008,8 @@ SProcXFixesCreatePointerBarrier(ClientPtr client)\n     int i;\n     CARD16 *in_devices = (CARD16 *) &stuff[1];\n \n+    REQUEST_AT_LEAST_SIZE(xXFixesCreatePointerBarrierReq);\n+\n     swaps(&stuff->length);\n     swaps(&stuff->num_devices);\n     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));\ndiff --git a\/xfixes\/region.c b\/xfixes\/region.c\nindex e773701..7c0a7d2 100644\n--- a\/xfixes\/region.c\n+++ b\/xfixes\/region.c\n@@ -359,6 +359,7 @@ ProcXFixesCopyRegion(ClientPtr client)\n     RegionPtr pSource, pDestination;\n \n     REQUEST(xXFixesCopyRegionReq);\n+    REQUEST_SIZE_MATCH(xXFixesCopyRegionReq);\n \n     VERIFY_REGION(pSource, stuff->source, client, DixReadAccess);\n     VERIFY_REGION(pDestination, stuff->destination, client, DixWriteAccess);\n@@ -375,7 +376,7 @@ SProcXFixesCopyRegion(ClientPtr client)\n     REQUEST(xXFixesCopyRegionReq);\n \n     swaps(&stuff->length);\n-    REQUEST_AT_LEAST_SIZE(xXFixesCopyRegionReq);\n+    REQUEST_SIZE_MATCH(xXFixesCopyRegionReq);\n     swapl(&stuff->source);\n     swapl(&stuff->destination);\n     return (*ProcXFixesVector[stuff->xfixesReqType]) (client);\ndiff --git a\/xfixes\/saveset.c b\/xfixes\/saveset.c\nindex 2043153..fd9c7a1 100644\n--- a\/xfixes\/saveset.c\n+++ b\/xfixes\/saveset.c\n@@ -62,6 +62,7 @@ int _X_COLD\n SProcXFixesChangeSaveSet(ClientPtr client)\n {\n     REQUEST(xXFixesChangeSaveSetReq);\n+    REQUEST_SIZE_MATCH(xXFixesChangeSaveSetReq);\n \n     swaps(&stuff->length);\n     swapl(&stuff->window);\ndiff --git a\/xfixes\/xfixes.c b\/xfixes\/xfixes.c\nindex 77efd64..248bf02 100644\n--- a\/xfixes\/xfixes.c\n+++ b\/xfixes\/xfixes.c\n@@ -160,6 +160,7 @@ static _X_COLD int\n SProcXFixesQueryVersion(ClientPtr client)\n {\n     REQUEST(xXFixesQueryVersionReq);\n+    REQUEST_SIZE_MATCH(xXFixesQueryVersionReq);\n \n     swaps(&stuff->length);\n     swapl(&stuff->majorVersion);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-1828","CWE_ID":"20","category":"security","commit_id":"726bc6b092da4c093eb74d13c07184b18c1af0f1","commit_message":"From 726bc6b092da4c093eb74d13c07184b18c1af0f1 Mon Sep 17 00:00:00 2001\nFrom: Guenter Roeck <linux@roeck-us.net>\nDate: Wed, 27 Feb 2013 10:57:31 +0000\nSubject: [PATCH] net\/sctp: Validate parameter size for SCTP_GET_ASSOC_STATS\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nBuilding sctp may fail with:\n\nIn function \u2018copy_from_user\u2019,\n    inlined from \u2018sctp_getsockopt_assoc_stats\u2019 at\n    net\/sctp\/socket.c:5656:20:\narch\/x86\/include\/asm\/uaccess_32.h:211:26: error: call to\n    \u2018copy_from_user_overflow\u2019 declared with attribute error: copy_from_user()\n    buffer size is not provably correct\n\nif built with W=1 due to a missing parameter size validation\nbefore the call to copy_from_user.\n\nSigned-off-by: Guenter Roeck <linux@roeck-us.net>\nAcked-by: Vlad Yasevich <vyasevich@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/sctp\/socket.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/net\/sctp\/socket.c b\/net\/sctp\/socket.c\nindex cedd9bf67b8c5..9ef5c7312e12c 100644\n--- a\/net\/sctp\/socket.c\n+++ b\/net\/sctp\/socket.c\n@@ -5653,6 +5653,9 @@ static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n \tif (len < sizeof(sctp_assoc_t))\n \t\treturn -EINVAL;\n \n+\t\/* Allow the struct to grow and fill in as much as possible *\/\n+\tlen = min_t(size_t, len, sizeof(sas));\n+\n \tif (copy_from_user(&sas, optval, len))\n \t\treturn -EFAULT;\n \n@@ -5686,9 +5689,6 @@ static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n \t\/* Mark beginning of a new observation period *\/\n \tasoc->stats.max_obs_rto = asoc->rto_min;\n \n-\t\/* Allow the struct to grow and fill in as much as possible *\/\n-\tlen = min_t(size_t, len, sizeof(sas));\n-\n \tif (put_user(len, optlen))\n \t\treturn -EFAULT;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-7267","CWE_ID":"20","category":"security","commit_id":"f3d3342602f8bcbf37d7c46641cb9bca7618eb1c","commit_message":"From f3d3342602f8bcbf37d7c46641cb9bca7618eb1c Mon Sep 17 00:00:00 2001\nFrom: Hannes Frederic Sowa <hannes@stressinduktion.org>\nDate: Thu, 21 Nov 2013 03:14:22 +0100\nSubject: net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include\/linux\/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec\/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n crypto\/algif_hash.c            |  2 --\n crypto\/algif_skcipher.c        |  1 -\n drivers\/isdn\/mISDN\/socket.c    | 13 ++++---------\n drivers\/net\/ppp\/pppoe.c        |  2 --\n include\/linux\/net.h            |  8 ++++++++\n net\/appletalk\/ddp.c            | 16 +++++++---------\n net\/atm\/common.c               |  2 --\n net\/ax25\/af_ax25.c             |  4 ++--\n net\/bluetooth\/af_bluetooth.c   |  9 ++-------\n net\/bluetooth\/hci_sock.c       |  2 --\n net\/bluetooth\/rfcomm\/sock.c    |  1 -\n net\/bluetooth\/sco.c            |  1 -\n net\/caif\/caif_socket.c         |  4 ----\n net\/compat.c                   |  3 ++-\n net\/core\/iovec.c               |  3 ++-\n net\/ipx\/af_ipx.c               |  3 +--\n net\/irda\/af_irda.c             |  4 ----\n net\/iucv\/af_iucv.c             |  2 --\n net\/key\/af_key.c               |  1 -\n net\/l2tp\/l2tp_ppp.c            |  2 --\n net\/llc\/af_llc.c               |  2 --\n net\/netlink\/af_netlink.c       |  2 --\n net\/netrom\/af_netrom.c         |  3 +--\n net\/nfc\/llcp_sock.c            |  2 --\n net\/nfc\/rawsock.c              |  2 --\n net\/packet\/af_packet.c         | 32 +++++++++++++++-----------------\n net\/rds\/recv.c                 |  2 --\n net\/rose\/af_rose.c             |  8 +++++---\n net\/rxrpc\/ar-recvmsg.c         |  9 ++++++---\n net\/socket.c                   | 19 +++++++++++--------\n net\/tipc\/socket.c              |  6 ------\n net\/unix\/af_unix.c             |  5 -----\n net\/vmw_vsock\/af_vsock.c       |  2 --\n net\/vmw_vsock\/vmci_transport.c |  2 --\n net\/x25\/af_x25.c               |  3 +--\n 35 files changed, 67 insertions(+), 115 deletions(-)\n\n","diff_code":"diff --git a\/crypto\/algif_hash.c b\/crypto\/algif_hash.c\nindex 0262210cad38..ef5356cd280a 100644\n--- a\/crypto\/algif_hash.c\n+++ b\/crypto\/algif_hash.c\n@@ -161,8 +161,6 @@ static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\ndiff --git a\/crypto\/algif_skcipher.c b\/crypto\/algif_skcipher.c\nindex a1c4f0a55583..6a6dfc062d2a 100644\n--- a\/crypto\/algif_skcipher.c\n+++ b\/crypto\/algif_skcipher.c\n@@ -432,7 +432,6 @@ static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n \tlong copied = 0;\n \n \tlock_sock(sk);\n-\tmsg->msg_namelen = 0;\n \tfor (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;\n \t     iovlen--, iov++) {\n \t\tunsigned long seglen = iov->iov_len;\ndiff --git a\/drivers\/isdn\/mISDN\/socket.c b\/drivers\/isdn\/mISDN\/socket.c\nindex e47dcb9d1e91..5cefb479c707 100644\n--- a\/drivers\/isdn\/mISDN\/socket.c\n+++ b\/drivers\/isdn\/mISDN\/socket.c\n@@ -117,7 +117,6 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sk_buff\t\t*skb;\n \tstruct sock\t\t*sk = sock->sk;\n-\tstruct sockaddr_mISDN\t*maddr;\n \n \tint\t\tcopied, err;\n \n@@ -135,9 +134,9 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n-\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_mISDN *maddr = msg->msg_name;\n+\n \t\tmaddr->family = AF_ISDN;\n \t\tmaddr->dev = _pms(sk)->dev->id;\n \t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n@@ -150,11 +149,7 @@ mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n \t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n \t\t}\n-\t} else {\n-\t\tif (msg->msg_namelen)\n-\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n-\t\t\t       __func__, msg->msg_namelen);\n-\t\tmsg->msg_namelen = 0;\n+\t\tmsg->msg_namelen = sizeof(*maddr);\n \t}\n \n \tcopied = skb->len + MISDN_HEADER_LEN;\ndiff --git a\/drivers\/net\/ppp\/pppoe.c b\/drivers\/net\/ppp\/pppoe.c\nindex 5f66e30d9823..82ee6ed954cb 100644\n--- a\/drivers\/net\/ppp\/pppoe.c\n+++ b\/drivers\/net\/ppp\/pppoe.c\n@@ -979,8 +979,6 @@ static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (error < 0)\n \t\tgoto end;\n \n-\tm->msg_namelen = 0;\n-\n \tif (skb) {\n \t\ttotal_len = min_t(size_t, total_len, skb->len);\n \t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\ndiff --git a\/include\/linux\/net.h b\/include\/linux\/net.h\nindex b292a0435571..4bcee94cef93 100644\n--- a\/include\/linux\/net.h\n+++ b\/include\/linux\/net.h\n@@ -164,6 +164,14 @@ struct proto_ops {\n #endif\n \tint\t\t(*sendmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len);\n+\t\/* Notes for implementing recvmsg:\n+\t * ===============================\n+\t * msg->msg_namelen should get updated by the recvmsg handlers\n+\t * iff msg_name != NULL. It is by default 0 to prevent\n+\t * returning uninitialized memory to user space.  The recvfrom\n+\t * handlers can assume that msg.msg_name is either NULL or has\n+\t * a minimum size of sizeof(struct sockaddr_storage).\n+\t *\/\n \tint\t\t(*recvmsg)   (struct kiocb *iocb, struct socket *sock,\n \t\t\t\t      struct msghdr *m, size_t total_len,\n \t\t\t\t      int flags);\ndiff --git a\/net\/appletalk\/ddp.c b\/net\/appletalk\/ddp.c\nindex 7fee50d637f9..7d424ac6e760 100644\n--- a\/net\/appletalk\/ddp.c\n+++ b\/net\/appletalk\/ddp.c\n@@ -1735,7 +1735,6 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n-\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n@@ -1764,14 +1763,13 @@ static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n \n-\tif (!err) {\n-\t\tif (sat) {\n-\t\t\tsat->sat_family      = AF_APPLETALK;\n-\t\t\tsat->sat_port        = ddp->deh_sport;\n-\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n-\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n-\t\t}\n-\t\tmsg->msg_namelen = sizeof(*sat);\n+\tif (!err && msg->msg_name) {\n+\t\tstruct sockaddr_at *sat = msg->msg_name;\n+\t\tsat->sat_family      = AF_APPLETALK;\n+\t\tsat->sat_port        = ddp->deh_sport;\n+\t\tsat->sat_addr.s_node = ddp->deh_snode;\n+\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n+\t\tmsg->msg_namelen     = sizeof(*sat);\n \t}\n \n \tskb_free_datagram(sk, skb);\t\/* Free the datagram. *\/\ndiff --git a\/net\/atm\/common.c b\/net\/atm\/common.c\nindex 737bef59ce89..7b491006eaf4 100644\n--- a\/net\/atm\/common.c\n+++ b\/net\/atm\/common.c\n@@ -531,8 +531,6 @@ int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n \ndiff --git a\/net\/ax25\/af_ax25.c b\/net\/ax25\/af_ax25.c\nindex a00123ebb0ae..7bb1605bdfd9 100644\n--- a\/net\/ax25\/af_ax25.c\n+++ b\/net\/ax25\/af_ax25.c\n@@ -1636,11 +1636,11 @@ static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (msg->msg_namelen != 0) {\n-\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n+\tif (msg->msg_name) {\n \t\tax25_digi digi;\n \t\tax25_address src;\n \t\tconst unsigned char *mac = skb_mac_header(skb);\n+\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n \n \t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n \t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\ndiff --git a\/net\/bluetooth\/af_bluetooth.c b\/net\/bluetooth\/af_bluetooth.c\nindex f6a1671ea2ff..56ca494621c6 100644\n--- a\/net\/bluetooth\/af_bluetooth.c\n+++ b\/net\/bluetooth\/af_bluetooth.c\n@@ -224,10 +224,9 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb) {\n-\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n-\t\t\tmsg->msg_namelen = 0;\n+\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n \t\t\treturn 0;\n-\t\t}\n+\n \t\treturn err;\n \t}\n \n@@ -245,8 +244,6 @@ int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tif (bt_sk(sk)->skb_msg_name)\n \t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n \t\t\t\t\t\t&msg->msg_namelen);\n-\t\telse\n-\t\t\tmsg->msg_namelen = 0;\n \t}\n \n \tskb_free_datagram(sk, skb);\n@@ -295,8 +292,6 @@ int bt_sock_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags & MSG_OOB)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \tBT_DBG(\"sk %p size %zu\", sk, size);\n \n \tlock_sock(sk);\ndiff --git a\/net\/bluetooth\/hci_sock.c b\/net\/bluetooth\/hci_sock.c\nindex 71f0be173080..6a6c8bb4fd72 100644\n--- a\/net\/bluetooth\/hci_sock.c\n+++ b\/net\/bluetooth\/hci_sock.c\n@@ -856,8 +856,6 @@ static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn err;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/bluetooth\/rfcomm\/sock.c b\/net\/bluetooth\/rfcomm\/sock.c\nindex c4d3d423f89b..c80766f892c3 100644\n--- a\/net\/bluetooth\/rfcomm\/sock.c\n+++ b\/net\/bluetooth\/rfcomm\/sock.c\n@@ -615,7 +615,6 @@ static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n-\t\tmsg->msg_namelen = 0;\n \t\treturn 0;\n \t}\n \ndiff --git a\/net\/bluetooth\/sco.c b\/net\/bluetooth\/sco.c\nindex 12a0e51e21e1..24fa3964b3c8 100644\n--- a\/net\/bluetooth\/sco.c\n+++ b\/net\/bluetooth\/sco.c\n@@ -711,7 +711,6 @@ static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n \t\tsk->sk_state = BT_CONFIG;\n-\t\tmsg->msg_namelen = 0;\n \n \t\trelease_sock(sk);\n \t\treturn 0;\ndiff --git a\/net\/caif\/caif_socket.c b\/net\/caif\/caif_socket.c\nindex 05a41c7ec304..d6be3edb7a43 100644\n--- a\/net\/caif\/caif_socket.c\n+++ b\/net\/caif\/caif_socket.c\n@@ -286,8 +286,6 @@ static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (m->msg_flags&MSG_OOB)\n \t\tgoto read_error;\n \n-\tm->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n \tif (!skb)\n \t\tgoto read_error;\n@@ -361,8 +359,6 @@ static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/*\n \t * Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\ndiff --git a\/net\/compat.c b\/net\/compat.c\nindex 89032580bd1d..618c6a8a911b 100644\n--- a\/net\/compat.c\n+++ b\/net\/compat.c\n@@ -93,7 +93,8 @@ int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tkern_msg->msg_name = kern_address;\n+\t\tif (kern_msg->msg_name)\n+\t\t\tkern_msg->msg_name = kern_address;\n \t} else\n \t\tkern_msg->msg_name = NULL;\n \ndiff --git a\/net\/core\/iovec.c b\/net\/core\/iovec.c\nindex 4cdb7c48dad6..b61869429f4c 100644\n--- a\/net\/core\/iovec.c\n+++ b\/net\/core\/iovec.c\n@@ -48,7 +48,8 @@ int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *a\n \t\t\tif (err < 0)\n \t\t\t\treturn err;\n \t\t}\n-\t\tm->msg_name = address;\n+\t\tif (m->msg_name)\n+\t\t\tm->msg_name = address;\n \t} else {\n \t\tm->msg_name = NULL;\n \t}\ndiff --git a\/net\/ipx\/af_ipx.c b\/net\/ipx\/af_ipx.c\nindex 7a1e0fc1bd4d..e096025b477f 100644\n--- a\/net\/ipx\/af_ipx.c\n+++ b\/net\/ipx\/af_ipx.c\n@@ -1823,8 +1823,6 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (skb->tstamp.tv64)\n \t\tsk->sk_stamp = skb->tstamp;\n \n-\tmsg->msg_namelen = sizeof(*sipx);\n-\n \tif (sipx) {\n \t\tsipx->sipx_family\t= AF_IPX;\n \t\tsipx->sipx_port\t\t= ipx->ipx_source.sock;\n@@ -1832,6 +1830,7 @@ static int ipx_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsipx->sipx_network\t= IPX_SKB_CB(skb)->ipx_source_net;\n \t\tsipx->sipx_type \t= ipx->ipx_type;\n \t\tsipx->sipx_zero\t\t= 0;\n+\t\tmsg->msg_namelen\t= sizeof(*sipx);\n \t}\n \trc = copied;\n \ndiff --git a\/net\/irda\/af_irda.c b\/net\/irda\/af_irda.c\nindex 0f676908d15b..de7db23049f1 100644\n--- a\/net\/irda\/af_irda.c\n+++ b\/net\/irda\/af_irda.c\n@@ -1385,8 +1385,6 @@ static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n \n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \n-\tmsg->msg_namelen = 0;\n-\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n@@ -1451,8 +1449,6 @@ static int irda_recvmsg_stream(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, noblock);\n \n-\tmsg->msg_namelen = 0;\n-\n \tdo {\n \t\tint chunk;\n \t\tstruct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);\ndiff --git a\/net\/iucv\/af_iucv.c b\/net\/iucv\/af_iucv.c\nindex 168aff5e60de..c4b7218058b6 100644\n--- a\/net\/iucv\/af_iucv.c\n+++ b\/net\/iucv\/af_iucv.c\n@@ -1324,8 +1324,6 @@ static int iucv_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint err = 0;\n \tu32 offset;\n \n-\tmsg->msg_namelen = 0;\n-\n \tif ((sk->sk_state == IUCV_DISCONN) &&\n \t    skb_queue_empty(&iucv->backlog_skb_q) &&\n \t    skb_queue_empty(&sk->sk_receive_queue) &&\ndiff --git a\/net\/key\/af_key.c b\/net\/key\/af_key.c\nindex 911ef03bf8fb..545f047868ad 100644\n--- a\/net\/key\/af_key.c\n+++ b\/net\/key\/af_key.c\n@@ -3616,7 +3616,6 @@ static int pfkey_recvmsg(struct kiocb *kiocb,\n \tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n \tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n \tif (skb == NULL)\n \t\tgoto out;\ndiff --git a\/net\/l2tp\/l2tp_ppp.c b\/net\/l2tp\/l2tp_ppp.c\nindex ffda81ef1a70..be5fadf34739 100644\n--- a\/net\/l2tp\/l2tp_ppp.c\n+++ b\/net\/l2tp\/l2tp_ppp.c\n@@ -197,8 +197,6 @@ static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sk->sk_state & PPPOX_BOUND)\n \t\tgoto end;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = 0;\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\ndiff --git a\/net\/llc\/af_llc.c b\/net\/llc\/af_llc.c\nindex 6cba486353e8..7b01b9f5846c 100644\n--- a\/net\/llc\/af_llc.c\n+++ b\/net\/llc\/af_llc.c\n@@ -720,8 +720,6 @@ static int llc_ui_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tint target;\t\/* Read at least this many bytes *\/\n \tlong timeo;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \tcopied = -ENOTCONN;\n \tif (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))\ndiff --git a\/net\/netlink\/af_netlink.c b\/net\/netlink\/af_netlink.c\nindex f0176e1a5a81..bca50b95c182 100644\n--- a\/net\/netlink\/af_netlink.c\n+++ b\/net\/netlink\/af_netlink.c\n@@ -2335,8 +2335,6 @@ static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,\n \t}\n #endif\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = data_skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/netrom\/af_netrom.c b\/net\/netrom\/af_netrom.c\nindex 698814bfa7ad..53c19a35fc6d 100644\n--- a\/net\/netrom\/af_netrom.c\n+++ b\/net\/netrom\/af_netrom.c\n@@ -1179,10 +1179,9 @@ static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n+\t\tmsg->msg_namelen = sizeof(*sax);\n \t}\n \n-\tmsg->msg_namelen = sizeof(*sax);\n-\n \tskb_free_datagram(sk, skb);\n \n \trelease_sock(sk);\ndiff --git a\/net\/nfc\/llcp_sock.c b\/net\/nfc\/llcp_sock.c\nindex d308402b67d8..824c6056bf82 100644\n--- a\/net\/nfc\/llcp_sock.c\n+++ b\/net\/nfc\/llcp_sock.c\n@@ -807,8 +807,6 @@ static int llcp_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tpr_debug(\"%p %zu\\n\", sk, len);\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state == LLCP_CLOSED &&\ndiff --git a\/net\/nfc\/rawsock.c b\/net\/nfc\/rawsock.c\nindex cd958b381f96..66bcd2eb5773 100644\n--- a\/net\/nfc\/rawsock.c\n+++ b\/net\/nfc\/rawsock.c\n@@ -244,8 +244,6 @@ static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (!skb)\n \t\treturn rc;\n \n-\tmsg->msg_namelen = 0;\n-\n \tcopied = skb->len;\n \tif (len < copied) {\n \t\tmsg->msg_flags |= MSG_TRUNC;\ndiff --git a\/net\/packet\/af_packet.c b\/net\/packet\/af_packet.c\nindex 2e8286b47c28..61bd50adead1 100644\n--- a\/net\/packet\/af_packet.c\n+++ b\/net\/packet\/af_packet.c\n@@ -2660,7 +2660,6 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tstruct sock *sk = sock->sk;\n \tstruct sk_buff *skb;\n \tint copied, err;\n-\tstruct sockaddr_ll *sll;\n \tint vnet_hdr_len = 0;\n \n \terr = -EINVAL;\n@@ -2744,22 +2743,10 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \t\t\tgoto out_free;\n \t}\n \n-\t\/*\n-\t *\tIf the address length field is there to be filled in, we fill\n-\t *\tit in now.\n-\t *\/\n-\n-\tsll = &PACKET_SKB_CB(skb)->sa.ll;\n-\tif (sock->type == SOCK_PACKET)\n-\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n-\telse\n-\t\tmsg->msg_namelen = sll->sll_halen + offsetof(struct sockaddr_ll, sll_addr);\n-\n-\t\/*\n-\t *\tYou lose any data beyond the buffer you gave. If it worries a\n-\t *\tuser program they can ask the device for its MTU anyway.\n+\t\/* You lose any data beyond the buffer you gave. If it worries\n+\t * a user program they can ask the device for its MTU\n+\t * anyway.\n \t *\/\n-\n \tcopied = skb->len;\n \tif (copied > len) {\n \t\tcopied = len;\n@@ -2772,9 +2759,20 @@ static int packet_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tsock_recv_ts_and_drops(msg, sk, skb);\n \n-\tif (msg->msg_name)\n+\tif (msg->msg_name) {\n+\t\t\/* If the address length field is there to be filled\n+\t\t * in, we fill it in now.\n+\t\t *\/\n+\t\tif (sock->type == SOCK_PACKET) {\n+\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_pkt);\n+\t\t} else {\n+\t\t\tstruct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;\n+\t\t\tmsg->msg_namelen = sll->sll_halen +\n+\t\t\t\toffsetof(struct sockaddr_ll, sll_addr);\n+\t\t}\n \t\tmemcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa,\n \t\t       msg->msg_namelen);\n+\t}\n \n \tif (pkt_sk(sk)->auxdata) {\n \t\tstruct tpacket_auxdata aux;\ndiff --git a\/net\/rds\/recv.c b\/net\/rds\/recv.c\nindex 9f0f17cf6bf9..de339b24ca14 100644\n--- a\/net\/rds\/recv.c\n+++ b\/net\/rds\/recv.c\n@@ -410,8 +410,6 @@ int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \n \trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n \n-\tmsg->msg_namelen = 0;\n-\n \tif (msg_flags & MSG_OOB)\n \t\tgoto out;\n \ndiff --git a\/net\/rose\/af_rose.c b\/net\/rose\/af_rose.c\nindex e98fcfbe6007..33af77246bfe 100644\n--- a\/net\/rose\/af_rose.c\n+++ b\/net\/rose\/af_rose.c\n@@ -1216,7 +1216,6 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n {\n \tstruct sock *sk = sock->sk;\n \tstruct rose_sock *rose = rose_sk(sk);\n-\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n \tsize_t copied;\n \tunsigned char *asmptr;\n \tstruct sk_buff *skb;\n@@ -1252,8 +1251,11 @@ static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \n-\tif (srose != NULL) {\n-\t\tmemset(srose, 0, msg->msg_namelen);\n+\tif (msg->msg_name) {\n+\t\tstruct sockaddr_rose *srose;\n+\n+\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n+\t\tsrose = msg->msg_name;\n \t\tsrose->srose_family = AF_ROSE;\n \t\tsrose->srose_addr   = rose->dest_addr;\n \t\tsrose->srose_call   = rose->dest_call;\ndiff --git a\/net\/rxrpc\/ar-recvmsg.c b\/net\/rxrpc\/ar-recvmsg.c\nindex 4b48687c3890..898492a8d61b 100644\n--- a\/net\/rxrpc\/ar-recvmsg.c\n+++ b\/net\/rxrpc\/ar-recvmsg.c\n@@ -143,10 +143,13 @@ int rxrpc_recvmsg(struct kiocb *iocb, struct socket *sock,\n \n \t\t\/* copy the peer address and timestamp *\/\n \t\tif (!continue_call) {\n-\t\t\tif (msg->msg_name && msg->msg_namelen > 0)\n+\t\t\tif (msg->msg_name) {\n+\t\t\t\tsize_t len =\n+\t\t\t\t\tsizeof(call->conn->trans->peer->srx);\n \t\t\t\tmemcpy(msg->msg_name,\n-\t\t\t\t       &call->conn->trans->peer->srx,\n-\t\t\t\t       sizeof(call->conn->trans->peer->srx));\n+\t\t\t\t       &call->conn->trans->peer->srx, len);\n+\t\t\t\tmsg->msg_namelen = len;\n+\t\t\t}\n \t\t\tsock_recv_ts_and_drops(msg, &rx->sk, skb);\n \t\t}\n \ndiff --git a\/net\/socket.c b\/net\/socket.c\nindex c226aceee65b..fc285564e49e 100644\n--- a\/net\/socket.c\n+++ b\/net\/socket.c\n@@ -1840,8 +1840,10 @@ SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n \tmsg.msg_iov = &iov;\n \tiov.iov_len = size;\n \tiov.iov_base = ubuf;\n-\tmsg.msg_name = (struct sockaddr *)&address;\n-\tmsg.msg_namelen = sizeof(address);\n+\t\/* Save some cycles and don't copy the address if not needed *\/\n+\tmsg.msg_name = addr ? (struct sockaddr *)&address : NULL;\n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg.msg_namelen = 0;\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = sock_recvmsg(sock, &msg, size, flags);\n@@ -2221,16 +2223,14 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \t\t\tgoto out;\n \t}\n \n-\t\/*\n-\t *      Save the user-mode address (verify_iovec will change the\n-\t *      kernel msghdr to use the kernel address space)\n+\t\/* Save the user-mode address (verify_iovec will change the\n+\t * kernel msghdr to use the kernel address space)\n \t *\/\n-\n \tuaddr = (__force void __user *)msg_sys->msg_name;\n \tuaddr_len = COMPAT_NAMELEN(msg);\n-\tif (MSG_CMSG_COMPAT & flags) {\n+\tif (MSG_CMSG_COMPAT & flags)\n \t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n-\t} else\n+\telse\n \t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n \tif (err < 0)\n \t\tgoto out_freeiov;\n@@ -2239,6 +2239,9 @@ static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n \tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n \tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n \n+\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n+\tmsg_sys->msg_namelen = 0;\n+\n \tif (sock->file->f_flags & O_NONBLOCK)\n \t\tflags |= MSG_DONTWAIT;\n \terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\ndiff --git a\/net\/tipc\/socket.c b\/net\/tipc\/socket.c\nindex 3906527259d1..3b61851bb927 100644\n--- a\/net\/tipc\/socket.c\n+++ b\/net\/tipc\/socket.c\n@@ -980,9 +980,6 @@ static int recv_msg(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n restart:\n \n@@ -1091,9 +1088,6 @@ static int recv_stream(struct kiocb *iocb, struct socket *sock,\n \t\tgoto exit;\n \t}\n \n-\t\/* will be updated in set_orig_addr() if needed *\/\n-\tm->msg_namelen = 0;\n-\n \ttarget = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);\n \ttimeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n \ndiff --git a\/net\/unix\/af_unix.c b\/net\/unix\/af_unix.c\nindex c1f403bed683..01625ccc3ae6 100644\n--- a\/net\/unix\/af_unix.c\n+++ b\/net\/unix\/af_unix.c\n@@ -1754,7 +1754,6 @@ static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n {\n \tstruct unix_sock *u = unix_sk(sk);\n \n-\tmsg->msg_namelen = 0;\n \tif (u->addr) {\n \t\tmsg->msg_namelen = u->addr->len;\n \t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n@@ -1778,8 +1777,6 @@ static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (flags&MSG_OOB)\n \t\tgoto out;\n \n-\tmsg->msg_namelen = 0;\n-\n \terr = mutex_lock_interruptible(&u->readlock);\n \tif (err) {\n \t\terr = sock_intr_errno(sock_rcvtimeo(sk, noblock));\n@@ -1924,8 +1921,6 @@ static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,\n \ttarget = sock_rcvlowat(sk, flags&MSG_WAITALL, size);\n \ttimeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Lock the socket to prevent queue disordering\n \t * while sleeps in memcpy_tomsg\n \t *\/\ndiff --git a\/net\/vmw_vsock\/af_vsock.c b\/net\/vmw_vsock\/af_vsock.c\nindex 545c08b8a1d4..5adfd94c5b85 100644\n--- a\/net\/vmw_vsock\/af_vsock.c\n+++ b\/net\/vmw_vsock\/af_vsock.c\n@@ -1662,8 +1662,6 @@ vsock_stream_recvmsg(struct kiocb *kiocb,\n \tvsk = vsock_sk(sk);\n \terr = 0;\n \n-\tmsg->msg_namelen = 0;\n-\n \tlock_sock(sk);\n \n \tif (sk->sk_state != SS_CONNECTED) {\ndiff --git a\/net\/vmw_vsock\/vmci_transport.c b\/net\/vmw_vsock\/vmci_transport.c\nindex 9d6986634e0b..687360da62d9 100644\n--- a\/net\/vmw_vsock\/vmci_transport.c\n+++ b\/net\/vmw_vsock\/vmci_transport.c\n@@ -1746,8 +1746,6 @@ static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \n-\tmsg->msg_namelen = 0;\n-\n \t\/* Retrieve the head sk_buff from the socket's receive queue. *\/\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\ndiff --git a\/net\/x25\/af_x25.c b\/net\/x25\/af_x25.c\nindex 45a3ab5612c1..7622789d3750 100644\n--- a\/net\/x25\/af_x25.c\n+++ b\/net\/x25\/af_x25.c\n@@ -1340,10 +1340,9 @@ static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,\n \tif (sx25) {\n \t\tsx25->sx25_family = AF_X25;\n \t\tsx25->sx25_addr   = x25->dest_addr;\n+\t\tmsg->msg_namelen = sizeof(*sx25);\n \t}\n \n-\tmsg->msg_namelen = sizeof(struct sockaddr_x25);\n-\n \tx25_check_rbuf(sk);\n \trc = copied;\n out_free_dgram:\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2015-6824","CWE_ID":"20","category":"security","commit_id":"a5d44d5c220e12ca0cb7a4eceb0f74759cb13111","commit_message":"From a5d44d5c220e12ca0cb7a4eceb0f74759cb13111 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Wed, 15 Jul 2015 19:20:19 +0200\nSubject: [PATCH] swscale\/utils: Clear pix buffers\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nFixes use of uninitialized memory\nFixes: a96874b9466b6edc660a519c7ad47977_signal_sigsegv_7ffff713351a_744_nc_sample.avi with memlimit 2147483648\n\nFound-by: Samuel Gro\u00c3\u009f, Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libswscale\/utils.c | 6 +++---\n 1 file changed, 3 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/libswscale\/utils.c b\/libswscale\/utils.c\nindex c384aa5302..16f187a38f 100644\n--- a\/libswscale\/utils.c\n+++ b\/libswscale\/utils.c\n@@ -1496,9 +1496,9 @@ av_cold int sws_init_context(SwsContext *c, SwsFilter *srcFilter,\n \n     \/* Allocate pixbufs (we use dynamic allocation because otherwise we would\n      * need to allocate several megabytes to handle all possible cases) *\/\n-    FF_ALLOC_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);\n-    FF_ALLOC_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);\n-    FF_ALLOC_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);\n+    FF_ALLOCZ_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);\n+    FF_ALLOCZ_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);\n+    FF_ALLOCZ_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);\n     if (CONFIG_SWSCALE_ALPHA && isALPHA(c->srcFormat) && isALPHA(c->dstFormat))\n         FF_ALLOCZ_OR_GOTO(c, c->alpPixBuf, c->vLumBufSize * 3 * sizeof(int16_t *), fail);\n     \/* Note we need at least one pixel more at the end because of the MMX code\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-5355","CWE_ID":"20","category":"security","commit_id":"5efb45231671baa2db2011d8f67f9d6e72bc455b","commit_message":"From 5efb45231671baa2db2011d8f67f9d6e72bc455b Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Fri, 29 Apr 2016 15:19:49 -0700\nSubject: [PATCH] Fix packet length handling.\n\nTreat the packet length as unsigned - it shouldn't be negative in the\nfile.  If it is, that'll probably cause the sscanf to fail, so we'll\nreport the file as bad.\n\nCheck it against WTAP_MAX_PACKET_SIZE to make sure we don't try to\nallocate a huge amount of memory, just as we do in other file readers.\n\nUse the now-validated packet size as the length in\nws_buffer_assure_space(), so we are certain to have enough space, and\ndon't allocate too much space.\n\nBug: 12394\nChange-Id: Ifa023ce70f7a2697bf151009b035a6e6cf8d5d90\nReviewed-on: https:\/\/code.wireshark.org\/review\/15169\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n---\n wiretap\/toshiba.c | 22 ++++++++++++++--------\n 1 file changed, 14 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/wiretap\/toshiba.c b\/wiretap\/toshiba.c\nindex 091eb1e4c1..9a06681189 100644\n--- a\/wiretap\/toshiba.c\n+++ b\/wiretap\/toshiba.c\n@@ -98,11 +98,6 @@ static const char toshiba_hdr_magic[]  =\n static const char toshiba_rec_magic[]  = { '[', 'N', 'o', '.' };\n #define TOSHIBA_REC_MAGIC_SIZE  (sizeof toshiba_rec_magic  \/ sizeof toshiba_rec_magic[0])\n \n-\/*\n- * XXX - is this the biggest packet we can get?\n- *\/\n-#define TOSHIBA_MAX_PACKET_LEN\t16384\n-\n static gboolean toshiba_read(wtap *wth, int *err, gchar **err_info,\n \tgint64 *data_offset);\n static gboolean toshiba_seek_read(wtap *wth, gint64 seek_off,\n@@ -253,7 +248,8 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n \tchar\tline[TOSHIBA_LINE_LENGTH];\n \tint\tnum_items_scanned;\n-\tint\tpkt_len, pktnum, hr, min, sec, csec;\n+\tguint\tpkt_len;\n+\tint\tpktnum, hr, min, sec, csec;\n \tchar\tchannel[10], direction[10];\n \tint\ti, hex_lines;\n \tguint8\t*pd;\n@@ -305,12 +301,22 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \n \t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n \n-\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n+\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n \tif (num_items_scanned != 1) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n \t\treturn FALSE;\n \t}\n+\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n+\t\t\/*\n+\t\t * Probably a corrupt capture file; don't blow up trying\n+\t\t * to allocate space for an immensely-large packet.\n+\t\t *\/\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n+\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n+\t\treturn FALSE;\n+\t}\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n@@ -341,7 +347,7 @@ parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n \t}\n \n \t\/* Make sure we have enough room for the packet *\/\n-\tws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);\n+\tws_buffer_assure_space(buf, pkt_len);\n \tpd = ws_buffer_start_ptr(buf);\n \n \t\/* Calculate the number of hex dump lines, each\n","owner":"wireshark","repo":"wireshark","source":"cve"},{"CVE_ID":"CVE-2016-10397","CWE_ID":"20","category":"security","commit_id":"b061fa909de77085d3822a89ab901b934d0362c4","commit_message":"From b061fa909de77085d3822a89ab901b934d0362c4 Mon Sep 17 00:00:00 2001\nFrom: Nikita Popov <nikic@php.net>\nDate: Sat, 8 Oct 2016 01:04:22 +0200\nSubject: [PATCH] Fix bug #73192\n\n---\n ext\/standard\/tests\/url\/bug73192.phpt            | 30 +++++++++++++++++++++++++\n ext\/standard\/tests\/url\/parse_url_basic_001.phpt | 20 ++---------------\n ext\/standard\/tests\/url\/parse_url_basic_002.phpt |  4 ++--\n ext\/standard\/tests\/url\/parse_url_basic_003.phpt |  4 ++--\n ext\/standard\/tests\/url\/parse_url_basic_004.phpt |  4 ++--\n ext\/standard\/tests\/url\/parse_url_basic_005.phpt |  4 ++--\n ext\/standard\/tests\/url\/parse_url_basic_006.phpt |  4 ++--\n ext\/standard\/tests\/url\/parse_url_basic_007.phpt |  4 ++--\n ext\/standard\/tests\/url\/parse_url_basic_008.phpt |  4 ++--\n ext\/standard\/tests\/url\/parse_url_basic_009.phpt |  4 ++--\n ext\/standard\/url.c                              | 23 +------------------\n 11 files changed, 49 insertions(+), 56 deletions(-)\n create mode 100644 ext\/standard\/tests\/url\/bug73192.phpt\n\n","diff_code":"diff --git a\/ext\/standard\/tests\/url\/bug73192.phpt b\/ext\/standard\/tests\/url\/bug73192.phpt\nnew file mode 100644\nindex 0000000..6ecb477\n--- \/dev\/null\n+++ b\/ext\/standard\/tests\/url\/bug73192.phpt\n@@ -0,0 +1,30 @@\n+--TEST--\n+Bug #73192: parse_url return wrong hostname\n+--FILE--\n+<?php\n+\n+var_dump(parse_url(\"http:\/\/example.com:80#@google.com\/\"));\n+var_dump(parse_url(\"http:\/\/example.com:80?@google.com\/\"));\n+\n+?>\n+--EXPECT--\n+array(4) {\n+  [\"scheme\"]=>\n+  string(4) \"http\"\n+  [\"host\"]=>\n+  string(11) \"example.com\"\n+  [\"port\"]=>\n+  int(80)\n+  [\"fragment\"]=>\n+  string(12) \"@google.com\/\"\n+}\n+array(4) {\n+  [\"scheme\"]=>\n+  string(4) \"http\"\n+  [\"host\"]=>\n+  string(11) \"example.com\"\n+  [\"port\"]=>\n+  int(80)\n+  [\"query\"]=>\n+  string(12) \"@google.com\/\"\n+}\ndiff --git a\/ext\/standard\/tests\/url\/parse_url_basic_001.phpt b\/ext\/standard\/tests\/url\/parse_url_basic_001.phpt\nindex 0708691..e468066 100644\n--- a\/ext\/standard\/tests\/url\/parse_url_basic_001.phpt\n+++ b\/ext\/standard\/tests\/url\/parse_url_basic_001.phpt\n@@ -763,25 +763,9 @@ echo \"Done\";\n   int(6)\n }\n \n---> http:\/\/?:\/: array(3) {\n-  [\"scheme\"]=>\n-  string(4) \"http\"\n-  [\"host\"]=>\n-  string(1) \"?\"\n-  [\"path\"]=>\n-  string(1) \"\/\"\n-}\n+--> http:\/\/?:\/: bool(false)\n \n---> http:\/\/@?:\/: array(4) {\n-  [\"scheme\"]=>\n-  string(4) \"http\"\n-  [\"host\"]=>\n-  string(1) \"?\"\n-  [\"user\"]=>\n-  string(0) \"\"\n-  [\"path\"]=>\n-  string(1) \"\/\"\n-}\n+--> http:\/\/@?:\/: bool(false)\n \n --> file:\/\/\/:: array(2) {\n   [\"scheme\"]=>\ndiff --git a\/ext\/standard\/tests\/url\/parse_url_basic_002.phpt b\/ext\/standard\/tests\/url\/parse_url_basic_002.phpt\nindex c05d1f4..f222ffc 100644\n--- a\/ext\/standard\/tests\/url\/parse_url_basic_002.phpt\n+++ b\/ext\/standard\/tests\/url\/parse_url_basic_002.phpt\n@@ -98,8 +98,8 @@ echo \"Done\";\n --> http:\/\/::?   : string(4) \"http\"\n --> http:\/\/::#   : string(4) \"http\"\n --> x:\/\/::6.5   : string(1) \"x\"\n---> http:\/\/?:\/   : string(4) \"http\"\n---> http:\/\/@?:\/   : string(4) \"http\"\n+--> http:\/\/?:\/   : bool(false)\n+--> http:\/\/@?:\/   : bool(false)\n --> file:\/\/\/:   : string(4) \"file\"\n --> file:\/\/\/a:\/   : string(4) \"file\"\n --> file:\/\/\/ab:\/   : string(4) \"file\"\ndiff --git a\/ext\/standard\/tests\/url\/parse_url_basic_003.phpt b\/ext\/standard\/tests\/url\/parse_url_basic_003.phpt\nindex 88eda50..70dc4bb 100644\n--- a\/ext\/standard\/tests\/url\/parse_url_basic_003.phpt\n+++ b\/ext\/standard\/tests\/url\/parse_url_basic_003.phpt\n@@ -97,8 +97,8 @@ echo \"Done\";\n --> http:\/\/::?   : string(1) \":\"\n --> http:\/\/::#   : string(1) \":\"\n --> x:\/\/::6.5   : string(1) \":\"\n---> http:\/\/?:\/   : string(1) \"?\"\n---> http:\/\/@?:\/   : string(1) \"?\"\n+--> http:\/\/?:\/   : bool(false)\n+--> http:\/\/@?:\/   : bool(false)\n --> file:\/\/\/:   : NULL\n --> file:\/\/\/a:\/   : NULL\n --> file:\/\/\/ab:\/   : NULL\ndiff --git a\/ext\/standard\/tests\/url\/parse_url_basic_004.phpt b\/ext\/standard\/tests\/url\/parse_url_basic_004.phpt\nindex e3b9abd..7ddddaf 100644\n--- a\/ext\/standard\/tests\/url\/parse_url_basic_004.phpt\n+++ b\/ext\/standard\/tests\/url\/parse_url_basic_004.phpt\n@@ -97,8 +97,8 @@ echo \"Done\";\n --> http:\/\/::?   : NULL\n --> http:\/\/::#   : NULL\n --> x:\/\/::6.5   : int(6)\n---> http:\/\/?:\/   : NULL\n---> http:\/\/@?:\/   : NULL\n+--> http:\/\/?:\/   : bool(false)\n+--> http:\/\/@?:\/   : bool(false)\n --> file:\/\/\/:   : NULL\n --> file:\/\/\/a:\/   : NULL\n --> file:\/\/\/ab:\/   : NULL\ndiff --git a\/ext\/standard\/tests\/url\/parse_url_basic_005.phpt b\/ext\/standard\/tests\/url\/parse_url_basic_005.phpt\nindex 5b2cb98..b2ca06f 100644\n--- a\/ext\/standard\/tests\/url\/parse_url_basic_005.phpt\n+++ b\/ext\/standard\/tests\/url\/parse_url_basic_005.phpt\n@@ -97,8 +97,8 @@ echo \"Done\";\n --> http:\/\/::?   : NULL\n --> http:\/\/::#   : NULL\n --> x:\/\/::6.5   : NULL\n---> http:\/\/?:\/   : NULL\n---> http:\/\/@?:\/   : string(0) \"\"\n+--> http:\/\/?:\/   : bool(false)\n+--> http:\/\/@?:\/   : bool(false)\n --> file:\/\/\/:   : NULL\n --> file:\/\/\/a:\/   : NULL\n --> file:\/\/\/ab:\/   : NULL\ndiff --git a\/ext\/standard\/tests\/url\/parse_url_basic_006.phpt b\/ext\/standard\/tests\/url\/parse_url_basic_006.phpt\nindex 79af6b8..f0c251b 100644\n--- a\/ext\/standard\/tests\/url\/parse_url_basic_006.phpt\n+++ b\/ext\/standard\/tests\/url\/parse_url_basic_006.phpt\n@@ -97,8 +97,8 @@ echo \"Done\";\n --> http:\/\/::?   : NULL\n --> http:\/\/::#   : NULL\n --> x:\/\/::6.5   : NULL\n---> http:\/\/?:\/   : NULL\n---> http:\/\/@?:\/   : NULL\n+--> http:\/\/?:\/   : bool(false)\n+--> http:\/\/@?:\/   : bool(false)\n --> file:\/\/\/:   : NULL\n --> file:\/\/\/a:\/   : NULL\n --> file:\/\/\/ab:\/   : NULL\ndiff --git a\/ext\/standard\/tests\/url\/parse_url_basic_007.phpt b\/ext\/standard\/tests\/url\/parse_url_basic_007.phpt\nindex 8e04553..1b362bb 100644\n--- a\/ext\/standard\/tests\/url\/parse_url_basic_007.phpt\n+++ b\/ext\/standard\/tests\/url\/parse_url_basic_007.phpt\n@@ -97,8 +97,8 @@ echo \"Done\";\n --> http:\/\/::?   : NULL\n --> http:\/\/::#   : NULL\n --> x:\/\/::6.5   : NULL\n---> http:\/\/?:\/   : string(1) \"\/\"\n---> http:\/\/@?:\/   : string(1) \"\/\"\n+--> http:\/\/?:\/   : bool(false)\n+--> http:\/\/@?:\/   : bool(false)\n --> file:\/\/\/:   : string(2) \"\/:\"\n --> file:\/\/\/a:\/   : string(3) \"a:\/\"\n --> file:\/\/\/ab:\/   : string(5) \"\/ab:\/\"\ndiff --git a\/ext\/standard\/tests\/url\/parse_url_basic_008.phpt b\/ext\/standard\/tests\/url\/parse_url_basic_008.phpt\nindex 0c77221..1271f38 100644\n--- a\/ext\/standard\/tests\/url\/parse_url_basic_008.phpt\n+++ b\/ext\/standard\/tests\/url\/parse_url_basic_008.phpt\n@@ -97,8 +97,8 @@ echo \"Done\";\n --> http:\/\/::?   : NULL\n --> http:\/\/::#   : NULL\n --> x:\/\/::6.5   : NULL\n---> http:\/\/?:\/   : NULL\n---> http:\/\/@?:\/   : NULL\n+--> http:\/\/?:\/   : bool(false)\n+--> http:\/\/@?:\/   : bool(false)\n --> file:\/\/\/:   : NULL\n --> file:\/\/\/a:\/   : NULL\n --> file:\/\/\/ab:\/   : NULL\ndiff --git a\/ext\/standard\/tests\/url\/parse_url_basic_009.phpt b\/ext\/standard\/tests\/url\/parse_url_basic_009.phpt\nindex 487b271..72f172a 100644\n--- a\/ext\/standard\/tests\/url\/parse_url_basic_009.phpt\n+++ b\/ext\/standard\/tests\/url\/parse_url_basic_009.phpt\n@@ -97,8 +97,8 @@ echo \"Done\";\n --> http:\/\/::?   : NULL\n --> http:\/\/::#   : NULL\n --> x:\/\/::6.5   : NULL\n---> http:\/\/?:\/   : NULL\n---> http:\/\/@?:\/   : NULL\n+--> http:\/\/?:\/   : bool(false)\n+--> http:\/\/@?:\/   : bool(false)\n --> file:\/\/\/:   : NULL\n --> file:\/\/\/a:\/   : NULL\n --> file:\/\/\/ab:\/   : NULL\ndiff --git a\/ext\/standard\/url.c b\/ext\/standard\/url.c\nindex dd861a5..9627184 100644\n--- a\/ext\/standard\/url.c\n+++ b\/ext\/standard\/url.c\n@@ -217,28 +217,7 @@ PHPAPI php_url *php_url_parse_ex(char const *str, int length)\n \t\tgoto nohost;\n \t}\n \n-\te = ue;\n-\n-\tif (!(p = memchr(s, '\/', (ue - s)))) {\n-\t\tchar *query, *fragment;\n-\n-\t\tquery = memchr(s, '?', (ue - s));\n-\t\tfragment = memchr(s, '#', (ue - s));\n-\n-\t\tif (query && fragment) {\n-\t\t\tif (query > fragment) {\n-\t\t\t\te = fragment;\n-\t\t\t} else {\n-\t\t\t\te = query;\n-\t\t\t}\n-\t\t} else if (query) {\n-\t\t\te = query;\n-\t\t} else if (fragment) {\n-\t\t\te = fragment;\n-\t\t}\n-\t} else {\n-\t\te = p;\n-\t}\n+\te = s + strcspn(s, \"\/?#\");\n \n \t\/* check for login and password *\/\n \tif ((p = zend_memrchr(s, '@', (e-s)))) {\n-- \n2.1.4\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2015-8218","CWE_ID":"20","category":"security","commit_id":"d4a731b84a08f0f3839eaaaf82e97d8d9c67da46","commit_message":"From d4a731b84a08f0f3839eaaaf82e97d8d9c67da46 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michael@niedermayer.cc>\nDate: Thu, 5 Nov 2015 21:35:23 +0100\nSubject: [PATCH] avcodec\/faxcompr: Add missing runs check in\n decode_uncompressed()\n\nFixes out of array access\nFixes: 54e488b9da4abbceaf405d6492515697\/asan_heap-oob_32769b0_160_a8755eb08ee8f9579348501945a33955.TIF\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n---\n libavcodec\/faxcompr.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/faxcompr.c b\/libavcodec\/faxcompr.c\nindex 80df418a29..2a1d2bc3f6 100644\n--- a\/libavcodec\/faxcompr.c\n+++ b\/libavcodec\/faxcompr.c\n@@ -189,6 +189,10 @@ static int decode_uncompressed(AVCodecContext *avctx, GetBitContext *gb,\n     *mode = !*mode;\n     if (newmode != *mode) { \/\/FIXME CHECK\n         *(*runs)++ = 0;\n+        if (*runs >= runend) {\n+            av_log(avctx, AV_LOG_ERROR, \"uncompressed run overrun\\n\");\n+            return AVERROR_INVALIDDATA;\n+        }\n         *mode = newmode;\n     }\n     return 0;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-5357","CWE_ID":"20","category":"security","commit_id":"11edc83b98a61e890d7bb01855389d40e984ea82","commit_message":"From 11edc83b98a61e890d7bb01855389d40e984ea82 Mon Sep 17 00:00:00 2001\nFrom: Guy Harris <guy@alum.mit.edu>\nDate: Sun, 1 May 2016 16:13:31 -0700\nSubject: [PATCH] Don't treat the packet length as unsigned.\n\nThe scanf family of functions are as annoyingly bad at handling unsigned\nnumbers as strtoul() is - both of them are perfectly willing to accept a\nvalue beginning with a negative sign as an unsigned value.  When using\nstrtoul(), you can compensate for this by explicitly checking for a '-'\nas the first character of the string, but you can't do that with\nsscanf().\n\nSo revert to having pkt_len be signed, and scanning it with %d, but\ncheck for a negative value and fail if we see a negative value.\n\nBug: 12396\nChange-Id: I54fe8f61f42c32b5ef33da633ece51bbcda8c95f\nReviewed-on: https:\/\/code.wireshark.org\/review\/15220\nReviewed-by: Guy Harris <guy@alum.mit.edu>\n---\n wiretap\/netscreen.c | 11 ++++++++---\n 1 file changed, 8 insertions(+), 3 deletions(-)\n\n","diff_code":"diff --git a\/wiretap\/netscreen.c b\/wiretap\/netscreen.c\nindex e10b1d9fe3..d0ed5c732b 100644\n--- a\/wiretap\/netscreen.c\n+++ b\/wiretap\/netscreen.c\n@@ -263,28 +263,33 @@ static gboolean\n parse_netscreen_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer* buf,\n     char *line, int *err, gchar **err_info)\n {\n+\tint\t\tpkt_len;\n \tint\t\tsec;\n \tint\t\tdsec;\n \tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n \tchar\t\tdirection[2];\n-\tguint\t\tpkt_len;\n \tchar\t\tcap_src[13];\n \tchar\t\tcap_dst[13];\n \tguint8\t\t*pd;\n \tgchar\t\t*p;\n \tint\t\tn, i = 0;\n-\tguint\t\toffset = 0;\n+\tint\t\toffset = 0;\n \tgchar\t\tdststr[13];\n \n \tphdr->rec_type = REC_TYPE_PACKET;\n \tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n \n-\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9\/:.-](%1[io]) len=%9u:%12s->%12s\/\",\n+\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9\/:.-](%1[io]) len=%9d:%12s->%12s\/\",\n \t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n \t\t*err = WTAP_ERR_BAD_FILE;\n \t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n \t\treturn -1;\n \t}\n+\tif (pkt_len < 0) {\n+\t\t*err = WTAP_ERR_BAD_FILE;\n+\t\t*err_info = g_strdup(\"netscreen: packet header has a negative packet length\");\n+\t\treturn FALSE;\n+\t}\n \tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n \t\t\/*\n \t\t * Probably a corrupt capture file; don't blow up trying\n","owner":"wireshark","repo":"wireshark","source":"cve"},{"CVE_ID":"CVE-2015-7551","CWE_ID":"20","category":"security","commit_id":"339e11a7f178312d937b7c95dd3115ce7236597a","commit_message":"From 339e11a7f178312d937b7c95dd3115ce7236597a Mon Sep 17 00:00:00 2001\nFrom: usa <usa@b2dd03c8-39d4-4d8f-98ff-823fe69b080e>\nDate: Wed, 16 Dec 2015 12:15:26 +0000\nSubject: [PATCH] merge revision(s): 53153 and 23405@ruby_1_9_1\n\n\t* ext\/fiddle\/handle.c: check tainted string arguments.\n\t  Patch provided by tenderlove and nobu.\n\n\t* test\/fiddle\/test_handle.rb (class TestHandle): add test for above.\n\n\t* ext\/dl\/handle.c (rb_dlhandle_initialize): prohibits DL::dlopen\n\t  with a tainted name of library.\n\t  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.\n\n\t* ext\/dl\/handle.c (rb_dlhandle_sym): ditto\n\n\n\ngit-svn-id: svn+ssh:\/\/ci.ruby-lang.org\/ruby\/branches\/ruby_2_1@53156 b2dd03c8-39d4-4d8f-98ff-823fe69b080e\n---\n ChangeLog                  | 15 +++++++++++++++\n ext\/fiddle\/handle.c        | 17 ++++++++++-------\n test\/fiddle\/test_handle.rb | 17 +++++++++++++++++\n version.h                  |  2 +-\n 4 files changed, 43 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex df20a42e1d4f..97e7eb32d89f 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,3 +1,18 @@\n+Wed Dec 16 21:10:03 2015  CHIKANAGA Tomoyuki  <nagachika@ruby-lang.org>\n+\n+\t* ext\/fiddle\/handle.c: check tainted string arguments.\n+\t  Patch provided by tenderlove and nobu.\n+\n+\t* test\/fiddle\/test_handle.rb (class TestHandle): add test for above.\n+\n+Wed Dec 16 21:10:36 2015  Yuki Sonoda (Yugui)  <yugui@yugui.jp>\n+\n+\t* ext\/dl\/handle.c (rb_dlhandle_initialize): prohibits DL::dlopen\n+\t  with a tainted name of library.\n+\t  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.\n+\n+\t* ext\/dl\/handle.c (rb_dlhandle_sym): ditto\n+\n Wed Dec 16 16:13:04 2015  Nobuyoshi Nakada  <nobu@ruby-lang.org>\n \n \t* io.c (parse_mode_enc): fix buffer overflow.\ndiff --git a\/ext\/fiddle\/handle.c b\/ext\/fiddle\/handle.c\nindex 36970a224867..fa207ef159f7 100644\n--- a\/ext\/fiddle\/handle.c\n+++ b\/ext\/fiddle\/handle.c\n@@ -1,6 +1,8 @@\n #include <ruby.h>\n #include <fiddle.h>\n \n+#define SafeStringValueCStr(v) (rb_check_safe_obj(rb_string_value(&v)), StringValueCStr(v))\n+\n VALUE rb_cHandle;\n \n struct dl_handle {\n@@ -143,11 +145,11 @@ rb_fiddle_handle_initialize(int argc, VALUE argv[], VALUE self)\n \tcflag = RTLD_LAZY | RTLD_GLOBAL;\n \tbreak;\n       case 1:\n-\tclib = NIL_P(lib) ? NULL : StringValuePtr(lib);\n+\tclib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);\n \tcflag = RTLD_LAZY | RTLD_GLOBAL;\n \tbreak;\n       case 2:\n-\tclib = NIL_P(lib) ? NULL : StringValuePtr(lib);\n+\tclib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);\n \tcflag = NUM2INT(flag);\n \tbreak;\n       default:\n@@ -263,7 +265,7 @@ rb_fiddle_handle_to_i(VALUE self)\n     return PTR2NUM(fiddle_handle);\n }\n \n-static VALUE fiddle_handle_sym(void *handle, const char *symbol);\n+static VALUE fiddle_handle_sym(void *handle, VALUE symbol);\n \n \/*\n  * Document-method: sym\n@@ -282,7 +284,7 @@ rb_fiddle_handle_sym(VALUE self, VALUE sym)\n \trb_raise(rb_eFiddleError, \"closed handle\");\n     }\n \n-    return fiddle_handle_sym(fiddle_handle->ptr, StringValueCStr(sym));\n+    return fiddle_handle_sym(fiddle_handle->ptr, sym);\n }\n \n #ifndef RTLD_NEXT\n@@ -305,11 +307,11 @@ rb_fiddle_handle_sym(VALUE self, VALUE sym)\n static VALUE\n rb_fiddle_handle_s_sym(VALUE self, VALUE sym)\n {\n-    return fiddle_handle_sym(RTLD_NEXT, StringValueCStr(sym));\n+    return fiddle_handle_sym(RTLD_NEXT, sym);\n }\n \n static VALUE\n-fiddle_handle_sym(void *handle, const char *name)\n+fiddle_handle_sym(void *handle, VALUE symbol)\n {\n #if defined(HAVE_DLERROR)\n     const char *err;\n@@ -318,6 +320,7 @@ fiddle_handle_sym(void *handle, const char *name)\n # define CHECK_DLERROR\n #endif\n     void (*func)();\n+    const char *name = SafeStringValueCStr(symbol);\n \n     rb_secure(2);\n #ifdef HAVE_DLERROR\n@@ -367,7 +370,7 @@ fiddle_handle_sym(void *handle, const char *name)\n     }\n #endif\n     if( !func ){\n-\trb_raise(rb_eFiddleError, \"unknown symbol \\\"%s\\\"\", name);\n+\trb_raise(rb_eFiddleError, \"unknown symbol \\\"%\"PRIsVALUE\"\\\"\", symbol);\n     }\n \n     return PTR2NUM(func);\ndiff --git a\/test\/fiddle\/test_handle.rb b\/test\/fiddle\/test_handle.rb\nindex 2007a191b6b8..8d7589e44ce9 100644\n--- a\/test\/fiddle\/test_handle.rb\n+++ b\/test\/fiddle\/test_handle.rb\n@@ -10,6 +10,23 @@ class TestHandle < TestCase\n \n     include Test::Unit::Assertions\n \n+    def test_safe_handle_open\n+      t = Thread.new do\n+        $SAFE = 1\n+        Fiddle::Handle.new(LIBC_SO.taint)\n+      end\n+      assert_raise(SecurityError) { t.value }\n+    end\n+\n+    def test_safe_function_lookup\n+      t = Thread.new do\n+        h = Fiddle::Handle.new(LIBC_SO)\n+        $SAFE = 1\n+        h[\"qsort\".taint]\n+      end\n+      assert_raise(SecurityError) { t.value }\n+    end\n+\n     def test_to_i\n       handle = Fiddle::Handle.new(LIBC_SO)\n       assert_kind_of Integer, handle.to_i\ndiff --git a\/version.h b\/version.h\nindex f25921ec9fec..31d15f8832c8 100644\n--- a\/version.h\n+++ b\/version.h\n@@ -1,6 +1,6 @@\n #define RUBY_VERSION \"2.1.8\"\n #define RUBY_RELEASE_DATE \"2015-12-16\"\n-#define RUBY_PATCHLEVEL 438\n+#define RUBY_PATCHLEVEL 439\n \n #define RUBY_RELEASE_YEAR 2015\n #define RUBY_RELEASE_MONTH 12\n","owner":"ruby","repo":"ruby","source":"cve"},{"CVE_ID":"CVE-2014-4503","CWE_ID":"20","category":"security","commit_id":"910c36089940e81fb85c65b8e63dcd2fac71470c","commit_message":"From 910c36089940e81fb85c65b8e63dcd2fac71470c Mon Sep 17 00:00:00 2001\nFrom: Noel Maersk <veox@wemakethings.net>\nDate: Thu, 5 Jun 2014 23:02:02 +0300\nSubject: [PATCH] stratum: parse_notify(): Don't die on malformed\n bbversion\/prev_hash\/nbit\/ntime.\n\nMight have introduced a memory leak, don't have time to check. :(\n\nShould the other hex2bin()'s be checked?\n\nThanks to Mick Ayzenberg <mick.dejavusecurity.com> for finding this.\n---\n util.c | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/util.c b\/util.c\nindex 941545183..b3d2f0b30 100644\n--- a\/util.c\n+++ b\/util.c\n@@ -1600,17 +1600,23 @@ static bool parse_notify(struct pool *pool, json_t *val)\n \t\tpool->swork.nbit,\n \t\t\"00000000\", \/* nonce *\/\n \t\tworkpadding);\n-\tif (unlikely(!hex2bin(pool->header_bin, header, 128)))\n-\t\tquit(1, \"Failed to convert header to header_bin in parse_notify\");\n+\tif (unlikely(!hex2bin(pool->header_bin, header, 128))) {\n+\t\tapplog(LOG_WARNING, \"%s: Failed to convert header to header_bin, got %s\", __func__, header);\n+\t\tpool_failed(pool);\n+\t\t\/\/ TODO: memory leaks? goto out, clean up there?\n+\t\treturn false;\n+\t}\n \n \tcb1 = (unsigned char *)calloc(cb1_len, 1);\n \tif (unlikely(!cb1))\n \t\tquithere(1, \"Failed to calloc cb1 in parse_notify\");\n \thex2bin(cb1, coinbase1, cb1_len);\n+\n \tcb2 = (unsigned char *)calloc(cb2_len, 1);\n \tif (unlikely(!cb2))\n \t\tquithere(1, \"Failed to calloc cb2 in parse_notify\");\n \thex2bin(cb2, coinbase2, cb2_len);\n+\n \tfree(pool->coinbase);\n \talign_len(&alloc_len);\n \tpool->coinbase = (unsigned char *)calloc(alloc_len, 1);\n@@ -1618,6 +1624,7 @@ static bool parse_notify(struct pool *pool, json_t *val)\n \t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n \tmemcpy(pool->coinbase, cb1, cb1_len);\n \tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n+\t\/\/ NOTE: gap for nonce2, filled at work generation time\n \tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n \tcg_wunlock(&pool->data_lock);\n \n","owner":"sgminer-dev","repo":"sgminer","source":"cve"},{"CVE_ID":"CVE-2010-2805","CWE_ID":"20","category":"security","commit_id":"45a3c76b547511fa9d97aca34b150a0663257375","commit_message":"From 45a3c76b547511fa9d97aca34b150a0663257375 Mon Sep 17 00:00:00 2001\nFrom: Werner Lemberg <wl@gnu.org>\nDate: Wed, 4 Aug 2010 15:54:55 +0200\nSubject: Fix Savannah bug #30644.\n\n* src\/base\/ftstream.c (FT_Stream_EnterFrame): Fix comparison.\n---\n ChangeLog           | 6 ++++++\n src\/base\/ftstream.c | 2 +-\n 2 files changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex b430b10..66e67a8 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,5 +1,11 @@\n 2010-08-04  Werner Lemberg  <wl@gnu.org>\n \n+\tFix Savannah bug #30644.\n+\n+\t* src\/base\/ftstream.c (FT_Stream_EnterFrame): Fix comparison.\n+\n+2010-08-04  Werner Lemberg  <wl@gnu.org>\n+\n \t`make devel' fails if FT_CONFIG_OPTION_OLD_INTERNALS is set.\n \n \t* devel\/ftoption.h: Synchronize with\ndiff --git a\/src\/base\/ftstream.c b\/src\/base\/ftstream.c\nindex 9b087ac..210aaa4 100644\n--- a\/src\/base\/ftstream.c\n+++ b\/src\/base\/ftstream.c\n@@ -287,7 +287,7 @@\n     {\n       \/* check current and new position *\/\n       if ( stream->pos >= stream->size        ||\n-           stream->pos + count > stream->size )\n+           stream->size - stream->pos < count )\n       {\n         FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                    \" invalid i\/o; pos = 0x%lx, count = %lu, size = 0x%lx\\n\",\n-- \ncgit v1.0-41-gc330\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-4617","CWE_ID":"20","category":"security","commit_id":"11fdfcf82bd8d2b5bc38292a29876e10770f4b0a","commit_message":"From 11fdfcf82bd8d2b5bc38292a29876e10770f4b0a Mon Sep 17 00:00:00 2001\nFrom: Werner Koch <wk@gnupg.org>\nDate: Fri, 20 Jun 2014 10:39:26 +0200\nSubject: [PATCH] gpg: Avoid infinite loop in uncompressing garbled packets.\n\n* g10\/compress.c (do_uncompress): Limit the number of extra FF bytes.\n--\n\nA packet like (a3 01 5b ff) leads to an infinite loop.  Using\n--max-output won't help if it is a partial packet.  This patch\nactually fixes a regression introduced on 1999-05-31 (c34c6769).\nActually it would be sufficient to stuff just one extra 0xff byte.\nGiven that this problem popped up only after 15 years, I feel safer to\nallow for a very few FF bytes.\n\nThanks to Olivier Levillain and Florian Maury for their detailed\nreport.\n---\n g10\/compress.c | 21 ++++++++++++---------\n 1 file changed, 12 insertions(+), 9 deletions(-)\n\n","diff_code":"diff --git a\/g10\/compress.c b\/g10\/compress.c\nindex 2c1617422..07c9e5e9c 100644\n--- a\/g10\/compress.c\n+++ b\/g10\/compress.c\n@@ -131,7 +131,7 @@ init_uncompress( compress_filter_context_t *zfx, z_stream *zs )\n      * PGP uses a windowsize of 13 bits. Using a negative value for\n      * it forces zlib not to expect a zlib header.  This is a\n      * undocumented feature Peter Gutmann told me about.\n-     *    \n+     *\n      * We must use 15 bits for the inflator because CryptoEx uses 15\n      * bits thus the output would get scrambled w\/o error indication\n      * if we would use 13 bits.  For the uncompressing this does not\n@@ -155,7 +155,8 @@ do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n \t       IOBUF a, size_t *ret_len )\n {\n     int zrc;\n-    int rc=0;\n+    int rc = 0;\n+    int leave = 0;\n     size_t n;\n     int nread, count;\n     int refill = !zs->avail_in;\n@@ -178,13 +179,14 @@ do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n \t    if( nread == -1 )\n                 nread = 0;\n \t    n += nread;\n-\t    \/* If we use the undocumented feature to suppress\n-\t     * the zlib header, we have to give inflate an\n-\t     * extra dummy byte to read *\/\n-\t    if( nread < count && zfx->algo == 1 ) {\n-\t\t*(zfx->inbuf + n) = 0xFF; \/* is it really needed ? *\/\n-\t\tzfx->algo1hack = 1;\n+\t    \/* Algo 1 has no zlib header which requires us to to give\n+\t     * inflate an extra dummy byte to read. To be on the safe\n+\t     * side we allow for up to 4 ff bytes.  *\/\n+\t    if( nread < count && zfx->algo == 1 && zfx->algo1hack < 4) {\n+\t\t*(zfx->inbuf + n) = 0xFF;\n+\t\tzfx->algo1hack++;\n \t\tn++;\n+                leave = 1;\n \t    }\n \t    zs->avail_in = n;\n \t}\n@@ -208,7 +210,8 @@ do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n \t    else\n \t\tlog_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n \t}\n-    } while( zs->avail_out && zrc != Z_STREAM_END  && zrc != Z_BUF_ERROR );\n+    } while (zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR\n+             && !leave);\n     *ret_len = zfx->outbufsize - zs->avail_out;\n     if( DBG_FILTER )\n \tlog_debug(\"do_uncompress: returning %u bytes\\n\", (unsigned)*ret_len );\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9907","CWE_ID":"20","category":"security","commit_id":"504ada82b6fa38a30c846c1c29116af7290decb2","commit_message":"From 504ada82b6fa38a30c846c1c29116af7290decb2 Mon Sep 17 00:00:00 2001\nFrom: dirk <dirk@git.imagemagick.org>\nDate: Mon, 29 Dec 2014 19:50:06 +0000\nSubject: [PATCH] Added check for bogus num_images value.\n\n---\n coders\/dds.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/coders\/dds.c b\/coders\/dds.c\nindex 17c9bf0e8e..404a78a939 100644\n--- a\/coders\/dds.c\n+++ b\/coders\/dds.c\n@@ -1836,6 +1836,8 @@ static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n   {\n     if (n != 0)\n       {\n+        if (EOFBlob(image) != MagickFalse)\n+          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n         \/* Start a new image *\/\n         AcquireNextImage(image_info,image);\n         if (GetNextImageInList(image) == (Image *) NULL)\n","owner":"ImageMagick","repo":"ImageMagick","source":"cve"},{"CVE_ID":"CVE-2012-6085","CWE_ID":"20","category":"security","commit_id":"f0b33b6fb8e0586e9584a7a409dcc31263776a67","commit_message":"From f0b33b6fb8e0586e9584a7a409dcc31263776a67 Mon Sep 17 00:00:00 2001\nFrom: Werner Koch <wk@gnupg.org>\nDate: Thu, 20 Dec 2012 09:43:41 +0100\nSubject: [PATCH] gpg: Import only packets which are allowed in a keyblock.\n\n* g10\/import.c (valid_keyblock_packet): New.\n(read_block): Store only valid packets.\n--\n\nA corrupted key, which for example included a mangled public key\nencrypted packet, used to corrupt the keyring.  This change skips all\npackets which are not allowed in a keyblock.\n\nGnuPG-bug-id: 1455\n\n(cherry-picked from commit f795a0d59e197455f8723c300eebf59e09853efa)\n---\n g10\/import.c | 23 ++++++++++++++++++++++-\n 1 file changed, 22 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/g10\/import.c b\/g10\/import.c\nindex bfe02eb16..a57b32e3f 100644\n--- a\/g10\/import.c\n+++ b\/g10\/import.c\n@@ -384,6 +384,27 @@ import_print_stats (void *hd)\n }\n \n \n+\/* Return true if PKTTYPE is valid in a keyblock.  *\/\n+static int\n+valid_keyblock_packet (int pkttype)\n+{\n+  switch (pkttype)\n+    {\n+    case PKT_PUBLIC_KEY:\n+    case PKT_PUBLIC_SUBKEY:\n+    case PKT_SECRET_KEY:\n+    case PKT_SECRET_SUBKEY:\n+    case PKT_SIGNATURE:\n+    case PKT_USER_ID:\n+    case PKT_ATTRIBUTE:\n+    case PKT_RING_TRUST:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+\n \/****************\n  * Read the next keyblock from stream A.\n  * PENDING_PKT should be initialzed to NULL\n@@ -461,7 +482,7 @@ read_block( IOBUF a, PACKET **pending_pkt, KBNODE *ret_root )\n \t    }\n \t    in_cert = 1;\n \t  default:\n-\t    if( in_cert ) {\n+\t    if (in_cert && valid_keyblock_packet (pkt->pkttype)) {\n \t\tif( !root )\n \t\t    root = new_kbnode( pkt );\n \t\telse\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2012-5534","CWE_ID":"20","category":"security","commit_id":"efb795c74fe954b9544074aafcebb1be4452b03a","commit_message":"From: Sebastien Helleu <flashcode@flashtux.org>\nDate: Sun, 18 Nov 2012 09:38:30 +0000 (+0100)\nSubject: core: do not call shell to execute command in hook_process (fix security problem... \nX-Git-Tag: v0.4.0-rc1~76\nX-Git-Url: http:\/\/git.savannah.gnu.org\/gitweb\/?p=weechat.git;a=commitdiff_plain;h=efb795c74fe954b9544074aafcebb1be4452b03a\n\ncore: do not call shell to execute command in hook_process (fix security problem when a plugin\/script gives untrusted command) (bug #37764)\n---\n\n","diff_code":"diff --git a\/ChangeLog b\/ChangeLog\nindex 0c6b2ff..2be112f 100644\n--- a\/ChangeLog\n+++ b\/ChangeLog\n@@ -1,12 +1,14 @@\n WeeChat ChangeLog\n =================\n S\u00c3\u00a9bastien Helleu <flashcode@flashtux.org>\n-v0.4.0-dev, 2012-11-14\n+v0.4.0-dev, 2012-11-18\n \n \n Version 0.4.0 (under dev!)\n --------------------------\n \n+* core: do not call shell to execute command in hook_process (fix security\n+  problem when a plugin\/script gives untrusted command) (bug #37764)\n * core: stop cmake if gcrypt lib is not found (bug #37671)\n * core: add incomplete mouse events \"event-down\" and \"event-drag\" (task #11840)\n * core: add command \/eval, use expression in conditions for bars\ndiff --git a\/src\/core\/wee-hook.c b\/src\/core\/wee-hook.c\nindex d2d77da..5e708d0 100644\n--- a\/src\/core\/wee-hook.c\n+++ b\/src\/core\/wee-hook.c\n@@ -1388,9 +1388,9 @@ hook_process (struct t_weechat_plugin *plugin,\n void\n hook_process_child (struct t_hook *hook_process)\n {\n-    char *exec_args[4] = { \"sh\", \"-c\", NULL, NULL };\n+    char **exec_args;\n     const char *ptr_url;\n-    int rc;\n+    int rc, i;\n \n     \/*\n      * close stdin, so that process will fail to read stdin (process reading\n@@ -1429,10 +1429,24 @@ hook_process_child (struct t_hook *hook_process)\n     else\n     {\n         \/* launch command *\/\n-        exec_args[2] = HOOK_PROCESS(hook_process, command);\n-        execvp (exec_args[0], exec_args);\n+        exec_args = string_split_shell (HOOK_PROCESS(hook_process, command));\n+        if (exec_args)\n+        {\n+            if (weechat_debug_core >= 1)\n+            {\n+                log_printf (\"hook_process, command='%s'\",\n+                            HOOK_PROCESS(hook_process, command));\n+                for (i = 0; exec_args[i]; i++)\n+                {\n+                    log_printf (\"  args[%02d] == '%s'\", i, exec_args[i]);\n+                }\n+            }\n+            execvp (exec_args[0], exec_args);\n+        }\n \n         \/* should not be executed if execvp was ok *\/\n+        if (exec_args)\n+            string_free_split (exec_args);\n         fprintf (stderr, \"Error with command '%s'\\n\",\n                  HOOK_PROCESS(hook_process, command));\n         rc = EXIT_FAILURE;\ndiff --git a\/src\/core\/wee-string.c b\/src\/core\/wee-string.c\nindex 269663c..38dde2d 100644\n--- a\/src\/core\/wee-string.c\n+++ b\/src\/core\/wee-string.c\n@@ -1138,6 +1138,196 @@ string_split (const char *string, const char *separators, int keep_eol,\n }\n \n \/*\n+ * string_split_shell: split a string like the shell does for a command with\n+ *                     arguments.\n+ *                     Note: result must be freed with string_free_split.\n+ *                     This function is a C conversion of python class \"shlex\"\n+ *                     (file: Lib\/shlex.py in python repository)\n+ *                     Doc: http:\/\/docs.python.org\/3\/library\/shlex.html\n+ *                     Copyrights in shlex.py:\n+ *                       Module and documentation by Eric S. Raymond, 21 Dec 1998\n+ *                       Input stacking and error message cleanup added by ESR, March 2000\n+ *                       push_source() and pop_source() made explicit by ESR, January 2001.\n+ *                       Posix compliance, split(), string arguments, and\n+ *                       iterator interface by Gustavo Niemeyer, April 2003.\n+ *\/\n+\n+char **\n+string_split_shell (const char *string)\n+{\n+    int temp_len, num_args, add_char_to_temp, add_temp_to_args, quoted;\n+    char *string2, *temp, **args, **args2, state, escapedstate;\n+    char *ptr_string, *ptr_next, saved_char;\n+\n+    if (!string)\n+        return NULL;\n+\n+    string2 = strdup (string);\n+    if (!string2)\n+        return NULL;\n+\n+    \/*\n+     * prepare \"args\" with one pointer to NULL, the \"args\" will be reallocated\n+     * later, each time a new argument is added\n+     *\/\n+    num_args = 0;\n+    args = malloc ((num_args + 1) * sizeof (args[0]));\n+    if (!args)\n+    {\n+        free (string2);\n+        return NULL;\n+    }\n+    args[0] = NULL;\n+\n+    \/* prepare a temp string for working (adding chars one by one) *\/\n+    temp = malloc ((2 * strlen (string)) + 1);\n+    if (!temp)\n+    {\n+        free (string2);\n+        free (args);\n+        return NULL;\n+    }\n+    temp[0] = '\\0';\n+    temp_len = 0;\n+\n+    state = ' ';\n+    escapedstate = ' ';\n+    quoted = 0;\n+    ptr_string = string2;\n+    while (ptr_string[0])\n+    {\n+        add_char_to_temp = 0;\n+        add_temp_to_args = 0;\n+        ptr_next = utf8_next_char (ptr_string);\n+        saved_char = ptr_next[0];\n+        ptr_next[0] = '\\0';\n+        if (state == ' ')\n+        {\n+            if ((ptr_string[0] == ' ') || (ptr_string[0] == '\\t')\n+                || (ptr_string[0] == '\\r') || (ptr_string[0] == '\\n'))\n+            {\n+                if (temp[0] || quoted)\n+                    add_temp_to_args = 1;\n+            }\n+            else if (ptr_string[0] == '\\\\')\n+            {\n+                escapedstate = 'a';\n+                state = ptr_string[0];\n+            }\n+            else if ((ptr_string[0] == '\\'') || (ptr_string[0] == '\"'))\n+            {\n+                state = ptr_string[0];\n+            }\n+            else\n+            {\n+                add_char_to_temp = 1;\n+                state = 'a';\n+            }\n+        }\n+        else if ((state == '\\'') || (state == '\"'))\n+        {\n+            quoted = 1;\n+            if (ptr_string[0] == state)\n+            {\n+                state = 'a';\n+            }\n+            else if ((state == '\"') && (ptr_string[0] == '\\\\'))\n+            {\n+                escapedstate = state;\n+                state = ptr_string[0];\n+            }\n+            else\n+            {\n+                add_char_to_temp = 1;\n+            }\n+        }\n+        else if (state == '\\\\')\n+        {\n+            if (((escapedstate == '\\'') || (escapedstate == '\"'))\n+                && (ptr_string[0] != state) && (ptr_string[0] != escapedstate))\n+            {\n+                temp[temp_len] = state;\n+                temp_len++;\n+                temp[temp_len] = '\\0';\n+            }\n+            add_char_to_temp = 1;\n+            state = escapedstate;\n+        }\n+        else if (state == 'a')\n+        {\n+            if ((ptr_string[0] == ' ') || (ptr_string[0] == '\\t')\n+                || (ptr_string[0] == '\\r') || (ptr_string[0] == '\\n'))\n+            {\n+                state = ' ';\n+                if (temp[0] || quoted)\n+                    add_temp_to_args = 1;\n+            }\n+            else if (ptr_string[0] == '\\\\')\n+            {\n+                escapedstate = 'a';\n+                state = ptr_string[0];\n+            }\n+            else if ((ptr_string[0] == '\\'') || (ptr_string[0] == '\"'))\n+            {\n+                state = ptr_string[0];\n+            }\n+            else\n+            {\n+                add_char_to_temp = 1;\n+            }\n+        }\n+        if (add_char_to_temp)\n+        {\n+            memcpy (temp + temp_len, ptr_string, ptr_next - ptr_string);\n+            temp_len += (ptr_next - ptr_string);\n+            temp[temp_len] = '\\0';\n+        }\n+        if (add_temp_to_args)\n+        {\n+            num_args++;\n+            args2 = realloc (args, (num_args + 1) * sizeof (args[0]));\n+            if (!args2)\n+            {\n+                free (string2);\n+                free (temp);\n+                return args;\n+            }\n+            args = args2;\n+            args[num_args - 1] = strdup (temp);\n+            args[num_args] = NULL;\n+            temp[0] = '\\0';\n+            temp_len = 0;\n+            escapedstate = ' ';\n+            quoted = 0;\n+        }\n+        ptr_next[0] = saved_char;\n+        ptr_string = ptr_next;\n+    }\n+\n+    if (temp[0] || (state != ' '))\n+    {\n+        num_args++;\n+        args2 = realloc (args, (num_args + 1) * sizeof (args[0]));\n+        if (!args2)\n+        {\n+            free (string2);\n+            free (temp);\n+            return args;\n+        }\n+        args = args2;\n+        args[num_args - 1] = strdup (temp);\n+        args[num_args] = NULL;\n+        temp[0] = '\\0';\n+        temp_len = 0;\n+    }\n+\n+    free (string2);\n+    free (temp);\n+\n+    return args;\n+}\n+\n+\/*\n  * string_free_split: free a split string\n  *\/\n \ndiff --git a\/src\/core\/wee-string.h b\/src\/core\/wee-string.h\nindex a9fc76e..c0d017b 100644\n--- a\/src\/core\/wee-string.h\n+++ b\/src\/core\/wee-string.h\n@@ -59,6 +59,7 @@ extern int string_has_highlight_regex_compiled (const char *string,\n extern int string_has_highlight_regex (const char *string, const char *regex);\n extern char **string_split (const char *string, const char *separators,\n                             int keep_eol, int num_items_max, int *num_items);\n+extern char **string_split_shell (const char *string);\n extern void string_free_split (char **split_string);\n extern char *string_build_with_split_string (const char **split_string,\n                                              const char *separator);","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-2287","CWE_ID":"20","category":"security","commit_id":"59839dfff5eabca01cc4e20b45797a60a80af8cb","commit_message":"From 59839dfff5eabca01cc4e20b45797a60a80af8cb Mon Sep 17 00:00:00 2001\nFrom: Marcelo Tosatti <mtosatti@redhat.com>\nDate: Thu, 16 Apr 2009 08:30:44 -0300\nSubject: KVM: x86: check for cr3 validity in ioctl_set_sregs\n\nMatt T. Yourst notes that kvm_arch_vcpu_ioctl_set_sregs lacks validity\nchecking for the new cr3 value:\n\n\"Userspace callers of KVM_SET_SREGS can pass a bogus value of cr3 to\nthe kernel. This will trigger a NULL pointer access in gfn_to_rmap()\nwhen userspace next tries to call KVM_RUN on the affected VCPU and kvm\nattempts to activate the new non-existent page table root.\n\nThis happens since kvm only validates that cr3 points to a valid guest\nphysical memory page when code *inside* the guest sets cr3. However, kvm\ncurrently trusts the userspace caller (e.g. QEMU) on the host machine to\nalways supply a valid page table root, rather than properly validating\nit along with the rest of the reloaded guest state.\"\n\nhttp:\/\/sourceforge.net\/tracker\/?func=detail&atid=893831&aid=2687641&group_id=180599\n\nCheck for a valid cr3 address in kvm_arch_vcpu_ioctl_set_sregs, triple\nfault in case of failure.\n\nCc: stable@kernel.org\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\nSigned-off-by: Avi Kivity <avi@redhat.com>\n---\n arch\/x86\/kvm\/x86.c | 8 +++++++-\n 1 file changed, 7 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/arch\/x86\/kvm\/x86.c b\/arch\/x86\/kvm\/x86.c\nindex ffbb2c818d78..2bad49b535c8 100644\n--- a\/arch\/x86\/kvm\/x86.c\n+++ b\/arch\/x86\/kvm\/x86.c\n@@ -3993,7 +3993,13 @@ int kvm_arch_vcpu_ioctl_set_sregs(struct kvm_vcpu *vcpu,\n \n \tvcpu->arch.cr2 = sregs->cr2;\n \tmmu_reset_needed |= vcpu->arch.cr3 != sregs->cr3;\n-\tvcpu->arch.cr3 = sregs->cr3;\n+\n+\tdown_read(&vcpu->kvm->slots_lock);\n+\tif (gfn_to_memslot(vcpu->kvm, sregs->cr3 >> PAGE_SHIFT))\n+\t\tvcpu->arch.cr3 = sregs->cr3;\n+\telse\n+\t\tset_bit(KVM_REQ_TRIPLE_FAULT, &vcpu->requests);\n+\tup_read(&vcpu->kvm->slots_lock);\n \n \tkvm_set_cr8(vcpu, sregs->cr8);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-6505","CWE_ID":"20","category":"security","commit_id":"95ed56939eb2eaa4e2f349fe6dcd13ca4edfd8fb","commit_message":"From 95ed56939eb2eaa4e2f349fe6dcd13ca4edfd8fb Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Tue, 7 Feb 2017 02:23:33 -0800\nSubject: [PATCH] usb: ohci: limit the number of link eds\n\nThe guest may builds an infinite loop with link eds. This patch\nlimit the number of linked ed to avoid this.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nMessage-id: 5899a02e.45ca240a.6c373.93c1@mx.google.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/usb\/hcd-ohci.c | 9 ++++++++-\n 1 file changed, 8 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/usb\/hcd-ohci.c b\/hw\/usb\/hcd-ohci.c\nindex 2cba3e3..21c93e0 100644\n--- a\/hw\/usb\/hcd-ohci.c\n+++ b\/hw\/usb\/hcd-ohci.c\n@@ -42,6 +42,8 @@\n \n #define OHCI_MAX_PORTS 15\n \n+#define ED_LINK_LIMIT 4\n+\n static int64_t usb_frame_time;\n static int64_t usb_bit_time;\n \n@@ -1184,7 +1186,7 @@ static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n     uint32_t next_ed;\n     uint32_t cur;\n     int active;\n-\n+    uint32_t link_cnt = 0;\n     active = 0;\n \n     if (head == 0)\n@@ -1199,6 +1201,11 @@ static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)\n \n         next_ed = ed.next & OHCI_DPTR_MASK;\n \n+        if (++link_cnt > ED_LINK_LIMIT) {\n+            ohci_die(ohci);\n+            return 0;\n+        }\n+\n         if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {\n             uint32_t addr;\n             \/* Cancel pending packets for ED that have been paused.  *\/\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-5328","CWE_ID":"20","category":"security","commit_id":"fa2755e20ab0c7215d99c2dc7c262e98a09b01df","commit_message":"From fa2755e20ab0c7215d99c2dc7c262e98a09b01df Mon Sep 17 00:00:00 2001\nFrom: Oleg Nesterov <oleg@redhat.com>\nDate: Wed, 26 May 2010 14:44:08 -0700\nSubject: INIT_TASK() should initialize ->thread_group list\n\nThe trivial \/sbin\/init doing\n\n\tint main(void)\n\t{\n\t\tkill(0, SIGKILL)\n\t}\n\ncrashes the kernel.\n\nThis happens because __kill_pgrp_info(init_struct_pid) also sends SIGKILL\nto the swapper process which runs with the uninitialized ->thread_group.\n\nChange INIT_TASK() to initialize ->thread_group properly.\n\nNote: the real problem is that the swapper process must not be visible to\nsignals, see the next patch. But this change is right anyway and fixes\nthe crash.\n\nReported-and-tested-by: Mathias Krause <mathias.krause@secunet.com>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nCc: Cedric Le Goater <clg@fr.ibm.com>\nCc: Dave Hansen <haveblue@us.ibm.com>\nCc: Eric Biederman <ebiederm@xmission.com>\nCc: Herbert Poetzl <herbert@13thfloor.at>\nCc: Mathias Krause <Mathias.Krause@secunet.com>\nAcked-by: Roland McGrath <roland@redhat.com>\nAcked-by: Serge Hallyn <serue@us.ibm.com>\nAcked-by: Sukadev Bhattiprolu <sukadev@us.ibm.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n include\/linux\/init_task.h | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/include\/linux\/init_task.h b\/include\/linux\/init_task.h\nindex 0551e0dcb71b..6deb1ba52fdb 100644\n--- a\/include\/linux\/init_task.h\n+++ b\/include\/linux\/init_task.h\n@@ -163,6 +163,7 @@ extern struct cred init_cred;\n \t\t[PIDTYPE_PGID] = INIT_PID_LINK(PIDTYPE_PGID),\t\t\\\n \t\t[PIDTYPE_SID]  = INIT_PID_LINK(PIDTYPE_SID),\t\t\\\n \t},\t\t\t\t\t\t\t\t\\\n+\t.thread_group\t= LIST_HEAD_INIT(tsk.thread_group),\t\t\\\n \t.dirties = INIT_PROP_LOCAL_SINGLE(dirties),\t\t\t\\\n \tINIT_IDS\t\t\t\t\t\t\t\\\n \tINIT_PERF_EVENTS(tsk)\t\t\t\t\t\t\\\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-2168","CWE_ID":"20","category":"security","commit_id":"954d75b2b64e4799f360d2a6bf9cff6d9fee37e7","commit_message":"From 954d75b2b64e4799f360d2a6bf9cff6d9fee37e7 Mon Sep 17 00:00:00 2001\nFrom: Simon McVittie <simon.mcvittie@collabora.co.uk>\nDate: Mon, 10 Jun 2013 18:06:47 +0100\nSubject: CVE-2013-2168: _dbus_printf_string_upper_bound: copy the va_list for\n each use\n\nUsing a va_list more than once is non-portable: it happens to work\nunder the ABI of (for instance) x86 Linux, but not x86-64 Linux.\n\nThis led to _dbus_printf_string_upper_bound() crashing if it should\nhave returned exactly 1024 bytes. Many system services can be induced\nto process a caller-controlled string in ways that\nend up using _dbus_printf_string_upper_bound(), so this is a denial of\nservice.\n\nReviewed-by: Thiago Macieira <thiago@kde.org>\n---\n dbus\/dbus-sysdeps-unix.c | 16 +++++++++++++---\n dbus\/dbus-sysdeps-win.c  |  9 +++++++--\n 2 files changed, 20 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/dbus\/dbus-sysdeps-unix.c b\/dbus\/dbus-sysdeps-unix.c\nindex fc67799..e31c735 100644\n--- a\/dbus\/dbus-sysdeps-unix.c\n+++ b\/dbus\/dbus-sysdeps-unix.c\n@@ -3121,8 +3121,11 @@ _dbus_printf_string_upper_bound (const char *format,\n   char static_buf[1024];\n   int bufsize = sizeof (static_buf);\n   int len;\n+  va_list args_copy;\n \n-  len = vsnprintf (static_buf, bufsize, format, args);\n+  DBUS_VA_COPY (args_copy, args);\n+  len = vsnprintf (static_buf, bufsize, format, args_copy);\n+  va_end (args_copy);\n \n   \/* If vsnprintf() returned non-negative, then either the string fits in\n    * static_buf, or this OS has the POSIX and C99 behaviour where vsnprintf\n@@ -3138,8 +3141,12 @@ _dbus_printf_string_upper_bound (const char *format,\n        * or the real length could be coincidentally the same. Which is it?\n        * If vsnprintf returns the truncated length, we'll go to the slow\n        * path. *\/\n-      if (vsnprintf (static_buf, 1, format, args) == 1)\n+      DBUS_VA_COPY (args_copy, args);\n+\n+      if (vsnprintf (static_buf, 1, format, args_copy) == 1)\n         len = -1;\n+\n+      va_end (args_copy);\n     }\n \n   \/* If vsnprintf() returned negative, we have to do more work.\n@@ -3155,7 +3162,10 @@ _dbus_printf_string_upper_bound (const char *format,\n       if (buf == NULL)\n         return -1;\n \n-      len = vsnprintf (buf, bufsize, format, args);\n+      DBUS_VA_COPY (args_copy, args);\n+      len = vsnprintf (buf, bufsize, format, args_copy);\n+      va_end (args_copy);\n+\n       dbus_free (buf);\n \n       \/* If the reported length is exactly the buffer size, round up to the\ndiff --git a\/dbus\/dbus-sysdeps-win.c b\/dbus\/dbus-sysdeps-win.c\nindex bc4951b..c42316f 100644\n--- a\/dbus\/dbus-sysdeps-win.c\n+++ b\/dbus\/dbus-sysdeps-win.c\n@@ -538,9 +538,12 @@ int _dbus_printf_string_upper_bound (const char *format,\n   char buf[1024];\n   int bufsize;\n   int len;\n+  va_list args_copy;\n \n   bufsize = sizeof (buf);\n-  len = _vsnprintf (buf, bufsize - 1, format, args);\n+  DBUS_VA_COPY (args_copy, args);\n+  len = _vsnprintf (buf, bufsize - 1, format, args_copy);\n+  va_end (args_copy);\n \n   while (len == -1) \/* try again *\/\n     {\n@@ -553,7 +556,9 @@ int _dbus_printf_string_upper_bound (const char *format,\n       if (p == NULL)\n         return -1;\n \n-      len = _vsnprintf (p, bufsize - 1, format, args);\n+      DBUS_VA_COPY (args_copy, args);\n+      len = _vsnprintf (p, bufsize - 1, format, args_copy);\n+      va_end (args_copy);\n       free (p);\n     }\n \n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-2097","CWE_ID":"20","category":"security","commit_id":"f58eab151214d2d35ff0973f2b3e51c5eb372da4","commit_message":"From f58eab151214d2d35ff0973f2b3e51c5eb372da4 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 31 Jan 2014 19:16:02 +0100\nSubject: [PATCH] avcodec\/takdec: always check bits_per_raw_sample\n\nFixes out of array access\nFixes: asan_heap-oob_19c7a94_6470_cov_1453611734_luckynight-partial.tak\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/takdec.c | 8 +++-----\n 1 file changed, 3 insertions(+), 5 deletions(-)\n\n","diff_code":"diff --git a\/libavcodec\/takdec.c b\/libavcodec\/takdec.c\nindex fcbe10ad3c..86ca3ac013 100644\n--- a\/libavcodec\/takdec.c\n+++ b\/libavcodec\/takdec.c\n@@ -721,11 +721,9 @@ static int tak_decode_frame(AVCodecContext *avctx, void *data,\n         return AVERROR_INVALIDDATA;\n     }\n \n-    if (s->ti.bps != avctx->bits_per_raw_sample) {\n-        avctx->bits_per_raw_sample = s->ti.bps;\n-        if ((ret = set_bps_params(avctx)) < 0)\n-            return ret;\n-    }\n+    avctx->bits_per_raw_sample = s->ti.bps;\n+    if ((ret = set_bps_params(avctx)) < 0)\n+        return ret;\n     if (s->ti.sample_rate != avctx->sample_rate) {\n         avctx->sample_rate = s->ti.sample_rate;\n         set_sample_rate_params(avctx);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-3627","CWE_ID":"20","category":"security","commit_id":"b9aae1e43eb2c8e989510187cff0ba3e996f9a4c","commit_message":"From b9aae1e43eb2c8e989510187cff0ba3e996f9a4c Mon Sep 17 00:00:00 2001\nFrom: Gisle Aas <gisle@aas.no>\nDate: Thu, 22 Oct 2009 21:45:54 +0200\nSubject: [PATCH] decode_entities confused by trailing incomplete entity\n\nMark Martinec reported crashed when running SpamAssassin, given a\nparticular HTML junk mail to parse.  The problem was caused by\nHTML::Parsers decode_entities function confusing itself when it\nencountered strings with incomplete entities at the end of the string.\n---\n t\/entities.t |  4 +++-\n util.c       | 12 ++++++------\n 2 files changed, 9 insertions(+), 7 deletions(-)\n\n","diff_code":"diff --git a\/t\/entities.t b\/t\/entities.t\nindex 7f6a29a..e96501c 100644\n--- a\/t\/entities.t\n+++ b\/t\/entities.t\n@@ -1,6 +1,6 @@\n use HTML::Entities qw(decode_entities encode_entities encode_entities_numeric);\n \n-use Test::More tests => 16;\n+use Test::More tests => 17;\n \n $a = \"V&aring;re norske tegn b&oslash;r &#230res\";\n \n@@ -71,6 +71,8 @@ is(decode_entities(\"abc&def&ghi&abc;&def;\"), \"abc&def&ghi&abc;&def;\");\n is(decode_entities(\"&apos;\"), \"'\");\n is(encode_entities(\"'\", \"'\"), \"&#39;\");\n \n+is(decode_entities(\"Attention Home&#959&#969n&#1257rs...1&#1109t T&#1110&#1084e E&#957&#1257&#1075\"),\n+  \"Attention Home\\x{3BF}\\x{3C9}n\\x{4E9}rs...1\\x{455}t T\\x{456}\\x{43C}e E\\x{3BD}\\x{4E9}\\x{433}\");\n \n __END__\n # Quoted from rfc1866.txt\ndiff --git a\/util.c b\/util.c\nindex 28fec78..6f56a2b 100644\n--- a\/util.c\n+++ b\/util.c\n@@ -94,14 +94,14 @@ decode_entities(pTHX_ SV* sv, HV* entity2char, bool expand_prefix)\n \tent_start = s;\n \trepl = 0;\n \n-\tif (*s == '#') {\n+\tif (s < end && *s == '#') {\n \t    UV num = 0;\n \t    UV prev = 0;\n \t    int ok = 0;\n \t    s++;\n-\t    if (*s == 'x' || *s == 'X') {\n+\t    if (s < end && (*s == 'x' || *s == 'X')) {\n \t\ts++;\n-\t\twhile (*s) {\n+\t\twhile (s < end) {\n \t\t    char *tmp = strchr(PL_hexdigit, *s);\n \t\t    if (!tmp)\n \t\t\tbreak;\n@@ -117,7 +117,7 @@ decode_entities(pTHX_ SV* sv, HV* entity2char, bool expand_prefix)\n \t\t}\n \t    }\n \t    else {\n-\t\twhile (isDIGIT(*s)) {\n+\t\twhile (s < end && isDIGIT(*s)) {\n \t\t    num = num * 10 + (*s - '0');\n \t\t    if (prev && num < prev) {\n \t\t\t\/* overflow *\/\n@@ -180,7 +180,7 @@ decode_entities(pTHX_ SV* sv, HV* entity2char, bool expand_prefix)\n \t}\n \telse {\n \t    char *ent_name = s;\n-\t    while (isALNUM(*s))\n+\t    while (s < end && isALNUM(*s))\n \t\ts++;\n \t    if (ent_name != s && entity2char) {\n \t\tSV** svp;\n@@ -216,7 +216,7 @@ decode_entities(pTHX_ SV* sv, HV* entity2char, bool expand_prefix)\n \n \tif (repl) {\n \t    char *repl_allocated = 0;\n-\t    if (*s == ';')\n+\t    if (s < end && *s == ';')\n \t\ts++;\n \t    t--;  \/* '&' already copied, undo it *\/\n \n","owner":"gisle","repo":"html-parser","source":"cve"},{"CVE_ID":"CVE-2018-1000040","CWE_ID":"20","category":"security","commit_id":"83d4dae44c71816c084a635550acc1a51529b881","commit_message":"From 83d4dae44c71816c084a635550acc1a51529b881 Mon Sep 17 00:00:00 2001\nFrom: Sebastian Rasmussen <sebras@gmail.com>\nDate: Tue, 23 Jan 2018 16:43:59 +0100\nSubject: [PATCH 1\/1] Bug 698904: Upon error both free color converter and\n clear its pointer.\n\nWithout this change future calls to fz_fin_cached_color_converter()\nwill try to dereference the already freed pointer.\n---\n source\/fitz\/colorspace.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/source\/fitz\/colorspace.c b\/source\/fitz\/colorspace.c\nindex c099297..336513f 100644\n--- a\/source\/fitz\/colorspace.c\n+++ b\/source\/fitz\/colorspace.c\n@@ -3663,6 +3663,7 @@ void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_\n \t\tfz_drop_color_converter(ctx, &cached->base);\n \t\tfz_drop_hash_table(ctx, cached->hash);\n \t\tfz_free(ctx, cached);\n+\t\tcc->opaque = NULL;\n \t\tfz_rethrow(ctx);\n \t}\n }\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-9330","CWE_ID":"20","category":"security","commit_id":"26f670a244982335cc08943fb1ec099a2c81e42d","commit_message":"From 26f670a244982335cc08943fb1ec099a2c81e42d Mon Sep 17 00:00:00 2001\nFrom: Li Qiang <liqiang6-s@360.cn>\nDate: Tue, 7 Feb 2017 03:15:03 -0800\nSubject: [PATCH] usb: ohci: fix error return code in servicing iso td\n\nIt should return 1 if an error occurs when reading iso td.\nThis will avoid an infinite loop issue in ohci_service_ed_list.\n\nSigned-off-by: Li Qiang <liqiang6-s@360.cn>\nMessage-id: 5899ac3e.1033240a.944d5.9a2d@mx.google.com\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/usb\/hcd-ohci.c | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/usb\/hcd-ohci.c b\/hw\/usb\/hcd-ohci.c\nindex c82a92f..2cba3e3 100644\n--- a\/hw\/usb\/hcd-ohci.c\n+++ b\/hw\/usb\/hcd-ohci.c\n@@ -725,7 +725,7 @@ static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n     if (ohci_read_iso_td(ohci, addr, &iso_td)) {\n         trace_usb_ohci_iso_td_read_failed(addr);\n         ohci_die(ohci);\n-        return 0;\n+        return 1;\n     }\n \n     starting_frame = OHCI_BM(iso_td.flags, TD_SF);\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-11232","CWE_ID":"20","category":"security","commit_id":"f09444639099584bc4784dfcd85ada67c6f33e0f","commit_message":"From f09444639099584bc4784dfcd85ada67c6f33e0f Mon Sep 17 00:00:00 2001\nFrom: Wang Nan <wangnan0@huawei.com>\nDate: Mon, 23 Jan 2017 10:41:22 -0700\nSubject: [PATCH] coresight: fix kernel panic caused by invalid CPU\n\nCommit d52c9750f150 (\"coresight: reset \"enable_sink\" flag when need be\")\ncaused a kernel panic because of the using of an invalid value: after\n'for_each_cpu(cpu, mask)', value of local variable 'cpu' become invalid,\ncauses following 'cpu_to_node' access invalid memory area.\n\nThis patch brings the deleted 'cpu = cpumask_first(mask)' back.\n\nPanic log:\n\n $ perf record -e cs_etm\/\/ ls\n\n Unable to handle kernel paging request at virtual address fffe801804af4f10\n pgd = ffff8017ce031600\n [fffe801804af4f10] *pgd=0000000000000000, *pud=0000000000000000\n Internal error: Oops: 96000004 [#1] SMP\n Modules linked in:\n CPU: 33 PID: 1619 Comm: perf Not tainted 4.7.1+ #16\n Hardware name: Huawei Taishan 2280 \/CH05TEVBA, BIOS 1.10 11\/24\/2016\n task: ffff8017cb0c8400 ti: ffff8017cb154000 task.ti: ffff8017cb154000\n PC is at tmc_alloc_etf_buffer+0x60\/0xd4\n LR is at tmc_alloc_etf_buffer+0x44\/0xd4\n pc : [<ffff000008633df8>] lr : [<ffff000008633ddc>] pstate: 60000145\n sp : ffff8017cb157b40\n x29: ffff8017cb157b40 x28: 0000000000000000\n ...skip...\n 7a60: ffff000008c64dc8 0000000000000006 0000000000000253 ffffffffffffffff\n 7a80: 0000000000000000 0000000000000000 ffff0000080872cc 0000000000000001\n [<ffff000008633df8>] tmc_alloc_etf_buffer+0x60\/0xd4\n [<ffff000008632b9c>] etm_setup_aux+0x1dc\/0x1e8\n [<ffff00000816eed4>] rb_alloc_aux+0x2b0\/0x338\n [<ffff00000816a5e4>] perf_mmap+0x414\/0x568\n [<ffff0000081ab694>] mmap_region+0x324\/0x544\n [<ffff0000081abbe8>] do_mmap+0x334\/0x3e0\n [<ffff000008191150>] vm_mmap_pgoff+0xa4\/0xc8\n [<ffff0000081a9a30>] SyS_mmap_pgoff+0xb0\/0x22c\n [<ffff0000080872e4>] sys_mmap+0x18\/0x28\n [<ffff0000080843f0>] el0_svc_naked+0x24\/0x28\n Code: 912040a5 d0001c00 f873d821 911c6000 (b8656822)\n ---[ end trace 98933da8f92b0c9a ]---\n\nSigned-off-by: Wang Nan <wangnan0@huawei.com>\nCc: Xia Kaixu <xiakaixu@huawei.com>\nCc: Li Zefan <lizefan@huawei.com>\nCc: Mathieu Poirier <mathieu.poirier@linaro.org>\nCc: linux-arm-kernel@lists.infradead.org\nCc: linux-kernel@vger.kernel.org\nFixes: d52c9750f150 (\"coresight: reset \"enable_sink\" flag when need be\")\nSigned-off-by: Mathieu Poirier <mathieu.poirier@linaro.org>\nCc: stable <stable@vger.kernel.org> # 4.10\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/hwtracing\/coresight\/coresight-etm-perf.c | 1 +\n 1 file changed, 1 insertion(+)\n\n","diff_code":"diff --git a\/drivers\/hwtracing\/coresight\/coresight-etm-perf.c b\/drivers\/hwtracing\/coresight\/coresight-etm-perf.c\nindex 17741969026e0..26cfac3e6de7b 100644\n--- a\/drivers\/hwtracing\/coresight\/coresight-etm-perf.c\n+++ b\/drivers\/hwtracing\/coresight\/coresight-etm-perf.c\n@@ -242,6 +242,7 @@ static void *etm_setup_aux(int event_cpu, void **pages,\n \tif (!sink_ops(sink)->alloc_buffer)\n \t\tgoto err;\n \n+\tcpu = cpumask_first(mask);\n \t\/* Get the AUX specific data from the sink buffer *\/\n \tevent_data->snk_config =\n \t\t\tsink_ops(sink)->alloc_buffer(sink, cpu, pages,\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-9390","CWE_ID":"20","category":"security","commit_id":"ba2b9d000660313af7b692542afbd374c5685865","commit_message":"From ba2b9d000660313af7b692542afbd374c5685865 Mon Sep 17 00:00:00 2001\nFrom: Michael Adams <mdadams@ece.uvic.ca>\nDate: Tue, 25 Oct 2016 16:18:51 -0700\nSubject: [PATCH] Ensure that not all tiles lie outside the image area.\n\n---\n src\/libjasper\/jpc\/jpc_cs.c  | 4 ++++\n src\/libjasper\/jpc\/jpc_dec.c | 1 +\n 2 files changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/src\/libjasper\/jpc\/jpc_cs.c b\/src\/libjasper\/jpc\/jpc_cs.c\nindex 1e0c9af..cf7199e 100644\n--- a\/src\/libjasper\/jpc\/jpc_cs.c\n+++ b\/src\/libjasper\/jpc\/jpc_cs.c\n@@ -508,6 +508,10 @@ static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n \t  !siz->tileheight || !siz->numcomps || siz->numcomps > 16384) {\n \t\treturn -1;\n \t}\n+\tif (siz->tilexoff >= siz->width || siz->tileyoff >= siz->height) {\n+\t\tjas_eprintf(\"all tiles are outside the image area\\n\");\n+\t\treturn -1;\n+\t}\n \tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {\n \t\treturn -1;\n \t}\ndiff --git a\/src\/libjasper\/jpc\/jpc_dec.c b\/src\/libjasper\/jpc\/jpc_dec.c\nindex 2dc3db8..4bddb22 100644\n--- a\/src\/libjasper\/jpc\/jpc_dec.c\n+++ b\/src\/libjasper\/jpc\/jpc_dec.c\n@@ -1216,6 +1216,7 @@ static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n \tdec->tilexoff = siz->tilexoff;\n \tdec->tileyoff = siz->tileyoff;\n \tdec->numcomps = siz->numcomps;\n+\n \tif (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) {\n \t\treturn -1;\n \t}\n","owner":"mdadams","repo":"jasper","source":"cve"},{"CVE_ID":"CVE-2016-6128","CWE_ID":"20","category":"security","commit_id":"1ccfe21e14c4d18336f9da8515cd17db88c3de61","commit_message":"From 1ccfe21e14c4d18336f9da8515cd17db88c3de61 Mon Sep 17 00:00:00 2001\nFrom: Pierre Joye <pierre.php@gmail.com>\nDate: Mon, 27 Jun 2016 11:17:39 +0700\nSubject: [PATCH] fix php 72494, invalid color index not handled, can lead to\n crash\n\n---\n src\/gd_crop.c        | 4 ++++\n tests\/CMakeLists.txt | 1 +\n tests\/Makefile.am    | 1 +\n 3 files changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/src\/gd_crop.c b\/src\/gd_crop.c\nindex 02966336..532b49b3 100644\n--- a\/src\/gd_crop.c\n+++ b\/src\/gd_crop.c\n@@ -136,6 +136,10 @@ BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int c\n \t\treturn NULL;\n \t}\n \n+\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n+\t\treturn NULL;\n+\t}\n+\n \t\/* TODO: Add gdImageGetRowPtr and works with ptr at the row level\n \t * for the true color and palette images\n \t * new formats will simply work with ptr\ndiff --git a\/tests\/CMakeLists.txt b\/tests\/CMakeLists.txt\nindex 6f5c7860..5093d526 100644\n--- a\/tests\/CMakeLists.txt\n+++ b\/tests\/CMakeLists.txt\n@@ -31,6 +31,7 @@ if (BUILD_TEST)\n \t\tgdimagecolortransparent\n \t\tgdimagecopy\n \t\tgdimagecopyrotated\n+        gdimagecrop\n \t\tgdimagefile\n \t\tgdimagefill\n \t\tgdimagefilledellipse\ndiff --git a\/tests\/Makefile.am b\/tests\/Makefile.am\nindex 4f6e7569..5a0ebe81 100644\n--- a\/tests\/Makefile.am\n+++ b\/tests\/Makefile.am\n@@ -25,6 +25,7 @@ include gdimagecolorresolve\/Makemodule.am\n include gdimagecolortransparent\/Makemodule.am\n include gdimagecopy\/Makemodule.am\n include gdimagecopyrotated\/Makemodule.am\n+include gdimagecrop\/Makemodule.am\n include gdimagefile\/Makemodule.am\n include gdimagefill\/Makemodule.am\n include gdimagefilledellipse\/Makemodule.am\n","owner":"libgd","repo":"libgd","source":"cve"},{"CVE_ID":"CVE-2014-4617","CWE_ID":"20","category":"security","commit_id":"014b2103fcb12f261135e3954f26e9e07b39e342","commit_message":"From 014b2103fcb12f261135e3954f26e9e07b39e342 Mon Sep 17 00:00:00 2001\nFrom: Werner Koch <wk@gnupg.org>\nDate: Fri, 20 Jun 2014 10:39:26 +0200\nSubject: [PATCH] gpg: Avoid infinite loop in uncompressing garbled packets.\n\n* g10\/compress.c (do_uncompress): Limit the number of extra FF bytes.\n--\n\nA packet like (a3 01 5b ff) leads to an infinite loop.  Using\n--max-output won't help if it is a partial packet.  This patch\nactually fixes a regression introduced on 1999-05-31 (c34c6769).\nActually it would be sufficient to stuff just one extra 0xff byte.\nGiven that this problem popped up only after 15 years, I feel safer to\nallow for a very few FF bytes.\n\nThanks to Olivier Levillain and Florian Maury for their detailed\nreport.\n---\n g10\/compress.c | 19 +++++++++++--------\n 1 file changed, 11 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/g10\/compress.c b\/g10\/compress.c\nindex a91dd2303..6e151bcfe 100644\n--- a\/g10\/compress.c\n+++ b\/g10\/compress.c\n@@ -161,7 +161,8 @@ do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n \t       IOBUF a, size_t *ret_len )\n {\n     int zrc;\n-    int rc=0;\n+    int rc = 0;\n+    int leave = 0;\n     size_t n;\n     int nread, count;\n     int refill = !zs->avail_in;\n@@ -179,13 +180,14 @@ do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n \t    nread = iobuf_read( a, zfx->inbuf + n, count );\n \t    if( nread == -1 ) nread = 0;\n \t    n += nread;\n-\t    \/* If we use the undocumented feature to suppress\n-\t     * the zlib header, we have to give inflate an\n-\t     * extra dummy byte to read *\/\n-\t    if( nread < count && zfx->algo == 1 ) {\n-\t\t*(zfx->inbuf + n) = 0xFF; \/* is it really needed ? *\/\n-\t\tzfx->algo1hack = 1;\n+\t    \/* Algo 1 has no zlib header which requires us to to give\n+\t     * inflate an extra dummy byte to read. To be on the safe\n+\t     * side we allow for up to 4 ff bytes.  *\/\n+\t    if( nread < count && zfx->algo == 1 && zfx->algo1hack < 4) {\n+\t\t*(zfx->inbuf + n) = 0xFF;\n+\t\tzfx->algo1hack++;\n \t\tn++;\n+                leave = 1;\n \t    }\n \t    zs->avail_in = n;\n \t}\n@@ -205,7 +207,8 @@ do_uncompress( compress_filter_context_t *zfx, z_stream *zs,\n \t    else\n \t\tlog_fatal(\"zlib inflate problem: rc=%d\\n\", zrc );\n \t}\n-    } while( zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR );\n+    } while (zs->avail_out && zrc != Z_STREAM_END && zrc != Z_BUF_ERROR\n+             && !leave);\n \n     *ret_len = zfx->outbufsize - zs->avail_out;\n     if( DBG_FILTER )\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-1336","CWE_ID":"20","category":"security","commit_id":"54af3bb543c071769141387a42deaaab5074da55","commit_message":"From 54af3bb543c071769141387a42deaaab5074da55 Mon Sep 17 00:00:00 2001\nFrom: Trond Myklebust <Trond.Myklebust@netapp.com>\nDate: Fri, 28 Sep 2007 12:27:41 -0400\nSubject: NFS: Fix an Oops in encode_lookup()\n\nIt doesn't look as if the NFS file name limit is being initialised correctly\nin the struct nfs_server. Make sure that we limit whatever is being set in\nnfs_probe_fsinfo() and nfs_init_server().\n\nAlso ensure that readdirplus and nfs4_path_walk respect our file name\nlimits.\n\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/nfs\/client.c  | 29 +++++++++++++++++++----------\n fs\/nfs\/dir.c     |  2 ++\n fs\/nfs\/getroot.c |  3 +++\n 3 files changed, 24 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/fs\/nfs\/client.c b\/fs\/nfs\/client.c\nindex a49f9feff776..a204484072f3 100644\n--- a\/fs\/nfs\/client.c\n+++ b\/fs\/nfs\/client.c\n@@ -588,16 +588,6 @@ static int nfs_init_server(struct nfs_server *server, const struct nfs_mount_dat\n \tserver->namelen  = data->namlen;\n \t\/* Create a client RPC handle for the NFSv3 ACL management interface *\/\n \tnfs_init_server_aclclient(server);\n-\tif (clp->cl_nfsversion == 3) {\n-\t\tif (server->namelen == 0 || server->namelen > NFS3_MAXNAMLEN)\n-\t\t\tserver->namelen = NFS3_MAXNAMLEN;\n-\t\tif (!(data->flags & NFS_MOUNT_NORDIRPLUS))\n-\t\t\tserver->caps |= NFS_CAP_READDIRPLUS;\n-\t} else {\n-\t\tif (server->namelen == 0 || server->namelen > NFS2_MAXNAMLEN)\n-\t\t\tserver->namelen = NFS2_MAXNAMLEN;\n-\t}\n-\n \tdprintk(\"<-- nfs_init_server() = 0 [new %p]\\n\", clp);\n \treturn 0;\n \n@@ -794,6 +784,16 @@ struct nfs_server *nfs_create_server(const struct nfs_mount_data *data,\n \terror = nfs_probe_fsinfo(server, mntfh, &fattr);\n \tif (error < 0)\n \t\tgoto error;\n+\tif (server->nfs_client->rpc_ops->version == 3) {\n+\t\tif (server->namelen == 0 || server->namelen > NFS3_MAXNAMLEN)\n+\t\t\tserver->namelen = NFS3_MAXNAMLEN;\n+\t\tif (!(data->flags & NFS_MOUNT_NORDIRPLUS))\n+\t\t\tserver->caps |= NFS_CAP_READDIRPLUS;\n+\t} else {\n+\t\tif (server->namelen == 0 || server->namelen > NFS2_MAXNAMLEN)\n+\t\t\tserver->namelen = NFS2_MAXNAMLEN;\n+\t}\n+\n \tif (!(fattr.valid & NFS_ATTR_FATTR)) {\n \t\terror = server->nfs_client->rpc_ops->getattr(server, mntfh, &fattr);\n \t\tif (error < 0) {\n@@ -984,6 +984,9 @@ struct nfs_server *nfs4_create_server(const struct nfs4_mount_data *data,\n \tif (error < 0)\n \t\tgoto error;\n \n+\tif (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)\n+\t\tserver->namelen = NFS4_MAXNAMLEN;\n+\n \tBUG_ON(!server->nfs_client);\n \tBUG_ON(!server->nfs_client->rpc_ops);\n \tBUG_ON(!server->nfs_client->rpc_ops->file_inode_ops);\n@@ -1056,6 +1059,9 @@ struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *data,\n \tif (error < 0)\n \t\tgoto error;\n \n+\tif (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)\n+\t\tserver->namelen = NFS4_MAXNAMLEN;\n+\n \tdprintk(\"Referral FSID: %llx:%llx\\n\",\n \t\t(unsigned long long) server->fsid.major,\n \t\t(unsigned long long) server->fsid.minor);\n@@ -1115,6 +1121,9 @@ struct nfs_server *nfs_clone_server(struct nfs_server *source,\n \tif (error < 0)\n \t\tgoto out_free_server;\n \n+\tif (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)\n+\t\tserver->namelen = NFS4_MAXNAMLEN;\n+\n \tdprintk(\"Cloned FSID: %llx:%llx\\n\",\n \t\t(unsigned long long) server->fsid.major,\n \t\t(unsigned long long) server->fsid.minor);\ndiff --git a\/fs\/nfs\/dir.c b\/fs\/nfs\/dir.c\nindex ea97408e423e..e4a04d16b8b0 100644\n--- a\/fs\/nfs\/dir.c\n+++ b\/fs\/nfs\/dir.c\n@@ -1162,6 +1162,8 @@ static struct dentry *nfs_readdir_lookup(nfs_readdir_descriptor_t *desc)\n \t}\n \tif (!desc->plus || !(entry->fattr->valid & NFS_ATTR_FATTR))\n \t\treturn NULL;\n+\tif (name.len > NFS_SERVER(dir)->namelen)\n+\t\treturn NULL;\n \t\/* Note: caller is already holding the dir->i_mutex! *\/\n \tdentry = d_alloc(parent, &name);\n \tif (dentry == NULL)\ndiff --git a\/fs\/nfs\/getroot.c b\/fs\/nfs\/getroot.c\nindex d1cbf0a0fbb2..522e5ad4d8ad 100644\n--- a\/fs\/nfs\/getroot.c\n+++ b\/fs\/nfs\/getroot.c\n@@ -175,6 +175,9 @@ next_component:\n \t\tpath++;\n \tname.len = path - (const char *) name.name;\n \n+\tif (name.len > NFS4_MAXNAMLEN)\n+\t\treturn -ENAMETOOLONG;\n+\n eat_dot_dir:\n \twhile (*path == '\/')\n \t\tpath++;\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1163","CWE_ID":"20","category":"security","commit_id":"1eafbfeb7bdf59cfe173304c76188f3fd5f1fd05","commit_message":"From 1eafbfeb7bdf59cfe173304c76188f3fd5f1fd05 Mon Sep 17 00:00:00 2001\nFrom: Timo Warns <Warns@pre-sense.de>\nDate: Mon, 14 Mar 2011 14:59:33 +0100\nSubject: Fix corrupted OSF partition table parsing\n\nThe kernel automatically evaluates partition tables of storage devices.\nThe code for evaluating OSF partitions contains a bug that leaks data\nfrom kernel heap memory to userspace for certain corrupted OSF\npartitions.\n\nIn more detail:\n\n  for (i = 0 ; i < le16_to_cpu(label->d_npartitions); i++, partition++) {\n\niterates from 0 to d_npartitions - 1, where d_npartitions is read from\nthe partition table without validation and partition is a pointer to an\narray of at most 8 d_partitions.\n\nAdd the proper and obvious validation.\n\nSigned-off-by: Timo Warns <warns@pre-sense.de>\nCc: stable@kernel.org\n[ Changed the patch trivially to not repeat the whole le16_to_cpu()\n  thing, and to use an explicit constant for the magic value '8' ]\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/partitions\/osf.c | 12 ++++++++++--\n 1 file changed, 10 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/fs\/partitions\/osf.c b\/fs\/partitions\/osf.c\nindex 48cec7cbca17..be03a0b08b47 100644\n--- a\/fs\/partitions\/osf.c\n+++ b\/fs\/partitions\/osf.c\n@@ -10,10 +10,13 @@\n #include \"check.h\"\n #include \"osf.h\"\n \n+#define MAX_OSF_PARTITIONS 8\n+\n int osf_partition(struct parsed_partitions *state)\n {\n \tint i;\n \tint slot = 1;\n+\tunsigned int npartitions;\n \tSector sect;\n \tunsigned char *data;\n \tstruct disklabel {\n@@ -45,7 +48,7 @@ int osf_partition(struct parsed_partitions *state)\n \t\t\tu8  p_fstype;\n \t\t\tu8  p_frag;\n \t\t\t__le16 p_cpg;\n-\t\t} d_partitions[8];\n+\t\t} d_partitions[MAX_OSF_PARTITIONS];\n \t} * label;\n \tstruct d_partition * partition;\n \n@@ -63,7 +66,12 @@ int osf_partition(struct parsed_partitions *state)\n \t\tput_dev_sector(sect);\n \t\treturn 0;\n \t}\n-\tfor (i = 0 ; i < le16_to_cpu(label->d_npartitions); i++, partition++) {\n+\tnpartitions = le16_to_cpu(label->d_npartitions);\n+\tif (npartitions > MAX_OSF_PARTITIONS) {\n+\t\tput_dev_sector(sect);\n+\t\treturn 0;\n+\t}\n+\tfor (i = 0 ; i < npartitions; i++, partition++) {\n \t\tif (slot == state->limit)\n \t\t        break;\n \t\tif (le32_to_cpu(partition->p_size))\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-14598","CWE_ID":"20","category":"security","commit_id":"e83722768fd5c467ef61fa159e8c6278770b45c2","commit_message":"From e83722768fd5c467ef61fa159e8c6278770b45c2 Mon Sep 17 00:00:00 2001\nFrom: Tobias Stoeckmann <tobias@stoeckmann.org>\nDate: Fri, 27 Jul 2018 16:38:00 +0200\nSubject: Fixed crash on invalid reply (CVE-2018-14598).\n\nIf the server sends a reply in which even the first string would\noverflow the transmitted bytes, list[0] (or flist[0]) will be set to\nNULL and a count of 0 is returned.\n\nIf the resulting list is freed with XFreeExtensionList or\nXFreeFontPath later on, the first Xfree call:\n\n    Xfree (list[0]-1)\n turns into\n    Xfree (NULL-1)\n\nwhich will most likely trigger a segmentation fault.\n\nI have modified the code to return NULL if the first string would\noverflow, thus protecting the freeing functions later on.\n\nSigned-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>\n---\n src\/GetFPath.c | 5 +++++\n src\/ListExt.c  | 5 +++++\n 2 files changed, 10 insertions(+)\n\n","diff_code":"diff --git a\/src\/GetFPath.c b\/src\/GetFPath.c\nindex 813757c..87d2576 100644\n--- a\/src\/GetFPath.c\n+++ b\/src\/GetFPath.c\n@@ -78,6 +78,11 @@ char **XGetFontPath(\n \t\t    length = *(unsigned char *)ch;\n \t\t    *ch = '\\0'; \/* and replace with null-termination *\/\n \t\t    count++;\n+\t\t} else if (i == 0) {\n+\t\t    Xfree(flist);\n+\t\t    Xfree(ch);\n+\t\t    flist = NULL;\n+\t\t    break;\n \t\t} else\n \t\t    flist[i] = NULL;\n \t    }\ndiff --git a\/src\/ListExt.c b\/src\/ListExt.c\nindex 0498aa1..a795041 100644\n--- a\/src\/ListExt.c\n+++ b\/src\/ListExt.c\n@@ -83,6 +83,11 @@ char **XListExtensions(\n \t\t    length = *(unsigned char *)ch;\n \t\t    *ch = '\\0'; \/* and replace with null-termination *\/\n \t\t    count++;\n+\t\t} else if (i == 0) {\n+\t\t    Xfree(list);\n+\t\t    Xfree(ch);\n+\t\t    list = NULL;\n+\t\t    break;\n \t\t} else\n \t\t    list[i] = NULL;\n \t    }\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1598","CWE_ID":"20","category":"security","commit_id":"c6914a6f261aca0c9f715f883a353ae7ff51fe83","commit_message":"From c6914a6f261aca0c9f715f883a353ae7ff51fe83 Mon Sep 17 00:00:00 2001\nFrom: Dave Jones <davej@redhat.com>\nDate: Tue, 19 Apr 2011 20:36:59 -0700\nSubject: can: Add missing socket check in can\/bcm release.\n\nWe can get here with a NULL socket argument passed from userspace,\nso we need to handle it accordingly.\n\nSigned-off-by: Dave Jones <davej@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n net\/can\/bcm.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/net\/can\/bcm.c b\/net\/can\/bcm.c\nindex 57b1aed79014..8a6a05e7c3c8 100644\n--- a\/net\/can\/bcm.c\n+++ b\/net\/can\/bcm.c\n@@ -1427,9 +1427,14 @@ static int bcm_init(struct sock *sk)\n static int bcm_release(struct socket *sock)\n {\n \tstruct sock *sk = sock->sk;\n-\tstruct bcm_sock *bo = bcm_sk(sk);\n+\tstruct bcm_sock *bo;\n \tstruct bcm_op *op, *next;\n \n+\tif (sk == NULL)\n+\t\treturn 0;\n+\n+\tbo = bcm_sk(sk);\n+\n \t\/* remove bcm_ops, timer, rx_unregister(), etc. *\/\n \n \tunregister_netdevice_notifier(&bo->notifier);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9603","CWE_ID":"20","category":"security","commit_id":"3030fb7e0d41836f8add6399e9a7c7b740b48bfd","commit_message":"From 3030fb7e0d41836f8add6399e9a7c7b740b48bfd Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Tue, 16 Dec 2014 16:24:55 +0100\nSubject: [PATCH] avcodec\/vmdvideo: Check len before using it in method 3\n\nFixes out of array access\nFixes: asan_heap-oob_4d23ba_91_cov_3853393937_128.vmd\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/vmdvideo.c | 3 +++\n 1 file changed, 3 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/vmdvideo.c b\/libavcodec\/vmdvideo.c\nindex fa0fbe32d4..a2ba1c959b 100644\n--- a\/libavcodec\/vmdvideo.c\n+++ b\/libavcodec\/vmdvideo.c\n@@ -339,6 +339,9 @@ static int vmd_decode(VmdVideoContext *s, AVFrame *frame)\n                         ofs += slen;\n                         bytestream2_skip(&gb, len);\n                     } else {\n+                        if (ofs + len > frame_width ||\n+                            bytestream2_get_bytes_left(&gb) < len)\n+                            return AVERROR_INVALIDDATA;\n                         bytestream2_get_buffer(&gb, &dp[ofs], len);\n                         ofs += len;\n                     }\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2011-1012","CWE_ID":"20","category":"security","commit_id":"294f6cf48666825d23c9372ef37631232746e40d","commit_message":"From 294f6cf48666825d23c9372ef37631232746e40d Mon Sep 17 00:00:00 2001\nFrom: Timo Warns <Warns@pre-sense.de>\nDate: Fri, 25 Feb 2011 14:44:21 -0800\nSubject: ldm: corrupted partition table can cause kernel oops\n\nThe kernel automatically evaluates partition tables of storage devices.\nThe code for evaluating LDM partitions (in fs\/partitions\/ldm.c) contains\na bug that causes a kernel oops on certain corrupted LDM partitions.  A\nkernel subsystem seems to crash, because, after the oops, the kernel no\nlonger recognizes newly connected storage devices.\n\nThe patch changes ldm_parse_vmdb() to Validate the value of vblk_size.\n\nSigned-off-by: Timo Warns <warns@pre-sense.de>\nCc: Eugene Teo <eugeneteo@kernel.sg>\nAcked-by: Richard Russon <ldm@flatcap.org>\nCc: Harvey Harrison <harvey.harrison@gmail.com>\nCc: <stable@kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n fs\/partitions\/ldm.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/fs\/partitions\/ldm.c b\/fs\/partitions\/ldm.c\nindex 789c625c7aa5..b10e3540d5b7 100644\n--- a\/fs\/partitions\/ldm.c\n+++ b\/fs\/partitions\/ldm.c\n@@ -251,6 +251,11 @@ static bool ldm_parse_vmdb (const u8 *data, struct vmdb *vm)\n \t}\n \n \tvm->vblk_size     = get_unaligned_be32(data + 0x08);\n+\tif (vm->vblk_size == 0) {\n+\t\tldm_error (\"Illegal VBLK size\");\n+\t\treturn false;\n+\t}\n+\n \tvm->vblk_offset   = get_unaligned_be32(data + 0x0C);\n \tvm->last_vblk_seq = get_unaligned_be32(data + 0x04);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2016-4449","CWE_ID":"20","category":"security","commit_id":"b1d34de46a11323fccffa9fadeb33be670d602f5","commit_message":"From b1d34de46a11323fccffa9fadeb33be670d602f5 Mon Sep 17 00:00:00 2001\nFrom: Daniel Veillard <veillard@redhat.com>\nDate: Mon, 14 Mar 2016 17:19:44 +0800\nSubject: [PATCH] Fix inappropriate fetch of entities content\n\nFor https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=761430\n\nlibfuzzer regression testing exposed another case where the parser would\nfetch content of an external entity while not in validating mode.\nPlug that hole\n---\n parser.c | 16 +++++++++++++++-\n 1 file changed, 15 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/parser.c b\/parser.c\nindex c424fc1e..f6d652ee 100644\n--- a\/parser.c\n+++ b\/parser.c\n@@ -2861,7 +2861,21 @@ xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n \t        ctxt->nbentities += ent->checked \/ 2;\n \t    if (ent != NULL) {\n                 if (ent->content == NULL) {\n-\t\t    xmlLoadEntityContent(ctxt, ent);\n+\t\t    \/*\n+\t\t     * Note: external parsed entities will not be loaded,\n+\t\t     * it is not required for a non-validating parser to\n+\t\t     * complete external PEreferences coming from the\n+\t\t     * internal subset\n+\t\t     *\/\n+\t\t    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||\n+\t\t\t((ctxt->options & XML_PARSE_DTDVALID) != 0) ||\n+\t\t\t(ctxt->validate != 0)) {\n+\t\t\txmlLoadEntityContent(ctxt, ent);\n+\t\t    } else {\n+\t\t\txmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,\n+\t\t  \"not validating will not read content for PE entity %s\\n\",\n+\t\t                      ent->name, NULL);\n+\t\t    }\n \t\t}\n \t\tctxt->depth++;\n \t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n-- \n2.21.0\n\n","owner":"GNOME","repo":"libxml2","source":"cve"},{"CVE_ID":"CVE-2012-5621","CWE_ID":"20","category":"security","commit_id":"7d09807257963a4f5168a01aec1795a398746372","commit_message":"From 7d09807257963a4f5168a01aec1795a398746372 Mon Sep 17 00:00:00 2001\nFrom: Eugen Dedu <Eugen.Dedu@pu-pm.univ-fcomte.fr>\nDate: Sat, 20 Oct 2012 23:48:56 +0200\nSubject: [PATCH] Validate UTF-8 strings before showing them\n\nCloses bug #653009.\n---\n lib\/engine\/components\/opal\/opal-call.cpp | 45 ++++++++++++++++--------\n 1 file changed, 31 insertions(+), 14 deletions(-)\n\n","diff_code":"diff --git a\/lib\/engine\/components\/opal\/opal-call.cpp b\/lib\/engine\/components\/opal\/opal-call.cpp\nindex 622dd7ed3..defc3cfa9 100644\n--- a\/lib\/engine\/components\/opal\/opal-call.cpp\n+++ b\/lib\/engine\/components\/opal\/opal-call.cpp\n@@ -260,7 +260,7 @@ const std::string\n Opal::Call::get_duration () const\n {\n   std::stringstream duration;\n-  \n+\n   if (start_time.IsValid () && IsEstablished ()) {\n \n     PTimeInterval t = PTime () - start_time;\n@@ -274,26 +274,39 @@ Opal::Call::get_duration () const\n }\n \n \n-time_t \n+time_t\n Opal::Call::get_start_time () const\n {\n   return start_time.GetTimeInSeconds ();\n }\n \n \n-bool \n+bool\n Opal::Call::is_outgoing () const\n {\n   return outgoing;\n }\n \n \n+\/\/ if the parameter is not valid utf8, remove from it all the chars\n+\/\/   after the first invalid utf8 char, so that it becomes valid utf8\n+static void\n+make_valid_utf8 (string & str)\n+{\n+  const char *pos;\n+  if (!g_utf8_validate (str.c_str(), -1, &pos)) {\n+    PTRACE (4, \"Ekiga\\tTrimming invalid UTF-8 string: \" << str.c_str());\n+    str = str.substr (0, pos - str.c_str()).append (\"...\");\n+  }\n+}\n+\n+\n void\n Opal::Call::parse_info (OpalConnection & connection)\n {\n   char start_special_chars [] = \"$\";\n   char end_special_chars [] = \"([;=\";\n-  \n+\n   std::string l_party_name;\n   std::string r_party_name;\n   std::string app;\n@@ -315,7 +328,11 @@ Opal::Call::parse_info (OpalConnection & connection)\n       remote_party_name = r_party_name;\n     if (!app.empty ())\n       remote_application = app;\n-    \n+\n+    make_valid_utf8 (remote_party_name);\n+    make_valid_utf8 (remote_application);\n+    make_valid_utf8 (remote_uri);\n+\n     strip_special_chars (remote_party_name, end_special_chars, false);\n     strip_special_chars (remote_application, end_special_chars, false);\n     strip_special_chars (remote_uri, end_special_chars, false);\n@@ -329,7 +346,7 @@ Opal::Call::parse_info (OpalConnection & connection)\n PBoolean\n Opal::Call::OnEstablished (OpalConnection & connection)\n {\n-  RTP_Session *session = NULL; \n+  RTP_Session *session = NULL;\n   OpalMediaStreamPtr stream;\n \n   NoAnswerTimer.Stop (false);\n@@ -347,7 +364,7 @@ Opal::Call::OnEstablished (OpalConnection & connection)\n \n       session = PDownCast (OpalRTPConnection, &connection)->GetSession (stream->GetSessionID ());\n       if (session) {\n-      \n+\n         session->SetIgnorePayloadTypeChanges (TRUE);\n         session->SetRxStatisticsInterval(50);\n         session->SetTxStatisticsInterval(50);\n@@ -355,7 +372,7 @@ Opal::Call::OnEstablished (OpalConnection & connection)\n     }\n \n     stream = connection.GetMediaStream (OpalMediaType::Video (), false);\n-    if (stream != NULL) { \n+    if (stream != NULL) {\n \n       session = PDownCast (OpalRTPConnection, &connection)->GetSession (stream->GetSessionID ());\n       if (session) {\n@@ -366,12 +383,12 @@ Opal::Call::OnEstablished (OpalConnection & connection)\n       }\n     }\n   }\n-  \n+\n   return OpalCall::OnEstablished (connection);\n }\n \n \n-void \n+void\n Opal::Call::OnReleased (OpalConnection & connection)\n {\n   parse_info (connection);\n@@ -510,7 +527,7 @@ Opal::Call::OnSetUp (OpalConnection & connection)\n \n   new CallSetup (*this, connection);\n \n-  return true; \n+  return true;\n }\n \n \n@@ -524,9 +541,9 @@ Opal::Call::OnAlerting (OpalConnection & connection)\n }\n \n \n-void \n-Opal::Call::OnHold (OpalConnection & \/*connection*\/, \n-                    bool \/*from_remote*\/, \n+void\n+Opal::Call::OnHold (OpalConnection & \/*connection*\/,\n+                    bool \/*from_remote*\/,\n                     bool on_hold)\n {\n   if (on_hold)\n-- \n2.21.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-9653","CWE_ID":"20","category":"security","commit_id":"445c8fb0ebff85195be94cd9f7e1df89cade5c7f","commit_message":"From 445c8fb0ebff85195be94cd9f7e1df89cade5c7f Mon Sep 17 00:00:00 2001\nFrom: Christos Zoulas <christos@zoulas.com>\nDate: Tue, 16 Dec 2014 20:53:05 +0000\nSubject: [PATCH] Bail out on partial reads, from Alexander Cherepanov\n\n---\n src\/readelf.c | 17 +++++++++--------\n 1 file changed, 9 insertions(+), 8 deletions(-)\n\n","diff_code":"diff --git a\/src\/readelf.c b\/src\/readelf.c\nindex 429666304..9d54fc973 100644\n--- a\/src\/readelf.c\n+++ b\/src\/readelf.c\n@@ -27,7 +27,7 @@\n #include \"file.h\"\n \n #ifndef lint\n-FILE_RCSID(\"@(#)$File: readelf.c,v 1.113 2014\/12\/11 14:10:53 christos Exp $\")\n+FILE_RCSID(\"@(#)$File: readelf.c,v 1.114 2014\/12\/11 14:19:36 christos Exp $\")\n #endif\n \n #ifdef BUILTIN_ELF\n@@ -319,7 +319,7 @@ dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n \t * Loop through all the program headers.\n \t *\/\n \tfor ( ; num; num--) {\n-\t\tif (pread(fd, xph_addr, xph_sizeof, off) == -1) {\n+\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n \t\t\tfile_badread(ms);\n \t\t\treturn -1;\n \t\t}\n@@ -928,6 +928,7 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \tuint64_t cap_hw1 = 0;\t\/* SunOS 5.x hardware capabilites *\/\n \tuint64_t cap_sf1 = 0;\t\/* SunOS 5.x software capabilites *\/\n \tchar name[50];\n+\tssize_t namesize;\n \n \tif (size != xsh_sizeof) {\n \t\tif (file_printf(ms, \", corrupted section header size\") == -1)\n@@ -936,7 +937,7 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \t}\n \n \t\/* Read offset of name section to be able to read section names later *\/\n-\tif (pread(fd, xsh_addr, xsh_sizeof, off + size * strtab) == -1) {\n+\tif (pread(fd, xsh_addr, xsh_sizeof, off + size * strtab) < (ssize_t)xsh_sizeof) {\n \t\tfile_badread(ms);\n \t\treturn -1;\n \t}\n@@ -944,15 +945,15 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \n \tfor ( ; num; num--) {\n \t\t\/* Read the name of this section. *\/\n-\t\tif (pread(fd, name, sizeof(name), name_off + xsh_name) == -1) {\n+\t\tif ((namesize = pread(fd, name, sizeof(name) - 1, name_off + xsh_name)) == -1) {\n \t\t\tfile_badread(ms);\n \t\t\treturn -1;\n \t\t}\n-\t\tname[sizeof(name) - 1] = '\\0';\n+\t\tname[namesize] = '\\0';\n \t\tif (strcmp(name, \".debug_info\") == 0)\n \t\t\tstripped = 0;\n \n-\t\tif (pread(fd, xsh_addr, xsh_sizeof, off) == -1) {\n+\t\tif (pread(fd, xsh_addr, xsh_sizeof, off) < (ssize_t)xsh_sizeof) {\n \t\t\tfile_badread(ms);\n \t\t\treturn -1;\n \t\t}\n@@ -982,7 +983,7 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \t\t\t\t    \" for note\");\n \t\t\t\treturn -1;\n \t\t\t}\n-\t\t\tif (pread(fd, nbuf, xsh_size, xsh_offset) == -1) {\n+\t\t\tif (pread(fd, nbuf, xsh_size, xsh_offset) < (ssize_t)xsh_size) {\n \t\t\t\tfile_badread(ms);\n \t\t\t\tfree(nbuf);\n \t\t\t\treturn -1;\n@@ -1178,7 +1179,7 @@ dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n \t}\n \n   \tfor ( ; num; num--) {\n-\t\tif (pread(fd, xph_addr, xph_sizeof, off) == -1) {\n+\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n \t\t\tfile_badread(ms);\n \t\t\treturn -1;\n \t\t}\n","owner":"file","repo":"file","source":"cve"},{"CVE_ID":"CVE-2011-1751","CWE_ID":"20","category":"security","commit_id":"505597e4476a6bc219d0ec1362b760d71cb4fdca","commit_message":"From 505597e4476a6bc219d0ec1362b760d71cb4fdca Mon Sep 17 00:00:00 2001\nFrom: Gerd Hoffmann <kraxel@redhat.com>\nDate: Wed, 27 Apr 2011 11:05:34 +0200\nSubject: Ignore pci unplug requests for unpluggable devices (CVE-2011-1751)\n\nThis patch makes qemu ignore unplug requests from the guest for pci\ndevices which are tagged as non-hotpluggable.  Trouble spot is the\npiix4 chipset with the ISA bridge.  Requests to unplug that one will\nmake it go away together with all ISA bus devices, which are not\nprepared to be unplugged and thus don't cleanup, leaving active\nqemu timers behind in free'ed memory.\n\nSigned-off-by: Gerd Hoffmann <kraxel@redhat.com>\n---\n hw\/acpi_piix4.c | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/hw\/acpi_piix4.c b\/hw\/acpi_piix4.c\nindex 96f522233a..6c908ff00b 100644\n--- a\/hw\/acpi_piix4.c\n+++ b\/hw\/acpi_piix4.c\n@@ -471,11 +471,13 @@ static void pciej_write(void *opaque, uint32_t addr, uint32_t val)\n     BusState *bus = opaque;\n     DeviceState *qdev, *next;\n     PCIDevice *dev;\n+    PCIDeviceInfo *info;\n     int slot = ffs(val) - 1;\n \n     QLIST_FOREACH_SAFE(qdev, &bus->children, sibling, next) {\n         dev = DO_UPCAST(PCIDevice, qdev, qdev);\n-        if (PCI_SLOT(dev->devfn) == slot) {\n+        info = container_of(qdev->info, PCIDeviceInfo, qdev);\n+        if (PCI_SLOT(dev->devfn) == slot && !info->no_hotplug) {\n             qdev_free(qdev);\n         }\n     }\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2017-1000252","CWE_ID":"20","category":"security","commit_id":"36ae3c0a36b7456432fedce38ae2f7bd3e01a563","commit_message":"From 36ae3c0a36b7456432fedce38ae2f7bd3e01a563 Mon Sep 17 00:00:00 2001\nFrom: =?UTF-8?q?Jan=20H=2E=20Sch=C3=B6nherr?= <jschoenh@amazon.de>\nDate: Thu, 7 Sep 2017 19:02:48 +0100\nSubject: [PATCH] KVM: Don't accept obviously wrong gsi values via KVM_IRQFD\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nWe cannot add routes for gsi values >= KVM_MAX_IRQ_ROUTES -- see\nkvm_set_irq_routing(). Hence, there is no sense in accepting them\nvia KVM_IRQFD. Prevent them from entering the system in the first\nplace.\n\nSigned-off-by: Jan H. Sch\u00f6nherr <jschoenh@amazon.de>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>\n---\n virt\/kvm\/eventfd.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/virt\/kvm\/eventfd.c b\/virt\/kvm\/eventfd.c\nindex f2ac53ab82438..c608ab495282d 100644\n--- a\/virt\/kvm\/eventfd.c\n+++ b\/virt\/kvm\/eventfd.c\n@@ -565,6 +565,8 @@ kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n {\n \tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n \t\treturn -EINVAL;\n+\tif (args->gsi >= KVM_MAX_IRQ_ROUTES)\n+\t\treturn -EINVAL;\n \n \tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n \t\treturn kvm_irqfd_deassign(kvm, args);\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-2841","CWE_ID":"20","category":"security","commit_id":"415ab35a441eca767d033a2702223e785b9d5190","commit_message":"From 415ab35a441eca767d033a2702223e785b9d5190 Mon Sep 17 00:00:00 2001\nFrom: Prasad J Pandit <pjp@fedoraproject.org>\nDate: Wed, 24 Feb 2016 11:41:33 +0530\nSubject: [PATCH] net: ne2000: check ring buffer control registers\n\nNe2000 NIC uses ring buffer of NE2000_MEM_SIZE(49152)\nbytes to process network packets. Registers PSTART & PSTOP\ndefine ring buffer size & location. Setting these registers\nto invalid values could lead to infinite loop or OOB r\/w\naccess issues. Add check to avoid it.\n\nReported-by: Yang Hongke <yanghongke@huawei.com>\nTested-by: Yang Hongke <yanghongke@huawei.com>\nSigned-off-by: Prasad J Pandit <pjp@fedoraproject.org>\nSigned-off-by: Jason Wang <jasowang@redhat.com>\n---\n hw\/net\/ne2000.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\n","diff_code":"diff --git a\/hw\/net\/ne2000.c b\/hw\/net\/ne2000.c\nindex e408083..f0feaf9 100644\n--- a\/hw\/net\/ne2000.c\n+++ b\/hw\/net\/ne2000.c\n@@ -155,6 +155,10 @@ static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n \n+    if (s->stop <= s->start) {\n+        return 1;\n+    }\n+\n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n-- \n1.8.3.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-0846","CWE_ID":"20","category":"security","commit_id":"a7ee6281f7ef1c29284e3a4cadfe0f227ffde1ed","commit_message":"From a7ee6281f7ef1c29284e3a4cadfe0f227ffde1ed Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Fri, 30 Nov 2012 23:59:40 +0100\nSubject: [PATCH] qdm2: check array index before use, fix out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/qdm2.c | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/qdm2.c b\/libavcodec\/qdm2.c\nindex 4cf4b2f932..1dfb8d5715 100644\n--- a\/libavcodec\/qdm2.c\n+++ b\/libavcodec\/qdm2.c\n@@ -1257,6 +1257,11 @@ static void qdm2_decode_super_block (QDM2Context *q)\n     for (i = 0; packet_bytes > 0; i++) {\n         int j;\n \n+        if (i>=FF_ARRAY_ELEMS(q->sub_packet_list_A)) {\n+            SAMPLES_NEEDED_2(\"too many packet bytes\");\n+            return;\n+        }\n+\n         q->sub_packet_list_A[i].next = NULL;\n \n         if (i > 0) {\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-17141","CWE_ID":"20","category":"security","commit_id":"c6cac8d8cd0dbe313689ba77023e12bc5b3027be","commit_message":"From: Patrice Fournier <patrice.fournier@ifax.com>\nDate: Tue, 18 Sep 2018 03:00:53 +0000 (-0400)\nSubject: Address CVE-2018-17141 and fixes a few vulnerabilities in code supporting JPEG\nX-Git-Url: http:\/\/git.hylafax.org\/HylaFAX?a=commitdiff_plain;h=c6cac8d8cd0dbe313689ba77023e12bc5b3027be\n\nAddress CVE-2018-17141 and fixes a few vulnerabilities in code supporting JPEG\n\nThese changes are adapted from Lee's fix for this vulnerability.\n\nLuis Merino, Markus Vervier, and Eric Sesterhenn of X41 D-SEC GmbH\n(Security Advisory: X41-2018-008) discovered an uninitialized pointer write\nand also an out-of-bounds write in FaxModem::writeECMData() that could lead\nto remote code execution with a specially-crafted fax sender.\n\nThese changes fix the coding errors and deliberately prevent malicious and\nmalfunctioning senders from inadvertently or deliberately setting JPEG and\nMH\/MR\/MMR\/JBIG formats in the same DCS signal.\n---\n\n","diff_code":"diff --git a\/faxd\/Class2.c++ b\/faxd\/Class2.c++\nindex 9bd312d..6439719 100644\n--- a\/faxd\/Class2.c++\n+++ b\/faxd\/Class2.c++\n@@ -485,6 +485,15 @@ Class2Modem::parseClass2Capabilities(const char* cap, Class2Params& params, bool\n \t} else {\n \t    if (jpscan == 0x1) params.jp = JP_GREY;\n \t    else if (jpscan & 0x2) params.jp = JP_COLOR;\n+\t    \/*\n+\t     * ITU T.30 does not specify that bits 16 (MR) or 31 (MMR) must be set to zero if color fax is used;\n+\t     * and ITU T.32 Table 21 provides a data field, \"JP\", for JPEG support separate from \"DF\" for data\n+\t     * format and does not specify that DF is meaningless in DCS when JP is used; but because T.4\/T.6\n+\t     * (MH\/MR\/MMR), JBIG, and JPEG are distinct formats from each other, we must conclude that any\n+\t     * indication of JPEG in DCS must, therefore, invalidate any indication in DCS of MH\/MR\/MMR\/JBIG.\n+\t     * Otherwise, having both df and jp be non-zero will be confusing and possibly cause problems.\n+\t     *\/\n+\t    if (params.jp != JP_NONE) params.df = 0;\t\/\/ Yes, this is DF_1DMH, but there is no \"DF_NONE\".\n \t}\n \treturn (true);\n     } else {\ndiff --git a\/faxd\/CopyQuality.c++ b\/faxd\/CopyQuality.c++\nindex 6ebc936..d1f2d0f 100644\n--- a\/faxd\/CopyQuality.c++\n+++ b\/faxd\/CopyQuality.c++\n@@ -38,6 +38,7 @@\n #include <ctype.h>\n \n #define\tRCVBUFSIZ\t(32*1024)\t\t\/\/ XXX\n+#define\tCOLORBUFSIZ\t(2000*1024)\t\t\/\/ 1MB is not big enough\n \n static\tvoid setupCompression(TIFF*, u_int, u_int, uint32);\n \n@@ -356,7 +357,7 @@ FaxModem::recvPageDLEData(TIFF* tif, bool checkQuality,\n \t\t * rather fax-specific.\n \t\t *\/\n \t\trecvEOLCount = 0;\n-\t\trecvRow = (u_char*) malloc(1024*1000);    \/\/ 1M should do it?\n+\t\trecvRow = (u_char*) malloc(COLORBUFSIZ);\n \t\tfxAssert(recvRow != NULL, \"page buffering error (JPEG page).\");\n \t\trecvPageStart = recvRow;\n \t    }\n@@ -408,8 +409,12 @@ FaxModem::recvPageDLEData(TIFF* tif, bool checkQuality,\n \t\t    if (params.df == DF_JBIG) {\n \t\t\tflushRawData(tif, 0, (const u_char*) buf, cc);\n \t\t    } else {\n-\t\t\tmemcpy(recvRow, (const char*) buf, cc);\n-\t\t\trecvRow += cc;\n+\t\t\t\/* We don't support reception of a JPEG page bigger than COLORBUFSIZ. *\/\n+\t\t\tif (recvRow + cc - recvPageStart > COLORBUFSIZ) cc = recvPageStart + COLORBUFSIZ - recvRow;\n+\t\t\tif (cc > 0) {\n+\t\t\t    memcpy(recvRow, (const char*) buf, cc);\n+\t\t\t    recvRow += cc;\n+\t\t\t}\n \t\t    }\n \t\t} while (!fin);\n \t\tif (params.df == DF_JBIG) clearSDNORMCount();\n@@ -987,7 +992,7 @@ FaxModem::writeECMData(TIFF* tif, u_char* buf, u_int cc, const Class2Params& par\n \t    case JP_GREY+4:\n \t    case JP_COLOR+4:\n \t\trecvEOLCount = 0;\n-\t\trecvRow = (u_char*) malloc(1024*1000);    \/\/ 1M should do it?\n+\t\trecvRow = (u_char*) malloc(COLORBUFSIZ);\n \t\tfxAssert(recvRow != NULL, \"page buffering error (JPEG page).\");\n \t\trecvPageStart = recvRow;\n \t\tsetupStartPage(tif, params);\n@@ -1039,14 +1044,20 @@ FaxModem::writeECMData(TIFF* tif, u_char* buf, u_int cc, const Class2Params& par\n \t    }\n \t    break;\n     }\n-    if (params.jp != JP_GREY && params.jp != JP_COLOR) {\n-\tflushRawData(tif, 0, (const u_char*) buf, cc);\n-    } else {\n-\tmemcpy(recvRow, (const char*) buf, cc);\n-\trecvRow += cc;\n-    }\n-    if (seq & 2 && (params.jp == JP_GREY || params.jp == JP_COLOR)) {\n-\tfixupJPEG(tif);\n+    switch (dataform) {\n+       case JP_GREY+4:\n+       case JP_COLOR+4:\n+           \/* We don't support reception of a JPEG page bigger than COLORBUFSIZ. *\/\n+           if (recvRow + cc - recvPageStart > COLORBUFSIZ) cc = recvPageStart + COLORBUFSIZ - recvRow;\n+           if (cc > 0) {\n+               memcpy(recvRow, (const char*) buf, cc);\n+               recvRow += cc;\n+           }\n+           if (seq & 2) fixupJPEG(tif);\n+           break;\n+       default:\n+           flushRawData(tif, 0, (const u_char*) buf, cc);\n+           break;\n     }\n }\n \ndiff --git a\/libhylafax\/Class2Params.c++ b\/libhylafax\/Class2Params.c++\nindex 0409cbd..81b9a22 100644\n--- a\/libhylafax\/Class2Params.c++\n+++ b\/libhylafax\/Class2Params.c++\n@@ -303,6 +303,15 @@ Class2Params::setFromDCS(FaxParams& dcs_caps)\n     if (dcs_caps.isBitEnabled(FaxParams::BITNUM_FULLCOLOR)) {\n \tif (jp == JP_GREY) jp = JP_COLOR;\n     }\n+    \/*\n+     * ITU T.30 does not specify that bits 16 (MR) or 31 (MMR) must be set to zero if color fax is used;\n+     * and ITU T.32 Table 21 provides a data field, \"JP\", for JPEG support separate from \"DF\" for data\n+     * format and does not specify that DF is meaningless in DCS when JP is used; but because T.4\/T.6\n+     * (MH\/MR\/MMR), JBIG, and JPEG are distinct formats from each other, we must conclude that any\n+     * indication of JPEG in DCS must, therefore, invalidate any indication in DCS of MH\/MR\/MMR\/JBIG.\n+     * Otherwise, having both df and jp be non-zero will be confusing and possibly cause problems.\n+     *\/\n+    if (jp != JP_NONE) df = 0;\t\/\/ Yes, this is DF_1DMH, but there is no \"DF_NONE\".\n     if (ec == EC_DISABLE &&\n \t(df == DF_2DMMR || df == DF_JBIG || jp == JP_GREY || jp == JP_COLOR)) {\n \t\/\/ MMR, JBIG, and JPEG require ECM... we've seen cases where fax","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-14361","CWE_ID":"20","category":"security","commit_id":"9e927affe3a021175f354af5fa01d22657c20585","commit_message":"From 9e927affe3a021175f354af5fa01d22657c20585 Mon Sep 17 00:00:00 2001\nFrom: JerikoOne <jeriko.one@gmx.us>\nDate: Tue, 3 Jul 2018 17:22:12 -0500\nSubject: [PATCH] Add alloc fail check in nntp_fetch_headers\n\n---\n nntp.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/nntp.c b\/nntp.c\nindex 032b6e141..a0ffa609c 100644\n--- a\/nntp.c\n+++ b\/nntp.c\n@@ -1288,6 +1288,8 @@ static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first,\n   fc.last = last;\n   fc.restore = restore;\n   fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char));\n+  if (fc.messages == NULL)\n+\t  return -1;\n #ifdef USE_HCACHE\n   fc.hc = hc;\n #endif\n","owner":"neomutt","repo":"neomutt","source":"cve"},{"CVE_ID":"CVE-2016-7976","CWE_ID":"20","category":"security","commit_id":"6d444c273da5499a4cd72f21cb6d4c9a5256807d","commit_message":"From 6d444c273da5499a4cd72f21cb6d4c9a5256807d Mon Sep 17 00:00:00 2001\nFrom: Chris Liddell <chris.liddell@artifex.com>\nDate: Wed, 5 Oct 2016 09:55:55 +0100\nSubject: [PATCH] Bug 697178: Add a file permissions callback\n\nFor the rare occasions when the graphics library directly opens a file\n(currently for reading), this allows us to apply any restrictions on\nfile access normally applied in the interpteter.\n---\n base\/gsicc_manage.c | 10 ++++++----\n base\/gslibctx.c     | 12 +++++++++++-\n base\/gslibctx.h     |  7 +++++++\n psi\/imain.c         |  2 ++\n psi\/int.mak         |  2 +-\n psi\/zfile.c         | 19 +++++++++++++++++++\n psi\/zfile.h         |  7 +++++++\n 7 files changed, 53 insertions(+), 6 deletions(-)\n\n","diff_code":"diff --git a\/base\/gsicc_manage.c b\/base\/gsicc_manage.c\nindex 931c2a6..e9c09c3 100644\n--- a\/base\/gsicc_manage.c\n+++ b\/base\/gsicc_manage.c\n@@ -1124,10 +1124,12 @@ gsicc_open_search(const char* pname, int namelen, gs_memory_t *mem_gc,\n     }\n \n     \/* First just try it like it is *\/\n-    str = sfopen(pname, \"r\", mem_gc);\n-    if (str != NULL) {\n-        *strp = str;\n-        return 0;\n+    if (gs_check_file_permission(mem_gc, pname, namelen, \"r\") >= 0) {\n+        str = sfopen(pname, \"r\", mem_gc);\n+        if (str != NULL) {\n+            *strp = str;\n+            return 0;\n+        }\n     }\n \n     \/* If that fails, try %rom% *\/ \/* FIXME: Not sure this is needed or correct *\/\ndiff --git a\/base\/gslibctx.c b\/base\/gslibctx.c\nindex eaa0458..37ce1ca 100644\n--- a\/base\/gslibctx.c\n+++ b\/base\/gslibctx.c\n@@ -189,7 +189,7 @@ Failure:\n         gscms_destroy(mem);\n         goto Failure;\n     }\n-    \n+    pio->client_check_file_permission = NULL;\n     gp_get_realtime(pio->real_time_0);\n \n     \/* Set scanconverter to 1 (default) *\/\n@@ -343,3 +343,13 @@ void errflush(const gs_memory_t *mem)\n         fflush(mem->gs_lib_ctx->fstderr);\n     \/* else nothing to flush *\/\n }\n+\n+int\n+gs_check_file_permission (gs_memory_t *mem, const char *fname, const int len, const char *permission)\n+{\n+    int code = 0;\n+    if (mem->gs_lib_ctx->client_check_file_permission != NULL) {\n+        code = mem->gs_lib_ctx->client_check_file_permission(mem, fname, len, permission);\n+    }\n+    return code;\n+}\ndiff --git a\/base\/gslibctx.h b\/base\/gslibctx.h\nindex 7a4e110..020e2d9 100644\n--- a\/base\/gslibctx.h\n+++ b\/base\/gslibctx.h\n@@ -32,6 +32,9 @@ typedef struct gs_fapi_server_s gs_fapi_server;\n #  define gs_font_dir_DEFINED\n typedef struct gs_font_dir_s gs_font_dir;\n #endif\n+\n+typedef int (*client_check_file_permission_t) (gs_memory_t *mem, const char *fname, const int len, const char *permission);\n+\n typedef struct gs_lib_ctx_s\n {\n     gs_memory_t *memory;  \/* mem->gs_lib_ctx->memory == mem *\/\n@@ -61,6 +64,7 @@ typedef struct gs_lib_ctx_s\n     struct gx_io_device_s **io_device_table;\n     int io_device_table_count;\n     int io_device_table_size;\n+    client_check_file_permission_t client_check_file_permission;\n     \/* Define the default value of AccurateScreens that affects setscreen\n        and setcolorscreen. *\/\n     bool screen_accurate_screens;\n@@ -133,6 +137,9 @@ int\n gs_lib_ctx_get_default_device_list(const gs_memory_t *mem, char** dev_list_str,\n                         int *list_str_len);\n \n+int\n+gs_check_file_permission (gs_memory_t *mem, const char *fname, const int len, const char *permission);\n+\n #define IS_LIBCTX_STDOUT(mem, f) (f == mem->gs_lib_ctx->fstdout)\n #define IS_LIBCTX_STDERR(mem, f) (f == mem->gs_lib_ctx->fstderr)\n \ndiff --git a\/psi\/imain.c b\/psi\/imain.c\nindex 9a9bb5d..6874128 100644\n--- a\/psi\/imain.c\n+++ b\/psi\/imain.c\n@@ -57,6 +57,7 @@\n #include \"ivmspace.h\"\n #include \"idisp.h\"              \/* for setting display device callback *\/\n #include \"iplugin.h\"\n+#include \"zfile.h\"\n \n #ifdef PACIFY_VALGRIND\n #include \"valgrind.h\"\n@@ -212,6 +213,7 @@ gs_main_init1(gs_main_instance * minst)\n                                            \"the_gs_name_table\");\n             if (code < 0)\n                 return code;\n+            mem->gs_lib_ctx->client_check_file_permission = z_check_file_permissions;\n         }\n         code = obj_init(&minst->i_ctx_p, &idmem);  \/* requires name_init *\/\n         if (code < 0)\ndiff --git a\/psi\/int.mak b\/psi\/int.mak\nindex 4654afc..bb30d51 100644\n--- a\/psi\/int.mak\n+++ b\/psi\/int.mak\n@@ -2024,7 +2024,7 @@ $(PSOBJ)imain.$(OBJ) : $(PSSRC)imain.c $(GH) $(memory__h) $(string__h)\\\n  $(ialloc_h) $(iconf_h) $(idebug_h) $(idict_h) $(idisp_h) $(iinit_h)\\\n  $(iname_h) $(interp_h) $(iplugin_h) $(isave_h) $(iscan_h) $(ivmspace_h)\\\n  $(iinit_h) $(main_h) $(oper_h) $(ostack_h)\\\n- $(sfilter_h) $(store_h) $(stream_h) $(strimpl_h)\\\n+ $(sfilter_h) $(store_h) $(stream_h) $(strimpl_h) $(zfile_h)\\\n  $(INT_MAK) $(MAKEDIRS)\n \t$(PSCC) $(PSO_)imain.$(OBJ) $(C_) $(PSSRC)imain.c\n \ndiff --git a\/psi\/zfile.c b\/psi\/zfile.c\nindex 2c6c958..2f27f82 100644\n--- a\/psi\/zfile.c\n+++ b\/psi\/zfile.c\n@@ -197,6 +197,25 @@ check_file_permissions(i_ctx_t *i_ctx_p, const char *fname, int len,\n     return check_file_permissions_reduced(i_ctx_p, fname_reduced, rlen, permitgroup);\n }\n \n+\/* z_check_file_permissions: see zfile.h for explanation\n+ *\/\n+int\n+z_check_file_permissions(gs_memory_t *mem, const char *fname, const int len, const char *permission)\n+{\n+    i_ctx_t *i_ctx_p = get_minst_from_memory(mem)->i_ctx_p;\n+    gs_parsed_file_name_t pname;\n+    const char *permitgroup = permission[0] == 'r' ? \"PermitFileReading\" : \"PermitFileWriting\";\n+    int code = gs_parse_file_name(&pname, fname, len, imemory);\n+    if (code < 0)\n+        return code;\n+\n+    if (pname.iodev && i_ctx_p->LockFilePermissions && strcmp(pname.iodev->dname, \"%pipe%\") == 0)\n+        return gs_error_invalidfileaccess;\n+        \n+    code = check_file_permissions(i_ctx_p, fname, len, permitgroup);\n+    return code;\n+}\n+\n \/* <name_string> <access_string> file <file> *\/\n int                             \/* exported for zsysvm.c *\/\n zfile(i_ctx_t *i_ctx_p)\ndiff --git a\/psi\/zfile.h b\/psi\/zfile.h\nindex fdf1373..a9399c7 100644\n--- a\/psi\/zfile.h\n+++ b\/psi\/zfile.h\n@@ -22,4 +22,11 @@\n int zopen_file(i_ctx_t *i_ctx_p, const gs_parsed_file_name_t *pfn,\n            const char *file_access, stream **ps, gs_memory_t *mem);\n \n+\/* z_check_file_permissions: a callback (via mem->gs_lib_ctx->client_check_file_permission)\n+ * to allow applying the above permissions checks when opening file(s) from\n+ * the graphics library\n+ *\/\n+int\n+z_check_file_permissions(gs_memory_t *mem, const char *fname,\n+                                 const int len, const char *permission);\n #endif\n-- \n2.9.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2008-7316","CWE_ID":"20","category":"security","commit_id":"124d3b7041f9a0ca7c43a6293e1cae4576c32fd5","commit_message":"From 124d3b7041f9a0ca7c43a6293e1cae4576c32fd5 Mon Sep 17 00:00:00 2001\nFrom: Nick Piggin <nickpiggin@yahoo.com.au>\nDate: Sat, 2 Feb 2008 15:01:17 +0100\nSubject: [PATCH] fix writev regression: pan hanging unkillable and\n un-straceable\n\nFrederik Himpe reported an unkillable and un-straceable pan process.\n\nZero length iovecs can go into an infinite loop in writev, because the\niovec iterator does not always advance over them.\n\nThe sequence required to trigger this is not trivial. I think it\nrequires that a zero-length iovec be followed by a non-zero-length iovec\nwhich causes a pagefault in the atomic usercopy. This causes the writev\ncode to drop back into single-segment copy mode, which then tries to\ncopy the 0 bytes of the zero-length iovec; a zero length copy looks like\na failure though, so it loops.\n\nPut a test into iov_iter_advance to catch zero-length iovecs. We could\njust put the test in the fallback path, but I feel it is more robust to\nskip over zero-length iovecs throughout the code (iovec iterator may be\nused in filesystems too, so it should be robust).\n\nSigned-off-by: Nick Piggin <npiggin@suse.de>\nSigned-off-by: Ingo Molnar <mingo@elte.hu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\n---\n mm\/filemap.c | 8 ++++++--\n 1 file changed, 6 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/mm\/filemap.c b\/mm\/filemap.c\nindex 89ce6fe5f8be1..76bea88cbebcb 100644\n--- a\/mm\/filemap.c\n+++ b\/mm\/filemap.c\n@@ -1750,7 +1750,11 @@ static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n \t\tconst struct iovec *iov = i->iov;\n \t\tsize_t base = i->iov_offset;\n \n-\t\twhile (bytes) {\n+\t\t\/*\n+\t\t * The !iov->iov_len check ensures we skip over unlikely\n+\t\t * zero-length segments.\n+\t\t *\/\n+\t\twhile (bytes || !iov->iov_len) {\n \t\t\tint copy = min(bytes, iov->iov_len - base);\n \n \t\t\tbytes -= copy;\n@@ -2268,6 +2272,7 @@ static ssize_t generic_perform_write(struct file *file,\n \n \t\tcond_resched();\n \n+\t\tiov_iter_advance(i, copied);\n \t\tif (unlikely(copied == 0)) {\n \t\t\t\/*\n \t\t\t * If we were unable to copy any data at all, we must\n@@ -2281,7 +2286,6 @@ static ssize_t generic_perform_write(struct file *file,\n \t\t\t\t\t\tiov_iter_single_seg_count(i));\n \t\t\tgoto again;\n \t\t}\n-\t\tiov_iter_advance(i, copied);\n \t\tpos += copied;\n \t\twritten += copied;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-1581","CWE_ID":"20","category":"security","commit_id":"fd0e435b0fe85622f167b84432552885a4856ac8","commit_message":"From fd0e435b0fe85622f167b84432552885a4856ac8 Mon Sep 17 00:00:00 2001\nFrom: Phil Oester <kernel@linuxace.com>\nDate: Mon, 14 Mar 2011 06:22:04 +0000\nSubject: bonding: Incorrect TX queue offset\n\nWhen packets come in from a device with >= 16 receive queues\nheaded out a bonding interface, syslog gets filled with this:\n\n    kernel: bond0 selects TX queue 16, but real number of TX queues is 16\n\nbecause queue_mapping is offset by 1.  Adjust return value\nto account for the offset.\n\nThis is a revision of my earlier patch (which did not use the\nskb_rx_queue_* helpers - thanks to Ben for the suggestion).\nAndy submitted a similar patch which emits a pr_warning on\ninvalid queue selection, but I believe the log spew is\nnot useful.  We can revisit that question in the future,\nbut in the interim I believe fixing the core problem is\nworthwhile.\n\nSigned-off-by: Phil Oester <kernel@linuxace.com>\nSigned-off-by: Andy Gospodarek <andy@greyhouse.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n drivers\/net\/bonding\/bond_main.c | 11 +++++++++--\n 1 file changed, 9 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/net\/bonding\/bond_main.c b\/drivers\/net\/bonding\/bond_main.c\nindex 3ad4f501949e..a93d9417dc15 100644\n--- a\/drivers\/net\/bonding\/bond_main.c\n+++ b\/drivers\/net\/bonding\/bond_main.c\n@@ -4341,11 +4341,18 @@ static u16 bond_select_queue(struct net_device *dev, struct sk_buff *skb)\n {\n \t\/*\n \t * This helper function exists to help dev_pick_tx get the correct\n-\t * destination queue.  Using a helper function skips the a call to\n+\t * destination queue.  Using a helper function skips a call to\n \t * skb_tx_hash and will put the skbs in the queue we expect on their\n \t * way down to the bonding driver.\n \t *\/\n-\treturn skb->queue_mapping;\n+\tu16 txq = skb_rx_queue_recorded(skb) ? skb_get_rx_queue(skb) : 0;\n+\n+\tif (unlikely(txq >= dev->real_num_tx_queues)) {\n+\t\tdo\n+\t\t\ttxq -= dev->real_num_tx_queues;\n+\t\twhile (txq >= dev->real_num_tx_queues);\n+\t}\n+\treturn txq;\n }\n \n static netdev_tx_t bond_start_xmit(struct sk_buff *skb, struct net_device *dev)\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2011-0531","CWE_ID":"20","category":"security","commit_id":"59491dcedffbf97612d2c572943b56ee4289dd07","commit_message":"From 59491dcedffbf97612d2c572943b56ee4289dd07 Mon Sep 17 00:00:00 2001\nFrom: Steve Lhomme <slhomme@matroska.org>\nDate: Sat, 29 Jan 2011 14:27:43 +0100\nSubject: [PATCH] the ID could be OK but the class mismatching\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=utf8\nContent-Transfer-Encoding: 8bit\n\nSigned-off-by: R\u00c3\u00a9mi Denis-Courmont <remi@remlab.net>\n---\n modules\/demux\/mkv\/mkv.hpp | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n","diff_code":"diff --git a\/modules\/demux\/mkv\/mkv.hpp b\/modules\/demux\/mkv\/mkv.hpp\nindex f0e87c6894..664cafac21 100644\n--- a\/modules\/demux\/mkv\/mkv.hpp\n+++ b\/modules\/demux\/mkv\/mkv.hpp\n@@ -115,7 +115,7 @@ extern \"C\" {\n \n #define MKVD_TIMECODESCALE 1000000\n \n-#define MKV_IS_ID( el, C ) ( EbmlId( (*el) ) == C::ClassInfos.GlobalId )\n+#define MKV_IS_ID( el, C ) ( el != NULL && typeid( *el ) == typeid( C ) )\n \n \n using namespace LIBMATROSKA_NAMESPACE;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2014-2673","CWE_ID":"20","category":"security","commit_id":"621b5060e823301d0cba4cb52a7ee3491922d291","commit_message":"From 621b5060e823301d0cba4cb52a7ee3491922d291 Mon Sep 17 00:00:00 2001\nFrom: Michael Neuling <mikey@neuling.org>\nDate: Mon, 3 Mar 2014 14:21:40 +1100\nSubject: [PATCH] powerpc\/tm: Fix crash when forking inside a transaction\n\nWhen we fork\/clone we currently don't copy any of the TM state to the new\nthread.  This results in a TM bad thing (program check) when the new process is\nswitched in as the kernel does a tmrechkpt with TEXASR FS not set.  Also, since\nR1 is from userspace, we trigger the bad kernel stack pointer detection.  So we\nend up with something like this:\n\n   Bad kernel stack pointer 0 at c0000000000404fc\n   cpu 0x2: Vector: 700 (Program Check) at [c00000003ffefd40]\n       pc: c0000000000404fc: restore_gprs+0xc0\/0x148\n       lr: 0000000000000000\n       sp: 0\n      msr: 9000000100201030\n     current = 0xc000001dd1417c30\n     paca    = 0xc00000000fe00800   softe: 0        irq_happened: 0x01\n       pid   = 0, comm = swapper\/2\n   WARNING: exception is not recoverable, can't continue\n\nThe below fixes this by flushing the TM state before we copy the task_struct to\nthe clone.  To do this we go through the tmreclaim patch, which removes the\ncheckpointed registers from the CPU and transitions the CPU out of TM suspend\nmode.  Hence we need to call tmrechkpt after to restore the checkpointed state\nand the TM mode for the current task.\n\nTo make this fail from userspace is simply:\n\ttbegin\n\tli\tr0, 2\n\tsc\n\t<boom>\n\nKudos to Adhemerval Zanella Neto for finding this.\n\nSigned-off-by: Michael Neuling <mikey@neuling.org>\ncc: Adhemerval Zanella Neto <azanella@br.ibm.com>\ncc: stable@vger.kernel.org\nSigned-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>\n---\n arch\/powerpc\/kernel\/process.c | 9 +++++++++\n 1 file changed, 9 insertions(+)\n\n","diff_code":"diff --git a\/arch\/powerpc\/kernel\/process.c b\/arch\/powerpc\/kernel\/process.c\nindex 8d4c247f17389..af064d28b3652 100644\n--- a\/arch\/powerpc\/kernel\/process.c\n+++ b\/arch\/powerpc\/kernel\/process.c\n@@ -1048,6 +1048,15 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n \tflush_altivec_to_thread(src);\n \tflush_vsx_to_thread(src);\n \tflush_spe_to_thread(src);\n+\t\/*\n+\t * Flush TM state out so we can copy it.  __switch_to_tm() does this\n+\t * flush but it removes the checkpointed state from the current CPU and\n+\t * transitions the CPU out of TM mode.  Hence we need to call\n+\t * tm_recheckpoint_new_task() (on the same task) to restore the\n+\t * checkpointed state back and the TM mode.\n+\t *\/\n+\t__switch_to_tm(src);\n+\ttm_recheckpoint_new_task(src);\n \n \t*dst = *src;\n \n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-8849","CWE_ID":"20","category":"security","commit_id":"71554140bdaede27b95dbe4c9b5a028a83c83cce","commit_message":"From 71554140bdaede27b95dbe4c9b5a028a83c83cce Mon Sep 17 00:00:00 2001\nFrom: Alexander Reinholdt <alexander.reinholdt@kdemail.net>\nDate: Wed, 10 May 2017 10:23:34 +0200\nSubject: Find the mount\/umount commands in the helper\n\nInstead of trusting what we get passed in\nCVE-2017-8849\n---\n core\/smb4kglobal.cpp         | 65 +++++++++++++++++++++++++++++++++++-\n core\/smb4kglobal.h           | 16 ++++++++-\n core\/smb4kmounter_p.cpp      | 78 ++++----------------------------------------\n helpers\/CMakeLists.txt       |  6 +++-\n helpers\/smb4kmounthelper.cpp | 51 +++++++++++++++++++++++++++--\n 5 files changed, 139 insertions(+), 77 deletions(-)\n\n","diff_code":"diff --git a\/core\/smb4kglobal.cpp b\/core\/smb4kglobal.cpp\nindex 172016f..818a78a 100644\n--- a\/core\/smb4kglobal.cpp\n+++ b\/core\/smb4kglobal.cpp\n@@ -2,7 +2,7 @@\n     smb4kglobal  -  This is the global namespace for Smb4K.\n                              -------------------\n     begin                : Sa Apr 2 2005\n-    copyright            : (C) 2005-2014 by Alexander Reinholdt\n+    copyright            : (C) 2005-2017 by Alexander Reinholdt\n     email                : alexander.reinholdt@kdemail.net\n  ***************************************************************************\/\n \n@@ -851,3 +851,66 @@ QStringList Smb4KGlobal::whitelistedMountArguments()\n #endif\n \n \n+const QString Smb4KGlobal::findMountExecutable()\n+{\n+  QString mount;\n+  QStringList paths;\n+  paths << \"\/bin\";\n+  paths << \"\/sbin\";\n+  paths << \"\/usr\/bin\";\n+  paths << \"\/usr\/sbin\";\n+  paths << \"\/usr\/local\/bin\";\n+  paths << \"\/usr\/local\/sbin\";\n+\n+  for (int i = 0; i < paths.size(); ++i)\n+  {\n+#if defined(Q_OS_LINUX)\n+    mount = KGlobal::dirs()->findExe(\"mount.cifs\", paths.at(i));\n+#elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n+    mount = KGlobal::dirs()->findExe(\"mount_smbfs\", paths.at(i));\n+#endif\n+\n+    if (!mount.isEmpty())\n+    {\n+      break;\n+    }\n+    else\n+    {\n+      continue;\n+    }\n+  }\n+  \n+  return mount;\n+}\n+\n+\n+const QString Smb4KGlobal::findUmountExecutable()\n+{\n+  \/\/ Find the umount program.\n+  QString umount;\n+  QStringList paths;\n+  paths << \"\/bin\";\n+  paths << \"\/sbin\";\n+  paths << \"\/usr\/bin\";\n+  paths << \"\/usr\/sbin\";\n+  paths << \"\/usr\/local\/bin\";\n+  paths << \"\/usr\/local\/sbin\";\n+\n+  for ( int i = 0; i < paths.size(); ++i )\n+  {\n+    umount = KGlobal::dirs()->findExe(\"umount\", paths.at(i));\n+\n+    if (!umount.isEmpty())\n+    {\n+      break;\n+    }\n+    else\n+    {\n+      continue;\n+    }\n+  }\n+  \n+  return umount;\n+}\n+\n+\ndiff --git a\/core\/smb4kglobal.h b\/core\/smb4kglobal.h\nindex db1805b..0ef377d 100644\n--- a\/core\/smb4kglobal.h\n+++ b\/core\/smb4kglobal.h\n@@ -2,7 +2,7 @@\n     smb4kglobal  -  This is the global namespace for Smb4K.\n                              -------------------\n     begin                : Sa Apr 2 2005\n-    copyright            : (C) 2005-2014 by Alexander Reinholdt\n+    copyright            : (C) 2005-2017 by Alexander Reinholdt\n     email                : alexander.reinholdt@kdemail.net\n  ***************************************************************************\/\n \n@@ -455,6 +455,20 @@ namespace Smb4KGlobal\n    *\/\n   KDE_EXPORT QStringList whitelistedMountArguments();\n #endif\n+  \n+  \/**\n+   * Find the mount executable on the system.\n+   * \n+   * @returns the path of the mount executable.\n+   *\/\n+  KDE_EXPORT const QString findMountExecutable();\n+  \n+  \/**\n+   * Find the umount executable on the system.\n+   * \n+   * @returns the path of the umount executable.\n+   *\/\n+  KDE_EXPORT const QString findUmountExecutable();\n };\n \n #endif\ndiff --git a\/core\/smb4kmounter_p.cpp b\/core\/smb4kmounter_p.cpp\nindex 63a87ed..342052a 100644\n--- a\/core\/smb4kmounter_p.cpp\n+++ b\/core\/smb4kmounter_p.cpp\n@@ -207,30 +207,7 @@ bool Smb4KMountJob::createMountAction(Smb4KShare *share, Action *action)\n \/\/\n bool Smb4KMountJob::fillArgs(Smb4KShare *share, QMap<QString, QVariant>& map)\n {\n-  \/\/ Find the mount program.\n-  QString mount;\n-  QStringList paths;\n-  paths << \"\/bin\";\n-  paths << \"\/sbin\";\n-  paths << \"\/usr\/bin\";\n-  paths << \"\/usr\/sbin\";\n-  paths << \"\/usr\/local\/bin\";\n-  paths << \"\/usr\/local\/sbin\";\n-\n-  for (int i = 0; i < paths.size(); ++i)\n-  {\n-    mount = KGlobal::dirs()->findExe(\"mount.cifs\", paths.at(i));\n-\n-    if (!mount.isEmpty())\n-    {\n-      map.insert(\"mh_command\", mount);\n-      break;\n-    }\n-    else\n-    {\n-      continue;\n-    }\n-  }\n+  const QString mount = findMountExecutable();\n \n   if (mount.isEmpty())\n   {\n@@ -242,6 +219,8 @@ bool Smb4KMountJob::fillArgs(Smb4KShare *share, QMap<QString, QVariant>& map)\n     \/\/ Do nothing\n   }\n   \n+  map.insert(\"mh_command\", mount);\n+  \n   \/\/ Mount arguments.\n   QMap<QString, QString> global_options = globalSambaOptions();\n   Smb4KCustomOptions *options  = Smb4KCustomOptionsManager::self()->findOptions(share);\n@@ -729,30 +708,7 @@ bool Smb4KMountJob::fillArgs(Smb4KShare *share, QMap<QString, QVariant>& map)\n \/\/\n bool Smb4KMountJob::fillArgs(Smb4KShare *share, QMap<QString, QVariant>& map)\n {\n-  \/\/ Find the mount program.\n-  QString mount;\n-  QStringList paths;\n-  paths << \"\/bin\";\n-  paths << \"\/sbin\";\n-  paths << \"\/usr\/bin\";\n-  paths << \"\/usr\/sbin\";\n-  paths << \"\/usr\/local\/bin\";\n-  paths << \"\/usr\/local\/sbin\";\n-\n-  for (int i = 0; i < paths.size(); ++i)\n-  {\n-    mount = KGlobal::dirs()->findExe(\"mount_smbfs\", paths.at(i));\n-\n-    if (!mount.isEmpty())\n-    {\n-      map.insert(\"mh_command\", mount);\n-      break;\n-    }\n-    else\n-    {\n-      continue;\n-    }\n-  }\n+  const QString mount = findMountExecutable();\n \n   if (mount.isEmpty())\n   {\n@@ -764,6 +720,8 @@ bool Smb4KMountJob::fillArgs(Smb4KShare *share, QMap<QString, QVariant>& map)\n     \/\/ Do nothing\n   }\n   \n+  map.insert(\"mh_command\", mount);\n+  \n   \/\/ Mount arguments.\n   QMap<QString, QString> global_options = globalSambaOptions();\n   Smb4KCustomOptions *options  = Smb4KCustomOptionsManager::self()->findOptions(share);\n@@ -1253,29 +1211,7 @@ bool Smb4KUnmountJob::createUnmountAction(Smb4KShare *share, Action *action)\n     \/\/ Do nothing\n   }\n   \n-  \/\/ Find the umount program.\n-  QString umount;\n-  QStringList paths;\n-  paths << \"\/bin\";\n-  paths << \"\/sbin\";\n-  paths << \"\/usr\/bin\";\n-  paths << \"\/usr\/sbin\";\n-  paths << \"\/usr\/local\/bin\";\n-  paths << \"\/usr\/local\/sbin\";\n-\n-  for ( int i = 0; i < paths.size(); ++i )\n-  {\n-    umount = KGlobal::dirs()->findExe(\"umount\", paths.at(i));\n-\n-    if (!umount.isEmpty())\n-    {\n-      break;\n-    }\n-    else\n-    {\n-      continue;\n-    }\n-  }\n+  const QString umount = findUmountExecutable();\n \n   if (umount.isEmpty() && !m_silent)\n   {\ndiff --git a\/helpers\/CMakeLists.txt b\/helpers\/CMakeLists.txt\nindex e9e670b..cd4228d 100644\n--- a\/helpers\/CMakeLists.txt\n+++ b\/helpers\/CMakeLists.txt\n@@ -1,7 +1,11 @@\n+include_directories(\n+  ${CMAKE_SOURCE_DIR}\/core\n+  ${CMAKE_BINARY_DIR}\/core )\n+\n set( smb4kmounthelper_SRCS smb4kmounthelper.cpp )\n \n kde4_add_executable( mounthelper ${smb4kmounthelper_SRCS} )\n-target_link_libraries( mounthelper ${KDE4_KDECORE_LIBS} ${KDE4_KIO_LIBS} )\n+target_link_libraries( mounthelper smb4kcore ${KDE4_KDECORE_LIBS} ${KDE4_KIO_LIBS} )\n install( TARGETS mounthelper DESTINATION ${LIBEXEC_INSTALL_DIR} )\n \n kde4_install_auth_helper_files( mounthelper net.sourceforge.smb4k.mounthelper root )\ndiff --git a\/helpers\/smb4kmounthelper.cpp b\/helpers\/smb4kmounthelper.cpp\nindex a2f2fed..7959020 100644\n--- a\/helpers\/smb4kmounthelper.cpp\n+++ b\/helpers\/smb4kmounthelper.cpp\n@@ -29,6 +29,7 @@\n \n \/\/ application specific includes\n #include \"smb4kmounthelper.h\"\n+#include \"core\/smb4kglobal.h\"\n \n \/\/ Qt includes\n #include <QProcessEnvironment>\n@@ -43,12 +44,35 @@\n #include <kmountpoint.h>\n #include <kurl.h>\n \n+using namespace Smb4KGlobal;\n+\n KDE4_AUTH_HELPER_MAIN( \"net.sourceforge.smb4k.mounthelper\", Smb4KMountHelper )\n \n \n ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n {\n   ActionReply reply;\n+  \n+  \/\/\n+  \/\/ Get the mount executable\n+  \/\/\n+  const QString mount = findMountExecutable();\n+  \n+  \/\/\n+  \/\/ Check the executable\n+  \/\/\n+  if (mount != args[\"mh_command\"].toString())\n+  {\n+    \/\/ Something weird is going on, bail out.\n+    reply.setErrorCode(ActionReply::HelperError);\n+    reply.setErrorDescription(i18n(\"Wrong executable passed. Bailing out.\"));\n+    return reply;\n+  }\n+  else\n+  {\n+    \/\/ Do nothing\n+  }\n+  \n   \/\/ The mountpoint is a unique and can be used to\n   \/\/ find the share.\n   reply.addData(\"mh_mountpoint\", args[\"mh_mountpoint\"]);\n@@ -75,12 +99,12 @@ ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n   \/\/ Set the mount command here.\n   QStringList command;\n #if defined(Q_OS_LINUX)\n-  command << args[\"mh_command\"].toString();\n+  command << mount;\n   command << args[\"mh_unc\"].toString();\n   command << args[\"mh_mountpoint\"].toString();\n   command << args[\"mh_options\"].toStringList();\n #elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)\n-  command << args[\"mh_command\"].toString();\n+  command << mount;\n   command << args[\"mh_options\"].toStringList();\n   command << args[\"mh_unc\"].toString();\n   command << args[\"mh_mountpoint\"].toString();\n@@ -161,6 +185,27 @@ ActionReply Smb4KMountHelper::mount(const QVariantMap &args)\n ActionReply Smb4KMountHelper::unmount(const QVariantMap &args)\n {\n   ActionReply reply;\n+  \n+  \/\/\n+  \/\/ Get the umount executable\n+  \/\/\n+  const QString umount = findUmountExecutable();\n+  \n+  \/\/\n+  \/\/ Check the executable\n+  \/\/\n+  if (umount != args[\"mh_command\"].toString())\n+  {\n+    \/\/ Something weird is going on, bail out.\n+    reply.setErrorCode(ActionReply::HelperError);\n+    reply.setErrorDescription(i18n(\"Wrong executable passed. Bailing out.\"));\n+    return reply;\n+  }\n+  else\n+  {\n+    \/\/ Do nothing\n+  }\n+  \n   \/\/ The mountpoint is a unique and can be used to\n   \/\/ find the share.\n   reply.addData(\"mh_mountpoint\", args[\"mh_mountpoint\"]);\n@@ -208,7 +253,7 @@ ActionReply Smb4KMountHelper::unmount(const QVariantMap &args)\n   \n   \/\/ Set the umount command here.\n   QStringList command;\n-  command << args[\"mh_command\"].toString();\n+  command << umount;\n   command << args[\"mh_options\"].toStringList();\n   command << args[\"mh_mountpoint\"].toString();\n \n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-1152","CWE_ID":"20","category":"security","commit_id":"75cc83685e103bc8ba380a57468c8f04413033f9","commit_message":"From 75cc83685e103bc8ba380a57468c8f04413033f9 Mon Sep 17 00:00:00 2001\nFrom: Trond Norbye <Trond.Norbye@sun.com>\nDate: Wed, 28 Oct 2009 11:51:05 +0100\nSubject: [PATCH] Issue 102: Piping null to the server will crash it\n\n---\n memcached.c | 31 +++++++++++++++++++++++++++++--\n testapp.c   | 17 +++++++++++++++++\n 2 files changed, 46 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/memcached.c b\/memcached.c\nindex f6f007162..1789135a8 100644\n--- a\/memcached.c\n+++ b\/memcached.c\n@@ -3127,9 +3127,27 @@ static int try_read_command(conn *c) {\n \n         if (c->rbytes == 0)\n             return 0;\n+\n         el = memchr(c->rcurr, '\\n', c->rbytes);\n-        if (!el)\n+        if (!el) {\n+            if (c->rbytes > 1024) {\n+                \/*\n+                 * We didn't have a '\\n' in the first k. This _has_ to be a\n+                 * large multiget, if not we should just nuke the connection.\n+                 *\/\n+                char *ptr = c->rcurr;\n+                while (*ptr == ' ') { \/* ignore leading whitespaces *\/\n+                    ++ptr;\n+                }\n+\n+                if (strcmp(ptr, \"get \") && strcmp(ptr, \"gets \")) {\n+                    conn_set_state(c, conn_closing);\n+                    return 1;\n+                }\n+            }\n+\n             return 0;\n+        }\n         cont = el + 1;\n         if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n             el--;\n@@ -3191,12 +3209,17 @@ static enum try_read_result try_read_udp(conn *c) {\n  * close.\n  * before reading, move the remaining incomplete fragment of a command\n  * (if any) to the beginning of the buffer.\n+ *\n+ * To protect us from someone flooding a connection with bogus data causing\n+ * the connection to eat up all available memory, break out and start looking\n+ * at the data I've got after a number of reallocs...\n+ *\n  * @return enum try_read_result\n  *\/\n static enum try_read_result try_read_network(conn *c) {\n     enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n     int res;\n-\n+    int num_allocs = 0;\n     assert(c != NULL);\n \n     if (c->rcurr != c->rbuf) {\n@@ -3207,6 +3230,10 @@ static enum try_read_result try_read_network(conn *c) {\n \n     while (1) {\n         if (c->rbytes >= c->rsize) {\n+            if (num_allocs == 4) {\n+                return gotdata;\n+            }\n+            ++num_allocs;\n             char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n             if (!new_rbuf) {\n                 if (settings.verbose > 0)\ndiff --git a\/testapp.c b\/testapp.c\nindex b0491c30c..5ff2a1f10 100644\n--- a\/testapp.c\n+++ b\/testapp.c\n@@ -538,6 +538,22 @@ static enum test_return test_issue_92(void) {\n     return TEST_PASS;\n }\n \n+static enum test_return test_issue_102(void) {\n+    char buffer[4096];\n+    memset(buffer, ' ', sizeof(buffer));\n+    buffer[sizeof(buffer) - 1] = '\\0';\n+\n+    close(sock);\n+    sock = connect_server(\"127.0.0.1\", port, false);\n+\n+    send_ascii_command(buffer);\n+    \/* verify that the server closed the connection *\/\n+    assert(read(sock, buffer, sizeof(buffer)) == 0);\n+    close(sock);\n+    sock = connect_server(\"127.0.0.1\", port, false);\n+    return TEST_PASS;\n+}\n+\n static enum test_return start_memcached_server(void) {\n     server_pid = start_server(&port, false, 600);\n     sock = connect_server(\"127.0.0.1\", port, false);\n@@ -1676,6 +1692,7 @@ struct testcase testcases[] = {\n     \/* The following tests all run towards the same server *\/\n     { \"start_server\", start_memcached_server },\n     { \"issue_92\", test_issue_92 },\n+    { \"issue_102\", test_issue_102 },\n     { \"binary_noop\", test_binary_noop },\n     { \"binary_quit\", test_binary_quit },\n     { \"binary_quitq\", test_binary_quitq },\n","owner":"memcached","repo":"memcached","source":"cve"},{"CVE_ID":"CVE-2017-7645","CWE_ID":"20","category":"security","commit_id":"e6838a29ecb484c97e4efef9429643b9851fba6e","commit_message":"From e6838a29ecb484c97e4efef9429643b9851fba6e Mon Sep 17 00:00:00 2001\nFrom: \"J. Bruce Fields\" <bfields@redhat.com>\nDate: Fri, 21 Apr 2017 16:10:18 -0400\nSubject: [PATCH] nfsd: check for oversized NFSv2\/v3 arguments\nMIME-Version: 1.0\nContent-Type: text\/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\nA client can append random data to the end of an NFSv2 or NFSv3 RPC call\nwithout our complaining; we'll just stop parsing at the end of the\nexpected data and ignore the rest.\n\nEncoded arguments and replies are stored together in an array of pages,\nand if a call is too large it could leave inadequate space for the\nreply.  This is normally OK because NFS RPC's typically have either\nshort arguments and long replies (like READ) or long arguments and short\nreplies (like WRITE).  But a client that sends an incorrectly long reply\ncan violate those assumptions.  This was observed to cause crashes.\n\nAlso, several operations increment rq_next_page in the decode routine\nbefore checking the argument size, which can leave rq_next_page pointing\nwell past the end of the page array, causing trouble later in\nsvc_free_pages.\n\nSo, following a suggestion from Neil Brown, add a central check to\nenforce our expectation that no NFSv2\/v3 call has both a large call and\na large reply.\n\nAs followup we may also want to rewrite the encoding routines to check\nmore carefully that they aren't running off the end of the page array.\n\nWe may also consider rejecting calls that have any extra garbage\nappended.  That would be safer, and within our rights by spec, but given\nthe age of our server and the NFS protocol, and the fact that we've\nnever enforced this before, we may need to balance that against the\npossibility of breaking some oddball client.\n\nReported-by: Tuomas Haanp\u00e4\u00e4 <thaan@synopsys.com>\nReported-by: Ari Kauppi <ari@synopsys.com>\nCc: stable@vger.kernel.org\nReviewed-by: NeilBrown <neilb@suse.com>\nSigned-off-by: J. Bruce Fields <bfields@redhat.com>\n---\n fs\/nfsd\/nfssvc.c | 36 ++++++++++++++++++++++++++++++++++++\n 1 file changed, 36 insertions(+)\n\n","diff_code":"diff --git a\/fs\/nfsd\/nfssvc.c b\/fs\/nfsd\/nfssvc.c\nindex 31e1f95934571..59979f0bbd4bf 100644\n--- a\/fs\/nfsd\/nfssvc.c\n+++ b\/fs\/nfsd\/nfssvc.c\n@@ -747,6 +747,37 @@ static __be32 map_new_errors(u32 vers, __be32 nfserr)\n \treturn nfserr;\n }\n \n+\/*\n+ * A write procedure can have a large argument, and a read procedure can\n+ * have a large reply, but no NFSv2 or NFSv3 procedure has argument and\n+ * reply that can both be larger than a page.  The xdr code has taken\n+ * advantage of this assumption to be a sloppy about bounds checking in\n+ * some cases.  Pending a rewrite of the NFSv2\/v3 xdr code to fix that\n+ * problem, we enforce these assumptions here:\n+ *\/\n+static bool nfs_request_too_big(struct svc_rqst *rqstp,\n+\t\t\t\tstruct svc_procedure *proc)\n+{\n+\t\/*\n+\t * The ACL code has more careful bounds-checking and is not\n+\t * susceptible to this problem:\n+\t *\/\n+\tif (rqstp->rq_prog != NFS_PROGRAM)\n+\t\treturn false;\n+\t\/*\n+\t * Ditto NFSv4 (which can in theory have argument and reply both\n+\t * more than a page):\n+\t *\/\n+\tif (rqstp->rq_vers >= 4)\n+\t\treturn false;\n+\t\/* The reply will be small, we're OK: *\/\n+\tif (proc->pc_xdrressize > 0 &&\n+\t    proc->pc_xdrressize < XDR_QUADLEN(PAGE_SIZE))\n+\t\treturn false;\n+\n+\treturn rqstp->rq_arg.len > PAGE_SIZE;\n+}\n+\n int\n nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n {\n@@ -759,6 +790,11 @@ nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n \t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n \tproc = rqstp->rq_procinfo;\n \n+\tif (nfs_request_too_big(rqstp, proc)) {\n+\t\tdprintk(\"nfsd: NFSv%d argument too large\\n\", rqstp->rq_vers);\n+\t\t*statp = rpc_garbage_args;\n+\t\treturn 1;\n+\t}\n \t\/*\n \t * Give the xdr decoder a chance to change this if it wants\n \t * (necessary in the NFSv4.0 compound case)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2017-12843","CWE_ID":"20","category":"security","commit_id":"53c4137bd924b954432c6c59da7572c4c5ffa901","commit_message":"From 53c4137bd924b954432c6c59da7572c4c5ffa901 Mon Sep 17 00:00:00 2001\nFrom: Bron Gondwana <brong@fastmail.fm>\nDate: Fri, 11 Aug 2017 11:58:37 +1000\nSubject: [PATCH] imapd: check for isadmin BEFORE parsing sync lines\n\n---\n imap\/imapd.c | 8 ++++++++\n 1 file changed, 8 insertions(+)\n\n","diff_code":"diff --git a\/imap\/imapd.c b\/imap\/imapd.c\nindex 49b3f0e80..9ac96d2bf 100644\n--- a\/imap\/imapd.c\n+++ b\/imap\/imapd.c\n@@ -2062,6 +2062,8 @@ static void cmdloop(void)\n                 snmp_increment(SCAN_COUNT, 1);\n             }\n             else if (!strcmp(cmd.s, \"Syncapply\")) {\n+                if (!imapd_userisadmin) goto badcmd;\n+\n                 struct dlist *kl = sync_parseline(imapd_in);\n \n                 if (kl) {\n@@ -2071,6 +2073,8 @@ static void cmdloop(void)\n                 else goto extraargs;\n             }\n             else if (!strcmp(cmd.s, \"Syncget\")) {\n+                if (!imapd_userisadmin) goto badcmd;\n+\n                 struct dlist *kl = sync_parseline(imapd_in);\n \n                 if (kl) {\n@@ -2080,6 +2084,8 @@ static void cmdloop(void)\n                 else goto extraargs;\n             }\n             else if (!strcmp(cmd.s, \"Syncrestart\")) {\n+                if (!imapd_userisadmin) goto badcmd;\n+\n                 if (c == '\\r') c = prot_getc(imapd_in);\n                 if (c != '\\n') goto extraargs;\n \n@@ -2087,6 +2093,8 @@ static void cmdloop(void)\n                 cmd_syncrestart(tag.s, &reserve_list, 1);\n             }\n             else if (!strcmp(cmd.s, \"Syncrestore\")) {\n+                if (!imapd_userisadmin) goto badcmd;\n+\n                 struct dlist *kl = sync_parseline(imapd_in);\n \n                 if (kl) {\n","owner":"cyrusimap","repo":"cyrus-imapd","source":"cve"},{"CVE_ID":"CVE-2013-0849","CWE_ID":"20","category":"security","commit_id":"3ae610451170cd5a28b33950006ff0bd23036845","commit_message":"From 3ae610451170cd5a28b33950006ff0bd23036845 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Thu, 29 Nov 2012 15:18:17 +0100\nSubject: [PATCH] roqvideodec: check dimensions validity\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/roqvideodec.c | 6 ++++++\n 1 file changed, 6 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/roqvideodec.c b\/libavcodec\/roqvideodec.c\nindex 08e644e77c..3a8e904c33 100644\n--- a\/libavcodec\/roqvideodec.c\n+++ b\/libavcodec\/roqvideodec.c\n@@ -170,6 +170,12 @@ static av_cold int roq_decode_init(AVCodecContext *avctx)\n     RoqContext *s = avctx->priv_data;\n \n     s->avctx = avctx;\n+\n+    if (avctx->width%16 || avctx->height%16) {\n+         av_log_ask_for_sample(avctx, \"dimensions not being a multiple of 16 are unsupported\\n\");\n+         return AVERROR_PATCHWELCOME;\n+    }\n+\n     s->width = avctx->width;\n     s->height = avctx->height;\n     avcodec_get_frame_defaults(&s->frames[0]);\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2009-0748","CWE_ID":"20","category":"security","commit_id":"4ec110281379826c5cf6ed14735e47027c3c5765","commit_message":"From 4ec110281379826c5cf6ed14735e47027c3c5765 Mon Sep 17 00:00:00 2001\nFrom: Theodore Ts'o <tytso@mit.edu>\nDate: Tue, 6 Jan 2009 14:53:26 -0500\nSubject: ext4: Add sanity checks for the superblock before mounting the\n filesystem\n\nThis avoids insane superblock configurations that could lead to kernel\noops due to null pointer derefences.\n\nhttp:\/\/bugzilla.kernel.org\/show_bug.cgi?id=12371\n\nThanks to David Maciejak at Fortinet's FortiGuard Global Security\nResearch Team who discovered this bug independently (but at\napproximately the same time) as Thiemo Nagel, who submitted the patch.\n\nSigned-off-by: Thiemo Nagel <thiemo.nagel@ph.tum.de>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: stable@kernel.org\n---\n fs\/ext4\/super.c | 30 ++++++++++++++++++++----------\n 1 file changed, 20 insertions(+), 10 deletions(-)\n\n","diff_code":"diff --git a\/fs\/ext4\/super.c b\/fs\/ext4\/super.c\nindex 8ff8709828fd..517c90ad25bd 100644\n--- a\/fs\/ext4\/super.c\n+++ b\/fs\/ext4\/super.c\n@@ -2041,8 +2041,8 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n \tconst char *descr;\n \tint ret = -EINVAL;\n \tint blocksize;\n-\tint db_count;\n-\tint i;\n+\tunsigned int db_count;\n+\tunsigned int i;\n \tint needs_recovery, has_huge_files;\n \tint features;\n \t__u64 blocks_count;\n@@ -2331,20 +2331,30 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)\n \tif (EXT4_BLOCKS_PER_GROUP(sb) == 0)\n \t\tgoto cantfind_ext4;\n \n-\t\/* ensure blocks_count calculation below doesn't sign-extend *\/\n-\tif (ext4_blocks_count(es) + EXT4_BLOCKS_PER_GROUP(sb) <\n-\t    le32_to_cpu(es->s_first_data_block) + 1) {\n-\t\tprintk(KERN_WARNING \"EXT4-fs: bad geometry: block count %llu, \"\n-\t\t       \"first data block %u, blocks per group %lu\\n\",\n-\t\t\text4_blocks_count(es),\n-\t\t\tle32_to_cpu(es->s_first_data_block),\n-\t\t\tEXT4_BLOCKS_PER_GROUP(sb));\n+        \/*\n+         * It makes no sense for the first data block to be beyond the end\n+         * of the filesystem.\n+         *\/\n+        if (le32_to_cpu(es->s_first_data_block) >= ext4_blocks_count(es)) {\n+                printk(KERN_WARNING \"EXT4-fs: bad geometry: first data\"\n+\t\t       \"block %u is beyond end of filesystem (%llu)\\n\",\n+\t\t       le32_to_cpu(es->s_first_data_block),\n+\t\t       ext4_blocks_count(es));\n \t\tgoto failed_mount;\n \t}\n \tblocks_count = (ext4_blocks_count(es) -\n \t\t\tle32_to_cpu(es->s_first_data_block) +\n \t\t\tEXT4_BLOCKS_PER_GROUP(sb) - 1);\n \tdo_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));\n+\tif (blocks_count > ((uint64_t)1<<32) - EXT4_DESC_PER_BLOCK(sb)) {\n+\t\tprintk(KERN_WARNING \"EXT4-fs: groups count too large: %u \"\n+\t\t       \"(block count %llu, first data block %u, \"\n+\t\t       \"blocks per group %lu)\\n\", sbi->s_groups_count,\n+\t\t       ext4_blocks_count(es),\n+\t\t       le32_to_cpu(es->s_first_data_block),\n+\t\t       EXT4_BLOCKS_PER_GROUP(sb));\n+\t\tgoto failed_mount;\n+\t}\n \tsbi->s_groups_count = blocks_count;\n \tdb_count = (sbi->s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) \/\n \t\t   EXT4_DESC_PER_BLOCK(sb);\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2010-4254","CWE_ID":"20","category":"security","commit_id":"4905ef1130feb26c3150b28b97e4a96752e0d399","commit_message":"From 4905ef1130feb26c3150b28b97e4a96752e0d399 Mon Sep 17 00:00:00 2001\nFrom: Rodrigo Kumpera <kumpera@gmail.com>\nDate: Thu, 25 Nov 2010 14:23:31 -0200\nSubject: [PATCH] Handle invalid instantiation of generic methods.\n\n\t* verify.c: Add new function to internal verifier API to check\n\tmethod instantiations.\n\n\t* reflection.c (mono_reflection_bind_generic_method_parameters):\n\tCheck the instantiation before returning it.\n\n\tFixes #655847\n---\n mono\/metadata\/reflection.c       |  3 +++\n mono\/metadata\/verify-internals.h |  1 +\n mono\/metadata\/verify.c           | 15 +++++++++++++++\n 3 files changed, 19 insertions(+)\n\n","diff_code":"diff --git a\/mono\/metadata\/reflection.c b\/mono\/metadata\/reflection.c\nindex 3ba44ea8399a..f7905f651528 100644\n--- a\/mono\/metadata\/reflection.c\n+++ b\/mono\/metadata\/reflection.c\n@@ -10176,6 +10176,9 @@ mono_reflection_bind_generic_method_parameters (MonoReflectionMethod *rmethod, M\n \t\tmono_g_hash_table_insert (image->generic_def_objects, imethod, rmethod);\n \t\tmono_loader_unlock ();\n \t}\n+\n+\tif (!mono_verifier_is_method_valid_generic_instantiation (inflated))\n+\t\tmono_raise_exception (mono_get_exception_argument (\"typeArguments\", \"Invalid generic arguments\"));\n \t\n \treturn mono_method_get_object (mono_object_domain (rmethod), inflated, NULL);\n }\ndiff --git a\/mono\/metadata\/verify-internals.h b\/mono\/metadata\/verify-internals.h\nindex f73b01044d56..a95cc5d2d799 100644\n--- a\/mono\/metadata\/verify-internals.h\n+++ b\/mono\/metadata\/verify-internals.h\n@@ -22,6 +22,7 @@ gboolean mono_verifier_is_enabled_for_class (MonoClass *klass) MONO_INTERNAL;\n gboolean mono_verifier_is_method_full_trust (MonoMethod *method) MONO_INTERNAL;\n gboolean mono_verifier_is_class_full_trust (MonoClass *klass) MONO_INTERNAL;\n gboolean mono_verifier_class_is_valid_generic_instantiation (MonoClass *class) MONO_INTERNAL;\n+gboolean mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method) MONO_INTERNAL;\n \n gboolean mono_verifier_verify_class (MonoClass *klass) MONO_INTERNAL;\n \ndiff --git a\/mono\/metadata\/verify.c b\/mono\/metadata\/verify.c\nindex b678ed71722e..2b393a99a93e 100644\n--- a\/mono\/metadata\/verify.c\n+++ b\/mono\/metadata\/verify.c\n@@ -6533,6 +6533,14 @@ mono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n \treturn mono_class_is_valid_generic_instantiation (NULL, class);\n }\n \n+gboolean\n+mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method)\n+{\n+\tif (!method->is_inflated)\n+\t\treturn TRUE;\n+\treturn mono_method_is_valid_generic_instantiation (NULL, method);\n+}\n+\n #else\n \n gboolean\n@@ -6611,5 +6619,12 @@ mono_verifier_class_is_valid_generic_instantiation (MonoClass *class)\n \treturn TRUE;\n }\n \n+gboolean\n+mono_verifier_is_method_valid_generic_instantiation (MonoMethod *method)\n+{\n+\treturn TRUE;\n+}\n+\n+\n \n #endif\n","owner":"mono","repo":"mono","source":"cve"},{"CVE_ID":"CVE-2011-4914","CWE_ID":"20","category":"security","commit_id":"e0bccd315db0c2f919e7fcf9cb60db21d9986f52","commit_message":"From e0bccd315db0c2f919e7fcf9cb60db21d9986f52 Mon Sep 17 00:00:00 2001\nFrom: Ben Hutchings <ben@decadent.org.uk>\nDate: Sun, 20 Mar 2011 06:48:05 +0000\nSubject: [PATCH] rose: Add length checks to CALL_REQUEST parsing\n\nDefine some constant offsets for CALL_REQUEST based on the description\nat <http:\/\/www.techfest.com\/networking\/wan\/x25plp.htm> and the\ndefinition of ROSE as using 10-digit (5-byte) addresses.  Use them\nconsistently.  Validate all implicit and explicit facilities lengths.\nValidate the address length byte rather than either trusting or\nassuming its value.\n\nSigned-off-by: Ben Hutchings <ben@decadent.org.uk>\nSigned-off-by: David S. Miller <davem@davemloft.net>\n---\n include\/net\/rose.h       |  8 +++-\n net\/rose\/af_rose.c       |  8 ++--\n net\/rose\/rose_loopback.c | 13 +++++-\n net\/rose\/rose_route.c    | 20 +++++----\n net\/rose\/rose_subr.c     | 91 +++++++++++++++++++++++++---------------\n 5 files changed, 93 insertions(+), 47 deletions(-)\n\n","diff_code":"diff --git a\/include\/net\/rose.h b\/include\/net\/rose.h\nindex 5ba9f02731eb3..555dd198aab75 100644\n--- a\/include\/net\/rose.h\n+++ b\/include\/net\/rose.h\n@@ -14,6 +14,12 @@\n \n #define\tROSE_MIN_LEN\t\t\t3\n \n+#define\tROSE_CALL_REQ_ADDR_LEN_OFF\t3\n+#define\tROSE_CALL_REQ_ADDR_LEN_VAL\t0xAA\t\/* each address is 10 digits *\/\n+#define\tROSE_CALL_REQ_DEST_ADDR_OFF\t4\n+#define\tROSE_CALL_REQ_SRC_ADDR_OFF\t9\n+#define\tROSE_CALL_REQ_FACILITIES_OFF\t14\n+\n #define\tROSE_GFI\t\t\t0x10\n #define\tROSE_Q_BIT\t\t\t0x80\n #define\tROSE_D_BIT\t\t\t0x40\n@@ -214,7 +220,7 @@ extern void rose_requeue_frames(struct sock *);\n extern int  rose_validate_nr(struct sock *, unsigned short);\n extern void rose_write_internal(struct sock *, int);\n extern int  rose_decode(struct sk_buff *, int *, int *, int *, int *, int *);\n-extern int  rose_parse_facilities(unsigned char *, struct rose_facilities_struct *);\n+extern int  rose_parse_facilities(unsigned char *, unsigned int, struct rose_facilities_struct *);\n extern void rose_disconnect(struct sock *, int, int, int);\n \n \/* rose_timer.c *\/\ndiff --git a\/net\/rose\/af_rose.c b\/net\/rose\/af_rose.c\nindex 5ee0c62046a03..a80aef6e3d1fb 100644\n--- a\/net\/rose\/af_rose.c\n+++ b\/net\/rose\/af_rose.c\n@@ -978,7 +978,7 @@ int rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct ros\n \tstruct sock *make;\n \tstruct rose_sock *make_rose;\n \tstruct rose_facilities_struct facilities;\n-\tint n, len;\n+\tint n;\n \n \tskb->sk = NULL;\t\t\/* Initially we don't know who it's for *\/\n \n@@ -987,9 +987,9 @@ int rose_rx_call_request(struct sk_buff *skb, struct net_device *dev, struct ros\n \t *\/\n \tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n \n-\tlen  = (((skb->data[3] >> 4) & 0x0F) + 1) >> 1;\n-\tlen += (((skb->data[3] >> 0) & 0x0F) + 1) >> 1;\n-\tif (!rose_parse_facilities(skb->data + len + 4, &facilities)) {\n+\tif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\n+\t\t\t\t   skb->len - ROSE_CALL_REQ_FACILITIES_OFF,\n+\t\t\t\t   &facilities)) {\n \t\trose_transmit_clear_request(neigh, lci, ROSE_INVALID_FACILITY, 76);\n \t\treturn 0;\n \t}\ndiff --git a\/net\/rose\/rose_loopback.c b\/net\/rose\/rose_loopback.c\nindex ae4a9d99aec70..344456206b70b 100644\n--- a\/net\/rose\/rose_loopback.c\n+++ b\/net\/rose\/rose_loopback.c\n@@ -73,9 +73,20 @@ static void rose_loopback_timer(unsigned long param)\n \tunsigned int lci_i, lci_o;\n \n \twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n+\t\tif (skb->len < ROSE_MIN_LEN) {\n+\t\t\tkfree_skb(skb);\n+\t\t\tcontinue;\n+\t\t}\n \t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n \t\tframetype = skb->data[2];\n-\t\tdest      = (rose_address *)(skb->data + 4);\n+\t\tif (frametype == ROSE_CALL_REQUEST &&\n+\t\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n+\t\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n+\t\t     ROSE_CALL_REQ_ADDR_LEN_VAL)) {\n+\t\t\tkfree_skb(skb);\n+\t\t\tcontinue;\n+\t\t}\n+\t\tdest      = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n \t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n \n \t\tskb_reset_transport_header(skb);\ndiff --git a\/net\/rose\/rose_route.c b\/net\/rose\/rose_route.c\nindex 88a77e90e7e86..08dcd2f29cdc7 100644\n--- a\/net\/rose\/rose_route.c\n+++ b\/net\/rose\/rose_route.c\n@@ -861,7 +861,7 @@ int rose_route_frame(struct sk_buff *skb, ax25_cb *ax25)\n \tunsigned int lci, new_lci;\n \tunsigned char cause, diagnostic;\n \tstruct net_device *dev;\n-\tint len, res = 0;\n+\tint res = 0;\n \tchar buf[11];\n \n #if 0\n@@ -869,10 +869,17 @@ int rose_route_frame(struct sk_buff *skb, ax25_cb *ax25)\n \t\treturn res;\n #endif\n \n+\tif (skb->len < ROSE_MIN_LEN)\n+\t\treturn res;\n \tframetype = skb->data[2];\n \tlci = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n-\tsrc_addr  = (rose_address *)(skb->data + 9);\n-\tdest_addr = (rose_address *)(skb->data + 4);\n+\tif (frametype == ROSE_CALL_REQUEST &&\n+\t    (skb->len <= ROSE_CALL_REQ_FACILITIES_OFF ||\n+\t     skb->data[ROSE_CALL_REQ_ADDR_LEN_OFF] !=\n+\t     ROSE_CALL_REQ_ADDR_LEN_VAL))\n+\t\treturn res;\n+\tsrc_addr  = (rose_address *)(skb->data + ROSE_CALL_REQ_SRC_ADDR_OFF);\n+\tdest_addr = (rose_address *)(skb->data + ROSE_CALL_REQ_DEST_ADDR_OFF);\n \n \tspin_lock_bh(&rose_neigh_list_lock);\n \tspin_lock_bh(&rose_route_list_lock);\n@@ -1010,12 +1017,11 @@ int rose_route_frame(struct sk_buff *skb, ax25_cb *ax25)\n \t\tgoto out;\n \t}\n \n-\tlen  = (((skb->data[3] >> 4) & 0x0F) + 1) >> 1;\n-\tlen += (((skb->data[3] >> 0) & 0x0F) + 1) >> 1;\n-\n \tmemset(&facilities, 0x00, sizeof(struct rose_facilities_struct));\n \n-\tif (!rose_parse_facilities(skb->data + len + 4, &facilities)) {\n+\tif (!rose_parse_facilities(skb->data + ROSE_CALL_REQ_FACILITIES_OFF,\n+\t\t\t\t   skb->len - ROSE_CALL_REQ_FACILITIES_OFF,\n+\t\t\t\t   &facilities)) {\n \t\trose_transmit_clear_request(rose_neigh, lci, ROSE_INVALID_FACILITY, 76);\n \t\tgoto out;\n \t}\ndiff --git a\/net\/rose\/rose_subr.c b\/net\/rose\/rose_subr.c\nindex 174d51c9ce377..f6c71caa94b9d 100644\n--- a\/net\/rose\/rose_subr.c\n+++ b\/net\/rose\/rose_subr.c\n@@ -142,7 +142,7 @@ void rose_write_internal(struct sock *sk, int frametype)\n \t\t*dptr++ = ROSE_GFI | lci1;\n \t\t*dptr++ = lci2;\n \t\t*dptr++ = frametype;\n-\t\t*dptr++ = 0xAA;\n+\t\t*dptr++ = ROSE_CALL_REQ_ADDR_LEN_VAL;\n \t\tmemcpy(dptr, &rose->dest_addr,  ROSE_ADDR_LEN);\n \t\tdptr   += ROSE_ADDR_LEN;\n \t\tmemcpy(dptr, &rose->source_addr, ROSE_ADDR_LEN);\n@@ -246,12 +246,16 @@ static int rose_parse_national(unsigned char *p, struct rose_facilities_struct *\n \tdo {\n \t\tswitch (*p & 0xC0) {\n \t\tcase 0x00:\n+\t\t\tif (len < 2)\n+\t\t\t\treturn -1;\n \t\t\tp   += 2;\n \t\t\tn   += 2;\n \t\t\tlen -= 2;\n \t\t\tbreak;\n \n \t\tcase 0x40:\n+\t\t\tif (len < 3)\n+\t\t\t\treturn -1;\n \t\t\tif (*p == FAC_NATIONAL_RAND)\n \t\t\t\tfacilities->rand = ((p[1] << 8) & 0xFF00) + ((p[2] << 0) & 0x00FF);\n \t\t\tp   += 3;\n@@ -260,32 +264,48 @@ static int rose_parse_national(unsigned char *p, struct rose_facilities_struct *\n \t\t\tbreak;\n \n \t\tcase 0x80:\n+\t\t\tif (len < 4)\n+\t\t\t\treturn -1;\n \t\t\tp   += 4;\n \t\t\tn   += 4;\n \t\t\tlen -= 4;\n \t\t\tbreak;\n \n \t\tcase 0xC0:\n+\t\t\tif (len < 2)\n+\t\t\t\treturn -1;\n \t\t\tl = p[1];\n+\t\t\tif (len < 2 + l)\n+\t\t\t\treturn -1;\n \t\t\tif (*p == FAC_NATIONAL_DEST_DIGI) {\n \t\t\t\tif (!fac_national_digis_received) {\n+\t\t\t\t\tif (l < AX25_ADDR_LEN)\n+\t\t\t\t\t\treturn -1;\n \t\t\t\t\tmemcpy(&facilities->source_digis[0], p + 2, AX25_ADDR_LEN);\n \t\t\t\t\tfacilities->source_ndigis = 1;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (*p == FAC_NATIONAL_SRC_DIGI) {\n \t\t\t\tif (!fac_national_digis_received) {\n+\t\t\t\t\tif (l < AX25_ADDR_LEN)\n+\t\t\t\t\t\treturn -1;\n \t\t\t\t\tmemcpy(&facilities->dest_digis[0], p + 2, AX25_ADDR_LEN);\n \t\t\t\t\tfacilities->dest_ndigis = 1;\n \t\t\t\t}\n \t\t\t}\n \t\t\telse if (*p == FAC_NATIONAL_FAIL_CALL) {\n+\t\t\t\tif (l < AX25_ADDR_LEN)\n+\t\t\t\t\treturn -1;\n \t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n \t\t\t}\n \t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n+\t\t\t\tif (l < 1 + ROSE_ADDR_LEN)\n+\t\t\t\t\treturn -1;\n \t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n \t\t\t}\n \t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n+\t\t\t\tif (l % AX25_ADDR_LEN)\n+\t\t\t\t\treturn -1;\n \t\t\t\tfac_national_digis_received = 1;\n \t\t\t\tfacilities->source_ndigis = 0;\n \t\t\t\tfacilities->dest_ndigis   = 0;\n@@ -319,24 +339,32 @@ static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *fac\n \tdo {\n \t\tswitch (*p & 0xC0) {\n \t\tcase 0x00:\n+\t\t\tif (len < 2)\n+\t\t\t\treturn -1;\n \t\t\tp   += 2;\n \t\t\tn   += 2;\n \t\t\tlen -= 2;\n \t\t\tbreak;\n \n \t\tcase 0x40:\n+\t\t\tif (len < 3)\n+\t\t\t\treturn -1;\n \t\t\tp   += 3;\n \t\t\tn   += 3;\n \t\t\tlen -= 3;\n \t\t\tbreak;\n \n \t\tcase 0x80:\n+\t\t\tif (len < 4)\n+\t\t\t\treturn -1;\n \t\t\tp   += 4;\n \t\t\tn   += 4;\n \t\t\tlen -= 4;\n \t\t\tbreak;\n \n \t\tcase 0xC0:\n+\t\t\tif (len < 2)\n+\t\t\t\treturn -1;\n \t\t\tl = p[1];\n \n \t\t\t\/* Prevent overflows*\/\n@@ -365,49 +393,44 @@ static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *fac\n \treturn n;\n }\n \n-int rose_parse_facilities(unsigned char *p,\n+int rose_parse_facilities(unsigned char *p, unsigned packet_len,\n \tstruct rose_facilities_struct *facilities)\n {\n \tint facilities_len, len;\n \n \tfacilities_len = *p++;\n \n-\tif (facilities_len == 0)\n+\tif (facilities_len == 0 || (unsigned)facilities_len > packet_len)\n \t\treturn 0;\n \n-\twhile (facilities_len > 0) {\n-\t\tif (*p == 0x00) {\n-\t\t\tfacilities_len--;\n-\t\t\tp++;\n-\n-\t\t\tswitch (*p) {\n-\t\t\tcase FAC_NATIONAL:\t\t\/* National *\/\n-\t\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n-\t\t\t\tif (len < 0)\n-\t\t\t\t\treturn 0;\n-\t\t\t\tfacilities_len -= len + 1;\n-\t\t\t\tp += len + 1;\n-\t\t\t\tbreak;\n-\n-\t\t\tcase FAC_CCITT:\t\t\/* CCITT *\/\n-\t\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n-\t\t\t\tif (len < 0)\n-\t\t\t\t\treturn 0;\n-\t\t\t\tfacilities_len -= len + 1;\n-\t\t\t\tp += len + 1;\n-\t\t\t\tbreak;\n-\n-\t\t\tdefault:\n-\t\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n-\t\t\t\tfacilities_len--;\n-\t\t\t\tp++;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t} else\n-\t\t\tbreak;\t\/* Error in facilities format *\/\n+\twhile (facilities_len >= 3 && *p == 0x00) {\n+\t\tfacilities_len--;\n+\t\tp++;\n+\n+\t\tswitch (*p) {\n+\t\tcase FAC_NATIONAL:\t\t\/* National *\/\n+\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n+\t\t\tbreak;\n+\n+\t\tcase FAC_CCITT:\t\t\/* CCITT *\/\n+\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n+\t\t\tlen = 1;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tif (len < 0)\n+\t\t\treturn 0;\n+\t\tif (WARN_ON(len >= facilities_len))\n+\t\t\treturn 0;\n+\t\tfacilities_len -= len + 1;\n+\t\tp += len + 1;\n \t}\n \n-\treturn 1;\n+\treturn facilities_len == 0;\n }\n \n static int rose_create_facilities(unsigned char *buffer, struct rose_sock *rose)\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2013-1798","CWE_ID":"20","category":"security","commit_id":"a2c118bfab8bc6b8bb213abfc35201e441693d55","commit_message":"From a2c118bfab8bc6b8bb213abfc35201e441693d55 Mon Sep 17 00:00:00 2001\nFrom: Andy Honig <ahonig@google.com>\nDate: Wed, 20 Feb 2013 14:49:16 -0800\nSubject: [PATCH] KVM: Fix bounds checking in ioapic indirect register reads\n (CVE-2013-1798)\n\nIf the guest specifies a IOAPIC_REG_SELECT with an invalid value and follows\nthat with a read of the IOAPIC_REG_WINDOW KVM does not properly validate\nthat request.  ioapic_read_indirect contains an\nASSERT(redir_index < IOAPIC_NUM_PINS), but the ASSERT has no effect in\nnon-debug builds.  In recent kernels this allows a guest to cause a kernel\noops by reading invalid memory.  In older kernels (pre-3.3) this allows a\nguest to read from large ranges of host memory.\n\nTested: tested against apic unit tests.\n\nSigned-off-by: Andrew Honig <ahonig@google.com>\nSigned-off-by: Marcelo Tosatti <mtosatti@redhat.com>\n---\n virt\/kvm\/ioapic.c | 7 +++++--\n 1 file changed, 5 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/virt\/kvm\/ioapic.c b\/virt\/kvm\/ioapic.c\nindex ce82b94019584..5ba005c00e2f7 100644\n--- a\/virt\/kvm\/ioapic.c\n+++ b\/virt\/kvm\/ioapic.c\n@@ -74,9 +74,12 @@ static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n \t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n \t\t\tu64 redir_content;\n \n-\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n+\t\t\tif (redir_index < IOAPIC_NUM_PINS)\n+\t\t\t\tredir_content =\n+\t\t\t\t\tioapic->redirtbl[redir_index].bits;\n+\t\t\telse\n+\t\t\t\tredir_content = ~0ULL;\n \n-\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n \t\t\tresult = (ioapic->ioregsel & 0x1) ?\n \t\t\t    (redir_content >> 32) & 0xffffffff :\n \t\t\t    redir_content & 0xffffffff;\n","owner":"stoth68000","repo":"media-tree","source":"cve"},{"CVE_ID":"CVE-2019-3565","CWE_ID":"20","category":"security","commit_id":"01686e15ec77ccb4d49a77d5bce3a01601e54d64","commit_message":"From 01686e15ec77ccb4d49a77d5bce3a01601e54d64 Mon Sep 17 00:00:00 2001\nFrom: David Goldblatt <davidgoldblatt@fb.com>\nDate: Thu, 2 May 2019 18:52:10 -0700\nSubject: [PATCH] Throw on skipping an invalid type.\n\nSummary:\nCertain values (e.g.) T_STOP should not appear as a skip type. Allowing them to\ncan cause thrift to loop unboundedly.\n\nReviewed By: spalamarchuk\n\nDifferential Revision: D15102451\n\nfbshipit-source-id: c08d52f44f37e9c212d3480233ac217105586c9f\n---\n thrift\/lib\/cpp\/protocol\/TProtocol.h | 5 +++--\n 1 file changed, 3 insertions(+), 2 deletions(-)\n\n","diff_code":"diff --git a\/thrift\/lib\/cpp\/protocol\/TProtocol.h b\/thrift\/lib\/cpp\/protocol\/TProtocol.h\nindex 9c5d91300..273ff10be 100644\n--- a\/thrift\/lib\/cpp\/protocol\/TProtocol.h\n+++ b\/thrift\/lib\/cpp\/protocol\/TProtocol.h\n@@ -165,8 +165,9 @@ uint32_t skip(Protocol_& prot, TType arg_type) {\n       result += prot.readListEnd();\n       return result;\n     }\n-    default:\n-      return 0;\n+    default: {\n+      TProtocolException::throwInvalidSkipType(arg_type);\n+    }\n   }\n }\n \n","owner":"facebook","repo":"fbthrift","source":"cve"},{"CVE_ID":"CVE-2018-8050","CWE_ID":"20","category":"security","commit_id":"435a2ca802358a3debb6d164d2c33049131df81c","commit_message":"From 435a2ca802358a3debb6d164d2c33049131df81c Mon Sep 17 00:00:00 2001\nFrom: Phillip Hellewell <sshock@gmail.com>\nDate: Sat, 10 Mar 2018 18:05:39 -0700\nSubject: [PATCH] Sanity check size passed to malloc...\n\nAdd sanity check before calling malloc in af_get_page() function to\navoid undefined behavior (e.g., seg fault) when dealing with a corrupt\nAFF image with an invalid pagesize.\n\nIssue found by Luis Rocha (luiscrocha@gmail.com).\n---\n lib\/afflib_pages.cpp | 5 +++++\n 1 file changed, 5 insertions(+)\n\n","diff_code":"diff --git a\/lib\/afflib_pages.cpp b\/lib\/afflib_pages.cpp\nindex 2569c2a..f8cf775 100644\n--- a\/lib\/afflib_pages.cpp\n+++ b\/lib\/afflib_pages.cpp\n@@ -219,6 +219,11 @@ int af_get_page(AFFILE *af,int64_t pagenum,unsigned char *data,size_t *bytes)\n \t    return -3;\t\t\t\/\/ read error\n \t}\n \n+\t\/* Sanity check to avoid undefined behaviour when calling malloc below with pagesize from a corrupt AFF image. *\/\n+\tif(af->image_pagesize <= 0 || af->image_pagesize > 16*1024*1024)\n+\t    return -1;\n+\n+\n \t\/* Now uncompress directly into the buffer provided by the caller, unless the caller didn't\n \t * provide a buffer. If that happens, allocate our own...\n \t *\/\n","owner":"sshock","repo":"AFFLIBv3","source":"cve"},{"CVE_ID":"CVE-2018-16276","CWE_ID":"20","category":"security","commit_id":"f1e255d60ae66a9f672ff9a207ee6cd8e33d2679","commit_message":"From f1e255d60ae66a9f672ff9a207ee6cd8e33d2679 Mon Sep 17 00:00:00 2001\nFrom: Jann Horn <jannh@google.com>\nDate: Fri, 6 Jul 2018 17:12:56 +0200\nSubject: USB: yurex: fix out-of-bounds uaccess in read handler\n\nIn general, accessing userspace memory beyond the length of the supplied\nbuffer in VFS read\/write handlers can lead to both kernel memory corruption\n(via kernel_read()\/kernel_write(), which can e.g. be triggered via\nsys_splice()) and privilege escalation inside userspace.\n\nFix it by using simple_read_from_buffer() instead of custom logic.\n\nFixes: 6bc235a2e24a (\"USB: add driver for Meywa-Denki & Kayac YUREX\")\nSigned-off-by: Jann Horn <jannh@google.com>\nCc: stable <stable@vger.kernel.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n drivers\/usb\/misc\/yurex.c | 23 ++++++-----------------\n 1 file changed, 6 insertions(+), 17 deletions(-)\n\n","diff_code":"diff --git a\/drivers\/usb\/misc\/yurex.c b\/drivers\/usb\/misc\/yurex.c\nindex 8abb6cbbd98a..3be40eaa1ac9 100644\n--- a\/drivers\/usb\/misc\/yurex.c\n+++ b\/drivers\/usb\/misc\/yurex.c\n@@ -396,8 +396,7 @@ static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n \t\t\t  loff_t *ppos)\n {\n \tstruct usb_yurex *dev;\n-\tint retval = 0;\n-\tint bytes_read = 0;\n+\tint len = 0;\n \tchar in_buffer[20];\n \tunsigned long flags;\n \n@@ -405,26 +404,16 @@ static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n \n \tmutex_lock(&dev->io_mutex);\n \tif (!dev->interface) {\t\t\/* already disconnected *\/\n-\t\tretval = -ENODEV;\n-\t\tgoto exit;\n+\t\tmutex_unlock(&dev->io_mutex);\n+\t\treturn -ENODEV;\n \t}\n \n \tspin_lock_irqsave(&dev->lock, flags);\n-\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n+\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n \tspin_unlock_irqrestore(&dev->lock, flags);\n-\n-\tif (*ppos < bytes_read) {\n-\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n-\t\t\tretval = -EFAULT;\n-\t\telse {\n-\t\t\tretval = bytes_read - *ppos;\n-\t\t\t*ppos += bytes_read;\n-\t\t}\n-\t}\n-\n-exit:\n \tmutex_unlock(&dev->io_mutex);\n-\treturn retval;\n+\n+\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n }\n \n static ssize_t yurex_write(struct file *file, const char __user *user_buffer,\n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"torvalds","repo":"linux","source":"cve"},{"CVE_ID":"CVE-2016-7949","CWE_ID":"20","category":"security","commit_id":"9362c7ddd1af3b168953d0737877bc52d79c94f4","commit_message":"From 9362c7ddd1af3b168953d0737877bc52d79c94f4 Mon Sep 17 00:00:00 2001\nFrom: Tobias Stoeckmann <tobias@stoeckmann.org>\nDate: Sun, 25 Sep 2016 21:43:09 +0200\nSubject: Validate lengths while parsing server data.\n\nIndividual lengths inside received server data can overflow\nthe previously reserved memory.\n\nIt is therefore important to validate every single length\nfield to not overflow the previously agreed sum of all invidual\nlength fields.\n\nv2: consume remaining bytes in the reply buffer on error.\n\nSigned-off-by: Tobias Stoeckmann <tobias@stoeckmann.org>\nReviewed-by: Matthieu Herrb@laas.fr\n---\n src\/Xrender.c | 18 ++++++++++++++++++\n 1 file changed, 18 insertions(+)\n\n","diff_code":"diff --git a\/src\/Xrender.c b\/src\/Xrender.c\nindex 3102eb2..71cf3e6 100644\n--- a\/src\/Xrender.c\n+++ b\/src\/Xrender.c\n@@ -533,12 +533,30 @@ XRenderQueryFormats (Display *dpy)\n \tscreen->fallback = _XRenderFindFormat (xri, xScreen->fallback);\n \tscreen->subpixel = SubPixelUnknown;\n \txDepth = (xPictDepth *) (xScreen + 1);\n+\tif (screen->ndepths > rep.numDepths) {\n+\t    Xfree (xri);\n+\t    Xfree (xData);\n+\t    _XEatDataWords (dpy, rep.length);\n+\t    UnlockDisplay (dpy);\n+\t    SyncHandle ();\n+\t    return 0;\n+\t}\n+\trep.numDepths -= screen->ndepths;\n \tfor (nd = 0; nd < screen->ndepths; nd++)\n \t{\n \t    depth->depth = xDepth->depth;\n \t    depth->nvisuals = xDepth->nPictVisuals;\n \t    depth->visuals = visual;\n \t    xVisual = (xPictVisual *) (xDepth + 1);\n+\t    if (depth->nvisuals > rep.numVisuals) {\n+\t\tXfree (xri);\n+\t\tXfree (xData);\n+\t\t_XEatDataWords (dpy, rep.length);\n+\t\tUnlockDisplay (dpy);\n+\t\tSyncHandle ();\n+\t\treturn 0;\n+\t    }\n+\t    rep.numVisuals -= depth->nvisuals;\n \t    for (nv = 0; nv < depth->nvisuals; nv++)\n \t    {\n \t\tvisual->visual = _XRenderFindVisual (dpy, xVisual->visual);\n-- \ncgit v1.1\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2013-3672","CWE_ID":"20","category":"security","commit_id":"8d3c99e825317b7efda5fd12e69896b47c700303","commit_message":"From 8d3c99e825317b7efda5fd12e69896b47c700303 Mon Sep 17 00:00:00 2001\nFrom: Michael Niedermayer <michaelni@gmx.at>\nDate: Thu, 2 May 2013 21:52:08 +0200\nSubject: [PATCH] mmvideo\/mm_decode_inter: check horizontal coordinate too\n\nFixes out of array accesses\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n---\n libavcodec\/mmvideo.c | 2 ++\n 1 file changed, 2 insertions(+)\n\n","diff_code":"diff --git a\/libavcodec\/mmvideo.c b\/libavcodec\/mmvideo.c\nindex bf47f6527c..36dc9f9d8a 100644\n--- a\/libavcodec\/mmvideo.c\n+++ b\/libavcodec\/mmvideo.c\n@@ -151,6 +151,8 @@ static int mm_decode_inter(MmContext * s, int half_horiz, int half_vert)\n             int replace_array = bytestream2_get_byte(&s->gb);\n             for(j=0; j<8; j++) {\n                 int replace = (replace_array >> (7-j)) & 1;\n+                if (x + half_horiz >= s->avctx->width)\n+                    return AVERROR_INVALIDDATA;\n                 if (replace) {\n                     int color = bytestream2_get_byte(&data_ptr);\n                     s->frame.data[0][y*s->frame.linesize[0] + x] = color;\n-- \n2.11.0\n\n","owner":"NA","repo":"NA","source":"cve"},{"CVE_ID":"CVE-2018-18281","CWE_ID":"20","category":"security","commit_id":"eb66ae030829605d61fbef1909ce310e29f78821","commit_message":"From eb66ae030829605d61fbef1909ce310e29f78821 Mon Sep 17 00:00:00 2001\nFrom: Linus Torvalds <torvalds@linux-foundation.org>\nDate: Fri, 12 Oct 2018 15:22:59 -0700\nSubject: mremap: properly flush TLB before releasing the page\n\nJann Horn points out that our TLB flushing was subtly wrong for the\nmremap() case.  What makes mremap() special is that we don't follow the\nusual \"add page to list of pages to be freed, then flush tlb, and then\nfree pages\".  No, mremap() obviously just _moves_ the page from one page\ntable location to another.\n\nThat matters, because mremap() thus doesn't directly control the\nlifetime of the moved page with a freelist: instead, the lifetime of the\npage is controlled by the page table locking, that serializes access to\nthe entry.\n\nAs a result, we need to flush the TLB not just before releasing the lock\nfor the source location (to avoid any concurrent accesses to the entry),\nbut also before we release the destination page table lock (to avoid the\nTLB being flushed after somebody else has already done something to that\npage).\n\nThis also makes the whole \"need_flush\" logic unnecessary, since we now\nalways end up flushing the TLB for every valid entry.\n\nReported-and-tested-by: Jann Horn <jannh@google.com>\nAcked-by: Will Deacon <will.deacon@arm.com>\nTested-by: Ingo Molnar <mingo@kernel.org>\nAcked-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\n---\n include\/linux\/huge_mm.h |  2 +-\n mm\/huge_memory.c        | 10 ++++------\n mm\/mremap.c             | 30 +++++++++++++-----------------\n 3 files changed, 18 insertions(+), 24 deletions(-)\n\n","diff_code":"diff --git a\/include\/linux\/huge_mm.h b\/include\/linux\/huge_mm.h\nindex 99c19b06d9a4..fdcb45999b26 100644\n--- a\/include\/linux\/huge_mm.h\n+++ b\/include\/linux\/huge_mm.h\n@@ -43,7 +43,7 @@ extern int mincore_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n \t\t\tunsigned char *vec);\n extern bool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr,\n \t\t\t unsigned long new_addr, unsigned long old_end,\n-\t\t\t pmd_t *old_pmd, pmd_t *new_pmd, bool *need_flush);\n+\t\t\t pmd_t *old_pmd, pmd_t *new_pmd);\n extern int change_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n \t\t\tunsigned long addr, pgprot_t newprot,\n \t\t\tint prot_numa);\ndiff --git a\/mm\/huge_memory.c b\/mm\/huge_memory.c\nindex 58269f8ba7c4..deed97fba979 100644\n--- a\/mm\/huge_memory.c\n+++ b\/mm\/huge_memory.c\n@@ -1780,7 +1780,7 @@ static pmd_t move_soft_dirty_pmd(pmd_t pmd)\n \n bool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr,\n \t\t  unsigned long new_addr, unsigned long old_end,\n-\t\t  pmd_t *old_pmd, pmd_t *new_pmd, bool *need_flush)\n+\t\t  pmd_t *old_pmd, pmd_t *new_pmd)\n {\n \tspinlock_t *old_ptl, *new_ptl;\n \tpmd_t pmd;\n@@ -1811,7 +1811,7 @@ bool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr,\n \t\tif (new_ptl != old_ptl)\n \t\t\tspin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n \t\tpmd = pmdp_huge_get_and_clear(mm, old_addr, old_pmd);\n-\t\tif (pmd_present(pmd) && pmd_dirty(pmd))\n+\t\tif (pmd_present(pmd))\n \t\t\tforce_flush = true;\n \t\tVM_BUG_ON(!pmd_none(*new_pmd));\n \n@@ -1822,12 +1822,10 @@ bool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr,\n \t\t}\n \t\tpmd = move_soft_dirty_pmd(pmd);\n \t\tset_pmd_at(mm, new_addr, new_pmd, pmd);\n-\t\tif (new_ptl != old_ptl)\n-\t\t\tspin_unlock(new_ptl);\n \t\tif (force_flush)\n \t\t\tflush_tlb_range(vma, old_addr, old_addr + PMD_SIZE);\n-\t\telse\n-\t\t\t*need_flush = true;\n+\t\tif (new_ptl != old_ptl)\n+\t\t\tspin_unlock(new_ptl);\n \t\tspin_unlock(old_ptl);\n \t\treturn true;\n \t}\ndiff --git a\/mm\/mremap.c b\/mm\/mremap.c\nindex 5c2e18505f75..a9617e72e6b7 100644\n--- a\/mm\/mremap.c\n+++ b\/mm\/mremap.c\n@@ -115,7 +115,7 @@ static pte_t move_soft_dirty_pte(pte_t pte)\n static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,\n \t\tunsigned long old_addr, unsigned long old_end,\n \t\tstruct vm_area_struct *new_vma, pmd_t *new_pmd,\n-\t\tunsigned long new_addr, bool need_rmap_locks, bool *need_flush)\n+\t\tunsigned long new_addr, bool need_rmap_locks)\n {\n \tstruct mm_struct *mm = vma->vm_mm;\n \tpte_t *old_pte, *new_pte, pte;\n@@ -163,15 +163,17 @@ static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,\n \n \t\tpte = ptep_get_and_clear(mm, old_addr, old_pte);\n \t\t\/*\n-\t\t * If we are remapping a dirty PTE, make sure\n+\t\t * If we are remapping a valid PTE, make sure\n \t\t * to flush TLB before we drop the PTL for the\n-\t\t * old PTE or we may race with page_mkclean().\n+\t\t * PTE.\n \t\t *\n-\t\t * This check has to be done after we removed the\n-\t\t * old PTE from page tables or another thread may\n-\t\t * dirty it after the check and before the removal.\n+\t\t * NOTE! Both old and new PTL matter: the old one\n+\t\t * for racing with page_mkclean(), the new one to\n+\t\t * make sure the physical page stays valid until\n+\t\t * the TLB entry for the old mapping has been\n+\t\t * flushed.\n \t\t *\/\n-\t\tif (pte_present(pte) && pte_dirty(pte))\n+\t\tif (pte_present(pte))\n \t\t\tforce_flush = true;\n \t\tpte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr);\n \t\tpte = move_soft_dirty_pte(pte);\n@@ -179,13 +181,11 @@ static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,\n \t}\n \n \tarch_leave_lazy_mmu_mode();\n+\tif (force_flush)\n+\t\tflush_tlb_range(vma, old_end - len, old_end);\n \tif (new_ptl != old_ptl)\n \t\tspin_unlock(new_ptl);\n \tpte_unmap(new_pte - 1);\n-\tif (force_flush)\n-\t\tflush_tlb_range(vma, old_end - len, old_end);\n-\telse\n-\t\t*need_flush = true;\n \tpte_unmap_unlock(old_pte - 1, old_ptl);\n \tif (need_rmap_locks)\n \t\tdrop_rmap_locks(vma);\n@@ -198,7 +198,6 @@ unsigned long move_page_tables(struct vm_area_struct *vma,\n {\n \tunsigned long extent, next, old_end;\n \tpmd_t *old_pmd, *new_pmd;\n-\tbool need_flush = false;\n \tunsigned long mmun_start;\t\/* For mmu_notifiers *\/\n \tunsigned long mmun_end;\t\t\/* For mmu_notifiers *\/\n \n@@ -229,8 +228,7 @@ unsigned long move_page_tables(struct vm_area_struct *vma,\n \t\t\t\tif (need_rmap_locks)\n \t\t\t\t\ttake_rmap_locks(vma);\n \t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n-\t\t\t\t\t\t    old_end, old_pmd, new_pmd,\n-\t\t\t\t\t\t    &need_flush);\n+\t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n \t\t\t\tif (need_rmap_locks)\n \t\t\t\t\tdrop_rmap_locks(vma);\n \t\t\t\tif (moved)\n@@ -246,10 +244,8 @@ unsigned long move_page_tables(struct vm_area_struct *vma,\n \t\tif (extent > next - new_addr)\n \t\t\textent = next - new_addr;\n \t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n-\t\t\t  new_pmd, new_addr, need_rmap_locks, &need_flush);\n+\t\t\t  new_pmd, new_addr, need_rmap_locks);\n \t}\n-\tif (need_flush)\n-\t\tflush_tlb_range(vma, old_end-len, old_addr);\n \n \tmmu_notifier_invalidate_range_end(vma->vm_mm, mmun_start, mmun_end);\n \n-- \ncgit 1.2-0.3.lf.el7\n\n","owner":"NA","repo":"NA","source":"cve"}]